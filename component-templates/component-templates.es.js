var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { v4 } from "uuid";
import * as React$6 from "react";
import React__default, { useContext, useState, useEffect, createContext, forwardRef, createElement, useImperativeHandle, Children, useRef, useReducer, useCallback, useMemo, Component as Component$7, useLayoutEffect, Fragment as Fragment$2, isValidElement, cloneElement as cloneElement$2 } from "react";
import { useNavigate, useLocation, matchPath, useParams, BrowserRouter } from "react-router-dom";
import { generateUtilityClasses as generateUtilityClasses$1, generateUtilityClass as generateUtilityClass$1, unstable_composeClasses, Checkbox as Checkbox$1, TableRow, TableCell, Typography, Input, Button as Button$1, Dialog, DialogTitle, Grid, IconButton as IconButton$1, DialogContent, DialogContentText, Chip as Chip$1, Box, Select, MenuItem as MenuItem$1, Pagination, TextField as TextField$2, Table, TableBody, FormControl as FormControl$1, Card, CardHeader, CardContent, Divider, CardActions, TableContainer, TableHead, TableFooter, LinearProgress, Container, useTheme as useTheme$1, ListItem, ListItemButton, ListItemIcon, ListItemText, CircularProgress as CircularProgress$1, DialogActions as DialogActions$1 } from "@mui/material";
import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { Close, Add, FileDownloadRounded, ArrowBack, Search, Save, Undo, Delete, ContentCopy } from "@mui/icons-material";
import TextField$1 from "@mui/material/TextField";
import { useEventCallback as useEventCallback$1, ownerWindow, unstable_useEnhancedEffect, useForkRef, createSvgIcon, unstable_useId, ownerDocument, capitalize, debounce as debounce$4, useControlled } from "@mui/material/utils";
import Autocomplete, { createFilterOptions } from "@mui/material/Autocomplete";
import Chip from "@mui/material/Chip";
import { createRequest, useClient } from "urql";
import Modal from "@mui/material/Modal";
import ReactDOM from "react-dom";
import { styled, lighten, alpha, darken, useThemeProps, useTheme, ThemeProvider as ThemeProvider$1 } from "@mui/material/styles";
import InputBase from "@mui/material/InputBase";
import MenuItem from "@mui/material/MenuItem";
import IconButton from "@mui/material/IconButton";
import MenuList from "@mui/material/MenuList";
import ClickAwayListener from "@mui/material/ClickAwayListener";
import Grow from "@mui/material/Grow";
import Paper from "@mui/material/Paper";
import Popper from "@mui/material/Popper";
import Checkbox from "@mui/material/Checkbox";
import FormControl from "@mui/material/FormControl";
import MUISelect from "@mui/material/Select";
import MUISwitch, { switchClasses } from "@mui/material/Switch";
import Button from "@mui/material/Button";
import MUITooltip from "@mui/material/Tooltip";
import CircularProgress from "@mui/material/CircularProgress";
import TablePagination$1, { tablePaginationClasses } from "@mui/material/TablePagination";
import TrapFocus from "@mui/material/Unstable_TrapFocus";
import InputLabel from "@mui/material/InputLabel";
import FormControlLabel from "@mui/material/FormControlLabel";
import Badge from "@mui/material/Badge";
import NoSsr from "@mui/material/NoSsr";
import useMediaQuery from "@mui/material/useMediaQuery";
import Typography$1 from "@mui/material/Typography";
import Grid$1 from "@mui/material/Grid";
import Tab from "@mui/material/Tab";
import Tabs, { tabsClasses } from "@mui/material/Tabs";
import DialogActions from "@mui/material/DialogActions";
import InputAdornment from "@mui/material/InputAdornment";
import Fade from "@mui/material/Fade";
import ButtonBase from "@mui/material/ButtonBase";
import DialogContent$1 from "@mui/material/DialogContent";
import Dialog$1, { dialogClasses } from "@mui/material/Dialog";
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function isObjectLike$4(value) {
  return _typeof$3(value) == "object" && value !== null;
}
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match2;
  while ((match2 = lineRegexp.exec(source.body)) && match2.index < position) {
    line += 1;
    column = position + 1 - (match2.index + match2[0].length);
  }
  return {
    line,
    column
  };
}
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref) {
    _ref[0];
    var line = _ref[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var GraphQLError = /* @__PURE__ */ function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
    var _nodeLocations, _nodeLocations2, _nodeLocations3;
    var _this;
    _classCallCheck(this, GraphQLError2);
    _this = _super.call(this, message);
    _this.name = "GraphQLError";
    _this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    var nodeLocations = [];
    for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {
      var _this$nodes;
      var _ref4 = _ref3[_i2];
      var loc = _ref4.loc;
      if (loc != null) {
        nodeLocations.push(loc);
      }
    }
    nodeLocations = undefinedIfEmpty(nodeLocations);
    _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;
    _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function(loc2) {
      return loc2.start;
    });
    _this.locations = positions && source ? positions.map(function(pos) {
      return getLocation(source, pos);
    }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function(loc2) {
      return getLocation(loc2.source, loc2.start);
    });
    _this.path = path !== null && path !== void 0 ? path : void 0;
    var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;
    if (extensions == null && isObjectLike$4(originalExtensions)) {
      _this.extensions = _objectSpread({}, originalExtensions);
    } else {
      _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};
    }
    Object.defineProperties(_assertThisInitialized$2(_this), {
      message: {
        enumerable: true
      },
      locations: {
        enumerable: _this.locations != null
      },
      path: {
        enumerable: _this.path != null
      },
      extensions: {
        enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(_assertThisInitialized$2(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized$2(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized$2(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass$1(GraphQLError2, [{
    key: "toString",
    value: function toString2() {
      return printError(this);
    }
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  var output = error.message;
  if (error.nodes) {
    for (var _i4 = 0, _error$nodes2 = error.nodes; _i4 < _error$nodes2.length; _i4++) {
      var node = _error$nodes2[_i4];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i6 = 0, _error$locations2 = error.locations; _i6 < _error$locations2.length; _i6++) {
      var location2 = _error$locations2[_i6];
      output += "\n\n" + printSourceLocation(error.source, location2);
    }
  }
  return output;
}
function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
}
var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});
function invariant$1(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
var nodejsCustomInspectSymbol$1 = nodejsCustomInspectSymbol;
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === "function" || invariant$1(0);
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol$1) {
    classObject.prototype[nodejsCustomInspectSymbol$1] = fn;
  }
}
var Location = /* @__PURE__ */ function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = /* @__PURE__ */ function() {
  function Token2(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof$1(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
  var keys2 = Object.keys(object);
  if (keys2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  var properties = keys2.map(function(key) {
    var value = formatValue(object[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol$1)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var instanceOf = function instanceOf2(value, constructor) {
  return value instanceof constructor;
};
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var Source = /* @__PURE__ */ function() {
  function Source2(body) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body), "."));
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf(source, Source);
}
var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i2 = 0; i2 < str.length; ++i2) {
    if (str[i2] !== " " && str[i2] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent = 0;
  var commonIndent = null;
  for (var i2 = 0; i2 < value.length; ++i2) {
    switch (value.charCodeAt(i2)) {
      case 13:
        if (value.charCodeAt(i2 + 1) === 10) {
          ++i2;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent = 0;
        break;
      case 9:
      case 32:
        ++indent;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {
          commonIndent = indent;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
var Lexer = /* @__PURE__ */ function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code) {
  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code = body.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code) {
  if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }
  if (code === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;
  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && (code > 31 || code === 9));
  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (code >= 48 && code <= 57) {
      throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
}
function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;
  if (code >= 48 && code <= 57) {
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);
    }
    if (code < 32 && code !== 9) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    ++position;
    if (code === 92) {
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);
      switch (code) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
          if (charCode < 0) {
            var invalidSequence = body.slice(position + 1, position + 5);
            throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position += 4;
          break;
        }
        default:
          throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }
      ++position;
      chunkStart = position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
    }
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    if (code === 10) {
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function uniCharCode(a2, b2, c2, d2) {
  return char2hex(a2) << 12 | char2hex(b2) << 8 | char2hex(c2) << 4 | char2hex(d2);
}
function char2hex(a2) {
  return a2 >= 48 && a2 <= 57 ? a2 - 48 : a2 >= 65 && a2 <= 70 ? a2 - 55 : a2 >= 97 && a2 <= 102 ? a2 - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;
  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
    ++position;
  }
  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
}
function isNameStart(code) {
  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
}
function parse$2(source, options) {
  var parser = new Parser$1(source, options);
  return parser.parseDocument();
}
var Parser$1 = /* @__PURE__ */ function() {
  function Parser2(source, options) {
    var sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
  }
  var _proto = Parser2.prototype;
  _proto.parseName = function parseName() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument2() {
    var start = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    var operation = this.parseOperationType();
    var name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;
    var start = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return {
          kind: Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.FLOAT:
        this._lexer.advance();
        return {
          kind: Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return {
              kind: Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };
          case "false":
            return {
              kind: Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };
          case "null":
            return {
              kind: Kind.NULL,
              loc: this.loc(token)
            };
          default:
            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }
      case TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }
        break;
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this.parseValueLiteral(isConst);
    };
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this2.parseObjectField(isConst);
    };
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = {
        kind: Kind.LIST_TYPE,
        type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type,
        loc: this.loc(start)
      };
    }
    return type;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var _this$_options2;
    if (!this.expectOptionalKeyword("implements")) {
      return [];
    }
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
      var types = [];
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
      return types;
    }
    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values2 = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values: values2,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values2 = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values2.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values: values2,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();
    if (DirectiveLocation[name.value] !== void 0) {
      return name;
    }
    throw this.unexpected(start);
  };
  _proto.loc = function loc(startToken) {
    var _this$_options4;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return void 0;
  };
  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  };
  return Parser2;
}();
function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit(root2, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root2);
  var keys2 = [root2];
  var index = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent = void 0;
  var path = [];
  var ancestors = [];
  var newRoot = root2;
  do {
    index++;
    var isLeaving = index === keys2.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone2 = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k2 = _Object$keys2[_i2];
            clone2[k2] = node[k2];
          }
          node = clone2;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys2[index] : void 0;
      node = parent ? parent[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent) {
        path.push(key);
      }
    }
    var result = void 0;
    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys2 = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}
const useGeneratedQuery = () => {
};
const useGeneratedByIdQuery = () => {
};
const useUpdateTemplateMutation = () => {
};
var generated = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useGeneratedQuery,
  useGeneratedByIdQuery,
  useUpdateTemplateMutation
}, Symbol.toStringTag, { value: "Module" }));
const defaultState = {
  getMany: (entityName, filterProps2) => {
    return { data: [], entityFields: { name: "entityName", fields: [] } };
  },
  getOne: (entityName, filterProps2) => {
    return {
      error: {
        error: {
          name: "networkError",
          message: "there is error",
          networkError: { name: "", message: "" }
        }
      },
      entityFields: { name: "entityName", fields: [] }
    };
  }
};
const DataContext = React__default.createContext(defaultState);
const useDataContext = (entityName) => {
  const dataContext = useContext(DataContext);
  const upsert = dataContext.upsert(entityName);
  const upsertDisabled = upsert ? false : true;
  return {
    getOne: (options) => {
      return dataContext.getOne(entityName, options);
    },
    upsert: (value) => {
      return upsert.execute(value);
    },
    upsertDisabled
  };
};
const useEntityList = (entityName, filterProps2) => {
  const dataContext = useContext(DataContext);
  return dataContext.getMany(entityName, filterProps2);
};
const useEntityDetails = (entityName, options) => {
  const dataContext = useContext(DataContext);
  return dataContext.getOne(entityName, options);
};
const useFilter = () => {
  const [sort, setSort] = React__default.useState();
  const [page, setPage] = useState(1);
  const [pageSize, setPageSize] = useState(10);
  const [filter2, setFilter] = useState();
  const offset = page * pageSize - pageSize;
  const [countRows, setCountRows] = useState(10);
  useEffect(() => {
    setSort(sort);
  }, [sort]);
  const filterProps2 = {
    filter: filter2,
    offset,
    page,
    pageSize,
    countRows,
    sort,
    onSort: (sort2) => {
      setSort(sort2);
    },
    onChangePage: (page2) => {
      setPage(page2);
    },
    onPageSize: (pageSize2) => {
      setPageSize(pageSize2);
    },
    onFilter: (query) => {
      setFilter(query);
    },
    setCountToRows: (count) => {
      setCountRows(count);
    }
  };
  return filterProps2;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d2, b2) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics$1(d2, b2);
};
function __extends$1(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics$1(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray$1(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol === "function" && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$w = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$1:
          case g$1:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$1:
              case t$1:
              case r$1:
              case h$w:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$1;
}
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$1;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h$w;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n$1;
reactIs_production_min.Fragment = e$1;
reactIs_production_min.Lazy = t$1;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$1;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$1(a2) || z$1(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A$1;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$1;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$w;
};
reactIs_production_min.isElement = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n$1;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$1;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t$1;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e$1 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$1 || a2 === q$1 || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t$1 || a2.$$typeof === r$1 || a2.$$typeof === h$w || a2.$$typeof === k$1 || a2.$$typeof === n$1 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIs = reactIs$1.exports;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty$2 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys2 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys2 = keys2.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      var key = keys2[i2];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty$2(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
function invariant(condition, message, Err) {
  if (Err === void 0) {
    Err = Error;
  }
  if (!condition) {
    throw new Err(message);
  }
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var ErrorKind;
(function(ErrorKind2) {
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
  ErrorKind2[ErrorKind2["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
  ErrorKind2[ErrorKind2["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
  ErrorKind2[ErrorKind2["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
  ErrorKind2[ErrorKind2["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
  ErrorKind2[ErrorKind2["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
  ErrorKind2[ErrorKind2["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
  ErrorKind2[ErrorKind2["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
  ErrorKind2[ErrorKind2["INVALID_TAG"] = 23] = "INVALID_TAG";
  ErrorKind2[ErrorKind2["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
  ErrorKind2[ErrorKind2["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
  ErrorKind2[ErrorKind2["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
  TYPE2[TYPE2["tag"] = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(SKELETON_TYPE2) {
  SKELETON_TYPE2[SKELETON_TYPE2["number"] = 0] = "number";
  SKELETON_TYPE2[SKELETON_TYPE2["dateTime"] = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isTagElement(el) {
  return el.type === TYPE.tag;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match2) {
    var len = match2.length;
    switch (match2[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(skeleton) {
  if (skeleton.length === 0) {
    throw new Error("Number skeleton cannot be empty");
  }
  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function(x2) {
    return x2.length > 0;
  });
  var tokens = [];
  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
    var stringToken = stringTokens_1[_i];
    var stemAndOptions = stringToken.split("/");
    if (stemAndOptions.length === 0) {
      throw new Error("Invalid number skeleton");
    }
    var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
    for (var _a2 = 0, options_1 = options; _a2 < options_1.length; _a2++) {
      var option = options_1[_a2];
      if (option.length === 0) {
        throw new Error("Invalid number skeleton");
      }
    }
    tokens.push({ stem, options });
  }
  return tokens;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(str) {
  var result = {};
  if (str[str.length - 1] === "r") {
    result.roundingPriority = "morePrecision";
  } else if (str[str.length - 1] === "s") {
    result.roundingPriority = "lessPrecision";
  }
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(stem) {
  var result;
  if (stem[0] === "E" && stem[1] === "E") {
    result = {
      notation: "engineering"
    };
    stem = stem.slice(2);
  } else if (stem[0] === "E") {
    result = {
      notation: "scientific"
    };
    stem = stem.slice(1);
  }
  if (result) {
    var signDisplay = stem.slice(0, 2);
    if (signDisplay === "+!") {
      result.signDisplay = "always";
      stem = stem.slice(2);
    } else if (signDisplay === "+?") {
      result.signDisplay = "exceptZero";
      stem = stem.slice(2);
    }
    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
      throw new Error("Malformed concise eng/scientific notation");
    }
    result.minimumIntegerDigits = stem.length;
  }
  return result;
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function parseNumberSkeleton(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
      case "%":
        result.style = "percent";
        continue;
      case "%x100":
        result.style = "percent";
        result.scale = 100;
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
      case ",_":
        result.useGrouping = false;
        continue;
      case "precision-integer":
      case ".":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
      case "K":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign$1(__assign$1(__assign$1({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt2) {
          return __assign$1(__assign$1({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "engineering":
        result = __assign$1(__assign$1(__assign$1({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt2) {
          return __assign$1(__assign$1({}, all), parseNotationOptions(opt2));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
      case "scale":
        result.scale = parseFloat(token.options[0]);
        continue;
      case "integer-width":
        if (token.options.length > 1) {
          throw new RangeError("integer-width stems only accept a single optional option");
        }
        token.options[0].replace(INTEGER_WIDTH_REGEX, function(_2, g1, g2, g3, g4, g5) {
          if (g1) {
            result.minimumIntegerDigits = g2.length;
          } else if (g3 && g4) {
            throw new Error("We currently do not support maximum integer digits");
          } else if (g5) {
            throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
      result.minimumIntegerDigits = token.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(_2, g1, g2, g3, g4, g5) {
        if (g2 === "*") {
          result.minimumFractionDigits = g1.length;
        } else if (g3 && g3[0] === "#") {
          result.maximumFractionDigits = g3.length;
        } else if (g4 && g5) {
          result.minimumFractionDigits = g4.length;
          result.maximumFractionDigits = g4.length + g5.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length;
        }
        return "";
      });
      var opt = token.options[0];
      if (opt === "w") {
        result = __assign$1(__assign$1({}, result), { trailingZeroDisplay: "stripIfInteger" });
      } else if (opt) {
        result = __assign$1(__assign$1({}, result), parseSignificantPrecision(opt));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign$1(__assign$1({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign$1(__assign$1({}, result), signOpts);
    }
    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
    if (conciseScientificAndEngineeringOpts) {
      result = __assign$1(__assign$1({}, result), conciseScientificAndEngineeringOpts);
    }
  }
  return result;
}
var _a;
var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(start, end) {
  return { start, end };
}
var hasNativeStartsWith = !!String.prototype.startsWith;
var hasNativeFromCodePoint = !!String.fromCodePoint;
var hasNativeFromEntries = !!Object.fromEntries;
var hasNativeCodePointAt = !!String.prototype.codePointAt;
var hasTrimStart = !!String.prototype.trimStart;
var hasTrimEnd = !!String.prototype.trimEnd;
var hasNativeIsSafeInteger = !!Number.isSafeInteger;
var isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(n2) {
  return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2 && Math.abs(n2) <= 9007199254740991;
};
var REGEX_SUPPORTS_U_AND_Y = true;
try {
  var re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (_2) {
  REGEX_SUPPORTS_U_AND_Y = false;
}
var startsWith = hasNativeStartsWith ? function startsWith2(s2, search, position) {
  return s2.startsWith(search, position);
} : function startsWith3(s2, search, position) {
  return s2.slice(position, position + search.length) === search;
};
var fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : function fromCodePoint2() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  var elements = "";
  var length = codePoints.length;
  var i2 = 0;
  var code;
  while (length > i2) {
    code = codePoints[i2++];
    if (code > 1114111)
      throw RangeError(code + " is not a valid code point");
    elements += code < 65536 ? String.fromCharCode(code) : String.fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
  }
  return elements;
};
var fromEntries = hasNativeFromEntries ? Object.fromEntries : function fromEntries2(entries) {
  var obj = {};
  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
    var _a2 = entries_1[_i], k2 = _a2[0], v2 = _a2[1];
    obj[k2] = v2;
  }
  return obj;
};
var codePointAt = hasNativeCodePointAt ? function codePointAt2(s2, index) {
  return s2.codePointAt(index);
} : function codePointAt3(s2, index) {
  var size = s2.length;
  if (index < 0 || index >= size) {
    return void 0;
  }
  var first = s2.charCodeAt(index);
  var second;
  return first < 55296 || first > 56319 || index + 1 === size || (second = s2.charCodeAt(index + 1)) < 56320 || second > 57343 ? first : (first - 55296 << 10) + (second - 56320) + 65536;
};
var trimStart = hasTrimStart ? function trimStart2(s2) {
  return s2.trimStart();
} : function trimStart3(s2) {
  return s2.replace(SPACE_SEPARATOR_START_REGEX, "");
};
var trimEnd = hasTrimEnd ? function trimEnd2(s2) {
  return s2.trimEnd();
} : function trimEnd3(s2) {
  return s2.replace(SPACE_SEPARATOR_END_REGEX, "");
};
function RE(s2, flag) {
  return new RegExp(s2, flag);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var _a2;
    IDENTIFIER_PREFIX_RE_1.lastIndex = index;
    var match2 = IDENTIFIER_PREFIX_RE_1.exec(s2);
    return (_a2 = match2[1]) !== null && _a2 !== void 0 ? _a2 : "";
  };
} else {
  matchIdentifierAtIndex = function matchIdentifierAtIndex2(s2, index) {
    var match2 = [];
    while (true) {
      var c2 = codePointAt(s2, index);
      if (c2 === void 0 || _isWhiteSpace(c2) || _isPatternSyntax(c2)) {
        break;
      }
      match2.push(c2);
      index += c2 >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, match2);
  };
}
var Parser = function() {
  function Parser2(message, options) {
    if (options === void 0) {
      options = {};
    }
    this.message = message;
    this.position = { offset: 0, line: 1, column: 1 };
    this.ignoreTag = !!options.ignoreTag;
    this.requiresOtherClause = !!options.requiresOtherClause;
    this.shouldParseSkeletons = !!options.shouldParseSkeletons;
  }
  Parser2.prototype.parse = function() {
    if (this.offset() !== 0) {
      throw Error("parser can only be used once");
    }
    return this.parseMessage(0, "", false);
  };
  Parser2.prototype.parseMessage = function(nestingLevel, parentArgType, expectingCloseTag) {
    var elements = [];
    while (!this.isEOF()) {
      var char = this.char();
      if (char === 123) {
        var result = this.parseArgument(nestingLevel, expectingCloseTag);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else if (char === 125 && nestingLevel > 0) {
        break;
      } else if (char === 35 && (parentArgType === "plural" || parentArgType === "selectordinal")) {
        var position = this.clonePosition();
        this.bump();
        elements.push({
          type: TYPE.pound,
          location: createLocation(position, this.clonePosition())
        });
      } else if (char === 60 && !this.ignoreTag && this.peek() === 47) {
        if (expectingCloseTag) {
          break;
        } else {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
        }
      } else if (char === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
        var result = this.parseTag(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      } else {
        var result = this.parseLiteral(nestingLevel, parentArgType);
        if (result.err) {
          return result;
        }
        elements.push(result.val);
      }
    }
    return { val: elements, err: null };
  };
  Parser2.prototype.parseTag = function(nestingLevel, parentArgType) {
    var startPosition = this.clonePosition();
    this.bump();
    var tagName = this.parseTagName();
    this.bumpSpace();
    if (this.bumpIf("/>")) {
      return {
        val: {
          type: TYPE.literal,
          value: "<".concat(tagName, "/>"),
          location: createLocation(startPosition, this.clonePosition())
        },
        err: null
      };
    } else if (this.bumpIf(">")) {
      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
      if (childrenResult.err) {
        return childrenResult;
      }
      var children = childrenResult.val;
      var endTagStartPosition = this.clonePosition();
      if (this.bumpIf("</")) {
        if (this.isEOF() || !_isAlpha(this.char())) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        var closingTagNameStartPosition = this.clonePosition();
        var closingTagName = this.parseTagName();
        if (tagName !== closingTagName) {
          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
        }
        this.bumpSpace();
        if (!this.bumpIf(">")) {
          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
        }
        return {
          val: {
            type: TYPE.tag,
            value: tagName,
            children,
            location: createLocation(startPosition, this.clonePosition())
          },
          err: null
        };
      } else {
        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
      }
    } else {
      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
    }
  };
  Parser2.prototype.parseTagName = function() {
    var startOffset = this.offset();
    this.bump();
    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
      this.bump();
    }
    return this.message.slice(startOffset, this.offset());
  };
  Parser2.prototype.parseLiteral = function(nestingLevel, parentArgType) {
    var start = this.clonePosition();
    var value = "";
    while (true) {
      var parseQuoteResult = this.tryParseQuote(parentArgType);
      if (parseQuoteResult) {
        value += parseQuoteResult;
        continue;
      }
      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
      if (parseUnquotedResult) {
        value += parseUnquotedResult;
        continue;
      }
      var parseLeftAngleResult = this.tryParseLeftAngleBracket();
      if (parseLeftAngleResult) {
        value += parseLeftAngleResult;
        continue;
      }
      break;
    }
    var location2 = createLocation(start, this.clonePosition());
    return {
      val: { type: TYPE.literal, value, location: location2 },
      err: null
    };
  };
  Parser2.prototype.tryParseLeftAngleBracket = function() {
    if (!this.isEOF() && this.char() === 60 && (this.ignoreTag || !_isAlphaOrSlash(this.peek() || 0))) {
      this.bump();
      return "<";
    }
    return null;
  };
  Parser2.prototype.tryParseQuote = function(parentArgType) {
    if (this.isEOF() || this.char() !== 39) {
      return null;
    }
    switch (this.peek()) {
      case 39:
        this.bump();
        this.bump();
        return "'";
      case 123:
      case 60:
      case 62:
      case 125:
        break;
      case 35:
        if (parentArgType === "plural" || parentArgType === "selectordinal") {
          break;
        }
        return null;
      default:
        return null;
    }
    this.bump();
    var codePoints = [this.char()];
    this.bump();
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch === 39) {
        if (this.peek() === 39) {
          codePoints.push(39);
          this.bump();
        } else {
          this.bump();
          break;
        }
      } else {
        codePoints.push(ch);
      }
      this.bump();
    }
    return fromCodePoint.apply(void 0, codePoints);
  };
  Parser2.prototype.tryParseUnquoted = function(nestingLevel, parentArgType) {
    if (this.isEOF()) {
      return null;
    }
    var ch = this.char();
    if (ch === 60 || ch === 123 || ch === 35 && (parentArgType === "plural" || parentArgType === "selectordinal") || ch === 125 && nestingLevel > 0) {
      return null;
    } else {
      this.bump();
      return fromCodePoint(ch);
    }
  };
  Parser2.prototype.parseArgument = function(nestingLevel, expectingCloseTag) {
    var openingBracePosition = this.clonePosition();
    this.bump();
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    if (this.char() === 125) {
      this.bump();
      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    var value = this.parseIdentifierIfPossible().value;
    if (!value) {
      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bumpSpace();
    if (this.isEOF()) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    switch (this.char()) {
      case 125: {
        this.bump();
        return {
          val: {
            type: TYPE.argument,
            value,
            location: createLocation(openingBracePosition, this.clonePosition())
          },
          err: null
        };
      }
      case 44: {
        this.bump();
        this.bumpSpace();
        if (this.isEOF()) {
          return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
        }
        return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
      }
      default:
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
    }
  };
  Parser2.prototype.parseIdentifierIfPossible = function() {
    var startingPosition = this.clonePosition();
    var startOffset = this.offset();
    var value = matchIdentifierAtIndex(this.message, startOffset);
    var endOffset = startOffset + value.length;
    this.bumpTo(endOffset);
    var endPosition = this.clonePosition();
    var location2 = createLocation(startingPosition, endPosition);
    return { value, location: location2 };
  };
  Parser2.prototype.parseArgumentOptions = function(nestingLevel, expectingCloseTag, value, openingBracePosition) {
    var _a2;
    var typeStartPosition = this.clonePosition();
    var argType = this.parseIdentifierIfPossible().value;
    var typeEndPosition = this.clonePosition();
    switch (argType) {
      case "":
        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
      case "number":
      case "date":
      case "time": {
        this.bumpSpace();
        var styleAndLocation = null;
        if (this.bumpIf(",")) {
          this.bumpSpace();
          var styleStartPosition = this.clonePosition();
          var result = this.parseSimpleArgStyleIfPossible();
          if (result.err) {
            return result;
          }
          var style2 = trimEnd(result.val);
          if (style2.length === 0) {
            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          var styleLocation = createLocation(styleStartPosition, this.clonePosition());
          styleAndLocation = { style: style2, styleLocation };
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_1 = createLocation(openingBracePosition, this.clonePosition());
        if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, "::", 0)) {
          var skeleton = trimStart(styleAndLocation.style.slice(2));
          if (argType === "number") {
            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
            if (result.err) {
              return result;
            }
            return {
              val: { type: TYPE.number, value, location: location_1, style: result.val },
              err: null
            };
          } else {
            if (skeleton.length === 0) {
              return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
            }
            var style2 = {
              type: SKELETON_TYPE.dateTime,
              pattern: skeleton,
              location: styleAndLocation.styleLocation,
              parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}
            };
            var type = argType === "date" ? TYPE.date : TYPE.time;
            return {
              val: { type, value, location: location_1, style: style2 },
              err: null
            };
          }
        }
        return {
          val: {
            type: argType === "number" ? TYPE.number : argType === "date" ? TYPE.date : TYPE.time,
            value,
            location: location_1,
            style: (_a2 = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a2 !== void 0 ? _a2 : null
          },
          err: null
        };
      }
      case "plural":
      case "selectordinal":
      case "select": {
        var typeEndPosition_1 = this.clonePosition();
        this.bumpSpace();
        if (!this.bumpIf(",")) {
          return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign$1({}, typeEndPosition_1)));
        }
        this.bumpSpace();
        var identifierAndLocation = this.parseIdentifierIfPossible();
        var pluralOffset = 0;
        if (argType !== "select" && identifierAndLocation.value === "offset") {
          if (!this.bumpIf(":")) {
            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
          }
          this.bumpSpace();
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
          if (result.err) {
            return result;
          }
          this.bumpSpace();
          identifierAndLocation = this.parseIdentifierIfPossible();
          pluralOffset = result.val;
        }
        var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
        if (optionsResult.err) {
          return optionsResult;
        }
        var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
        if (argCloseResult.err) {
          return argCloseResult;
        }
        var location_2 = createLocation(openingBracePosition, this.clonePosition());
        if (argType === "select") {
          return {
            val: {
              type: TYPE.select,
              value,
              options: fromEntries(optionsResult.val),
              location: location_2
            },
            err: null
          };
        } else {
          return {
            val: {
              type: TYPE.plural,
              value,
              options: fromEntries(optionsResult.val),
              offset: pluralOffset,
              pluralType: argType === "plural" ? "cardinal" : "ordinal",
              location: location_2
            },
            err: null
          };
        }
      }
      default:
        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
    }
  };
  Parser2.prototype.tryParseArgumentClose = function(openingBracePosition) {
    if (this.isEOF() || this.char() !== 125) {
      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
    }
    this.bump();
    return { val: true, err: null };
  };
  Parser2.prototype.parseSimpleArgStyleIfPossible = function() {
    var nestedBraces = 0;
    var startPosition = this.clonePosition();
    while (!this.isEOF()) {
      var ch = this.char();
      switch (ch) {
        case 39: {
          this.bump();
          var apostrophePosition = this.clonePosition();
          if (!this.bumpUntil("'")) {
            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
          }
          this.bump();
          break;
        }
        case 123: {
          nestedBraces += 1;
          this.bump();
          break;
        }
        case 125: {
          if (nestedBraces > 0) {
            nestedBraces -= 1;
          } else {
            return {
              val: this.message.slice(startPosition.offset, this.offset()),
              err: null
            };
          }
          break;
        }
        default:
          this.bump();
          break;
      }
    }
    return {
      val: this.message.slice(startPosition.offset, this.offset()),
      err: null
    };
  };
  Parser2.prototype.parseNumberSkeletonFromString = function(skeleton, location2) {
    var tokens = [];
    try {
      tokens = parseNumberSkeletonFromString(skeleton);
    } catch (e2) {
      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location2);
    }
    return {
      val: {
        type: SKELETON_TYPE.number,
        tokens,
        location: location2,
        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}
      },
      err: null
    };
  };
  Parser2.prototype.tryParsePluralOrSelectOptions = function(nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
    var _a2;
    var hasOtherClause = false;
    var options = [];
    var parsedSelectors = /* @__PURE__ */ new Set();
    var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
    while (true) {
      if (selector.length === 0) {
        var startPosition = this.clonePosition();
        if (parentArgType !== "select" && this.bumpIf("=")) {
          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
          if (result.err) {
            return result;
          }
          selectorLocation = createLocation(startPosition, this.clonePosition());
          selector = this.message.slice(startPosition.offset, this.offset());
        } else {
          break;
        }
      }
      if (parsedSelectors.has(selector)) {
        return this.error(parentArgType === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
      }
      if (selector === "other") {
        hasOtherClause = true;
      }
      this.bumpSpace();
      var openingBracePosition = this.clonePosition();
      if (!this.bumpIf("{")) {
        return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
      }
      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
      if (fragmentResult.err) {
        return fragmentResult;
      }
      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
      if (argCloseResult.err) {
        return argCloseResult;
      }
      options.push([
        selector,
        {
          value: fragmentResult.val,
          location: createLocation(openingBracePosition, this.clonePosition())
        }
      ]);
      parsedSelectors.add(selector);
      this.bumpSpace();
      _a2 = this.parseIdentifierIfPossible(), selector = _a2.value, selectorLocation = _a2.location;
    }
    if (options.length === 0) {
      return this.error(parentArgType === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
    }
    if (this.requiresOtherClause && !hasOtherClause) {
      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
    }
    return { val: options, err: null };
  };
  Parser2.prototype.tryParseDecimalInteger = function(expectNumberError, invalidNumberError) {
    var sign = 1;
    var startingPosition = this.clonePosition();
    if (this.bumpIf("+"))
      ;
    else if (this.bumpIf("-")) {
      sign = -1;
    }
    var hasDigits = false;
    var decimal = 0;
    while (!this.isEOF()) {
      var ch = this.char();
      if (ch >= 48 && ch <= 57) {
        hasDigits = true;
        decimal = decimal * 10 + (ch - 48);
        this.bump();
      } else {
        break;
      }
    }
    var location2 = createLocation(startingPosition, this.clonePosition());
    if (!hasDigits) {
      return this.error(expectNumberError, location2);
    }
    decimal *= sign;
    if (!isSafeInteger(decimal)) {
      return this.error(invalidNumberError, location2);
    }
    return { val: decimal, err: null };
  };
  Parser2.prototype.offset = function() {
    return this.position.offset;
  };
  Parser2.prototype.isEOF = function() {
    return this.offset() === this.message.length;
  };
  Parser2.prototype.clonePosition = function() {
    return {
      offset: this.position.offset,
      line: this.position.line,
      column: this.position.column
    };
  };
  Parser2.prototype.char = function() {
    var offset = this.position.offset;
    if (offset >= this.message.length) {
      throw Error("out of bound");
    }
    var code = codePointAt(this.message, offset);
    if (code === void 0) {
      throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
    }
    return code;
  };
  Parser2.prototype.error = function(kind, location2) {
    return {
      val: null,
      err: {
        kind,
        message: this.message,
        location: location2
      }
    };
  };
  Parser2.prototype.bump = function() {
    if (this.isEOF()) {
      return;
    }
    var code = this.char();
    if (code === 10) {
      this.position.line += 1;
      this.position.column = 1;
      this.position.offset += 1;
    } else {
      this.position.column += 1;
      this.position.offset += code < 65536 ? 1 : 2;
    }
  };
  Parser2.prototype.bumpIf = function(prefix) {
    if (startsWith(this.message, prefix, this.offset())) {
      for (var i2 = 0; i2 < prefix.length; i2++) {
        this.bump();
      }
      return true;
    }
    return false;
  };
  Parser2.prototype.bumpUntil = function(pattern) {
    var currentOffset = this.offset();
    var index = this.message.indexOf(pattern, currentOffset);
    if (index >= 0) {
      this.bumpTo(index);
      return true;
    } else {
      this.bumpTo(this.message.length);
      return false;
    }
  };
  Parser2.prototype.bumpTo = function(targetOffset) {
    if (this.offset() > targetOffset) {
      throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
    }
    targetOffset = Math.min(targetOffset, this.message.length);
    while (true) {
      var offset = this.offset();
      if (offset === targetOffset) {
        break;
      }
      if (offset > targetOffset) {
        throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
      }
      this.bump();
      if (this.isEOF()) {
        break;
      }
    }
  };
  Parser2.prototype.bumpSpace = function() {
    while (!this.isEOF() && _isWhiteSpace(this.char())) {
      this.bump();
    }
  };
  Parser2.prototype.peek = function() {
    if (this.isEOF()) {
      return null;
    }
    var code = this.char();
    var offset = this.offset();
    var nextCode = this.message.charCodeAt(offset + (code >= 65536 ? 2 : 1));
    return nextCode !== null && nextCode !== void 0 ? nextCode : null;
  };
  return Parser2;
}();
function _isAlpha(codepoint) {
  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;
}
function _isAlphaOrSlash(codepoint) {
  return _isAlpha(codepoint) || codepoint === 47;
}
function _isPotentialElementNameChar(c2) {
  return c2 === 45 || c2 === 46 || c2 >= 48 && c2 <= 57 || c2 === 95 || c2 >= 97 && c2 <= 122 || c2 >= 65 && c2 <= 90 || c2 == 183 || c2 >= 192 && c2 <= 214 || c2 >= 216 && c2 <= 246 || c2 >= 248 && c2 <= 893 || c2 >= 895 && c2 <= 8191 || c2 >= 8204 && c2 <= 8205 || c2 >= 8255 && c2 <= 8256 || c2 >= 8304 && c2 <= 8591 || c2 >= 11264 && c2 <= 12271 || c2 >= 12289 && c2 <= 55295 || c2 >= 63744 && c2 <= 64975 || c2 >= 65008 && c2 <= 65533 || c2 >= 65536 && c2 <= 983039;
}
function _isWhiteSpace(c2) {
  return c2 >= 9 && c2 <= 13 || c2 === 32 || c2 === 133 || c2 >= 8206 && c2 <= 8207 || c2 === 8232 || c2 === 8233;
}
function _isPatternSyntax(c2) {
  return c2 >= 33 && c2 <= 35 || c2 === 36 || c2 >= 37 && c2 <= 39 || c2 === 40 || c2 === 41 || c2 === 42 || c2 === 43 || c2 === 44 || c2 === 45 || c2 >= 46 && c2 <= 47 || c2 >= 58 && c2 <= 59 || c2 >= 60 && c2 <= 62 || c2 >= 63 && c2 <= 64 || c2 === 91 || c2 === 92 || c2 === 93 || c2 === 94 || c2 === 96 || c2 === 123 || c2 === 124 || c2 === 125 || c2 === 126 || c2 === 161 || c2 >= 162 && c2 <= 165 || c2 === 166 || c2 === 167 || c2 === 169 || c2 === 171 || c2 === 172 || c2 === 174 || c2 === 176 || c2 === 177 || c2 === 182 || c2 === 187 || c2 === 191 || c2 === 215 || c2 === 247 || c2 >= 8208 && c2 <= 8213 || c2 >= 8214 && c2 <= 8215 || c2 === 8216 || c2 === 8217 || c2 === 8218 || c2 >= 8219 && c2 <= 8220 || c2 === 8221 || c2 === 8222 || c2 === 8223 || c2 >= 8224 && c2 <= 8231 || c2 >= 8240 && c2 <= 8248 || c2 === 8249 || c2 === 8250 || c2 >= 8251 && c2 <= 8254 || c2 >= 8257 && c2 <= 8259 || c2 === 8260 || c2 === 8261 || c2 === 8262 || c2 >= 8263 && c2 <= 8273 || c2 === 8274 || c2 === 8275 || c2 >= 8277 && c2 <= 8286 || c2 >= 8592 && c2 <= 8596 || c2 >= 8597 && c2 <= 8601 || c2 >= 8602 && c2 <= 8603 || c2 >= 8604 && c2 <= 8607 || c2 === 8608 || c2 >= 8609 && c2 <= 8610 || c2 === 8611 || c2 >= 8612 && c2 <= 8613 || c2 === 8614 || c2 >= 8615 && c2 <= 8621 || c2 === 8622 || c2 >= 8623 && c2 <= 8653 || c2 >= 8654 && c2 <= 8655 || c2 >= 8656 && c2 <= 8657 || c2 === 8658 || c2 === 8659 || c2 === 8660 || c2 >= 8661 && c2 <= 8691 || c2 >= 8692 && c2 <= 8959 || c2 >= 8960 && c2 <= 8967 || c2 === 8968 || c2 === 8969 || c2 === 8970 || c2 === 8971 || c2 >= 8972 && c2 <= 8991 || c2 >= 8992 && c2 <= 8993 || c2 >= 8994 && c2 <= 9e3 || c2 === 9001 || c2 === 9002 || c2 >= 9003 && c2 <= 9083 || c2 === 9084 || c2 >= 9085 && c2 <= 9114 || c2 >= 9115 && c2 <= 9139 || c2 >= 9140 && c2 <= 9179 || c2 >= 9180 && c2 <= 9185 || c2 >= 9186 && c2 <= 9254 || c2 >= 9255 && c2 <= 9279 || c2 >= 9280 && c2 <= 9290 || c2 >= 9291 && c2 <= 9311 || c2 >= 9472 && c2 <= 9654 || c2 === 9655 || c2 >= 9656 && c2 <= 9664 || c2 === 9665 || c2 >= 9666 && c2 <= 9719 || c2 >= 9720 && c2 <= 9727 || c2 >= 9728 && c2 <= 9838 || c2 === 9839 || c2 >= 9840 && c2 <= 10087 || c2 === 10088 || c2 === 10089 || c2 === 10090 || c2 === 10091 || c2 === 10092 || c2 === 10093 || c2 === 10094 || c2 === 10095 || c2 === 10096 || c2 === 10097 || c2 === 10098 || c2 === 10099 || c2 === 10100 || c2 === 10101 || c2 >= 10132 && c2 <= 10175 || c2 >= 10176 && c2 <= 10180 || c2 === 10181 || c2 === 10182 || c2 >= 10183 && c2 <= 10213 || c2 === 10214 || c2 === 10215 || c2 === 10216 || c2 === 10217 || c2 === 10218 || c2 === 10219 || c2 === 10220 || c2 === 10221 || c2 === 10222 || c2 === 10223 || c2 >= 10224 && c2 <= 10239 || c2 >= 10240 && c2 <= 10495 || c2 >= 10496 && c2 <= 10626 || c2 === 10627 || c2 === 10628 || c2 === 10629 || c2 === 10630 || c2 === 10631 || c2 === 10632 || c2 === 10633 || c2 === 10634 || c2 === 10635 || c2 === 10636 || c2 === 10637 || c2 === 10638 || c2 === 10639 || c2 === 10640 || c2 === 10641 || c2 === 10642 || c2 === 10643 || c2 === 10644 || c2 === 10645 || c2 === 10646 || c2 === 10647 || c2 === 10648 || c2 >= 10649 && c2 <= 10711 || c2 === 10712 || c2 === 10713 || c2 === 10714 || c2 === 10715 || c2 >= 10716 && c2 <= 10747 || c2 === 10748 || c2 === 10749 || c2 >= 10750 && c2 <= 11007 || c2 >= 11008 && c2 <= 11055 || c2 >= 11056 && c2 <= 11076 || c2 >= 11077 && c2 <= 11078 || c2 >= 11079 && c2 <= 11084 || c2 >= 11085 && c2 <= 11123 || c2 >= 11124 && c2 <= 11125 || c2 >= 11126 && c2 <= 11157 || c2 === 11158 || c2 >= 11159 && c2 <= 11263 || c2 >= 11776 && c2 <= 11777 || c2 === 11778 || c2 === 11779 || c2 === 11780 || c2 === 11781 || c2 >= 11782 && c2 <= 11784 || c2 === 11785 || c2 === 11786 || c2 === 11787 || c2 === 11788 || c2 === 11789 || c2 >= 11790 && c2 <= 11798 || c2 === 11799 || c2 >= 11800 && c2 <= 11801 || c2 === 11802 || c2 === 11803 || c2 === 11804 || c2 === 11805 || c2 >= 11806 && c2 <= 11807 || c2 === 11808 || c2 === 11809 || c2 === 11810 || c2 === 11811 || c2 === 11812 || c2 === 11813 || c2 === 11814 || c2 === 11815 || c2 === 11816 || c2 === 11817 || c2 >= 11818 && c2 <= 11822 || c2 === 11823 || c2 >= 11824 && c2 <= 11833 || c2 >= 11834 && c2 <= 11835 || c2 >= 11836 && c2 <= 11839 || c2 === 11840 || c2 === 11841 || c2 === 11842 || c2 >= 11843 && c2 <= 11855 || c2 >= 11856 && c2 <= 11857 || c2 === 11858 || c2 >= 11859 && c2 <= 11903 || c2 >= 12289 && c2 <= 12291 || c2 === 12296 || c2 === 12297 || c2 === 12298 || c2 === 12299 || c2 === 12300 || c2 === 12301 || c2 === 12302 || c2 === 12303 || c2 === 12304 || c2 === 12305 || c2 >= 12306 && c2 <= 12307 || c2 === 12308 || c2 === 12309 || c2 === 12310 || c2 === 12311 || c2 === 12312 || c2 === 12313 || c2 === 12314 || c2 === 12315 || c2 === 12316 || c2 === 12317 || c2 >= 12318 && c2 <= 12319 || c2 === 12320 || c2 === 12336 || c2 === 64830 || c2 === 64831 || c2 >= 65093 && c2 <= 65094;
}
function pruneLocation(els) {
  els.forEach(function(el) {
    delete el.location;
    if (isSelectElement(el) || isPluralElement(el)) {
      for (var k2 in el.options) {
        delete el.options[k2].location;
        pruneLocation(el.options[k2].value);
      }
    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
      delete el.style.location;
    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {
      delete el.style.location;
    } else if (isTagElement(el)) {
      pruneLocation(el.children);
    }
  });
}
function parse$1(message, opts) {
  if (opts === void 0) {
    opts = {};
  }
  opts = __assign$1({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
  var result = new Parser(message, opts).parse();
  if (result.err) {
    var error = SyntaxError(ErrorKind[result.err.kind]);
    error.location = result.err.location;
    error.originalMessage = result.err.message;
    throw error;
  }
  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
    pruneLocation(result.val);
  }
  return result.val;
}
function memoize$2(fn, options) {
  var cache2 = options && options.cache ? options.cache : cacheDefault;
  var serializer = options && options.serializer ? options.serializer : serializerDefault;
  var strategy = options && options.strategy ? options.strategy : strategyDefault;
  return strategy(fn, {
    cache: cache2,
    serializer
  });
}
function isPrimitive(value) {
  return value == null || typeof value === "number" || typeof value === "boolean";
}
function monadic(fn, cache2, serializer, arg) {
  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
  var computedValue = cache2.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.call(this, arg);
    cache2.set(cacheKey, computedValue);
  }
  return computedValue;
}
function variadic(fn, cache2, serializer) {
  var args = Array.prototype.slice.call(arguments, 3);
  var cacheKey = serializer(args);
  var computedValue = cache2.get(cacheKey);
  if (typeof computedValue === "undefined") {
    computedValue = fn.apply(this, args);
    cache2.set(cacheKey, computedValue);
  }
  return computedValue;
}
function assemble(fn, context, strategy, cache2, serialize) {
  return strategy.bind(context, fn, cache2, serialize);
}
function strategyDefault(fn, options) {
  var strategy = fn.length === 1 ? monadic : variadic;
  return assemble(fn, this, strategy, options.cache.create(), options.serializer);
}
function strategyVariadic(fn, options) {
  return assemble(fn, this, variadic, options.cache.create(), options.serializer);
}
function strategyMonadic(fn, options) {
  return assemble(fn, this, monadic, options.cache.create(), options.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(key) {
  return this.cache[key];
};
ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
  this.cache[key] = value;
};
var cacheDefault = {
  create: function create() {
    return new ObjectWithoutPrototypeCache();
  }
};
var strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic
};
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["MISSING_VALUE"] = "MISSING_VALUE";
  ErrorCode2["INVALID_VALUE"] = "INVALID_VALUE";
  ErrorCode2["MISSING_INTL_API"] = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = function(_super) {
  __extends(FormatError2, _super);
  function FormatError2(msg, code, originalMessage) {
    var _this = _super.call(this, msg) || this;
    _this.code = code;
    _this.originalMessage = originalMessage;
    return _this;
  }
  FormatError2.prototype.toString = function() {
    return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
  };
  return FormatError2;
}(Error);
var InvalidValueError = function(_super) {
  __extends(InvalidValueError2, _super);
  function InvalidValueError2(variableId, value, options, originalMessage) {
    return _super.call(this, 'Invalid values for "'.concat(variableId, '": "').concat(value, '". Options are "').concat(Object.keys(options).join('", "'), '"'), ErrorCode.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueError2;
}(FormatError);
var InvalidValueTypeError = function(_super) {
  __extends(InvalidValueTypeError2, _super);
  function InvalidValueTypeError2(value, type, originalMessage) {
    return _super.call(this, 'Value for "'.concat(value, '" must be of type ').concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
  }
  return InvalidValueTypeError2;
}(FormatError);
var MissingValueError = function(_super) {
  __extends(MissingValueError2, _super);
  function MissingValueError2(variableId, originalMessage) {
    return _super.call(this, 'The intl string context variable "'.concat(variableId, '" was not provided to the string "').concat(originalMessage, '"'), ErrorCode.MISSING_VALUE, originalMessage) || this;
  }
  return MissingValueError2;
}(FormatError);
var PART_TYPE;
(function(PART_TYPE2) {
  PART_TYPE2[PART_TYPE2["literal"] = 0] = "literal";
  PART_TYPE2[PART_TYPE2["object"] = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function isFormatXMLElementFn(el) {
  return typeof el === "function";
}
function formatToParts(els, locales, formatters2, formats, values2, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: PART_TYPE.literal,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: PART_TYPE.literal,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: PART_TYPE.literal,
          value: formatters2.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values2 && varName in values2)) {
      throw new MissingValueError(varName, originalMessage);
    }
    var value = values2[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: typeof value === "string" ? PART_TYPE.literal : PART_TYPE.object,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style2 = typeof el.style === "string" ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getDateTimeFormat(locales, style2).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style2 = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : void 0;
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getDateTimeFormat(locales, style2).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style2 = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : void 0;
      if (style2 && style2.scale) {
        value = value * (style2.scale || 1);
      }
      result.push({
        type: PART_TYPE.literal,
        value: formatters2.getNumberFormat(locales, style2).format(value)
      });
      continue;
    }
    if (isTagElement(el)) {
      var children = el.children, value_1 = el.value;
      var formatFn = values2[value_1];
      if (!isFormatXMLElementFn(formatFn)) {
        throw new InvalidValueTypeError(value_1, "function", originalMessage);
      }
      var parts = formatToParts(children, locales, formatters2, formats, values2, currentPluralValue);
      var chunks2 = formatFn(parts.map(function(p2) {
        return p2.value;
      }));
      if (!Array.isArray(chunks2)) {
        chunks2 = [chunks2];
      }
      result.push.apply(result, chunks2.map(function(c2) {
        return {
          type: typeof c2 === "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: c2
        };
      }));
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters2, formats, values2));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=".concat(value)];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API, originalMessage);
        }
        var rule = formatters2.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters2, formats, values2, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign(__assign(__assign({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign(__assign({}, c1[k2]), c2[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign({}, defaultConfig));
}
function createFastMemoizeCache$1(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createDefaultFormatters(cache2) {
  if (cache2 === void 0) {
    cache2 = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoize$2(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache2.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize$2(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache2.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize$2(function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache$1(cache2.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = function() {
  function IntlMessageFormat2(message, locales, overrideFormats, opts) {
    var _this = this;
    if (locales === void 0) {
      locales = IntlMessageFormat2.defaultLocale;
    }
    this.formatterCache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
    this.format = function(values2) {
      var parts = _this.formatToParts(values2);
      if (parts.length === 1) {
        return parts[0].value;
      }
      var result = parts.reduce(function(all, part) {
        if (!all.length || part.type !== PART_TYPE.literal || typeof all[all.length - 1] !== "string") {
          all.push(part.value);
        } else {
          all[all.length - 1] += part.value;
        }
        return all;
      }, []);
      if (result.length <= 1) {
        return result[0] || "";
      }
      return result;
    };
    this.formatToParts = function(values2) {
      return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values2, void 0, _this.message);
    };
    this.resolvedOptions = function() {
      return {
        locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
      };
    };
    this.getAst = function() {
      return _this.ast;
    };
    if (typeof message === "string") {
      this.message = message;
      if (!IntlMessageFormat2.__parse) {
        throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
      }
      this.ast = IntlMessageFormat2.__parse(message, {
        ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag
      });
    } else {
      this.ast = message;
    }
    if (!Array.isArray(this.ast)) {
      throw new TypeError("A message must be provided as a String or AST.");
    }
    this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
    this.locales = locales;
    this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
  }
  Object.defineProperty(IntlMessageFormat2, "defaultLocale", {
    get: function() {
      if (!IntlMessageFormat2.memoizedDefaultLocale) {
        IntlMessageFormat2.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
      }
      return IntlMessageFormat2.memoizedDefaultLocale;
    },
    enumerable: false,
    configurable: true
  });
  IntlMessageFormat2.memoizedDefaultLocale = null;
  IntlMessageFormat2.__parse = parse$1;
  IntlMessageFormat2.formats = {
    number: {
      integer: {
        maximumFractionDigits: 0
      },
      currency: {
        style: "currency"
      },
      percent: {
        style: "percent"
      }
    },
    date: {
      short: {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      medium: {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      long: {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      full: {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      short: {
        hour: "numeric",
        minute: "numeric"
      },
      medium: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      long: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      full: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  };
  return IntlMessageFormat2;
}();
var IntlErrorCode;
(function(IntlErrorCode2) {
  IntlErrorCode2["FORMAT_ERROR"] = "FORMAT_ERROR";
  IntlErrorCode2["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
  IntlErrorCode2["INVALID_CONFIG"] = "INVALID_CONFIG";
  IntlErrorCode2["MISSING_DATA"] = "MISSING_DATA";
  IntlErrorCode2["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
})(IntlErrorCode || (IntlErrorCode = {}));
var IntlError = function(_super) {
  __extends$1(IntlError2, _super);
  function IntlError2(code, message, exception) {
    var _this = this;
    var err = exception ? exception instanceof Error ? exception : new Error(String(exception)) : void 0;
    _this = _super.call(this, "[@formatjs/intl Error ".concat(code, "] ").concat(message, " \n").concat(err ? "\n".concat(err.message, "\n").concat(err.stack) : "")) || this;
    _this.code = code;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_this, IntlError2);
    }
    return _this;
  }
  return IntlError2;
}(Error);
var UnsupportedFormatterError = function(_super) {
  __extends$1(UnsupportedFormatterError2, _super);
  function UnsupportedFormatterError2(message, exception) {
    return _super.call(this, IntlErrorCode.UNSUPPORTED_FORMATTER, message, exception) || this;
  }
  return UnsupportedFormatterError2;
}(IntlError);
var InvalidConfigError = function(_super) {
  __extends$1(InvalidConfigError2, _super);
  function InvalidConfigError2(message, exception) {
    return _super.call(this, IntlErrorCode.INVALID_CONFIG, message, exception) || this;
  }
  return InvalidConfigError2;
}(IntlError);
var MissingDataError = function(_super) {
  __extends$1(MissingDataError2, _super);
  function MissingDataError2(message, exception) {
    return _super.call(this, IntlErrorCode.MISSING_DATA, message, exception) || this;
  }
  return MissingDataError2;
}(IntlError);
var IntlFormatError = function(_super) {
  __extends$1(IntlFormatError2, _super);
  function IntlFormatError2(message, locale2, exception) {
    return _super.call(this, IntlErrorCode.FORMAT_ERROR, "".concat(message, " \nLocale: ").concat(locale2, "\n"), exception) || this;
  }
  return IntlFormatError2;
}(IntlError);
var MessageFormatError = function(_super) {
  __extends$1(MessageFormatError2, _super);
  function MessageFormatError2(message, locale2, descriptor, exception) {
    var _this = _super.call(this, "".concat(message, " \nMessageID: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.id, "\nDefault Message: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage, "\nDescription: ").concat(descriptor === null || descriptor === void 0 ? void 0 : descriptor.description, " \n"), locale2, exception) || this;
    _this.descriptor = descriptor;
    return _this;
  }
  return MessageFormatError2;
}(IntlFormatError);
var MissingTranslationError = function(_super) {
  __extends$1(MissingTranslationError2, _super);
  function MissingTranslationError2(descriptor, locale2) {
    var _this = _super.call(this, IntlErrorCode.MISSING_TRANSLATION, 'Missing message: "'.concat(descriptor.id, '" for locale "').concat(locale2, '", using ').concat(descriptor.defaultMessage ? "default message" : "id", " as fallback.")) || this;
    _this.descriptor = descriptor;
    return _this;
  }
  return MissingTranslationError2;
}(IntlError);
function filterProps(props, allowlist, defaults) {
  if (defaults === void 0) {
    defaults = {};
  }
  return allowlist.reduce(function(filtered, name) {
    if (name in props) {
      filtered[name] = props[name];
    } else if (name in defaults) {
      filtered[name] = defaults[name];
    }
    return filtered;
  }, {});
}
var defaultErrorHandler = function(error) {
};
var DEFAULT_INTL_CONFIG$1 = {
  formats: {},
  messages: {},
  timeZone: void 0,
  defaultLocale: "en",
  defaultFormats: {},
  fallbackOnEmptyString: true,
  onError: defaultErrorHandler
};
function createIntlCache() {
  return {
    dateTime: {},
    number: {},
    message: {},
    relativeTime: {},
    pluralRules: {},
    list: {},
    displayNames: {}
  };
}
function createFastMemoizeCache(store) {
  return {
    create: function() {
      return {
        get: function(key) {
          return store[key];
        },
        set: function(key, value) {
          store[key] = value;
        }
      };
    }
  };
}
function createFormatters(cache2) {
  if (cache2 === void 0) {
    cache2 = createIntlCache();
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  var ListFormat = Intl.ListFormat;
  var DisplayNames = Intl.DisplayNames;
  var getDateTimeFormat = memoize$2(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.DateTimeFormat).bind.apply(_a2, __spreadArray$1([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache2.dateTime),
    strategy: strategies.variadic
  });
  var getNumberFormat = memoize$2(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.NumberFormat).bind.apply(_a2, __spreadArray$1([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache2.number),
    strategy: strategies.variadic
  });
  var getPluralRules = memoize$2(function() {
    var _a2;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new ((_a2 = Intl.PluralRules).bind.apply(_a2, __spreadArray$1([void 0], args, false)))();
  }, {
    cache: createFastMemoizeCache(cache2.pluralRules),
    strategy: strategies.variadic
  });
  return {
    getDateTimeFormat,
    getNumberFormat,
    getMessageFormat: memoize$2(function(message, locales, overrideFormats, opts) {
      return new IntlMessageFormat(message, locales, overrideFormats, __assign$1({ formatters: {
        getNumberFormat,
        getDateTimeFormat,
        getPluralRules
      } }, opts || {}));
    }, {
      cache: createFastMemoizeCache(cache2.message),
      strategy: strategies.variadic
    }),
    getRelativeTimeFormat: memoize$2(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArray$1([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.relativeTime),
      strategy: strategies.variadic
    }),
    getPluralRules,
    getListFormat: memoize$2(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (ListFormat.bind.apply(ListFormat, __spreadArray$1([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.list),
      strategy: strategies.variadic
    }),
    getDisplayNames: memoize$2(function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new (DisplayNames.bind.apply(DisplayNames, __spreadArray$1([void 0], args, false)))();
    }, {
      cache: createFastMemoizeCache(cache2.displayNames),
      strategy: strategies.variadic
    })
  };
}
function getNamedFormat(formats, type, name, onError) {
  var formatType = formats && formats[type];
  var format2;
  if (formatType) {
    format2 = formatType[name];
  }
  if (format2) {
    return format2;
  }
  onError(new UnsupportedFormatterError("No ".concat(type, " format named: ").concat(name)));
}
function setTimeZoneInOptions(opts, timeZone) {
  return Object.keys(opts).reduce(function(all, k2) {
    all[k2] = __assign$1({ timeZone }, opts[k2]);
    return all;
  }, {});
}
function deepMergeOptions(opts1, opts2) {
  var keys2 = Object.keys(__assign$1(__assign$1({}, opts1), opts2));
  return keys2.reduce(function(all, k2) {
    all[k2] = __assign$1(__assign$1({}, opts1[k2] || {}), opts2[k2] || {});
    return all;
  }, {});
}
function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
  if (!timeZone) {
    return f1;
  }
  var mfFormats = IntlMessageFormat.formats;
  return __assign$1(__assign$1(__assign$1({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
}
function formatMessage$1(_a2, state, messageDescriptor, values2, opts) {
  var locale2 = _a2.locale, formats = _a2.formats, messages = _a2.messages, defaultLocale2 = _a2.defaultLocale, defaultFormats2 = _a2.defaultFormats, fallbackOnEmptyString = _a2.fallbackOnEmptyString, onError = _a2.onError, timeZone = _a2.timeZone, defaultRichTextElements = _a2.defaultRichTextElements;
  if (messageDescriptor === void 0) {
    messageDescriptor = { id: "" };
  }
  var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
  invariant(!!msgId, "[@formatjs/intl] An `id` must be provided to format a message. You can either:\n1. Configure your build toolchain with [babel-plugin-formatjs](https://formatjs.io/docs/tooling/babel-plugin)\nor [@formatjs/ts-transformer](https://formatjs.io/docs/tooling/ts-transformer) OR\n2. Configure your `eslint` config to include [eslint-plugin-formatjs](https://formatjs.io/docs/tooling/linter#enforce-id)\nto autofix this issue");
  var id2 = String(msgId);
  var message = messages && Object.prototype.hasOwnProperty.call(messages, id2) && messages[id2];
  if (Array.isArray(message) && message.length === 1 && message[0].type === TYPE.literal) {
    return message[0].value;
  }
  if (!values2 && message && typeof message === "string" && !defaultRichTextElements) {
    return message.replace(/'\{(.*?)\}'/gi, "{$1}");
  }
  values2 = __assign$1(__assign$1({}, defaultRichTextElements), values2 || {});
  formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
  defaultFormats2 = deepMergeFormatsAndSetTimeZone(defaultFormats2, timeZone);
  if (!message) {
    if (fallbackOnEmptyString === false && message === "") {
      return message;
    }
    if (!defaultMessage || locale2 && locale2.toLowerCase() !== defaultLocale2.toLowerCase()) {
      onError(new MissingTranslationError(messageDescriptor, locale2));
    }
    if (defaultMessage) {
      try {
        var formatter = state.getMessageFormat(defaultMessage, defaultLocale2, defaultFormats2, opts);
        return formatter.format(values2);
      } catch (e2) {
        onError(new MessageFormatError('Error formatting default message for: "'.concat(id2, '", rendering default message verbatim'), locale2, messageDescriptor, e2));
        return typeof defaultMessage === "string" ? defaultMessage : id2;
      }
    }
    return id2;
  }
  try {
    var formatter = state.getMessageFormat(message, locale2, formats, __assign$1({ formatters: state }, opts || {}));
    return formatter.format(values2);
  } catch (e2) {
    onError(new MessageFormatError('Error formatting message: "'.concat(id2, '", using ').concat(defaultMessage ? "default message" : "id", " as fallback."), locale2, messageDescriptor, e2));
  }
  if (defaultMessage) {
    try {
      var formatter = state.getMessageFormat(defaultMessage, defaultLocale2, defaultFormats2, opts);
      return formatter.format(values2);
    } catch (e2) {
      onError(new MessageFormatError('Error formatting the default message for: "'.concat(id2, '", rendering message verbatim'), locale2, messageDescriptor, e2));
    }
  }
  if (typeof message === "string") {
    return message;
  }
  if (typeof defaultMessage === "string") {
    return defaultMessage;
  }
  return id2;
}
var DATE_TIME_FORMAT_OPTIONS = [
  "localeMatcher",
  "formatMatcher",
  "timeZone",
  "hour12",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "hourCycle",
  "dateStyle",
  "timeStyle",
  "calendar",
  "numberingSystem"
];
function getFormatter$2(_a2, type, getDateTimeFormat, options) {
  var locale2 = _a2.locale, formats = _a2.formats, onError = _a2.onError, timeZone = _a2.timeZone;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = __assign$1(__assign$1({}, timeZone && { timeZone }), format2 && getNamedFormat(formats, type, format2, onError));
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
  if (type === "time" && !filteredOptions.hour && !filteredOptions.minute && !filteredOptions.second && !filteredOptions.timeStyle && !filteredOptions.dateStyle) {
    filteredOptions = __assign$1(__assign$1({}, filteredOptions), { hour: "numeric", minute: "numeric" });
  }
  return getDateTimeFormat(locale2, filteredOptions);
}
function formatDate(config2, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "date", getDateTimeFormat, options).format(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date.", e2));
  }
  return String(date);
}
function formatTime(config2, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "time", getDateTimeFormat, options).format(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting time.", e2));
  }
  return String(date);
}
function formatDateTimeRange(config2, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var from = _a2[0], to = _a2[1], _b = _a2[2], options = _b === void 0 ? {} : _b;
  var timeZone = config2.timeZone, locale2 = config2.locale, onError = config2.onError;
  var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, timeZone ? { timeZone } : {});
  try {
    return getDateTimeFormat(locale2, filteredOptions).formatRange(from, to);
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date time range.", e2));
  }
  return String(from);
}
function formatDateToParts(config2, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "date", getDateTimeFormat, options).formatToParts(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting date.", e2));
  }
  return [];
}
function formatTimeToParts(config2, getDateTimeFormat) {
  var _a2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    _a2[_i - 2] = arguments[_i];
  }
  var value = _a2[0], _b = _a2[1], options = _b === void 0 ? {} : _b;
  var date = typeof value === "string" ? new Date(value || 0) : value;
  try {
    return getFormatter$2(config2, "time", getDateTimeFormat, options).formatToParts(date);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting time.", e2));
  }
  return [];
}
var DISPLAY_NAMES_OPTONS = [
  "localeMatcher",
  "style",
  "type",
  "fallback"
];
function formatDisplayName(_a2, getDisplayNames, value, options) {
  var locale2 = _a2.locale, onError = _a2.onError;
  var DisplayNames = Intl.DisplayNames;
  if (!DisplayNames) {
    onError(new FormatError('Intl.DisplayNames is not available in this environment.\nTry polyfilling it using "@formatjs/intl-displaynames"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
  try {
    return getDisplayNames(locale2, filteredOptions).of(value);
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting display name.", e2));
  }
}
var LIST_FORMAT_OPTIONS = [
  "localeMatcher",
  "type",
  "style"
];
var now$2 = Date.now();
function generateToken(i2) {
  return "".concat(now$2, "_").concat(i2, "_").concat(now$2);
}
function formatList(opts, getListFormat, values2, options) {
  if (options === void 0) {
    options = {};
  }
  var results = formatListToParts(opts, getListFormat, values2, options).reduce(function(all, el) {
    var val = el.value;
    if (typeof val !== "string") {
      all.push(val);
    } else if (typeof all[all.length - 1] === "string") {
      all[all.length - 1] += val;
    } else {
      all.push(val);
    }
    return all;
  }, []);
  return results.length === 1 ? results[0] : results;
}
function formatListToParts(_a2, getListFormat, values2, options) {
  var locale2 = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var ListFormat = Intl.ListFormat;
  if (!ListFormat) {
    onError(new FormatError('Intl.ListFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-listformat"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
  try {
    var richValues_1 = {};
    var serializedValues = values2.map(function(v2, i2) {
      if (typeof v2 === "object") {
        var id2 = generateToken(i2);
        richValues_1[id2] = v2;
        return id2;
      }
      return String(v2);
    });
    return getListFormat(locale2, filteredOptions).formatToParts(serializedValues).map(function(part) {
      return part.type === "literal" ? part : __assign$1(__assign$1({}, part), { value: richValues_1[part.value] || part.value });
    });
  } catch (e2) {
    onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting list.", e2));
  }
  return values2;
}
var PLURAL_FORMAT_OPTIONS = [
  "localeMatcher",
  "type"
];
function formatPlural(_a2, getPluralRules, value, options) {
  var locale2 = _a2.locale, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  if (!Intl.PluralRules) {
    onError(new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n', ErrorCode.MISSING_INTL_API));
  }
  var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
  try {
    return getPluralRules(locale2, filteredOptions).select(value);
  } catch (e2) {
    onError(new IntlFormatError("Error formatting plural.", locale2, e2));
  }
  return "other";
}
var RELATIVE_TIME_FORMAT_OPTIONS = ["numeric", "style"];
function getFormatter$1(_a2, getRelativeTimeFormat, options) {
  var locale2 = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = !!format2 && getNamedFormat(formats, "relative", format2, onError) || {};
  var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
  return getRelativeTimeFormat(locale2, filteredOptions);
}
function formatRelativeTime(config2, getRelativeTimeFormat, value, unit, options) {
  if (options === void 0) {
    options = {};
  }
  if (!unit) {
    unit = "second";
  }
  var RelativeTimeFormat = Intl.RelativeTimeFormat;
  if (!RelativeTimeFormat) {
    config2.onError(new FormatError('Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using "@formatjs/intl-relativetimeformat"\n', ErrorCode.MISSING_INTL_API));
  }
  try {
    return getFormatter$1(config2, getRelativeTimeFormat, options).format(value, unit);
  } catch (e2) {
    config2.onError(new IntlFormatError("Error formatting relative time.", config2.locale, e2));
  }
  return String(value);
}
var NUMBER_FORMAT_OPTIONS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "unit",
  "unitDisplay",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "currencyDisplay",
  "currencySign",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "numberingSystem"
];
function getFormatter(_a2, getNumberFormat, options) {
  var locale2 = _a2.locale, formats = _a2.formats, onError = _a2.onError;
  if (options === void 0) {
    options = {};
  }
  var format2 = options.format;
  var defaults = format2 && getNamedFormat(formats, "number", format2, onError) || {};
  var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
  return getNumberFormat(locale2, filteredOptions);
}
function formatNumber(config2, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config2, getNumberFormat, options).format(value);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting number.", e2));
  }
  return String(value);
}
function formatNumberToParts(config2, getNumberFormat, value, options) {
  if (options === void 0) {
    options = {};
  }
  try {
    return getFormatter(config2, getNumberFormat, options).formatToParts(value);
  } catch (e2) {
    config2.onError(new IntlError(IntlErrorCode.FORMAT_ERROR, "Error formatting number.", e2));
  }
  return [];
}
function messagesContainString(messages) {
  var firstMessage = messages ? messages[Object.keys(messages)[0]] : void 0;
  return typeof firstMessage === "string";
}
function verifyConfigMessages(config2) {
  if (config2.defaultRichTextElements && messagesContainString(config2.messages || {})) {
    console.warn('[@formatjs/intl] "defaultRichTextElements" was specified but "message" was not pre-compiled. \nPlease consider using "@formatjs/cli" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution');
  }
}
function createIntl$1(config2, cache2) {
  var formatters2 = createFormatters(cache2);
  var resolvedConfig = __assign$1(__assign$1({}, DEFAULT_INTL_CONFIG$1), config2);
  var locale2 = resolvedConfig.locale, defaultLocale2 = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
  if (!locale2) {
    if (onError) {
      onError(new InvalidConfigError('"locale" was not configured, using "'.concat(defaultLocale2, '" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details')));
    }
    resolvedConfig.locale = resolvedConfig.defaultLocale || "en";
  } else if (!Intl.NumberFormat.supportedLocalesOf(locale2).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale2, '" in Intl.NumberFormat. Using default locale: "').concat(defaultLocale2, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  } else if (!Intl.DateTimeFormat.supportedLocalesOf(locale2).length && onError) {
    onError(new MissingDataError('Missing locale data for locale: "'.concat(locale2, '" in Intl.DateTimeFormat. Using default locale: "').concat(defaultLocale2, '" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details')));
  }
  verifyConfigMessages(resolvedConfig);
  return __assign$1(__assign$1({}, resolvedConfig), { formatters: formatters2, formatNumber: formatNumber.bind(null, resolvedConfig, formatters2.getNumberFormat), formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters2.getNumberFormat), formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters2.getRelativeTimeFormat), formatDate: formatDate.bind(null, resolvedConfig, formatters2.getDateTimeFormat), formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters2.getDateTimeFormat), formatTime: formatTime.bind(null, resolvedConfig, formatters2.getDateTimeFormat), formatDateTimeRange: formatDateTimeRange.bind(null, resolvedConfig, formatters2.getDateTimeFormat), formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters2.getDateTimeFormat), formatPlural: formatPlural.bind(null, resolvedConfig, formatters2.getPluralRules), formatMessage: formatMessage$1.bind(null, resolvedConfig, formatters2), formatList: formatList.bind(null, resolvedConfig, formatters2.getListFormat), formatListToParts: formatListToParts.bind(null, resolvedConfig, formatters2.getListFormat), formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters2.getDisplayNames) });
}
function invariantIntlContext(intl) {
  invariant(intl, "[React Intl] Could not find required `intl` object. <IntlProvider> needs to exist in the component ancestry.");
}
var DEFAULT_INTL_CONFIG = __assign$1(__assign$1({}, DEFAULT_INTL_CONFIG$1), { textComponent: React$6.Fragment });
function assignUniqueKeysToParts(formatXMLElementFn) {
  return function(parts) {
    return formatXMLElementFn(React$6.Children.toArray(parts));
  };
}
function shallowEqual$1(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (!objA || !objB) {
    return false;
  }
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;
  if (bKeys.length !== len) {
    return false;
  }
  for (var i2 = 0; i2 < len; i2++) {
    var key = aKeys[i2];
    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
      return false;
    }
  }
  return true;
}
var IntlContext = React$6.createContext(null);
IntlContext.Consumer;
var IntlProvider$2 = IntlContext.Provider;
var Provider$2 = IntlProvider$2;
var Context = IntlContext;
function useIntl() {
  var intl = React$6.useContext(Context);
  invariantIntlContext(intl);
  return intl;
}
function processIntlConfig(config2) {
  return {
    locale: config2.locale,
    timeZone: config2.timeZone,
    fallbackOnEmptyString: config2.fallbackOnEmptyString,
    formats: config2.formats,
    textComponent: config2.textComponent,
    messages: config2.messages,
    defaultLocale: config2.defaultLocale,
    defaultFormats: config2.defaultFormats,
    onError: config2.onError,
    wrapRichTextChunksInFragment: config2.wrapRichTextChunksInFragment,
    defaultRichTextElements: config2.defaultRichTextElements
  };
}
function assignUniqueKeysToFormatXMLElementFnArgument(values2) {
  if (!values2) {
    return values2;
  }
  return Object.keys(values2).reduce(function(acc, k2) {
    var v2 = values2[k2];
    acc[k2] = isFormatXMLElementFn(v2) ? assignUniqueKeysToParts(v2) : v2;
    return acc;
  }, {});
}
var formatMessage = function(config2, formatters2, descriptor, rawValues) {
  var rest = [];
  for (var _i = 4; _i < arguments.length; _i++) {
    rest[_i - 4] = arguments[_i];
  }
  var values2 = assignUniqueKeysToFormatXMLElementFnArgument(rawValues);
  var chunks2 = formatMessage$1.apply(void 0, __spreadArray$1([
    config2,
    formatters2,
    descriptor,
    values2
  ], rest, false));
  if (Array.isArray(chunks2)) {
    return React$6.Children.toArray(chunks2);
  }
  return chunks2;
};
var createIntl = function(_a2, cache2) {
  var rawDefaultRichTextElements = _a2.defaultRichTextElements, config2 = __rest(_a2, ["defaultRichTextElements"]);
  var defaultRichTextElements = assignUniqueKeysToFormatXMLElementFnArgument(rawDefaultRichTextElements);
  var coreIntl = createIntl$1(__assign$1(__assign$1(__assign$1({}, DEFAULT_INTL_CONFIG), config2), { defaultRichTextElements }), cache2);
  return __assign$1(__assign$1({}, coreIntl), { formatMessage: formatMessage.bind(null, {
    locale: coreIntl.locale,
    timeZone: coreIntl.timeZone,
    fallbackOnEmptyString: coreIntl.fallbackOnEmptyString,
    formats: coreIntl.formats,
    defaultLocale: coreIntl.defaultLocale,
    defaultFormats: coreIntl.defaultFormats,
    messages: coreIntl.messages,
    onError: coreIntl.onError,
    defaultRichTextElements
  }, coreIntl.formatters) });
};
var IntlProvider = function(_super) {
  __extends$1(IntlProvider2, _super);
  function IntlProvider2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.cache = createIntlCache();
    _this.state = {
      cache: _this.cache,
      intl: createIntl(processIntlConfig(_this.props), _this.cache),
      prevConfig: processIntlConfig(_this.props)
    };
    return _this;
  }
  IntlProvider2.getDerivedStateFromProps = function(props, _a2) {
    var prevConfig = _a2.prevConfig, cache2 = _a2.cache;
    var config2 = processIntlConfig(props);
    if (!shallowEqual$1(prevConfig, config2)) {
      return {
        intl: createIntl(config2, cache2),
        prevConfig: config2
      };
    }
    return null;
  };
  IntlProvider2.prototype.render = function() {
    invariantIntlContext(this.state.intl);
    return React$6.createElement(Provider$2, { value: this.state.intl }, this.props.children);
  };
  IntlProvider2.displayName = "IntlProvider";
  IntlProvider2.defaultProps = DEFAULT_INTL_CONFIG;
  return IntlProvider2;
}(React$6.PureComponent);
var IntlProvider$1 = IntlProvider;
function areEqual(prevProps, nextProps) {
  var values2 = prevProps.values, otherProps = __rest(prevProps, ["values"]);
  var nextValues = nextProps.values, nextOtherProps = __rest(nextProps, ["values"]);
  return shallowEqual$1(nextValues, values2) && shallowEqual$1(otherProps, nextOtherProps);
}
function FormattedMessage(props) {
  var intl = useIntl();
  var formatMessage2 = intl.formatMessage, _a2 = intl.textComponent, Text = _a2 === void 0 ? React$6.Fragment : _a2;
  var id2 = props.id, description = props.description, defaultMessage = props.defaultMessage, values2 = props.values, children = props.children, _b = props.tagName, Component2 = _b === void 0 ? Text : _b, ignoreTag = props.ignoreTag;
  var descriptor = { id: id2, description, defaultMessage };
  var nodes = formatMessage2(descriptor, values2, {
    ignoreTag
  });
  if (typeof children === "function") {
    return children(Array.isArray(nodes) ? nodes : [nodes]);
  }
  if (Component2) {
    return React$6.createElement(Component2, null, React$6.Children.toArray(nodes));
  }
  return React$6.createElement(React$6.Fragment, null, nodes);
}
FormattedMessage.displayName = "FormattedMessage";
var MemoizedFormattedMessage = React$6.memo(FormattedMessage, areEqual);
MemoizedFormattedMessage.displayName = "MemoizedFormattedMessage";
var FormattedMessage$1 = MemoizedFormattedMessage;
const GridApiContext = /* @__PURE__ */ React$6.createContext(void 0);
function useGridApiContext() {
  const apiRef = React$6.useContext(GridApiContext);
  if (apiRef === void 0) {
    throw new Error(["MUI: Could not find the data grid context.", "It looks like you rendered your component outside of a DataGrid or DataGridPro parent component.", "This can also happen if you are bundling multiple versions of the data grid."].join("\n"));
  }
  return apiRef;
}
const GridRootPropsContext = /* @__PURE__ */ React$6.createContext(void 0);
const useGridRootProps = () => {
  const contextValue = React$6.useContext(GridRootPropsContext);
  if (!contextValue) {
    throw new Error("MUI: useGridRootProps should only be used inside the DataGrid/DataGridPro component.");
  }
  return contextValue;
};
var propTypes$3 = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes$3.exports = factoryWithThrowingShims();
}
var PropTypes$5 = propTypes$3.exports;
function chainPropTypes(propType1, propType2) {
  {
    return () => null;
  }
}
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
const useEnhancedEffect = typeof window !== "undefined" ? React$6.useLayoutEffect : React$6.useEffect;
var useEnhancedEffect$1 = useEnhancedEffect;
let globalId$1 = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React$6.useState(idOverride);
  const id2 = idOverride || defaultId;
  React$6.useEffect(() => {
    if (defaultId == null) {
      globalId$1 += 1;
      setDefaultId(`mui-${globalId$1}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$6["useId"];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
var GridEvents;
(function(GridEvents2) {
  GridEvents2["resize"] = "resize";
  GridEvents2["debouncedResize"] = "debouncedResize";
  GridEvents2["viewportInnerSizeChange"] = "viewportInnerSizeChange";
  GridEvents2["componentError"] = "componentError";
  GridEvents2["unmount"] = "unmount";
  GridEvents2["cellModeChange"] = "cellModeChange";
  GridEvents2["cellClick"] = "cellClick";
  GridEvents2["cellDoubleClick"] = "cellDoubleClick";
  GridEvents2["cellMouseDown"] = "cellMouseDown";
  GridEvents2["cellMouseUp"] = "cellMouseUp";
  GridEvents2["cellKeyDown"] = "cellKeyDown";
  GridEvents2["cellFocusIn"] = "cellFocusIn";
  GridEvents2["cellFocusOut"] = "cellFocusOut";
  GridEvents2["cellDragEnter"] = "cellDragEnter";
  GridEvents2["cellDragOver"] = "cellDragOver";
  GridEvents2["editCellPropsChange"] = "editCellPropsChange";
  GridEvents2["cellEditCommit"] = "cellEditCommit";
  GridEvents2["cellEditStart"] = "cellEditStart";
  GridEvents2["cellEditStop"] = "cellEditStop";
  GridEvents2["rowEditStart"] = "rowEditStart";
  GridEvents2["rowEditStop"] = "rowEditStop";
  GridEvents2["rowEditCommit"] = "rowEditCommit";
  GridEvents2["cellNavigationKeyDown"] = "cellNavigationKeyDown";
  GridEvents2["rowClick"] = "rowClick";
  GridEvents2["rowDoubleClick"] = "rowDoubleClick";
  GridEvents2["rowMouseEnter"] = "rowMouseEnter";
  GridEvents2["rowMouseLeave"] = "rowMouseLeave";
  GridEvents2["editRowsModelChange"] = "editRowsModelChange";
  GridEvents2["columnHeaderBlur"] = "columnHeaderBlur";
  GridEvents2["columnHeaderFocus"] = "columnHeaderFocus";
  GridEvents2["columnHeaderNavigationKeyDown"] = "columnHeaderNavigationKeyDown";
  GridEvents2["columnHeaderKeyDown"] = "columnHeaderKeyDown";
  GridEvents2["columnHeaderClick"] = "columnHeaderClick";
  GridEvents2["columnHeaderDoubleClick"] = "columnHeaderDoubleClick";
  GridEvents2["columnHeaderOver"] = "columnHeaderOver";
  GridEvents2["columnHeaderOut"] = "columnHeaderOut";
  GridEvents2["columnHeaderEnter"] = "columnHeaderEnter";
  GridEvents2["columnHeaderLeave"] = "columnHeaderLeave";
  GridEvents2["columnHeaderDragStart"] = "columnHeaderDragStart";
  GridEvents2["columnHeaderDragOver"] = "columnHeaderDragOver";
  GridEvents2["columnHeaderDragEnter"] = "columnHeaderDragEnter";
  GridEvents2["columnHeaderDragEnd"] = "columnHeaderDragEnd";
  GridEvents2["selectionChange"] = "selectionChange";
  GridEvents2["headerSelectionCheckboxChange"] = "headerSelectionCheckboxChange";
  GridEvents2["rowSelectionCheckboxChange"] = "rowSelectionCheckboxChange";
  GridEvents2["pageChange"] = "pageChange";
  GridEvents2["pageSizeChange"] = "pageSizeChange";
  GridEvents2["rowGroupingModelChange"] = "rowGroupingModelChange";
  GridEvents2["rowsScroll"] = "rowsScroll";
  GridEvents2["rowsScrollEnd"] = "rowsScrollEnd";
  GridEvents2["columnSeparatorMouseDown"] = "columnSeparatorMouseDown";
  GridEvents2["columnResize"] = "columnResize";
  GridEvents2["columnWidthChange"] = "columnWidthChange";
  GridEvents2["columnResizeStart"] = "columnResizeStart";
  GridEvents2["columnResizeStop"] = "columnResizeStop";
  GridEvents2["columnOrderChange"] = "columnOrderChange";
  GridEvents2["rowsSet"] = "rowsSet";
  GridEvents2["rowExpansionChange"] = "rowExpansionChange";
  GridEvents2["visibleRowsSet"] = "visibleRowsSet";
  GridEvents2["columnsChange"] = "columnsChange";
  GridEvents2["detailPanelsExpandedRowIdsChange"] = "detailPanelsExpandedRowIdsChange";
  GridEvents2["pinnedColumnsChange"] = "pinnedColumnsChange";
  GridEvents2["preProcessorRegister"] = "preProcessorRegister";
  GridEvents2["preProcessorUnregister"] = "preProcessorUnregister";
  GridEvents2["rowGroupsPreProcessingChange"] = "rowGroupsPreProcessingChange";
  GridEvents2["sortModelChange"] = "sortModelChange";
  GridEvents2["filterModelChange"] = "filterModelChange";
  GridEvents2["columnVisibilityModelChange"] = "columnVisibilityModelChange";
  GridEvents2["stateChange"] = "stateChange";
  GridEvents2["columnVisibilityChange"] = "columnVisibilityChange";
  GridEvents2["virtualScrollerContentSizeChange"] = "virtualScrollerContentSizeChange";
})(GridEvents || (GridEvents = {}));
function getDataGridUtilityClass(slot) {
  return generateUtilityClass$1("MuiDataGrid", slot);
}
const gridClasses = generateUtilityClasses$1("MuiDataGrid", ["actionsCell", "autoHeight", "booleanCell", "cell--editable", "cell--editing", "cell--textCenter", "cell--textLeft", "cell--textRight", "cell--withRenderer", "cell", "cellContent", "cellCheckbox", "checkboxInput", "columnHeader--alignCenter", "columnHeader--alignLeft", "columnHeader--alignRight", "columnHeader--dragging", "columnHeader--moving", "columnHeader--numeric", "columnHeader--sortable", "columnHeader--sorted", "columnHeader", "columnHeaderCheckbox", "columnHeaderDraggableContainer", "columnHeaderDropZone", "columnHeaderTitle", "columnHeaderTitleContainer", "columnHeaderTitleContainerContent", "columnHeaders", "columnHeadersInner", "columnHeadersInner--scrollable", "columnSeparator--resizable", "columnSeparator--resizing", "columnSeparator--sideLeft", "columnSeparator--sideRight", "columnSeparator", "columnsPanel", "columnsPanelRow", "detailPanel", "detailPanels", "detailPanelToggleCell", "detailPanelToggleCell--expanded", "panel", "panelHeader", "panelWrapper", "panelContent", "panelFooter", "paper", "editBooleanCell", "editInputCell", "filterForm", "filterFormDeleteIcon", "filterFormLinkOperatorInput", "filterFormColumnInput", "filterFormOperatorInput", "filterFormValueInput", "filterIcon", "footerContainer", "iconButtonContainer", "iconSeparator", "main", "menu", "menuIcon", "menuIconButton", "menuOpen", "menuList", "overlay", "root", "row--editable", "row--editing", "row", "row--lastVisible", "rowCount", "scrollArea--left", "scrollArea--right", "scrollArea", "selectedRowCount", "sortIcon", "toolbarContainer", "toolbarFilterList", "virtualScroller", "virtualScrollerContent", "virtualScrollerContent--overflowed", "virtualScrollerRenderZone", "pinnedColumns", "pinnedColumns--left", "pinnedColumns--right", "pinnedColumnHeaders", "pinnedColumnHeaders--left", "pinnedColumnHeaders--right", "withBorder", "treeDataGroupingCell", "treeDataGroupingCellToggle", "groupingCriteriaCell", "groupingCriteriaCellToggle"]);
const useUtilityClasses$E = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["main"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridMainContainerRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "Main",
  overridesResolver: (props, styles) => styles.main
})(() => ({
  position: "relative",
  flexGrow: 1,
  display: "flex",
  flexDirection: "column",
  overflow: "hidden"
}));
function GridMainContainer(props) {
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$E(ownerState);
  return /* @__PURE__ */ jsx(GridMainContainerRoot, {
    className: classes2.root,
    children: props.children
  });
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createDetectElementResize(nonce, hostWindow) {
  var resetTriggers = function resetTriggers2(element) {
    var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + "px";
    expandChild.style.height = expand.offsetHeight + 1 + "px";
    expand.scrollLeft = expand.scrollWidth;
    expand.scrollTop = expand.scrollHeight;
  };
  var checkTriggers = function checkTriggers2(element) {
    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
  };
  var scrollListener = function scrollListener2(e2) {
    if (e2.target.className.indexOf("contract-trigger") < 0 && e2.target.className.indexOf("expand-trigger") < 0) {
      return;
    }
    var element = this;
    resetTriggers(this);
    if (this.__resizeRAF__) {
      hostWindow.cancelAnimationFrame(this.__resizeRAF__);
    }
    this.__resizeRAF__ = hostWindow.requestAnimationFrame(function() {
      if (checkTriggers(element)) {
        element.__resizeLast__.width = element.offsetWidth;
        element.__resizeLast__.height = element.offsetHeight;
        element.__resizeListeners__.forEach(function(fn) {
          fn.call(element, e2);
        });
      }
    });
  };
  var animation = false, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "";
  {
    var elm = document.createElement("fakeelement");
    if (elm.style.animationName !== void 0) {
      animation = true;
    }
    if (animation === false) {
      for (var i2 = 0; i2 < domPrefixes.length; i2++) {
        if (elm.style[domPrefixes[i2] + "AnimationName"] !== void 0) {
          pfx = domPrefixes[i2];
          keyframeprefix = "-" + pfx.toLowerCase() + "-";
          animationstartevent = startEvents[i2];
          animation = true;
          break;
        }
      }
    }
  }
  var animationName = "resizeanim";
  var animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
  var animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  var createStyles = function createStyles2(doc) {
    if (!doc.getElementById("muiDetectElementResize")) {
      var css2 = (animationKeyframes ? animationKeyframes : "") + ".Mui-resizeTriggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .Mui-resizeTriggers, .Mui-resizeTriggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .Mui-resizeTriggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style2 = doc.createElement("style");
      style2.id = "muiDetectElementResize";
      style2.type = "text/css";
      if (nonce != null) {
        style2.setAttribute("nonce", nonce);
      }
      if (style2.styleSheet) {
        style2.styleSheet.cssText = css2;
      } else {
        style2.appendChild(doc.createTextNode(css2));
      }
      head.appendChild(style2);
    }
  };
  var addResizeListener = function addResizeListener2(element, fn) {
    if (!element.__resizeTriggers__) {
      var doc = element.ownerDocument;
      var elementStyle = hostWindow.getComputedStyle(element);
      if (elementStyle && elementStyle.position == "static") {
        element.style.position = "relative";
      }
      createStyles(doc);
      element.__resizeLast__ = {};
      element.__resizeListeners__ = [];
      (element.__resizeTriggers__ = doc.createElement("div")).className = "Mui-resizeTriggers";
      element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
      element.appendChild(element.__resizeTriggers__);
      resetTriggers(element);
      element.addEventListener("scroll", scrollListener, true);
      if (animationstartevent) {
        element.__resizeTriggers__.__animationListener__ = function animationListener(e2) {
          if (e2.animationName == animationName) {
            resetTriggers(element);
          }
        };
        element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
      }
    }
    element.__resizeListeners__.push(fn);
  };
  var removeResizeListener = function removeResizeListener2(element, fn) {
    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
    if (!element.__resizeListeners__.length) {
      element.removeEventListener("scroll", scrollListener, true);
      if (element.__resizeTriggers__.__animationListener__) {
        element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__);
        element.__resizeTriggers__.__animationListener__ = null;
      }
      try {
        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
      } catch (e2) {
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}
const _excluded$$ = ["children", "defaultHeight", "defaultWidth", "disableHeight", "disableWidth", "nonce", "onResize", "style"];
const GridAutoSizer = /* @__PURE__ */ React$6.forwardRef(function AutoSizer(props, ref) {
  const {
    children,
    defaultHeight = null,
    defaultWidth = null,
    disableHeight = false,
    disableWidth = false,
    nonce,
    onResize,
    style: style2
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$$);
  const [state, setState] = React$6.useState({
    height: defaultHeight,
    width: defaultWidth
  });
  const rootRef = React$6.useRef(null);
  const parentElement = React$6.useRef(null);
  const handleResize = useEventCallback$1(() => {
    if (parentElement.current) {
      const height = parentElement.current.offsetHeight || 0;
      const width = parentElement.current.offsetWidth || 0;
      const win = ownerWindow(parentElement.current);
      const computedStyle = win.getComputedStyle(parentElement.current);
      const paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
      const paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
      const paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
      const paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
      const newHeight = height - paddingTop - paddingBottom;
      const newWidth = width - paddingLeft - paddingRight;
      if (!disableHeight && state.height !== newHeight || !disableWidth && state.width !== newWidth) {
        setState({
          height: newHeight,
          width: newWidth
        });
        if (onResize) {
          onResize({
            height: newHeight,
            width: newWidth
          });
        }
      }
    }
  });
  unstable_useEnhancedEffect(() => {
    var _parentElement$curren;
    parentElement.current = rootRef.current.parentElement;
    if (!parentElement) {
      return void 0;
    }
    const win = ownerWindow((_parentElement$curren = parentElement.current) != null ? _parentElement$curren : void 0);
    const detectElementResize = createDetectElementResize(nonce, win);
    detectElementResize.addResizeListener(parentElement.current, handleResize);
    handleResize();
    return () => {
      detectElementResize.removeResizeListener(parentElement.current, handleResize);
    };
  }, [nonce, handleResize]);
  const outerStyle = {
    overflow: "visible"
  };
  const childParams = {};
  if (!disableHeight) {
    outerStyle.height = 0;
    childParams.height = state.height;
  }
  if (!disableWidth) {
    outerStyle.width = 0;
    childParams.width = state.width;
  }
  const handleRef = useForkRef(rootRef, ref);
  return /* @__PURE__ */ jsx("div", _extends$5({
    ref: handleRef,
    style: _extends$5({}, outerStyle, style2)
  }, other, {
    children: state.height === null && state.width === null ? null : children(childParams)
  }));
});
function isOutputSelector(selector) {
  return selector.cache;
}
const useGridSelector = (apiRef, selector) => {
  if (isOutputSelector(selector)) {
    return selector(apiRef);
  }
  return selector(apiRef.current.state);
};
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  var entries = [];
  function get(key) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals(key, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get,
    put,
    getEntries,
    clear
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a2, b2) {
  return a2 === b2;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
      return false;
    }
    var length = prev.length;
    for (var i2 = 0; i2 < length; i2++) {
      if (!equalityCheck(prev[i2], next[i2])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache2 = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache2.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache2.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache2.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache2.clear();
  };
  return memoized;
}
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize2) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize2.apply(void 0, [function() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector = memoize2(function() {
      var params = [];
      var length = dependencies.length;
      for (var i2 = 0; i2 < length; i2++) {
        params.push(dependencies[i2].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  };
  return createSelector2;
}
var createSelector$1 = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
const cache = {};
const createSelector = (...args) => {
  const selector = (...selectorArgs) => {
    const [stateOrApiRef, instanceId] = selectorArgs;
    const isApiRef = !!stateOrApiRef.current;
    const cacheKey = isApiRef ? stateOrApiRef.current.instanceId : instanceId != null ? instanceId : "default";
    const state = isApiRef ? stateOrApiRef.current.state : stateOrApiRef;
    if (cache[cacheKey] && cache[cacheKey].get(args)) {
      return cache[cacheKey].get(args)(state, cacheKey);
    }
    const newSelector = createSelector$1(...args);
    if (!cache[cacheKey]) {
      cache[cacheKey] = /* @__PURE__ */ new Map();
    }
    cache[cacheKey].set(args, newSelector);
    return newSelector(state, cacheKey);
  };
  selector.cache = cache;
  return selector;
};
const gridRowsStateSelector = (state) => state.rows;
const gridRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalRowCount);
const gridTopLevelRowCountSelector = createSelector(gridRowsStateSelector, (rows) => rows.totalTopLevelRowCount);
const gridRowsLookupSelector = createSelector(gridRowsStateSelector, (rows) => rows.idRowsLookup);
const gridRowTreeSelector = createSelector(gridRowsStateSelector, (rows) => rows.tree);
const gridRowGroupingNameSelector = createSelector(gridRowsStateSelector, (rows) => rows.groupingName);
const gridRowTreeDepthSelector = createSelector(gridRowsStateSelector, (rows) => rows.treeDepth);
const gridRowIdsSelector = createSelector(gridRowsStateSelector, (rows) => rows.ids);
const gridSortingStateSelector = (state) => state.sorting;
const gridSortedRowIdsSelector = createSelector(gridSortingStateSelector, (sortingState) => sortingState.sortedRows);
const gridSortedRowEntriesSelector = createSelector(gridSortedRowIdsSelector, gridRowsLookupSelector, (sortedIds, idRowsLookup) => sortedIds.map((id2) => ({
  id: id2,
  model: idRowsLookup[id2]
})));
const gridSortModelSelector = createSelector(gridSortingStateSelector, (sorting) => sorting.sortModel);
const gridSortColumnLookupSelector = createSelector(gridSortModelSelector, (sortModel) => {
  const result = sortModel.reduce((res, sortItem, index) => {
    res[sortItem.field] = {
      sortDirection: sortItem.sort,
      sortIndex: sortModel.length > 1 ? index + 1 : void 0
    };
    return res;
  }, {});
  return result;
});
const gridColumnsSelector = (state) => state.columns;
const gridColumnFieldsSelector = createSelector(gridColumnsSelector, (columnsState) => columnsState.all);
const gridColumnLookupSelector = createSelector(gridColumnsSelector, (columnsState) => columnsState.lookup);
const gridColumnDefinitionsSelector = createSelector(gridColumnFieldsSelector, gridColumnLookupSelector, (allFields, lookup) => allFields.map((field) => lookup[field]));
const gridColumnVisibilityModelSelector = createSelector(gridColumnsSelector, (columnsState) => columnsState.columnVisibilityModel);
const gridVisibleColumnDefinitionsSelector = createSelector(gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector, (columns, columnVisibilityModel) => columns.filter((column) => columnVisibilityModel[column.field] !== false));
createSelector(gridVisibleColumnDefinitionsSelector, (visibleColumns) => visibleColumns.map((column) => column.field));
const gridColumnPositionsSelector = createSelector(gridVisibleColumnDefinitionsSelector, (visibleColumns) => {
  const positions = [];
  let currentPosition = 0;
  for (let i2 = 0; i2 < visibleColumns.length; i2 += 1) {
    positions.push(currentPosition);
    currentPosition += visibleColumns[i2].computedWidth;
  }
  return positions;
});
const gridColumnsTotalWidthSelector = createSelector(gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector, (visibleColumns, positions) => {
  const colCount = visibleColumns.length;
  if (colCount === 0) {
    return 0;
  }
  return positions[colCount - 1] + visibleColumns[colCount - 1].computedWidth;
});
const gridFilterableColumnDefinitionsSelector = createSelector(gridColumnDefinitionsSelector, (columns) => columns.filter((col) => col.filterable));
const gridFilterableColumnLookupSelector = createSelector(gridColumnDefinitionsSelector, (columns) => columns.reduce((acc, col) => {
  if (col.filterable) {
    acc[col.field] = col;
  }
  return acc;
}, {}));
createSelector(gridFilterableColumnDefinitionsSelector, (columns) => columns.map((col) => col.field));
createSelector(gridVisibleColumnDefinitionsSelector, (visibleColumns) => visibleColumns.length);
const gridColumnsMetaSelector = createSelector(gridColumnPositionsSelector, gridColumnsTotalWidthSelector, (positions, totalWidth) => ({
  totalWidth,
  positions
}));
const gridFilterStateSelector = (state) => state.filter;
const gridFilterModelSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filterModel);
const gridVisibleRowsLookupSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.visibleRowsLookup);
const gridFilteredRowsLookupSelector = createSelector(gridFilterStateSelector, (filterState) => filterState.filteredRowsLookup);
createSelector(gridFilterStateSelector, (filterState) => filterState.filteredDescendantCountLookup);
const gridVisibleSortedRowEntriesSelector = createSelector(gridVisibleRowsLookupSelector, gridSortedRowEntriesSelector, (visibleRowsLookup, sortedRows) => sortedRows.filter((row) => visibleRowsLookup[row.id] !== false));
const gridVisibleSortedRowIdsSelector = createSelector(gridVisibleSortedRowEntriesSelector, (visibleSortedRowEntries) => visibleSortedRowEntries.map((row) => row.id));
const gridFilteredSortedRowEntriesSelector = createSelector(gridFilteredRowsLookupSelector, gridSortedRowEntriesSelector, (filteredRowsLookup, sortedRows) => sortedRows.filter((row) => filteredRowsLookup[row.id] !== false));
const gridFilteredSortedRowIdsSelector = createSelector(gridFilteredSortedRowEntriesSelector, (filteredSortedRowEntries) => filteredSortedRowEntries.map((row) => row.id));
const gridVisibleSortedTopLevelRowEntriesSelector = createSelector(gridVisibleSortedRowEntriesSelector, gridRowTreeSelector, gridRowTreeDepthSelector, (visibleSortedRows, rowTree, rowTreeDepth) => {
  if (rowTreeDepth < 2) {
    return visibleSortedRows;
  }
  return visibleSortedRows.filter((row) => {
    var _rowTree$row$id;
    return ((_rowTree$row$id = rowTree[row.id]) == null ? void 0 : _rowTree$row$id.depth) === 0;
  });
});
const gridVisibleRowCountSelector = createSelector(gridVisibleSortedRowEntriesSelector, (visibleSortedRows) => visibleSortedRows.length);
const gridVisibleTopLevelRowCountSelector = createSelector(gridVisibleSortedTopLevelRowEntriesSelector, (visibleSortedTopLevelRows) => visibleSortedTopLevelRows.length);
const gridFilterActiveItemsSelector = createSelector(gridFilterModelSelector, gridColumnLookupSelector, (filterModel, columnLookup) => {
  var _filterModel$items;
  return (_filterModel$items = filterModel.items) == null ? void 0 : _filterModel$items.filter((item) => {
    var _column$filterOperato, _item$value;
    if (!item.columnField) {
      return false;
    }
    const column = columnLookup[item.columnField];
    if (!(column != null && column.filterOperators) || (column == null ? void 0 : (_column$filterOperato = column.filterOperators) == null ? void 0 : _column$filterOperato.length) === 0) {
      return false;
    }
    const filterOperator = column.filterOperators.find((operator) => operator.value === item.operatorValue);
    if (!filterOperator) {
      return false;
    }
    return !filterOperator.InputComponent || item.value != null && ((_item$value = item.value) == null ? void 0 : _item$value.toString()) !== "";
  });
});
const gridFilterActiveItemsLookupSelector = createSelector(gridFilterActiveItemsSelector, (activeFilters) => {
  const result = activeFilters.reduce((res, filterItem) => {
    if (!res[filterItem.columnField]) {
      res[filterItem.columnField] = [filterItem];
    } else {
      res[filterItem.columnField].push(filterItem);
    }
    return res;
  }, {});
  return result;
});
const gridDensitySelector = (state) => state.density;
createSelector(gridDensitySelector, (density) => density.value);
const gridDensityRowHeightSelector = createSelector(gridDensitySelector, (density) => density.rowHeight);
const gridDensityHeaderHeightSelector = createSelector(gridDensitySelector, (density) => density.headerHeight);
const gridDensityFactorSelector = createSelector(gridDensitySelector, (density) => density.factor);
function GridOverlayWrapper(props) {
  var _viewportInnerSize$he, _viewportInnerSize$wi;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);
  const [viewportInnerSize, setViewportInnerSize] = React$6.useState(() => {
    var _apiRef$current$getRo, _apiRef$current$getRo2;
    return (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.viewportInnerSize) != null ? _apiRef$current$getRo : null;
  });
  const handleViewportSizeChange = React$6.useCallback(() => {
    var _apiRef$current$getRo3, _apiRef$current$getRo4;
    setViewportInnerSize((_apiRef$current$getRo3 = (_apiRef$current$getRo4 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo4.viewportInnerSize) != null ? _apiRef$current$getRo3 : null);
  }, [apiRef]);
  unstable_useEnhancedEffect(() => {
    return apiRef.current.subscribeEvent(GridEvents.viewportInnerSizeChange, handleViewportSizeChange);
  }, [apiRef, handleViewportSizeChange]);
  let height = (_viewportInnerSize$he = viewportInnerSize == null ? void 0 : viewportInnerSize.height) != null ? _viewportInnerSize$he : 0;
  if (rootProps.autoHeight && height === 0) {
    height = "auto";
  }
  if (!viewportInnerSize) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", _extends$5({
    style: {
      height,
      width: (_viewportInnerSize$wi = viewportInnerSize == null ? void 0 : viewportInnerSize.width) != null ? _viewportInnerSize$wi : 0,
      position: "absolute",
      top: headerHeight,
      bottom: height === "auto" ? 0 : void 0
    }
  }, props));
}
function GridOverlays() {
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalRowCount = useGridSelector(apiRef, gridRowCountSelector);
  const visibleRowCount = useGridSelector(apiRef, gridVisibleRowCountSelector);
  const showNoRowsOverlay = !rootProps.loading && totalRowCount === 0;
  const showNoResultsOverlay = !rootProps.loading && totalRowCount > 0 && visibleRowCount === 0;
  let overlay = null;
  if (showNoRowsOverlay) {
    var _rootProps$components;
    overlay = /* @__PURE__ */ jsx(rootProps.components.NoRowsOverlay, _extends$5({}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.noRowsOverlay));
  }
  if (showNoResultsOverlay) {
    var _rootProps$components2;
    overlay = /* @__PURE__ */ jsx(rootProps.components.NoResultsOverlay, _extends$5({}, (_rootProps$components2 = rootProps.componentsProps) == null ? void 0 : _rootProps$components2.noResultsOverlay));
  }
  if (rootProps.loading) {
    var _rootProps$components3;
    overlay = /* @__PURE__ */ jsx(rootProps.components.LoadingOverlay, _extends$5({}, (_rootProps$components3 = rootProps.componentsProps) == null ? void 0 : _rootProps$components3.loadingOverlay));
  }
  if (overlay === null) {
    return null;
  }
  return /* @__PURE__ */ jsx(GridOverlayWrapper, {
    children: overlay
  });
}
function GridBody(props) {
  const {
    children,
    VirtualScrollerComponent,
    ColumnHeadersComponent
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);
  const [isVirtualizationDisabled, setIsVirtualizationDisabled] = React$6.useState(rootProps.disableVirtualization);
  const disableVirtualization = React$6.useCallback(() => {
    setIsVirtualizationDisabled(true);
  }, []);
  const enableVirtualization = React$6.useCallback(() => {
    setIsVirtualizationDisabled(false);
  }, []);
  apiRef.current.unstable_disableVirtualization = disableVirtualization;
  apiRef.current.unstable_enableVirtualization = enableVirtualization;
  const columnHeadersRef = React$6.useRef(null);
  const columnsContainerRef = React$6.useRef(null);
  const windowRef = React$6.useRef(null);
  const renderingZoneRef = React$6.useRef(null);
  apiRef.current.columnHeadersContainerElementRef = columnsContainerRef;
  apiRef.current.columnHeadersElementRef = columnHeadersRef;
  apiRef.current.windowRef = windowRef;
  apiRef.current.renderingZoneRef = renderingZoneRef;
  const handleResize = React$6.useCallback((size) => {
    apiRef.current.publishEvent(GridEvents.resize, size);
  }, [apiRef]);
  return /* @__PURE__ */ jsxs(GridMainContainer, {
    children: [/* @__PURE__ */ jsx(GridOverlays, {}), /* @__PURE__ */ jsx(ColumnHeadersComponent, {
      ref: columnsContainerRef,
      innerRef: columnHeadersRef
    }), /* @__PURE__ */ jsx(GridAutoSizer, {
      nonce: rootProps.nonce,
      disableHeight: rootProps.autoHeight,
      onResize: handleResize,
      children: (size) => {
        const style2 = {
          width: size.width,
          height: size.height ? size.height - headerHeight : "auto",
          marginTop: headerHeight
        };
        return /* @__PURE__ */ jsx(VirtualScrollerComponent, {
          ref: windowRef,
          style: style2,
          disableVirtualization: isVirtualizationDisabled
        });
      }
    }), children]
  });
}
function useGridLogger(apiRef, name) {
  const logger = React$6.useRef(null);
  if (logger.current) {
    return logger.current;
  }
  const newLogger = apiRef.current.getLogger(name);
  logger.current = newLogger;
  return newLogger;
}
class ErrorBoundary$1 extends React$6.Component {
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    if (this.props.api.current) {
      this.logError(error);
      this.props.api.current.showError({
        error,
        errorInfo
      });
    }
  }
  logError(error, errorInfo) {
    this.props.logger.error(`An unexpected error occurred. Error: ${error && error.message}. `, error, errorInfo);
  }
  render() {
    var _this$state;
    if (this.props.hasError || (_this$state = this.state) != null && _this$state.hasError) {
      return this.props.render(this.props.componentProps || this.state);
    }
    return this.props.children;
  }
}
const ErrorOverlayWrapper = styled("div")({
  position: "absolute",
  top: 0,
  width: "100%",
  height: "100%"
});
function GridErrorHandler(props) {
  const {
    children
  } = props;
  const apiRef = useGridApiContext();
  const logger = useGridLogger(apiRef, "GridErrorHandler");
  const rootProps = useGridRootProps();
  const error = apiRef.current.state.error;
  const handleResize = React$6.useCallback((size) => {
    apiRef.current.publishEvent(GridEvents.resize, size);
  }, [apiRef]);
  return /* @__PURE__ */ jsx(ErrorBoundary$1, {
    hasError: error != null,
    componentProps: error,
    api: apiRef,
    logger,
    render: (errorProps) => /* @__PURE__ */ jsx(GridMainContainer, {
      children: /* @__PURE__ */ jsx(GridAutoSizer, {
        nonce: rootProps.nonce,
        disableHeight: rootProps.autoHeight,
        onResize: handleResize,
        children: () => {
          var _rootProps$components;
          return /* @__PURE__ */ jsx(ErrorOverlayWrapper, {
            children: /* @__PURE__ */ jsx(rootProps.components.ErrorOverlay, _extends$5({}, errorProps, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.errorOverlay))
          });
        }
      })
    }),
    children
  });
}
function GridFooterPlaceholder() {
  var _rootProps$components;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const footerRef = React$6.useRef(null);
  apiRef.current.footerRef = footerRef;
  if (rootProps.hideFooter) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", {
    ref: footerRef,
    children: /* @__PURE__ */ jsx(rootProps.components.Footer, _extends$5({}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.footer))
  });
}
function GridHeaderPlaceholder() {
  var _rootProps$components;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const headerRef = React$6.useRef(null);
  apiRef.current.headerRef = headerRef;
  return /* @__PURE__ */ jsx("div", {
    ref: headerRef,
    children: /* @__PURE__ */ jsx(rootProps.components.Header, _extends$5({}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.header))
  });
}
function toVal(mix) {
  var k2, y2, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k2 = 0; k2 < mix.length; k2++) {
        if (mix[k2]) {
          if (y2 = toVal(mix[k2])) {
            str && (str += " ");
            str += y2;
          }
        }
      }
    } else {
      for (k2 in mix) {
        if (mix[k2]) {
          str && (str += " ");
          str += k2;
        }
      }
    }
  }
  return str;
}
function clsx() {
  var i2 = 0, tmp, x2, str = "";
  while (i2 < arguments.length) {
    if (tmp = arguments[i2++]) {
      if (x2 = toVal(tmp)) {
        str && (str += " ");
        str += x2;
      }
    }
  }
  return str;
}
const GridArrowUpwardIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"
}), "ArrowUpward");
const GridArrowDownwardIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
const GridKeyboardArrowRight = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "KeyboardArrowRight");
const GridExpandMoreIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
const GridFilterListIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"
}), "FilterList");
const GridFilterAltIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61z"
}), "FilterAlt");
createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
}), "Menu");
createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckCircle");
const GridColumnIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"
}), "ColumnIcon");
const GridSeparatorIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M11 19V5h2v14z"
}), "Separator");
const GridViewHeadlineIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
}), "ViewHeadline");
const GridTableRowsIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M21,8H3V4h18V8z M21,10H3v4h18V10z M21,16H3v4h18V16z"
}), "TableRows");
const GridViewStreamIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M4 18h17v-6H4v6zM4 5v6h17V5H4z"
}), "ViewStream");
const GridTripleDotsVerticalIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "TripleDotsVertical");
const GridCloseIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const GridAddIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
const GridRemoveIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M19 13H5v-2h14v2z"
}), "Remove");
const GridLoadIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"
}), "Load");
const GridDragIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "Drag");
const GridSaveAltIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2z"
}), "SaveAlt");
const GridCheckIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");
const GridMoreVertIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "MoreVert");
function getValueFromOption(option) {
  if (typeof option === "object" && option !== null) {
    return option.value;
  }
  return option;
}
function getValueFromValueOptions(value, valueOptions) {
  if (valueOptions === void 0) {
    return void 0;
  }
  const result = valueOptions.find((option) => {
    const optionValue = getValueFromOption(option);
    return String(optionValue) === String(value);
  });
  return getValueFromOption(result);
}
const _excluded$_ = ["item", "applyValue", "type", "apiRef", "focusElementRef"];
const renderSingleSelectOptions$2 = ({
  valueOptions,
  valueFormatter,
  field
}, api) => {
  const iterableColumnValues = typeof valueOptions === "function" ? ["", ...valueOptions({
    field
  })] : ["", ...valueOptions || []];
  return iterableColumnValues.map((option) => typeof option === "object" ? /* @__PURE__ */ jsx("option", {
    value: option.value,
    children: option.label
  }, option.value) : /* @__PURE__ */ jsx("option", {
    value: option,
    children: valueFormatter && option !== "" ? valueFormatter({
      value: option,
      field,
      api
    }) : option
  }, option));
};
const SUBMIT_FILTER_STROKE_TIME = 500;
function GridFilterInputValue(props) {
  var _item$value, _rootProps$components;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef
  } = props, others = _objectWithoutPropertiesLoose$2(props, _excluded$_);
  const filterTimeout = React$6.useRef();
  const [filterValueState, setFilterValueState] = React$6.useState((_item$value = item.value) != null ? _item$value : "");
  const [applying, setIsApplying] = React$6.useState(false);
  const id2 = unstable_useId();
  const rootProps = useGridRootProps();
  const singleSelectProps = type === "singleSelect" ? {
    select: true,
    SelectProps: {
      native: true
    },
    children: renderSingleSelectOptions$2(apiRef.current.getColumn(item.columnField), apiRef.current)
  } : {};
  const onFilterChange = React$6.useCallback((event) => {
    let value = event.target.value;
    if (type === "singleSelect") {
      const column = apiRef.current.getColumn(item.columnField);
      const columnValueOptions = typeof column.valueOptions === "function" ? column.valueOptions({
        field: column.field
      }) : column.valueOptions;
      value = getValueFromValueOptions(value, columnValueOptions);
    }
    clearTimeout(filterTimeout.current);
    setFilterValueState(String(value));
    setIsApplying(true);
    filterTimeout.current = setTimeout(() => {
      applyValue(_extends$5({}, item, {
        value
      }));
      setIsApplying(false);
    }, SUBMIT_FILTER_STROKE_TIME);
  }, [apiRef, applyValue, item, type]);
  React$6.useEffect(() => {
    return () => {
      clearTimeout(filterTimeout.current);
    };
  }, []);
  React$6.useEffect(() => {
    var _item$value2;
    const itemValue = (_item$value2 = item.value) != null ? _item$value2 : "";
    setFilterValueState(String(itemValue));
  }, [item.value]);
  const InputProps = applying ? {
    endAdornment: /* @__PURE__ */ jsx(GridLoadIcon, {})
  } : others.InputProps;
  return /* @__PURE__ */ jsx(rootProps.components.BaseTextField, _extends$5({
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    type: type || "text",
    variant: "standard",
    InputProps,
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef
  }, singleSelectProps, others, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTextField));
}
const _excluded$Z = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "getValue", "isValidating", "debounceMs"];
const useUtilityClasses$D = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridEditInputCellRoot = styled(InputBase, {
  name: "MuiDataGrid",
  slot: "EditInputCell",
  overridesResolver: (props, styles) => styles.editInputCell
})(({
  theme
}) => _extends$5({}, theme.typography.body2, {
  padding: "1px 0",
  "& input": {
    padding: "0 16px",
    height: "100%"
  }
}));
function GridEditInputCell(props) {
  const {
    id: id2,
    value,
    api,
    field,
    colDef,
    hasFocus,
    debounceMs = SUBMIT_FILTER_STROKE_TIME
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$Z);
  const inputRef = React$6.useRef();
  const [valueState, setValueState] = React$6.useState(value);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$D(ownerState);
  const handleChange = React$6.useCallback((event) => {
    const newValue = event.target.value;
    setValueState(newValue);
    api.setEditCellValue({
      id: id2,
      field,
      value: newValue,
      debounceMs
    }, event);
  }, [api, debounceMs, field, id2]);
  React$6.useEffect(() => {
    setValueState(value);
  }, [value]);
  unstable_useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsx(GridEditInputCellRoot, _extends$5({
    inputRef,
    className: classes2.root,
    fullWidth: true,
    type: colDef.type === "number" ? colDef.type : "text",
    value: valueState != null ? valueState : "",
    onChange: handleChange
  }, other));
}
const renderEditInputCell = (params) => /* @__PURE__ */ jsx(GridEditInputCell, _extends$5({}, params));
const buildWarning = (message, gravity = "warning") => {
  let alreadyWarned = false;
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  return () => {
    if (!alreadyWarned) {
      alreadyWarned = true;
      if (gravity === "error") {
        console.error(cleanMessage);
      } else {
        console.warn(cleanMessage);
      }
    }
  };
};
const wrapWithWarningOnCall = (method, message) => {
  {
    return method;
  }
};
const sortModelDisableMultiColumnsSortingWarning = buildWarning(["MUI: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
const sanitizeSortModel = (model, disableMultipleColumnsSorting) => {
  if (disableMultipleColumnsSorting && model.length > 1) {
    sortModelDisableMultiColumnsSortingWarning();
    return [model[0]];
  }
  return model;
};
const mergeStateWithSortModel = (sortModel, disableMultipleColumnsSorting) => (state) => _extends$5({}, state, {
  sorting: _extends$5({}, state.sorting, {
    sortModel: sanitizeSortModel(sortModel, disableMultipleColumnsSorting)
  })
});
const isDesc = (direction) => direction === "desc";
const parseSortItem = (sortItem, apiRef) => {
  const column = apiRef.current.getColumn(sortItem.field);
  if (!column) {
    return null;
  }
  const comparator = isDesc(sortItem.sort) ? (...args) => -1 * column.sortComparator(...args) : column.sortComparator;
  const getSortCellParams = (id2) => ({
    id: id2,
    field: column.field,
    rowNode: apiRef.current.getRowNode(id2),
    value: apiRef.current.getCellValue(id2, column.field),
    api: apiRef.current
  });
  return {
    getSortCellParams,
    comparator
  };
};
const compareRows = (parsedSortItems, row1Params, row2Params) => {
  return parsedSortItems.reduce((res, item, index) => {
    if (res !== 0) {
      return res;
    }
    const sortCellParams1 = row1Params[index];
    const sortCellParams2 = row2Params[index];
    res = item.comparator(sortCellParams1.value, sortCellParams2.value, sortCellParams1, sortCellParams2);
    return res;
  }, 0);
};
const buildAggregatedSortingApplier = (sortModel, apiRef) => {
  const comparatorList = sortModel.map((item) => parseSortItem(item, apiRef)).filter((comparator) => !!comparator);
  if (comparatorList.length === 0) {
    return null;
  }
  return (rowList) => rowList.map((value) => ({
    value,
    params: comparatorList.map((el) => el.getSortCellParams(value.id))
  })).sort((a2, b2) => compareRows(comparatorList, a2.params, b2.params)).map((row) => row.value.id);
};
const getNextGridSortDirection = (sortingOrder, current) => {
  const currentIdx = sortingOrder.indexOf(current);
  if (!current || currentIdx === -1 || currentIdx + 1 === sortingOrder.length) {
    return sortingOrder[0];
  }
  return sortingOrder[currentIdx + 1];
};
const gridNillComparator = (v1, v2) => {
  if (v1 == null && v2 != null) {
    return -1;
  }
  if (v2 == null && v1 != null) {
    return 1;
  }
  if (v1 == null && v2 == null) {
    return 0;
  }
  return null;
};
const collator$1 = new Intl.Collator();
const gridStringOrNumberComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (typeof value1 === "string") {
    return collator$1.compare(value1.toString(), value2.toString());
  }
  return value1 - value2;
};
const gridNumberComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  return Number(value1) - Number(value2);
};
const gridDateComparator = (value1, value2) => {
  const nillResult = gridNillComparator(value1, value2);
  if (nillResult !== null) {
    return nillResult;
  }
  if (value1 > value2) {
    return 1;
  }
  if (value1 < value2) {
    return -1;
  }
  return 0;
};
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
function eq$1(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$1(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$1(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf$1(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype["delete"] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;
function stackClear$1() {
  this.__data__ = new ListCache$1();
  this.size = 0;
}
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet$1(key) {
  return this.__data__.get(key);
}
function stackHas$1(key) {
  return this.__data__.has(key);
}
var freeGlobal$4 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$5 = freeGlobal$4;
var freeSelf$3 = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal$5 || freeSelf$3 || Function("return this")();
var root$5 = root$4;
var Symbol$3 = root$5.Symbol;
var Symbol$4 = Symbol$3;
var objectProto$r = Object.prototype;
var hasOwnProperty$j = objectProto$r.hasOwnProperty;
var nativeObjectToString$3 = objectProto$r.toString;
var symToStringTag$3 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$j.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var objectProto$q = Object.prototype;
var nativeObjectToString$2 = objectProto$q.toString;
function objectToString$3(value) {
  return nativeObjectToString$2.call(value);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$3(value);
}
function isObject$7(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$4 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  }
  var tag = baseGetTag$1(value);
  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var coreJsData$2 = root$5["__core-js_shared__"];
var coreJsData$3 = coreJsData$2;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$4 = Function.prototype;
var funcToString$4 = funcProto$4.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$4.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$3 = Function.prototype, objectProto$p = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$i = objectProto$p.hasOwnProperty;
var reIsNative$1 = RegExp("^" + funcToString$3.call(hasOwnProperty$i).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
var Map$3 = getNative$1(root$5, "Map");
var Map$4 = Map$3;
var nativeCreate$2 = getNative$1(Object, "create");
var nativeCreate$3 = nativeCreate$2;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
var objectProto$o = Object.prototype;
var hasOwnProperty$h = objectProto$o.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$3) {
    var result = data[key];
    return result === HASH_UNDEFINED$4 ? void 0 : result;
  }
  return hasOwnProperty$h.call(data, key) ? data[key] : void 0;
}
var objectProto$n = Object.prototype;
var hasOwnProperty$g = objectProto$n.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$3 ? data[key] !== void 0 : hasOwnProperty$g.call(data, key);
}
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$3 && value === void 0 ? HASH_UNDEFINED$3 : value;
  return this;
}
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype["delete"] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    hash: new Hash$1(),
    map: new (Map$4 || ListCache$1)(),
    string: new Hash$1()
  };
}
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData$1(map, key) {
  var data = map.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete$1(key) {
  var result = getMapData$1(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
function mapCacheSet$1(key, value) {
  var data = getMapData$1(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype["delete"] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$4 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack$1(entries) {
  var data = this.__data__ = new ListCache$1(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear$1;
Stack$1.prototype["delete"] = stackDelete$1;
Stack$1.prototype.get = stackGet$1;
Stack$1.prototype.has = stackHas$1;
Stack$1.prototype.set = stackSet$1;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array$3 = root$5.Uint8Array;
var Uint8Array$4 = Uint8Array$3;
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]";
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$6:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$4(object), new Uint8Array$4(other))) {
        return false;
      }
      return true;
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
      return eq$1(+object, +other);
    case errorTag$3:
      return object.name == other.name && object.message == other.message;
    case regexpTag$4:
    case stringTag$4:
      return object == other + "";
    case mapTag$7:
      var convert = mapToArray;
    case setTag$7:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$5:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
function arrayPush$1(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var isArray$6 = Array.isArray;
var isArray$7 = isArray$6;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$7(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray$1() {
  return [];
}
var objectProto$m = Object.prototype;
var propertyIsEnumerable$3 = objectProto$m.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$2 = !nativeGetSymbols$2 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$2(object), function(symbol) {
    return propertyIsEnumerable$3.call(object, symbol);
  });
};
var getSymbols$3 = getSymbols$2;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
function isObjectLike$3(value) {
  return value != null && typeof value == "object";
}
var argsTag$5 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$1(value) == argsTag$5;
}
var objectProto$l = Object.prototype;
var hasOwnProperty$f = objectProto$l.hasOwnProperty;
var propertyIsEnumerable$2 = objectProto$l.propertyIsEnumerable;
var isArguments$2 = baseIsArguments$1(function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$3(value) && hasOwnProperty$f.call(value, "callee") && !propertyIsEnumerable$2.call(value, "callee");
};
var isArguments$3 = isArguments$2;
function stubFalse$1() {
  return false;
}
var freeExports$4 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$4 = freeExports$4 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$4 = freeModule$4 && freeModule$4.exports === freeExports$4;
var Buffer$3 = moduleExports$4 ? root$5.Buffer : void 0;
var nativeIsBuffer$1 = Buffer$3 ? Buffer$3.isBuffer : void 0;
var isBuffer$2 = nativeIsBuffer$1 || stubFalse$1;
var isBuffer$3 = isBuffer$2;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$3 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$6 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$5 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$4] = typedArrayTags$1[arrayTag$3] = typedArrayTags$1[arrayBufferTag$3] = typedArrayTags$1[boolTag$3] = typedArrayTags$1[dataViewTag$5] = typedArrayTags$1[dateTag$3] = typedArrayTags$1[errorTag$2] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$6] = typedArrayTags$1[numberTag$3] = typedArrayTags$1[objectTag$6] = typedArrayTags$1[regexpTag$3] = typedArrayTags$1[setTag$6] = typedArrayTags$1[stringTag$3] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength$1(value.length) && !!typedArrayTags$1[baseGetTag$1(value)];
}
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$3 = freeExports$3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$3 = freeModule$3 && freeModule$3.exports === freeExports$3;
var freeProcess$1 = moduleExports$3 && freeGlobal$5.process;
var nodeUtil$2 = function() {
  try {
    return freeProcess$1 && freeProcess$1.binding && freeProcess$1.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$3 = nodeUtil$2;
var nodeIsTypedArray$1 = nodeUtil$3 && nodeUtil$3.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray$1 ? baseUnary$1(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray$3 = isTypedArray$2;
var objectProto$k = Object.prototype;
var hasOwnProperty$e = objectProto$k.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$7(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$e.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$1(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$j = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$j;
  return value === proto;
}
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys$2 = overArg$1(Object.keys, Object);
var nativeKeys$3 = nativeKeys$2;
var objectProto$i = Object.prototype;
var hasOwnProperty$d = objectProto$i.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$1(object)) {
    return nativeKeys$3(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$d.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$3(value);
}
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);
}
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols$3);
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$h = Object.prototype;
var hasOwnProperty$c = objectProto$h.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$c.call(other, key))) {
      return false;
    }
  }
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView$3 = getNative$1(root$5, "DataView");
var DataView$4 = DataView$3;
var Promise$3 = getNative$1(root$5, "Promise");
var Promise$4 = Promise$3;
var Set$3 = getNative$1(root$5, "Set");
var Set$4 = Set$3;
var WeakMap$3 = getNative$1(root$5, "WeakMap");
var WeakMap$4 = WeakMap$3;
var mapTag$5 = "[object Map]", objectTag$5 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$4 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$4), mapCtorString$1 = toSource$1(Map$4), promiseCtorString$1 = toSource$1(Promise$4), setCtorString$1 = toSource$1(Set$4), weakMapCtorString$1 = toSource$1(WeakMap$4);
var getTag$2 = baseGetTag$1;
if (DataView$4 && getTag$2(new DataView$4(new ArrayBuffer(1))) != dataViewTag$4 || Map$4 && getTag$2(new Map$4()) != mapTag$5 || Promise$4 && getTag$2(Promise$4.resolve()) != promiseTag$1 || Set$4 && getTag$2(new Set$4()) != setTag$5 || WeakMap$4 && getTag$2(new WeakMap$4()) != weakMapTag$3) {
  getTag$2 = function(value) {
    var result = baseGetTag$1(value), Ctor = result == objectTag$5 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$4;
        case mapCtorString$1:
          return mapTag$5;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$5;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var getTag$3 = getTag$2;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", objectTag$4 = "[object Object]";
var objectProto$g = Object.prototype;
var hasOwnProperty$b = objectProto$g.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$7(object), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag$2 : getTag$3(object), othTag = othIsArr ? arrayTag$2 : getTag$3(other);
  objTag = objTag == argsTag$3 ? objectTag$4 : objTag;
  othTag = othTag == argsTag$3 ? objectTag$4 : othTag;
  var objIsObj = objTag == objectTag$4, othIsObj = othTag == objectTag$4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray$3(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$b.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$3(value) && !isObjectLike$3(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function isDeepEqual(value, other) {
  return baseIsEqual(value, other);
}
function isNumber(value) {
  return typeof value === "number";
}
function isFunction$2(value) {
  return typeof value === "function";
}
function localStorageAvailable() {
  try {
    const key = "__some_random_key_you_are_not_going_to_use__";
    window.localStorage.setItem(key, key);
    window.localStorage.removeItem(key);
    return true;
  } catch (err) {
    return false;
  }
}
function escapeRegExp(value) {
  return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
const _excluded$Y = ["item", "applyValue", "type", "apiRef", "focusElementRef"];
function GridFilterInputMultipleValue(props) {
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$Y);
  const [filterValueState, setFilterValueState] = React$6.useState(item.value || []);
  const id2 = unstable_useId();
  React$6.useEffect(() => {
    var _item$value;
    const itemValue = (_item$value = item.value) != null ? _item$value : [];
    setFilterValueState(itemValue.map(String));
  }, [item.value]);
  const handleChange = React$6.useCallback((event, value) => {
    setFilterValueState(value.map(String));
    applyValue(_extends$5({}, item, {
      value: [...value]
    }));
  }, [applyValue, item]);
  return /* @__PURE__ */ jsx(Autocomplete, _extends$5({
    multiple: true,
    freeSolo: true,
    limitTags: 1,
    options: [],
    filterOptions: (options, params) => {
      const {
        inputValue
      } = params;
      return inputValue == null || inputValue === "" ? [] : [inputValue];
    },
    id: id2,
    value: filterValueState,
    onChange: handleChange,
    renderTags: (value, getTagProps) => value.map((option, index) => /* @__PURE__ */ jsx(Chip, _extends$5({
      variant: "outlined",
      size: "small",
      label: option
    }, getTagProps({
      index
    })))),
    renderInput: (params) => /* @__PURE__ */ jsx(TextField$1, _extends$5({}, params, {
      label: apiRef.current.getLocaleText("filterPanelInputLabel"),
      placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
      InputLabelProps: _extends$5({}, params.InputLabelProps, {
        shrink: true
      }),
      inputRef: focusElementRef,
      type: type || "text",
      variant: "standard"
    }))
  }, other));
}
const getGridStringOperators = () => [{
  value: "contains",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterRegex = new RegExp(escapeRegExp(filterItem.value), "i");
    return ({
      value
    }) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "equals",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const collator2 = new Intl.Collator(void 0, {
      sensitivity: "base",
      usage: "search"
    });
    return ({
      value
    }) => {
      return value != null ? collator2.compare(filterItem.value, value.toString()) === 0 : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "startsWith",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterRegex = new RegExp(`^${escapeRegExp(filterItem.value)}.*$`, "i");
    return ({
      value
    }) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "endsWith",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const filterRegex = new RegExp(`.*${escapeRegExp(filterItem.value)}$`, "i");
    return ({
      value
    }) => {
      return value != null ? filterRegex.test(value.toString()) : false;
    };
  },
  InputComponent: GridFilterInputValue
}, {
  value: "isEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value === "" || value == null;
    };
  }
}, {
  value: "isNotEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value !== "" && value != null;
    };
  }
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const collator2 = new Intl.Collator(void 0, {
      sensitivity: "base",
      usage: "search"
    });
    return ({
      value
    }) => value != null ? filterItem.value.some((filterValue) => {
      return collator2.compare(filterValue, value.toString() || "") === 0;
    }) : false;
  },
  InputComponent: GridFilterInputMultipleValue
}];
const GRID_STRING_COL_DEF = {
  width: 100,
  minWidth: 50,
  maxWidth: Infinity,
  hide: false,
  hideable: true,
  sortable: true,
  resizable: true,
  filterable: true,
  groupable: true,
  pinnable: true,
  editable: false,
  sortComparator: gridStringOrNumberComparator,
  type: "string",
  align: "left",
  filterOperators: getGridStringOperators(),
  renderEditCell: renderEditInputCell
};
const parseNumericValue = (value) => {
  if (value == null) {
    return null;
  }
  return Number(value);
};
const getGridNumericOperators = () => [{
  label: "=",
  value: "=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      return parseNumericValue(value) === filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  label: "!=",
  value: "!=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      return parseNumericValue(value) !== filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  label: ">",
  value: ">",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) > filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  label: ">=",
  value: ">=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) >= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  label: "<",
  value: "<",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) < filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  label: "<=",
  value: "<=",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || Number.isNaN(filterItem.value)) {
      return null;
    }
    return ({
      value
    }) => {
      if (value == null) {
        return false;
      }
      return parseNumericValue(value) <= filterItem.value;
    };
  },
  InputComponent: GridFilterInputValue,
  InputComponentProps: {
    type: "number"
  }
}, {
  value: "isEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value == null;
    };
  }
}, {
  value: "isNotEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value != null;
    };
  }
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    return ({
      value
    }) => {
      return value != null && filterItem.value.includes(Number(value));
    };
  },
  InputComponent: GridFilterInputMultipleValue,
  InputComponentProps: {
    type: "number"
  }
}];
const getGridNumericColumnOperators = wrapWithWarningOnCall(getGridNumericOperators, "MUI: Using getGridNumericColumnOperators is deprecated, use getGridNumericOperators instead.");
const GRID_NUMERIC_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  type: "number",
  align: "right",
  headerAlign: "right",
  sortComparator: gridNumberComparator,
  valueParser: (value) => value === "" ? null : Number(value),
  valueFormatter: ({
    value
  }) => value && isNumber(value) && value.toLocaleString() || value,
  filterOperators: getGridNumericOperators()
});
const _excluded$X = ["item", "applyValue", "type", "apiRef", "focusElementRef", "InputProps"];
const SUBMIT_FILTER_DATE_STROKE_TIME = 500;
function GridFilterInputDate(props) {
  var _item$value, _rootProps$components;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef,
    InputProps
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$X);
  const filterTimeout = React$6.useRef();
  const [filterValueState, setFilterValueState] = React$6.useState((_item$value = item.value) != null ? _item$value : "");
  const [applying, setIsApplying] = React$6.useState(false);
  const id2 = unstable_useId();
  const rootProps = useGridRootProps();
  const onFilterChange = React$6.useCallback((event) => {
    const value = event.target.value;
    clearTimeout(filterTimeout.current);
    setFilterValueState(String(value));
    setIsApplying(true);
    filterTimeout.current = setTimeout(() => {
      applyValue(_extends$5({}, item, {
        value
      }));
      setIsApplying(false);
    }, SUBMIT_FILTER_DATE_STROKE_TIME);
  }, [applyValue, item]);
  React$6.useEffect(() => {
    return () => {
      clearTimeout(filterTimeout.current);
    };
  }, []);
  React$6.useEffect(() => {
    var _item$value2;
    const itemValue = (_item$value2 = item.value) != null ? _item$value2 : "";
    setFilterValueState(String(itemValue));
  }, [item.value]);
  return /* @__PURE__ */ jsx(rootProps.components.BaseTextField, _extends$5({
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    type: type || "text",
    variant: "standard",
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef,
    InputProps: _extends$5({}, applying ? {
      endAdornment: /* @__PURE__ */ jsx(GridLoadIcon, {})
    } : {}, InputProps, {
      inputProps: _extends$5({
        max: type === "datetime-local" ? "9999-12-31T23:59" : "9999-12-31"
      }, InputProps == null ? void 0 : InputProps.inputProps)
    })
  }, other, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTextField));
}
const dateRegex$1 = /(\d+)-(\d+)-(\d+)/;
const dateTimeRegex = /(\d+)-(\d+)-(\d+)T(\d+):(\d+)/;
function buildApplyFilterFn(filterItem, compareFn, showTime, keepHours) {
  if (!filterItem.value) {
    return null;
  }
  const [year, month, day, hour, minute] = filterItem.value.match(showTime ? dateTimeRegex : dateRegex$1).slice(1).map(Number);
  const time = new Date(year, month - 1, day, hour || 0, minute || 0).getTime();
  return ({
    value
  }) => {
    if (!value) {
      return false;
    }
    const valueAsDate = value instanceof Date ? value : new Date(value.toString());
    if (keepHours) {
      return compareFn(valueAsDate.getTime(), time);
    }
    const dateCopy = value instanceof Date ? new Date(valueAsDate) : valueAsDate;
    const timeToCompare = dateCopy.setHours(showTime ? valueAsDate.getHours() : 0, showTime ? valueAsDate.getMinutes() : 0, 0, 0);
    return compareFn(timeToCompare, time);
  };
}
const getGridDateOperators = (showTime) => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 === value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "not",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 !== value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "after",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 > value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrAfter",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 >= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "before",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 < value2, showTime, !showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "onOrBefore",
  getApplyFilterFn: (filterItem) => {
    return buildApplyFilterFn(filterItem, (value1, value2) => value1 <= value2, showTime);
  },
  InputComponent: GridFilterInputDate,
  InputComponentProps: {
    type: showTime ? "datetime-local" : "date"
  }
}, {
  value: "isEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value == null;
    };
  }
}, {
  value: "isNotEmpty",
  getApplyFilterFn: () => {
    return ({
      value
    }) => {
      return value != null;
    };
  }
}];
const _excluded$W = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "getValue", "inputProps", "isValidating"];
const useUtilityClasses$C = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editInputCell"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function GridEditDateCell(props) {
  const {
    id: id2,
    value: valueProp,
    api,
    field,
    colDef,
    hasFocus,
    inputProps
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$W);
  const isDateTime2 = colDef.type === "dateTime";
  const inputRef = React$6.useRef();
  const valueTransformed = React$6.useMemo(() => {
    let parsedDate;
    if (valueProp == null) {
      parsedDate = null;
    } else if (valueProp instanceof Date) {
      parsedDate = valueProp;
    } else {
      parsedDate = new Date((valueProp != null ? valueProp : "").toString());
    }
    let formattedDate;
    if (parsedDate == null || Number.isNaN(parsedDate.getTime())) {
      formattedDate = "";
    } else {
      const localDate = new Date(parsedDate.getTime() - parsedDate.getTimezoneOffset() * 60 * 1e3);
      formattedDate = localDate.toISOString().substr(0, isDateTime2 ? 16 : 10);
    }
    return {
      parsed: parsedDate,
      formatted: formattedDate
    };
  }, [valueProp, isDateTime2]);
  const [valueState, setValueState] = React$6.useState(valueTransformed);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$C(ownerState);
  const handleChange = React$6.useCallback((event) => {
    const newFormattedDate = event.target.value;
    let newParsedDate;
    if (newFormattedDate === "") {
      newParsedDate = null;
    } else {
      const [date, time] = newFormattedDate.split("T");
      const [year, month, day] = date.split("-");
      newParsedDate = new Date();
      newParsedDate.setFullYear(year, Number(month) - 1, day);
      newParsedDate.setHours(0, 0, 0, 0);
      if (time) {
        const [hours, minutes] = time.split(":");
        newParsedDate.setHours(Number(hours), Number(minutes), 0, 0);
      }
    }
    setValueState({
      parsed: newParsedDate,
      formatted: newFormattedDate
    });
    api.setEditCellValue({
      id: id2,
      field,
      value: newParsedDate
    }, event);
  }, [api, field, id2]);
  React$6.useEffect(() => {
    setValueState((state) => {
      var _valueTransformed$par, _state$parsed;
      if (valueTransformed.parsed !== state.parsed && ((_valueTransformed$par = valueTransformed.parsed) == null ? void 0 : _valueTransformed$par.getTime()) !== ((_state$parsed = state.parsed) == null ? void 0 : _state$parsed.getTime())) {
        return valueTransformed;
      }
      return state;
    });
  }, [valueTransformed]);
  unstable_useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsx(InputBase, _extends$5({
    inputRef,
    fullWidth: true,
    className: classes2.root,
    type: isDateTime2 ? "datetime-local" : "date",
    inputProps: _extends$5({
      max: isDateTime2 ? "9999-12-31T23:59" : "9999-12-31"
    }, inputProps),
    value: valueState.formatted,
    onChange: handleChange
  }, other));
}
const renderEditDateCell = (params) => /* @__PURE__ */ jsx(GridEditDateCell, _extends$5({}, params));
function gridDateFormatter({
  value
}) {
  if (value instanceof Date) {
    return value.toLocaleDateString();
  }
  return value;
}
function gridDateTimeFormatter({
  value
}) {
  if (value instanceof Date) {
    return value.toLocaleString();
  }
  return value;
}
const GRID_DATE_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  type: "date",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateFormatter,
  filterOperators: getGridDateOperators(),
  renderEditCell: renderEditDateCell
});
const GRID_DATETIME_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  type: "dateTime",
  sortComparator: gridDateComparator,
  valueFormatter: gridDateTimeFormatter,
  filterOperators: getGridDateOperators(true),
  renderEditCell: renderEditDateCell
});
const _excluded$V = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "hasFocus", "tabIndex", "getValue"];
const useUtilityClasses$B = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["booleanCell"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridBooleanCell = /* @__PURE__ */ React$6.memo((props) => {
  const {
    value,
    api
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$V);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$B(ownerState);
  const Icon = React$6.useMemo(() => value ? rootProps.components.BooleanCellTrueIcon : rootProps.components.BooleanCellFalseIcon, [rootProps.components.BooleanCellFalseIcon, rootProps.components.BooleanCellTrueIcon, value]);
  return /* @__PURE__ */ jsx(Icon, _extends$5({
    fontSize: "small",
    className: classes2.root,
    titleAccess: api.getLocaleText(value ? "booleanCellTrueLabel" : "booleanCellFalseLabel"),
    "data-value": Boolean(value)
  }, other));
});
const renderBooleanCell = (params) => {
  if (params.rowNode.isAutoGenerated) {
    return "";
  }
  return /* @__PURE__ */ jsx(GridBooleanCell, _extends$5({}, params));
};
const _excluded$U = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "getValue", "hasFocus", "isValidating", "error"];
const useUtilityClasses$A = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["editBooleanCell"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function GridEditBooleanCell(props) {
  var _rootProps$components;
  const {
    id: idProp,
    value,
    api,
    field,
    className,
    hasFocus
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$U);
  const inputRef = React$6.useRef(null);
  const id2 = unstable_useId();
  const [valueState, setValueState] = React$6.useState(value);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$A(ownerState);
  const handleChange = React$6.useCallback((event) => {
    const newValue = event.target.checked;
    setValueState(newValue);
    api.setEditCellValue({
      id: idProp,
      field,
      value: newValue
    }, event);
  }, [api, field, idProp]);
  React$6.useEffect(() => {
    setValueState(value);
  }, [value]);
  unstable_useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsx("label", _extends$5({
    htmlFor: id2,
    className: clsx(classes2.root, className)
  }, other, {
    children: /* @__PURE__ */ jsx(rootProps.components.BaseCheckbox, _extends$5({
      id: id2,
      inputRef,
      checked: Boolean(valueState),
      onChange: handleChange,
      size: "small"
    }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseCheckbox))
  }));
}
const renderEditBooleanCell = (params) => /* @__PURE__ */ jsx(GridEditBooleanCell, _extends$5({}, params));
const _excluded$T = ["item", "applyValue", "apiRef", "focusElementRef"];
function GridFilterInputBoolean(props) {
  var _rootProps$components;
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef
  } = props, others = _objectWithoutPropertiesLoose$2(props, _excluded$T);
  const [filterValueState, setFilterValueState] = React$6.useState(item.value || "");
  const rootProps = useGridRootProps();
  const onFilterChange = React$6.useCallback((event) => {
    const value = event.target.value;
    setFilterValueState(value);
    applyValue(_extends$5({}, item, {
      value
    }));
  }, [applyValue, item]);
  React$6.useEffect(() => {
    setFilterValueState(item.value || "");
  }, [item.value]);
  return /* @__PURE__ */ jsxs(rootProps.components.BaseTextField, _extends$5({
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    value: filterValueState,
    onChange: onFilterChange,
    variant: "standard",
    select: true,
    SelectProps: {
      native: true
    },
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef
  }, others, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTextField, {
    children: [/* @__PURE__ */ jsx("option", {
      value: "",
      children: apiRef.current.getLocaleText("filterValueAny")
    }), /* @__PURE__ */ jsx("option", {
      value: "true",
      children: apiRef.current.getLocaleText("filterValueTrue")
    }), /* @__PURE__ */ jsx("option", {
      value: "false",
      children: apiRef.current.getLocaleText("filterValueFalse")
    })]
  }));
}
const getGridBooleanOperators = () => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    if (!filterItem.value) {
      return null;
    }
    const valueAsBoolean = filterItem.value === "true";
    return ({
      value
    }) => {
      return Boolean(value) === valueAsBoolean;
    };
  },
  InputComponent: GridFilterInputBoolean
}];
function gridBooleanFormatter({
  value,
  api
}) {
  return value ? api.getLocaleText("booleanCellTrueLabel") : api.getLocaleText("booleanCellFalseLabel");
}
const GRID_BOOLEAN_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  type: "boolean",
  align: "center",
  headerAlign: "center",
  renderCell: renderBooleanCell,
  renderEditCell: renderEditBooleanCell,
  sortComparator: gridNumberComparator,
  valueFormatter: gridBooleanFormatter,
  filterOperators: getGridBooleanOperators()
});
const isEscapeKey = (key) => key === "Escape";
const isEnterKey = (key) => key === "Enter";
const isTabKey = (key) => key === "Tab";
const isSpaceKey = (key) => key === " ";
const isArrowKeys = (key) => key.indexOf("Arrow") === 0;
const isHomeOrEndKeys = (key) => key === "Home" || key === "End";
const isPageKeys = (key) => key.indexOf("Page") === 0;
const isDeleteKeys = (key) => key === "Delete" || key === "Backspace";
const printableCharRegex = /^(\p{L}|\p{M}\p{L}|\p{M}|\p{N}|\p{Z}|\p{S}|\p{P})$/iu;
const isPrintableKey = (key) => printableCharRegex.test(key);
const GRID_CELL_EXIT_EDIT_MODE_KEYS = ["Enter", "Escape", "Tab"];
const GRID_CELL_EDIT_COMMIT_KEYS = ["Enter", "Tab"];
const isCellEnterEditModeKeys = (key) => isEnterKey(key) || isDeleteKeys(key) || isPrintableKey(key);
const isCellExitEditModeKeys = (key) => GRID_CELL_EXIT_EDIT_MODE_KEYS.indexOf(key) > -1;
const isCellEditCommitKeys = (key) => GRID_CELL_EDIT_COMMIT_KEYS.indexOf(key) > -1;
const isNavigationKey = (key) => isHomeOrEndKeys(key) || isArrowKeys(key) || isPageKeys(key) || isSpaceKey(key);
const isKeyboardEvent = (event) => !!event.key;
const isHideMenuKey = (key) => isTabKey(key) || isEscapeKey(key);
var GridEditModes;
(function(GridEditModes2) {
  GridEditModes2["Cell"] = "cell";
  GridEditModes2["Row"] = "row";
})(GridEditModes || (GridEditModes = {}));
var GridCellModes;
(function(GridCellModes2) {
  GridCellModes2["Edit"] = "edit";
  GridCellModes2["View"] = "view";
})(GridCellModes || (GridCellModes = {}));
var GridRowModes;
(function(GridRowModes2) {
  GridRowModes2["Edit"] = "edit";
  GridRowModes2["View"] = "view";
})(GridRowModes || (GridRowModes = {}));
const _excluded$S = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "getValue", "hasFocus", "isValidating", "error"];
const renderSingleSelectOptions$1 = (option) => typeof option === "object" ? /* @__PURE__ */ jsx(MenuItem, {
  value: option.value,
  children: option.label
}, option.value) : /* @__PURE__ */ jsx(MenuItem, {
  value: option,
  children: option
}, option);
function GridEditSingleSelectCell(props) {
  var _rootProps$components;
  const {
    id: id2,
    value,
    api,
    field,
    row,
    colDef,
    hasFocus,
    error
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$S);
  const ref = React$6.useRef();
  const inputRef = React$6.useRef();
  const rootProps = useGridRootProps();
  const [open, setOpen] = React$6.useState(rootProps.editMode === "cell");
  let valueOptionsFormatted;
  if (typeof colDef.valueOptions === "function") {
    valueOptionsFormatted = colDef.valueOptions({
      id: id2,
      row,
      field
    });
  } else {
    valueOptionsFormatted = colDef.valueOptions;
  }
  if (colDef.valueFormatter) {
    valueOptionsFormatted = valueOptionsFormatted.map((option) => {
      if (typeof option === "object") {
        return option;
      }
      const params = {
        field,
        api,
        value: option
      };
      return {
        value: option,
        label: String(colDef.valueFormatter(params))
      };
    });
  }
  const handleChange = async (event) => {
    setOpen(false);
    const isValid2 = await api.setEditCellValue({
      id: id2,
      field,
      value: event.target.value
    }, event);
    if (rootProps.editMode === GridEditModes.Row || isValid2 === false) {
      return;
    }
    const canCommit = await Promise.resolve(api.commitCellChange({
      id: id2,
      field
    }, event));
    if (canCommit) {
      api.setCellMode(id2, field, "view");
      if (event.key) {
        const params = api.getCellParams(id2, field);
        api.publishEvent(GridEvents.cellNavigationKeyDown, params, event);
      }
    }
  };
  const handleClose = (event, reason) => {
    if (rootProps.editMode === GridEditModes.Row) {
      setOpen(false);
      return;
    }
    if (reason === "backdropClick" || isEscapeKey(event.key)) {
      api.setCellMode(id2, field, "view");
    }
  };
  const handleOpen = () => {
    setOpen(true);
  };
  unstable_useEnhancedEffect(() => {
    if (hasFocus) {
      inputRef.current.focus();
    }
  }, [hasFocus]);
  return /* @__PURE__ */ jsx(rootProps.components.BaseSelect, _extends$5({
    ref,
    inputRef,
    value,
    onChange: handleChange,
    open,
    onOpen: handleOpen,
    MenuProps: {
      onClose: handleClose
    },
    error,
    fullWidth: true
  }, other, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseSelect, {
    children: valueOptionsFormatted.map(renderSingleSelectOptions$1)
  }));
}
const renderEditSingleSelectCell = (params) => /* @__PURE__ */ jsx(GridEditSingleSelectCell, _extends$5({}, params));
const _excluded$R = ["item", "applyValue", "type", "apiRef", "focusElementRef"];
const renderSingleSelectOptions = ({
  valueOptions,
  valueFormatter,
  field
}, api) => {
  const iterableColumnValues = typeof valueOptions === "function" ? ["", ...valueOptions({
    field
  })] : ["", ...valueOptions || []];
  return iterableColumnValues.map((option) => typeof option === "object" ? /* @__PURE__ */ jsx("option", {
    value: option.value,
    children: option.label
  }, option.value) : /* @__PURE__ */ jsx("option", {
    value: option,
    children: valueFormatter && option !== "" ? valueFormatter({
      value: option,
      field,
      api
    }) : option
  }, option));
};
function GridFilterInputSingleSelect(props) {
  var _item$value, _rootProps$components;
  const {
    item,
    applyValue,
    type,
    apiRef,
    focusElementRef
  } = props, others = _objectWithoutPropertiesLoose$2(props, _excluded$R);
  const [filterValueState, setFilterValueState] = React$6.useState((_item$value = item.value) != null ? _item$value : "");
  const id2 = unstable_useId();
  const rootProps = useGridRootProps();
  const currentColumn = item.columnField ? apiRef.current.getColumn(item.columnField) : null;
  const currentValueOptions = React$6.useMemo(() => {
    return typeof currentColumn.valueOptions === "function" ? currentColumn.valueOptions({
      field: currentColumn.field
    }) : currentColumn.valueOptions;
  }, [currentColumn]);
  const onFilterChange = React$6.useCallback((event) => {
    let value = event.target.value;
    value = getValueFromValueOptions(value, currentValueOptions);
    setFilterValueState(String(value));
    applyValue(_extends$5({}, item, {
      value
    }));
  }, [applyValue, item, currentValueOptions]);
  React$6.useEffect(() => {
    var _itemValue;
    let itemValue;
    if (currentValueOptions !== void 0) {
      itemValue = getValueFromValueOptions(item.value, currentValueOptions);
      if (itemValue !== item.value) {
        applyValue(_extends$5({}, item, {
          value: itemValue
        }));
        return;
      }
    } else {
      itemValue = item.value;
    }
    itemValue = (_itemValue = itemValue) != null ? _itemValue : "";
    setFilterValueState(String(itemValue));
  }, [item, currentValueOptions, applyValue]);
  return /* @__PURE__ */ jsx(rootProps.components.BaseTextField, _extends$5({
    id: id2,
    label: apiRef.current.getLocaleText("filterPanelInputLabel"),
    placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
    value: filterValueState,
    onChange: onFilterChange,
    type: type || "text",
    variant: "standard",
    InputLabelProps: {
      shrink: true
    },
    inputRef: focusElementRef,
    select: true,
    SelectProps: {
      native: true
    }
  }, others, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTextField, {
    children: renderSingleSelectOptions(apiRef.current.getColumn(item.columnField), apiRef.current)
  }));
}
const _excluded$Q = ["item", "applyValue", "type", "apiRef", "focusElementRef"];
const getSingleSelectOptionFormatter = ({
  valueFormatter,
  field
}, api) => (option) => {
  if (typeof option === "object") {
    return option.label;
  }
  return valueFormatter && option !== "" ? valueFormatter({
    value: option,
    field,
    api
  }) : option;
};
const isOptionEqualToValue = (option, value) => getValueFromOption(option) === getValueFromOption(value);
const filter$1 = createFilterOptions();
function GridFilterInputMultipleSingleSelect(props) {
  const {
    item,
    applyValue,
    apiRef,
    focusElementRef
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$Q);
  const id2 = unstable_useId();
  const resolvedColumn = item.columnField ? apiRef.current.getColumn(item.columnField) : null;
  const resolvedValueOptions = React$6.useMemo(() => {
    return typeof resolvedColumn.valueOptions === "function" ? resolvedColumn.valueOptions({
      field: resolvedColumn.field
    }) : resolvedColumn.valueOptions;
  }, [resolvedColumn]);
  const resolvedFormattedValueOptions = React$6.useMemo(() => {
    return resolvedValueOptions.map(getValueFromOption);
  }, [resolvedValueOptions]);
  const filterValueOptionFormatter = getSingleSelectOptionFormatter(apiRef.current.getColumn(item.columnField), apiRef.current);
  const filterValues = React$6.useMemo(() => {
    if (!Array.isArray(item.value)) {
      return [];
    }
    if (resolvedValueOptions !== void 0) {
      const itemValueIndexes = item.value.map((element) => {
        const formattedElement = getValueFromOption(element);
        const index = resolvedFormattedValueOptions.findIndex((formatedOption) => formatedOption === formattedElement);
        return index;
      });
      return itemValueIndexes.filter((index) => index >= 0).map((index) => resolvedValueOptions[index]);
    }
    return item.value;
  }, [item.value, resolvedValueOptions, resolvedFormattedValueOptions]);
  React$6.useEffect(() => {
    if (!Array.isArray(item.value) || filterValues.length !== item.value.length) {
      applyValue(_extends$5({}, item, {
        value: filterValues.map(getValueFromOption)
      }));
    }
  }, [item, filterValues, applyValue]);
  const handleChange = React$6.useCallback((event, value) => {
    applyValue(_extends$5({}, item, {
      value: [...value.map(getValueFromOption)]
    }));
  }, [applyValue, item]);
  return /* @__PURE__ */ jsx(Autocomplete, _extends$5({
    multiple: true,
    freeSolo: false,
    limitTags: 1,
    options: resolvedValueOptions,
    isOptionEqualToValue,
    filterOptions: filter$1,
    id: id2,
    value: filterValues,
    onChange: handleChange,
    renderTags: (value, getTagProps) => value.map((option, index) => /* @__PURE__ */ jsx(Chip, _extends$5({
      variant: "outlined",
      size: "small",
      label: filterValueOptionFormatter(option)
    }, getTagProps({
      index
    })))),
    renderInput: (params) => /* @__PURE__ */ jsx(TextField$1, _extends$5({}, params, {
      label: apiRef.current.getLocaleText("filterPanelInputLabel"),
      placeholder: apiRef.current.getLocaleText("filterPanelInputPlaceholder"),
      InputLabelProps: _extends$5({}, params.InputLabelProps, {
        shrink: true
      }),
      inputRef: focusElementRef,
      type: "singleSelect",
      variant: "standard"
    }))
  }, other));
}
const parseObjectValue = (value) => {
  if (value == null || typeof value !== "object") {
    return value;
  }
  return value.value;
};
const getGridSingleSelectOperators = () => [{
  value: "is",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return ({
      value
    }) => parseObjectValue(value) === parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "not",
  getApplyFilterFn: (filterItem) => {
    if (filterItem.value == null || filterItem.value === "") {
      return null;
    }
    return ({
      value
    }) => parseObjectValue(value) !== parseObjectValue(filterItem.value);
  },
  InputComponent: GridFilterInputSingleSelect
}, {
  value: "isAnyOf",
  getApplyFilterFn: (filterItem) => {
    if (!Array.isArray(filterItem.value) || filterItem.value.length === 0) {
      return null;
    }
    const filterItemValues = filterItem.value.map(parseObjectValue);
    return ({
      value
    }) => filterItemValues.includes(parseObjectValue(value));
  },
  InputComponent: GridFilterInputMultipleSingleSelect
}];
const GRID_SINGLE_SELECT_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  type: "singleSelect",
  renderEditCell: renderEditSingleSelectCell,
  filterOperators: getGridSingleSelectOperators()
});
const _excluded$P = ["open", "target", "onClickAway", "children", "position", "className", "onExited"];
const useUtilityClasses$z = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["menu"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridMenuRoot = styled(Popper, {
  name: "MuiDataGrid",
  slot: "Menu",
  overridesResolver: (props, styles) => styles.menu
})(({
  theme
}) => ({
  zIndex: theme.zIndex.modal,
  [`& .${gridClasses.menuList}`]: {
    outline: 0
  }
}));
const transformOrigin = {
  "bottom-start": "top left",
  "bottom-end": "top right"
};
const GridMenu = (props) => {
  var _rootProps$components;
  const {
    open,
    target,
    onClickAway,
    children,
    position,
    className,
    onExited
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$P);
  const prevTarget = React$6.useRef(target);
  const prevOpen = React$6.useRef(open);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$z(ownerState);
  React$6.useEffect(() => {
    if (prevOpen.current && prevTarget.current) {
      prevTarget.current.focus();
    }
    prevOpen.current = open;
    prevTarget.current = target;
  }, [open, target]);
  const handleExited = (popperOnExited) => (node) => {
    if (popperOnExited) {
      popperOnExited();
    }
    if (onExited) {
      onExited(node);
    }
  };
  return /* @__PURE__ */ jsx(GridMenuRoot, _extends$5({
    as: rootProps.components.BasePopper,
    className: clsx(className, classes2.root),
    open,
    anchorEl: target,
    transition: true,
    placement: position
  }, other, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.basePopper, {
    children: ({
      TransitionProps,
      placement
    }) => /* @__PURE__ */ jsx(ClickAwayListener, {
      onClickAway,
      children: /* @__PURE__ */ jsx(Grow, _extends$5({}, TransitionProps, {
        style: {
          transformOrigin: transformOrigin[placement]
        },
        onExited: handleExited(TransitionProps == null ? void 0 : TransitionProps.onExited),
        children: /* @__PURE__ */ jsx(Paper, {
          children
        })
      }))
    })
  }));
};
const hasActions = (colDef) => typeof colDef.getActions === "function";
const GridActionsCell = (props) => {
  const [open, setOpen] = React$6.useState(false);
  const buttonRef = React$6.useRef(null);
  const touchRippleRefs = React$6.useRef({});
  const menuId = unstable_useId();
  const buttonId = unstable_useId();
  const rootProps = useGridRootProps();
  const {
    colDef,
    id: id2,
    api,
    hasFocus,
    position = "bottom-end"
  } = props;
  React$6.useLayoutEffect(() => {
    if (!hasFocus) {
      Object.entries(touchRippleRefs.current).forEach(([index, ref]) => {
        ref == null ? void 0 : ref.stop({}, () => {
          delete touchRippleRefs.current[index];
        });
      });
    }
  }, [hasFocus]);
  if (!hasActions(colDef)) {
    throw new Error("MUI: Missing the `getActions` property in the `GridColDef`.");
  }
  const showMenu = () => setOpen(true);
  const hideMenu = () => setOpen(false);
  const options = colDef.getActions(api.getRowParams(id2));
  const iconButtons = options.filter((option) => !option.props.showInMenu);
  const menuButtons = options.filter((option) => option.props.showInMenu);
  const handleTouchRippleRef = (index) => (instance) => {
    touchRippleRefs.current[index] = instance;
  };
  return /* @__PURE__ */ jsxs("div", {
    className: gridClasses.actionsCell,
    children: [iconButtons.map((button, index) => /* @__PURE__ */ React$6.cloneElement(button, {
      key: index,
      touchRippleRef: handleTouchRippleRef(index)
    })), menuButtons.length > 0 && /* @__PURE__ */ jsx(IconButton, {
      ref: buttonRef,
      id: buttonId,
      "aria-label": api.getLocaleText("actionsCellMore"),
      "aria-controls": menuId,
      "aria-expanded": open ? "true" : void 0,
      "aria-haspopup": "true",
      size: "small",
      onClick: showMenu,
      children: /* @__PURE__ */ jsx(rootProps.components.MoreActionsIcon, {
        fontSize: "small"
      })
    }), menuButtons.length > 0 && /* @__PURE__ */ jsx(GridMenu, {
      id: menuId,
      onClickAway: hideMenu,
      onClick: hideMenu,
      open,
      target: buttonRef.current,
      position,
      "aria-labelledby": buttonId,
      children: /* @__PURE__ */ jsx(MenuList, {
        className: gridClasses.menuList,
        children: menuButtons.map((button, index) => /* @__PURE__ */ React$6.cloneElement(button, {
          key: index
        }))
      })
    })]
  });
};
const renderActionsCell = (params) => /* @__PURE__ */ jsx(GridActionsCell, _extends$5({}, params));
const GRID_ACTIONS_COLUMN_TYPE = "actions";
const GRID_ACTIONS_COL_DEF = _extends$5({}, GRID_STRING_COL_DEF, {
  sortable: false,
  filterable: false,
  width: 100,
  align: "center",
  headerAlign: "center",
  headerName: "",
  disableColumnMenu: true,
  disableExport: true,
  renderCell: renderActionsCell
});
const DEFAULT_GRID_COL_TYPE_KEY = "__default__";
const getGridDefaultColumnTypes = () => {
  const nativeColumnTypes = {
    string: GRID_STRING_COL_DEF,
    number: GRID_NUMERIC_COL_DEF,
    date: GRID_DATE_COL_DEF,
    dateTime: GRID_DATETIME_COL_DEF,
    boolean: GRID_BOOLEAN_COL_DEF,
    singleSelect: GRID_SINGLE_SELECT_COL_DEF,
    [GRID_ACTIONS_COLUMN_TYPE]: GRID_ACTIONS_COL_DEF
  };
  nativeColumnTypes[DEFAULT_GRID_COL_TYPE_KEY] = GRID_STRING_COL_DEF;
  return nativeColumnTypes;
};
const GridFeatureModeConstant = {
  client: "client",
  server: "server"
};
var GridLinkOperator;
(function(GridLinkOperator2) {
  GridLinkOperator2["And"] = "and";
  GridLinkOperator2["Or"] = "or";
})(GridLinkOperator || (GridLinkOperator = {}));
function checkGridRowIdIsValid(id2, row, detailErrorMessage = "A row was provided without id in the rows prop:") {
  if (id2 == null) {
    throw new Error(["MUI: The data grid component requires all rows to have a unique `id` property.", "Alternatively, you can use the `getRowId` prop to specify a custom id for each row.", detailErrorMessage, JSON.stringify(row)].join("\n"));
  }
}
var GridDensityTypes;
(function(GridDensityTypes2) {
  GridDensityTypes2["Compact"] = "compact";
  GridDensityTypes2["Standard"] = "standard";
  GridDensityTypes2["Comfortable"] = "comfortable";
})(GridDensityTypes || (GridDensityTypes = {}));
const gridFocusStateSelector = (state) => state.focus;
const gridFocusCellSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.cell);
const gridFocusColumnHeaderSelector = createSelector(gridFocusStateSelector, (focusState) => focusState.columnHeader);
const gridTabIndexStateSelector = (state) => state.tabIndex;
const gridTabIndexCellSelector = createSelector(gridTabIndexStateSelector, (state) => state.cell);
const gridTabIndexColumnHeaderSelector = createSelector(gridTabIndexStateSelector, (state) => state.columnHeader);
const _excluded$O = ["align", "children", "colIndex", "cellMode", "field", "formattedValue", "hasFocus", "height", "isEditable", "rowId", "tabIndex", "value", "width", "className", "showRightBorder", "extendRowFullWidth", "row", "onClick", "onDoubleClick", "onMouseDown", "onMouseUp", "onKeyDown", "onDragEnter", "onDragOver"];
let cachedSupportsPreventScroll;
function doesSupportPreventScroll() {
  if (cachedSupportsPreventScroll === void 0) {
    document.createElement("div").focus({
      get preventScroll() {
        cachedSupportsPreventScroll = true;
        return false;
      }
    });
  }
  return cachedSupportsPreventScroll;
}
const useUtilityClasses$y = (ownerState) => {
  const {
    align,
    showRightBorder,
    isEditable,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["cell", `cell--text${capitalize(align)}`, isEditable && "cell--editable", showRightBorder && "withBorder"],
    content: ["cellContent"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function GridCell(props) {
  const {
    align,
    children,
    colIndex,
    cellMode,
    field,
    formattedValue,
    hasFocus,
    height,
    isEditable,
    rowId,
    tabIndex,
    value,
    width,
    className,
    showRightBorder,
    onClick,
    onDoubleClick,
    onMouseDown,
    onMouseUp,
    onKeyDown,
    onDragEnter,
    onDragOver
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$O);
  const valueToRender = formattedValue == null ? value : formattedValue;
  const cellRef = React$6.useRef(null);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    align,
    showRightBorder,
    isEditable,
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$y(ownerState);
  const publishMouseUp = React$6.useCallback((eventName) => (event) => {
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (onMouseUp) {
      onMouseUp(event);
    }
  }, [apiRef, field, onMouseUp, rowId]);
  const publish = React$6.useCallback((eventName, propHandler) => (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    const params = apiRef.current.getCellParams(rowId, field || "");
    apiRef.current.publishEvent(eventName, params, event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, field, rowId]);
  const style2 = {
    minWidth: width,
    maxWidth: width,
    minHeight: height,
    maxHeight: height
  };
  React$6.useLayoutEffect(() => {
    if (!hasFocus || cellMode === GridCellModes.Edit) {
      return;
    }
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    if (cellRef.current && !cellRef.current.contains(doc.activeElement)) {
      const focusableElement = cellRef.current.querySelector('[tabindex="0"]');
      const elementToFocus = focusableElement || cellRef.current;
      if (doesSupportPreventScroll()) {
        elementToFocus.focus({
          preventScroll: true
        });
      } else {
        const scrollPosition = apiRef.current.getScrollPosition();
        elementToFocus.focus();
        apiRef.current.scroll(scrollPosition);
      }
    }
  }, [hasFocus, cellMode, apiRef]);
  let handleFocus = other.onFocus;
  return /* @__PURE__ */ jsx("div", _extends$5({
    ref: cellRef,
    className: clsx(className, classes2.root),
    role: "cell",
    "data-field": field,
    "data-colindex": colIndex,
    "aria-colindex": colIndex + 1,
    style: style2,
    tabIndex: cellMode === "view" || !isEditable ? tabIndex : -1,
    onClick: publish(GridEvents.cellClick, onClick),
    onDoubleClick: publish(GridEvents.cellDoubleClick, onDoubleClick),
    onMouseDown: publish(GridEvents.cellMouseDown, onMouseDown),
    onMouseUp: publishMouseUp(GridEvents.cellMouseUp),
    onKeyDown: publish(GridEvents.cellKeyDown, onKeyDown),
    onDragEnter: publish(GridEvents.cellDragEnter, onDragEnter),
    onDragOver: publish(GridEvents.cellDragOver, onDragOver)
  }, other, {
    onFocus: handleFocus,
    children: children != null ? children : /* @__PURE__ */ jsx("div", {
      className: classes2.content,
      children: valueToRender == null ? void 0 : valueToRender.toString()
    })
  }));
}
const GridRootStyles = styled("div", {
  name: "MuiDataGrid",
  slot: "Root",
  overridesResolver: (props, styles) => [
    {
      [`&.${gridClasses.autoHeight}`]: styles.autoHeight
    },
    {
      [`& .${gridClasses.editBooleanCell}`]: styles.editBooleanCell
    },
    {
      [`& .${gridClasses["cell--editing"]}`]: styles["cell--editing"]
    },
    {
      [`& .${gridClasses["cell--textCenter"]}`]: styles["cell--textCenter"]
    },
    {
      [`& .${gridClasses["cell--textLeft"]}`]: styles["cell--textLeft"]
    },
    {
      [`& .${gridClasses["cell--textRight"]}`]: styles["cell--textRight"]
    },
    {
      [`& .${gridClasses["cell--withRenderer"]}`]: styles["cell--withRenderer"]
    },
    {
      [`& .${gridClasses.cell}`]: styles.cell
    },
    {
      [`& .${gridClasses.cellContent}`]: styles.cellContent
    },
    {
      [`& .${gridClasses.cellCheckbox}`]: styles.cellCheckbox
    },
    {
      [`& .${gridClasses.checkboxInput}`]: styles.checkboxInput
    },
    {
      [`& .${gridClasses["columnHeader--alignCenter"]}`]: styles["columnHeader--alignCenter"]
    },
    {
      [`& .${gridClasses["columnHeader--alignLeft"]}`]: styles["columnHeader--alignLeft"]
    },
    {
      [`& .${gridClasses["columnHeader--alignRight"]}`]: styles["columnHeader--alignRight"]
    },
    {
      [`& .${gridClasses["columnHeader--dragging"]}`]: styles["columnHeader--dragging"]
    },
    {
      [`& .${gridClasses["columnHeader--moving"]}`]: styles["columnHeader--moving"]
    },
    {
      [`& .${gridClasses["columnHeader--numeric"]}`]: styles["columnHeader--numeric"]
    },
    {
      [`& .${gridClasses["columnHeader--sortable"]}`]: styles["columnHeader--sortable"]
    },
    {
      [`& .${gridClasses["columnHeader--sorted"]}`]: styles["columnHeader--sorted"]
    },
    {
      [`& .${gridClasses.columnHeader}`]: styles.columnHeader
    },
    {
      [`& .${gridClasses.columnHeaderCheckbox}`]: styles.columnHeaderCheckbox
    },
    {
      [`& .${gridClasses.columnHeaderDraggableContainer}`]: styles.columnHeaderDraggableContainer
    },
    {
      [`& .${gridClasses.columnHeaderTitleContainer}`]: styles.columnHeaderTitleContainer
    },
    {
      [`& .${gridClasses["columnSeparator--resizable"]}`]: styles["columnSeparator--resizable"]
    },
    {
      [`& .${gridClasses["columnSeparator--resizing"]}`]: styles["columnSeparator--resizing"]
    },
    {
      [`& .${gridClasses.columnSeparator}`]: styles.columnSeparator
    },
    {
      [`& .${gridClasses.filterIcon}`]: styles.filterIcon
    },
    {
      [`& .${gridClasses.iconSeparator}`]: styles.iconSeparator
    },
    {
      [`& .${gridClasses.menuIcon}`]: styles.menuIcon
    },
    {
      [`& .${gridClasses.menuIconButton}`]: styles.menuIconButton
    },
    {
      [`& .${gridClasses.menuOpen}`]: styles.menuOpen
    },
    {
      [`& .${gridClasses.menuList}`]: styles.menuList
    },
    {
      [`& .${gridClasses["row--editable"]}`]: styles["row--editable"]
    },
    {
      [`& .${gridClasses["row--editing"]}`]: styles["row--editing"]
    },
    {
      [`& .${gridClasses.row}`]: styles.row
    },
    {
      [`& .${gridClasses.sortIcon}`]: styles.sortIcon
    },
    {
      [`& .${gridClasses.withBorder}`]: styles.withBorder
    },
    {
      [`& .${gridClasses.treeDataGroupingCell}`]: styles.treeDataGroupingCell
    },
    {
      [`& .${gridClasses.treeDataGroupingCellToggle}`]: styles.treeDataGroupingCellToggle
    },
    {
      [`& .${gridClasses.detailPanelToggleCell}`]: styles.detailPanelToggleCell
    },
    {
      [`& .${gridClasses["detailPanelToggleCell--expanded"]}`]: styles["detailPanelToggleCell--expanded"]
    },
    styles.root
  ]
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68);
  const gridStyle = _extends$5({
    flex: 1,
    boxSizing: "border-box",
    position: "relative",
    border: `1px solid ${borderColor}`,
    borderRadius: theme.shape.borderRadius,
    color: theme.palette.text.primary
  }, theme.typography.body2, {
    outline: "none",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    [`&.${gridClasses.autoHeight}`]: {
      height: "auto",
      [`& .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
        borderColor: "transparent"
      }
    },
    [`& .${gridClasses["virtualScrollerContent--overflowed"]} .${gridClasses["row--lastVisible"]} .${gridClasses.cell}`]: {
      borderColor: "transparent"
    },
    [`& .${gridClasses.columnHeader}, & .${gridClasses.cell}`]: {
      WebkitTapHighlightColor: "transparent",
      lineHeight: null,
      padding: "0 10px",
      boxSizing: "border-box"
    },
    [`& .${gridClasses.columnHeader}:focus-within, & .${gridClasses.cell}:focus-within`]: {
      outline: `solid ${alpha(theme.palette.primary.main, 0.5)} 1px`,
      outlineWidth: 1,
      outlineOffset: -1
    },
    [`& .${gridClasses.columnHeader}:focus, & .${gridClasses.cell}:focus`]: {
      outline: `solid ${theme.palette.primary.main} 1px`
    },
    [`& .${gridClasses.columnHeaderCheckbox}, & .${gridClasses.cellCheckbox}`]: {
      padding: 0,
      justifyContent: "center",
      alignItems: "center"
    },
    [`& .${gridClasses.columnHeader}`]: {
      position: "relative",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses["columnHeader--sorted"]} .${gridClasses.iconButtonContainer}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}) .${gridClasses.sortIcon}`]: {
      opacity: 0,
      transition: theme.transitions.create(["opacity"], {
        duration: theme.transitions.duration.shorter
      })
    },
    [`& .${gridClasses.columnHeader}:not(.${gridClasses["columnHeader--sorted"]}):hover .${gridClasses.sortIcon}`]: {
      opacity: 0.5
    },
    [`& .${gridClasses.columnHeaderTitleContainer}`]: {
      display: "flex",
      alignItems: "center",
      minWidth: 0,
      flex: 1,
      whiteSpace: "nowrap",
      overflow: "hidden"
    },
    [`& .${gridClasses.columnHeaderTitleContainerContent}`]: {
      overflow: "hidden",
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses.sortIcon}, & .${gridClasses.filterIcon}`]: {
      fontSize: "inherit"
    },
    [`& .${gridClasses["columnHeader--sortable"]}`]: {
      cursor: "pointer"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      justifyContent: "center"
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderDraggableContainer}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.columnHeaderTitleContainer}`]: {
      flexDirection: "row-reverse"
    },
    [`& .${gridClasses["columnHeader--alignCenter"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
      marginRight: "auto",
      marginLeft: -6
    },
    [`& .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}, & .${gridClasses["columnHeader--alignRight"]} .${gridClasses.menuIcon}`]: {
      marginRight: "auto",
      marginLeft: -10
    },
    [`& .${gridClasses["columnHeader--moving"]}`]: {
      backgroundColor: theme.palette.action.hover
    },
    [`& .${gridClasses.columnSeparator}`]: {
      position: "absolute",
      zIndex: 100,
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      color: borderColor
    },
    [`& .${gridClasses["columnSeparator--sideLeft"]}`]: {
      left: -12
    },
    [`& .${gridClasses["columnSeparator--sideRight"]}`]: {
      right: -12
    },
    [`& .${gridClasses["columnSeparator--resizable"]}`]: {
      cursor: "col-resize",
      touchAction: "none",
      "&:hover": {
        color: theme.palette.text.primary,
        "@media (hover: none)": {
          color: borderColor
        }
      },
      [`&.${gridClasses["columnSeparator--resizing"]}`]: {
        color: theme.palette.text.primary
      }
    },
    [`& .${gridClasses.iconSeparator}`]: {
      color: "inherit"
    },
    [`& .${gridClasses.menuIcon}`]: {
      width: 0,
      visibility: "hidden",
      fontSize: 20,
      marginRight: -10,
      display: "flex",
      alignItems: "center"
    },
    [`& .${gridClasses.columnHeader}:hover`]: {
      [`& .${gridClasses.iconButtonContainer}`]: {
        visibility: "visible",
        width: "auto"
      },
      [`& .${gridClasses.menuIcon}`]: {
        width: "auto",
        visibility: "visible"
      }
    },
    [`.${gridClasses.menuOpen}`]: {
      visibility: "visible",
      width: "auto"
    },
    [`& .${gridClasses.row}`]: {
      display: "flex",
      width: "fit-content",
      breakInside: "avoid",
      "&:hover, &.Mui-hovered": {
        backgroundColor: theme.palette.action.hover,
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      "&.Mui-selected": {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        "&:hover, &.Mui-hovered": {
          backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
          }
        }
      }
    },
    [`& .${gridClasses.cell}`]: {
      display: "flex",
      alignItems: "center",
      overflow: "hidden",
      whiteSpace: "nowrap",
      borderBottom: `1px solid ${borderColor}`
    },
    [`& .${gridClasses.cellContent}`]: {
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    [`& .${gridClasses.cell}.${gridClasses["cell--editing"]}`]: {
      padding: 1,
      display: "flex",
      boxShadow: theme.shadows[2],
      backgroundColor: theme.palette.background.paper,
      "&:focus-within": {
        outline: `solid ${theme.palette.primary.main} 1px`,
        outlineOffset: "-1px"
      }
    },
    [`& .${gridClasses["row--editing"]}`]: {
      boxShadow: theme.shadows[2]
    },
    [`& .${gridClasses["row--editing"]} .${gridClasses.cell}`]: {
      boxShadow: theme.shadows[0],
      backgroundColor: theme.palette.background.paper
    },
    [`& .${gridClasses.editBooleanCell}`]: {
      display: "flex",
      height: "100%",
      width: "100%",
      alignItems: "center",
      justifyContent: "center"
    },
    [`& .${gridClasses.booleanCell}[data-value="true"]`]: {
      color: theme.palette.text.secondary
    },
    [`& .${gridClasses.booleanCell}[data-value="false"]`]: {
      color: theme.palette.text.disabled
    },
    [`& .${gridClasses.actionsCell}`]: {
      display: "inline-flex",
      alignItems: "center",
      gridGap: theme.spacing(1)
    },
    [`& .${gridClasses.withBorder}`]: {
      borderRight: `1px solid ${borderColor}`
    },
    [`& .${gridClasses["cell--textLeft"]}`]: {
      justifyContent: "flex-start"
    },
    [`& .${gridClasses["cell--textRight"]}`]: {
      justifyContent: "flex-end"
    },
    [`& .${gridClasses["cell--textCenter"]}`]: {
      justifyContent: "center"
    },
    [`& .${gridClasses.columnHeaderDraggableContainer}`]: {
      display: "flex",
      width: "100%"
    },
    [`& .${gridClasses["columnHeader--dragging"]}`]: {
      background: theme.palette.background.paper,
      padding: "0 12px",
      borderRadius: theme.shape.borderRadius,
      opacity: theme.palette.action.disabledOpacity
    },
    [`& .${gridClasses.treeDataGroupingCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.treeDataGroupingCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: theme.spacing(2)
    },
    [`& .${gridClasses.groupingCriteriaCell}`]: {
      display: "flex",
      alignItems: "center",
      width: "100%"
    },
    [`& .${gridClasses.groupingCriteriaCellToggle}`]: {
      flex: "0 0 28px",
      alignSelf: "stretch",
      marginRight: theme.spacing(2)
    }
  });
  return gridStyle;
});
const _excluded$N = ["children", "className"];
const GridRoot = /* @__PURE__ */ React$6.forwardRef(function GridRoot2(props, ref) {
  var _rootProps$classes;
  const rootProps = useGridRootProps();
  const {
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$N);
  const apiRef = useGridApiContext();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const totalRowCount = useGridSelector(apiRef, gridRowCountSelector);
  const rootContainerRef = React$6.useRef(null);
  const handleRef = useForkRef(rootContainerRef, ref);
  apiRef.current.rootElementRef = rootContainerRef;
  return /* @__PURE__ */ jsx(NoSsr, {
    children: /* @__PURE__ */ jsx(GridRootStyles, _extends$5({
      ref: handleRef,
      className: clsx(className, (_rootProps$classes = rootProps.classes) == null ? void 0 : _rootProps$classes.root, gridClasses.root, rootProps.autoHeight && gridClasses.autoHeight),
      role: "grid",
      "aria-colcount": visibleColumns.length,
      "aria-rowcount": totalRowCount,
      "aria-multiselectable": !rootProps.disableMultipleSelection,
      "aria-label": rootProps["aria-label"],
      "aria-labelledby": rootProps["aria-labelledby"]
    }, other, {
      children
    }))
  });
});
const _excluded$M = ["className"];
const useUtilityClasses$x = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["footerContainer"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridFooterContainerRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "FooterContainer",
  overridesResolver: (props, styles) => styles.footerContainer
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68);
  return {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
    minHeight: 52,
    borderTop: `1px solid ${borderColor}`
  };
});
const GridFooterContainer = /* @__PURE__ */ React$6.forwardRef(function GridFooterContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$M);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$x(ownerState);
  return /* @__PURE__ */ jsx(GridFooterContainerRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
const _excluded$L = ["className"];
const useUtilityClasses$w = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["overlay"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridOverlayRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "Overlay",
  overridesResolver: (props, styles) => styles.overlay
})(({
  theme
}) => ({
  display: "flex",
  height: "100%",
  alignSelf: "center",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: alpha(theme.palette.background.default, theme.palette.action.disabledOpacity)
}));
const GridOverlay = /* @__PURE__ */ React$6.forwardRef(function GridOverlay2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$L);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$w(ownerState);
  return /* @__PURE__ */ jsx(GridOverlayRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
const _excluded$K = ["className"];
const useUtilityClasses$v = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["iconButtonContainer"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridIconButtonContainerRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "IconButtonContainer",
  overridesResolver: (props, styles) => styles.iconButtonContainer
})(() => ({
  display: "flex",
  visibility: "hidden",
  width: 0
}));
const GridIconButtonContainer = /* @__PURE__ */ React$6.forwardRef(function GridIconButtonContainer2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$K);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$v(ownerState);
  return /* @__PURE__ */ jsx(GridIconButtonContainerRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
const useUtilityClasses$u = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    icon: ["sortIcon"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function getIcon(icons2, direction, className, sortingOrder) {
  let Icon;
  const iconProps = {};
  if (direction === "asc") {
    Icon = icons2.ColumnSortedAscendingIcon;
  } else if (direction === "desc") {
    Icon = icons2.ColumnSortedDescendingIcon;
  } else {
    Icon = icons2.ColumnUnsortedIcon;
    iconProps.sortingOrder = sortingOrder;
  }
  return Icon ? /* @__PURE__ */ jsx(Icon, _extends$5({
    fontSize: "small",
    className
  }, iconProps)) : null;
}
function GridColumnHeaderSortIconRaw(props) {
  const {
    direction,
    index,
    sortingOrder
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$5({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$u(ownerState);
  const iconElement = getIcon(rootProps.components, direction, classes2.icon, sortingOrder);
  if (!iconElement) {
    return null;
  }
  const iconButton = /* @__PURE__ */ jsx(IconButton, {
    tabIndex: -1,
    "aria-label": apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    title: apiRef.current.getLocaleText("columnHeaderSortIconLabel"),
    size: "small",
    children: iconElement
  });
  return /* @__PURE__ */ jsxs(GridIconButtonContainer, {
    children: [index != null && /* @__PURE__ */ jsx(Badge, {
      badgeContent: index,
      color: "default",
      children: iconButton
    }), index == null && iconButton]
  });
}
const GridColumnHeaderSortIcon = /* @__PURE__ */ React$6.memo(GridColumnHeaderSortIconRaw);
function isOverflown(element) {
  return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;
}
function findParentElementFromClassName(elem, className) {
  return elem.closest(`.${className}`);
}
function isGridCellRoot(elem) {
  return elem != null && elem.classList.contains(gridClasses.cell);
}
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}
function getGridColumnHeaderElement(root2, field) {
  return root2.querySelector(`[role="columnheader"][data-field="${escapeOperandAttributeSelector(field)}"]`);
}
function getGridRowElement(root2, id2) {
  return root2.querySelector(`.${gridClasses.row}[data-id="${escapeOperandAttributeSelector(String(id2))}"]`);
}
function getGridCellElement(root2, {
  id: id2,
  field
}) {
  const row = getGridRowElement(root2, id2);
  if (!row) {
    return null;
  }
  return row.querySelector(`.${gridClasses.cell}[data-field="${escapeOperandAttributeSelector(field)}"]`);
}
const _excluded$J = ["className"];
const useUtilityClasses$t = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnHeaderTitle"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridColumnHeaderTitleRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaderTitle",
  overridesResolver: (props, styles) => styles.columnHeaderTitle
})(({
  theme
}) => ({
  textOverflow: "ellipsis",
  overflow: "hidden",
  whiteSpace: "nowrap",
  fontWeight: theme.typography.fontWeightMedium
}));
const ColumnHeaderInnerTitle = /* @__PURE__ */ React$6.forwardRef(function ColumnHeaderInnerTitle2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$J);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$t(ownerState);
  return /* @__PURE__ */ jsx(GridColumnHeaderTitleRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
function GridColumnHeaderTitle(props) {
  var _rootProps$components;
  const {
    label,
    description,
    columnWidth
  } = props;
  const rootProps = useGridRootProps();
  const titleRef = React$6.useRef(null);
  const [tooltip, setTooltip] = React$6.useState("");
  React$6.useEffect(() => {
    if (!description && titleRef && titleRef.current) {
      const isOver = isOverflown(titleRef.current);
      if (isOver) {
        setTooltip(label);
      } else {
        setTooltip("");
      }
    }
  }, [titleRef, columnWidth, description, label]);
  return /* @__PURE__ */ jsx(rootProps.components.BaseTooltip, _extends$5({
    title: description || tooltip
  }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTooltip, {
    children: /* @__PURE__ */ jsx(ColumnHeaderInnerTitle, {
      ref: titleRef,
      children: label
    })
  }));
}
const _excluded$I = ["resizable", "resizing", "height", "side"];
var GridColumnHeaderSeparatorSides;
(function(GridColumnHeaderSeparatorSides2) {
  GridColumnHeaderSeparatorSides2["Left"] = "left";
  GridColumnHeaderSeparatorSides2["Right"] = "right";
})(GridColumnHeaderSeparatorSides || (GridColumnHeaderSeparatorSides = {}));
const useUtilityClasses$s = (ownerState) => {
  const {
    resizable,
    resizing,
    classes: classes2,
    side
  } = ownerState;
  const slots = {
    root: ["columnSeparator", resizable && "columnSeparator--resizable", resizing && "columnSeparator--resizing", side && `columnSeparator--side${capitalize(side)}`],
    icon: ["iconSeparator"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function GridColumnHeaderSeparatorRaw(props) {
  const {
    height,
    side = GridColumnHeaderSeparatorSides.Right
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$I);
  const rootProps = useGridRootProps();
  const ownerState = _extends$5({}, props, {
    side,
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$s(ownerState);
  const stopClick = React$6.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
  }, []);
  return /* @__PURE__ */ jsx("div", _extends$5({
    className: classes2.root,
    style: {
      minHeight: height,
      opacity: rootProps.showColumnRightBorder ? 0 : 1
    }
  }, other, {
    onClick: stopClick,
    children: /* @__PURE__ */ jsx(rootProps.components.ColumnResizeIcon, {
      className: classes2.icon
    })
  }));
}
const GridColumnHeaderSeparator = /* @__PURE__ */ React$6.memo(GridColumnHeaderSeparatorRaw);
const useUtilityClasses$r = (ownerState) => {
  const {
    classes: classes2,
    open
  } = ownerState;
  const slots = {
    root: ["menuIcon", open && "menuOpen"],
    button: ["menuIconButton"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const ColumnHeaderMenuIcon = /* @__PURE__ */ React$6.memo((props) => {
  const {
    column,
    open,
    columnMenuId,
    columnMenuButtonId,
    iconButtonRef
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$5({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$r(ownerState);
  const handleMenuIconClick = React$6.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    apiRef.current.toggleColumnMenu(column.field);
  }, [apiRef, column.field]);
  return /* @__PURE__ */ jsx("div", {
    className: classes2.root,
    children: /* @__PURE__ */ jsx(IconButton, {
      ref: iconButtonRef,
      tabIndex: -1,
      className: classes2.button,
      "aria-label": apiRef.current.getLocaleText("columnMenuLabel"),
      title: apiRef.current.getLocaleText("columnMenuLabel"),
      size: "small",
      onClick: handleMenuIconClick,
      "aria-expanded": open ? "true" : void 0,
      "aria-haspopup": "true",
      "aria-controls": columnMenuId,
      id: columnMenuButtonId,
      children: /* @__PURE__ */ jsx(rootProps.components.ColumnMenuIcon, {
        fontSize: "small"
      })
    })
  });
});
const gridPreferencePanelStateSelector = (state) => state.preferencePanel;
var GridPreferencePanelsValue;
(function(GridPreferencePanelsValue2) {
  GridPreferencePanelsValue2["filters"] = "filters";
  GridPreferencePanelsValue2["columns"] = "columns";
})(GridPreferencePanelsValue || (GridPreferencePanelsValue = {}));
const useUtilityClasses$q = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    icon: ["filterIcon"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function ColumnHeaderFilterIcon(props) {
  var _rootProps$components;
  const {
    counter
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = _extends$5({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$q(ownerState);
  const toggleFilter = React$6.useCallback((event) => {
    event.preventDefault();
    event.stopPropagation();
    const {
      open,
      openedPanelValue
    } = gridPreferencePanelStateSelector(apiRef.current.state);
    if (open && openedPanelValue === GridPreferencePanelsValue.filters) {
      apiRef.current.hideFilterPanel();
    } else {
      apiRef.current.showFilterPanel();
    }
  }, [apiRef]);
  if (!counter) {
    return null;
  }
  const iconButton = /* @__PURE__ */ jsx(IconButton, {
    onClick: toggleFilter,
    color: "default",
    "aria-label": apiRef.current.getLocaleText("columnHeaderFiltersLabel"),
    size: "small",
    tabIndex: -1,
    children: /* @__PURE__ */ jsx(rootProps.components.ColumnFilteredIcon, {
      className: classes2.icon,
      fontSize: "small"
    })
  });
  return /* @__PURE__ */ jsx(rootProps.components.BaseTooltip, _extends$5({
    title: apiRef.current.getLocaleText("columnHeaderFiltersTooltipActive")(counter),
    enterDelay: 1e3
  }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTooltip, {
    children: /* @__PURE__ */ jsxs(GridIconButtonContainer, {
      children: [counter > 1 && /* @__PURE__ */ jsx(Badge, {
        badgeContent: counter,
        color: "default",
        children: iconButton
      }), counter === 1 && iconButton]
    })
  }));
}
function GridColumnHeaderMenu({
  columnMenuId,
  columnMenuButtonId,
  ContentComponent,
  contentComponentProps,
  field,
  open,
  target,
  onExited
}) {
  const apiRef = useGridApiContext();
  const currentColumn = apiRef.current.getColumn(field);
  const hideMenu = React$6.useCallback((event) => {
    event.stopPropagation();
    apiRef.current.hideColumnMenu();
  }, [apiRef]);
  if (!target) {
    return null;
  }
  return /* @__PURE__ */ jsx(GridMenu, {
    placement: `bottom-${currentColumn.align === "right" ? "start" : "end"}`,
    open,
    target,
    onClickAway: hideMenu,
    onExited,
    children: /* @__PURE__ */ jsx(ContentComponent, _extends$5({
      currentColumn,
      hideMenu,
      open,
      id: columnMenuId,
      labelledby: columnMenuButtonId
    }, contentComponentProps))
  });
}
const useUtilityClasses$p = (ownerState) => {
  const {
    column,
    classes: classes2,
    isDragging,
    sortDirection,
    showRightBorder
  } = ownerState;
  const isColumnSorted = sortDirection != null;
  const isColumnNumeric = column.type === "number";
  const slots = {
    root: ["columnHeader", column.headerAlign === "left" && "columnHeader--alignLeft", column.headerAlign === "center" && "columnHeader--alignCenter", column.headerAlign === "right" && "columnHeader--alignRight", column.sortable && "columnHeader--sortable", isDragging && "columnHeader--moving", isColumnSorted && "columnHeader--sorted", isColumnNumeric && "columnHeader--numeric", showRightBorder && "withBorder"],
    draggableContainer: ["columnHeaderDraggableContainer"],
    titleContainer: ["columnHeaderTitleContainer"],
    titleContainerContent: ["columnHeaderTitleContainerContent"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
function GridColumnHeaderItem(props) {
  var _apiRef$current$getRo, _column$sortingOrder, _column$headerName, _rootProps$components;
  const {
    column,
    columnMenuOpen,
    colIndex,
    headerHeight,
    isResizing,
    isLastColumn,
    sortDirection,
    sortIndex,
    filterItemsCounter,
    hasFocus,
    tabIndex,
    extendRowFullWidth,
    disableReorder,
    separatorSide
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const headerCellRef = React$6.useRef(null);
  const columnMenuId = unstable_useId();
  const columnMenuButtonId = unstable_useId();
  const iconButtonRef = React$6.useRef(null);
  const [showColumnMenuIcon, setShowColumnMenuIcon] = React$6.useState(columnMenuOpen);
  const {
    hasScrollX,
    hasScrollY
  } = (_apiRef$current$getRo = apiRef.current.getRootDimensions()) != null ? _apiRef$current$getRo : {
    hasScrollX: false,
    hasScrollY: false
  };
  let headerComponent = null;
  if (column.renderHeader) {
    headerComponent = column.renderHeader(apiRef.current.getColumnHeaderParams(column.field));
  }
  const publish = React$6.useCallback((eventName) => (event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getColumnHeaderParams(column.field), event);
  }, [apiRef, column.field]);
  const mouseEventsHandlers = {
    onClick: publish(GridEvents.columnHeaderClick),
    onDoubleClick: publish(GridEvents.columnHeaderDoubleClick),
    onMouseOver: publish(GridEvents.columnHeaderOver),
    onMouseOut: publish(GridEvents.columnHeaderOut),
    onMouseEnter: publish(GridEvents.columnHeaderEnter),
    onMouseLeave: publish(GridEvents.columnHeaderLeave),
    onKeyDown: publish(GridEvents.columnHeaderKeyDown),
    onFocus: publish(GridEvents.columnHeaderFocus),
    onBlur: publish(GridEvents.columnHeaderBlur)
  };
  const draggableEventHandlers = {
    onDragStart: publish(GridEvents.columnHeaderDragStart),
    onDragEnter: publish(GridEvents.columnHeaderDragEnter),
    onDragOver: publish(GridEvents.columnHeaderDragOver),
    onDragEnd: publish(GridEvents.columnHeaderDragEnd)
  };
  const removeLastBorderRight = isLastColumn && hasScrollX && !hasScrollY;
  const showRightBorder = !isLastColumn ? rootProps.showColumnRightBorder : !removeLastBorderRight && !extendRowFullWidth;
  const ownerState = _extends$5({}, props, {
    classes: rootProps.classes,
    showRightBorder
  });
  const classes2 = useUtilityClasses$p(ownerState);
  const width = column.computedWidth;
  let ariaSort;
  if (sortDirection != null) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  React$6.useEffect(() => {
    if (!showColumnMenuIcon) {
      setShowColumnMenuIcon(columnMenuOpen);
    }
  }, [showColumnMenuIcon, columnMenuOpen]);
  const handleExited = React$6.useCallback(() => {
    setShowColumnMenuIcon(false);
  }, []);
  const columnMenuIconButton = !rootProps.disableColumnMenu && !column.disableColumnMenu && /* @__PURE__ */ jsx(ColumnHeaderMenuIcon, {
    column,
    columnMenuId,
    columnMenuButtonId,
    open: showColumnMenuIcon,
    iconButtonRef
  });
  const sortingOrder = (_column$sortingOrder = column.sortingOrder) != null ? _column$sortingOrder : rootProps.sortingOrder;
  const columnTitleIconButtons = /* @__PURE__ */ jsxs(React$6.Fragment, {
    children: [!rootProps.disableColumnFilter && /* @__PURE__ */ jsx(ColumnHeaderFilterIcon, {
      counter: filterItemsCounter
    }), column.sortable && !column.hideSortIcons && /* @__PURE__ */ jsx(GridColumnHeaderSortIcon, {
      direction: sortDirection,
      index: sortIndex,
      sortingOrder
    })]
  });
  React$6.useLayoutEffect(() => {
    const columnMenuState = apiRef.current.state.columnMenu;
    if (hasFocus && !columnMenuState.open) {
      const focusableElement = headerCellRef.current.querySelector('[tabindex="0"]');
      if (focusableElement) {
        focusableElement.focus();
      } else {
        headerCellRef.current.focus();
      }
    }
  });
  const headerClassName = typeof column.headerClassName === "function" ? column.headerClassName({
    field: column.field,
    colDef: column
  }) : column.headerClassName;
  return /* @__PURE__ */ jsxs("div", _extends$5({
    ref: headerCellRef,
    className: clsx(classes2.root, headerClassName),
    "data-field": column.field,
    style: {
      width,
      minWidth: width,
      maxWidth: width
    },
    role: "columnheader",
    tabIndex,
    "aria-colindex": colIndex + 1,
    "aria-sort": ariaSort
  }, mouseEventsHandlers, {
    children: [/* @__PURE__ */ jsxs("div", _extends$5({
      className: classes2.draggableContainer,
      draggable: !rootProps.disableColumnReorder && !disableReorder && !column.disableReorder
    }, draggableEventHandlers, {
      children: [/* @__PURE__ */ jsxs("div", {
        className: classes2.titleContainer,
        children: [/* @__PURE__ */ jsx("div", {
          className: classes2.titleContainerContent,
          children: headerComponent || /* @__PURE__ */ jsx(GridColumnHeaderTitle, {
            label: (_column$headerName = column.headerName) != null ? _column$headerName : column.field,
            description: column.description,
            columnWidth: width
          })
        }), columnTitleIconButtons]
      }), columnMenuIconButton]
    })), /* @__PURE__ */ jsx(GridColumnHeaderSeparator, {
      resizable: !rootProps.disableColumnResize && !!column.resizable,
      resizing: isResizing,
      height: headerHeight,
      onMouseDown: publish(GridEvents.columnSeparatorMouseDown),
      side: separatorSide
    }), /* @__PURE__ */ jsx(GridColumnHeaderMenu, {
      columnMenuId,
      columnMenuButtonId,
      field: column.field,
      open: columnMenuOpen,
      target: iconButtonRef.current,
      ContentComponent: rootProps.components.ColumnMenu,
      contentComponentProps: (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.columnMenu,
      onExited: handleExited
    })]
  }));
}
const _excluded$H = ["field", "id", "value", "formattedValue", "row", "rowNode", "colDef", "isEditable", "cellMode", "hasFocus", "tabIndex", "getValue"];
const useUtilityClasses$o = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridCellCheckboxForwardRef = /* @__PURE__ */ React$6.forwardRef(function GridCellCheckboxRenderer(props, ref) {
  var _rootProps$components;
  const {
    field,
    id: id2,
    value: isChecked,
    hasFocus,
    tabIndex
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$H);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$o(ownerState);
  const checkboxElement = React$6.useRef(null);
  const rippleRef = React$6.useRef();
  const handleRef = useForkRef(checkboxElement, ref);
  const element = apiRef.current.getCellElement(id2, field);
  const handleChange = (event) => {
    const params = {
      value: event.target.checked,
      id: id2
    };
    apiRef.current.publishEvent(GridEvents.rowSelectionCheckboxChange, params, event);
  };
  React$6.useLayoutEffect(() => {
    if (tabIndex === 0 && element) {
      element.tabIndex = -1;
    }
  }, [element, tabIndex]);
  React$6.useLayoutEffect(() => {
    if (hasFocus) {
      var _checkboxElement$curr;
      const input = (_checkboxElement$curr = checkboxElement.current) == null ? void 0 : _checkboxElement$curr.querySelector("input");
      input == null ? void 0 : input.focus();
    } else if (rippleRef.current) {
      rippleRef.current.stop({});
    }
  }, [hasFocus]);
  const handleKeyDown = React$6.useCallback((event) => {
    if (isSpaceKey(event.key)) {
      event.stopPropagation();
    }
    if (isNavigationKey(event.key) && !event.shiftKey) {
      apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, props, event);
    }
  }, [apiRef, props]);
  const isSelectable = !rootProps.isRowSelectable || rootProps.isRowSelectable(apiRef.current.getRowParams(id2));
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectRow" : "checkboxSelectionSelectRow");
  return /* @__PURE__ */ jsx(rootProps.components.BaseCheckbox, _extends$5({
    ref: handleRef,
    tabIndex,
    checked: isChecked,
    onChange: handleChange,
    className: classes2.root,
    color: "primary",
    inputProps: {
      "aria-label": label
    },
    onKeyDown: handleKeyDown,
    disabled: !isSelectable,
    touchRippleRef: rippleRef
  }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseCheckbox, other));
});
const GridCellCheckboxRenderer2 = /* @__PURE__ */ React$6.memo(GridCellCheckboxForwardRef);
const gridSelectionStateSelector = (state) => state.selection;
const selectedGridRowsCountSelector = createSelector(gridSelectionStateSelector, (selection) => selection.length);
const selectedGridRowsSelector = createSelector(gridSelectionStateSelector, gridRowsLookupSelector, (selectedRows, rowsLookup) => new Map(selectedRows.map((id2) => [id2, rowsLookup[id2]])));
const selectedIdsLookupSelector = createSelector(gridSelectionStateSelector, (selection) => selection.reduce((lookup, rowId) => {
  lookup[rowId] = rowId;
  return lookup;
}, {}));
const gridPaginationSelector = (state) => state.pagination;
const gridPageSelector = createSelector(gridPaginationSelector, (pagination) => pagination.page);
const gridPageSizeSelector = createSelector(gridPaginationSelector, (pagination) => pagination.pageSize);
createSelector(gridPaginationSelector, (pagination) => pagination.pageCount);
const gridPaginationRowRangeSelector = createSelector(gridPaginationSelector, gridRowTreeSelector, gridRowTreeDepthSelector, gridVisibleSortedRowEntriesSelector, gridVisibleSortedTopLevelRowEntriesSelector, (pagination, rowTree, rowTreeDepth, visibleSortedRowEntries, visibleSortedTopLevelRowEntries) => {
  const visibleTopLevelRowCount = visibleSortedTopLevelRowEntries.length;
  const topLevelFirstRowIndex = Math.min(pagination.pageSize * pagination.page, visibleTopLevelRowCount - 1);
  const topLevelLastRowIndex = Math.min(topLevelFirstRowIndex + pagination.pageSize - 1, visibleTopLevelRowCount - 1);
  if (topLevelFirstRowIndex === -1 || topLevelLastRowIndex === -1) {
    return null;
  }
  if (rowTreeDepth < 2) {
    return {
      firstRowIndex: topLevelFirstRowIndex,
      lastRowIndex: topLevelLastRowIndex
    };
  }
  const topLevelFirstRow = visibleSortedTopLevelRowEntries[topLevelFirstRowIndex];
  const topLevelRowsInCurrentPageCount = topLevelLastRowIndex - topLevelFirstRowIndex + 1;
  const firstRowIndex = visibleSortedRowEntries.findIndex((row) => row.id === topLevelFirstRow.id);
  let lastRowIndex = firstRowIndex;
  let topLevelRowAdded = 0;
  while (lastRowIndex < visibleSortedRowEntries.length && topLevelRowAdded <= topLevelRowsInCurrentPageCount) {
    const row = visibleSortedRowEntries[lastRowIndex];
    const depth = rowTree[row.id].depth;
    if (topLevelRowAdded < topLevelRowsInCurrentPageCount || depth > 0) {
      lastRowIndex += 1;
    }
    if (depth === 0) {
      topLevelRowAdded += 1;
    }
  }
  return {
    firstRowIndex,
    lastRowIndex: lastRowIndex - 1
  };
});
const gridPaginatedVisibleSortedGridRowEntriesSelector = createSelector(gridVisibleSortedRowEntriesSelector, gridPaginationRowRangeSelector, (visibleSortedRowEntries, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowEntries.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const gridPaginatedVisibleSortedGridRowIdsSelector = createSelector(gridVisibleSortedRowIdsSelector, gridPaginationRowRangeSelector, (visibleSortedRowIds, paginationRange) => {
  if (!paginationRange) {
    return [];
  }
  return visibleSortedRowIds.slice(paginationRange.firstRowIndex, paginationRange.lastRowIndex + 1);
});
const _excluded$G = ["field", "colDef"];
const useUtilityClasses$n = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["checkboxInput"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridHeaderCheckbox = /* @__PURE__ */ React$6.forwardRef(function GridHeaderCheckbox2(props, ref) {
  var _rootProps$components;
  const other = _objectWithoutPropertiesLoose$2(props, _excluded$G);
  const [, forceUpdate] = React$6.useState(false);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$n(ownerState);
  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const selection = useGridSelector(apiRef, gridSelectionStateSelector);
  const visibleRowIds = useGridSelector(apiRef, gridVisibleSortedRowIdsSelector);
  const paginatedVisibleRowIds = useGridSelector(apiRef, gridPaginatedVisibleSortedGridRowIdsSelector);
  const filteredSelection = React$6.useMemo(() => {
    if (typeof rootProps.isRowSelectable !== "function") {
      return selection;
    }
    return selection.filter((id2) => {
      if (!apiRef.current.getRow(id2)) {
        return false;
      }
      return rootProps.isRowSelectable(apiRef.current.getRowParams(id2));
    });
  }, [apiRef, rootProps.isRowSelectable, selection]);
  const selectionCandidates = React$6.useMemo(() => {
    const rowIds = !rootProps.pagination || !rootProps.checkboxSelectionVisibleOnly ? visibleRowIds : paginatedVisibleRowIds;
    return rowIds.reduce((acc, id2) => {
      acc[id2] = true;
      return acc;
    }, {});
  }, [rootProps.pagination, rootProps.checkboxSelectionVisibleOnly, paginatedVisibleRowIds, visibleRowIds]);
  const currentSelectionSize = React$6.useMemo(() => filteredSelection.filter((id2) => selectionCandidates[id2]).length, [filteredSelection, selectionCandidates]);
  const isIndeterminate = currentSelectionSize > 0 && currentSelectionSize < Object.keys(selectionCandidates).length;
  const isChecked = currentSelectionSize > 0;
  const handleChange = (event) => {
    const params = {
      value: event.target.checked
    };
    apiRef.current.publishEvent(GridEvents.headerSelectionCheckboxChange, params);
  };
  const tabIndex = tabIndexState !== null && tabIndexState.field === props.field ? 0 : -1;
  React$6.useLayoutEffect(() => {
    const element = apiRef.current.getColumnHeaderElement(props.field);
    if (tabIndex === 0 && element) {
      element.tabIndex = -1;
    }
  }, [tabIndex, apiRef, props.field]);
  const handleKeyDown = React$6.useCallback((event) => {
    if (event.key === " ") {
      apiRef.current.publishEvent(GridEvents.headerSelectionCheckboxChange, {
        value: !isChecked
      });
    }
    if (isNavigationKey(event.key) && !event.shiftKey) {
      apiRef.current.publishEvent(GridEvents.columnHeaderNavigationKeyDown, props, event);
    }
  }, [apiRef, props, isChecked]);
  const handleSelectionChange = React$6.useCallback(() => {
    forceUpdate((p2) => !p2);
  }, []);
  React$6.useEffect(() => {
    return apiRef.current.subscribeEvent(GridEvents.selectionChange, handleSelectionChange);
  }, [apiRef, handleSelectionChange]);
  const label = apiRef.current.getLocaleText(isChecked ? "checkboxSelectionUnselectAllRows" : "checkboxSelectionSelectAllRows");
  return /* @__PURE__ */ jsx(rootProps.components.BaseCheckbox, _extends$5({
    ref,
    indeterminate: isIndeterminate,
    checked: isChecked,
    onChange: handleChange,
    className: classes2.root,
    color: "primary",
    inputProps: {
      "aria-label": label
    },
    tabIndex,
    onKeyDown: handleKeyDown
  }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseCheckbox, other));
});
const GridColumnsMenuItem = (props) => {
  const {
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showColumns = React$6.useCallback((event) => {
    onClick(event);
    apiRef.current.showPreferences(GridPreferencePanelsValue.columns);
  }, [apiRef, onClick]);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  return /* @__PURE__ */ jsx(MenuItem, {
    onClick: showColumns,
    children: apiRef.current.getLocaleText("columnMenuShowColumns")
  });
};
const GridFilterMenuItem = (props) => {
  const {
    column,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const showFilter = React$6.useCallback((event) => {
    onClick(event);
    apiRef.current.showFilterPanel(column == null ? void 0 : column.field);
  }, [apiRef, column == null ? void 0 : column.field, onClick]);
  if (rootProps.disableColumnFilter || !(column != null && column.filterable)) {
    return null;
  }
  return /* @__PURE__ */ jsx(MenuItem, {
    onClick: showFilter,
    children: apiRef.current.getLocaleText("columnMenuFilter")
  });
};
const _excluded$F = ["hideMenu", "currentColumn", "open", "id", "labelledby", "className", "children"];
const GridColumnMenuContainer = /* @__PURE__ */ React$6.forwardRef(function GridColumnMenuContainer2(props, ref) {
  const {
    hideMenu,
    open,
    id: id2,
    labelledby,
    className,
    children
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$F);
  const handleListKeyDown = React$6.useCallback((event) => {
    if (isTabKey(event.key)) {
      event.preventDefault();
    }
    if (isHideMenuKey(event.key)) {
      hideMenu(event);
    }
  }, [hideMenu]);
  return /* @__PURE__ */ jsx(MenuList, _extends$5({
    id: id2,
    ref,
    className: clsx(gridClasses.menuList, className),
    "aria-labelledby": labelledby,
    onKeyDown: handleListKeyDown,
    autoFocus: open
  }, other, {
    children
  }));
});
const computeColumnTypes = (customColumnTypes = {}) => {
  const allColumnTypes = _extends$5({}, getGridDefaultColumnTypes(), customColumnTypes);
  const mergedColumnTypes = {};
  Object.entries(allColumnTypes).forEach(([colType, colTypeDef]) => {
    colTypeDef = _extends$5({}, allColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);
    mergedColumnTypes[colType] = colTypeDef;
  });
  return mergedColumnTypes;
};
function computeFlexColumnsWidth({
  initialFreeSpace,
  totalFlexUnits,
  flexColumns
}) {
  const flexColumnsLookup = {
    all: {},
    frozenFields: [],
    freeze: (field) => {
      const value = flexColumnsLookup.all[field];
      if (value && value.frozen !== true) {
        flexColumnsLookup.all[field].frozen = true;
        flexColumnsLookup.frozenFields.push(field);
      }
    }
  };
  function loopOverFlexItems() {
    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {
      return;
    }
    const violationsLookup = {
      min: {},
      max: {}
    };
    let remainingFreeSpace = initialFreeSpace;
    let flexUnits = totalFlexUnits;
    let totalViolation = 0;
    flexColumnsLookup.frozenFields.forEach((field) => {
      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;
      flexUnits -= flexColumnsLookup.all[field].flex;
    });
    for (let i2 = 0; i2 < flexColumns.length; i2 += 1) {
      const column = flexColumns[i2];
      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {
        continue;
      }
      const widthPerFlexUnit = remainingFreeSpace / flexUnits;
      let computedWidth = widthPerFlexUnit * column.flex;
      if (computedWidth < column.minWidth) {
        totalViolation += column.minWidth - computedWidth;
        computedWidth = column.minWidth;
        violationsLookup.min[column.field] = true;
      } else if (computedWidth > column.maxWidth) {
        totalViolation += column.maxWidth - computedWidth;
        computedWidth = column.maxWidth;
        violationsLookup.max[column.field] = true;
      }
      flexColumnsLookup.all[column.field] = {
        frozen: false,
        computedWidth,
        flex: column.flex
      };
    }
    if (totalViolation < 0) {
      Object.keys(violationsLookup.max).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else if (totalViolation > 0) {
      Object.keys(violationsLookup.min).forEach((field) => {
        flexColumnsLookup.freeze(field);
      });
    } else {
      flexColumns.forEach(({
        field
      }) => {
        flexColumnsLookup.freeze(field);
      });
    }
    loopOverFlexItems();
  }
  loopOverFlexItems();
  return flexColumnsLookup.all;
}
const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {
  const columnsLookup = {};
  let totalFlexUnits = 0;
  let widthAllocatedBeforeFlex = 0;
  const flexColumns = [];
  rawState.all.forEach((columnField) => {
    const newColumn = _extends$5({}, rawState.lookup[columnField]);
    if (rawState.columnVisibilityModel[columnField] === false) {
      newColumn.computedWidth = 0;
    } else {
      let computedWidth;
      if (newColumn.flex && newColumn.flex > 0) {
        totalFlexUnits += newColumn.flex;
        computedWidth = 0;
        flexColumns.push(newColumn);
      } else {
        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);
      }
      widthAllocatedBeforeFlex += computedWidth;
      newColumn.computedWidth = computedWidth;
    }
    columnsLookup[columnField] = newColumn;
  });
  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0);
  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {
    const computedColumnWidths = computeFlexColumnsWidth({
      initialFreeSpace,
      totalFlexUnits,
      flexColumns
    });
    Object.keys(computedColumnWidths).forEach((field) => {
      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;
    });
  }
  return _extends$5({}, rawState, {
    lookup: columnsLookup
  });
};
const getGridColDef = (columnTypes, type) => {
  if (!type) {
    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
  }
  if (!columnTypes[type]) {
    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
  }
  return columnTypes[type];
};
const createColumnsState = ({
  apiRef,
  columnsToUpsert,
  columnsTypes,
  currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),
  shouldRegenColumnVisibilityModelFromColumns,
  reset
}) => {
  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;
  let columnsStateWithoutColumnVisibilityModel;
  if (reset) {
    columnsStateWithoutColumnVisibilityModel = {
      all: [],
      lookup: {}
    };
  } else {
    const currentState = gridColumnsSelector(apiRef.current.state);
    columnsStateWithoutColumnVisibilityModel = {
      all: [...currentState.all],
      lookup: _extends$5({}, currentState.lookup)
    };
  }
  const columnsToUpsertLookup = {};
  columnsToUpsert.forEach((newColumn) => {
    columnsToUpsertLookup[newColumn.field] = true;
    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {
      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends$5({}, getGridColDef(columnsTypes, newColumn.type), newColumn);
      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);
    } else {
      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends$5({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);
    }
  });
  const columnsLookupBeforePreProcessing = _extends$5({}, columnsStateWithoutColumnVisibilityModel.lookup);
  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors("hydrateColumns", columnsStateWithoutColumnVisibilityModel);
  let columnVisibilityModel = {};
  if (shouldRegenColumnVisibilityModelFromColumns) {
    if (reset) {
      columnsStateWithPreProcessing.all.forEach((field) => {
        columnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;
      });
    } else {
      const newColumnVisibilityModel = _extends$5({}, currentColumnVisibilityModel);
      let hasModelChanged = false;
      columnsStateWithPreProcessing.all.forEach((field) => {
        var _currentColumnVisibil;
        if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {
          return;
        }
        const isVisibleBefore = (_currentColumnVisibil = currentColumnVisibilityModel[field]) != null ? _currentColumnVisibil : true;
        const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;
        if (isVisibleAfter !== isVisibleBefore) {
          hasModelChanged = true;
          newColumnVisibilityModel[field] = isVisibleAfter;
        }
      });
      if (hasModelChanged) {
        columnVisibilityModel = newColumnVisibilityModel;
      } else {
        columnVisibilityModel = currentColumnVisibilityModel;
      }
    }
  } else {
    columnVisibilityModel = currentColumnVisibilityModel;
  }
  const columnsState = _extends$5({}, columnsStateWithPreProcessing, {
    columnVisibilityModel
  });
  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);
};
const setColumnsState = (columnsState) => (state) => _extends$5({}, state, {
  columns: columnsState
});
const HideGridColMenuItem = (props) => {
  const {
    column,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const timeoutRef = React$6.useRef();
  const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
  const columnsWithMenu = visibleColumns.filter((col) => col.disableColumnMenu !== true);
  const disabled = columnsWithMenu.length === 1;
  const toggleColumn = React$6.useCallback((event) => {
    if (disabled) {
      return;
    }
    onClick(event);
    timeoutRef.current = setTimeout(() => {
      apiRef.current.setColumnVisibility(column == null ? void 0 : column.field, false);
    }, 100);
  }, [apiRef, column == null ? void 0 : column.field, onClick, disabled]);
  React$6.useEffect(() => {
    return () => clearTimeout(timeoutRef.current);
  }, []);
  if (rootProps.disableColumnSelector) {
    return null;
  }
  if (column.hideable === false) {
    return null;
  }
  return /* @__PURE__ */ jsx(MenuItem, {
    onClick: toggleColumn,
    disabled,
    children: apiRef.current.getLocaleText("columnMenuHideColumn")
  });
};
const SortGridMenuItems = (props) => {
  const {
    column,
    onClick
  } = props;
  const apiRef = useGridApiContext();
  const sortModel = useGridSelector(apiRef, gridSortModelSelector);
  const sortDirection = React$6.useMemo(() => {
    if (!column) {
      return null;
    }
    const sortItem = sortModel.find((item) => item.field === column.field);
    return sortItem == null ? void 0 : sortItem.sort;
  }, [column, sortModel]);
  const onSortMenuItemClick = React$6.useCallback((event) => {
    onClick(event);
    const direction = event.currentTarget.getAttribute("data-value") || null;
    apiRef.current.sortColumn(column, direction);
  }, [apiRef, column, onClick]);
  if (!column || !column.sortable) {
    return null;
  }
  return /* @__PURE__ */ jsxs(React$6.Fragment, {
    children: [/* @__PURE__ */ jsx(MenuItem, {
      onClick: onSortMenuItemClick,
      disabled: sortDirection == null,
      children: apiRef.current.getLocaleText("columnMenuUnsort")
    }), /* @__PURE__ */ jsx(MenuItem, {
      onClick: onSortMenuItemClick,
      "data-value": "asc",
      disabled: sortDirection === "asc",
      children: apiRef.current.getLocaleText("columnMenuSortAsc")
    }), /* @__PURE__ */ jsx(MenuItem, {
      onClick: onSortMenuItemClick,
      "data-value": "desc",
      disabled: sortDirection === "desc",
      children: apiRef.current.getLocaleText("columnMenuSortDesc")
    })]
  });
};
const GridColumnMenu = /* @__PURE__ */ React$6.forwardRef(function GridColumnMenu2(props, ref) {
  const {
    hideMenu,
    currentColumn
  } = props;
  const apiRef = useGridApiContext();
  const defaultButtons = [
    /* @__PURE__ */ jsx(SortGridMenuItems, {
      onClick: hideMenu,
      column: currentColumn
    }),
    /* @__PURE__ */ jsx(GridFilterMenuItem, {
      onClick: hideMenu,
      column: currentColumn
    }),
    /* @__PURE__ */ jsx(HideGridColMenuItem, {
      onClick: hideMenu,
      column: currentColumn
    }),
    /* @__PURE__ */ jsx(GridColumnsMenuItem, {
      onClick: hideMenu,
      column: currentColumn
    })
  ];
  const preProcessedButtons = apiRef.current.unstable_applyPreProcessors("columnMenu", defaultButtons, currentColumn);
  return /* @__PURE__ */ jsx(GridColumnMenuContainer, _extends$5({
    ref
  }, props, {
    children: preProcessedButtons.map((button, index) => /* @__PURE__ */ React$6.cloneElement(button, {
      key: index,
      onClick: hideMenu,
      column: currentColumn
    }))
  }));
});
const _excluded$E = ["className"];
const useUtilityClasses$m = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelContent"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridPanelContentRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "PanelContent",
  overridesResolver: (props, styles) => styles.panelContent
})({
  display: "flex",
  flexDirection: "column",
  overflow: "auto",
  flex: "1 1",
  maxHeight: 400
});
function GridPanelContent(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$E);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$m(ownerState);
  return /* @__PURE__ */ jsx(GridPanelContentRoot, _extends$5({
    className: clsx(className, classes2.root)
  }, other));
}
const _excluded$D = ["className"];
const useUtilityClasses$l = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelFooter"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridPanelFooterRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "PanelFooter",
  overridesResolver: (props, styles) => styles.panelFooter
})(({
  theme
}) => ({
  padding: theme.spacing(0.5),
  display: "flex",
  justifyContent: "space-between"
}));
function GridPanelFooter(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$D);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$l(ownerState);
  return /* @__PURE__ */ jsx(GridPanelFooterRoot, _extends$5({
    className: clsx(className, classes2.root)
  }, other));
}
const _excluded$C = ["className"];
const useUtilityClasses$k = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelHeader"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridPanelHeaderRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "PanelHeader",
  overridesResolver: (props, styles) => styles.panelHeader
})(({
  theme
}) => ({
  padding: theme.spacing(1)
}));
function GridPanelHeader(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$C);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$k(ownerState);
  return /* @__PURE__ */ jsx(GridPanelHeaderRoot, _extends$5({
    className: clsx(className, classes2.root)
  }, other));
}
const _excluded$B = ["className"];
const useUtilityClasses$j = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["panelWrapper"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridPanelWrapperRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "PanelWrapper",
  overridesResolver: (props, styles) => styles.panelWrapper
})({
  display: "flex",
  flexDirection: "column",
  flex: 1,
  "&:focus": {
    outline: 0
  }
});
const isEnabled = () => true;
function GridPanelWrapper(props) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$B);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsx(TrapFocus, {
    open: true,
    disableEnforceFocus: true,
    isEnabled,
    children: /* @__PURE__ */ jsx(GridPanelWrapperRoot, _extends$5({
      tabIndex: -1,
      className: clsx(className, classes2.root)
    }, other))
  });
}
let experimentalEnabled = false;
if (typeof process !== "undefined" && {}.GRID_EXPERIMENTAL_ENABLED !== void 0 && localStorageAvailable() && window.localStorage.getItem("GRID_EXPERIMENTAL_ENABLED")) {
  experimentalEnabled = window.localStorage.getItem("GRID_EXPERIMENTAL_ENABLED") === "true";
} else if (typeof process !== "undefined") {
  experimentalEnabled = {}.GRID_EXPERIMENTAL_ENABLED === "true";
}
const GRID_EXPERIMENTAL_ENABLED = experimentalEnabled;
const useUtilityClasses$i = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnsPanel"],
    columnsPanelRow: ["columnsPanelRow"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridColumnsPanelRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnsPanel",
  overridesResolver: (props, styles) => styles.columnsPanel
})(() => ({
  padding: "8px 0px 8px 8px"
}));
const GridColumnsPanelRowRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnsPanelRow",
  overridesResolver: (props, styles) => styles.columnsPanelRow
})(({
  theme
}) => ({
  display: "flex",
  justifyContent: "space-between",
  padding: "1px 8px 1px 7px",
  [`& .${switchClasses.root}`]: {
    marginRight: theme.spacing(0.5)
  }
}));
const GridIconButtonRoot = styled(IconButton)({
  justifyContent: "flex-end"
});
function GridColumnsPanel() {
  var _rootProps$components, _rootProps$components3, _rootProps$components4;
  const apiRef = useGridApiContext();
  const searchInputRef = React$6.useRef(null);
  const columns = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const columnVisibilityModel = useGridSelector(apiRef, gridColumnVisibilityModelSelector);
  const rootProps = useGridRootProps();
  const [searchValue, setSearchValue] = React$6.useState("");
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$i(ownerState);
  const toggleColumn = (event) => {
    const {
      name: field
    } = event.target;
    apiRef.current.setColumnVisibility(field, columnVisibilityModel[field] === false);
  };
  const toggleAllColumns = React$6.useCallback((isVisible) => {
    apiRef.current.updateColumns(columns.map((col) => {
      if (col.hideable !== false) {
        return {
          field: col.field,
          hide: !isVisible
        };
      }
      return col;
    }));
  }, [apiRef, columns]);
  const handleSearchValueChange = React$6.useCallback((event) => {
    setSearchValue(event.target.value);
  }, []);
  const currentColumns = React$6.useMemo(() => {
    if (!searchValue) {
      return columns;
    }
    const searchValueToCheck = searchValue.toLowerCase();
    return columns.filter((column) => (column.headerName || column.field).toLowerCase().indexOf(searchValueToCheck) > -1);
  }, [columns, searchValue]);
  React$6.useEffect(() => {
    searchInputRef.current.focus();
  }, []);
  return /* @__PURE__ */ jsxs(GridPanelWrapper, {
    children: [/* @__PURE__ */ jsx(GridPanelHeader, {
      children: /* @__PURE__ */ jsx(rootProps.components.BaseTextField, _extends$5({
        label: apiRef.current.getLocaleText("columnsPanelTextFieldLabel"),
        placeholder: apiRef.current.getLocaleText("columnsPanelTextFieldPlaceholder"),
        inputRef: searchInputRef,
        value: searchValue,
        onChange: handleSearchValueChange,
        variant: "standard",
        fullWidth: true
      }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseTextField))
    }), /* @__PURE__ */ jsx(GridPanelContent, {
      children: /* @__PURE__ */ jsx(GridColumnsPanelRoot, {
        className: classes2.root,
        children: currentColumns.map((column) => {
          var _rootProps$components2;
          return /* @__PURE__ */ jsxs(GridColumnsPanelRowRoot, {
            className: classes2.columnsPanelRow,
            children: [/* @__PURE__ */ jsx(FormControlLabel, {
              control: /* @__PURE__ */ jsx(rootProps.components.BaseSwitch, _extends$5({
                disabled: column.hideable === false,
                checked: columnVisibilityModel[column.field] !== false,
                onClick: toggleColumn,
                name: column.field,
                color: "primary",
                size: "small"
              }, (_rootProps$components2 = rootProps.componentsProps) == null ? void 0 : _rootProps$components2.baseSwitch)),
              label: column.headerName || column.field
            }), !rootProps.disableColumnReorder && GRID_EXPERIMENTAL_ENABLED && /* @__PURE__ */ jsx(GridIconButtonRoot, {
              draggable: true,
              "aria-label": apiRef.current.getLocaleText("columnsPanelDragIconLabel"),
              title: apiRef.current.getLocaleText("columnsPanelDragIconLabel"),
              size: "small",
              disabled: true,
              children: /* @__PURE__ */ jsx(GridDragIcon, {})
            })]
          }, column.field);
        })
      })
    }), /* @__PURE__ */ jsxs(GridPanelFooter, {
      children: [/* @__PURE__ */ jsx(rootProps.components.BaseButton, _extends$5({
        onClick: () => toggleAllColumns(false),
        color: "primary"
      }, (_rootProps$components3 = rootProps.componentsProps) == null ? void 0 : _rootProps$components3.baseButton, {
        children: apiRef.current.getLocaleText("columnsPanelHideAllButton")
      })), /* @__PURE__ */ jsx(rootProps.components.BaseButton, _extends$5({
        onClick: () => toggleAllColumns(true),
        color: "primary"
      }, (_rootProps$components4 = rootProps.componentsProps) == null ? void 0 : _rootProps$components4.baseButton, {
        children: apiRef.current.getLocaleText("columnsPanelShowAllButton")
      }))]
    })]
  });
}
const _excluded$A = ["children", "className", "classes"];
const gridPanelClasses = generateUtilityClasses$1("MuiDataGrid", ["panel", "paper"]);
const GridPanelRoot = styled(Popper, {
  name: "MuiDataGrid",
  slot: "Panel",
  overridesResolver: (props, styles) => styles.panel
})(({
  theme
}) => ({
  zIndex: theme.zIndex.modal
}));
const GridPaperRoot = styled(Paper, {
  name: "MuiDataGrid",
  slot: "Paper",
  overridesResolver: (props, styles) => styles.paper
})(({
  theme
}) => ({
  backgroundColor: theme.palette.background.paper,
  minWidth: 300,
  maxHeight: 450,
  display: "flex"
}));
const GridPanel = /* @__PURE__ */ React$6.forwardRef((props, ref) => {
  var _apiRef$current$colum;
  const {
    children,
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$A);
  const apiRef = useGridApiContext();
  const classes2 = gridPanelClasses;
  const [isPlaced, setIsPlaced] = React$6.useState(false);
  const handleClickAway = React$6.useCallback(() => {
    apiRef.current.hidePreferences();
  }, [apiRef]);
  const handleKeyDown = React$6.useCallback((event) => {
    if (isEscapeKey(event.key)) {
      apiRef.current.hidePreferences();
    }
  }, [apiRef]);
  const modifiers = React$6.useMemo(() => [{
    name: "flip",
    enabled: false
  }, {
    name: "isPlaced",
    enabled: true,
    phase: "main",
    fn: () => {
      setIsPlaced(true);
    },
    effect: () => () => {
      setIsPlaced(false);
    }
  }], []);
  const anchorEl = (_apiRef$current$colum = apiRef.current.columnHeadersContainerElementRef) == null ? void 0 : _apiRef$current$colum.current;
  if (!anchorEl) {
    return null;
  }
  return /* @__PURE__ */ jsx(GridPanelRoot, _extends$5({
    ref,
    placement: "bottom-start",
    className: clsx(className, classes2.panel),
    anchorEl,
    modifiers
  }, other, {
    children: /* @__PURE__ */ jsx(ClickAwayListener, {
      onClickAway: handleClickAway,
      children: /* @__PURE__ */ jsx(GridPaperRoot, {
        className: classes2.paper,
        elevation: 8,
        onKeyDown: handleKeyDown,
        children: isPlaced && children
      })
    })
  }));
});
const GridPreferencesPanel = /* @__PURE__ */ React$6.forwardRef(function GridPreferencesPanel2(props, ref) {
  var _rootProps$components, _rootProps$components2, _rootProps$components3, _rootProps$components4;
  const apiRef = useGridApiContext();
  const columns = useGridSelector(apiRef, gridColumnDefinitionsSelector);
  const rootProps = useGridRootProps();
  const preferencePanelState = useGridSelector(apiRef, gridPreferencePanelStateSelector);
  const isColumnsTabOpen = preferencePanelState.openedPanelValue === GridPreferencePanelsValue.columns;
  const isFiltersTabOpen = !preferencePanelState.openedPanelValue || !isColumnsTabOpen;
  return /* @__PURE__ */ jsxs(rootProps.components.Panel, _extends$5({
    ref,
    as: rootProps.components.BasePopper,
    open: columns.length > 0 && preferencePanelState.open
  }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.panel, props, (_rootProps$components2 = rootProps.componentsProps) == null ? void 0 : _rootProps$components2.basePopper, {
    children: [!rootProps.disableColumnSelector && isColumnsTabOpen && /* @__PURE__ */ jsx(rootProps.components.ColumnsPanel, _extends$5({}, (_rootProps$components3 = rootProps.componentsProps) == null ? void 0 : _rootProps$components3.columnsPanel)), !rootProps.disableColumnFilter && isFiltersTabOpen && /* @__PURE__ */ jsx(rootProps.components.FilterPanel, _extends$5({}, (_rootProps$components4 = rootProps.componentsProps) == null ? void 0 : _rootProps$components4.filterPanel))]
  }));
});
const useUtilityClasses$h = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["filterForm"],
    deleteIcon: ["filterFormDeleteIcon"],
    linkOperatorInput: ["filterFormLinkOperatorInput"],
    columnInput: ["filterFormColumnInput"],
    operatorInput: ["filterFormOperatorInput"],
    valueInput: ["filterFormValueInput"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridFilterFormRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "FilterForm",
  overridesResolver: (props, styles) => styles.filterForm
})(({
  theme
}) => ({
  display: "flex",
  padding: theme.spacing(1)
}));
const FilterFormDeleteIcon = styled(FormControl, {
  name: "MuiDataGrid",
  slot: "FilterFormDeleteIcon",
  overridesResolver: (_2, styles) => styles.filterFormDeleteIcon
})(({
  theme
}) => ({
  flexShrink: 0,
  justifyContent: "flex-end",
  marginRight: theme.spacing(0.5),
  marginBottom: theme.spacing(0.2)
}));
const FilterFormLinkOperatorInput = styled(FormControl, {
  name: "MuiDataGrid",
  slot: "FilterFormLinkOperatorInput",
  overridesResolver: (_2, styles) => styles.filterFormLinkOperatorInput
})({
  minWidth: 55,
  marginRight: 5,
  justifyContent: "end"
});
const FilterFormColumnInput = styled(FormControl, {
  name: "MuiDataGrid",
  slot: "FilterFormColumnInput",
  overridesResolver: (_2, styles) => styles.filterFormColumnInput
})({
  width: 150
});
const FilterFormOperatorInput = styled(FormControl, {
  name: "MuiDataGrid",
  slot: "FilterFormOperatorInput",
  overridesResolver: (_2, styles) => styles.filterFormOperatorInput
})({
  width: 120
});
const FilterFormValueInput = styled(FormControl, {
  name: "MuiDataGrid",
  slot: "FilterFormValueInput",
  overridesResolver: (_2, styles) => styles.filterFormValueInput
})({
  width: 190
});
const getLinkOperatorLocaleKey = (linkOperator) => {
  switch (linkOperator) {
    case GridLinkOperator.And:
      return "filterPanelOperatorAnd";
    case GridLinkOperator.Or:
      return "filterPanelOperatorOr";
    default:
      throw new Error("MUI: Invalid `linkOperator` property in the `GridFilterPanel`.");
  }
};
const getColumnLabel = (col) => col.headerName || col.field;
const collator = new Intl.Collator();
function GridFilterForm(props) {
  var _rootProps$components, _rootProps$components2, _rootProps$components3, _rootProps$components4, _currentColumn$filter2;
  const {
    item,
    hasMultipleFilters,
    deleteFilter,
    applyFilterChanges,
    multiFilterOperator,
    showMultiFilterOperators,
    disableMultiFilterOperator,
    applyMultiFilterOperatorChanges,
    focusElementRef,
    linkOperators = [GridLinkOperator.And, GridLinkOperator.Or],
    columnsSort,
    deleteIconProps = {},
    linkOperatorInputProps = {},
    operatorInputProps = {},
    columnInputProps = {},
    valueInputProps = {}
  } = props;
  const apiRef = useGridApiContext();
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const columnSelectId = unstable_useId();
  const columnSelectLabelId = unstable_useId();
  const operatorSelectId = unstable_useId();
  const operatorSelectLabelId = unstable_useId();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$h(ownerState);
  const valueRef = React$6.useRef(null);
  const filterSelectorRef = React$6.useRef(null);
  const hasLinkOperatorColumn = hasMultipleFilters && linkOperators.length > 0;
  const baseFormControlProps = ((_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseFormControl) || {};
  const sortedFilterableColumns = React$6.useMemo(() => {
    switch (columnsSort) {
      case "asc":
        return filterableColumns.sort((a2, b2) => collator.compare(getColumnLabel(a2), getColumnLabel(b2)));
      case "desc":
        return filterableColumns.sort((a2, b2) => -collator.compare(getColumnLabel(a2), getColumnLabel(b2)));
      default:
        return filterableColumns;
    }
  }, [filterableColumns, columnsSort]);
  const currentColumn = item.columnField ? apiRef.current.getColumn(item.columnField) : null;
  const currentOperator = React$6.useMemo(() => {
    var _currentColumn$filter;
    if (!item.operatorValue || !currentColumn) {
      return null;
    }
    return (_currentColumn$filter = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter.find((operator) => operator.value === item.operatorValue);
  }, [item, currentColumn]);
  const changeColumn = React$6.useCallback((event) => {
    const columnField = event.target.value;
    const column = apiRef.current.getColumn(columnField);
    if (column.field === currentColumn.field) {
      return;
    }
    const newOperator = column.filterOperators.find((operator) => operator.value === item.operatorValue) || column.filterOperators[0];
    const eraseItemValue = !newOperator.InputComponent || newOperator.InputComponent !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
    applyFilterChanges(_extends$5({}, item, {
      columnField,
      operatorValue: newOperator.value,
      value: eraseItemValue ? void 0 : item.value
    }));
  }, [apiRef, applyFilterChanges, item, currentColumn, currentOperator]);
  const changeOperator = React$6.useCallback((event) => {
    const operatorValue = event.target.value;
    const newOperator = currentColumn == null ? void 0 : currentColumn.filterOperators.find((operator) => operator.value === operatorValue);
    const eraseItemValue = !(newOperator != null && newOperator.InputComponent) || (newOperator == null ? void 0 : newOperator.InputComponent) !== (currentOperator == null ? void 0 : currentOperator.InputComponent);
    applyFilterChanges(_extends$5({}, item, {
      operatorValue,
      value: eraseItemValue ? void 0 : item.value
    }));
  }, [applyFilterChanges, item, currentColumn, currentOperator]);
  const changeLinkOperator = React$6.useCallback((event) => {
    const linkOperator = event.target.value === GridLinkOperator.And.toString() ? GridLinkOperator.And : GridLinkOperator.Or;
    applyMultiFilterOperatorChanges(linkOperator);
  }, [applyMultiFilterOperatorChanges]);
  const handleDeleteFilter = () => {
    if (rootProps.disableMultipleColumnsFiltering) {
      if (item.value === void 0) {
        deleteFilter(item);
      } else {
        applyFilterChanges(_extends$5({}, item, {
          value: void 0
        }));
      }
    } else {
      deleteFilter(item);
    }
  };
  React$6.useImperativeHandle(focusElementRef, () => ({
    focus: () => {
      if (currentOperator != null && currentOperator.InputComponent) {
        var _valueRef$current;
        valueRef == null ? void 0 : (_valueRef$current = valueRef.current) == null ? void 0 : _valueRef$current.focus();
      } else {
        filterSelectorRef.current.focus();
      }
    }
  }), [currentOperator]);
  return /* @__PURE__ */ jsxs(GridFilterFormRoot, {
    className: classes2.root,
    children: [/* @__PURE__ */ jsx(FilterFormDeleteIcon, _extends$5({
      variant: "standard",
      as: rootProps.components.BaseFormControl
    }, baseFormControlProps, deleteIconProps, {
      className: clsx(classes2.deleteIcon, baseFormControlProps.className, deleteIconProps.className),
      children: /* @__PURE__ */ jsx(IconButton, {
        "aria-label": apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        title: apiRef.current.getLocaleText("filterPanelDeleteIconLabel"),
        onClick: handleDeleteFilter,
        size: "small",
        children: /* @__PURE__ */ jsx(rootProps.components.FilterPanelDeleteIcon, {
          fontSize: "small"
        })
      })
    })), /* @__PURE__ */ jsx(FilterFormLinkOperatorInput, _extends$5({
      variant: "standard",
      as: rootProps.components.BaseFormControl
    }, baseFormControlProps, linkOperatorInputProps, {
      sx: _extends$5({
        display: hasLinkOperatorColumn ? "flex" : "none",
        visibility: showMultiFilterOperators ? "visible" : "hidden"
      }, baseFormControlProps.sx || {}, linkOperatorInputProps.sx || {}),
      className: clsx(classes2.linkOperatorInput, baseFormControlProps.className, linkOperatorInputProps.className),
      children: /* @__PURE__ */ jsx(rootProps.components.BaseSelect, _extends$5({
        inputProps: {
          "aria-label": apiRef.current.getLocaleText("filterPanelLinkOperator")
        },
        value: multiFilterOperator,
        onChange: changeLinkOperator,
        disabled: !!disableMultiFilterOperator || linkOperators.length === 1,
        native: true
      }, (_rootProps$components2 = rootProps.componentsProps) == null ? void 0 : _rootProps$components2.baseSelect, {
        children: linkOperators.map((linkOperator) => /* @__PURE__ */ jsx("option", {
          value: linkOperator.toString(),
          children: apiRef.current.getLocaleText(getLinkOperatorLocaleKey(linkOperator))
        }, linkOperator.toString()))
      }))
    })), /* @__PURE__ */ jsxs(FilterFormColumnInput, _extends$5({
      variant: "standard",
      as: rootProps.components.BaseFormControl
    }, baseFormControlProps, columnInputProps, {
      className: clsx(classes2.columnInput, baseFormControlProps.className, columnInputProps.className),
      children: [/* @__PURE__ */ jsx(InputLabel, {
        htmlFor: columnSelectId,
        id: columnSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelColumns")
      }), /* @__PURE__ */ jsx(rootProps.components.BaseSelect, _extends$5({
        labelId: columnSelectLabelId,
        id: columnSelectId,
        label: apiRef.current.getLocaleText("filterPanelColumns"),
        value: item.columnField || "",
        onChange: changeColumn,
        native: true
      }, (_rootProps$components3 = rootProps.componentsProps) == null ? void 0 : _rootProps$components3.baseSelect, {
        children: sortedFilterableColumns.map((col) => /* @__PURE__ */ jsx("option", {
          value: col.field,
          children: getColumnLabel(col)
        }, col.field))
      }))]
    })), /* @__PURE__ */ jsxs(FilterFormOperatorInput, _extends$5({
      variant: "standard",
      as: rootProps.components.BaseFormControl
    }, baseFormControlProps, operatorInputProps, {
      className: clsx(classes2.operatorInput, baseFormControlProps.className, operatorInputProps.className),
      children: [/* @__PURE__ */ jsx(InputLabel, {
        htmlFor: operatorSelectId,
        id: operatorSelectLabelId,
        children: apiRef.current.getLocaleText("filterPanelOperators")
      }), /* @__PURE__ */ jsx(rootProps.components.BaseSelect, _extends$5({
        labelId: operatorSelectLabelId,
        label: apiRef.current.getLocaleText("filterPanelOperators"),
        id: operatorSelectId,
        value: item.operatorValue,
        onChange: changeOperator,
        native: true,
        inputRef: filterSelectorRef
      }, (_rootProps$components4 = rootProps.componentsProps) == null ? void 0 : _rootProps$components4.baseSelect, {
        children: currentColumn == null ? void 0 : (_currentColumn$filter2 = currentColumn.filterOperators) == null ? void 0 : _currentColumn$filter2.map((operator) => /* @__PURE__ */ jsx("option", {
          value: operator.value,
          children: operator.label || apiRef.current.getLocaleText(`filterOperator${capitalize(operator.value)}`)
        }, operator.value))
      }))]
    })), /* @__PURE__ */ jsx(FilterFormValueInput, _extends$5({
      variant: "standard",
      as: rootProps.components.BaseFormControl
    }, baseFormControlProps, valueInputProps, {
      className: clsx(classes2.valueInput, baseFormControlProps.className, valueInputProps.className),
      children: currentOperator != null && currentOperator.InputComponent ? /* @__PURE__ */ jsx(currentOperator.InputComponent, _extends$5({
        apiRef,
        item,
        applyValue: applyFilterChanges,
        focusElementRef: valueRef
      }, currentOperator.InputComponentProps)) : null
    }))]
  });
}
const _excluded$z = ["linkOperators", "columnsSort", "filterFormProps"];
function GridFilterPanel(props) {
  var _rootProps$components;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const filterModel = useGridSelector(apiRef, gridFilterModelSelector);
  const filterableColumns = useGridSelector(apiRef, gridFilterableColumnDefinitionsSelector);
  const lastFilterRef = React$6.useRef(null);
  const {
    linkOperators = [GridLinkOperator.And, GridLinkOperator.Or],
    columnsSort,
    filterFormProps
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$z);
  const applyFilter = React$6.useCallback((item) => {
    apiRef.current.upsertFilterItem(item);
  }, [apiRef]);
  const applyFilterLinkOperator = React$6.useCallback((operator) => {
    apiRef.current.setFilterLinkOperator(operator);
  }, [apiRef]);
  const getDefaultItem = React$6.useCallback(() => {
    const firstColumnWithOperator = filterableColumns.find((colDef) => {
      var _colDef$filterOperato;
      return (_colDef$filterOperato = colDef.filterOperators) == null ? void 0 : _colDef$filterOperato.length;
    });
    if (!firstColumnWithOperator) {
      return null;
    }
    return {
      columnField: firstColumnWithOperator.field,
      operatorValue: firstColumnWithOperator.filterOperators[0].value,
      id: Math.round(Math.random() * 1e5)
    };
  }, [filterableColumns]);
  const items = React$6.useMemo(() => {
    if (filterModel.items.length) {
      return filterModel.items;
    }
    const defaultItem = getDefaultItem();
    return defaultItem ? [defaultItem] : [];
  }, [filterModel.items, getDefaultItem]);
  const hasMultipleFilters = items.length > 1;
  const addNewFilter = () => {
    const defaultItem = getDefaultItem();
    if (!defaultItem) {
      return;
    }
    apiRef.current.setFilterModel(_extends$5({}, filterModel, {
      items: [...items, defaultItem]
    }));
  };
  const deleteFilter = React$6.useCallback((item) => {
    const shouldCloseFilterPanel = items.length === 1;
    apiRef.current.deleteFilterItem(item);
    if (shouldCloseFilterPanel) {
      apiRef.current.hideFilterPanel();
    }
  }, [apiRef, items.length]);
  React$6.useEffect(() => {
    if (linkOperators.length > 0 && filterModel.linkOperator && !linkOperators.includes(filterModel.linkOperator)) {
      applyFilterLinkOperator(linkOperators[0]);
    }
  }, [linkOperators, applyFilterLinkOperator, filterModel.linkOperator]);
  React$6.useEffect(() => {
    if (items.length > 0) {
      lastFilterRef.current.focus();
    }
  }, [items.length]);
  return /* @__PURE__ */ jsxs(GridPanelWrapper, _extends$5({}, other, {
    children: [/* @__PURE__ */ jsx(GridPanelContent, {
      children: items.map((item, index) => /* @__PURE__ */ jsx(GridFilterForm, _extends$5({
        item,
        applyFilterChanges: applyFilter,
        deleteFilter,
        hasMultipleFilters,
        showMultiFilterOperators: index > 0,
        multiFilterOperator: filterModel.linkOperator,
        disableMultiFilterOperator: index !== 1,
        applyMultiFilterOperatorChanges: applyFilterLinkOperator,
        focusElementRef: index === items.length - 1 ? lastFilterRef : null,
        linkOperators,
        columnsSort
      }, filterFormProps), item.id == null ? index : item.id))
    }), !rootProps.disableMultipleColumnsFiltering && /* @__PURE__ */ jsx(GridPanelFooter, {
      children: /* @__PURE__ */ jsx(rootProps.components.BaseButton, _extends$5({
        onClick: addNewFilter,
        startIcon: /* @__PURE__ */ jsx(GridAddIcon, {}),
        color: "primary"
      }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.baseButton, {
        children: apiRef.current.getLocaleText("filterPanelAddFilter")
      }))
    })]
  }));
}
const _excluded$y = ["className", "rowCount", "visibleRowCount"];
const useUtilityClasses$g = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["rowCount"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridRowCountRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "RowCount",
  overridesResolver: (props, styles) => styles.rowCount
})(({
  theme
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme.spacing(0, 2)
}));
const GridRowCount = /* @__PURE__ */ React$6.forwardRef(function GridRowCount2(props, ref) {
  const {
    className,
    rowCount,
    visibleRowCount
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$y);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$g(ownerState);
  if (rowCount === 0) {
    return null;
  }
  const text = visibleRowCount < rowCount ? apiRef.current.getLocaleText("footerTotalVisibleRows")(visibleRowCount, rowCount) : rowCount.toLocaleString();
  return /* @__PURE__ */ jsxs(GridRowCountRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other, {
    children: [apiRef.current.getLocaleText("footerTotalRows"), " ", text]
  }));
});
const _excluded$x = ["className", "selectedRowCount"];
const useUtilityClasses$f = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["selectedRowCount"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridSelectedRowCountRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "SelectedRowCount",
  overridesResolver: (props, styles) => styles.selectedRowCount
})(({
  theme
}) => ({
  alignItems: "center",
  display: "flex",
  margin: theme.spacing(0, 2),
  visibility: "hidden",
  width: 0,
  height: 0,
  [theme.breakpoints.up("sm")]: {
    visibility: "visible",
    width: "auto",
    height: "auto"
  }
}));
const GridSelectedRowCount = /* @__PURE__ */ React$6.forwardRef(function GridSelectedRowCount2(props, ref) {
  const {
    className,
    selectedRowCount
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$x);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$f(ownerState);
  const rowSelectedText = apiRef.current.getLocaleText("footerRowSelected")(selectedRowCount);
  return /* @__PURE__ */ jsx(GridSelectedRowCountRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other, {
    children: rowSelectedText
  }));
});
const GridFooter = /* @__PURE__ */ React$6.forwardRef(function GridFooter2(props, ref) {
  var _rootProps$components;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const totalTopLevelRowCount = useGridSelector(apiRef, gridTopLevelRowCountSelector);
  const selectedRowCount = useGridSelector(apiRef, selectedGridRowsCountSelector);
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridVisibleTopLevelRowCountSelector);
  const selectedRowCountElement = !rootProps.hideFooterSelectedRowCount && selectedRowCount > 0 ? /* @__PURE__ */ jsx(GridSelectedRowCount, {
    selectedRowCount
  }) : /* @__PURE__ */ jsx("div", {});
  const rowCountElement = !rootProps.hideFooterRowCount && !rootProps.pagination ? /* @__PURE__ */ jsx(GridRowCount, {
    rowCount: totalTopLevelRowCount,
    visibleRowCount: visibleTopLevelRowCount
  }) : null;
  const paginationElement = rootProps.pagination && !rootProps.hideFooterPagination && rootProps.components.Pagination && /* @__PURE__ */ jsx(rootProps.components.Pagination, _extends$5({}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.pagination));
  return /* @__PURE__ */ jsxs(GridFooterContainer, _extends$5({
    ref
  }, props, {
    children: [selectedRowCountElement, rowCountElement, paginationElement]
  }));
});
const GridHeader = /* @__PURE__ */ React$6.forwardRef(function GridHeader2(props, ref) {
  var _rootProps$components, _rootProps$components2;
  const rootProps = useGridRootProps();
  return /* @__PURE__ */ jsxs("div", _extends$5({
    ref
  }, props, {
    children: [/* @__PURE__ */ jsx(rootProps.components.PreferencesPanel, _extends$5({}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.preferencesPanel)), rootProps.components.Toolbar && /* @__PURE__ */ jsx(rootProps.components.Toolbar, _extends$5({}, (_rootProps$components2 = rootProps.componentsProps) == null ? void 0 : _rootProps$components2.toolbar))]
  }));
});
const GridLoadingOverlay = /* @__PURE__ */ React$6.forwardRef(function GridLoadingOverlay2(props, ref) {
  return /* @__PURE__ */ jsx(GridOverlay, _extends$5({
    ref
  }, props, {
    children: /* @__PURE__ */ jsx(CircularProgress, {})
  }));
});
const GridNoRowsOverlay = /* @__PURE__ */ React$6.forwardRef(function GridNoRowsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noRowsLabel = apiRef.current.getLocaleText("noRowsLabel");
  return /* @__PURE__ */ jsx(GridOverlay, _extends$5({
    ref
  }, props, {
    children: noRowsLabel
  }));
});
const GridPaginationRoot = styled(TablePagination$1)(({
  theme
}) => ({
  [`& .${tablePaginationClasses.selectLabel}`]: {
    display: "none",
    [theme.breakpoints.up("sm")]: {
      display: "block"
    }
  },
  [`& .${tablePaginationClasses.input}`]: {
    display: "none",
    [theme.breakpoints.up("sm")]: {
      display: "inline-flex"
    }
  }
}));
const GridPagination = /* @__PURE__ */ React$6.forwardRef(function GridPagination2(props, ref) {
  var _rootProps$rowsPerPag;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const paginationState = useGridSelector(apiRef, gridPaginationSelector);
  const lastPage = React$6.useMemo(() => Math.floor(paginationState.rowCount / (paginationState.pageSize || 1)), [paginationState.rowCount, paginationState.pageSize]);
  const handlePageSizeChange = React$6.useCallback((event) => {
    const newPageSize = Number(event.target.value);
    apiRef.current.setPageSize(newPageSize);
  }, [apiRef]);
  const handlePageChange = React$6.useCallback((event, page) => {
    apiRef.current.setPage(page);
  }, [apiRef]);
  return /* @__PURE__ */ jsx(GridPaginationRoot, _extends$5({
    ref,
    component: "div",
    count: paginationState.rowCount,
    page: paginationState.page <= lastPage ? paginationState.page : lastPage,
    rowsPerPageOptions: (_rootProps$rowsPerPag = rootProps.rowsPerPageOptions) != null && _rootProps$rowsPerPag.includes(paginationState.pageSize) ? rootProps.rowsPerPageOptions : [],
    rowsPerPage: paginationState.pageSize,
    onPageChange: handlePageChange,
    onRowsPerPageChange: handlePageSizeChange
  }, apiRef.current.getLocaleText("MuiTablePagination"), props));
});
const GRID_CHECKBOX_SELECTION_COL_DEF = _extends$5({}, GRID_BOOLEAN_COL_DEF, {
  field: "__check__",
  type: "checkboxSelection",
  width: 50,
  resizable: false,
  sortable: false,
  filterable: false,
  disableColumnMenu: true,
  disableReorder: true,
  disableExport: true,
  valueGetter: (params) => {
    const selectionLookup = selectedIdsLookupSelector(params.api.state, params.api.instanceId);
    return selectionLookup[params.id] !== void 0;
  },
  renderHeader: (params) => /* @__PURE__ */ jsx(GridHeaderCheckbox, _extends$5({}, params)),
  renderCell: (params) => /* @__PURE__ */ jsx(GridCellCheckboxRenderer2, _extends$5({}, params))
});
const _excluded$w = ["selected", "rowId", "row", "index", "style", "rowHeight", "className", "visibleColumns", "renderedColumns", "containerWidth", "firstColumnToRender", "lastColumnToRender", "cellFocus", "cellTabIndex", "editRowsState", "isLastVisible", "onClick", "onDoubleClick", "onMouseEnter", "onMouseLeave"];
const useUtilityClasses$e = (ownerState) => {
  const {
    editable,
    editing,
    selected,
    isLastVisible,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["row", selected && "selected", editable && "row--editable", editing && "row--editing", isLastVisible && "row--lastVisible"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const EmptyCell = ({
  width,
  height
}) => {
  if (!width || !height) {
    return null;
  }
  const style2 = {
    width,
    height
  };
  return /* @__PURE__ */ jsx("div", {
    className: "MuiDataGrid-cell",
    style: style2
  });
};
function GridRow(props) {
  var _apiRef$current$getRo;
  const {
    selected,
    rowId,
    index,
    style: styleProp,
    rowHeight,
    className,
    visibleColumns,
    renderedColumns,
    containerWidth,
    firstColumnToRender,
    cellFocus,
    cellTabIndex,
    editRowsState,
    isLastVisible = false,
    onClick,
    onDoubleClick,
    onMouseEnter,
    onMouseLeave
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$w);
  const ariaRowIndex = index + 2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const {
    hasScrollX,
    hasScrollY
  } = (_apiRef$current$getRo = apiRef.current.getRootDimensions()) != null ? _apiRef$current$getRo : {
    hasScrollX: false,
    hasScrollY: false
  };
  const ownerState = {
    selected,
    isLastVisible,
    classes: rootProps.classes,
    editing: apiRef.current.getRowMode(rowId) === GridRowModes.Edit,
    editable: rootProps.editMode === GridEditModes.Row
  };
  const classes2 = useUtilityClasses$e(ownerState);
  const publish = React$6.useCallback((eventName, propHandler) => (event) => {
    if (event.target.nodeType === 1 && !event.currentTarget.contains(event.target)) {
      return;
    }
    if (!apiRef.current.getRow(rowId)) {
      return;
    }
    apiRef.current.publishEvent(eventName, apiRef.current.getRowParams(rowId), event);
    if (propHandler) {
      propHandler(event);
    }
  }, [apiRef, rowId]);
  const publishClick = React$6.useCallback((event) => {
    const cell = findParentElementFromClassName(event.target, gridClasses.cell);
    const field = cell == null ? void 0 : cell.getAttribute("data-field");
    if (field) {
      if (field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
        return;
      }
      if (field === "__detail_panel_toggle__") {
        return;
      }
      if (apiRef.current.getCellMode(rowId, field) === GridCellModes.Edit) {
        return;
      }
      const column = apiRef.current.getColumn(field);
      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    publish(GridEvents.rowClick, onClick)(event);
  }, [apiRef, onClick, publish, rowId]);
  const style2 = _extends$5({
    maxHeight: rowHeight,
    minHeight: rowHeight
  }, styleProp);
  const rowClassName = typeof rootProps.getRowClassName === "function" && rootProps.getRowClassName(apiRef.current.getRowParams(rowId));
  const cells = [];
  for (let i2 = 0; i2 < renderedColumns.length; i2 += 1) {
    var _rootProps$components;
    const column = renderedColumns[i2];
    const indexRelativeToAllColumns = firstColumnToRender + i2;
    const isLastColumn = indexRelativeToAllColumns === visibleColumns.length - 1;
    const removeLastBorderRight = isLastColumn && hasScrollX && !hasScrollY;
    const showRightBorder = !isLastColumn ? rootProps.showCellRightBorder : !removeLastBorderRight && rootProps.disableExtendRowFullWidth;
    const cellParams = apiRef.current.getCellParams(rowId, column.field);
    const classNames2 = [];
    if (column.cellClassName) {
      classNames2.push(clsx(typeof column.cellClassName === "function" ? column.cellClassName(cellParams) : column.cellClassName));
    }
    const editCellState = editRowsState[rowId] ? editRowsState[rowId][column.field] : null;
    let content = null;
    if (editCellState == null && column.renderCell) {
      var _rootProps$classes;
      content = column.renderCell(_extends$5({}, cellParams, {
        api: apiRef.current
      }));
      classNames2.push(clsx(gridClasses["cell--withRenderer"], (_rootProps$classes = rootProps.classes) == null ? void 0 : _rootProps$classes["cell--withRenderer"]));
    }
    if (editCellState != null && column.renderEditCell) {
      var _rootProps$classes2;
      const params = _extends$5({}, cellParams, editCellState, {
        api: apiRef.current
      });
      content = column.renderEditCell(params);
      classNames2.push(clsx(gridClasses["cell--editing"], (_rootProps$classes2 = rootProps.classes) == null ? void 0 : _rootProps$classes2["cell--editing"]));
    }
    if (rootProps.getCellClassName) {
      classNames2.push(rootProps.getCellClassName(cellParams));
    }
    const hasFocus = cellFocus !== null && cellFocus.id === rowId && cellFocus.field === column.field;
    const tabIndex = cellTabIndex !== null && cellTabIndex.id === rowId && cellTabIndex.field === column.field && cellParams.cellMode === "view" ? 0 : -1;
    cells.push(/* @__PURE__ */ jsx(rootProps.components.Cell, _extends$5({
      value: cellParams.value,
      field: column.field,
      width: column.computedWidth,
      rowId,
      height: rowHeight,
      showRightBorder,
      formattedValue: cellParams.formattedValue,
      align: column.align || "left",
      cellMode: cellParams.cellMode,
      colIndex: indexRelativeToAllColumns,
      isEditable: cellParams.isEditable,
      hasFocus,
      tabIndex,
      className: clsx(classNames2)
    }, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.cell, {
      children: content
    }), column.field));
  }
  const emptyCellWidth = containerWidth - columnsTotalWidth;
  return /* @__PURE__ */ jsxs("div", _extends$5({
    "data-id": rowId,
    "data-rowindex": index,
    role: "row",
    className: clsx(rowClassName, classes2.root, className),
    "aria-rowindex": ariaRowIndex,
    "aria-selected": selected,
    style: style2,
    onClick: publishClick,
    onDoubleClick: publish(GridEvents.rowDoubleClick, onDoubleClick),
    onMouseEnter: publish(GridEvents.rowMouseEnter, onMouseEnter),
    onMouseLeave: publish(GridEvents.rowMouseLeave, onMouseLeave)
  }, other, {
    children: [cells, emptyCellWidth > 0 && /* @__PURE__ */ jsx(EmptyCell, {
      width: emptyCellWidth,
      height: rowHeight
    })]
  }));
}
const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
class TimerBasedCleanupTracking {
  constructor() {
    this.timeouts = /* @__PURE__ */ new Map();
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, CLEANUP_TIMER_LOOP_MILLIS);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
}
class FinalizationRegistryBasedCleanupTracking {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object, unsubscribe, unregisterToken) {
    this.registry.register(object, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  reset() {
  }
}
var GridSignature;
(function(GridSignature2) {
  GridSignature2["DataGrid"] = "DataGrid";
  GridSignature2["DataGridPro"] = "DataGridPro";
})(GridSignature || (GridSignature = {}));
class ObjectToBeRetainedByReact {
}
function createUseGridApiEventHandler(registry2) {
  let cleanupTokensCounter = 0;
  return function useGridApiEventHandler2(apiRef, eventName, handler, options) {
    const [objectRetainedByReact] = React$6.useState(new ObjectToBeRetainedByReact());
    const subscription = React$6.useRef(null);
    const handlerRef = React$6.useRef();
    handlerRef.current = handler;
    const cleanupTokenRef = React$6.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params, event, details) => {
        if (!event.defaultMuiPrevented) {
          var _handlerRef$current;
          (_handlerRef$current = handlerRef.current) == null ? void 0 : _handlerRef$current.call(handlerRef, params, event, details);
        }
      };
      subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registry2.register(objectRetainedByReact, () => {
        var _subscription$current;
        (_subscription$current = subscription.current) == null ? void 0 : _subscription$current.call(subscription);
        subscription.current = null;
        cleanupTokenRef.current = null;
      }, cleanupTokenRef.current);
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registry2.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    React$6.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event, details) => {
          if (!event.defaultMuiPrevented) {
            var _handlerRef$current2;
            (_handlerRef$current2 = handlerRef.current) == null ? void 0 : _handlerRef$current2.call(handlerRef, params, event, details);
          }
        };
        subscription.current = apiRef.current.subscribeEvent(eventName, enhancedHandler, options);
      }
      if (cleanupTokenRef.current && registry2) {
        registry2.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _subscription$current2;
        (_subscription$current2 = subscription.current) == null ? void 0 : _subscription$current2.call(subscription);
        subscription.current = null;
      };
    }, [apiRef, eventName, options]);
  };
}
const registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
const useGridApiEventHandler = createUseGridApiEventHandler(registry);
const optionsSubscriberOptions = {
  isFirst: true
};
function useGridApiOptionHandler(apiRef, eventName, handler) {
  useGridApiEventHandler(apiRef, eventName, handler, optionsSubscriberOptions);
}
const CLIFF = 1;
const SLOP = 1.5;
const useUtilityClasses$d = (ownerState) => {
  const {
    scrollDirection,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["scrollArea", `scrollArea--${scrollDirection}`]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridScrollAreaRawRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "ScrollArea",
  overridesResolver: (props, styles) => [{
    [`&.${gridClasses["scrollArea--left"]}`]: styles["scrollArea--left"]
  }, {
    [`&.${gridClasses["scrollArea--right"]}`]: styles["scrollArea--right"]
  }, styles.scrollArea]
})(() => ({
  position: "absolute",
  top: 0,
  zIndex: 101,
  width: 20,
  bottom: 0,
  [`&.${gridClasses["scrollArea--left"]}`]: {
    left: 0
  },
  [`&.${gridClasses["scrollArea--right"]}`]: {
    right: 0
  }
}));
function GridScrollAreaRaw(props) {
  const {
    scrollDirection
  } = props;
  const rootRef = React$6.useRef(null);
  const apiRef = useGridApiContext();
  const timeout = React$6.useRef();
  const [dragging, setDragging] = React$6.useState(false);
  const height = useGridSelector(apiRef, gridDensityHeaderHeightSelector);
  const scrollPosition = React$6.useRef({
    left: 0,
    top: 0
  });
  const rootProps = useGridRootProps();
  const ownerState = _extends$5({}, props, {
    classes: rootProps.classes
  });
  const classes2 = useUtilityClasses$d(ownerState);
  const handleScrolling = React$6.useCallback((newScrollPosition) => {
    scrollPosition.current = newScrollPosition;
  }, []);
  const handleDragOver = React$6.useCallback((event) => {
    let offset;
    if (scrollDirection === "left") {
      offset = event.clientX - rootRef.current.getBoundingClientRect().right;
    } else if (scrollDirection === "right") {
      offset = Math.max(1, event.clientX - rootRef.current.getBoundingClientRect().left);
    } else {
      throw new Error("MUI: Wrong drag direction");
    }
    offset = (offset - CLIFF) * SLOP + CLIFF;
    clearTimeout(timeout.current);
    timeout.current = setTimeout(() => {
      apiRef.current.scroll({
        left: scrollPosition.current.left + offset,
        top: scrollPosition.current.top
      });
    });
  }, [scrollDirection, apiRef]);
  React$6.useEffect(() => {
    return () => {
      clearTimeout(timeout.current);
    };
  }, []);
  const toggleDragging = React$6.useCallback(() => {
    setDragging((prevDragging) => !prevDragging);
  }, []);
  useGridApiEventHandler(apiRef, GridEvents.rowsScroll, handleScrolling);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, toggleDragging);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragEnd, toggleDragging);
  return dragging ? /* @__PURE__ */ jsx(GridScrollAreaRawRoot, {
    ref: rootRef,
    className: clsx(classes2.root),
    onDragOver: handleDragOver,
    style: {
      height
    }
  }) : null;
}
const GridScrollArea = /* @__PURE__ */ React$6.memo(GridScrollAreaRaw);
const GridContextProvider = ({
  apiRef,
  props,
  children
}) => {
  return /* @__PURE__ */ jsx(GridRootPropsContext.Provider, {
    value: props,
    children: /* @__PURE__ */ jsx(GridApiContext.Provider, {
      value: apiRef,
      children
    })
  });
};
const forceDebug = localStorageAvailable() && window.localStorage.getItem("DEBUG") != null;
const noop$2 = () => {
};
const noopLogger = {
  debug: noop$2,
  info: noop$2,
  warn: noop$2,
  error: noop$2
};
const LOG_LEVELS = ["debug", "info", "warn", "error"];
function getAppender(name, logLevel, appender = console) {
  const minLogLevelIdx = LOG_LEVELS.indexOf(logLevel);
  if (minLogLevelIdx === -1) {
    throw new Error(`MUI: Log level ${logLevel} not recognized.`);
  }
  const logger = LOG_LEVELS.reduce((loggerObj, method, idx) => {
    if (idx >= minLogLevelIdx) {
      loggerObj[method] = (...args) => {
        const [message, ...other] = args;
        appender[method](`MUI: ${name} - ${message}`, ...other);
      };
    } else {
      loggerObj[method] = noop$2;
    }
    return loggerObj;
  }, {});
  return logger;
}
const useGridLoggerFactory = (apiRef, props) => {
  apiRef.current.getLogger = React$6.useCallback((name) => {
    if (forceDebug) {
      return getAppender(name, "debug", props.logger);
    }
    if (!props.logLevel) {
      return noopLogger;
    }
    return getAppender(name, props.logLevel.toString(), props.logger);
  }, [props.logLevel, props.logger]);
};
function useGridApiMethod(apiRef, apiMethods, apiName) {
  const apiMethodsRef = React$6.useRef(apiMethods);
  const [apiMethodsNames] = React$6.useState(Object.keys(apiMethods));
  const installMethods = React$6.useCallback(() => {
    if (!apiRef.current) {
      return;
    }
    apiMethodsNames.forEach((methodName) => {
      if (!apiRef.current.hasOwnProperty(methodName)) {
        apiRef.current[methodName] = (...args) => apiMethodsRef.current[methodName](...args);
      }
    });
  }, [apiMethodsNames, apiRef]);
  React$6.useEffect(() => {
    apiMethodsRef.current = apiMethods;
  }, [apiMethods]);
  React$6.useEffect(() => {
    installMethods();
  }, [installMethods]);
  installMethods();
}
class EventManager {
  constructor() {
    this.maxListeners = 10;
    this.warnOnce = false;
    this.events = {};
  }
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i2 = highPriorityListeners.length - 1; i2 >= 0; i2 -= 1) {
      const listener = highPriorityListeners[i2];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i2 = 0; i2 < regularListeners.length; i2 += 1) {
      const listener = regularListeners[i2];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
}
const isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
let globalId = 0;
function useGridApiInitialization(inputApiRef, props) {
  const apiRef = React$6.useRef();
  if (!apiRef.current) {
    apiRef.current = {
      unstable_eventManager: new EventManager(),
      state: {},
      instanceId: globalId
    };
    globalId += 1;
  }
  React$6.useImperativeHandle(inputApiRef, () => apiRef.current, [apiRef]);
  const publishEvent = React$6.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    const details = props.signature === GridSignature.DataGridPro ? {
      api: apiRef.current
    } : {};
    apiRef.current.unstable_eventManager.emit(name, params, event, details);
  }, [apiRef, props.signature]);
  const subscribeEvent = React$6.useCallback((event, handler, options) => {
    apiRef.current.unstable_eventManager.on(event, handler, options);
    const api = apiRef.current;
    return () => {
      api.unstable_eventManager.removeListener(event, handler);
    };
  }, [apiRef]);
  const showError = React$6.useCallback((args) => {
    apiRef.current.publishEvent(GridEvents.componentError, args);
  }, [apiRef]);
  useGridApiMethod(apiRef, {
    subscribeEvent,
    publishEvent,
    showError
  });
  React$6.useEffect(() => {
    const api = apiRef.current;
    return () => {
      api.publishEvent(GridEvents.unmount);
    };
  }, [apiRef]);
  return apiRef;
}
function useGridErrorHandler(apiRef, props) {
  const handleError = React$6.useCallback((args) => {
    apiRef.current.setState((state) => _extends$5({}, state, {
      error: args
    }));
  }, [apiRef]);
  React$6.useEffect(() => {
    handleError(props.error);
  }, [handleError, props.error]);
  useGridApiEventHandler(apiRef, GridEvents.componentError, handleError);
}
const useGridLocaleText = (apiRef, props) => {
  const getLocaleText = React$6.useCallback((key) => {
    if (props.localeText[key] == null) {
      throw new Error(`Missing translation for key ${key}.`);
    }
    return props.localeText[key];
  }, [props.localeText]);
  const localeTextApi = {
    getLocaleText
  };
  useGridApiMethod(apiRef, localeTextApi);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
const useGridPreProcessing = (apiRef) => {
  const preProcessorsRef = React$6.useRef({});
  const registerPreProcessor = React$6.useCallback((group, id2, callback) => {
    if (!preProcessorsRef.current[group]) {
      preProcessorsRef.current[group] = {};
    }
    const preProcessors = preProcessorsRef.current[group];
    const oldCallback = preProcessors[id2];
    if (!oldCallback || oldCallback !== callback) {
      preProcessorsRef.current[group] = _extends$5({}, preProcessors, {
        [id2]: callback
      });
      apiRef.current.publishEvent(GridEvents.preProcessorRegister, group);
    }
    return () => {
      const _ref = preProcessorsRef.current[group], otherProcessors = _objectWithoutPropertiesLoose$2(_ref, [id2].map(_toPropertyKey));
      preProcessorsRef.current[group] = otherProcessors;
      apiRef.current.publishEvent(GridEvents.preProcessorUnregister, group);
    };
  }, [apiRef]);
  const applyPreProcessors = React$6.useCallback((...args) => {
    const [group, value, params] = args;
    if (!preProcessorsRef.current[group]) {
      return value;
    }
    const preProcessors = Object.values(preProcessorsRef.current[group]);
    return preProcessors.reduce((acc, preProcessor) => {
      return preProcessor(acc, params);
    }, value);
  }, []);
  const preProcessingApi = {
    unstable_registerPreProcessor: registerPreProcessor,
    unstable_applyPreProcessors: applyPreProcessors
  };
  useGridApiMethod(apiRef, preProcessingApi);
};
const useFirstRender = (callback) => {
  const isFirstRender = React$6.useRef(true);
  if (isFirstRender.current) {
    isFirstRender.current = false;
    callback();
  }
};
const useGridRegisterPreProcessor = (apiRef, group, callback) => {
  const cleanup = React$6.useRef();
  const id2 = React$6.useRef(`mui-${Math.round(Math.random() * 1e9)}`);
  const registerPreProcessor = React$6.useCallback(() => {
    cleanup.current = apiRef.current.unstable_registerPreProcessor(group, id2.current, callback);
  }, [apiRef, callback, group]);
  useFirstRender(() => {
    registerPreProcessor();
  });
  const isFirstRender = React$6.useRef(true);
  React$6.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      registerPreProcessor();
    }
    return () => {
      if (cleanup.current) {
        cleanup.current();
        cleanup.current = null;
      }
    };
  }, [registerPreProcessor]);
};
const getFlatRowTree = ({
  ids,
  idRowsLookup,
  previousTree
}) => {
  const tree = {};
  for (let i2 = 0; i2 < ids.length; i2 += 1) {
    const rowId = ids[i2];
    if (previousTree && previousTree[rowId]) {
      tree[rowId] = previousTree[rowId];
    } else {
      tree[rowId] = {
        id: rowId,
        depth: 0,
        parent: null,
        groupingKey: "",
        groupingField: null
      };
    }
  }
  return {
    groupingName: "none",
    tree,
    treeDepth: 1,
    idRowsLookup,
    ids
  };
};
const useGridRowGroupsPreProcessing = (apiRef) => {
  const rowGroupsPreProcessingRef = React$6.useRef(/* @__PURE__ */ new Map());
  const registerRowGroupsBuilder = React$6.useCallback((processingName, rowGroupingPreProcessing) => {
    var _rowGroupsPreProcessi;
    const rowGroupingPreProcessingBefore = (_rowGroupsPreProcessi = rowGroupsPreProcessingRef.current.get(processingName)) != null ? _rowGroupsPreProcessi : null;
    if (rowGroupingPreProcessingBefore !== rowGroupingPreProcessing) {
      rowGroupsPreProcessingRef.current.set(processingName, rowGroupingPreProcessing);
      apiRef.current.publishEvent(GridEvents.rowGroupsPreProcessingChange);
    }
  }, [apiRef]);
  const groupRows = React$6.useCallback((...params) => {
    let response = null;
    const preProcessingList = Array.from(rowGroupsPreProcessingRef.current.values());
    while (!response && preProcessingList.length) {
      const preProcessing = preProcessingList.shift();
      if (preProcessing) {
        response = preProcessing(...params);
      }
    }
    if (!response) {
      return getFlatRowTree(...params);
    }
    return response;
  }, []);
  const rowGroupsPreProcessingApi = {
    unstable_registerRowGroupsBuilder: registerRowGroupsBuilder,
    unstable_groupRows: groupRows
  };
  useGridApiMethod(apiRef, rowGroupsPreProcessingApi);
};
const useGridNativeEventListener = (apiRef, ref, eventName, handler, options) => {
  const logger = useGridLogger(apiRef, "useNativeEventListener");
  const [added, setAdded] = React$6.useState(false);
  const handlerRef = React$6.useRef(handler);
  const wrapHandler = React$6.useCallback((args) => {
    return handlerRef.current && handlerRef.current(args);
  }, []);
  React$6.useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);
  React$6.useEffect(() => {
    let targetElement;
    if (isFunction$2(ref)) {
      targetElement = ref();
    } else {
      targetElement = ref && ref.current ? ref.current : null;
    }
    if (targetElement && wrapHandler && eventName && !added) {
      logger.debug(`Binding native ${eventName} event`);
      targetElement.addEventListener(eventName, wrapHandler, options);
      const boundElem = targetElement;
      setAdded(true);
      const unsubscribe = () => {
        logger.debug(`Clearing native ${eventName} event`);
        boundElem.removeEventListener(eventName, wrapHandler, options);
      };
      apiRef.current.subscribeEvent(GridEvents.unmount, unsubscribe);
    }
  }, [ref, wrapHandler, eventName, added, logger, options, apiRef]);
};
const _excluded$v = ["stateId"];
const useGridStateInitialization = (apiRef, props) => {
  const controlStateMapRef = React$6.useRef({});
  const [, rawForceUpdate] = React$6.useState();
  const updateControlState = React$6.useCallback((controlStateItem) => {
    const {
      stateId
    } = controlStateItem, others = _objectWithoutPropertiesLoose$2(controlStateItem, _excluded$v);
    controlStateMapRef.current[stateId] = _extends$5({}, others, {
      stateId
    });
  }, []);
  const setState = React$6.useCallback((state) => {
    let newState;
    if (isFunction$2(state)) {
      newState = state(apiRef.current.state);
    } else {
      newState = state;
    }
    if (apiRef.current.state === newState) {
      return false;
    }
    let ignoreSetState = false;
    const updatedControlStateIds = [];
    Object.keys(controlStateMapRef.current).forEach((stateId) => {
      const controlState = controlStateMapRef.current[stateId];
      const oldSubState = controlState.stateSelector(apiRef.current.state, apiRef.current.instanceId);
      const newSubState = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (newSubState === oldSubState) {
        return;
      }
      updatedControlStateIds.push({
        stateId: controlState.stateId,
        hasPropChanged: newSubState !== controlState.propModel
      });
      if (controlState.propModel !== void 0 && newSubState !== controlState.propModel) {
        ignoreSetState = true;
      }
    });
    if (updatedControlStateIds.length > 1) {
      throw new Error(`You're not allowed to update several sub-state in one transaction. You already updated ${updatedControlStateIds[0].stateId}, therefore, you're not allowed to update ${updatedControlStateIds.map((el) => el.stateId).join(", ")} in the same transaction.`);
    }
    if (!ignoreSetState) {
      apiRef.current.state = newState;
      if (apiRef.current.publishEvent) {
        apiRef.current.publishEvent(GridEvents.stateChange, newState);
      }
    }
    if (updatedControlStateIds.length === 1) {
      const {
        stateId,
        hasPropChanged
      } = updatedControlStateIds[0];
      const controlState = controlStateMapRef.current[stateId];
      const model = controlState.stateSelector(newState, apiRef.current.instanceId);
      if (controlState.propOnChange && hasPropChanged) {
        const details = props.signature === GridSignature.DataGridPro ? {
          api: apiRef.current
        } : {};
        controlState.propOnChange(model, details);
      }
      if (!ignoreSetState) {
        apiRef.current.publishEvent(controlState.changeEvent, model);
      }
    }
    return !ignoreSetState;
  }, [apiRef, props.signature]);
  const forceUpdate = React$6.useCallback(() => rawForceUpdate(() => apiRef.current.state), [apiRef]);
  const stateApi = {
    setState,
    forceUpdate,
    unstable_updateControlState: updateControlState
  };
  useGridApiMethod(apiRef, stateApi);
};
const useGridInitialization = (inputApiRef, props) => {
  const apiRef = useGridApiInitialization(inputApiRef, props);
  useGridLoggerFactory(apiRef, props);
  useGridErrorHandler(apiRef, props);
  useGridStateInitialization(apiRef, props);
  useGridPreProcessing(apiRef);
  useGridRowGroupsPreProcessing(apiRef);
  useGridLocaleText(apiRef, props);
  return apiRef;
};
const useGridInitializeState = (initializer, apiRef, props) => {
  const isInitialized = React$6.useRef(false);
  if (!isInitialized.current) {
    apiRef.current.state = initializer(apiRef.current.state, props, apiRef);
    isInitialized.current = true;
  }
};
function writeToClipboardPolyfill(data) {
  const span = document.createElement("span");
  span.style.whiteSpace = "pre";
  span.style.userSelect = "all";
  span.style.opacity = "0px";
  span.textContent = data;
  document.body.appendChild(span);
  const range = document.createRange();
  range.selectNode(span);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  try {
    document.execCommand("copy");
  } finally {
    document.body.removeChild(span);
  }
}
const useGridClipboard = (apiRef) => {
  const copySelectedRowsToClipboard = React$6.useCallback((includeHeaders = false) => {
    if (apiRef.current.getSelectedRows().size === 0) {
      return;
    }
    const data = apiRef.current.getDataAsCsv({
      includeHeaders,
      delimiter: "	"
    });
    if (navigator.clipboard) {
      navigator.clipboard.writeText(data).catch(() => {
        writeToClipboardPolyfill(data);
      });
    } else {
      writeToClipboardPolyfill(data);
    }
  }, [apiRef]);
  const handleKeydown = React$6.useCallback((event) => {
    var _window$getSelection;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (String.fromCharCode(event.keyCode) !== "C" || !isModifierKeyPressed) {
      return;
    }
    if (((_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.toString()) !== "") {
      return;
    }
    apiRef.current.unstable_copySelectedRowsToClipboard(event.altKey);
  }, [apiRef]);
  useGridNativeEventListener(apiRef, apiRef.current.rootElementRef, "keydown", handleKeydown);
  const clipboardApi = {
    unstable_copySelectedRowsToClipboard: copySelectedRowsToClipboard
  };
  useGridApiMethod(apiRef, clipboardApi);
};
const useGridStateInit = (apiRef, callback) => {
  const isInitialized = React$6.useRef(false);
  if (!isInitialized.current) {
    apiRef.current.state = callback(apiRef.current.state);
    isInitialized.current = true;
  }
};
const gridColumnMenuSelector = (state) => state.columnMenu;
const useGridColumnMenu = (apiRef) => {
  const logger = useGridLogger(apiRef, "useGridColumnMenu");
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    columnMenu: {
      open: false
    }
  }));
  const showColumnMenu = React$6.useCallback((field) => {
    const shouldUpdate = apiRef.current.setState((state) => {
      if (state.columnMenu.open && state.columnMenu.field === field) {
        return state;
      }
      logger.debug("Opening Column Menu");
      return _extends$5({}, state, {
        columnMenu: {
          open: true,
          field
        }
      });
    });
    if (shouldUpdate) {
      apiRef.current.hidePreferences();
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const hideColumnMenu = React$6.useCallback(() => {
    const shouldUpdate = apiRef.current.setState((state) => {
      if (!state.columnMenu.open && state.columnMenu.field === void 0) {
        return state;
      }
      logger.debug("Hiding Column Menu");
      return _extends$5({}, state, {
        columnMenu: _extends$5({}, state.columnMenu, {
          open: false,
          field: void 0
        })
      });
    });
    if (shouldUpdate) {
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const toggleColumnMenu = React$6.useCallback((field) => {
    logger.debug("Toggle Column Menu");
    const columnMenu = gridColumnMenuSelector(apiRef.current.state);
    if (!columnMenu.open || columnMenu.field !== field) {
      showColumnMenu(field);
    } else {
      hideColumnMenu();
    }
  }, [apiRef, logger, showColumnMenu, hideColumnMenu]);
  const columnMenuApi = {
    showColumnMenu,
    hideColumnMenu,
    toggleColumnMenu
  };
  useGridApiMethod(apiRef, columnMenuApi);
  useGridApiEventHandler(apiRef, GridEvents.columnResizeStart, hideColumnMenu);
  useGridApiEventHandler(apiRef, GridEvents.rowsScroll, hideColumnMenu);
};
const columnsStateInitializer = (state, props, apiRef) => {
  var _props$initialState, _props$initialState$c, _ref, _props$columnVisibili, _props$initialState2, _props$initialState2$;
  const shouldUseVisibleColumnModel = !!props.columnVisibilityModel || !!((_props$initialState = props.initialState) != null && (_props$initialState$c = _props$initialState.columns) != null && _props$initialState$c.columnVisibilityModel);
  const columnsTypes = computeColumnTypes(props.columnTypes);
  const columnsState = createColumnsState({
    apiRef,
    columnsTypes,
    columnsToUpsert: props.columns,
    shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,
    currentColumnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.columns) == null ? void 0 : _props$initialState2$.columnVisibilityModel) != null ? _ref : {},
    reset: true
  });
  return _extends$5({}, state, {
    columns: columnsState
  });
};
function useGridColumns(apiRef, props) {
  var _props$initialState3, _props$initialState3$;
  const logger = useGridLogger(apiRef, "useGridColumns");
  const columnsTypes = React$6.useMemo(() => computeColumnTypes(props.columnTypes), [props.columnTypes]);
  const shouldUseVisibleColumnModel = React$6.useRef(!!props.columnVisibilityModel || !!((_props$initialState3 = props.initialState) != null && (_props$initialState3$ = _props$initialState3.columns) != null && _props$initialState3$.columnVisibilityModel)).current;
  apiRef.current.unstable_updateControlState({
    stateId: "visibleColumns",
    propModel: props.columnVisibilityModel,
    propOnChange: props.onColumnVisibilityModelChange,
    stateSelector: gridColumnVisibilityModelSelector,
    changeEvent: GridEvents.columnVisibilityModelChange
  });
  const setGridColumnsState = React$6.useCallback((columnsState) => {
    logger.debug("Updating columns state.");
    apiRef.current.setState(setColumnsState(columnsState));
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent(GridEvents.columnsChange, columnsState.all);
  }, [logger, apiRef]);
  const getColumn = React$6.useCallback((field) => gridColumnLookupSelector(apiRef)[field], [apiRef]);
  const getAllColumns = React$6.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);
  const getVisibleColumns = React$6.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);
  const getColumnsMeta = React$6.useCallback(() => gridColumnsMetaSelector(apiRef), [apiRef]);
  const getColumnIndex = React$6.useCallback((field, useVisibleColumns = true) => {
    const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);
    return columns.findIndex((col) => col.field === field);
  }, [apiRef]);
  const getColumnPosition = React$6.useCallback((field) => {
    const index = getColumnIndex(field);
    return gridColumnPositionsSelector(apiRef)[index];
  }, [apiRef, getColumnIndex]);
  const setColumnVisibilityModel = React$6.useCallback((model) => {
    const currentModel = gridColumnVisibilityModelSelector(apiRef);
    if (currentModel !== model) {
      apiRef.current.setState((state) => _extends$5({}, state, {
        columns: createColumnsState({
          apiRef,
          columnsTypes,
          columnsToUpsert: [],
          shouldRegenColumnVisibilityModelFromColumns: false,
          currentColumnVisibilityModel: model,
          reset: false
        })
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, columnsTypes]);
  const updateColumns = React$6.useCallback((columns) => {
    const columnsState = createColumnsState({
      apiRef,
      columnsTypes,
      columnsToUpsert: columns,
      shouldRegenColumnVisibilityModelFromColumns: true,
      reset: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, setGridColumnsState, columnsTypes]);
  const updateColumn = React$6.useCallback((column) => apiRef.current.updateColumns([column]), [apiRef]);
  const setColumnVisibility = React$6.useCallback((field, isVisible) => {
    if (shouldUseVisibleColumnModel) {
      var _columnVisibilityMode;
      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);
      const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;
      if (isVisible !== isCurrentlyVisible) {
        const newModel = _extends$5({}, columnVisibilityModel, {
          [field]: isVisible
        });
        apiRef.current.setColumnVisibilityModel(newModel);
      }
    } else {
      const column = apiRef.current.getColumn(field);
      const newColumn = _extends$5({}, column, {
        hide: !isVisible
      });
      apiRef.current.updateColumns([newColumn]);
      const params = {
        field,
        colDef: newColumn,
        isVisible
      };
      apiRef.current.publishEvent(GridEvents.columnVisibilityChange, params);
    }
  }, [apiRef, shouldUseVisibleColumnModel]);
  const setColumnIndex = React$6.useCallback((field, targetIndexPosition) => {
    const allColumns = gridColumnFieldsSelector(apiRef);
    const oldIndexPosition = allColumns.findIndex((col) => col === field);
    if (oldIndexPosition === targetIndexPosition) {
      return;
    }
    logger.debug(`Moving column ${field} to index ${targetIndexPosition}`);
    const updatedColumns = [...allColumns];
    updatedColumns.splice(targetIndexPosition, 0, updatedColumns.splice(oldIndexPosition, 1)[0]);
    setGridColumnsState(_extends$5({}, gridColumnsSelector(apiRef.current.state), {
      all: updatedColumns
    }));
    const params = {
      field,
      element: apiRef.current.getColumnHeaderElement(field),
      colDef: apiRef.current.getColumn(field),
      targetIndex: targetIndexPosition,
      oldIndex: oldIndexPosition
    };
    apiRef.current.publishEvent(GridEvents.columnOrderChange, params);
  }, [apiRef, logger, setGridColumnsState]);
  const setColumnWidth = React$6.useCallback((field, width) => {
    logger.debug(`Updating column ${field} width to ${width}`);
    const column = apiRef.current.getColumn(field);
    const newColumn = _extends$5({}, column, {
      width
    });
    apiRef.current.updateColumns([newColumn]);
    apiRef.current.publishEvent(GridEvents.columnWidthChange, {
      element: apiRef.current.getColumnHeaderElement(field),
      colDef: newColumn,
      width
    });
  }, [apiRef, logger]);
  const columnApi = {
    getColumn,
    getAllColumns,
    getColumnIndex,
    getColumnPosition,
    getVisibleColumns,
    getColumnsMeta,
    updateColumn,
    updateColumns,
    setColumnVisibilityModel,
    setColumnVisibility,
    setColumnIndex,
    setColumnWidth
  };
  useGridApiMethod(apiRef, columnApi);
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    if (!shouldUseVisibleColumnModel) {
      return prevState;
    }
    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);
    const hasHiddenColumns = Object.values(columnVisibilityModelToExport).some((value) => value === false);
    if (!hasHiddenColumns) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      columns: {
        columnVisibilityModel: columnVisibilityModelToExport
      }
    });
  }, [apiRef, shouldUseVisibleColumnModel]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    var _context$stateToResto;
    if (!shouldUseVisibleColumnModel) {
      return params;
    }
    const columnVisibilityModel = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;
    if (columnVisibilityModel != null) {
      const columnsState = createColumnsState({
        apiRef,
        columnsTypes,
        columnsToUpsert: [],
        shouldRegenColumnVisibilityModelFromColumns: false,
        currentColumnVisibilityModel: columnVisibilityModel,
        reset: false
      });
      apiRef.current.setState(setColumnsState(columnsState));
    }
    return params;
  }, [apiRef, shouldUseVisibleColumnModel, columnsTypes]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handlePreProcessorRegister = React$6.useCallback((name) => {
    if (name !== "hydrateColumns") {
      return;
    }
    logger.info(`Columns pre-processing have changed, regenerating the columns`);
    const columnsState = createColumnsState({
      apiRef,
      columnsTypes,
      columnsToUpsert: [],
      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,
      reset: false
    });
    setGridColumnsState(columnsState);
  }, [apiRef, logger, setGridColumnsState, columnsTypes, shouldUseVisibleColumnModel]);
  const prevInnerWidth = React$6.useRef(null);
  const handleGridSizeChange = (viewportInnerSize) => {
    if (prevInnerWidth.current !== viewportInnerSize.width) {
      prevInnerWidth.current = viewportInnerSize.width;
      setGridColumnsState(hydrateColumnsWidth(gridColumnsSelector(apiRef.current.state), viewportInnerSize.width));
    }
  };
  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);
  useGridApiEventHandler(apiRef, GridEvents.viewportInnerSizeChange, handleGridSizeChange);
  useGridApiOptionHandler(apiRef, GridEvents.columnVisibilityChange, props.onColumnVisibilityChange);
  const isFirstRender = React$6.useRef(true);
  React$6.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    logger.info(`GridColumns have changed, new length ${props.columns.length}`);
    const columnsState = createColumnsState({
      apiRef,
      columnsTypes,
      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,
      columnsToUpsert: props.columns,
      reset: true
    });
    setGridColumnsState(columnsState);
  }, [logger, apiRef, setGridColumnsState, props.columns, columnsTypes, shouldUseVisibleColumnModel]);
  React$6.useEffect(() => {
    if (props.columnVisibilityModel !== void 0) {
      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);
    }
  }, [apiRef, logger, props.columnVisibilityModel]);
}
const COMPACT_DENSITY_FACTOR = 0.7;
const COMFORTABLE_DENSITY_FACTOR = 1.3;
const getUpdatedDensityState = (newDensity, newHeaderHeight, newRowHeight) => {
  switch (newDensity) {
    case GridDensityTypes.Compact:
      return {
        value: newDensity,
        headerHeight: Math.floor(newHeaderHeight * COMPACT_DENSITY_FACTOR),
        rowHeight: Math.floor(newRowHeight * COMPACT_DENSITY_FACTOR),
        factor: COMPACT_DENSITY_FACTOR
      };
    case GridDensityTypes.Comfortable:
      return {
        value: newDensity,
        headerHeight: Math.floor(newHeaderHeight * COMFORTABLE_DENSITY_FACTOR),
        rowHeight: Math.floor(newRowHeight * COMFORTABLE_DENSITY_FACTOR),
        factor: COMFORTABLE_DENSITY_FACTOR
      };
    default:
      return {
        value: newDensity,
        headerHeight: newHeaderHeight,
        rowHeight: newRowHeight,
        factor: 1
      };
  }
};
const useGridDensity = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useDensity");
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    density: getUpdatedDensityState(props.density, props.headerHeight, props.rowHeight)
  }));
  const setDensity = React$6.useCallback((newDensity, newHeaderHeight = props.headerHeight, newRowHeight = props.rowHeight) => {
    logger.debug(`Set grid density to ${newDensity}`);
    apiRef.current.setState((state) => {
      const currentDensityState = gridDensitySelector(state);
      const newDensityState = getUpdatedDensityState(newDensity, newHeaderHeight, newRowHeight);
      if (isDeepEqual(currentDensityState, newDensityState)) {
        return state;
      }
      return _extends$5({}, state, {
        density: newDensityState
      });
    });
    apiRef.current.forceUpdate();
  }, [logger, apiRef, props.headerHeight, props.rowHeight]);
  React$6.useEffect(() => {
    apiRef.current.setDensity(props.density, props.headerHeight, props.rowHeight);
  }, [apiRef, props.density, props.rowHeight, props.headerHeight]);
  const densityApi = {
    setDensity
  };
  useGridApiMethod(apiRef, densityApi);
};
const getDefaultGridFilterModel = () => ({
  items: [],
  linkOperator: GridLinkOperator.And
});
function exportAs(blob, extension = "csv", filename = document.title) {
  const fullName = `${filename}.${extension}`;
  if ("download" in HTMLAnchorElement.prototype) {
    const url = URL.createObjectURL(blob);
    const a2 = document.createElement("a");
    a2.href = url;
    a2.download = fullName;
    a2.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
    });
    return;
  }
  throw new Error("MUI: exportAs not supported");
}
const serialiseCellValue = (value, delimiterCharacter) => {
  if (typeof value === "string") {
    const formattedValue = value.replace(/"/g, '""');
    if ([delimiterCharacter, "\n", "\r"].some((delimiter) => formattedValue.includes(delimiter))) {
      return `"${formattedValue}"`;
    }
    return formattedValue;
  }
  return value;
};
const serialiseRow = (id2, columns, getCellParams, delimiterCharacter) => columns.map((column) => {
  const cellParams = getCellParams(id2, column.field);
  return serialiseCellValue(cellParams.formattedValue, delimiterCharacter);
});
function buildCSV(options) {
  const {
    columns,
    rowIds,
    getCellParams,
    delimiterCharacter,
    includeHeaders
  } = options;
  const CSVBody = rowIds.reduce((acc, id2) => `${acc}${serialiseRow(id2, columns, getCellParams, delimiterCharacter).join(delimiterCharacter)}\r
`, "").trim();
  if (!includeHeaders) {
    return CSVBody;
  }
  const CSVHead = `${columns.filter((column) => column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field).map((column) => serialiseCellValue(column.headerName || column.field, delimiterCharacter)).join(delimiterCharacter)}\r
`;
  return `${CSVHead}${CSVBody}`.trim();
}
const getColumnsToExport = ({
  apiRef,
  options
}) => {
  const columns = gridColumnDefinitionsSelector(apiRef);
  if (options.fields) {
    return options.fields.map((field) => columns.find((column) => column.field === field)).filter((column) => !!column);
  }
  const validColumns = options.allColumns ? columns : gridVisibleColumnDefinitionsSelector(apiRef);
  return validColumns.filter((column) => !column.disableExport);
};
const defaultGetRowsToExport = ({
  apiRef
}) => {
  const filteredSortedRowIds = gridFilteredSortedRowIdsSelector(apiRef);
  const selectedRows = apiRef.current.getSelectedRows();
  if (selectedRows.size > 0) {
    return filteredSortedRowIds.filter((id2) => selectedRows.has(id2));
  }
  return filteredSortedRowIds;
};
const useGridCsvExport = (apiRef) => {
  const logger = useGridLogger(apiRef, "useGridCsvExport");
  const getDataAsCsv = React$6.useCallback((options = {}) => {
    var _options$getRowsToExp, _options$includeHeade;
    logger.debug(`Get data as CSV`);
    const exportedColumns = getColumnsToExport({
      apiRef,
      options
    });
    const getRowsToExport = (_options$getRowsToExp = options.getRowsToExport) != null ? _options$getRowsToExp : defaultGetRowsToExport;
    const exportedRowIds = getRowsToExport({
      apiRef
    });
    return buildCSV({
      columns: exportedColumns,
      rowIds: exportedRowIds,
      getCellParams: apiRef.current.getCellParams,
      delimiterCharacter: options.delimiter || ",",
      includeHeaders: (_options$includeHeade = options.includeHeaders) != null ? _options$includeHeade : true
    });
  }, [logger, apiRef]);
  const exportDataAsCsv = React$6.useCallback((options) => {
    logger.debug(`Export data as CSV`);
    const csv = getDataAsCsv(options);
    const blob = new Blob([options != null && options.utf8WithBom ? new Uint8Array([239, 187, 191]) : "", csv], {
      type: "text/csv"
    });
    exportAs(blob, "csv", options == null ? void 0 : options.fileName);
  }, [logger, getDataAsCsv]);
  const csvExportApi = {
    getDataAsCsv,
    exportDataAsCsv
  };
  useGridApiMethod(apiRef, csvExportApi);
};
const gridRowsMetaSelector = (state) => state.rowsMeta;
const useGridPrintExport = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridPrintExport");
  const doc = React$6.useRef(null);
  const previousGridState = React$6.useRef(null);
  const previousColumnVisibility = React$6.useRef({});
  React$6.useEffect(() => {
    doc.current = ownerDocument(apiRef.current.rootElementRef.current);
  }, [apiRef]);
  const updateGridColumnsForPrint = React$6.useCallback((fields, allColumns) => new Promise((resolve) => {
    if (!fields && !allColumns) {
      resolve();
      return;
    }
    const exportedColumnFields = getColumnsToExport({
      apiRef,
      options: {
        fields,
        allColumns
      }
    }).map((column) => column.field);
    const columns = gridColumnDefinitionsSelector(apiRef);
    const newColumnVisibilityModel = {};
    columns.forEach((column) => {
      newColumnVisibilityModel[column.field] = exportedColumnFields.includes(column.field);
    });
    apiRef.current.setColumnVisibilityModel(newColumnVisibilityModel);
    resolve();
  }), [apiRef]);
  const buildPrintWindow = React$6.useCallback((title) => {
    const iframeEl = document.createElement("iframe");
    iframeEl.id = "grid-print-window";
    iframeEl.src = window.location.href;
    iframeEl.style.position = "absolute";
    iframeEl.style.width = "0px";
    iframeEl.style.height = "0px";
    iframeEl.title = title || document.title;
    return iframeEl;
  }, []);
  const handlePrintWindowLoad = React$6.useCallback((printWindow, options) => {
    var _printWindow$contentW, _querySelector, _querySelector2;
    const normalizeOptions = _extends$5({
      copyStyles: true,
      hideToolbar: false,
      hideFooter: false
    }, options);
    printWindow.onload = null;
    const printDoc = printWindow.contentDocument || ((_printWindow$contentW = printWindow.contentWindow) == null ? void 0 : _printWindow$contentW.document);
    if (!printDoc) {
      return;
    }
    const headerHeight = gridDensityHeaderHeightSelector(apiRef);
    const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
    const gridRootElement = apiRef.current.rootElementRef.current;
    const gridClone = gridRootElement.cloneNode(true);
    const gridCloneViewport = gridClone.querySelector(`.${gridClasses.virtualScroller}`);
    gridCloneViewport.style.height = "auto";
    gridCloneViewport.style.width = "auto";
    gridCloneViewport.parentElement.style.width = "auto";
    gridCloneViewport.parentElement.style.height = "auto";
    const gridMain = gridClone.querySelector(`.${gridClasses.main}`);
    gridMain.style.overflow = "visible";
    const columnHeaders = gridClone.querySelector(`.${gridClasses.columnHeaders}`);
    const columnHeadersInner = columnHeaders.querySelector(`.${gridClasses.columnHeadersInner}`);
    columnHeadersInner.style.width = "100%";
    let gridToolbarElementHeight = ((_querySelector = gridRootElement.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _querySelector.clientHeight) || 0;
    let gridFooterElementHeight = ((_querySelector2 = gridRootElement.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _querySelector2.clientHeight) || 0;
    if (normalizeOptions.hideToolbar) {
      var _gridClone$querySelec;
      (_gridClone$querySelec = gridClone.querySelector(`.${gridClasses.toolbarContainer}`)) == null ? void 0 : _gridClone$querySelec.remove();
      gridToolbarElementHeight = 0;
    }
    if (normalizeOptions.hideFooter) {
      var _gridClone$querySelec2;
      (_gridClone$querySelec2 = gridClone.querySelector(`.${gridClasses.footerContainer}`)) == null ? void 0 : _gridClone$querySelec2.remove();
      gridFooterElementHeight = 0;
    }
    gridClone.style.height = `${rowsMeta.currentPageTotalHeight + headerHeight + gridToolbarElementHeight + gridFooterElementHeight}px`;
    printDoc.body.innerHTML = "";
    printDoc.body.appendChild(gridClone);
    const defaultPageStyle = typeof normalizeOptions.pageStyle === "function" ? normalizeOptions.pageStyle() : normalizeOptions.pageStyle;
    if (typeof defaultPageStyle === "string") {
      const styleElement = printDoc.createElement("style");
      styleElement.appendChild(printDoc.createTextNode(defaultPageStyle));
      printDoc.head.appendChild(styleElement);
    }
    if (normalizeOptions.bodyClassName) {
      printDoc.body.classList.add(...normalizeOptions.bodyClassName.split(" "));
    }
    if (normalizeOptions.copyStyles) {
      const headStyleElements = doc.current.querySelectorAll("style, link[rel='stylesheet']");
      for (let i2 = 0; i2 < headStyleElements.length; i2 += 1) {
        const node = headStyleElements[i2];
        if (node.tagName === "STYLE") {
          const newHeadStyleElements = printDoc.createElement(node.tagName);
          const sheet = node.sheet;
          if (sheet) {
            let styleCSS = "";
            for (let j2 = 0; j2 < sheet.cssRules.length; j2 += 1) {
              if (typeof sheet.cssRules[j2].cssText === "string") {
                styleCSS += `${sheet.cssRules[j2].cssText}\r
`;
              }
            }
            newHeadStyleElements.appendChild(printDoc.createTextNode(styleCSS));
            printDoc.head.appendChild(newHeadStyleElements);
          }
        } else if (node.getAttribute("href")) {
          const newHeadStyleElements = printDoc.createElement(node.tagName);
          for (let j2 = 0; j2 < node.attributes.length; j2 += 1) {
            const attr = node.attributes[j2];
            if (attr) {
              newHeadStyleElements.setAttribute(attr.nodeName, attr.nodeValue || "");
            }
          }
          printDoc.head.appendChild(newHeadStyleElements);
        }
      }
    }
    {
      printWindow.contentWindow.print();
    }
  }, [apiRef, doc]);
  const handlePrintWindowAfterPrint = React$6.useCallback((printWindow) => {
    var _previousGridState$cu, _previousGridState$cu2;
    doc.current.body.removeChild(printWindow);
    apiRef.current.restoreState(previousGridState.current || {});
    if (!((_previousGridState$cu = previousGridState.current) != null && (_previousGridState$cu2 = _previousGridState$cu.columns) != null && _previousGridState$cu2.columnVisibilityModel)) {
      apiRef.current.setColumnVisibilityModel(previousColumnVisibility.current);
    }
    apiRef.current.unstable_enableVirtualization();
    previousGridState.current = null;
    previousColumnVisibility.current = {};
  }, [apiRef]);
  const exportDataAsPrint = React$6.useCallback(async (options) => {
    logger.debug(`Export data as Print`);
    if (!apiRef.current.rootElementRef.current) {
      throw new Error("MUI: No grid root element available.");
    }
    previousGridState.current = apiRef.current.exportState();
    previousColumnVisibility.current = gridColumnVisibilityModelSelector(apiRef);
    if (props.pagination) {
      const visibleRowCount = gridVisibleRowCountSelector(apiRef);
      apiRef.current.setPageSize(visibleRowCount);
    }
    await updateGridColumnsForPrint(options == null ? void 0 : options.fields, options == null ? void 0 : options.allColumns);
    apiRef.current.unstable_disableVirtualization();
    const printWindow = buildPrintWindow(options == null ? void 0 : options.fileName);
    doc.current.body.appendChild(printWindow);
    {
      printWindow.onload = () => handlePrintWindowLoad(printWindow, options);
      printWindow.contentWindow.onafterprint = () => handlePrintWindowAfterPrint(printWindow);
    }
  }, [props, logger, apiRef, buildPrintWindow, handlePrintWindowLoad, handlePrintWindowAfterPrint, updateGridColumnsForPrint]);
  const printExportApi = {
    exportDataAsPrint
  };
  useGridApiMethod(apiRef, printExportApi);
};
const useGridRegisterFilteringMethod = (apiRef, groupingName, filteringMethod) => {
  const updateRegistration = React$6.useCallback((filteringMethodCollection) => {
    filteringMethodCollection[groupingName] = filteringMethod;
    return filteringMethodCollection;
  }, [groupingName, filteringMethod]);
  useGridRegisterPreProcessor(apiRef, "filteringMethod", updateRegistration);
};
const cleanFilterItem = (item, apiRef) => {
  const cleanItem = _extends$5({}, item);
  if (cleanItem.id == null) {
    cleanItem.id = Math.round(Math.random() * 1e5);
  }
  if (cleanItem.operatorValue == null) {
    const column = apiRef.current.getColumn(cleanItem.columnField);
    cleanItem.operatorValue = column && column.filterOperators[0].value;
  }
  return cleanItem;
};
const filterModelDisableMultiColumnsFilteringWarning = buildWarning(["MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.", "If you are using the community version of the `DataGrid`, this prop is always `true`."], "error");
const filterModelMissingItemIdWarning = buildWarning("MUI: The 'id' field is required on `filterModel.items` when you use multiple filters.", "error");
const filterModelMissingItemOperatorWarning = buildWarning(["MUI: One of your filtering item have no `operatorValue` provided.", "This property will become required on `@mui/x-data-grid@6.X`."]);
const sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {
  const hasSeveralItems = model.items.length > 1;
  let items;
  if (hasSeveralItems && disableMultipleColumnsFiltering) {
    filterModelDisableMultiColumnsFilteringWarning();
    items = [model.items[0]];
  } else {
    items = model.items;
  }
  const hasItemsWithoutIds = hasSeveralItems && items.some((item) => item.id == null);
  const hasItemWithoutOperator = items.some((item) => item.operatorValue == null);
  if (hasItemsWithoutIds) {
    filterModelMissingItemIdWarning();
  }
  if (hasItemWithoutOperator) {
    filterModelMissingItemOperatorWarning();
  }
  if (hasItemWithoutOperator || hasItemsWithoutIds) {
    return _extends$5({}, model, {
      items: items.map((item) => cleanFilterItem(item, apiRef))
    });
  }
  if (model.items !== items) {
    return _extends$5({}, model, {
      items
    });
  }
  return model;
};
const mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => (state) => _extends$5({}, state, {
  filter: _extends$5({}, state.filter, {
    filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)
  })
});
const buildAggregatedFilterApplier = (filterModel, apiRef) => {
  const {
    items,
    linkOperator = GridLinkOperator.And
  } = filterModel;
  const getFilterCallbackFromItem = (filterItem) => {
    if (!filterItem.columnField || !filterItem.operatorValue) {
      return null;
    }
    const column = apiRef.current.getColumn(filterItem.columnField);
    if (!column) {
      return null;
    }
    let parsedValue;
    if (column.valueParser) {
      var _filterItem$value;
      const parser = column.valueParser;
      parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map((x2) => parser(x2)) : parser(filterItem.value);
    } else {
      parsedValue = filterItem.value;
    }
    const newFilterItem = _extends$5({}, filterItem, {
      value: parsedValue
    });
    const filterOperators = column.filterOperators;
    if (!(filterOperators != null && filterOperators.length)) {
      throw new Error(`MUI: No filter operators found for column '${column.field}'.`);
    }
    const filterOperator = filterOperators.find((operator) => operator.value === newFilterItem.operatorValue);
    if (!filterOperator) {
      throw new Error(`MUI: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operatorValue}'.`);
    }
    const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);
    if (typeof applyFilterOnRow !== "function") {
      return null;
    }
    const fn = (rowId) => {
      const cellParams = apiRef.current.getCellParams(rowId, newFilterItem.columnField);
      return applyFilterOnRow(cellParams);
    };
    return {
      fn,
      item: newFilterItem
    };
  };
  const appliers = items.map(getFilterCallbackFromItem).filter((callback) => !!callback);
  if (appliers.length === 0) {
    return null;
  }
  return (rowId, shouldApplyFilter) => {
    const filteredAppliers = shouldApplyFilter ? appliers.filter((applier) => shouldApplyFilter(applier.item)) : appliers;
    if (linkOperator === GridLinkOperator.And) {
      return filteredAppliers.every((applier) => applier.fn(rowId));
    }
    return filteredAppliers.some((applier) => applier.fn(rowId));
  };
};
const filterStateInitializer = (state, props, apiRef) => {
  var _ref, _props$filterModel, _props$initialState, _props$initialState$f;
  const filterModel = (_ref = (_props$filterModel = props.filterModel) != null ? _props$filterModel : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$f = _props$initialState.filter) == null ? void 0 : _props$initialState$f.filterModel) != null ? _ref : getDefaultGridFilterModel();
  return _extends$5({}, state, {
    filter: {
      filterModel: sanitizeFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef),
      visibleRowsLookup: {},
      filteredDescendantCountLookup: {}
    }
  });
};
const useGridFilter = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridFilter");
  const filteringMethodCollectionRef = React$6.useRef({});
  const lastFilteringMethodApplied = React$6.useRef(null);
  apiRef.current.unstable_updateControlState({
    stateId: "filter",
    propModel: props.filterModel,
    propOnChange: props.onFilterModelChange,
    stateSelector: gridFilterModelSelector,
    changeEvent: GridEvents.filterModelChange
  });
  const applyFilters = React$6.useCallback(() => {
    apiRef.current.setState((state) => {
      const rowGroupingName = gridRowGroupingNameSelector(state, apiRef.current.instanceId);
      const filteringMethod = filteringMethodCollectionRef.current[rowGroupingName];
      if (!filteringMethod) {
        throw new Error("MUI: Invalid filtering method.");
      }
      const filterModel = gridFilterModelSelector(state, apiRef.current.instanceId);
      const isRowMatchingFilters = props.filterMode === GridFeatureModeConstant.client ? buildAggregatedFilterApplier(filterModel, apiRef) : null;
      lastFilteringMethodApplied.current = filteringMethod;
      const filteringResult = filteringMethod({
        isRowMatchingFilters
      });
      return _extends$5({}, state, {
        filter: _extends$5({}, state.filter, filteringResult)
      });
    });
    apiRef.current.publishEvent(GridEvents.visibleRowsSet);
    apiRef.current.forceUpdate();
  }, [apiRef, props.filterMode]);
  const upsertFilterItem = React$6.useCallback((item) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = [...filterModel.items];
    const itemIndex = items.findIndex((filterItem) => filterItem.id === item.id);
    if (itemIndex === -1) {
      items.push(item);
    } else {
      items[itemIndex] = item;
    }
    apiRef.current.setFilterModel(_extends$5({}, filterModel, {
      items
    }));
  }, [apiRef]);
  const deleteFilterItem = React$6.useCallback((itemToDelete) => {
    const filterModel = gridFilterModelSelector(apiRef);
    const items = filterModel.items.filter((item) => item.id !== itemToDelete.id);
    if (items.length === filterModel.items.length) {
      return;
    }
    apiRef.current.setFilterModel(_extends$5({}, filterModel, {
      items
    }));
  }, [apiRef]);
  const showFilterPanel = React$6.useCallback((targetColumnField) => {
    logger.debug("Displaying filter panel");
    if (targetColumnField) {
      const filterModel = gridFilterModelSelector(apiRef);
      const filterItemsWithValue = filterModel.items.filter((item) => item.value !== void 0);
      let newFilterItems;
      const filterItemOnTarget = filterItemsWithValue.find((item) => item.columnField === targetColumnField);
      if (filterItemOnTarget) {
        newFilterItems = filterItemsWithValue;
      } else if (props.disableMultipleColumnsFiltering) {
        newFilterItems = [{
          columnField: targetColumnField
        }];
      } else {
        newFilterItems = [...filterItemsWithValue, {
          columnField: targetColumnField
        }];
      }
      apiRef.current.setFilterModel(_extends$5({}, filterModel, {
        items: newFilterItems
      }));
    }
    apiRef.current.showPreferences(GridPreferencePanelsValue.filters);
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const hideFilterPanel = React$6.useCallback(() => {
    logger.debug("Hiding filter panel");
    apiRef.current.hidePreferences();
  }, [apiRef, logger]);
  const setFilterLinkOperator = React$6.useCallback((linkOperator) => {
    const filterModel = gridFilterModelSelector(apiRef);
    if (filterModel.linkOperator === linkOperator) {
      return;
    }
    apiRef.current.setFilterModel(_extends$5({}, filterModel, {
      linkOperator
    }));
  }, [apiRef]);
  const setFilterModel = React$6.useCallback((model) => {
    const currentModel = gridFilterModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug("Setting filter model");
      apiRef.current.setState(mergeStateWithFilterModel(model, props.disableMultipleColumnsFiltering, apiRef));
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef, logger, props.disableMultipleColumnsFiltering]);
  const getVisibleRowModels = React$6.useCallback(() => {
    const visibleSortedRows = gridVisibleSortedRowEntriesSelector(apiRef);
    return new Map(visibleSortedRows.map((row) => [row.id, row.model]));
  }, [apiRef]);
  const filterApi = {
    setFilterLinkOperator,
    unstable_applyFilters: applyFilters,
    deleteFilterItem,
    upsertFilterItem,
    setFilterModel,
    showFilterPanel,
    hideFilterPanel,
    getVisibleRowModels
  };
  useGridApiMethod(apiRef, filterApi);
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    const filterModelToExport = gridFilterModelSelector(apiRef);
    if (filterModelToExport.items.length === 0 && filterModelToExport.linkOperator === getDefaultGridFilterModel().linkOperator) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      filter: {
        filterModel: filterModelToExport
      }
    });
  }, [apiRef]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    var _context$stateToResto;
    const filterModel = (_context$stateToResto = context.stateToRestore.filter) == null ? void 0 : _context$stateToResto.filterModel;
    if (filterModel == null) {
      return params;
    }
    apiRef.current.setState(mergeStateWithFilterModel(filterModel, props.disableMultipleColumnsFiltering, apiRef));
    return _extends$5({}, params, {
      callbacks: [...params.callbacks, apiRef.current.unstable_applyFilters]
    });
  }, [apiRef, props.disableMultipleColumnsFiltering]);
  const flatFilteringMethod = React$6.useCallback((params) => {
    if (props.filterMode === GridFeatureModeConstant.client && params.isRowMatchingFilters) {
      const rowIds = gridRowIdsSelector(apiRef);
      const filteredRowsLookup = {};
      for (let i2 = 0; i2 < rowIds.length; i2 += 1) {
        const rowId = rowIds[i2];
        filteredRowsLookup[rowId] = params.isRowMatchingFilters(rowId);
      }
      return {
        filteredRowsLookup,
        visibleRowsLookup: filteredRowsLookup,
        filteredDescendantCountLookup: {}
      };
    }
    return {
      visibleRowsLookup: {},
      filteredRowsLookup: {},
      filteredDescendantCountLookup: {}
    };
  }, [apiRef, props.filterMode]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterFilteringMethod(apiRef, "none", flatFilteringMethod);
  const handleColumnsChange = React$6.useCallback(() => {
    logger.debug("onColUpdated - GridColumns changed, applying filters");
    const filterModel = gridFilterModelSelector(apiRef);
    const filterableColumnsLookup = gridFilterableColumnLookupSelector(apiRef);
    const newFilterItems = filterModel.items.filter((item) => item.columnField && filterableColumnsLookup[item.columnField]);
    if (newFilterItems.length < filterModel.items.length) {
      apiRef.current.setFilterModel(_extends$5({}, filterModel, {
        items: newFilterItems
      }));
    }
  }, [apiRef, logger]);
  const handlePreProcessorRegister = React$6.useCallback((name) => {
    if (name !== "filteringMethod") {
      return;
    }
    filteringMethodCollectionRef.current = apiRef.current.unstable_applyPreProcessors("filteringMethod", {});
    const rowGroupingName = gridRowGroupingNameSelector(apiRef);
    if (lastFilteringMethodApplied.current !== filteringMethodCollectionRef.current[rowGroupingName]) {
      apiRef.current.unstable_applyFilters();
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, GridEvents.rowsSet, apiRef.current.unstable_applyFilters);
  useGridApiEventHandler(apiRef, GridEvents.rowExpansionChange, apiRef.current.unstable_applyFilters);
  useGridApiEventHandler(apiRef, GridEvents.columnsChange, handleColumnsChange);
  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);
  useFirstRender(() => {
    filteringMethodCollectionRef.current = apiRef.current.unstable_applyPreProcessors("filteringMethod", {});
    apiRef.current.unstable_applyFilters();
  });
  React$6.useEffect(() => {
    if (props.filterModel !== void 0) {
      apiRef.current.setFilterModel(props.filterModel);
    }
  }, [apiRef, logger, props.filterModel]);
};
const useGridFocus = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridFocus");
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    focus: {
      cell: null,
      columnHeader: null
    },
    tabIndex: {
      cell: null,
      columnHeader: null
    }
  }));
  const lastClickedCell = React$6.useRef(null);
  const setCellFocus = React$6.useCallback((id2, field) => {
    if (!apiRef.current.getRow(id2)) {
      return;
    }
    const focusedCell = gridFocusCellSelector(apiRef);
    if ((focusedCell == null ? void 0 : focusedCell.id) === id2 && focusedCell.field === field) {
      return;
    }
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on cell with id=${id2} and field=${field}`);
      return _extends$5({}, state, {
        tabIndex: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null
        },
        focus: {
          cell: {
            id: id2,
            field
          },
          columnHeader: null
        }
      });
    });
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent(GridEvents.cellFocusIn, apiRef.current.getCellParams(id2, field));
  }, [apiRef, logger]);
  const setColumnHeaderFocus = React$6.useCallback((field, event = {}) => {
    const cell = gridFocusCellSelector(apiRef);
    if (cell) {
      apiRef.current.publishEvent(GridEvents.cellFocusOut, apiRef.current.getCellParams(cell.id, cell.field), event);
    }
    apiRef.current.setState((state) => {
      logger.debug(`Focusing on column header with colIndex=${field}`);
      return _extends$5({}, state, {
        tabIndex: {
          columnHeader: {
            field
          },
          cell: null
        },
        focus: {
          columnHeader: {
            field
          },
          cell: null
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const handleCellDoubleClick = React$6.useCallback(({
    id: id2,
    field
  }) => {
    apiRef.current.setCellFocus(id2, field);
  }, [apiRef]);
  const handleCellKeyDown = React$6.useCallback((params, event) => {
    if (event.key === "Enter" || event.key === "Tab" || isNavigationKey(event.key)) {
      return;
    }
    apiRef.current.setCellFocus(params.id, params.field);
  }, [apiRef]);
  const handleColumnHeaderFocus = React$6.useCallback(({
    field
  }, event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef]);
  const handleBlur = React$6.useCallback(() => {
    logger.debug(`Clearing focus`);
    apiRef.current.setState((state) => _extends$5({}, state, {
      focus: {
        cell: null,
        columnHeader: null
      }
    }));
  }, [logger, apiRef]);
  const handleCellMouseUp = React$6.useCallback((params) => {
    lastClickedCell.current = params;
  }, []);
  const handleDocumentClick = React$6.useCallback((event) => {
    const cellParams = lastClickedCell.current;
    lastClickedCell.current = null;
    const focusedCell = gridFocusCellSelector(apiRef);
    if (!focusedCell) {
      if (cellParams) {
        apiRef.current.setCellFocus(cellParams.id, cellParams.field);
      }
      return;
    }
    if ((cellParams == null ? void 0 : cellParams.id) === focusedCell.id && (cellParams == null ? void 0 : cellParams.field) === focusedCell.field) {
      return;
    }
    const cellElement = apiRef.current.getCellElement(focusedCell.id, focusedCell.field);
    if (cellElement != null && cellElement.contains(event.target)) {
      return;
    }
    if (!apiRef.current.getRow(focusedCell.id)) {
      return;
    }
    apiRef.current.publishEvent(GridEvents.cellFocusOut, apiRef.current.getCellParams(focusedCell.id, focusedCell.field), event);
    if (cellParams) {
      apiRef.current.setCellFocus(cellParams.id, cellParams.field);
    } else {
      apiRef.current.setState((state) => _extends$5({}, state, {
        focus: {
          cell: null,
          columnHeader: null
        }
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef]);
  const handleCellModeChange = React$6.useCallback((params) => {
    if (params.cellMode === "view") {
      return;
    }
    const cell = gridFocusCellSelector(apiRef);
    if ((cell == null ? void 0 : cell.id) !== params.id || (cell == null ? void 0 : cell.field) !== params.field) {
      apiRef.current.setCellFocus(params.id, params.field);
    }
  }, [apiRef]);
  useGridApiMethod(apiRef, {
    setCellFocus,
    setColumnHeaderFocus
  });
  React$6.useEffect(() => {
    const cell = gridFocusCellSelector(apiRef);
    if (cell) {
      const updatedRow = apiRef.current.getRow(cell.id);
      if (!updatedRow) {
        apiRef.current.setState((state) => _extends$5({}, state, {
          focus: {
            cell: null,
            columnHeader: null
          }
        }));
      }
    }
  }, [apiRef, props.rows]);
  React$6.useEffect(() => {
    const doc = ownerDocument(apiRef.current.rootElementRef.current);
    doc.addEventListener("click", handleDocumentClick);
    return () => {
      doc.removeEventListener("click", handleDocumentClick);
    };
  }, [apiRef, handleDocumentClick]);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderBlur, handleBlur);
  useGridApiEventHandler(apiRef, GridEvents.cellDoubleClick, handleCellDoubleClick);
  useGridApiEventHandler(apiRef, GridEvents.cellMouseUp, handleCellMouseUp);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, handleCellKeyDown);
  useGridApiEventHandler(apiRef, GridEvents.cellModeChange, handleCellModeChange);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderFocus, handleColumnHeaderFocus);
};
const useGridKeyboard = (apiRef) => {
  const expandSelection = React$6.useCallback((params, event) => {
    apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, params, event);
    const focusCell = gridFocusCellSelector(apiRef);
    if (!focusCell) {
      return;
    }
    const rowEl = findParentElementFromClassName(event.target, gridClasses.row);
    const startRowIndex = Number(rowEl.getAttribute("data-rowindex"));
    const startId = gridVisibleSortedRowIdsSelector(apiRef)[startRowIndex];
    if (startId === focusCell.id) {
      return;
    }
    apiRef.current.selectRowRange({
      startId,
      endId: focusCell.id
    }, !apiRef.current.isRowSelected(focusCell.id));
  }, [apiRef]);
  const handleCellKeyDown = React$6.useCallback((params, event) => {
    if (!event.currentTarget.contains(event.target)) {
      return;
    }
    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    const isEditMode = cellParams.cellMode === GridCellModes.Edit;
    if (isEditMode) {
      return;
    }
    if (event.key === " " && event.shiftKey) {
      return;
    }
    if (isNavigationKey(event.key) && !event.shiftKey) {
      apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, cellParams, event);
      return;
    }
    if (isNavigationKey(event.key) && event.shiftKey) {
      event.preventDefault();
      expandSelection(cellParams, event);
    }
  }, [apiRef, expandSelection]);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, handleCellKeyDown);
};
const getCurrentPageRows = (apiRef, props) => {
  let rows;
  let range;
  if (props.pagination && props.paginationMode === "client") {
    range = gridPaginationRowRangeSelector(apiRef);
    rows = gridPaginatedVisibleSortedGridRowEntriesSelector(apiRef);
  } else {
    rows = gridVisibleSortedRowEntriesSelector(apiRef);
    if (rows.length === 0) {
      range = null;
    } else {
      range = {
        firstRowIndex: 0,
        lastRowIndex: rows.length - 1
      };
    }
  }
  return {
    rows,
    range
  };
};
const useCurrentPageRows = (apiRef, props) => {
  const response = getCurrentPageRows(apiRef, props);
  return React$6.useMemo(() => ({
    rows: response.rows,
    range: response.range
  }), [response.rows, response.range]);
};
const useGridKeyboardNavigation = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridKeyboardNavigation");
  const currentPage = useCurrentPageRows(apiRef, props);
  const goToCell = React$6.useCallback((colIndex, rowIndex) => {
    logger.debug(`Navigating to cell row ${rowIndex}, col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex,
      rowIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    const visibleSortedRows = gridVisibleSortedRowEntriesSelector(apiRef);
    const node = visibleSortedRows[rowIndex];
    apiRef.current.setCellFocus(node.id, field);
  }, [apiRef, logger]);
  const goToHeader = React$6.useCallback((colIndex, event) => {
    logger.debug(`Navigating to header col ${colIndex}`);
    apiRef.current.scrollToIndexes({
      colIndex
    });
    const field = apiRef.current.getVisibleColumns()[colIndex].field;
    apiRef.current.setColumnHeaderFocus(field, event);
  }, [apiRef, logger]);
  const handleCellNavigationKeyDown = React$6.useCallback((params, event) => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!currentPage.range || !dimensions) {
      return;
    }
    const viewportPageSize = apiRef.current.unstable_getViewportPageSize();
    const visibleSortedRows = gridVisibleSortedRowEntriesSelector(apiRef);
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const rowIndexBefore = visibleSortedRows.findIndex((row) => row.id === params.id);
    const firstRowIndexInPage = currentPage.range.firstRowIndex;
    const lastRowIndexInPage = currentPage.range.lastRowIndex;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown":
      case "Enter": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, rowIndexBefore + 1);
        }
        break;
      }
      case "ArrowUp": {
        if (rowIndexBefore > firstRowIndexInPage) {
          goToCell(colIndexBefore, rowIndexBefore - 1);
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "ArrowRight": {
        if (colIndexBefore < lastColIndex) {
          goToCell(colIndexBefore + 1, rowIndexBefore);
        }
        break;
      }
      case "ArrowLeft": {
        if (colIndexBefore > firstColIndex) {
          goToCell(colIndexBefore - 1, rowIndexBefore);
        }
        break;
      }
      case "Tab": {
        if (event.shiftKey && colIndexBefore > firstColIndex) {
          goToCell(colIndexBefore - 1, rowIndexBefore);
        } else if (!event.shiftKey && colIndexBefore < lastColIndex) {
          goToCell(colIndexBefore + 1, rowIndexBefore);
        }
        break;
      }
      case "PageDown":
      case " ": {
        if (rowIndexBefore < lastRowIndexInPage) {
          goToCell(colIndexBefore, Math.min(rowIndexBefore + viewportPageSize, lastRowIndexInPage));
        }
        break;
      }
      case "PageUp": {
        const nextRowIndex = Math.max(rowIndexBefore - viewportPageSize, firstRowIndexInPage);
        if (nextRowIndex !== rowIndexBefore && nextRowIndex >= firstRowIndexInPage) {
          goToCell(colIndexBefore, nextRowIndex);
        } else {
          goToHeader(colIndexBefore, event);
        }
        break;
      }
      case "Home": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(firstColIndex, firstRowIndexInPage);
        } else {
          goToCell(firstColIndex, rowIndexBefore);
        }
        break;
      }
      case "End": {
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          goToCell(lastColIndex, lastRowIndexInPage);
        } else {
          goToCell(lastColIndex, rowIndexBefore);
        }
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPage, goToCell, goToHeader]);
  const handleColumnHeaderKeyDown = React$6.useCallback((params, event) => {
    var _currentPage$range$fi, _currentPage$range, _currentPage$range$la, _currentPage$range2;
    const headerTitleNode = event.currentTarget.querySelector(`.${gridClasses.columnHeaderTitleContainerContent}`);
    const isFromInsideContent = !!headerTitleNode && headerTitleNode.contains(event.target);
    if (isFromInsideContent && params.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return;
    }
    const viewportPageSize = apiRef.current.unstable_getViewportPageSize();
    const colIndexBefore = params.field ? apiRef.current.getColumnIndex(params.field) : 0;
    const firstRowIndexInPage = (_currentPage$range$fi = (_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.firstRowIndex) != null ? _currentPage$range$fi : null;
    const lastRowIndexInPage = (_currentPage$range$la = (_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.lastRowIndex) != null ? _currentPage$range$la : null;
    const firstColIndex = 0;
    const lastColIndex = gridVisibleColumnDefinitionsSelector(apiRef).length - 1;
    let shouldPreventDefault = true;
    switch (event.key) {
      case "ArrowDown": {
        if (firstRowIndexInPage !== null) {
          goToCell(colIndexBefore, firstRowIndexInPage);
        }
        break;
      }
      case "ArrowRight": {
        if (colIndexBefore < lastColIndex) {
          goToHeader(colIndexBefore + 1, event);
        }
        break;
      }
      case "ArrowLeft": {
        if (colIndexBefore > firstColIndex) {
          goToHeader(colIndexBefore - 1, event);
        }
        break;
      }
      case "PageDown": {
        if (firstRowIndexInPage !== null && lastRowIndexInPage !== null) {
          goToCell(colIndexBefore, Math.min(firstRowIndexInPage + viewportPageSize, lastRowIndexInPage));
        }
        break;
      }
      case "Home": {
        goToHeader(firstColIndex, event);
        break;
      }
      case "End": {
        goToHeader(lastColIndex, event);
        break;
      }
      case "Enter": {
        if (event.ctrlKey || event.metaKey) {
          apiRef.current.toggleColumnMenu(params.field);
        }
        break;
      }
      case " ": {
        break;
      }
      default: {
        shouldPreventDefault = false;
      }
    }
    if (shouldPreventDefault) {
      event.preventDefault();
    }
  }, [apiRef, currentPage, goToCell, goToHeader]);
  useGridApiEventHandler(apiRef, GridEvents.cellNavigationKeyDown, handleCellNavigationKeyDown);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderKeyDown, handleColumnHeaderKeyDown);
};
const defaultPageSize = (autoPageSize) => autoPageSize ? 0 : 100;
const pageSizeStateInitializer = (state, props) => {
  var _props$initialState, _props$initialState$p;
  let pageSize;
  if (props.pageSize != null) {
    pageSize = props.pageSize;
  } else if (((_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$p = _props$initialState.pagination) == null ? void 0 : _props$initialState$p.pageSize) != null) {
    pageSize = props.initialState.pagination.pageSize;
  } else {
    pageSize = defaultPageSize(props.autoPageSize);
  }
  return _extends$5({}, state, {
    pagination: {
      pageSize
    }
  });
};
const mergeStateWithPageSize = (pageSize) => (state) => _extends$5({}, state, {
  pagination: _extends$5({}, state.pagination, {
    pageSize
  })
});
const useGridPageSize = (apiRef, props) => {
  var _props$initialState3, _props$initialState3$;
  const logger = useGridLogger(apiRef, "useGridPageSize");
  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);
  apiRef.current.unstable_updateControlState({
    stateId: "pageSize",
    propModel: props.pageSize,
    propOnChange: props.onPageSizeChange,
    stateSelector: gridPageSizeSelector,
    changeEvent: GridEvents.pageSizeChange
  });
  const setPageSize = React$6.useCallback((pageSize) => {
    if (pageSize === gridPageSizeSelector(apiRef)) {
      return;
    }
    logger.debug(`Setting page size to ${pageSize}`);
    apiRef.current.setState(mergeStateWithPageSize(pageSize));
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const pageSizeApi = {
    setPageSize
  };
  useGridApiMethod(apiRef, pageSizeApi);
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    var _props$initialState2, _props$initialState2$;
    const pageSizeToExport = gridPageSizeSelector(apiRef);
    const shouldExportPageSize = props.pageSize != null || ((_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.pagination) == null ? void 0 : _props$initialState2$.pageSize) != null || pageSizeToExport !== defaultPageSize(props.autoPageSize);
    if (!shouldExportPageSize) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      pagination: _extends$5({}, prevState.pagination, {
        pageSize: pageSizeToExport
      })
    });
  }, [apiRef, props.pageSize, (_props$initialState3 = props.initialState) == null ? void 0 : (_props$initialState3$ = _props$initialState3.pagination) == null ? void 0 : _props$initialState3$.pageSize, props.autoPageSize]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    var _context$stateToResto;
    const pageSize = (_context$stateToResto = context.stateToRestore.pagination) == null ? void 0 : _context$stateToResto.pageSize;
    if (pageSize != null) {
      apiRef.current.setState(mergeStateWithPageSize(pageSize));
    }
    return params;
  }, [apiRef]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handleUpdateAutoPageSize = React$6.useCallback(() => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!props.autoPageSize || !dimensions) {
      return;
    }
    const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / rowHeight);
    apiRef.current.setPageSize(maximumPageSizeWithoutScrollBar);
  }, [apiRef, props.autoPageSize, rowHeight]);
  useGridApiEventHandler(apiRef, GridEvents.viewportInnerSizeChange, handleUpdateAutoPageSize);
  React$6.useEffect(() => {
    if (props.pageSize != null && !props.autoPageSize) {
      apiRef.current.setPageSize(props.pageSize);
    }
  }, [apiRef, props.autoPageSize, props.pageSize]);
  React$6.useEffect(() => {
    handleUpdateAutoPageSize();
  }, [handleUpdateAutoPageSize]);
};
const getPageCount = (rowCount, pageSize) => {
  if (pageSize > 0 && rowCount > 0) {
    return Math.ceil(rowCount / pageSize);
  }
  return 0;
};
const applyValidPage = (paginationState) => {
  if (!paginationState.pageCount) {
    return paginationState;
  }
  return _extends$5({}, paginationState, {
    page: Math.max(Math.min(paginationState.page, paginationState.pageCount - 1), 0)
  });
};
const mergeStateWithPage = (page) => (state) => _extends$5({}, state, {
  pagination: applyValidPage(_extends$5({}, state.pagination, {
    page
  }))
});
buildWarning(["MUI: the 'rowCount' prop is undefined while using paginationMode='server'", "For more detail, see http://mui.com/components/data-grid/pagination/#basic-implementation"], "error");
const pageStateInitializer = (state, props) => {
  var _ref, _props$page, _props$initialState, _props$initialState$p, _props$rowCount, _props$rowCount2;
  return _extends$5({}, state, {
    pagination: _extends$5({}, state.pagination, {
      page: (_ref = (_props$page = props.page) != null ? _props$page : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$p = _props$initialState.pagination) == null ? void 0 : _props$initialState$p.page) != null ? _ref : 0,
      pageCount: getPageCount((_props$rowCount = props.rowCount) != null ? _props$rowCount : 0, state.pagination.pageSize),
      rowCount: (_props$rowCount2 = props.rowCount) != null ? _props$rowCount2 : 0
    })
  });
};
const useGridPage = (apiRef, props) => {
  var _props$initialState3, _props$initialState3$;
  const logger = useGridLogger(apiRef, "useGridPage");
  const visibleTopLevelRowCount = useGridSelector(apiRef, gridVisibleTopLevelRowCountSelector);
  apiRef.current.unstable_updateControlState({
    stateId: "page",
    propModel: props.page,
    propOnChange: props.onPageChange,
    stateSelector: gridPageSelector,
    changeEvent: GridEvents.pageChange
  });
  const setPage = React$6.useCallback((page) => {
    logger.debug(`Setting page to ${page}`);
    apiRef.current.setState(mergeStateWithPage(page));
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const pageApi = {
    setPage
  };
  useGridApiMethod(apiRef, pageApi);
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    var _props$initialState2, _props$initialState2$;
    const pageToExport = gridPageSelector(apiRef);
    const shouldExportPage = props.page != null || ((_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.pagination) == null ? void 0 : _props$initialState2$.page) != null || pageToExport !== 0;
    if (!shouldExportPage) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      pagination: _extends$5({}, prevState.pagination, {
        page: pageToExport
      })
    });
  }, [apiRef, props.page, (_props$initialState3 = props.initialState) == null ? void 0 : (_props$initialState3$ = _props$initialState3.pagination) == null ? void 0 : _props$initialState3$.page]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    var _context$stateToResto, _context$stateToResto2;
    const page = (_context$stateToResto = (_context$stateToResto2 = context.stateToRestore.pagination) == null ? void 0 : _context$stateToResto2.page) != null ? _context$stateToResto : gridPageSelector(apiRef);
    apiRef.current.setState(mergeStateWithPage(page));
    return params;
  }, [apiRef]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  const handlePageSizeChange = (pageSize) => {
    apiRef.current.setState((state) => {
      const pageCount = getPageCount(state.pagination.rowCount, pageSize);
      return _extends$5({}, state, {
        pagination: applyValidPage(_extends$5({}, state.pagination, {
          pageCount,
          page: state.pagination.page
        }))
      });
    });
    apiRef.current.forceUpdate();
  };
  useGridApiEventHandler(apiRef, GridEvents.pageSizeChange, handlePageSizeChange);
  React$6.useEffect(() => {
  }, [props.rowCount, props.paginationMode]);
  React$6.useEffect(() => {
    apiRef.current.setState((state) => {
      const rowCount = props.rowCount !== void 0 ? props.rowCount : visibleTopLevelRowCount;
      const pageCount = getPageCount(rowCount, state.pagination.pageSize);
      const page = props.page == null ? state.pagination.page : props.page;
      return _extends$5({}, state, {
        pagination: applyValidPage(_extends$5({}, state.pagination, {
          page,
          rowCount,
          pageCount
        }))
      });
    });
    apiRef.current.forceUpdate();
  }, [visibleTopLevelRowCount, props.rowCount, props.page, props.paginationMode, apiRef]);
};
const useGridPagination = (apiRef, props) => {
  useGridPageSize(apiRef, props);
  useGridPage(apiRef, props);
};
const useGridPreferencesPanel = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridPreferencesPanel");
  useGridStateInit(apiRef, (state) => {
    var _props$initialState$p, _props$initialState;
    return _extends$5({}, state, {
      preferencePanel: (_props$initialState$p = (_props$initialState = props.initialState) == null ? void 0 : _props$initialState.preferencePanel) != null ? _props$initialState$p : {
        open: false
      }
    });
  });
  const hideTimeout = React$6.useRef();
  const immediateTimeout = React$6.useRef();
  const hidePreferences = React$6.useCallback(() => {
    logger.debug("Hiding Preferences Panel");
    apiRef.current.setState((state) => _extends$5({}, state, {
      preferencePanel: {
        open: false
      }
    }));
    apiRef.current.forceUpdate();
  }, [apiRef, logger]);
  const doNotHidePanel = React$6.useCallback(() => {
    immediateTimeout.current = setTimeout(() => clearTimeout(hideTimeout.current), 0);
  }, []);
  const hidePreferencesDelayed = React$6.useCallback(() => {
    hideTimeout.current = setTimeout(hidePreferences, 100);
  }, [hidePreferences]);
  const showPreferences = React$6.useCallback((newValue) => {
    logger.debug("Opening Preferences Panel");
    doNotHidePanel();
    apiRef.current.setState((state) => _extends$5({}, state, {
      preferencePanel: _extends$5({}, state.preferencePanel, {
        open: true,
        openedPanelValue: newValue
      })
    }));
    apiRef.current.forceUpdate();
  }, [doNotHidePanel, apiRef, logger]);
  useGridApiMethod(apiRef, {
    showPreferences,
    hidePreferences: hidePreferencesDelayed
  });
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    const preferencePanelToExport = gridPreferencePanelStateSelector(apiRef.current.state);
    if (!preferencePanelToExport.open && !preferencePanelToExport.openedPanelValue) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      preferencePanel: preferencePanelToExport
    });
  }, [apiRef]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    const preferencePanel = context.stateToRestore.preferencePanel;
    if (preferencePanel != null) {
      apiRef.current.setState((state) => _extends$5({}, state, {
        preferencePanel
      }));
    }
    return params;
  }, [apiRef]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  React$6.useEffect(() => {
    return () => {
      clearTimeout(hideTimeout.current);
      clearTimeout(immediateTimeout.current);
    };
  }, []);
};
const gridEditRowsStateSelector = (state) => state.editRows;
function isPromise$1(promise) {
  return typeof promise.then === "function";
}
const useCellEditing = (apiRef, props) => {
  var _props$experimentalFe2;
  const logger = useGridLogger(apiRef, "useGridEditRows");
  const buildCallback = (callback) => (...args) => {
    if (props.editMode === GridEditModes.Cell) {
      callback(...args);
    }
  };
  const setCellMode = React$6.useCallback((id2, field, mode) => {
    if (apiRef.current.getCellMode(id2, field) === mode) {
      return;
    }
    logger.debug(`Switching cell id: ${id2} field: ${field} to mode: ${mode}`);
    apiRef.current.setState((state) => {
      const newEditRowsState = _extends$5({}, state.editRows);
      newEditRowsState[id2] = _extends$5({}, newEditRowsState[id2]);
      if (mode === GridCellModes.Edit) {
        newEditRowsState[id2][field] = {
          value: apiRef.current.getCellValue(id2, field)
        };
      } else {
        delete newEditRowsState[id2][field];
        if (!Object.keys(newEditRowsState[id2]).length) {
          delete newEditRowsState[id2];
        }
      }
      return _extends$5({}, state, {
        editRows: newEditRowsState
      });
    });
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent(GridEvents.cellModeChange, apiRef.current.getCellParams(id2, field));
  }, [apiRef, logger]);
  const getCellMode = React$6.useCallback((id2, field) => {
    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);
    const isEditing = editRowsState[id2] && editRowsState[id2][field];
    return isEditing ? GridCellModes.Edit : GridCellModes.View;
  }, [apiRef]);
  const commitCellChange = React$6.useCallback((params, event = {}) => {
    var _props$experimentalFe;
    const {
      id: id2,
      field
    } = params;
    apiRef.current.unstable_runPendingEditCellValueChangeDebounce(id2, field);
    const model = apiRef.current.getEditRowsModel();
    if (!model[id2] || !model[id2][field]) {
      throw new Error(`MUI: Cell at id: ${id2} and field: ${field} is not in edit mode.`);
    }
    const editCellProps = model[id2][field];
    const column = apiRef.current.getColumn(field);
    const row = apiRef.current.getRow(id2);
    if ((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.preventCommitWhileValidating) {
      const cellProps = model[id2][field];
      if (cellProps.isValidating || cellProps.error) {
        return false;
      }
    }
    const commitParams = _extends$5({}, params, {
      value: editCellProps.value
    });
    let hasError = !!editCellProps.error;
    if (!hasError && typeof column.preProcessEditCellProps === "function") {
      const result = column.preProcessEditCellProps({
        id: id2,
        row,
        props: editCellProps
      });
      if (isPromise$1(result)) {
        return result.then((newEditCellProps) => {
          apiRef.current.unstable_setEditCellProps({
            id: id2,
            field,
            props: newEditCellProps
          });
          if (newEditCellProps.error) {
            return false;
          }
          apiRef.current.publishEvent(GridEvents.cellEditCommit, commitParams, event);
          return true;
        });
      }
      apiRef.current.unstable_setEditCellProps({
        id: id2,
        field,
        props: result
      });
      hasError = !!result.error;
    }
    if (!hasError) {
      apiRef.current.publishEvent(GridEvents.cellEditCommit, commitParams, event);
      return true;
    }
    return false;
  }, [apiRef, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.preventCommitWhileValidating]);
  const setCellEditingEditCellValue = React$6.useCallback((params) => {
    const column = apiRef.current.getColumn(params.field);
    const row = apiRef.current.getRow(params.id);
    return new Promise((resolve) => {
      let newEditCellProps = {
        value: params.value
      };
      const model = apiRef.current.getEditRowsModel();
      const editCellProps = model[params.id][params.field];
      if (typeof column.preProcessEditCellProps !== "function") {
        apiRef.current.unstable_setEditCellProps(_extends$5({}, params, {
          props: newEditCellProps
        }));
        resolve(true);
        return;
      }
      newEditCellProps = apiRef.current.unstable_setEditCellProps(_extends$5({}, params, {
        props: _extends$5({}, editCellProps, {
          isValidating: true
        })
      }));
      Promise.resolve(column.preProcessEditCellProps({
        id: params.id,
        row,
        props: _extends$5({}, newEditCellProps, {
          value: apiRef.current.unstable_parseValue(params.id, params.field, params.value)
        })
      })).then((newEditCellPropsProcessed) => {
        apiRef.current.unstable_setEditCellProps(_extends$5({}, params, {
          props: _extends$5({}, newEditCellPropsProcessed, {
            isValidating: false
          })
        }));
        resolve(!newEditCellPropsProcessed.error);
      });
    });
  }, [apiRef]);
  const cellEditingApi = {
    setCellMode,
    getCellMode,
    commitCellChange,
    unstable_setCellEditingEditCellValue: setCellEditingEditCellValue
  };
  useGridApiMethod(apiRef, cellEditingApi);
  const handleCellKeyDown = React$6.useCallback(async (params, event) => {
    const {
      id: id2,
      field,
      cellMode,
      isEditable
    } = params;
    if (!isEditable) {
      return;
    }
    const isEditMode = cellMode === GridCellModes.Edit;
    const isModifierKeyPressed = event.ctrlKey || event.metaKey || event.altKey;
    if (!isEditMode && isCellEnterEditModeKeys(event.key) && !isModifierKeyPressed && !(event.key === " " && event.shiftKey)) {
      apiRef.current.publishEvent(GridEvents.cellEditStart, params, event);
    }
    if (!isEditMode && isDeleteKeys(event.key)) {
      apiRef.current.setEditCellValue({
        id: id2,
        field,
        value: ""
      });
      apiRef.current.commitCellChange({
        id: id2,
        field
      }, event);
      apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);
    }
    if (isEditMode && isCellEditCommitKeys(event.key)) {
      const commitParams = {
        id: id2,
        field
      };
      const isValid2 = await apiRef.current.commitCellChange(commitParams, event);
      if (!isValid2) {
        return;
      }
    }
    if (isEditMode && isCellExitEditModeKeys(event.key)) {
      apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);
    }
  }, [apiRef]);
  const handleCellDoubleClick = React$6.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    apiRef.current.publishEvent(GridEvents.cellEditStart, params, event);
  }, [apiRef]);
  const commitPropsAndExit = async (params, event) => {
    if (params.cellMode === GridCellModes.View) {
      return;
    }
    await apiRef.current.commitCellChange(params, event);
    apiRef.current.publishEvent(GridEvents.cellEditStop, params, event);
  };
  const handleCellFocusOut = useEventCallback$1((params, event) => {
    commitPropsAndExit(params, event);
  });
  const handleColumnHeaderDragStart = useEventCallback$1(() => {
    const cell = gridFocusCellSelector(apiRef);
    if (!cell) {
      return;
    }
    const params = apiRef.current.getCellParams(cell.id, cell.field);
    commitPropsAndExit(params, {});
  });
  const handleCellEditStart = React$6.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    apiRef.current.setCellMode(params.id, params.field, GridCellModes.Edit);
    if (isKeyboardEvent(event) && isPrintableKey(event.key)) {
      apiRef.current.unstable_setEditCellProps({
        id: params.id,
        field: params.field,
        props: {
          value: ""
        }
      });
    }
  }, [apiRef]);
  const handleCellEditStop = React$6.useCallback((params, event) => {
    apiRef.current.setCellMode(params.id, params.field, GridCellModes.View);
    if (!isKeyboardEvent(event)) {
      return;
    }
    if (isCellEditCommitKeys(event.key)) {
      apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, params, event);
      return;
    }
    if (event.key === "Escape" || isDeleteKeys(event.key)) {
      apiRef.current.setCellFocus(params.id, params.field);
    }
  }, [apiRef]);
  const handleCellEditCommit = React$6.useCallback((params) => {
    const {
      id: id2,
      field
    } = params;
    const model = apiRef.current.getEditRowsModel();
    const {
      value
    } = model[id2][field];
    logger.debug(`Setting cell id: ${id2} field: ${field} to value: ${value == null ? void 0 : value.toString()}`);
    const row = apiRef.current.getRow(id2);
    if (row) {
      const column = apiRef.current.getColumn(params.field);
      let rowUpdate = _extends$5({}, row, {
        [field]: value
      });
      if (column.valueSetter) {
        rowUpdate = column.valueSetter({
          row,
          value
        });
      }
      apiRef.current.updateRows([rowUpdate]);
    }
  }, [apiRef, logger]);
  const handleEditCellPropsChange = React$6.useCallback((params) => {
    const row = apiRef.current.getRow(params.id);
    const column = apiRef.current.getColumn(params.field);
    const editCellProps = column.preProcessEditCellProps ? column.preProcessEditCellProps({
      id: params.id,
      row,
      props: params.props
    }) : params.props;
    if (isPromise$1(editCellProps)) {
      editCellProps.then((newEditCellProps) => {
        apiRef.current.unstable_setEditCellProps(_extends$5({}, params, {
          props: newEditCellProps
        }));
      });
    } else {
      apiRef.current.unstable_setEditCellProps(_extends$5({}, params, {
        props: editCellProps
      }));
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, buildCallback(handleCellKeyDown));
  useGridApiEventHandler(apiRef, GridEvents.cellDoubleClick, buildCallback(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, GridEvents.cellFocusOut, buildCallback(handleCellFocusOut));
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, buildCallback(handleColumnHeaderDragStart));
  useGridApiEventHandler(apiRef, GridEvents.cellEditStart, buildCallback(handleCellEditStart));
  useGridApiEventHandler(apiRef, GridEvents.cellEditStop, buildCallback(handleCellEditStop));
  useGridApiEventHandler(apiRef, GridEvents.cellEditCommit, buildCallback(handleCellEditCommit));
  useGridApiEventHandler(apiRef, GridEvents.editCellPropsChange, buildCallback(handleEditCellPropsChange));
  useGridApiOptionHandler(apiRef, GridEvents.cellEditCommit, props.onCellEditCommit);
  useGridApiOptionHandler(apiRef, GridEvents.cellEditStart, props.onCellEditStart);
  useGridApiOptionHandler(apiRef, GridEvents.cellEditStop, props.onCellEditStop);
};
const useGridRowEditing = (apiRef, props) => {
  var _props$experimentalFe2, _props$experimentalFe4;
  const focusTimeout = React$6.useRef(null);
  const nextFocusedCell = React$6.useRef(null);
  const columnFields = useGridSelector(apiRef, gridColumnFieldsSelector);
  const buildCallback = (callback) => (...args) => {
    if (props.editMode === GridEditModes.Row) {
      callback(...args);
    }
  };
  const setRowMode = React$6.useCallback((id2, mode) => {
    if (mode === apiRef.current.getRowMode(id2)) {
      return;
    }
    apiRef.current.setState((state) => {
      const newEditRowsState = _extends$5({}, state.editRows);
      if (mode === GridRowModes.Edit) {
        newEditRowsState[id2] = {};
        columnFields.forEach((field) => {
          const cellParams = apiRef.current.getCellParams(id2, field);
          if (cellParams.isEditable) {
            newEditRowsState[id2][field] = {
              value: cellParams.value
            };
          }
        });
      } else {
        delete newEditRowsState[id2];
      }
      return _extends$5({}, state, {
        editRows: newEditRowsState
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, columnFields]);
  const getRowMode = React$6.useCallback((id2) => {
    if (props.editMode === GridEditModes.Cell) {
      return GridRowModes.View;
    }
    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);
    return editRowsState[id2] ? GridRowModes.Edit : GridRowModes.View;
  }, [apiRef, props.editMode]);
  const commitRowChange = React$6.useCallback((id2, event = {}) => {
    var _props$experimentalFe;
    if (props.editMode === GridEditModes.Cell) {
      throw new Error(`MUI: You can't commit changes when the edit mode is 'cell'.`);
    }
    apiRef.current.unstable_runPendingEditCellValueChangeDebounce(id2);
    const model = apiRef.current.getEditRowsModel();
    const editRowProps = model[id2];
    if (!editRowProps) {
      throw new Error(`MUI: Row at id: ${id2} is not being edited.`);
    }
    if ((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.preventCommitWhileValidating) {
      const isValid2 = Object.keys(editRowProps).reduce((acc, field) => {
        return acc && !editRowProps[field].isValidating && !editRowProps[field].error;
      }, true);
      if (!isValid2) {
        return false;
      }
    }
    const hasFieldWithError = Object.values(editRowProps).some((value) => !!value.error);
    if (hasFieldWithError) {
      return false;
    }
    const fieldsWithValidator = Object.keys(editRowProps).filter((field) => {
      const column = apiRef.current.getColumn(field);
      return typeof column.preProcessEditCellProps === "function";
    });
    if (fieldsWithValidator.length > 0) {
      const row = apiRef.current.getRow(id2);
      const validatorErrors = fieldsWithValidator.map(async (field) => {
        const column = apiRef.current.getColumn(field);
        const newEditCellProps = await Promise.resolve(column.preProcessEditCellProps({
          id: id2,
          row,
          props: editRowProps[field]
        }));
        apiRef.current.unstable_setEditCellProps({
          id: id2,
          field,
          props: newEditCellProps
        });
        return newEditCellProps.error;
      });
      return Promise.all(validatorErrors).then((errors) => {
        if (errors.some((error) => !!error)) {
          return false;
        }
        apiRef.current.publishEvent(GridEvents.rowEditCommit, id2, event);
        return true;
      });
    }
    apiRef.current.publishEvent(GridEvents.rowEditCommit, id2, event);
    return true;
  }, [apiRef, props.editMode, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.preventCommitWhileValidating]);
  const setRowEditingEditCellValue = React$6.useCallback((params) => {
    const model = apiRef.current.getEditRowsModel();
    const editRow = model[params.id];
    const row = apiRef.current.getRow(params.id);
    let isValid2 = true;
    return new Promise((resolve) => {
      Object.keys(editRow).forEach(async (field) => {
        const column = apiRef.current.getColumn(field);
        let editCellProps = field === params.field ? {
          value: params.value
        } : editRow[field];
        editCellProps = apiRef.current.unstable_setEditCellProps({
          id: params.id,
          field,
          props: _extends$5({}, editCellProps, {
            isValidating: true
          })
        });
        if (column.preProcessEditCellProps) {
          editCellProps = await Promise.resolve(column.preProcessEditCellProps({
            id: params.id,
            row,
            props: _extends$5({}, editCellProps, {
              value: field === params.field ? apiRef.current.unstable_parseValue(params.id, field, params.value) : editCellProps.value
            })
          }));
        }
        if (editCellProps.error) {
          isValid2 = false;
        }
        apiRef.current.unstable_setEditCellProps({
          id: params.id,
          field,
          props: _extends$5({}, editCellProps, {
            isValidating: false
          })
        });
      });
      resolve(isValid2);
    });
  }, [apiRef]);
  const rowEditingApi = {
    setRowMode,
    getRowMode,
    commitRowChange,
    unstable_setRowEditingEditCellValue: setRowEditingEditCellValue
  };
  useGridApiMethod(apiRef, rowEditingApi);
  const handleCellKeyDown = React$6.useCallback(async (params, event) => {
    const {
      cellMode,
      isEditable
    } = params;
    if (!isEditable) {
      return;
    }
    const isEditMode = cellMode === GridCellModes.Edit;
    const rowParams = apiRef.current.getRowParams(params.id);
    if (isEditMode) {
      if (event.key === "Enter") {
        var _props$experimentalFe3;
        const isValid2 = await apiRef.current.commitRowChange(params.id);
        if (!isValid2 && (_props$experimentalFe3 = props.experimentalFeatures) != null && _props$experimentalFe3.preventCommitWhileValidating) {
          return;
        }
        apiRef.current.publishEvent(GridEvents.rowEditStop, rowParams, event);
      } else if (event.key === "Escape") {
        apiRef.current.publishEvent(GridEvents.rowEditStop, rowParams, event);
      }
    } else if (event.key === "Enter") {
      apiRef.current.publishEvent(GridEvents.rowEditStart, rowParams, event);
    }
  }, [apiRef, (_props$experimentalFe4 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe4.preventCommitWhileValidating]);
  const handleCellDoubleClick = React$6.useCallback((params, event) => {
    if (!params.isEditable) {
      return;
    }
    const rowParams = apiRef.current.getRowParams(params.id);
    apiRef.current.publishEvent(GridEvents.rowEditStart, rowParams, event);
  }, [apiRef]);
  const handleEditCellPropsChange = React$6.useCallback((params) => {
    const row = apiRef.current.getRow(params.id);
    const model = apiRef.current.getEditRowsModel();
    const editRow = model[params.id];
    Object.keys(editRow).forEach(async (field) => {
      const column = apiRef.current.getColumn(field);
      if (column.preProcessEditCellProps) {
        const editCellProps = field === params.field ? params.props : editRow[field];
        const newEditCellProps = await Promise.resolve(column.preProcessEditCellProps({
          id: params.id,
          row,
          props: editCellProps
        }));
        apiRef.current.unstable_setEditCellProps({
          id: params.id,
          field,
          props: newEditCellProps
        });
      } else if (field === params.field) {
        apiRef.current.unstable_setEditCellProps(params);
      }
    });
  }, [apiRef]);
  const handleRowEditStart = React$6.useCallback((params) => {
    apiRef.current.setRowMode(params.id, GridRowModes.Edit);
  }, [apiRef]);
  const handleRowEditStop = React$6.useCallback((params, event) => {
    apiRef.current.setRowMode(params.id, GridRowModes.View);
    if (event.key === "Enter") {
      apiRef.current.publishEvent(GridEvents.cellNavigationKeyDown, params, event);
    }
  }, [apiRef]);
  const handleRowEditCommit = React$6.useCallback((id2) => {
    const model = apiRef.current.getEditRowsModel();
    const editRow = model[id2];
    if (!editRow) {
      throw new Error(`MUI: Row at id: ${id2} is not being edited.`);
    }
    const row = apiRef.current.getRow(id2);
    if (row) {
      let rowUpdate = _extends$5({}, row);
      Object.keys(editRow).forEach((field) => {
        const column = apiRef.current.getColumn(field);
        const value = editRow[field].value;
        if (column.valueSetter) {
          rowUpdate = column.valueSetter({
            row: rowUpdate,
            value
          });
        } else {
          rowUpdate[field] = value;
        }
      });
      apiRef.current.updateRows([rowUpdate]);
    }
  }, [apiRef]);
  const handleCellFocusIn = React$6.useCallback((params) => {
    nextFocusedCell.current = params;
  }, []);
  const commitPropsAndExit = async (params, event) => {
    if (params.cellMode === GridCellModes.View) {
      return;
    }
    nextFocusedCell.current = null;
    focusTimeout.current = setTimeout(async () => {
      var _nextFocusedCell$curr;
      if (((_nextFocusedCell$curr = nextFocusedCell.current) == null ? void 0 : _nextFocusedCell$curr.id) !== params.id) {
        await apiRef.current.commitRowChange(params.id, event);
        const rowParams = apiRef.current.getRowParams(params.id);
        apiRef.current.publishEvent(GridEvents.rowEditStop, rowParams, event);
      }
    });
  };
  const handleCellFocusOut = useEventCallback$1((params, event) => {
    commitPropsAndExit(params, event);
  });
  const handleColumnHeaderDragStart = useEventCallback$1(() => {
    const cell = gridFocusCellSelector(apiRef);
    if (!cell) {
      return;
    }
    const params = apiRef.current.getCellParams(cell.id, cell.field);
    commitPropsAndExit(params, {});
  });
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, buildCallback(handleCellKeyDown));
  useGridApiEventHandler(apiRef, GridEvents.cellDoubleClick, buildCallback(handleCellDoubleClick));
  useGridApiEventHandler(apiRef, GridEvents.editCellPropsChange, buildCallback(handleEditCellPropsChange));
  useGridApiEventHandler(apiRef, GridEvents.rowEditStart, buildCallback(handleRowEditStart));
  useGridApiEventHandler(apiRef, GridEvents.rowEditStop, buildCallback(handleRowEditStop));
  useGridApiEventHandler(apiRef, GridEvents.rowEditCommit, buildCallback(handleRowEditCommit));
  useGridApiEventHandler(apiRef, GridEvents.cellFocusIn, buildCallback(handleCellFocusIn));
  useGridApiEventHandler(apiRef, GridEvents.cellFocusOut, buildCallback(handleCellFocusOut));
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, buildCallback(handleColumnHeaderDragStart));
  useGridApiOptionHandler(apiRef, GridEvents.rowEditCommit, props.onRowEditCommit);
  useGridApiOptionHandler(apiRef, GridEvents.rowEditStart, props.onRowEditStart);
  useGridApiOptionHandler(apiRef, GridEvents.rowEditStop, props.onRowEditStop);
};
function useGridEditing(apiRef, props) {
  var _props$experimentalFe2;
  const logger = useGridLogger(apiRef, "useGridEditRows");
  useCellEditing(apiRef, props);
  useGridRowEditing(apiRef, props);
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    editRows: {}
  }));
  const debounceMap = React$6.useRef({});
  apiRef.current.unstable_updateControlState({
    stateId: "editRows",
    propModel: props.editRowsModel,
    propOnChange: props.onEditRowsModelChange,
    stateSelector: gridEditRowsStateSelector,
    changeEvent: GridEvents.editRowsModelChange
  });
  const isCellEditable = React$6.useCallback((params) => !params.rowNode.isAutoGenerated && !!params.colDef.editable && !!params.colDef.renderEditCell && (!props.isCellEditable || props.isCellEditable(params)), [props.isCellEditable]);
  const maybeDebounce = (id2, field, debounceMs, callback) => {
    if (!debounceMs) {
      callback();
      return;
    }
    if (!debounceMap.current[id2]) {
      debounceMap.current[id2] = {};
    }
    if (debounceMap.current[id2][field]) {
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
    }
    const callbackToRunImmediately = () => {
      callback();
      const [timeout2] = debounceMap.current[id2][field];
      clearTimeout(timeout2);
      delete debounceMap.current[id2][field];
    };
    const timeout = setTimeout(() => {
      callback();
      delete debounceMap.current[id2][field];
    }, debounceMs);
    debounceMap.current[id2][field] = [timeout, callbackToRunImmediately];
  };
  const runPendingEditCellValueChangeDebounce = React$6.useCallback((id2, field) => {
    if (!debounceMap.current[id2]) {
      return;
    }
    if (!field) {
      Object.keys(debounceMap.current[id2]).forEach((debouncedField) => {
        const [, callback] = debounceMap.current[id2][debouncedField];
        callback();
      });
    } else if (debounceMap.current[id2][field]) {
      const [, callback] = debounceMap.current[id2][field];
      callback();
    }
  }, []);
  const setEditCellValue = React$6.useCallback((params, event = {}) => {
    maybeDebounce(params.id, params.field, params.debounceMs, () => {
      var _props$experimentalFe;
      if ((_props$experimentalFe = props.experimentalFeatures) != null && _props$experimentalFe.preventCommitWhileValidating) {
        if (props.editMode === "row") {
          return apiRef.current.unstable_setRowEditingEditCellValue(params);
        }
        return apiRef.current.unstable_setCellEditingEditCellValue(params);
      }
      const newParams = {
        id: params.id,
        field: params.field,
        props: {
          value: params.value
        }
      };
      return apiRef.current.publishEvent(GridEvents.editCellPropsChange, newParams, event);
    });
  }, [apiRef, props.editMode, (_props$experimentalFe2 = props.experimentalFeatures) == null ? void 0 : _props$experimentalFe2.preventCommitWhileValidating]);
  const parseValue = React$6.useCallback((id2, field, value) => {
    const column = apiRef.current.getColumn(field);
    return column.valueParser ? column.valueParser(value, apiRef.current.getCellParams(id2, field)) : value;
  }, [apiRef]);
  const setEditCellProps = React$6.useCallback((params) => {
    const {
      id: id2,
      field,
      props: editProps
    } = params;
    logger.debug(`Setting cell props on id: ${id2} field: ${field}`);
    apiRef.current.setState((state) => {
      const editRowsModel = _extends$5({}, state.editRows);
      editRowsModel[id2] = _extends$5({}, state.editRows[id2]);
      editRowsModel[id2][field] = _extends$5({}, editProps, {
        value: parseValue(id2, field, editProps.value)
      });
      return _extends$5({}, state, {
        editRows: editRowsModel
      });
    });
    apiRef.current.forceUpdate();
    const editRowsState = gridEditRowsStateSelector(apiRef.current.state);
    return editRowsState[id2][field];
  }, [apiRef, logger, parseValue]);
  const setEditRowsModel = React$6.useCallback((model) => {
    const currentModel = gridEditRowsStateSelector(apiRef.current.state);
    if (currentModel !== model) {
      logger.debug(`Setting editRows model`);
      apiRef.current.setState((state) => _extends$5({}, state, {
        editRows: model
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const getEditRowsModel = React$6.useCallback(() => gridEditRowsStateSelector(apiRef.current.state), [apiRef]);
  const preventTextSelection = React$6.useCallback((params, event) => {
    const isMoreThanOneClick = event.detail > 1;
    if (params.isEditable && params.cellMode === GridCellModes.View && isMoreThanOneClick) {
      event.preventDefault();
    }
  }, []);
  useGridApiEventHandler(apiRef, GridEvents.cellMouseDown, preventTextSelection);
  useGridApiOptionHandler(apiRef, GridEvents.editCellPropsChange, props.onEditCellPropsChange);
  const editingSharedApi = {
    isCellEditable,
    setEditRowsModel,
    getEditRowsModel,
    setEditCellValue,
    unstable_setEditCellProps: setEditCellProps,
    unstable_parseValue: parseValue,
    unstable_runPendingEditCellValueChangeDebounce: runPendingEditCellValueChangeDebounce
  };
  useGridApiMethod(apiRef, editingSharedApi);
  React$6.useEffect(() => {
    if (props.editRowsModel !== void 0) {
      apiRef.current.setEditRowsModel(props.editRowsModel);
    }
  }, [apiRef, props.editRowsModel]);
}
function getGridRowId(rowModel, getRowId, detailErrorMessage) {
  const id2 = getRowId ? getRowId(rowModel) : rowModel.id;
  checkGridRowIdIsValid(id2, rowModel, detailErrorMessage);
  return id2;
}
const convertGridRowsPropToState = ({
  prevState,
  rows,
  getRowId
}) => {
  let value;
  if (rows) {
    value = {
      idRowsLookup: {},
      ids: []
    };
    for (let i2 = 0; i2 < rows.length; i2 += 1) {
      const row = rows[i2];
      const id2 = getGridRowId(row, getRowId);
      value.idRowsLookup[id2] = row;
      value.ids.push(id2);
    }
  } else {
    value = prevState.value;
  }
  return {
    value,
    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates
  };
};
const getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp) => {
  const {
    value
  } = rowsCache.state;
  const rowCount = rowCountProp != null ? rowCountProp : 0;
  const groupingResponse = apiRef.current.unstable_groupRows(_extends$5({}, value, {
    previousTree
  }));
  const dataTopLevelRowCount = Object.values(groupingResponse.tree).filter((node) => node.parent == null).length;
  const totalRowCount = rowCount > groupingResponse.ids.length ? rowCount : groupingResponse.ids.length;
  const totalTopLevelRowCount = rowCount > dataTopLevelRowCount ? rowCount : dataTopLevelRowCount;
  return _extends$5({}, groupingResponse, {
    totalRowCount,
    totalTopLevelRowCount
  });
};
const rowsStateInitializer = (state, props, apiRef) => {
  const rowsCache = {
    state: convertGridRowsPropToState({
      rows: props.rows,
      getRowId: props.getRowId,
      prevState: {
        value: {
          idRowsLookup: {},
          ids: []
        },
        rowsBeforePartialUpdates: []
      }
    }),
    timeout: null,
    lastUpdateMs: Date.now()
  };
  return _extends$5({}, state, {
    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount),
    rowsCache
  });
};
const useGridRows = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridRows");
  const rowsCache = React$6.useRef(apiRef.current.state.rowsCache);
  const getRow = React$6.useCallback((id2) => {
    var _gridRowsLookupSelect;
    return (_gridRowsLookupSelect = gridRowsLookupSelector(apiRef)[id2]) != null ? _gridRowsLookupSelect : null;
  }, [apiRef]);
  const throttledRowsChange = React$6.useCallback((newState, throttle2) => {
    const run = () => {
      rowsCache.current.timeout = null;
      rowsCache.current.lastUpdateMs = Date.now();
      apiRef.current.setState((state) => _extends$5({}, state, {
        rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount)
      }));
      apiRef.current.publishEvent(GridEvents.rowsSet);
      apiRef.current.forceUpdate();
    };
    if (rowsCache.current.timeout) {
      clearTimeout(rowsCache.current.timeout);
    }
    rowsCache.current.state = newState;
    rowsCache.current.timeout = null;
    if (!throttle2) {
      run();
      return;
    }
    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);
    if (throttleRemainingTimeMs > 0) {
      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);
      return;
    }
    run();
  }, [props.throttleRowsMs, props.rowCount, apiRef]);
  const setRows = React$6.useCallback((rows) => {
    logger.debug(`Updating all rows, new length ${rows.length}`);
    throttledRowsChange(convertGridRowsPropToState({
      rows,
      prevState: rowsCache.current.state,
      getRowId: props.getRowId
    }), true);
  }, [logger, props.getRowId, throttledRowsChange]);
  const updateRows = React$6.useCallback((updates) => {
    if (props.signature === GridSignature.DataGrid && updates.length > 1) {
      throw new Error(["MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.", "You need to upgrade to the DataGridPro component to unlock this feature."].join("\n"));
    }
    const uniqUpdates = /* @__PURE__ */ new Map();
    updates.forEach((update) => {
      const id2 = getGridRowId(update, props.getRowId, "A row was provided without id when calling updateRows():");
      if (uniqUpdates.has(id2)) {
        uniqUpdates.set(id2, _extends$5({}, uniqUpdates.get(id2), update));
      } else {
        uniqUpdates.set(id2, update);
      }
    });
    const deletedRowIds = [];
    const newStateValue = {
      idRowsLookup: _extends$5({}, rowsCache.current.state.value.idRowsLookup),
      ids: [...rowsCache.current.state.value.ids]
    };
    uniqUpdates.forEach((partialRow, id2) => {
      if (partialRow._action === "delete") {
        delete newStateValue.idRowsLookup[id2];
        deletedRowIds.push(id2);
        return;
      }
      const oldRow = apiRef.current.getRow(id2);
      if (!oldRow) {
        newStateValue.idRowsLookup[id2] = partialRow;
        newStateValue.ids.push(id2);
        return;
      }
      newStateValue.idRowsLookup[id2] = _extends$5({}, apiRef.current.getRow(id2), partialRow);
    });
    if (deletedRowIds.length > 0) {
      newStateValue.ids = newStateValue.ids.filter((id2) => !deletedRowIds.includes(id2));
    }
    const state = _extends$5({}, rowsCache.current.state, {
      value: newStateValue
    });
    throttledRowsChange(state, true);
  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);
  const getRowModels = React$6.useCallback(() => {
    const allRows = gridRowIdsSelector(apiRef);
    const idRowsLookup = gridRowsLookupSelector(apiRef);
    return new Map(allRows.map((id2) => [id2, idRowsLookup[id2]]));
  }, [apiRef]);
  const getRowsCount = React$6.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);
  const getAllRowIds = React$6.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);
  const setRowChildrenExpansion = React$6.useCallback((id2, isExpanded) => {
    const currentNode = apiRef.current.getRowNode(id2);
    if (!currentNode) {
      throw new Error(`MUI: No row with id #${id2} found`);
    }
    const newNode = _extends$5({}, currentNode, {
      childrenExpanded: isExpanded
    });
    apiRef.current.setState((state) => {
      return _extends$5({}, state, {
        rows: _extends$5({}, state.rows, {
          tree: _extends$5({}, state.rows.tree, {
            [id2]: newNode
          })
        })
      });
    });
    apiRef.current.forceUpdate();
    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);
  }, [apiRef]);
  const getRowNode = React$6.useCallback((id2) => {
    var _gridRowTreeSelector$;
    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id2]) != null ? _gridRowTreeSelector$ : null;
  }, [apiRef]);
  React$6.useEffect(() => {
    return () => {
      if (rowsCache.current.timeout !== null) {
        clearTimeout(rowsCache.current.timeout);
      }
    };
  }, []);
  const isFirstRender = React$6.useRef(true);
  React$6.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {
      return;
    }
    logger.debug(`Updating all rows, new length ${props.rows.length}`);
    throttledRowsChange(convertGridRowsPropToState({
      rows: props.rows,
      getRowId: props.getRowId,
      prevState: rowsCache.current.state
    }), false);
  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);
  const handleGroupRows = React$6.useCallback(() => {
    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);
    let rows;
    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {
      rows = void 0;
    } else {
      rows = props.rows;
    }
    throttledRowsChange(convertGridRowsPropToState({
      rows,
      getRowId: props.getRowId,
      prevState: rowsCache.current.state
    }), false);
  }, [logger, throttledRowsChange, props.getRowId, props.rows]);
  useGridApiEventHandler(apiRef, GridEvents.rowGroupsPreProcessingChange, handleGroupRows);
  const rowApi = {
    getRow,
    getRowModels,
    getRowsCount,
    getAllRowIds,
    setRows,
    updateRows,
    setRowChildrenExpansion,
    getRowNode
  };
  useGridApiMethod(apiRef, rowApi);
};
function useGridParamsApi(apiRef) {
  const getColumnHeaderParams = React$6.useCallback((field) => ({
    field,
    colDef: apiRef.current.getColumn(field)
  }), [apiRef]);
  const getCellValueWithDeprecationWarning = React$6.useCallback((...args) => {
    return apiRef.current.getCellValue(...args);
  }, [apiRef]);
  const getRowParams = React$6.useCallback((id2) => {
    const row = apiRef.current.getRow(id2);
    if (!row) {
      throw new Error(`No row with id #${id2} found`);
    }
    const params = {
      id: id2,
      columns: apiRef.current.getAllColumns(),
      row,
      getValue: getCellValueWithDeprecationWarning
    };
    return params;
  }, [apiRef, getCellValueWithDeprecationWarning]);
  const getBaseCellParams = React$6.useCallback((id2, field) => {
    const row = apiRef.current.getRow(id2);
    const rowNode = apiRef.current.getRowNode(id2);
    if (!row || !rowNode) {
      throw new Error(`No row with id #${id2} found`);
    }
    const cellFocus = gridFocusCellSelector(apiRef);
    const cellTabIndex = gridTabIndexCellSelector(apiRef);
    const params = {
      id: id2,
      field,
      row,
      rowNode,
      value: row[field],
      colDef: apiRef.current.getColumn(field),
      cellMode: apiRef.current.getCellMode(id2, field),
      getValue: getCellValueWithDeprecationWarning,
      api: apiRef.current,
      hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id2,
      tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id2 ? 0 : -1
    };
    return params;
  }, [apiRef, getCellValueWithDeprecationWarning]);
  const getCellParams = React$6.useCallback((id2, field) => {
    const colDef = apiRef.current.getColumn(field);
    const value = apiRef.current.getCellValue(id2, field);
    const row = apiRef.current.getRow(id2);
    const rowNode = apiRef.current.getRowNode(id2);
    if (!row || !rowNode) {
      throw new Error(`No row with id #${id2} found`);
    }
    const cellFocus = gridFocusCellSelector(apiRef);
    const cellTabIndex = gridTabIndexCellSelector(apiRef);
    const params = {
      id: id2,
      field,
      row,
      rowNode,
      colDef,
      cellMode: apiRef.current.getCellMode(id2, field),
      getValue: getCellValueWithDeprecationWarning,
      hasFocus: cellFocus !== null && cellFocus.field === field && cellFocus.id === id2,
      tabIndex: cellTabIndex && cellTabIndex.field === field && cellTabIndex.id === id2 ? 0 : -1,
      value,
      formattedValue: value
    };
    if (colDef.valueFormatter) {
      params.formattedValue = colDef.valueFormatter({
        id: id2,
        field: params.field,
        value: params.value,
        api: apiRef.current
      });
    }
    params.isEditable = colDef && apiRef.current.isCellEditable(params);
    return params;
  }, [apiRef, getCellValueWithDeprecationWarning]);
  const getCellValue = React$6.useCallback((id2, field) => {
    const colDef = apiRef.current.getColumn(field);
    if (!colDef || !colDef.valueGetter) {
      const rowModel = apiRef.current.getRow(id2);
      if (!rowModel) {
        throw new Error(`No row with id #${id2} found`);
      }
      return rowModel[field];
    }
    return colDef.valueGetter(getBaseCellParams(id2, field));
  }, [apiRef, getBaseCellParams]);
  const getColumnHeaderElement = React$6.useCallback((field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridColumnHeaderElement(apiRef.current.rootElementRef.current, field);
  }, [apiRef]);
  const getRowElement = React$6.useCallback((id2) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridRowElement(apiRef.current.rootElementRef.current, id2);
  }, [apiRef]);
  const getCellElement = React$6.useCallback((id2, field) => {
    if (!apiRef.current.rootElementRef.current) {
      return null;
    }
    return getGridCellElement(apiRef.current.rootElementRef.current, {
      id: id2,
      field
    });
  }, [apiRef]);
  const paramsApi = {
    getCellValue,
    getCellParams,
    getCellElement,
    getRowParams,
    getRowElement,
    getColumnHeaderParams,
    getColumnHeaderElement
  };
  useGridApiMethod(apiRef, paramsApi);
}
const useGridSelection = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridSelection");
  const propSelectionModel = React$6.useMemo(() => {
    if (props.selectionModel == null) {
      return props.selectionModel;
    }
    if (Array.isArray(props.selectionModel)) {
      return props.selectionModel;
    }
    return [props.selectionModel];
  }, [props.selectionModel]);
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    selection: propSelectionModel != null ? propSelectionModel : []
  }));
  const lastRowToggled = React$6.useRef(null);
  apiRef.current.unstable_updateControlState({
    stateId: "selection",
    propModel: propSelectionModel,
    propOnChange: props.onSelectionModelChange,
    stateSelector: gridSelectionStateSelector,
    changeEvent: GridEvents.selectionChange
  });
  const {
    checkboxSelection,
    disableMultipleSelection,
    disableSelectionOnClick,
    isRowSelectable,
    pagination,
    paginationMode
  } = props;
  const canHaveMultipleSelection = !disableMultipleSelection || checkboxSelection;
  const expandRowRangeSelection = React$6.useCallback((id2) => {
    var _lastRowToggled$curre;
    let endId = id2;
    const startId = (_lastRowToggled$curre = lastRowToggled.current) != null ? _lastRowToggled$curre : id2;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (isSelected) {
      const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);
      const startIndex = visibleRowIds.findIndex((rowId) => rowId === startId);
      const endIndex = visibleRowIds.findIndex((rowId) => rowId === endId);
      if (startIndex > endIndex) {
        endId = visibleRowIds[endIndex + 1];
      } else {
        endId = visibleRowIds[endIndex - 1];
      }
    }
    lastRowToggled.current = id2;
    apiRef.current.selectRowRange({
      startId,
      endId
    }, !isSelected);
  }, [apiRef]);
  const setSelectionModel = React$6.useCallback((model) => {
    const currentModel = gridSelectionStateSelector(apiRef.current.state);
    if (currentModel !== model) {
      logger.debug(`Setting selection model`);
      apiRef.current.setState((state) => _extends$5({}, state, {
        selection: model
      }));
      apiRef.current.forceUpdate();
    }
  }, [apiRef, logger]);
  const isRowSelected = React$6.useCallback((id2) => gridSelectionStateSelector(apiRef.current.state).includes(id2), [apiRef]);
  const getSelectedRows = React$6.useCallback(() => selectedGridRowsSelector(apiRef), [apiRef]);
  const selectRow = React$6.useCallback((id2, isSelected = true, resetSelection = false) => {
    if (isRowSelectable && !isRowSelectable(apiRef.current.getRowParams(id2))) {
      return;
    }
    lastRowToggled.current = id2;
    if (resetSelection) {
      logger.debug(`Setting selection for row ${id2}`);
      apiRef.current.setSelectionModel(isSelected ? [id2] : []);
    } else {
      logger.debug(`Toggling selection for row ${id2}`);
      const selection = gridSelectionStateSelector(apiRef.current.state);
      const newSelection = selection.filter((el) => el !== id2);
      if (isSelected) {
        newSelection.push(id2);
      }
      const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
      if (isSelectionValid) {
        apiRef.current.setSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, logger, canHaveMultipleSelection]);
  const selectRows = React$6.useCallback((ids, isSelected = true, resetSelection = false) => {
    logger.debug(`Setting selection for several rows`);
    const selectableIds = isRowSelectable ? ids.filter((id2) => isRowSelectable(apiRef.current.getRowParams(id2))) : ids;
    let newSelection;
    if (resetSelection) {
      newSelection = isSelected ? selectableIds : [];
    } else {
      const selectionLookup = _extends$5({}, selectedIdsLookupSelector(apiRef));
      selectableIds.forEach((id2) => {
        if (isSelected) {
          selectionLookup[id2] = id2;
        } else {
          delete selectionLookup[id2];
        }
      });
      newSelection = Object.values(selectionLookup);
    }
    const isSelectionValid = newSelection.length < 2 || canHaveMultipleSelection;
    if (isSelectionValid) {
      apiRef.current.setSelectionModel(newSelection);
    }
  }, [apiRef, isRowSelectable, logger, canHaveMultipleSelection]);
  const selectRowRange = React$6.useCallback(({
    startId,
    endId
  }, isSelected = true, resetSelection) => {
    if (!apiRef.current.getRow(startId) || !apiRef.current.getRow(endId)) {
      return;
    }
    logger.debug(`Expanding selection from row ${startId} to row ${endId}`);
    const visibleRowIds = gridVisibleSortedRowIdsSelector(apiRef);
    const startIndex = visibleRowIds.indexOf(startId);
    const endIndex = visibleRowIds.indexOf(endId);
    const [start, end] = startIndex > endIndex ? [endIndex, startIndex] : [startIndex, endIndex];
    const rowsBetweenStartAndEnd = visibleRowIds.slice(start, end + 1);
    apiRef.current.selectRows(rowsBetweenStartAndEnd, isSelected, resetSelection);
  }, [apiRef, logger]);
  const selectionApi = {
    selectRow,
    selectRows,
    selectRowRange,
    setSelectionModel,
    getSelectedRows,
    isRowSelected
  };
  useGridApiMethod(apiRef, selectionApi);
  const removeOutdatedSelection = React$6.useCallback(() => {
    const currentSelection = gridSelectionStateSelector(apiRef.current.state);
    const rowsLookup = gridRowsLookupSelector(apiRef);
    const selectionLookup = _extends$5({}, selectedIdsLookupSelector(apiRef));
    let hasChanged = false;
    currentSelection.forEach((id2) => {
      if (!rowsLookup[id2]) {
        delete selectionLookup[id2];
        hasChanged = true;
      }
    });
    if (hasChanged) {
      apiRef.current.setSelectionModel(Object.values(selectionLookup));
    }
  }, [apiRef]);
  const handleSingleRowSelection = React$6.useCallback((id2, event) => {
    const hasCtrlKey = event.metaKey || event.ctrlKey;
    const isMultipleSelectionDisabled = !checkboxSelection && !hasCtrlKey && !isKeyboardEvent(event);
    const resetSelection = !canHaveMultipleSelection || isMultipleSelectionDisabled;
    const isSelected = apiRef.current.isRowSelected(id2);
    if (resetSelection) {
      apiRef.current.selectRow(id2, !isMultipleSelectionDisabled ? !isSelected : true, true);
    } else {
      apiRef.current.selectRow(id2, !isSelected, false);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection]);
  const handleCellClick = React$6.useCallback((params, event) => {
    if (disableSelectionOnClick) {
      return;
    }
    if (params.field === GRID_CHECKBOX_SELECTION_COL_DEF.field) {
      return;
    }
    if (params.field === "__detail_panel_toggle__") {
      return;
    }
    if (params.field) {
      const column = apiRef.current.getColumn(params.field);
      if (column.type === GRID_ACTIONS_COLUMN_TYPE) {
        return;
      }
    }
    if (event.shiftKey && (canHaveMultipleSelection || checkboxSelection)) {
      expandRowRangeSelection(params.id);
    } else {
      handleSingleRowSelection(params.id, event);
    }
  }, [disableSelectionOnClick, canHaveMultipleSelection, checkboxSelection, apiRef, expandRowRangeSelection, handleSingleRowSelection]);
  const preventSelectionOnShift = React$6.useCallback((params, event) => {
    if (canHaveMultipleSelection && event.shiftKey) {
      var _window$getSelection;
      (_window$getSelection = window.getSelection()) == null ? void 0 : _window$getSelection.removeAllRanges();
    }
  }, [canHaveMultipleSelection]);
  const handleRowSelectionCheckboxChange = React$6.useCallback((params, event) => {
    if (event.nativeEvent.shiftKey) {
      expandRowRangeSelection(params.id);
    } else {
      apiRef.current.selectRow(params.id, params.value);
    }
  }, [apiRef, expandRowRangeSelection]);
  const handleHeaderSelectionCheckboxChange = React$6.useCallback((params) => {
    const shouldLimitSelectionToCurrentPage = props.checkboxSelectionVisibleOnly && props.pagination;
    const rowsToBeSelected = shouldLimitSelectionToCurrentPage ? gridPaginatedVisibleSortedGridRowIdsSelector(apiRef) : gridVisibleSortedRowIdsSelector(apiRef);
    apiRef.current.selectRows(rowsToBeSelected, params.value);
  }, [apiRef, props.checkboxSelectionVisibleOnly, props.pagination]);
  const handleCellKeyDown = React$6.useCallback((params, event) => {
    if (!isGridCellRoot(event.target)) {
      return;
    }
    const cellParams = apiRef.current.getCellParams(params.id, params.field);
    const isEditMode = cellParams.cellMode === GridCellModes.Edit;
    if (isEditMode) {
      return;
    }
    if (event.key === " " && event.shiftKey) {
      event.preventDefault();
      handleSingleRowSelection(cellParams.id, event);
      return;
    }
    if (event.key.toLowerCase() === "a" && (event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      selectRows(apiRef.current.getAllRowIds(), true);
    }
  }, [apiRef, handleSingleRowSelection, selectRows]);
  useGridApiEventHandler(apiRef, GridEvents.visibleRowsSet, removeOutdatedSelection);
  useGridApiEventHandler(apiRef, GridEvents.cellClick, handleCellClick);
  useGridApiEventHandler(apiRef, GridEvents.rowSelectionCheckboxChange, handleRowSelectionCheckboxChange);
  useGridApiEventHandler(apiRef, GridEvents.headerSelectionCheckboxChange, handleHeaderSelectionCheckboxChange);
  useGridApiEventHandler(apiRef, GridEvents.cellMouseDown, preventSelectionOnShift);
  useGridApiEventHandler(apiRef, GridEvents.cellKeyDown, handleCellKeyDown);
  React$6.useEffect(() => {
    if (propSelectionModel !== void 0) {
      apiRef.current.setSelectionModel(propSelectionModel);
    }
  }, [apiRef, propSelectionModel]);
  const isStateControlled = propSelectionModel != null;
  React$6.useEffect(() => {
    if (isStateControlled) {
      return;
    }
    const currentSelection = gridSelectionStateSelector(apiRef.current.state);
    if (isRowSelectable) {
      const newSelection = currentSelection.filter((id2) => isRowSelectable(apiRef.current.getRowParams(id2)));
      if (newSelection.length < currentSelection.length) {
        apiRef.current.setSelectionModel(newSelection);
      }
    }
  }, [apiRef, isRowSelectable, isStateControlled]);
  React$6.useEffect(() => {
    const currentSelection = gridSelectionStateSelector(apiRef.current.state);
    if (!canHaveMultipleSelection && currentSelection.length > 1) {
      const {
        rows: currentPageRows
      } = getCurrentPageRows(apiRef, {
        pagination,
        paginationMode
      });
      const currentPageRowsLookup = currentPageRows.reduce((acc, {
        id: id2
      }) => {
        acc[id2] = true;
        return acc;
      }, {});
      const firstSelectableRow = currentSelection.find((id2) => {
        let isSelectable = true;
        if (isRowSelectable) {
          isSelectable = isRowSelectable(apiRef.current.getRowParams(id2));
        }
        return isSelectable && currentPageRowsLookup[id2];
      });
      apiRef.current.setSelectionModel(firstSelectableRow !== void 0 ? [firstSelectableRow] : []);
    }
  }, [apiRef, canHaveMultipleSelection, checkboxSelection, disableMultipleSelection, isRowSelectable, pagination, paginationMode]);
};
const GRID_DEFAULT_LOCALE_TEXT = {
  noRowsLabel: "No rows",
  noResultsOverlayLabel: "No results found.",
  errorOverlayDefaultLabel: "An error occurred.",
  toolbarDensity: "Density",
  toolbarDensityLabel: "Density",
  toolbarDensityCompact: "Compact",
  toolbarDensityStandard: "Standard",
  toolbarDensityComfortable: "Comfortable",
  toolbarColumns: "Columns",
  toolbarColumnsLabel: "Select columns",
  toolbarFilters: "Filters",
  toolbarFiltersLabel: "Show filters",
  toolbarFiltersTooltipHide: "Hide filters",
  toolbarFiltersTooltipShow: "Show filters",
  toolbarFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  toolbarExport: "Export",
  toolbarExportLabel: "Export",
  toolbarExportCSV: "Download as CSV",
  toolbarExportPrint: "Print",
  columnsPanelTextFieldLabel: "Find column",
  columnsPanelTextFieldPlaceholder: "Column title",
  columnsPanelDragIconLabel: "Reorder column",
  columnsPanelShowAllButton: "Show all",
  columnsPanelHideAllButton: "Hide all",
  filterPanelAddFilter: "Add filter",
  filterPanelDeleteIconLabel: "Delete",
  filterPanelLinkOperator: "Logic operator",
  filterPanelOperators: "Operator",
  filterPanelOperatorAnd: "And",
  filterPanelOperatorOr: "Or",
  filterPanelColumns: "Columns",
  filterPanelInputLabel: "Value",
  filterPanelInputPlaceholder: "Filter value",
  filterOperatorContains: "contains",
  filterOperatorEquals: "equals",
  filterOperatorStartsWith: "starts with",
  filterOperatorEndsWith: "ends with",
  filterOperatorIs: "is",
  filterOperatorNot: "is not",
  filterOperatorAfter: "is after",
  filterOperatorOnOrAfter: "is on or after",
  filterOperatorBefore: "is before",
  filterOperatorOnOrBefore: "is on or before",
  filterOperatorIsEmpty: "is empty",
  filterOperatorIsNotEmpty: "is not empty",
  filterOperatorIsAnyOf: "is any of",
  filterValueAny: "any",
  filterValueTrue: "true",
  filterValueFalse: "false",
  columnMenuLabel: "Menu",
  columnMenuShowColumns: "Show columns",
  columnMenuFilter: "Filter",
  columnMenuHideColumn: "Hide",
  columnMenuUnsort: "Unsort",
  columnMenuSortAsc: "Sort by ASC",
  columnMenuSortDesc: "Sort by DESC",
  columnHeaderFiltersTooltipActive: (count) => count !== 1 ? `${count} active filters` : `${count} active filter`,
  columnHeaderFiltersLabel: "Show filters",
  columnHeaderSortIconLabel: "Sort",
  footerRowSelected: (count) => count !== 1 ? `${count.toLocaleString()} rows selected` : `${count.toLocaleString()} row selected`,
  footerTotalRows: "Total Rows:",
  footerTotalVisibleRows: (visibleCount, totalCount) => `${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()}`,
  checkboxSelectionHeaderName: "Checkbox selection",
  checkboxSelectionSelectAllRows: "Select all rows",
  checkboxSelectionUnselectAllRows: "Unselect all rows",
  checkboxSelectionSelectRow: "Select row",
  checkboxSelectionUnselectRow: "Unselect row",
  booleanCellTrueLabel: "yes",
  booleanCellFalseLabel: "no",
  actionsCellMore: "more",
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  unpin: "Unpin",
  treeDataGroupingHeaderName: "Group",
  treeDataExpand: "see children",
  treeDataCollapse: "hide children",
  groupingColumnHeaderName: "Group",
  groupColumn: (name) => `Group by ${name}`,
  unGroupColumn: (name) => `Stop grouping by ${name}`,
  expandDetailPanel: "Expand",
  collapseDetailPanel: "Collapse",
  MuiTablePagination: {}
};
const _excluded$u = ["sortingOrder"];
const GridColumnUnsortedIcon = /* @__PURE__ */ React$6.memo(function GridColumnHeaderSortIcon2(props) {
  const {
    sortingOrder
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$u);
  const rootProps = useGridRootProps();
  const [nextSortDirection] = sortingOrder;
  const Icon = nextSortDirection === "asc" ? rootProps.components.ColumnSortedAscendingIcon : rootProps.components.ColumnSortedDescendingIcon;
  return Icon ? /* @__PURE__ */ jsx(Icon, _extends$5({}, other)) : null;
});
const _excluded$t = ["message", "hasError", "errorInfo"];
const ErrorOverlay = /* @__PURE__ */ React$6.forwardRef(function ErrorOverlay2(props, ref) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$t);
  const apiRef = useGridApiContext();
  const defaultLabel = apiRef.current.getLocaleText("errorOverlayDefaultLabel");
  return /* @__PURE__ */ jsx(GridOverlay, _extends$5({
    ref
  }, other, {
    children: message || defaultLabel
  }));
});
const GridNoResultsOverlay = /* @__PURE__ */ React$6.forwardRef(function GridNoResultsOverlay2(props, ref) {
  const apiRef = useGridApiContext();
  const noResultsOverlayLabel = apiRef.current.getLocaleText("noResultsOverlayLabel");
  return /* @__PURE__ */ jsx(GridOverlay, _extends$5({
    ref
  }, props, {
    children: noResultsOverlayLabel
  }));
});
const DEFAULT_GRID_ICON_SLOTS_COMPONENTS = {
  BooleanCellTrueIcon: GridCheckIcon,
  BooleanCellFalseIcon: GridCloseIcon,
  ColumnMenuIcon: GridTripleDotsVerticalIcon,
  OpenFilterButtonIcon: GridFilterListIcon,
  FilterPanelDeleteIcon: GridCloseIcon,
  ColumnFilteredIcon: GridFilterAltIcon,
  ColumnSelectorIcon: GridColumnIcon,
  ColumnUnsortedIcon: GridColumnUnsortedIcon,
  ColumnSortedAscendingIcon: GridArrowUpwardIcon,
  ColumnSortedDescendingIcon: GridArrowDownwardIcon,
  ColumnResizeIcon: GridSeparatorIcon,
  DensityCompactIcon: GridViewHeadlineIcon,
  DensityStandardIcon: GridTableRowsIcon,
  DensityComfortableIcon: GridViewStreamIcon,
  ExportIcon: GridSaveAltIcon,
  MoreActionsIcon: GridMoreVertIcon,
  TreeDataCollapseIcon: GridExpandMoreIcon,
  TreeDataExpandIcon: GridKeyboardArrowRight,
  GroupingCriteriaCollapseIcon: GridExpandMoreIcon,
  GroupingCriteriaExpandIcon: GridKeyboardArrowRight,
  DetailPanelExpandIcon: GridAddIcon,
  DetailPanelCollapseIcon: GridRemoveIcon
};
const DATA_GRID_DEFAULT_SLOTS_COMPONENTS = _extends$5({}, DEFAULT_GRID_ICON_SLOTS_COMPONENTS, {
  BaseCheckbox: Checkbox,
  BaseTextField: TextField$1,
  BaseFormControl: FormControl,
  BaseSelect: MUISelect,
  BaseSwitch: MUISwitch,
  BaseButton: Button,
  BaseTooltip: MUITooltip,
  BasePopper: Popper,
  Cell: GridCell,
  ColumnMenu: GridColumnMenu,
  ErrorOverlay,
  Footer: GridFooter,
  Header: GridHeader,
  Toolbar: null,
  PreferencesPanel: GridPreferencesPanel,
  LoadingOverlay: GridLoadingOverlay,
  NoResultsOverlay: GridNoResultsOverlay,
  NoRowsOverlay: GridNoRowsOverlay,
  Pagination: GridPagination,
  FilterPanel: GridFilterPanel,
  ColumnsPanel: GridColumnsPanel,
  Panel: GridPanel,
  Row: GridRow
});
const useUtilityClasses$c = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  return React$6.useMemo(() => {
    const slots = {
      cellCheckbox: ["cellCheckbox"],
      columnHeaderCheckbox: ["columnHeaderCheckbox"]
    };
    return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
  }, [classes2]);
};
const useGridSelectionPreProcessors = (apiRef, props) => {
  const ownerState = {
    classes: props.classes
  };
  const classes2 = useUtilityClasses$c(ownerState);
  const updateSelectionColumn = React$6.useCallback((columnsState) => {
    const selectionColumn = _extends$5({}, GRID_CHECKBOX_SELECTION_COL_DEF, {
      cellClassName: classes2.cellCheckbox,
      headerClassName: classes2.columnHeaderCheckbox,
      headerName: apiRef.current.getLocaleText("checkboxSelectionHeaderName")
    });
    const shouldHaveSelectionColumn = props.checkboxSelection;
    const haveSelectionColumn = columnsState.lookup[selectionColumn.field] != null;
    if (shouldHaveSelectionColumn && !haveSelectionColumn) {
      columnsState.lookup[selectionColumn.field] = selectionColumn;
      columnsState.all = [selectionColumn.field, ...columnsState.all];
    } else if (!shouldHaveSelectionColumn && haveSelectionColumn) {
      delete columnsState.lookup[selectionColumn.field];
      columnsState.all = columnsState.all.filter((field) => field !== selectionColumn.field);
    }
    return columnsState;
  }, [apiRef, classes2, props.checkboxSelection]);
  useGridRegisterPreProcessor(apiRef, "hydrateColumns", updateSelectionColumn);
};
const useGridRegisterSortingMethod = (apiRef, groupingName, filteringMethod) => {
  const updateRegistration = React$6.useCallback((sortingMethodCollection) => {
    sortingMethodCollection[groupingName] = filteringMethod;
    return sortingMethodCollection;
  }, [groupingName, filteringMethod]);
  useGridRegisterPreProcessor(apiRef, "sortingMethod", updateRegistration);
};
const sortingStateInitializer = (state, props) => {
  var _ref, _props$sortModel, _props$initialState, _props$initialState$s;
  const sortModel = (_ref = (_props$sortModel = props.sortModel) != null ? _props$sortModel : (_props$initialState = props.initialState) == null ? void 0 : (_props$initialState$s = _props$initialState.sorting) == null ? void 0 : _props$initialState$s.sortModel) != null ? _ref : [];
  return _extends$5({}, state, {
    sorting: {
      sortModel: sanitizeSortModel(sortModel, props.disableMultipleColumnsSorting),
      sortedRows: []
    }
  });
};
const useGridSorting = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridSorting");
  const sortingMethodCollectionRef = React$6.useRef({});
  const lastSortingMethodApplied = React$6.useRef(null);
  apiRef.current.unstable_updateControlState({
    stateId: "sortModel",
    propModel: props.sortModel,
    propOnChange: props.onSortModelChange,
    stateSelector: gridSortModelSelector,
    changeEvent: GridEvents.sortModelChange
  });
  const upsertSortModel = React$6.useCallback((field, sortItem) => {
    const sortModel = gridSortModelSelector(apiRef);
    const existingIdx = sortModel.findIndex((c2) => c2.field === field);
    let newSortModel = [...sortModel];
    if (existingIdx > -1) {
      if (!sortItem) {
        newSortModel.splice(existingIdx, 1);
      } else {
        newSortModel.splice(existingIdx, 1, sortItem);
      }
    } else {
      newSortModel = [...sortModel, sortItem];
    }
    return newSortModel;
  }, [apiRef]);
  const createSortItem = React$6.useCallback((col, directionOverride) => {
    var _col$sortingOrder2;
    const sortModel = gridSortModelSelector(apiRef);
    const existing = sortModel.find((c2) => c2.field === col.field);
    if (existing) {
      var _col$sortingOrder;
      const nextSort = directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder = col.sortingOrder) != null ? _col$sortingOrder : props.sortingOrder, existing.sort) : directionOverride;
      return nextSort == null ? void 0 : _extends$5({}, existing, {
        sort: nextSort
      });
    }
    return {
      field: col.field,
      sort: directionOverride === void 0 ? getNextGridSortDirection((_col$sortingOrder2 = col.sortingOrder) != null ? _col$sortingOrder2 : props.sortingOrder) : directionOverride
    };
  }, [apiRef, props.sortingOrder]);
  const applySorting = React$6.useCallback(() => {
    if (props.sortingMode === GridFeatureModeConstant.server) {
      logger.debug("Skipping sorting rows as sortingMode = server");
      apiRef.current.setState((state) => _extends$5({}, state, {
        sorting: _extends$5({}, state.sorting, {
          sortedRows: gridRowIdsSelector(state, apiRef.current.instanceId)
        })
      }));
      return;
    }
    apiRef.current.setState((state) => {
      const rowGroupingName = gridRowGroupingNameSelector(state, apiRef.current.instanceId);
      const sortingMethod = sortingMethodCollectionRef.current[rowGroupingName];
      if (!sortingMethod) {
        throw new Error("MUI: Invalid sorting method.");
      }
      const sortModel = gridSortModelSelector(state, apiRef.current.instanceId);
      const sortRowList = buildAggregatedSortingApplier(sortModel, apiRef);
      const sortedRows = sortingMethod({
        sortRowList
      });
      return _extends$5({}, state, {
        sorting: _extends$5({}, state.sorting, {
          sortedRows
        })
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, logger, props.sortingMode]);
  const setSortModel = React$6.useCallback((model) => {
    const currentModel = gridSortModelSelector(apiRef);
    if (currentModel !== model) {
      logger.debug(`Setting sort model`);
      apiRef.current.setState(mergeStateWithSortModel(model, props.disableMultipleColumnsSorting));
      apiRef.current.forceUpdate();
      apiRef.current.applySorting();
    }
  }, [apiRef, logger, props.disableMultipleColumnsSorting]);
  const sortColumn = React$6.useCallback((column, direction, allowMultipleSorting) => {
    if (!column.sortable) {
      return;
    }
    const sortItem = createSortItem(column, direction);
    let sortModel;
    if (!allowMultipleSorting || props.disableMultipleColumnsSorting) {
      sortModel = !sortItem ? [] : [sortItem];
    } else {
      sortModel = upsertSortModel(column.field, sortItem);
    }
    apiRef.current.setSortModel(sortModel);
  }, [apiRef, upsertSortModel, createSortItem, props.disableMultipleColumnsSorting]);
  const getSortModel = React$6.useCallback(() => gridSortModelSelector(apiRef), [apiRef]);
  const getSortedRows = React$6.useCallback(() => {
    const sortedRows = gridSortedRowEntriesSelector(apiRef);
    return sortedRows.map((row) => row.model);
  }, [apiRef]);
  const getSortedRowIds = React$6.useCallback(() => gridSortedRowIdsSelector(apiRef), [apiRef]);
  const getRowIndex = React$6.useCallback((id2) => apiRef.current.getSortedRowIds().indexOf(id2), [apiRef]);
  const getRowIdFromRowIndex = React$6.useCallback((index) => apiRef.current.getSortedRowIds()[index], [apiRef]);
  const sortApi = {
    getSortModel,
    getSortedRows,
    getSortedRowIds,
    getRowIndex,
    getRowIdFromRowIndex,
    setSortModel,
    sortColumn,
    applySorting
  };
  useGridApiMethod(apiRef, sortApi);
  const stateExportPreProcessing = React$6.useCallback((prevState) => {
    const sortModelToExport = gridSortModelSelector(apiRef);
    if (sortModelToExport.length === 0) {
      return prevState;
    }
    return _extends$5({}, prevState, {
      sorting: {
        sortModel: sortModelToExport
      }
    });
  }, [apiRef]);
  const stateRestorePreProcessing = React$6.useCallback((params, context) => {
    var _context$stateToResto;
    const sortModel = (_context$stateToResto = context.stateToRestore.sorting) == null ? void 0 : _context$stateToResto.sortModel;
    if (sortModel == null) {
      return params;
    }
    apiRef.current.setState(mergeStateWithSortModel(sortModel, props.disableMultipleColumnsSorting));
    return _extends$5({}, params, {
      callbacks: [...params.callbacks, apiRef.current.applySorting]
    });
  }, [apiRef, props.disableMultipleColumnsSorting]);
  const flatSortingMethod = React$6.useCallback((params) => {
    if (!params.sortRowList) {
      return gridRowIdsSelector(apiRef);
    }
    const rowTree = gridRowTreeSelector(apiRef);
    return params.sortRowList(Object.values(rowTree));
  }, [apiRef]);
  useGridRegisterPreProcessor(apiRef, "exportState", stateExportPreProcessing);
  useGridRegisterPreProcessor(apiRef, "restoreState", stateRestorePreProcessing);
  useGridRegisterSortingMethod(apiRef, "none", flatSortingMethod);
  const handleColumnHeaderClick = React$6.useCallback(({
    colDef
  }, event) => {
    const allowMultipleSorting = event.shiftKey || event.metaKey || event.ctrlKey;
    sortColumn(colDef, void 0, allowMultipleSorting);
  }, [sortColumn]);
  const handleColumnHeaderKeyDown = React$6.useCallback(({
    colDef
  }, event) => {
    if (isEnterKey(event.key) && !event.ctrlKey && !event.metaKey) {
      sortColumn(colDef, void 0, event.shiftKey);
    }
  }, [sortColumn]);
  const handleColumnsChange = React$6.useCallback(() => {
    const sortModel = gridSortModelSelector(apiRef);
    const latestColumns = gridColumnLookupSelector(apiRef);
    if (sortModel.length > 0) {
      const newModel = sortModel.filter((sortItem) => latestColumns[sortItem.field]);
      if (newModel.length < sortModel.length) {
        apiRef.current.setSortModel(newModel);
      }
    }
  }, [apiRef]);
  const handlePreProcessorRegister = React$6.useCallback((name) => {
    if (name !== "sortingMethod") {
      return;
    }
    sortingMethodCollectionRef.current = apiRef.current.unstable_applyPreProcessors("sortingMethod", {});
    const rowGroupingName = gridRowGroupingNameSelector(apiRef);
    if (lastSortingMethodApplied.current !== sortingMethodCollectionRef.current[rowGroupingName]) {
      apiRef.current.applySorting();
    }
  }, [apiRef]);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderClick, handleColumnHeaderClick);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderKeyDown, handleColumnHeaderKeyDown);
  useGridApiEventHandler(apiRef, GridEvents.rowsSet, apiRef.current.applySorting);
  useGridApiEventHandler(apiRef, GridEvents.columnsChange, handleColumnsChange);
  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);
  useFirstRender(() => {
    sortingMethodCollectionRef.current = apiRef.current.unstable_applyPreProcessors("sortingMethod", {});
    apiRef.current.applySorting();
  });
  React$6.useEffect(() => {
    if (props.sortModel !== void 0) {
      apiRef.current.setSortModel(props.sortModel);
    }
  }, [apiRef, props.sortModel]);
};
function scrollIntoView(dimensions) {
  const {
    clientHeight,
    scrollTop,
    offsetHeight,
    offsetTop
  } = dimensions;
  const elementBottom = offsetTop + offsetHeight;
  if (elementBottom - clientHeight > scrollTop) {
    return elementBottom - clientHeight;
  }
  if (offsetTop < scrollTop) {
    return offsetTop;
  }
  return void 0;
}
const useGridScroll = (apiRef, props) => {
  const logger = useGridLogger(apiRef, "useGridScroll");
  const colRef = apiRef.current.columnHeadersElementRef;
  const windowRef = apiRef.current.windowRef;
  const scrollToIndexes = React$6.useCallback((params) => {
    const totalRowCount = gridRowCountSelector(apiRef);
    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);
    if (totalRowCount === 0 || visibleColumns.length === 0) {
      return false;
    }
    logger.debug(`Scrolling to cell at row ${params.rowIndex}, col: ${params.colIndex} `);
    let scrollCoordinates = {};
    if (params.colIndex != null) {
      const columnPositions = gridColumnPositionsSelector(apiRef);
      scrollCoordinates.left = scrollIntoView({
        clientHeight: windowRef.current.clientWidth,
        scrollTop: windowRef.current.scrollLeft,
        offsetHeight: visibleColumns[params.colIndex].computedWidth,
        offsetTop: columnPositions[params.colIndex]
      });
    }
    if (params.rowIndex != null) {
      const rowsMeta = gridRowsMetaSelector(apiRef.current.state);
      const page = gridPageSelector(apiRef);
      const pageSize = gridPageSizeSelector(apiRef);
      const elementIndex = !props.pagination ? params.rowIndex : params.rowIndex - page * pageSize;
      const targetOffsetHeight = rowsMeta.positions[elementIndex + 1] ? rowsMeta.positions[elementIndex + 1] - rowsMeta.positions[elementIndex] : rowsMeta.currentPageTotalHeight - rowsMeta.positions[elementIndex];
      scrollCoordinates.top = scrollIntoView({
        clientHeight: windowRef.current.clientHeight,
        scrollTop: windowRef.current.scrollTop,
        offsetHeight: targetOffsetHeight,
        offsetTop: rowsMeta.positions[elementIndex]
      });
    }
    scrollCoordinates = apiRef.current.unstable_applyPreProcessors("scrollToIndexes", scrollCoordinates, params);
    if (typeof scrollCoordinates.left !== void 0 || typeof scrollCoordinates.top !== void 0) {
      apiRef.current.scroll(scrollCoordinates);
      return true;
    }
    return false;
  }, [logger, apiRef, windowRef, props.pagination]);
  const scroll = React$6.useCallback((params) => {
    if (windowRef.current && params.left != null && colRef.current) {
      colRef.current.scrollLeft = params.left;
      windowRef.current.scrollLeft = params.left;
      logger.debug(`Scrolling left: ${params.left}`);
    }
    if (windowRef.current && params.top != null) {
      windowRef.current.scrollTop = params.top;
      logger.debug(`Scrolling top: ${params.top}`);
    }
    logger.debug(`Scrolling, updating container, and viewport`);
  }, [windowRef, colRef, logger]);
  const getScrollPosition = React$6.useCallback(() => {
    if (!(windowRef != null && windowRef.current)) {
      return {
        top: 0,
        left: 0
      };
    }
    return {
      top: windowRef.current.scrollTop,
      left: windowRef.current.scrollLeft
    };
  }, [windowRef]);
  const scrollApi = {
    scroll,
    scrollToIndexes,
    getScrollPosition
  };
  useGridApiMethod(apiRef, scrollApi);
  const preventScroll = React$6.useCallback((event) => {
    event.target.scrollLeft = 0;
    event.target.scrollTop = 0;
  }, []);
  useGridNativeEventListener(apiRef, () => {
    var _apiRef$current, _apiRef$current$rende, _apiRef$current$rende2;
    return (_apiRef$current = apiRef.current) == null ? void 0 : (_apiRef$current$rende = _apiRef$current.renderingZoneRef) == null ? void 0 : (_apiRef$current$rende2 = _apiRef$current$rende.current) == null ? void 0 : _apiRef$current$rende2.parentElement;
  }, "scroll", preventScroll);
};
function useGridEvents(apiRef, props) {
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderClick, props.onColumnHeaderClick);
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderDoubleClick, props.onColumnHeaderDoubleClick);
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderOver, props.onColumnHeaderOver);
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderOut, props.onColumnHeaderOut);
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderEnter, props.onColumnHeaderEnter);
  useGridApiOptionHandler(apiRef, GridEvents.columnHeaderLeave, props.onColumnHeaderLeave);
  useGridApiOptionHandler(apiRef, GridEvents.columnOrderChange, props.onColumnOrderChange);
  useGridApiOptionHandler(apiRef, GridEvents.cellClick, props.onCellClick);
  useGridApiOptionHandler(apiRef, GridEvents.cellDoubleClick, props.onCellDoubleClick);
  useGridApiOptionHandler(apiRef, GridEvents.cellKeyDown, props.onCellKeyDown);
  useGridApiOptionHandler(apiRef, GridEvents.cellFocusOut, props.onCellFocusOut);
  useGridApiOptionHandler(apiRef, GridEvents.rowDoubleClick, props.onRowDoubleClick);
  useGridApiOptionHandler(apiRef, GridEvents.rowClick, props.onRowClick);
  useGridApiOptionHandler(apiRef, GridEvents.componentError, props.onError);
  useGridApiOptionHandler(apiRef, GridEvents.stateChange, props.onStateChange);
}
const hasScroll = ({
  content,
  container,
  scrollBarSize
}) => {
  const hasScrollXIfNoYScrollBar = content.width > container.width;
  const hasScrollYIfNoXScrollBar = content.height > container.height;
  let hasScrollX = false;
  let hasScrollY = false;
  if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {
    hasScrollX = hasScrollXIfNoYScrollBar;
    hasScrollY = content.height + (hasScrollX ? scrollBarSize : 0) > container.height;
    if (hasScrollY) {
      hasScrollX = content.width + scrollBarSize > container.width;
    }
  }
  return {
    hasScrollX,
    hasScrollY
  };
};
function useGridDimensions(apiRef, props) {
  const logger = useGridLogger(apiRef, "useResizeContainer");
  const warningShown = React$6.useRef(false);
  const rootDimensionsRef = React$6.useRef(null);
  const fullDimensionsRef = React$6.useRef(null);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);
  const updateGridDimensionsRef = React$6.useCallback(() => {
    var _apiRef$current$rootE;
    const rootElement = (_apiRef$current$rootE = apiRef.current.rootElementRef) == null ? void 0 : _apiRef$current$rootE.current;
    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);
    if (!rootDimensionsRef.current) {
      return;
    }
    let scrollBarSize;
    if (props.scrollbarSize != null) {
      scrollBarSize = props.scrollbarSize;
    } else if (!columnsTotalWidth || !rootElement) {
      scrollBarSize = 0;
    } else {
      const doc = ownerDocument(rootElement);
      const scrollDiv = doc.createElement("div");
      scrollDiv.style.width = "99px";
      scrollDiv.style.height = "99px";
      scrollDiv.style.position = "absolute";
      scrollDiv.style.overflow = "scroll";
      scrollDiv.className = "scrollDiv";
      rootElement.appendChild(scrollDiv);
      scrollBarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      rootElement.removeChild(scrollDiv);
    }
    const viewportOuterSize = {
      width: rootDimensionsRef.current.width,
      height: props.autoHeight ? rowsMeta.currentPageTotalHeight : rootDimensionsRef.current.height - headerHeight
    };
    const {
      hasScrollX,
      hasScrollY
    } = hasScroll({
      content: {
        width: Math.round(columnsTotalWidth),
        height: rowsMeta.currentPageTotalHeight
      },
      container: viewportOuterSize,
      scrollBarSize
    });
    const viewportInnerSize = {
      width: viewportOuterSize.width - (hasScrollY ? scrollBarSize : 0),
      height: viewportOuterSize.height - (hasScrollX ? scrollBarSize : 0)
    };
    const newFullDimensions = {
      viewportOuterSize,
      viewportInnerSize,
      hasScrollX,
      hasScrollY
    };
    const prevDimensions = fullDimensionsRef.current;
    fullDimensionsRef.current = newFullDimensions;
    if (newFullDimensions.viewportInnerSize.width !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.width) || newFullDimensions.viewportInnerSize.height !== (prevDimensions == null ? void 0 : prevDimensions.viewportInnerSize.height)) {
      apiRef.current.publishEvent(GridEvents.viewportInnerSizeChange, newFullDimensions.viewportInnerSize);
    }
  }, [apiRef, props.scrollbarSize, props.autoHeight, headerHeight, rowsMeta.currentPageTotalHeight]);
  const resize = React$6.useCallback(() => {
    updateGridDimensionsRef();
    apiRef.current.publishEvent(GridEvents.debouncedResize, rootDimensionsRef.current);
  }, [apiRef, updateGridDimensionsRef]);
  const getRootDimensions = React$6.useCallback(() => fullDimensionsRef.current, []);
  const getViewportPageSize = React$6.useCallback(() => {
    const dimensions = apiRef.current.getRootDimensions();
    if (!dimensions) {
      return 0;
    }
    const currentPage = getCurrentPageRows(apiRef, {
      pagination: props.pagination,
      paginationMode: props.paginationMode
    });
    if (props.getRowHeight) {
      const renderContext = apiRef.current.unstable_getRenderContext();
      const viewportPageSize = renderContext.lastRowIndex - renderContext.firstRowIndex;
      return Math.min(viewportPageSize - 1, currentPage.rows.length);
    }
    const maximumPageSizeWithoutScrollBar = Math.floor(dimensions.viewportInnerSize.height / gridDensityRowHeightSelector(apiRef));
    return Math.min(maximumPageSizeWithoutScrollBar, currentPage.rows.length);
  }, [apiRef, props.pagination, props.paginationMode, props.getRowHeight]);
  const dimensionsApi = {
    resize,
    getRootDimensions,
    unstable_getViewportPageSize: getViewportPageSize
  };
  useGridApiMethod(apiRef, dimensionsApi);
  const debounceResize = React$6.useMemo(() => debounce$4(resize, 60), [resize]);
  const isFirstSizing = React$6.useRef(true);
  const handleResize = React$6.useCallback((size) => {
    rootDimensionsRef.current = size;
    const isJSDOM = /jsdom/.test(window.navigator.userAgent);
    if (size.height === 0 && !warningShown.current && !props.autoHeight && !isJSDOM) {
      logger.warn(["The parent of the grid has an empty height.", "You need to make sure the container has an intrinsic height.", "The grid displays with a height of 0px.", "", "You can find a solution in the docs:", "https://mui.com/components/data-grid/layout/"].join("\n"));
      warningShown.current = true;
    }
    if (size.width === 0 && !warningShown.current && !isJSDOM) {
      logger.warn(["The parent of the grid has an empty width.", "You need to make sure the container has an intrinsic width.", "The grid displays with a width of 0px.", "", "You can find a solution in the docs:", "https://mui.com/components/data-grid/layout/"].join("\n"));
      warningShown.current = true;
    }
    if (isFirstSizing.current) {
      resize();
      isFirstSizing.current = false;
      return;
    }
    debounceResize();
  }, [props.autoHeight, debounceResize, logger, resize]);
  unstable_useEnhancedEffect(() => updateGridDimensionsRef(), [updateGridDimensionsRef]);
  useGridApiOptionHandler(apiRef, GridEvents.visibleRowsSet, updateGridDimensionsRef);
  useGridApiOptionHandler(apiRef, GridEvents.pageChange, updateGridDimensionsRef);
  useGridApiOptionHandler(apiRef, GridEvents.pageSizeChange, updateGridDimensionsRef);
  useGridApiOptionHandler(apiRef, GridEvents.columnsChange, updateGridDimensionsRef);
  useGridApiEventHandler(apiRef, GridEvents.resize, handleResize);
  useGridApiOptionHandler(apiRef, GridEvents.debouncedResize, props.onResize);
}
const useGridRowsMeta = (apiRef, props) => {
  const {
    getRowHeight,
    pagination,
    paginationMode
  } = props;
  const rowsHeightLookup = React$6.useRef({});
  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);
  const filterState = useGridSelector(apiRef, gridFilterStateSelector);
  const paginationState = useGridSelector(apiRef, gridPaginationSelector);
  const sortingState = useGridSelector(apiRef, gridSortingStateSelector);
  useGridStateInit(apiRef, (state) => _extends$5({}, state, {
    rowsMeta: {
      currentPageTotalHeight: 0,
      positions: []
    }
  }));
  const hydrateRowsMeta = React$6.useCallback(() => {
    const {
      rows
    } = getCurrentPageRows(apiRef, {
      pagination,
      paginationMode
    });
    apiRef.current.setState((state) => {
      const positions = [];
      const densityFactor = gridDensityFactorSelector(state, apiRef.current.instanceId);
      const currentRowHeight = gridDensityRowHeightSelector(state, apiRef.current.instanceId);
      const currentPageTotalHeight = rows.reduce((acc, row) => {
        positions.push(acc);
        let baseRowHeight;
        const isResized = rowsHeightLookup.current[row.id] && rowsHeightLookup.current[row.id].isResized || false;
        if (isResized) {
          baseRowHeight = rowsHeightLookup.current[row.id].value;
        } else {
          baseRowHeight = currentRowHeight;
          if (getRowHeight) {
            var _getRowHeight;
            baseRowHeight = (_getRowHeight = getRowHeight(_extends$5({}, row, {
              densityFactor
            }))) != null ? _getRowHeight : currentRowHeight;
          }
        }
        const heights = apiRef.current.unstable_applyPreProcessors("rowHeight", {
          base: baseRowHeight
        }, row);
        const finalRowHeight = Object.values(heights).reduce((acc2, value) => acc2 + value, 0);
        rowsHeightLookup.current[row.id] = {
          value: baseRowHeight,
          isResized
        };
        return acc + finalRowHeight;
      }, 0);
      return _extends$5({}, state, {
        rowsMeta: {
          currentPageTotalHeight,
          positions
        }
      });
    });
    apiRef.current.forceUpdate();
  }, [apiRef, pagination, paginationMode, getRowHeight]);
  const getTargetRowHeight = (rowId) => {
    var _rowsHeightLookup$cur;
    return ((_rowsHeightLookup$cur = rowsHeightLookup.current[rowId]) == null ? void 0 : _rowsHeightLookup$cur.value) || rowHeight;
  };
  const setRowHeight = React$6.useCallback((id2, height) => {
    rowsHeightLookup.current[id2] = {
      value: height,
      isResized: true
    };
    hydrateRowsMeta();
  }, [hydrateRowsMeta]);
  React$6.useEffect(() => {
    hydrateRowsMeta();
  }, [rowHeight, filterState, paginationState, sortingState, hydrateRowsMeta]);
  const handlePreProcessorRegister = React$6.useCallback((name) => {
    if (name !== "rowHeight") {
      return;
    }
    hydrateRowsMeta();
  }, [hydrateRowsMeta]);
  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);
  const rowsMetaApi = {
    unstable_getRowHeight: getTargetRowHeight,
    unstable_setRowHeight: setRowHeight
  };
  useGridApiMethod(apiRef, rowsMetaApi);
};
const useGridStatePersistence = (apiRef) => {
  const exportState = React$6.useCallback(() => {
    const stateToExport = apiRef.current.unstable_applyPreProcessors("exportState", {});
    return stateToExport;
  }, [apiRef]);
  const restoreState = React$6.useCallback((stateToRestore) => {
    const response = apiRef.current.unstable_applyPreProcessors("restoreState", {
      callbacks: []
    }, {
      stateToRestore
    });
    response.callbacks.forEach((callback) => {
      callback();
    });
    apiRef.current.forceUpdate();
  }, [apiRef]);
  const statePersistenceApi = {
    exportState,
    restoreState
  };
  useGridApiMethod(apiRef, statePersistenceApi);
};
const useDataGridComponent = (props) => {
  const apiRef = useGridInitialization(void 0, props);
  useGridSelectionPreProcessors(apiRef, props);
  useGridInitializeState(filterStateInitializer, apiRef, props);
  useGridInitializeState(pageSizeStateInitializer, apiRef, props);
  useGridInitializeState(pageStateInitializer, apiRef, props);
  useGridInitializeState(rowsStateInitializer, apiRef, props);
  useGridInitializeState(sortingStateInitializer, apiRef, props);
  useGridInitializeState(columnsStateInitializer, apiRef, props);
  useGridSelection(apiRef, props);
  useGridColumns(apiRef, props);
  useGridRows(apiRef, props);
  useGridParamsApi(apiRef);
  useGridEditing(apiRef, props);
  useGridFocus(apiRef, props);
  useGridSorting(apiRef, props);
  useGridPreferencesPanel(apiRef, props);
  useGridFilter(apiRef, props);
  useGridDensity(apiRef, props);
  useGridPagination(apiRef, props);
  useGridRowsMeta(apiRef, props);
  useGridScroll(apiRef, props);
  useGridColumnMenu(apiRef);
  useGridKeyboard(apiRef);
  useGridKeyboardNavigation(apiRef, props);
  useGridCsvExport(apiRef);
  useGridPrintExport(apiRef, props);
  useGridClipboard(apiRef);
  useGridDimensions(apiRef, props);
  useGridEvents(apiRef, props);
  useGridStatePersistence(apiRef);
  return apiRef;
};
const DATA_GRID_FORCED_PROPS = {
  apiRef: void 0,
  disableMultipleColumnsFiltering: true,
  disableMultipleColumnsSorting: true,
  disableMultipleSelection: true,
  throttleRowsMs: void 0,
  hideFooterRowCount: false,
  pagination: true,
  checkboxSelectionVisibleOnly: false,
  disableColumnReorder: true,
  disableColumnResize: true,
  signature: "DataGrid"
};
const MAX_PAGE_SIZE = 100;
const DATA_GRID_PROPS_DEFAULT_VALUES = {
  autoHeight: false,
  autoPageSize: false,
  checkboxSelection: false,
  checkboxSelectionVisibleOnly: false,
  columnBuffer: 3,
  rowBuffer: 3,
  columnThreshold: 3,
  rowThreshold: 3,
  density: GridDensityTypes.Standard,
  disableExtendRowFullWidth: false,
  disableColumnFilter: false,
  disableColumnMenu: false,
  disableColumnSelector: false,
  disableDensitySelector: false,
  disableMultipleColumnsFiltering: false,
  disableMultipleSelection: false,
  disableMultipleColumnsSorting: false,
  disableSelectionOnClick: false,
  disableVirtualization: false,
  editMode: GridEditModes.Cell,
  filterMode: GridFeatureModeConstant.client,
  headerHeight: 56,
  hideFooter: false,
  hideFooterPagination: false,
  hideFooterRowCount: false,
  hideFooterSelectedRowCount: false,
  logger: console,
  logLevel: "error",
  pagination: false,
  paginationMode: GridFeatureModeConstant.client,
  rowHeight: 52,
  rowsPerPageOptions: [25, 50, 100],
  showCellRightBorder: false,
  showColumnRightBorder: false,
  sortingOrder: ["asc", "desc", null],
  sortingMode: GridFeatureModeConstant.client,
  throttleRowsMs: 0,
  disableColumnReorder: false,
  disableColumnResize: false
};
const useDataGridProps = (inProps) => {
  if (inProps.pageSize > MAX_PAGE_SIZE) {
    throw new Error(`'props.pageSize' cannot exceed 100 in DataGrid.`);
  }
  const themedProps = useThemeProps({
    props: inProps,
    name: "MuiDataGrid"
  });
  const localeText = React$6.useMemo(() => _extends$5({}, GRID_DEFAULT_LOCALE_TEXT, themedProps.localeText), [themedProps.localeText]);
  const components = React$6.useMemo(() => {
    const overrides = themedProps.components;
    if (!overrides) {
      return _extends$5({}, DATA_GRID_DEFAULT_SLOTS_COMPONENTS);
    }
    const mergedComponents = {};
    Object.keys(DATA_GRID_DEFAULT_SLOTS_COMPONENTS).forEach((key) => {
      mergedComponents[key] = overrides[key] === void 0 ? DATA_GRID_DEFAULT_SLOTS_COMPONENTS[key] : overrides[key];
    });
    return mergedComponents;
  }, [themedProps.components]);
  return React$6.useMemo(() => _extends$5({}, DATA_GRID_PROPS_DEFAULT_VALUES, themedProps, {
    localeText,
    components
  }, DATA_GRID_FORCED_PROPS), [themedProps, localeText, components]);
};
const _excluded$s = ["className"];
const useUtilityClasses$b = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["virtualScroller"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const VirtualScrollerRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "VirtualScroller",
  overridesResolver: (props, styles) => styles.virtualScroller
})({
  overflow: "auto",
  "@media print": {
    overflow: "hidden"
  }
});
const GridVirtualScroller = /* @__PURE__ */ React$6.forwardRef(function GridVirtualScroller2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$s);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$b(ownerState);
  return /* @__PURE__ */ jsx(VirtualScrollerRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
const _excluded$r = ["className", "style"];
const useUtilityClasses$a = (ownerState) => {
  const {
    classes: classes2,
    overflowedContent
  } = ownerState;
  const slots = {
    root: ["virtualScrollerContent", overflowedContent && "virtualScrollerContent--overflowed"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const VirtualScrollerContentRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerContent",
  overridesResolver: (props, styles) => styles.virtualScrollerContent
})({
  position: "relative"
});
const GridVirtualScrollerContent = /* @__PURE__ */ React$6.forwardRef(function GridVirtualScrollerContent2(props, ref) {
  const {
    className,
    style: style2
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$r);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes,
    overflowedContent: !rootProps.autoHeight && (style2 == null ? void 0 : style2.minHeight) === "auto"
  };
  const classes2 = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsx(VirtualScrollerContentRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className),
    style: style2
  }, other));
});
const _excluded$q = ["className"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["virtualScrollerRenderZone"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const VirtualScrollerRenderZoneRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "VirtualScrollerRenderZone",
  overridesResolver: (props, styles) => styles.virtualScrollerRenderZone
})({
  position: "absolute"
});
const GridVirtualScrollerRenderZone = /* @__PURE__ */ React$6.forwardRef(function GridVirtualScrollerRenderZone2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$q);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsx(VirtualScrollerRenderZoneRoot, _extends$5({
    ref,
    className: clsx(classes2.root, className)
  }, other));
});
const _excluded$p = ["style"];
function getIndexFromScroll(offset, positions, sliceStart = 0, sliceEnd = positions.length) {
  if (positions.length <= 0) {
    return -1;
  }
  if (sliceStart >= sliceEnd) {
    return sliceStart;
  }
  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);
  const itemOffset = positions[pivot];
  return offset <= itemOffset ? getIndexFromScroll(offset, positions, sliceStart, pivot) : getIndexFromScroll(offset, positions, pivot + 1, sliceEnd);
}
const useGridVirtualScroller = (props) => {
  var _currentPage$range2;
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const {
    ref,
    disableVirtualization,
    onRenderZonePositioning,
    renderZoneMinColumnIndex = 0,
    renderZoneMaxColumnIndex = visibleColumns.length,
    getRowProps
  } = props;
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);
  const rowHeight = useGridSelector(apiRef, gridDensityRowHeightSelector);
  const cellFocus = useGridSelector(apiRef, gridFocusCellSelector);
  const cellTabIndex = useGridSelector(apiRef, gridTabIndexCellSelector);
  const rowsMeta = useGridSelector(apiRef, gridRowsMetaSelector);
  const editRowsState = useGridSelector(apiRef, gridEditRowsStateSelector);
  const selectedRowsLookup = useGridSelector(apiRef, selectedIdsLookupSelector);
  const currentPage = useCurrentPageRows(apiRef, rootProps);
  const renderZoneRef = React$6.useRef(null);
  const rootRef = React$6.useRef(null);
  const handleRef = useForkRef(ref, rootRef);
  const [renderContext, setRenderContext] = React$6.useState(null);
  const prevRenderContext = React$6.useRef(renderContext);
  const scrollPosition = React$6.useRef({
    top: 0,
    left: 0
  });
  const [containerWidth, setContainerWidth] = React$6.useState(null);
  const prevTotalWidth = React$6.useRef(columnsTotalWidth);
  const computeRenderContext = React$6.useCallback(() => {
    if (disableVirtualization) {
      return {
        firstRowIndex: 0,
        lastRowIndex: currentPage.rows.length,
        firstColumnIndex: 0,
        lastColumnIndex: visibleColumns.length
      };
    }
    const {
      top,
      left
    } = scrollPosition.current;
    const firstRowIndex = getIndexFromScroll(top, rowsMeta.positions);
    const lastRowIndex = rootProps.autoHeight ? firstRowIndex + currentPage.rows.length : getIndexFromScroll(top + rootRef.current.clientHeight, rowsMeta.positions);
    const firstColumnIndex = getIndexFromScroll(left, columnPositions);
    const lastColumnIndex = getIndexFromScroll(left + containerWidth, columnPositions);
    return {
      firstRowIndex,
      lastRowIndex,
      firstColumnIndex,
      lastColumnIndex
    };
  }, [disableVirtualization, rowsMeta.positions, rootProps.autoHeight, currentPage.rows.length, columnPositions, containerWidth, visibleColumns.length]);
  React$6.useEffect(() => {
    if (disableVirtualization) {
      renderZoneRef.current.style.transform = `translate3d(0px, 0px, 0px)`;
    } else {
      rootRef.current.scrollLeft = 0;
      rootRef.current.scrollTop = 0;
    }
  }, [disableVirtualization]);
  React$6.useEffect(() => {
    setContainerWidth(rootRef.current.clientWidth);
  }, [rowsMeta.currentPageTotalHeight]);
  const handleResize = React$6.useCallback(() => {
    if (rootRef.current) {
      setContainerWidth(rootRef.current.clientWidth);
    }
  }, []);
  useGridApiEventHandler(apiRef, GridEvents.resize, handleResize);
  const getRenderableIndexes = ({
    firstIndex,
    lastIndex,
    buffer,
    minFirstIndex,
    maxLastIndex
  }) => {
    return [clamp(firstIndex - buffer, minFirstIndex, maxLastIndex), clamp(lastIndex + buffer, minFirstIndex, maxLastIndex)];
  };
  const updateRenderZonePosition = React$6.useCallback((nextRenderContext) => {
    var _currentPage$range;
    const [firstRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: (_currentPage$range = currentPage.range) == null ? void 0 : _currentPage$range.lastRowIndex,
      buffer: rootProps.rowBuffer
    });
    const [firstColumnToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstColumnIndex,
      lastIndex: nextRenderContext.lastColumnIndex,
      minFirstIndex: renderZoneMinColumnIndex,
      maxLastIndex: renderZoneMaxColumnIndex,
      buffer: rootProps.columnBuffer
    });
    const top = gridRowsMetaSelector(apiRef.current.state).positions[firstRowToRender];
    const left = gridColumnPositionsSelector(apiRef)[firstColumnToRender];
    renderZoneRef.current.style.transform = `translate3d(${left}px, ${top}px, 0px)`;
    if (typeof onRenderZonePositioning === "function") {
      onRenderZonePositioning({
        top,
        left
      });
    }
  }, [apiRef, (_currentPage$range2 = currentPage.range) == null ? void 0 : _currentPage$range2.lastRowIndex, onRenderZonePositioning, renderZoneMaxColumnIndex, renderZoneMinColumnIndex, rootProps.columnBuffer, rootProps.rowBuffer]);
  const updateRenderContext = React$6.useCallback((nextRenderContext) => {
    setRenderContext(nextRenderContext);
    updateRenderZonePosition(nextRenderContext);
    prevRenderContext.current = nextRenderContext;
  }, [setRenderContext, prevRenderContext, updateRenderZonePosition]);
  React$6.useEffect(() => {
    if (containerWidth == null) {
      return;
    }
    const initialRenderContext = computeRenderContext();
    prevRenderContext.current = initialRenderContext;
    updateRenderContext(initialRenderContext);
    const {
      top,
      left
    } = scrollPosition.current;
    const params = {
      top,
      left,
      renderContext: initialRenderContext
    };
    apiRef.current.publishEvent(GridEvents.rowsScroll, params);
  }, [apiRef, computeRenderContext, containerWidth, updateRenderContext]);
  const handleScroll = (event) => {
    const {
      scrollTop,
      scrollLeft
    } = event.currentTarget;
    scrollPosition.current.top = scrollTop;
    scrollPosition.current.left = scrollLeft;
    if (scrollLeft < 0 || scrollTop < 0 || !prevRenderContext.current) {
      return;
    }
    const nextRenderContext = disableVirtualization ? prevRenderContext.current : computeRenderContext();
    const rowsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstRowIndex - prevRenderContext.current.firstRowIndex);
    const columnsScrolledSincePreviousRender = Math.abs(nextRenderContext.firstColumnIndex - prevRenderContext.current.firstColumnIndex);
    const shouldSetState = rowsScrolledSincePreviousRender >= rootProps.rowThreshold || columnsScrolledSincePreviousRender >= rootProps.columnThreshold || prevTotalWidth.current !== columnsTotalWidth;
    apiRef.current.publishEvent(GridEvents.rowsScroll, {
      top: scrollTop,
      left: scrollLeft,
      renderContext: shouldSetState ? nextRenderContext : prevRenderContext.current
    });
    if (shouldSetState) {
      updateRenderContext(nextRenderContext);
      prevTotalWidth.current = columnsTotalWidth;
    }
  };
  const getRows = (params = {
    renderContext
  }) => {
    const {
      renderContext: nextRenderContext,
      minFirstColumn = renderZoneMinColumnIndex,
      maxLastColumn = renderZoneMaxColumnIndex,
      availableSpace = containerWidth
    } = params;
    if (!currentPage.range || !nextRenderContext || availableSpace == null) {
      return null;
    }
    const rowBuffer = !disableVirtualization ? rootProps.rowBuffer : 0;
    const columnBuffer = !disableVirtualization ? rootProps.columnBuffer : 0;
    const [firstRowToRender, lastRowToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstRowIndex,
      lastIndex: nextRenderContext.lastRowIndex,
      minFirstIndex: 0,
      maxLastIndex: currentPage.rows.length,
      buffer: rowBuffer
    });
    const [firstColumnToRender, lastColumnToRender] = getRenderableIndexes({
      firstIndex: nextRenderContext.firstColumnIndex,
      lastIndex: nextRenderContext.lastColumnIndex,
      minFirstIndex: minFirstColumn,
      maxLastIndex: maxLastColumn,
      buffer: columnBuffer
    });
    const renderedRows = currentPage.rows.slice(firstRowToRender, lastRowToRender);
    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);
    const rows = [];
    for (let i2 = 0; i2 < renderedRows.length; i2 += 1) {
      var _rootProps$components;
      const {
        id: id2,
        model
      } = renderedRows[i2];
      const lastVisibleRowIndex = firstRowToRender + i2 === currentPage.rows.length - 1;
      const targetRowHeight = apiRef.current.unstable_getRowHeight(id2);
      let isSelected;
      if (selectedRowsLookup[id2] == null) {
        isSelected = false;
      } else if (typeof rootProps.isRowSelectable === "function") {
        isSelected = rootProps.isRowSelectable(apiRef.current.getRowParams(id2));
      } else {
        isSelected = true;
      }
      rows.push(/* @__PURE__ */ jsx(rootProps.components.Row, _extends$5({
        row: model,
        rowId: id2,
        rowHeight: targetRowHeight,
        cellFocus,
        cellTabIndex,
        editRowsState,
        renderedColumns,
        visibleColumns,
        firstColumnToRender,
        lastColumnToRender,
        selected: isSelected,
        index: currentPage.range.firstRowIndex + nextRenderContext.firstRowIndex + i2,
        containerWidth: availableSpace,
        isLastVisible: lastVisibleRowIndex
      }, typeof getRowProps === "function" ? getRowProps(id2, model) : {}, (_rootProps$components = rootProps.componentsProps) == null ? void 0 : _rootProps$components.row), id2));
    }
    return rows;
  };
  const needsHorizontalScrollbar = containerWidth && columnsTotalWidth > containerWidth;
  const contentSize = React$6.useMemo(() => {
    const height = Math.max(rowsMeta.currentPageTotalHeight, 1);
    let shouldExtendContent = false;
    if (rootRef != null && rootRef.current && height <= (rootRef == null ? void 0 : rootRef.current.clientHeight)) {
      shouldExtendContent = true;
    }
    const size = {
      width: needsHorizontalScrollbar ? columnsTotalWidth : "auto",
      height,
      minHeight: shouldExtendContent ? "100%" : "auto"
    };
    if (rootProps.autoHeight && currentPage.rows.length === 0) {
      size.height = 2 * rowHeight;
    }
    return size;
  }, [rootRef, columnsTotalWidth, rowsMeta.currentPageTotalHeight, currentPage.rows.length, needsHorizontalScrollbar, rootProps.autoHeight, rowHeight]);
  React$6.useEffect(() => {
    apiRef.current.publishEvent(GridEvents.virtualScrollerContentSizeChange);
  }, [apiRef, contentSize]);
  if (rootProps.autoHeight && currentPage.rows.length === 0) {
    contentSize.height = 2 * rowHeight;
  }
  const rootStyle = {};
  if (!needsHorizontalScrollbar) {
    rootStyle.overflowX = "hidden";
  }
  const getRenderContext = React$6.useCallback(() => {
    return prevRenderContext.current;
  }, []);
  apiRef.current.unstable_getRenderContext = getRenderContext;
  return {
    renderContext,
    updateRenderZonePosition,
    getRows,
    getRootProps: (_ref = {}) => {
      let {
        style: style2 = {}
      } = _ref, other = _objectWithoutPropertiesLoose$2(_ref, _excluded$p);
      return _extends$5({
        ref: handleRef,
        onScroll: handleScroll,
        style: _extends$5({}, style2, rootStyle)
      }, other);
    },
    getContentProps: ({
      style: style2 = {}
    } = {}) => ({
      style: _extends$5({}, style2, contentSize)
    }),
    getRenderZoneProps: () => ({
      ref: renderZoneRef
    })
  };
};
const _excluded$o = ["className", "disableVirtualization"];
const DataGridVirtualScroller = /* @__PURE__ */ React$6.forwardRef(function DataGridVirtualScroller2(props, ref) {
  const {
    className,
    disableVirtualization
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$o);
  const {
    getRootProps,
    getContentProps,
    getRenderZoneProps,
    getRows
  } = useGridVirtualScroller({
    ref,
    disableVirtualization
  });
  return /* @__PURE__ */ jsx(GridVirtualScroller, _extends$5({
    className
  }, getRootProps(other), {
    children: /* @__PURE__ */ jsx(GridVirtualScrollerContent, _extends$5({}, getContentProps(), {
      children: /* @__PURE__ */ jsx(GridVirtualScrollerRenderZone, _extends$5({}, getRenderZoneProps(), {
        children: getRows()
      }))
    }))
  }));
});
const useGridColumnHeaders = (props) => {
  const {
    innerRef: innerRefProp,
    minColumnIndex = 0
  } = props;
  const [dragCol, setDragCol] = React$6.useState("");
  const [resizeCol, setResizeCol] = React$6.useState("");
  const apiRef = useGridApiContext();
  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);
  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);
  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);
  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);
  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);
  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);
  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);
  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);
  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);
  const rootProps = useGridRootProps();
  const innerRef = React$6.useRef(null);
  const handleInnerRef = useForkRef(innerRefProp, innerRef);
  const [renderContext, setRenderContext] = React$6.useState(null);
  const prevRenderContext = React$6.useRef(renderContext);
  const prevScrollLeft = React$6.useRef(0);
  React$6.useEffect(() => {
    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;
  }, [apiRef]);
  const updateInnerPosition = React$6.useCallback((nextRenderContext) => {
    const firstColumnToRender = Math.max(nextRenderContext.firstColumnIndex - rootProps.columnBuffer, minColumnIndex);
    const offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;
    innerRef.current.style.transform = `translate3d(${-offset}px, 0px, 0px)`;
  }, [columnPositions, minColumnIndex, rootProps.columnBuffer]);
  const handleScroll = React$6.useCallback(({
    left,
    renderContext: nextRenderContext = null
  }) => {
    var _prevRenderContext$cu, _prevRenderContext$cu2;
    if (!innerRef.current) {
      return;
    }
    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {
      return;
    }
    prevScrollLeft.current = left;
    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {
      setRenderContext(nextRenderContext);
      prevRenderContext.current = nextRenderContext;
    }
    if (nextRenderContext) {
      updateInnerPosition(nextRenderContext);
    }
  }, [updateInnerPosition]);
  const handleColumnResizeStart = React$6.useCallback((params) => setResizeCol(params.field), []);
  const handleColumnResizeStop = React$6.useCallback(() => setResizeCol(""), []);
  const handleColumnReorderStart = React$6.useCallback((params) => setDragCol(params.field), []);
  const handleColumnReorderStop = React$6.useCallback(() => setDragCol(""), []);
  useGridApiEventHandler(apiRef, GridEvents.columnResizeStart, handleColumnResizeStart);
  useGridApiEventHandler(apiRef, GridEvents.columnResizeStop, handleColumnResizeStop);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, handleColumnReorderStart);
  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragEnd, handleColumnReorderStop);
  useGridApiEventHandler(apiRef, GridEvents.rowsScroll, handleScroll);
  const getColumns = (params, other = {}) => {
    const {
      renderContext: nextRenderContext = renderContext,
      minFirstColumn = minColumnIndex,
      maxLastColumn = visibleColumns.length
    } = params || {};
    if (!nextRenderContext) {
      return null;
    }
    const columns = [];
    const firstColumnToRender = Math.max(nextRenderContext.firstColumnIndex - rootProps.columnBuffer, minFirstColumn);
    const lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);
    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);
    for (let i2 = 0; i2 < renderedColumns.length; i2 += 1) {
      const column = renderedColumns[i2];
      const columnIndex = firstColumnToRender + i2;
      const isFirstColumn = columnIndex === 0;
      const hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);
      const tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;
      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;
      const open = columnMenuState.open && columnMenuState.field === column.field;
      columns.push(/* @__PURE__ */ jsx(GridColumnHeaderItem, _extends$5({}, sortColumnLookup[column.field], {
        columnMenuOpen: open,
        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,
        headerHeight,
        isDragging: column.field === dragCol,
        column,
        colIndex: columnIndex,
        isResizing: resizeCol === column.field,
        isLastColumn: columnIndex === columns.length - 1,
        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,
        hasFocus,
        tabIndex
      }, other), i2));
    }
    return columns;
  };
  const rootStyle = {
    minHeight: headerHeight,
    maxHeight: headerHeight,
    lineHeight: `${headerHeight}px`
  };
  return {
    renderContext,
    getColumns,
    isDragging: !!dragCol,
    updateInnerPosition,
    getRootProps: (other = {}) => _extends$5({
      style: rootStyle
    }, other),
    getInnerProps: () => ({
      ref: handleInnerRef,
      "aria-rowindex": 1,
      role: "row"
    })
  };
};
const _excluded$n = ["innerRef", "className"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnHeaders"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridColumnHeadersRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "ColumnHeaders",
  overridesResolver: (props, styles) => styles.columnHeaders
})(({
  theme
}) => {
  const borderColor = theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68);
  return {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    overflow: "hidden",
    display: "flex",
    alignItems: "center",
    borderBottom: `1px solid ${borderColor}`
  };
});
const GridColumnHeaders = /* @__PURE__ */ React$6.forwardRef(function GridColumnHeaders2(props, ref) {
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$n);
  const rootProps = useGridRootProps();
  const ownerState = {
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsx(GridColumnHeadersRoot, _extends$5({
    ref,
    className: clsx(className, classes2.root)
  }, other));
});
const _excluded$m = ["isDragging", "className"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    isDragging,
    hasScrollX,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["columnHeadersInner", isDragging && "columnHeaderDropZone", hasScrollX && "columnHeadersInner--scrollable"]
  };
  return unstable_composeClasses(slots, getDataGridUtilityClass, classes2);
};
const GridColumnHeadersInnerRoot = styled("div", {
  name: "MuiDataGrid",
  slot: "columnHeadersInner",
  overridesResolver: (props, styles) => [{
    [`&.${gridClasses.columnHeaderDropZone}`]: styles.columnHeaderDropZone
  }, styles.columnHeadersInner]
})(() => ({
  display: "flex",
  alignItems: "center",
  [`&.${gridClasses.columnHeaderDropZone} .${gridClasses.columnHeaderDraggableContainer}`]: {
    cursor: "move"
  },
  [`&.${gridClasses["columnHeadersInner--scrollable"]} .${gridClasses.columnHeader}:last-child`]: {
    borderRight: "none"
  }
}));
const GridColumnHeadersInner = /* @__PURE__ */ React$6.forwardRef(function GridColumnHeadersInner2(props, ref) {
  var _apiRef$current$getRo, _apiRef$current$getRo2;
  const {
    isDragging,
    className
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$m);
  const apiRef = useGridApiContext();
  const rootProps = useGridRootProps();
  const ownerState = {
    isDragging,
    hasScrollX: (_apiRef$current$getRo = (_apiRef$current$getRo2 = apiRef.current.getRootDimensions()) == null ? void 0 : _apiRef$current$getRo2.hasScrollX) != null ? _apiRef$current$getRo : false,
    classes: rootProps.classes
  };
  const classes2 = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsx(GridColumnHeadersInnerRoot, _extends$5({
    ref,
    className: clsx(className, classes2.root)
  }, other));
});
const _excluded$l = ["innerRef", "className"];
const DataGridColumnHeaders = /* @__PURE__ */ React$6.forwardRef(function GridColumnsHeader(props, ref) {
  const {
    innerRef
  } = props, other = _objectWithoutPropertiesLoose$2(props, _excluded$l);
  const {
    isDragging,
    getRootProps,
    getInnerProps,
    getColumns
  } = useGridColumnHeaders({
    innerRef
  });
  return /* @__PURE__ */ jsxs(GridColumnHeaders, _extends$5({
    ref
  }, getRootProps(other), {
    children: [/* @__PURE__ */ jsx(GridScrollArea, {
      scrollDirection: "left"
    }), /* @__PURE__ */ jsx(GridColumnHeadersInner, _extends$5({
      isDragging
    }, getInnerProps(), {
      children: getColumns()
    })), /* @__PURE__ */ jsx(GridScrollArea, {
      scrollDirection: "right"
    })]
  }));
});
const DataGridRaw = /* @__PURE__ */ React$6.forwardRef(function DataGrid(inProps, ref) {
  const props = useDataGridProps(inProps);
  const apiRef = useDataGridComponent(props);
  return /* @__PURE__ */ jsx(GridContextProvider, {
    apiRef,
    props,
    children: /* @__PURE__ */ jsx(GridRoot, {
      className: props.className,
      style: props.style,
      sx: props.sx,
      ref,
      children: /* @__PURE__ */ jsxs(GridErrorHandler, {
        children: [/* @__PURE__ */ jsx(GridHeaderPlaceholder, {}), /* @__PURE__ */ jsx(GridBody, {
          ColumnHeadersComponent: DataGridColumnHeaders,
          VirtualScrollerComponent: DataGridVirtualScroller
        }), /* @__PURE__ */ jsx(GridFooterPlaceholder, {})]
      })
    })
  });
});
const DataGrid2 = /* @__PURE__ */ React$6.memo(DataGridRaw);
DataGridRaw.propTypes = {
  "aria-label": PropTypes$5.string,
  "aria-labelledby": PropTypes$5.string,
  autoHeight: PropTypes$5.bool,
  autoPageSize: PropTypes$5.bool,
  checkboxSelection: PropTypes$5.bool,
  classes: PropTypes$5.object,
  columnBuffer: PropTypes$5.number,
  columns: chainPropTypes(PropTypes$5.array.isRequired),
  columnThreshold: PropTypes$5.number,
  columnTypes: PropTypes$5.object,
  columnVisibilityModel: PropTypes$5.object,
  components: PropTypes$5.object,
  componentsProps: PropTypes$5.object,
  density: PropTypes$5.oneOf(["comfortable", "compact", "standard"]),
  disableColumnFilter: PropTypes$5.bool,
  disableColumnMenu: PropTypes$5.bool,
  disableColumnSelector: PropTypes$5.bool,
  disableDensitySelector: PropTypes$5.bool,
  disableExtendRowFullWidth: PropTypes$5.bool,
  disableSelectionOnClick: PropTypes$5.bool,
  disableVirtualization: PropTypes$5.bool,
  editMode: PropTypes$5.oneOf(["cell", "row"]),
  editRowsModel: PropTypes$5.object,
  error: PropTypes$5.any,
  experimentalFeatures: PropTypes$5.shape({
    preventCommitWhileValidating: PropTypes$5.bool
  }),
  filterMode: PropTypes$5.oneOf(["client", "server"]),
  filterModel: PropTypes$5.shape({
    items: PropTypes$5.arrayOf(PropTypes$5.shape({
      columnField: PropTypes$5.string.isRequired,
      id: PropTypes$5.oneOfType([PropTypes$5.number, PropTypes$5.string]),
      operatorValue: PropTypes$5.string,
      value: PropTypes$5.any
    })).isRequired,
    linkOperator: PropTypes$5.oneOf(["and", "or"])
  }),
  getCellClassName: PropTypes$5.func,
  getDetailPanelContent: PropTypes$5.func,
  getRowClassName: PropTypes$5.func,
  getRowHeight: PropTypes$5.func,
  getRowId: PropTypes$5.func,
  headerHeight: PropTypes$5.number,
  hideFooter: PropTypes$5.bool,
  hideFooterPagination: PropTypes$5.bool,
  hideFooterSelectedRowCount: PropTypes$5.bool,
  initialState: PropTypes$5.object,
  isCellEditable: PropTypes$5.func,
  isRowSelectable: PropTypes$5.func,
  loading: PropTypes$5.bool,
  localeText: PropTypes$5.object,
  logger: PropTypes$5.shape({
    debug: PropTypes$5.func.isRequired,
    error: PropTypes$5.func.isRequired,
    info: PropTypes$5.func.isRequired,
    warn: PropTypes$5.func.isRequired
  }),
  logLevel: PropTypes$5.oneOf(["debug", "error", "info", "warn", false]),
  nonce: PropTypes$5.string,
  onCellClick: PropTypes$5.func,
  onCellDoubleClick: PropTypes$5.func,
  onCellEditCommit: PropTypes$5.func,
  onCellEditStart: PropTypes$5.func,
  onCellEditStop: PropTypes$5.func,
  onCellFocusOut: PropTypes$5.func,
  onCellKeyDown: PropTypes$5.func,
  onColumnHeaderClick: PropTypes$5.func,
  onColumnHeaderDoubleClick: PropTypes$5.func,
  onColumnHeaderEnter: PropTypes$5.func,
  onColumnHeaderLeave: PropTypes$5.func,
  onColumnHeaderOut: PropTypes$5.func,
  onColumnHeaderOver: PropTypes$5.func,
  onColumnOrderChange: PropTypes$5.func,
  onColumnVisibilityChange: PropTypes$5.func,
  onColumnVisibilityModelChange: PropTypes$5.func,
  onEditCellPropsChange: PropTypes$5.func,
  onEditRowsModelChange: PropTypes$5.func,
  onError: PropTypes$5.func,
  onFilterModelChange: PropTypes$5.func,
  onPageChange: PropTypes$5.func,
  onPageSizeChange: PropTypes$5.func,
  onResize: PropTypes$5.func,
  onRowClick: PropTypes$5.func,
  onRowDoubleClick: PropTypes$5.func,
  onRowEditCommit: PropTypes$5.func,
  onRowEditStart: PropTypes$5.func,
  onRowEditStop: PropTypes$5.func,
  onSelectionModelChange: PropTypes$5.func,
  onSortModelChange: PropTypes$5.func,
  onStateChange: PropTypes$5.func,
  page: PropTypes$5.number,
  pageSize: chainPropTypes(PropTypes$5.number),
  pagination: (props) => {
    if (props.pagination === false) {
      return new Error(["MUI: `<DataGrid pagination={false} />` is not a valid prop.", "Infinite scrolling is not available in the MIT version.", "", "You need to upgrade to the DataGridPro component to disable the pagination."].join("\n"));
    }
    return null;
  },
  paginationMode: PropTypes$5.oneOf(["client", "server"]),
  rowBuffer: PropTypes$5.number,
  rowCount: PropTypes$5.number,
  rowHeight: PropTypes$5.number,
  rows: PropTypes$5.arrayOf(PropTypes$5.object).isRequired,
  rowsPerPageOptions: PropTypes$5.arrayOf(PropTypes$5.number),
  rowThreshold: PropTypes$5.number,
  scrollbarSize: PropTypes$5.number,
  selectionModel: chainPropTypes(PropTypes$5.oneOfType([PropTypes$5.number, PropTypes$5.string, PropTypes$5.array])),
  showCellRightBorder: PropTypes$5.bool,
  showColumnRightBorder: PropTypes$5.bool,
  sortingMode: PropTypes$5.oneOf(["client", "server"]),
  sortingOrder: PropTypes$5.arrayOf(PropTypes$5.oneOf(["asc", "desc"])),
  sortModel: PropTypes$5.arrayOf(PropTypes$5.shape({
    field: PropTypes$5.string.isRequired,
    sort: PropTypes$5.oneOf(["asc", "desc"])
  })),
  sx: PropTypes$5.oneOfType([PropTypes$5.arrayOf(PropTypes$5.oneOfType([PropTypes$5.func, PropTypes$5.object, PropTypes$5.bool])), PropTypes$5.func, PropTypes$5.object])
};
const Translate = ({
  entityName,
  fieldName,
  defaultMessage,
  values: values2,
  children
}) => {
  let dataField = fieldName;
  let dataEntity = entityName;
  if (fieldName && fieldName.split("___").length === 2) {
    dataField = fieldName.split("___")[1];
    dataEntity = fieldName.split("___")[0];
  } else if (fieldName && fieldName.split("__").length === 2) {
    dataField = fieldName.split("__")[1];
  }
  return /* @__PURE__ */ jsx(FormattedMessage$1, {
    tagName: ({
      children: children2
    }) => /* @__PURE__ */ jsx("span", {
      className: "translate",
      dangerouslySetInnerHTML: {
        __html: children2
      },
      "data-message-id": fieldName ? `${entityName}.${fieldName}` : `${entityName}`,
      "data-field": dataField,
      "data-entity": dataEntity
    }),
    id: fieldName ? `${entityName}.${fieldName}` : `${entityName}`,
    defaultMessage: defaultMessage != null ? defaultMessage : fieldName ? `${fieldName} (${entityName})` : entityName,
    values: values2,
    children
  });
};
const booleanFormatTemplate = ({
  value
}) => {
  if (value == void 0)
    return "Loading...";
  return value ? /* @__PURE__ */ jsx(Checkbox$1, {
    defaultChecked: true
  }) : /* @__PURE__ */ jsx(Checkbox$1, {});
};
var isArray$5 = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== "undefined";
function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var arrA = isArray$5(a2), arrB = isArray$5(b2), i2, length, key;
    if (arrA && arrB) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var dateA = a2 instanceof Date, dateB = b2 instanceof Date;
    if (dateA != dateB)
      return false;
    if (dateA && dateB)
      return a2.getTime() == b2.getTime();
    var regexpA = a2 instanceof RegExp, regexpB = b2 instanceof RegExp;
    if (regexpA != regexpB)
      return false;
    if (regexpA && regexpB)
      return a2.toString() == b2.toString();
    var keys2 = keyList(a2);
    length = keys2.length;
    if (length !== keyList(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!hasProp.call(b2, keys2[i2]))
        return false;
    if (hasElementType && a2 instanceof Element && b2 instanceof Element)
      return a2 === b2;
    for (i2 = length; i2-- !== 0; ) {
      key = keys2[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      } else {
        if (!equal(a2[key], b2[key]))
          return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function exportedEqual(a2, b2) {
  try {
    return equal(a2, b2);
  } catch (error) {
    if (error.message && error.message.match(/stack|recursion/i) || error.number === -2146828260) {
      console.warn("Warning: react-fast-compare does not handle circular references.", error.name, error.message);
      return false;
    }
    throw error;
  }
};
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = deepmerge(target[key], source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var freeGlobal$2 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$3 = freeGlobal$2;
var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$3 || freeSelf$2 || Function("return this")();
var root$3 = root$2;
var Symbol$1 = root$3.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$a = objectProto$f.hasOwnProperty;
var nativeObjectToString$1 = objectProto$f.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$e = Object.prototype;
var nativeObjectToString = objectProto$e.toString;
function objectToString$2(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$2(value);
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function isObjectLike$2(value) {
  return value != null && typeof value == "object";
}
var objectTag$3 = "[object Object]";
var funcProto$2 = Function.prototype, objectProto$d = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$9 = objectProto$d.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject(value) {
  if (!isObjectLike$2(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$9.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function isObject$6(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$6(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$3["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$c = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject$6(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$3, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$7 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$6 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$1 = defineProperty;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike$2(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$4 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$3.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike$2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$3.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$7 = Object.prototype;
var hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$4(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$2 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$1 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$6(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$3.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$3 = Object.prototype;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
function arrayPush(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$3, "DataView");
var DataView$2 = DataView$1;
var Promise$1 = getNative(root$3, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$3, "Set");
var Set$2 = Set$1;
var WeakMap$1 = getNative(root$3, "WeakMap");
var WeakMap$2 = WeakMap$1;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto$2 = Object.prototype;
var hasOwnProperty = objectProto$2.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$3.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$4 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$4:
      return cloneSymbol(object);
  }
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$6(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike$2(value) && getTag$1(value) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike$2(value) && getTag$1(value) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$3 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$3] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$6(value)) {
    return value;
  }
  var isArr = isArray$4(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_SYMBOLS_FLAG$1 = 4;
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
}
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var symbolTag$2 = "[object Symbol]";
function isSymbol$2(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && baseGetTag(value) == symbolTag$2;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize$1(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result;
});
var stringToPath$1 = stringToPath;
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var INFINITY = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function toPath(value) {
  if (isArray$4(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol$2(value) ? [value] : copyArray(stringToPath$1(toString(value)));
}
var isProduction = true;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x2) {
    }
  }
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var isEmptyArray = function isEmptyArray2(value) {
  return Array.isArray(value) && value.length === 0;
};
var isFunction = function isFunction2(obj) {
  return typeof obj === "function";
};
var isObject$5 = function isObject(obj) {
  return obj !== null && typeof obj === "object";
};
var isInteger = function isInteger2(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isString = function isString2(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
};
var isEmptyChildren = function isEmptyChildren2(children) {
  return Children.count(children) === 0;
};
var isPromise = function isPromise2(value) {
  return isObject$5(value) && isFunction(value.then);
};
function getIn(obj, key, def, p2) {
  if (p2 === void 0) {
    p2 = 0;
  }
  var path = toPath(key);
  while (obj && p2 < path.length) {
    obj = obj[path[p2++]];
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  var res = clone(obj);
  var resVal = res;
  var i2 = 0;
  var pathArray = toPath(path);
  for (; i2 < pathArray.length - 1; i2++) {
    var currentPath = pathArray[i2];
    var currentObj = getIn(obj, pathArray.slice(0, i2 + 1));
    if (currentObj && (isObject$5(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      var nextPath = pathArray[i2 + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i2 === 0 ? obj : resVal)[pathArray[i2]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i2]];
  } else {
    resVal[pathArray[i2]] = value;
  }
  if (i2 === 0 && value === void 0) {
    delete res[pathArray[i2]];
  }
  return res;
}
function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = /* @__PURE__ */ new WeakMap();
  }
  if (response === void 0) {
    response = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var k2 = _Object$keys[_i];
    var val = object[k2];
    if (isObject$5(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k2] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k2]);
      }
    } else {
      response[k2] = value;
    }
  }
  return response;
}
var FormikContext = /* @__PURE__ */ createContext(void 0);
FormikContext.displayName = "FormikContext";
var FormikProvider = FormikContext.Provider;
var FormikConsumer = FormikContext.Consumer;
function useFormikContext() {
  var formik = useContext(FormikContext);
  !!!formik ? warning(false) : void 0;
  return formik;
}
function formikReducer(state, msg) {
  switch (msg.type) {
    case "SET_VALUES":
      return _extends$4({}, state, {
        values: msg.payload
      });
    case "SET_TOUCHED":
      return _extends$4({}, state, {
        touched: msg.payload
      });
    case "SET_ERRORS":
      if (reactFastCompare(state.errors, msg.payload)) {
        return state;
      }
      return _extends$4({}, state, {
        errors: msg.payload
      });
    case "SET_STATUS":
      return _extends$4({}, state, {
        status: msg.payload
      });
    case "SET_ISSUBMITTING":
      return _extends$4({}, state, {
        isSubmitting: msg.payload
      });
    case "SET_ISVALIDATING":
      return _extends$4({}, state, {
        isValidating: msg.payload
      });
    case "SET_FIELD_VALUE":
      return _extends$4({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_TOUCHED":
      return _extends$4({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_ERROR":
      return _extends$4({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });
    case "RESET_FORM":
      return _extends$4({}, state, msg.payload);
    case "SET_FORMIK_STATE":
      return msg.payload(state);
    case "SUBMIT_ATTEMPT":
      return _extends$4({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });
    case "SUBMIT_FAILURE":
      return _extends$4({}, state, {
        isSubmitting: false
      });
    case "SUBMIT_SUCCESS":
      return _extends$4({}, state, {
        isSubmitting: false
      });
    default:
      return state;
  }
}
var emptyErrors = {};
var emptyTouched = {};
function useFormik(_ref) {
  var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose$1(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
  var props = _extends$4({
    validateOnChange,
    validateOnBlur,
    validateOnMount,
    onSubmit
  }, rest);
  var initialValues = useRef(props.initialValues);
  var initialErrors = useRef(props.initialErrors || emptyErrors);
  var initialTouched = useRef(props.initialTouched || emptyTouched);
  var initialStatus = useRef(props.initialStatus);
  var isMounted = useRef(false);
  var fieldRegistry = useRef({});
  useEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  var _React$useReducer = useReducer(formikReducer, {
    values: props.initialValues,
    errors: props.initialErrors || emptyErrors,
    touched: props.initialTouched || emptyTouched,
    status: props.initialStatus,
    isSubmitting: false,
    isValidating: false,
    submitCount: 0
  }), state = _React$useReducer[0], dispatch = _React$useReducer[1];
  var runValidateHandler = useCallback(function(values2, field) {
    return new Promise(function(resolve, reject) {
      var maybePromisedErrors = props.validate(values2, field);
      if (maybePromisedErrors == null) {
        resolve(emptyErrors);
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function(errors) {
          resolve(errors || emptyErrors);
        }, function(actualException) {
          reject(actualException);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  }, [props.validate]);
  var runValidationSchema = useCallback(function(values2, field) {
    var validationSchema = props.validationSchema;
    var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
    var promise = field && schema.validateAt ? schema.validateAt(field, values2) : validateYupSchema(values2, schema);
    return new Promise(function(resolve, reject) {
      promise.then(function() {
        resolve(emptyErrors);
      }, function(err) {
        if (err.name === "ValidationError") {
          resolve(yupToFormErrors(err));
        } else {
          reject(err);
        }
      });
    });
  }, [props.validationSchema]);
  var runSingleFieldLevelValidation = useCallback(function(field, value) {
    return new Promise(function(resolve) {
      return resolve(fieldRegistry.current[field].validate(value));
    });
  }, []);
  var runFieldLevelValidations = useCallback(function(values2) {
    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
      return isFunction(fieldRegistry.current[f2].validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
      return runSingleFieldLevelValidation(f2, getIn(values2, f2));
    }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
    return Promise.all(fieldValidations).then(function(fieldErrorsList) {
      return fieldErrorsList.reduce(function(prev, curr, index) {
        if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
          return prev;
        }
        if (curr) {
          prev = setIn(prev, fieldKeysWithValidation[index], curr);
        }
        return prev;
      }, {});
    });
  }, [runSingleFieldLevelValidation]);
  var runAllValidations = useCallback(function(values2) {
    return Promise.all([runFieldLevelValidations(values2), props.validationSchema ? runValidationSchema(values2) : {}, props.validate ? runValidateHandler(values2) : {}]).then(function(_ref2) {
      var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
      var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
        arrayMerge
      });
      return combinedErrors;
    });
  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
  var validateFormWithHighPriority = useEventCallback(function(values2) {
    if (values2 === void 0) {
      values2 = state.values;
    }
    dispatch({
      type: "SET_ISVALIDATING",
      payload: true
    });
    return runAllValidations(values2).then(function(combinedErrors) {
      if (!!isMounted.current) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
        dispatch({
          type: "SET_ERRORS",
          payload: combinedErrors
        });
      }
      return combinedErrors;
    });
  });
  useEffect(function() {
    if (validateOnMount && isMounted.current === true && reactFastCompare(initialValues.current, props.initialValues)) {
      validateFormWithHighPriority(initialValues.current);
    }
  }, [validateOnMount, validateFormWithHighPriority]);
  var resetForm = useCallback(function(nextState) {
    var values2 = nextState && nextState.values ? nextState.values : initialValues.current;
    var errors = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
    initialValues.current = values2;
    initialErrors.current = errors;
    initialTouched.current = touched;
    initialStatus.current = status;
    var dispatchFn = function dispatchFn2() {
      dispatch({
        type: "RESET_FORM",
        payload: {
          isSubmitting: !!nextState && !!nextState.isSubmitting,
          errors,
          touched,
          status,
          values: values2,
          isValidating: !!nextState && !!nextState.isValidating,
          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
        }
      });
    };
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
      if (isPromise(maybePromisedOnReset)) {
        maybePromisedOnReset.then(dispatchFn);
      } else {
        dispatchFn();
      }
    } else {
      dispatchFn();
    }
  }, [props.initialErrors, props.initialStatus, props.initialTouched]);
  useEffect(function() {
    if (isMounted.current === true && !reactFastCompare(initialValues.current, props.initialValues)) {
      if (enableReinitialize) {
        initialValues.current = props.initialValues;
        resetForm();
      }
      if (validateOnMount) {
        validateFormWithHighPriority(initialValues.current);
      }
    }
  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
  useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !reactFastCompare(initialErrors.current, props.initialErrors)) {
      initialErrors.current = props.initialErrors || emptyErrors;
      dispatch({
        type: "SET_ERRORS",
        payload: props.initialErrors || emptyErrors
      });
    }
  }, [enableReinitialize, props.initialErrors]);
  useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !reactFastCompare(initialTouched.current, props.initialTouched)) {
      initialTouched.current = props.initialTouched || emptyTouched;
      dispatch({
        type: "SET_TOUCHED",
        payload: props.initialTouched || emptyTouched
      });
    }
  }, [enableReinitialize, props.initialTouched]);
  useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !reactFastCompare(initialStatus.current, props.initialStatus)) {
      initialStatus.current = props.initialStatus;
      dispatch({
        type: "SET_STATUS",
        payload: props.initialStatus
      });
    }
  }, [enableReinitialize, props.initialStatus, props.initialTouched]);
  var validateField = useEventCallback(function(name) {
    if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
      var value = getIn(state.values, name);
      var maybePromise = fieldRegistry.current[name].validate(value);
      if (isPromise(maybePromise)) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return maybePromise.then(function(x2) {
          return x2;
        }).then(function(error) {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: error
            }
          });
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
        });
      } else {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else if (props.validationSchema) {
      dispatch({
        type: "SET_ISVALIDATING",
        payload: true
      });
      return runValidationSchema(state.values, name).then(function(x2) {
        return x2;
      }).then(function(error) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: error[name]
          }
        });
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
      });
    }
    return Promise.resolve();
  });
  var registerField = useCallback(function(name, _ref3) {
    var validate = _ref3.validate;
    fieldRegistry.current[name] = {
      validate
    };
  }, []);
  var unregisterField = useCallback(function(name) {
    delete fieldRegistry.current[name];
  }, []);
  var setTouched = useEventCallback(function(touched, shouldValidate) {
    dispatch({
      type: "SET_TOUCHED",
      payload: touched
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var setErrors = useCallback(function(errors) {
    dispatch({
      type: "SET_ERRORS",
      payload: errors
    });
  }, []);
  var setValues = useEventCallback(function(values2, shouldValidate) {
    var resolvedValues = isFunction(values2) ? values2(state.values) : values2;
    dispatch({
      type: "SET_VALUES",
      payload: resolvedValues
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
  });
  var setFieldError = useCallback(function(field, value) {
    dispatch({
      type: "SET_FIELD_ERROR",
      payload: {
        field,
        value
      }
    });
  }, []);
  var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
    dispatch({
      type: "SET_FIELD_VALUE",
      payload: {
        field,
        value
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
  });
  var executeChange = useCallback(function(eventOrTextValue, maybePath) {
    var field = maybePath;
    var val = eventOrTextValue;
    var parsed;
    if (!isString(eventOrTextValue)) {
      if (eventOrTextValue.persist) {
        eventOrTextValue.persist();
      }
      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
      var type = target.type, name = target.name, id2 = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;
      field = maybePath ? maybePath : name ? name : id2;
      if (!field && false) {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
          handlerName: "handleChange"
        });
      }
      val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
    }
    if (field) {
      setFieldValue(field, val);
    }
  }, [setFieldValue, state.values]);
  var handleChange = useEventCallback(function(eventOrPath) {
    if (isString(eventOrPath)) {
      return function(event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }
  });
  var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
    if (touched === void 0) {
      touched = true;
    }
    dispatch({
      type: "SET_FIELD_TOUCHED",
      payload: {
        field,
        value: touched
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var executeBlur = useCallback(function(e2, path) {
    if (e2.persist) {
      e2.persist();
    }
    var _e$target = e2.target, name = _e$target.name, id2 = _e$target.id, outerHTML = _e$target.outerHTML;
    var field = path ? path : name ? name : id2;
    if (!field && false) {
      warnAboutMissingIdentifier({
        htmlContent: outerHTML,
        documentationAnchorLink: "handleblur-e-any--void",
        handlerName: "handleBlur"
      });
    }
    setFieldTouched(field, true);
  }, [setFieldTouched]);
  var handleBlur = useEventCallback(function(eventOrString) {
    if (isString(eventOrString)) {
      return function(event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }
  });
  var setFormikState = useCallback(function(stateOrCb) {
    if (isFunction(stateOrCb)) {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: stateOrCb
      });
    } else {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: function payload() {
          return stateOrCb;
        }
      });
    }
  }, []);
  var setStatus = useCallback(function(status) {
    dispatch({
      type: "SET_STATUS",
      payload: status
    });
  }, []);
  var setSubmitting = useCallback(function(isSubmitting) {
    dispatch({
      type: "SET_ISSUBMITTING",
      payload: isSubmitting
    });
  }, []);
  var submitForm = useEventCallback(function() {
    dispatch({
      type: "SUBMIT_ATTEMPT"
    });
    return validateFormWithHighPriority().then(function(combinedErrors) {
      var isInstanceOfError = combinedErrors instanceof Error;
      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
      if (isActuallyValid) {
        var promiseOrUndefined;
        try {
          promiseOrUndefined = executeSubmit();
          if (promiseOrUndefined === void 0) {
            return;
          }
        } catch (error) {
          throw error;
        }
        return Promise.resolve(promiseOrUndefined).then(function(result) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_SUCCESS"
            });
          }
          return result;
        })["catch"](function(_errors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            throw _errors;
          }
        });
      } else if (!!isMounted.current) {
        dispatch({
          type: "SUBMIT_FAILURE"
        });
        if (isInstanceOfError) {
          throw combinedErrors;
        }
      }
      return;
    });
  });
  var handleSubmit = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    submitForm()["catch"](function(reason) {
      console.warn("Warning: An unhandled error was caught from submitForm()", reason);
    });
  });
  var imperativeMethods = {
    resetForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    setErrors,
    setFieldError,
    setFieldTouched,
    setFieldValue,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    setFormikState,
    submitForm
  };
  var executeSubmit = useEventCallback(function() {
    return onSubmit(state.values, imperativeMethods);
  });
  var handleReset = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    resetForm();
  });
  var getFieldMeta = useCallback(function(name) {
    return {
      value: getIn(state.values, name),
      error: getIn(state.errors, name),
      touched: !!getIn(state.touched, name),
      initialValue: getIn(initialValues.current, name),
      initialTouched: !!getIn(initialTouched.current, name),
      initialError: getIn(initialErrors.current, name)
    };
  }, [state.errors, state.touched, state.values]);
  var getFieldHelpers = useCallback(function(name) {
    return {
      setValue: function setValue(value, shouldValidate) {
        return setFieldValue(name, value, shouldValidate);
      },
      setTouched: function setTouched2(value, shouldValidate) {
        return setFieldTouched(name, value, shouldValidate);
      },
      setError: function setError(value) {
        return setFieldError(name, value);
      }
    };
  }, [setFieldValue, setFieldTouched, setFieldError]);
  var getFieldProps = useCallback(function(nameOrOptions) {
    var isAnObject = isObject$5(nameOrOptions);
    var name = isAnObject ? nameOrOptions.name : nameOrOptions;
    var valueState = getIn(state.values, name);
    var field = {
      name,
      value: valueState,
      onChange: handleChange,
      onBlur: handleBlur
    };
    if (isAnObject) {
      var type = nameOrOptions.type, valueProp = nameOrOptions.value, is = nameOrOptions.as, multiple = nameOrOptions.multiple;
      if (type === "checkbox") {
        if (valueProp === void 0) {
          field.checked = !!valueState;
        } else {
          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
          field.value = valueProp;
        }
      } else if (type === "radio") {
        field.checked = valueState === valueProp;
        field.value = valueProp;
      } else if (is === "select" && multiple) {
        field.value = field.value || [];
        field.multiple = true;
      }
    }
    return field;
  }, [handleBlur, handleChange, state.values]);
  var dirty = useMemo(function() {
    return !reactFastCompare(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid2 = useMemo(function() {
    return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
  }, [isInitialValid, dirty, state.errors, props]);
  var ctx = _extends$4({}, state, {
    initialValues: initialValues.current,
    initialErrors: initialErrors.current,
    initialTouched: initialTouched.current,
    initialStatus: initialStatus.current,
    handleBlur,
    handleChange,
    handleReset,
    handleSubmit,
    resetForm,
    setErrors,
    setFormikState,
    setFieldTouched,
    setFieldValue,
    setFieldError,
    setStatus,
    setSubmitting,
    setTouched,
    setValues,
    submitForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    isValid: isValid2,
    dirty,
    unregisterField,
    registerField,
    getFieldProps,
    getFieldMeta,
    getFieldHelpers,
    validateOnBlur,
    validateOnChange,
    validateOnMount
  });
  return ctx;
}
function Formik(props) {
  var formikbag = useFormik(props);
  var component = props.component, children = props.children, render2 = props.render, innerRef = props.innerRef;
  useImperativeHandle(innerRef, function() {
    return formikbag;
  });
  return createElement(FormikProvider, {
    value: formikbag
  }, component ? createElement(component, formikbag) : render2 ? render2(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? Children.only(children) : null : null);
}
function warnAboutMissingIdentifier(_ref4) {
  var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
}
function yupToFormErrors(yupError) {
  var errors = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors, yupError.path, yupError.message);
    }
    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
      var _ref5;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref5 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref5 = _i.value;
      }
      var err = _ref5;
      if (!getIn(errors, err.path)) {
        errors = setIn(errors, err.path, err.message);
      }
    }
  }
  return errors;
}
function validateYupSchema(values2, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }
  if (context === void 0) {
    context = {};
  }
  var validateData = prepareDataForValidation(values2);
  return schema[sync ? "validateSync" : "validate"](validateData, {
    abortEarly: false,
    context
  });
}
function prepareDataForValidation(values2) {
  var data = Array.isArray(values2) ? [] : {};
  for (var k2 in values2) {
    if (Object.prototype.hasOwnProperty.call(values2, k2)) {
      var key = String(k2);
      if (Array.isArray(values2[key]) === true) {
        data[key] = values2[key].map(function(value) {
          if (Array.isArray(value) === true || isPlainObject(value)) {
            return prepareDataForValidation(value);
          } else {
            return value !== "" ? value : void 0;
          }
        });
      } else if (isPlainObject(values2[key])) {
        data[key] = prepareDataForValidation(values2[key]);
      } else {
        data[key] = values2[key] !== "" ? values2[key] : void 0;
      }
    }
  }
  return data;
}
function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function merge(e2, i2) {
    if (typeof destination[i2] === "undefined") {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e2);
      destination[i2] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options) : e2;
    } else if (options.isMergeableObject(e2)) {
      destination[i2] = deepmerge_1(target[i2], e2, options);
    } else if (target.indexOf(e2) === -1) {
      destination.push(e2);
    }
  });
  return destination;
}
function getSelectedValues(options) {
  return Array.from(options).filter(function(el) {
    return el.selected;
  }).map(function(el) {
    return el.value;
  });
}
function getValueForCheckbox(currentValue, checked, valueProp) {
  if (typeof currentValue === "boolean") {
    return Boolean(checked);
  }
  var currentArrayOfValues = [];
  var isValueInArray = false;
  var index = -1;
  if (!Array.isArray(currentValue)) {
    if (!valueProp || valueProp == "true" || valueProp == "false") {
      return Boolean(checked);
    }
  } else {
    currentArrayOfValues = currentValue;
    index = currentValue.indexOf(valueProp);
    isValueInArray = index >= 0;
  }
  if (checked && valueProp && !isValueInArray) {
    return currentArrayOfValues.concat(valueProp);
  }
  if (!isValueInArray) {
    return currentArrayOfValues;
  }
  return currentArrayOfValues.slice(0, index).concat(currentArrayOfValues.slice(index + 1));
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? useLayoutEffect : useEffect;
function useEventCallback(fn) {
  var ref = useRef(fn);
  useIsomorphicLayoutEffect(function() {
    ref.current = fn;
  });
  return useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current.apply(void 0, args);
  }, []);
}
function Field(_ref) {
  var validate = _ref.validate, name = _ref.name, render2 = _ref.render, children = _ref.children, is = _ref.as, component = _ref.component, props = _objectWithoutPropertiesLoose$1(_ref, ["validate", "name", "render", "children", "as", "component"]);
  var _useFormikContext = useFormikContext(), formik = _objectWithoutPropertiesLoose$1(_useFormikContext, ["validate", "validationSchema"]);
  var registerField = formik.registerField, unregisterField = formik.unregisterField;
  useEffect(function() {
    registerField(name, {
      validate
    });
    return function() {
      unregisterField(name);
    };
  }, [registerField, unregisterField, name, validate]);
  var field = formik.getFieldProps(_extends$4({
    name
  }, props));
  var meta = formik.getFieldMeta(name);
  var legacyBag = {
    field,
    form: formik
  };
  if (render2) {
    return render2(_extends$4({}, legacyBag, {
      meta
    }));
  }
  if (isFunction(children)) {
    return children(_extends$4({}, legacyBag, {
      meta
    }));
  }
  if (component) {
    if (typeof component === "string") {
      var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose$1(props, ["innerRef"]);
      return createElement(component, _extends$4({
        ref: innerRef
      }, field, rest), children);
    }
    return createElement(component, _extends$4({
      field,
      form: formik
    }, props), children);
  }
  var asElement = is || "input";
  if (typeof asElement === "string") {
    var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose$1(props, ["innerRef"]);
    return createElement(asElement, _extends$4({
      ref: _innerRef
    }, field, _rest), children);
  }
  return createElement(asElement, _extends$4({}, field, props), children);
}
var Form = /* @__PURE__ */ forwardRef(function(props, ref) {
  var action = props.action, rest = _objectWithoutPropertiesLoose$1(props, ["action"]);
  var _action = action != null ? action : "#";
  var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
  return createElement("form", Object.assign({
    onSubmit: handleSubmit,
    ref,
    onReset: handleReset,
    action: _action
  }, rest));
});
Form.displayName = "Form";
function connect(Comp) {
  var C2 = function C3(props) {
    return createElement(FormikConsumer, null, function(formik) {
      !!!formik ? warning(false) : void 0;
      return createElement(Comp, Object.assign({}, props, {
        formik
      }));
    });
  };
  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || "Component";
  C2.WrappedComponent = Comp;
  C2.displayName = "FormikConnect(" + componentDisplayName + ")";
  return hoistNonReactStatics_cjs(C2, Comp);
}
var move = function move2(array, from, to) {
  var copy = copyArrayLike(array);
  var value = copy[from];
  copy.splice(from, 1);
  copy.splice(to, 0, value);
  return copy;
};
var swap = function swap2(arrayLike, indexA, indexB) {
  var copy = copyArrayLike(arrayLike);
  var a2 = copy[indexA];
  copy[indexA] = copy[indexB];
  copy[indexB] = a2;
  return copy;
};
var insert = function insert2(arrayLike, index, value) {
  var copy = copyArrayLike(arrayLike);
  copy.splice(index, 0, value);
  return copy;
};
var replace = function replace2(arrayLike, index, value) {
  var copy = copyArrayLike(arrayLike);
  copy[index] = value;
  return copy;
};
var copyArrayLike = function copyArrayLike2(arrayLike) {
  if (!arrayLike) {
    return [];
  } else if (Array.isArray(arrayLike)) {
    return [].concat(arrayLike);
  } else {
    var maxIndex = Object.keys(arrayLike).map(function(key) {
      return parseInt(key);
    }).reduce(function(max, el) {
      return el > max ? el : max;
    }, 0);
    return Array.from(_extends$4({}, arrayLike, {
      length: maxIndex + 1
    }));
  }
};
var FieldArrayInner = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(FieldArrayInner2, _React$Component);
  function FieldArrayInner2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.updateArrayField = function(fn, alterTouched, alterErrors) {
      var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;
      setFormikState(function(prevState) {
        var updateErrors = typeof alterErrors === "function" ? alterErrors : fn;
        var updateTouched = typeof alterTouched === "function" ? alterTouched : fn;
        var values2 = setIn(prevState.values, name, fn(getIn(prevState.values, name)));
        var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : void 0;
        var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : void 0;
        if (isEmptyArray(fieldError)) {
          fieldError = void 0;
        }
        if (isEmptyArray(fieldTouched)) {
          fieldTouched = void 0;
        }
        return _extends$4({}, prevState, {
          values: values2,
          errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,
          touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched
        });
      });
    };
    _this.push = function(value) {
      return _this.updateArrayField(function(arrayLike) {
        return [].concat(copyArrayLike(arrayLike), [cloneDeep(value)]);
      }, false, false);
    };
    _this.handlePush = function(value) {
      return function() {
        return _this.push(value);
      };
    };
    _this.swap = function(indexA, indexB) {
      return _this.updateArrayField(function(array) {
        return swap(array, indexA, indexB);
      }, true, true);
    };
    _this.handleSwap = function(indexA, indexB) {
      return function() {
        return _this.swap(indexA, indexB);
      };
    };
    _this.move = function(from, to) {
      return _this.updateArrayField(function(array) {
        return move(array, from, to);
      }, true, true);
    };
    _this.handleMove = function(from, to) {
      return function() {
        return _this.move(from, to);
      };
    };
    _this.insert = function(index, value) {
      return _this.updateArrayField(function(array) {
        return insert(array, index, value);
      }, function(array) {
        return insert(array, index, null);
      }, function(array) {
        return insert(array, index, null);
      });
    };
    _this.handleInsert = function(index, value) {
      return function() {
        return _this.insert(index, value);
      };
    };
    _this.replace = function(index, value) {
      return _this.updateArrayField(function(array) {
        return replace(array, index, value);
      }, false, false);
    };
    _this.handleReplace = function(index, value) {
      return function() {
        return _this.replace(index, value);
      };
    };
    _this.unshift = function(value) {
      var length = -1;
      _this.updateArrayField(function(array) {
        var arr = array ? [value].concat(array) : [value];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function(array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function(array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      });
      return length;
    };
    _this.handleUnshift = function(value) {
      return function() {
        return _this.unshift(value);
      };
    };
    _this.handleRemove = function(index) {
      return function() {
        return _this.remove(index);
      };
    };
    _this.handlePop = function() {
      return function() {
        return _this.pop();
      };
    };
    _this.remove = _this.remove.bind(_assertThisInitialized$1(_this));
    _this.pop = _this.pop.bind(_assertThisInitialized$1(_this));
    return _this;
  }
  var _proto = FieldArrayInner2.prototype;
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.validateOnChange && this.props.formik.validateOnChange && !reactFastCompare(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {
      this.props.formik.validateForm(this.props.formik.values);
    }
  };
  _proto.remove = function remove(index) {
    var result;
    this.updateArrayField(function(array) {
      var copy = array ? copyArrayLike(array) : [];
      if (!result) {
        result = copy[index];
      }
      if (isFunction(copy.splice)) {
        copy.splice(index, 1);
      }
      return copy;
    }, true, true);
    return result;
  };
  _proto.pop = function pop() {
    var result;
    this.updateArrayField(function(array) {
      var tmp = array;
      if (!result) {
        result = tmp && tmp.pop && tmp.pop();
      }
      return tmp;
    }, true, true);
    return result;
  };
  _proto.render = function render2() {
    var arrayHelpers = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    };
    var _this$props2 = this.props, component = _this$props2.component, render3 = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose$1(_this$props2$formik, ["validate", "validationSchema"]);
    var props = _extends$4({}, arrayHelpers, {
      form: restOfFormik,
      name
    });
    return component ? createElement(component, props) : render3 ? render3(props) : children ? typeof children === "function" ? children(props) : !isEmptyChildren(children) ? Children.only(children) : null : null;
  };
  return FieldArrayInner2;
}(Component$7);
FieldArrayInner.defaultProps = {
  validateOnChange: true
};
var FieldArray = /* @__PURE__ */ connect(FieldArrayInner);
var FastFieldInner = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(FastFieldInner2, _React$Component);
  function FastFieldInner2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    var render2 = props.render, children = props.children, component = props.component, is = props.as;
    props.name;
    !!render2 ? warning(false) : void 0;
    !!(component && render2) ? warning(false) : void 0;
    !!(is && children && isFunction(children)) ? warning(false) : void 0;
    !!(component && children && isFunction(children)) ? warning(false) : void 0;
    !!(render2 && children && !isEmptyChildren(children)) ? warning(false) : void 0;
    return _this;
  }
  var _proto = FastFieldInner2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(props) {
    if (this.props.shouldUpdate) {
      return this.props.shouldUpdate(props, this.props);
    } else if (props.name !== this.props.name || getIn(props.formik.values, this.props.name) !== getIn(this.props.formik.values, this.props.name) || getIn(props.formik.errors, this.props.name) !== getIn(this.props.formik.errors, this.props.name) || getIn(props.formik.touched, this.props.name) !== getIn(this.props.formik.touched, this.props.name) || Object.keys(this.props).length !== Object.keys(props).length || props.formik.isSubmitting !== this.props.formik.isSubmitting) {
      return true;
    } else {
      return false;
    }
  };
  _proto.componentDidMount = function componentDidMount() {
    this.props.formik.registerField(this.props.name, {
      validate: this.props.validate
    });
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.name !== prevProps.name) {
      this.props.formik.unregisterField(prevProps.name);
      this.props.formik.registerField(this.props.name, {
        validate: this.props.validate
      });
    }
    if (this.props.validate !== prevProps.validate) {
      this.props.formik.registerField(this.props.name, {
        validate: this.props.validate
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.formik.unregisterField(this.props.name);
  };
  _proto.render = function render2() {
    var _this$props = this.props, name = _this$props.name, render3 = _this$props.render, is = _this$props.as, children = _this$props.children, component = _this$props.component, formik = _this$props.formik, props = _objectWithoutPropertiesLoose$1(_this$props, ["validate", "name", "render", "as", "children", "component", "shouldUpdate", "formik"]);
    var restOfFormik = _objectWithoutPropertiesLoose$1(formik, ["validate", "validationSchema"]);
    var field = formik.getFieldProps(_extends$4({
      name
    }, props));
    var meta = {
      value: getIn(formik.values, name),
      error: getIn(formik.errors, name),
      touched: !!getIn(formik.touched, name),
      initialValue: getIn(formik.initialValues, name),
      initialTouched: !!getIn(formik.initialTouched, name),
      initialError: getIn(formik.initialErrors, name)
    };
    var bag = {
      field,
      meta,
      form: restOfFormik
    };
    if (render3) {
      return render3(bag);
    }
    if (isFunction(children)) {
      return children(bag);
    }
    if (component) {
      if (typeof component === "string") {
        var innerRef = props.innerRef, rest = _objectWithoutPropertiesLoose$1(props, ["innerRef"]);
        return createElement(component, _extends$4({
          ref: innerRef
        }, field, rest), children);
      }
      return createElement(component, _extends$4({
        field,
        form: formik
      }, props), children);
    }
    var asElement = is || "input";
    if (typeof asElement === "string") {
      var _innerRef = props.innerRef, _rest = _objectWithoutPropertiesLoose$1(props, ["innerRef"]);
      return createElement(asElement, _extends$4({
        ref: _innerRef
      }, field, _rest), children);
    }
    return createElement(asElement, _extends$4({}, field, props), children);
  };
  return FastFieldInner2;
}(Component$7);
var FastField = /* @__PURE__ */ connect(FastFieldInner);
const isDateTime = (type) => {
  switch (type.toLowerCase()) {
    case "timestamp":
    case "timestamptz":
    case "datetime":
      return true;
    default:
      return false;
  }
};
const getInputType = (type) => {
  return isDateTime(type) ? "datetime-local" : type;
};
const getInputValue = (type, value) => {
  if (isDateTime(type)) {
    return value ? value.slice(0, 19) : new Date().toISOString().slice(0, 19);
  }
  if (value === "")
    return null;
  return value;
};
const TextField = ({
  entityName,
  entityField,
  name,
  value,
  label,
  formikProps,
  index
}) => {
  const inputVal = getInputValue(entityField.type, value);
  const inputProps = __spreadProps(__spreadValues({
    fullWidth: true,
    multiline: true,
    name,
    type: getInputType(entityField.type)
  }, entityField.type === "number" ? {
    step: ".01"
  } : {}), {
    required: entityField.required,
    error: !value && entityField.required
  });
  const even = index ? index % 2 == 0 : false;
  return /* @__PURE__ */ jsx(FastField, {
    name,
    children: ({
      field
    }) => {
      formikProps.setFieldValue(name, inputVal);
      return /* @__PURE__ */ jsxs(TableRow, {
        sx: {
          "td, th": {
            border: "none",
            whiteSpace: "break-spaces",
            background: (even || index == 0) && "#F2F3F4"
          },
          "& .MuiTableCell-root:first-of-type": {
            borderTopLeftRadius: "8px",
            borderBottomLeftRadius: "8px"
          },
          "& .MuiTableCell-root:last-child": {
            borderTopRightRadius: "8px",
            borderBottomRightRadius: "8px"
          }
        },
        children: [label && /* @__PURE__ */ jsx(TableCell, {
          sx: {
            width: "50%",
            padding: "14.5px 14px"
          },
          children: /* @__PURE__ */ jsx(Typography, {
            fontSize: "14px",
            children: label
          })
        }), /* @__PURE__ */ jsx(TableCell, {
          sx: {
            fontWeight: 400,
            fontSize: "14px",
            width: "50%",
            textAlign: "left",
            padding: "4px 14px"
          },
          children: /* @__PURE__ */ jsx(Input, __spreadValues(__spreadValues({}, field), inputProps))
        })]
      }, "rowname");
    }
  });
};
const CheckboxField = ({
  entityName,
  entityField,
  name,
  value,
  label,
  index
}) => {
  const inputProps = {
    checked: value
  };
  const even = index ? index % 2 == 0 : false;
  return /* @__PURE__ */ jsx(Field, {
    name,
    children: ({
      field
    }) => {
      return /* @__PURE__ */ jsxs(TableRow, {
        sx: {
          "td, th": {
            border: "none",
            whiteSpace: "break-spaces",
            background: (even || index == 0) && "#F2F3F4"
          },
          "& .MuiTableCell-root:first-of-type": {
            borderTopLeftRadius: "8px",
            borderBottomLeftRadius: "8px"
          },
          "& .MuiTableCell-root:last-child": {
            borderTopRightRadius: "8px",
            borderBottomRightRadius: "8px"
          }
        },
        children: [label && /* @__PURE__ */ jsx(TableCell, {
          sx: {
            width: "100%",
            padding: "5px 16px"
          },
          children: /* @__PURE__ */ jsx(Typography, {
            fontSize: "14px",
            children: label
          })
        }), /* @__PURE__ */ jsx(TableCell, {
          sx: {
            fontWeight: 400,
            fontSize: "14px",
            width: "100%",
            textAlign: "left",
            padding: "4px 16px"
          },
          children: /* @__PURE__ */ jsx(Checkbox$1, __spreadValues(__spreadValues({}, inputProps), field))
        })]
      }, "rowname");
    }
  });
};
const EntityDialog = ({
  name,
  data,
  entityName,
  entityField,
  render: render2 = ({
    children
  }) => {
    return /* @__PURE__ */ jsx(Fragment$1, {
      children
    });
  },
  formikProps
}) => {
  const Render = render2;
  const [open, setOpen] = React__default.useState(false);
  const handleClickOpen = () => {
    setOpen(true);
  };
  const handleClose = () => {
    setOpen(false);
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Render, {
      entityField,
      children: /* @__PURE__ */ jsx(Button$1, {
        variant: "outlined",
        onClick: handleClickOpen,
        children: /* @__PURE__ */ jsx(Translate, {
          entityName,
          fieldName: entityField.name,
          defaultMessage: stringPrettyCapitalize(entityField.name)
        })
      })
    }), /* @__PURE__ */ jsxs(Dialog, {
      fullWidth: true,
      maxWidth: "md",
      open,
      onClose: handleClose,
      children: [/* @__PURE__ */ jsx(DialogTitle, {
        children: /* @__PURE__ */ jsxs(Grid, {
          container: true,
          children: [/* @__PURE__ */ jsx(Grid, {
            item: true,
            xs: true,
            children: /* @__PURE__ */ jsx(Translate, {
              entityName,
              fieldName: entityField.name,
              defaultMessage: stringPrettyCapitalize(entityField.name)
            })
          }), /* @__PURE__ */ jsx(Grid, {
            item: true,
            children: /* @__PURE__ */ jsx(IconButton$1, {
              "aria-label": "close",
              onClick: handleClose,
              children: /* @__PURE__ */ jsx(Close, {})
            })
          })]
        })
      }), /* @__PURE__ */ jsx(DialogContent, {
        children: /* @__PURE__ */ jsx(DialogContentText, {
          children: /* @__PURE__ */ jsx(FormEntityTable, {
            name,
            entityField,
            data,
            formikProps
          })
        })
      })]
    })]
  });
};
const FieldItem = ({
  name,
  value,
  label,
  entityName,
  entityField,
  render: render2,
  formikProps,
  index
}) => {
  if (entityField.type === "array") {
    return /* @__PURE__ */ jsx(EntityDialog, {
      name,
      entityName,
      entityField,
      data: value,
      render: render2,
      formikProps
    });
  } else {
    return formInput({
      entityName,
      entityField,
      name,
      value,
      label,
      render: render2,
      formikProps,
      index
    });
  }
};
const ObjectField = ({
  name,
  value,
  entityName,
  entityField,
  render: render2,
  label,
  formikProps,
  index
}) => {
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: getVisibleFields(entityField.entityFields).map((field) => {
      return /* @__PURE__ */ jsx(FieldItem, {
        name: `${name}.${field.name}`,
        value: value == null ? void 0 : value[field.name],
        label,
        entityName: entityField.name,
        entityField: field,
        render: render2,
        formikProps,
        index
      });
    })
  });
};
const formInput = ({
  entityName,
  entityField,
  name,
  value,
  label,
  index,
  render: render2 = ({
    children
  }) => {
    return /* @__PURE__ */ jsx(Fragment$1, {
      children
    });
  },
  formikProps
}) => {
  const getLabelValue = () => {
    return typeof label === "function" ? label(entityName, entityField.name) : label;
  };
  switch (entityField.type.toLowerCase()) {
    case "boolean":
      return render2({
        entityField,
        children: /* @__PURE__ */ jsx(CheckboxField, {
          entityName,
          entityField,
          name,
          value,
          label: getLabelValue(),
          index
        })
      });
    case "array":
      if (entityField.entityFields) {
        return /* @__PURE__ */ jsx(FormEntityTable, {
          entityField,
          data: value,
          formikProps
        });
      }
    case "object":
      if (entityField.entityFields) {
        return /* @__PURE__ */ jsx(ObjectField, {
          name,
          entityName,
          entityField,
          value,
          render: render2,
          label,
          formikProps,
          index
        });
      }
    case "timestamp":
    case "timestamptz":
    case "datetime":
    case "string":
    case "number":
    case "int":
    case "jsonb":
    case "uuid":
    case "time":
    case "date":
    default:
      return render2({
        entityField,
        children: /* @__PURE__ */ jsx(TextField, {
          entityName,
          entityField,
          name,
          value,
          label: getLabelValue(),
          formikProps,
          index
        })
      });
  }
};
const stringPrettyCapitalize = (inputString) => inputString.replace(/^\w/, (c2) => c2.toUpperCase()).replace(/(\.|_)/g, " ");
const EntityLink = ({
  id: id2,
  label,
  typename
}) => label ? /* @__PURE__ */ jsx("a", {
  href: findPathRoot(typename) + "/" + typename + "/" + (id2 == null ? void 0 : id2.toString()),
  children: /* @__PURE__ */ jsx(Chip$1, {
    label,
    color: "primary"
  })
}) : /* @__PURE__ */ jsx(Fragment$1, {});
const isArray$2 = (fieldType) => fieldType === "Array" || fieldType === "array";
const isObject$4 = (fieldType) => fieldType === "Object" || fieldType === "object";
const containsAttributes = (field) => {
  var _a2;
  return (_a2 = field == null ? void 0 : field.name) != null ? _a2 : field == null ? void 0 : field.title;
};
const deepSearchEntityFields = (wantedField, entityFields) => {
  var _a2, _b, _c, _d, _e;
  return (_e = (_d = (_b = (_a2 = entityFields == null ? void 0 : entityFields.fields) == null ? void 0 : _a2.find((field) => (field == null ? void 0 : field.name) === wantedField)) == null ? void 0 : _b.entityFields) != null ? _d : (_c = entityFields == null ? void 0 : entityFields.fields) == null ? void 0 : _c.filter((field) => isArray$2(field == null ? void 0 : field.type)).map((mappedField) => deepSearchEntityFields(wantedField, mappedField == null ? void 0 : mappedField.entityFields)).find((foundField) => (foundField == null ? void 0 : foundField.name) === wantedField)) != null ? _e : entityFields;
};
const guessEntityFieldTitle = (currentField, entityFields) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  if ((currentField == null ? void 0 : currentField.__typename) !== entityFields.name) {
    entityFields = deepSearchEntityFields(currentField == null ? void 0 : currentField.__typename, entityFields);
  }
  const name = containsAttributes(currentField);
  if (!name) {
    const nestedObject = (_e = (_b = (_a2 = entityFields == null ? void 0 : entityFields.fields) == null ? void 0 : _a2.find((field) => isObject$4(field == null ? void 0 : field.type))) == null ? void 0 : _b.name) != null ? _e : (_d = (_c = entityFields == null ? void 0 : entityFields.fields) == null ? void 0 : _c.find((field) => isArray$2(field == null ? void 0 : field.type))) == null ? void 0 : _d.name;
    if (nestedObject) {
      if ((_f = currentField == null ? void 0 : currentField[nestedObject]) == null ? void 0 : _f.length) {
        return currentField[nestedObject].map((arrayField) => /* @__PURE__ */ jsx(EntityLink, {
          id: arrayField == null ? void 0 : arrayField.id,
          label: containsAttributes(arrayField),
          typename: arrayField == null ? void 0 : arrayField.__typename
        }));
      } else {
        return /* @__PURE__ */ jsx(EntityLink, {
          id: (_g = currentField == null ? void 0 : currentField[nestedObject]) == null ? void 0 : _g.id,
          label: containsAttributes(currentField == null ? void 0 : currentField[nestedObject]),
          typename: (_h = currentField == null ? void 0 : currentField[nestedObject]) == null ? void 0 : _h.__typename
        });
      }
    } else {
      return "";
    }
  } else {
    return /* @__PURE__ */ jsx(EntityLink, {
      id: currentField == null ? void 0 : currentField.id,
      label: name,
      typename: currentField == null ? void 0 : currentField.__typename
    });
  }
};
const dateFormatFunctionTemplate = (intl) => ({ value }) => value ? intl.formatDate(value) : "";
const dateTimeFormatTemplate = (intl) => ({ value }) => value ? `${intl.formatDate(value)}, ${intl.formatTime(value)}` : "";
const timeFormatTemplate = (intl) => ({ value }) => (value == null ? void 0 : value.substring(0, "00:00:00".length)) || "";
const basicFormatTemplate = (intl) => ({ value }) => value;
const arrayFormatTemplate = (intl, entityFields) => ({ value }) => {
  var _a2;
  const names = (_a2 = value == null ? void 0 : value.map((field) => {
    var _a3, _b;
    return (_b = (_a3 = field == null ? void 0 : field.name) != null ? _a3 : field == null ? void 0 : field.title) != null ? _b : field == null ? void 0 : field.id;
  })) != null ? _a2 : [];
  return names.length ? names.join(", ") : "";
};
const objectFormatTemplate = (intl, entityFields) => ({ value }) => guessEntityFieldTitle(value, entityFields);
const valueFormatterFunction = (type, intl, entityFields) => {
  switch (type.toLowerCase()) {
    case "string":
    case "number":
    case "int":
    case "jsonb":
    case "uuid":
      return basicFormatTemplate();
    case "boolean":
      return booleanFormatTemplate;
    case "date":
      return dateFormatFunctionTemplate(intl);
    case "datetime":
    case "timestamp":
    case "timestamptz":
      return dateTimeFormatTemplate(intl);
    case "time":
    case "timez":
      return timeFormatTemplate();
    case "array":
      return arrayFormatTemplate();
    case "object":
      return objectFormatTemplate(intl, entityFields);
    default:
      return basicFormatTemplate();
  }
};
const sortQueryFromGridData = (sort) => {
  let sortQuery = {};
  const sortModels = sortModelFromDataGrid(sort);
  sortModels.forEach((sortModel) => {
    const sortColumnFiled = sortModel == null ? void 0 : sortModel.field;
    const sortValue = sortModel == null ? void 0 : sortModel.sort;
    sortQuery = sortRelationships(sortColumnFiled, sortValue);
  });
  return sortQuery;
};
const sortModelFromDataGrid = (sort) => {
  const sortModel = sort;
  if (sortModel)
    return sortModel;
  return {};
};
const sortRelationships = (sortColumnField, sortValue) => {
  let tables = sortColumnField.split(".");
  const lastTable = tables.pop();
  let query = {};
  if (!lastTable) {
    query[sortColumnField] = sortValue;
    return query;
  }
  query[lastTable] = sortValue;
  tables.reverse().forEach((table) => {
    const oldQuery = query;
    query = {};
    query[table] = oldQuery;
  });
  return query;
};
const controlNextButton = (options) => {
  if (options.data.length <= options.pageSize) {
    hideNextButtonPagination(options.hideNextButton, options.setCountToRows, options.setHideNextButton, options.page);
  } else {
    showNextButtonPagination(options.countRows, options.setCountToRows, options.setHideNextButton, options.pageSize);
  }
};
const hideNextButtonPagination = (hideNextButton, setCountToRows, setHideNextButton, page) => {
  if (hideNextButton === false) {
    setCountToRows(page);
  }
  setHideNextButton(true);
};
const showNextButtonPagination = (countRows, setCountToRows, setHideNextButton, pageSize) => {
  if (!setCountToRows)
    return;
  setCountToRows(countRows + pageSize);
  setHideNextButton(false);
};
const controlSiblings = (data, pageSize, page, setSiblingCount) => {
  if (data.length < pageSize * 2 && page === 1) {
    return setSiblingCount(0);
  }
  return setSiblingCount(1);
};
const InputFilterInteger = (props) => {
  var _a2, _b, _c;
  const {
    item,
    applyValue
  } = props;
  const handleFilterChange = (event) => {
    const inputTargetValue = event.target.value.replace(/[^0-9]/g, "");
    applyValue(__spreadProps(__spreadValues({}, item), {
      value: inputTargetValue
    }));
  };
  const columnStates = (_b = (_a2 = props == null ? void 0 : props.apiRef) == null ? void 0 : _a2.current) == null ? void 0 : _b.state;
  const columns = (_c = columnStates == null ? void 0 : columnStates.columns) == null ? void 0 : _c.lookup;
  const columnFieldValue = () => {
    return item == null ? void 0 : item.columnField;
  };
  const columnTypeFromGraphQl = () => {
    const columnFieldName = columnFieldValue();
    return columns[columnFieldName].columnType;
  };
  const maxLength = () => {
    const columnType = columnTypeFromGraphQl();
    if (columnType === "Int") {
      return 9;
    }
    return 19;
  };
  return /* @__PURE__ */ jsx(TextField$1, {
    label: "Number",
    type: "tel",
    value: (item == null ? void 0 : item.value) || "",
    inputProps: {
      maxLength: maxLength()
    },
    onChange: handleFilterChange
  });
};
const getNumberFilterOperator = (filter2) => {
  const filterValue = filterValueFromDataGrid(filter2);
  const operatorValues = [
    {
      dataGrid: "=",
      graphQl: { _eq: filterValue }
    },
    {
      dataGrid: "!=",
      graphQl: { _neq: filterValue }
    },
    {
      dataGrid: ">",
      graphQl: { _gt: filterValue }
    },
    {
      dataGrid: "<",
      graphQl: { _lt: filterValue }
    },
    {
      dataGrid: ">=",
      graphQl: { _gte: filterValue }
    },
    {
      dataGrid: "<=",
      graphQl: { _lte: filterValue }
    }
  ];
  return operatorValues;
};
const getStringFilterOperator = (filter2) => {
  const filterValue = filterValueFromDataGrid(filter2);
  const operatorValues = [
    {
      dataGrid: "contains",
      graphQl: { _ilike: "%" + filterValue + "%" }
    },
    {
      dataGrid: "equals",
      graphQl: { _eq: filterValue }
    },
    {
      dataGrid: "startsWith",
      graphQl: { _ilike: filterValue + "%" }
    },
    {
      dataGrid: "endsWith",
      graphQl: { _ilike: "%" + filterValue }
    }
  ];
  return operatorValues;
};
const currentTimeData = () => {
  return new Date();
};
const timeZoneValue = () => {
  return currentTimeData().toString().split("GMT")[1].slice(0, 5);
};
const getDateFilterOperator = (filter2) => {
  const filterValue = filterValueFromDataGrid(filter2);
  const filterColumnField2 = filterColumnFieldFromDataGrid(filter2);
  const timeZone = timeZoneValue();
  const operatorValues = [
    {
      dataGrid: "is",
      graphQl: {
        dateTime: {
          _gte: filterValue + ":00.00000" + timeZone,
          _lte: filterValue + ":60.00000" + timeZone
        },
        date: {
          _gte: filterValue + "T00:00:00.00000" + timeZone,
          _lte: filterValue + "T24:00:00.00000" + timeZone
        }
      }
    },
    {
      dataGrid: "not",
      graphQl: {
        dateTime: [
          {
            [filterColumnField2]: { _gt: filterValue + ":60.00000" + timeZone }
          },
          {
            [filterColumnField2]: { _lt: filterValue + ":00.00000" + timeZone }
          }
        ],
        date: [
          { [filterColumnField2]: { _gt: filterValue + "T24:00:00" } },
          { [filterColumnField2]: { _lt: filterValue + "T00:00:00" } }
        ]
      }
    },
    {
      dataGrid: "before",
      graphQl: {
        dateTime: { _lt: filterValue + ":00.00000" + timeZone },
        date: { _lt: filterValue + "T00:00:00.00000" + timeZone }
      }
    },
    {
      dataGrid: "after",
      graphQl: {
        dateTime: { _gt: filterValue + ":60.00000" + timeZone },
        date: { _gt: filterValue + "T24:00:00.00000" + timeZone }
      }
    },
    {
      dataGrid: "onOrBefore",
      graphQl: {
        dateTime: { _lte: filterValue + ":60.00000" + timeZone },
        date: { _lte: filterValue + "T24:00:00.00000" + timeZone }
      }
    },
    {
      dataGrid: "onOrAfter",
      graphQl: {
        dateTime: { _gte: filterValue + ":00.00000" + timeZone },
        date: { _gte: filterValue + "T00:00:00.00000" + timeZone }
      }
    }
  ];
  return operatorValues;
};
const getBooleanFilterOperator = (filter2) => {
  const filterValue = filterValueFromDataGrid(filter2);
  const operatorValues = [
    {
      dataGrid: "is",
      graphQl: { _eq: filterValue }
    },
    {
      dataGrid: "not",
      graphQl: { _neq: filterValue }
    }
  ];
  return operatorValues;
};
const filterDataGrid = (filter2, columns) => {
  const filteredValue = filterValueFromDataGrid(filter2);
  if (filteredValue) {
    return getQueryFromDataGrid(filter2, columns);
  }
  return;
};
const getQueryFromDataGrid = (filter2, columns) => {
  var _a2;
  let filteredQueryForGraphQl = {};
  const columnDataByFilterColumnField = getColumnDataByFilterColumnField(filter2, columns);
  const filterDataType = (_a2 = columnDataByFilterColumnField[0]) == null ? void 0 : _a2.type;
  filteredQueryForGraphQl = filterDataByColumnTypeName(filter2, columns, filterDataType, filteredQueryForGraphQl);
  return filteredQueryForGraphQl;
};
const filterDataByColumnTypeName = (filter2, columns, filterDataType, filteredQueryForGraphQl) => {
  if (filterDataType === "string") {
    filteredQueryForGraphQl = getFilterGraphQlQuery(filter2, columns, filteredQueryForGraphQl, getStringFilterOperator(filter2));
  } else if (filterDataType === "number") {
    filteredQueryForGraphQl = getFilterGraphQlQuery(filter2, columns, filteredQueryForGraphQl, getNumberFilterOperator(filter2));
  } else if (filterDataType === "boolean" || filterDataType === "singleSelect") {
    filteredQueryForGraphQl = getFilterGraphQlQuery(filter2, columns, filteredQueryForGraphQl, getBooleanFilterOperator(filter2));
  } else if (filterDataType === "date" || filterDataType === "dateTime") {
    filteredQueryForGraphQl = getFilterGraphQlQuery(filter2, columns, filteredQueryForGraphQl, getDateFilterOperator(filter2));
  }
  return filteredQueryForGraphQl;
};
const getFilterGraphQlQuery = (filter2, columns, filteredQueryForGraphQl, getTypeFilterOperator) => {
  var _a2, _b;
  const filterOperatorList = getTypeFilterOperator;
  const currentOperatorFromDataGrid = filterOperatorList.filter((operator) => operator.dataGrid === filterOperatorFromDataGrid(filter2));
  const filterDataType = (_a2 = getColumnDataByFilterColumnField(filter2, columns)[0]) == null ? void 0 : _a2.type;
  const graphQlQuery = (_b = currentOperatorFromDataGrid[0]) == null ? void 0 : _b.graphQl;
  if (filterDataType === "date") {
    filteredQueryForGraphQl = dateAndDateTime(filter2, filteredQueryForGraphQl, graphQlQuery, "date");
  } else if (filterDataType === "dateTime") {
    filteredQueryForGraphQl = dateAndDateTime(filter2, filteredQueryForGraphQl, graphQlQuery, "dateTime");
  } else {
    filteredQueryForGraphQl = filterRelationships(filter2, graphQlQuery);
  }
  return filteredQueryForGraphQl;
};
const filterRelationships = (filter2, graphQlQuery) => {
  const columnName = filterColumnFieldFromDataGrid(filter2);
  const names = columnName.split(".");
  let filteredQuery = {};
  let objectQuery = graphQlQuery;
  names.reverse().forEach((name) => {
    filteredQuery[name] = objectQuery;
    objectQuery = filteredQuery;
    filteredQuery = {};
  });
  return objectQuery;
};
const dateAndDateTime = (filter2, filteredQueryForGraphQl, graphQlQuery, dateType) => {
  if (filterOperatorFromDataGrid(filter2) === "not") {
    filteredQueryForGraphQl["_or"] = graphQlQuery[dateType];
  } else {
    filteredQueryForGraphQl = filterRelationships(filter2, graphQlQuery[dateType]);
  }
  return filteredQueryForGraphQl;
};
const filterColumnField = (filterModel) => {
  console.log(filterModel, "filterModel");
  if (filterModel) {
    return filterModel == null ? void 0 : filterModel.columnField;
  }
  return "";
};
const filterColumnOperator = (filterModel) => {
  if (filterModel) {
    return filterModel == null ? void 0 : filterModel.operatorValue;
  }
  return "";
};
const getColumnDataByFilterColumnField = (filter2, columns) => {
  if (columns) {
    return columns.filter((column) => column.field === filterColumnFieldFromDataGrid(filter2));
  }
  return [];
};
const filterModelFromDataGrid = (filter2) => {
  if (filter2) {
    return filter2 == null ? void 0 : filter2.items;
  }
  return [];
};
const filterColumnFieldFromDataGrid = (filter2) => {
  const filterModels = filterModelFromDataGrid(filter2);
  for (const filterModel of filterModels) {
    return filterColumnField(filterModel);
  }
  return "";
};
const filterOperatorFromDataGrid = (filter2) => {
  const filterModels = filterModelFromDataGrid(filter2);
  for (const filterModel of filterModels) {
    return filterColumnOperator(filterModel);
  }
  return "";
};
const filterValueFromDataGrid = (filter2) => {
  const filterModels = filterModelFromDataGrid(filter2);
  for (const filterModel of filterModels) {
    const filteredValue = filterModel == null ? void 0 : filterModel.value;
    if (filteredValue)
      return filteredValue;
  }
  return "";
};
const numberColumnType = getGridNumericColumnOperators().map((operator) => __spreadProps(__spreadValues({}, operator), {
  InputComponent: InputFilterInteger
}));
const createUuidColumnType = {
  extendType: "string",
  filterOperators: getGridStringOperators().filter((operator) => operator.value === "equals").map((operator) => {
    return __spreadValues({}, operator);
  })
};
const uuidColumnType = () => {
  if (createUuidColumnType) {
    return createUuidColumnType == null ? void 0 : createUuidColumnType.filterOperators;
  }
  return [];
};
const tableColumnTypes = [
  {
    graphQl: "Int",
    dataGrid: "number"
  },
  {
    graphQl: "BigInteger",
    dataGrid: "number"
  },
  {
    graphQl: "time",
    dataGrid: "dateTime"
  },
  {
    graphQl: "timestamp",
    dataGrid: "dateTime"
  }
];
const dataGridColumnType = (eFType) => {
  const tableColumnType = getTableColumnType(eFType);
  const eFColumnType = eFType.toLowerCase();
  if (tableColumnType.length > 0) {
    return tableColumnTypeValue(tableColumnType);
  }
  return eFColumnType;
};
const tableColumnTypeValue = (tableColumnType) => {
  for (const columnType of tableColumnType) {
    return columnType.dataGrid;
  }
};
const getTableColumnType = (eFType) => {
  if (eFType) {
    return tableColumnTypes.filter((columnType) => columnType.graphQl === eFType);
  }
  return [];
};
const SelectPerPage = (props) => {
  const {
    pageSize,
    handlePageSize
  } = props;
  return /* @__PURE__ */ jsx(Box, {
    textAlign: "center",
    marginTop: "15px",
    children: /* @__PURE__ */ jsxs(Select, {
      value: pageSize,
      onChange: handlePageSize,
      children: [/* @__PURE__ */ jsx(MenuItem$1, {
        value: 10,
        children: "10"
      }), /* @__PURE__ */ jsx(MenuItem$1, {
        value: 20,
        children: "20"
      }), /* @__PURE__ */ jsx(MenuItem$1, {
        value: 25,
        children: "25"
      })]
    })
  });
};
const TablePagination = (props) => {
  const {
    countRows,
    page,
    handlePage,
    siblingCount,
    hideNextButton
  } = props;
  return /* @__PURE__ */ jsx(Box, {
    margin: "auto",
    width: "fit-content",
    children: /* @__PURE__ */ jsx(Pagination, {
      count: countRows,
      page,
      onChange: handlePage,
      boundaryCount: 0,
      siblingCount,
      hideNextButton,
      showFirstButton: true
    })
  });
};
const addCustomFilterOpperations = (columns) => {
  columns == null ? void 0 : columns.forEach((column) => {
    if ((column == null ? void 0 : column.type) === "number") {
      column.filterOperators = numberColumnType;
    }
  });
};
const Toolbar = ({
  props,
  searchText,
  setSearchText
}) => {
  return /* @__PURE__ */ jsxs(Grid, {
    container: true,
    wrap: "nowrap",
    justifyContent: "center",
    style: {
      padding: "16px 16px 0"
    },
    children: [props.onClickCreate && /* @__PURE__ */ jsx(Button$1, {
      startIcon: /* @__PURE__ */ jsx(Add, {}),
      color: "primary",
      variant: "contained",
      onClick: props.onClickCreate,
      sx: {
        mr: "10px"
      },
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "Create"
      })
    }), /* @__PURE__ */ jsx(Translate, {
      entityName: "Search...",
      children: (value) => /* @__PURE__ */ jsx(TextField$2, {
        variant: "outlined",
        value: searchText,
        onChange: (event) => {
          setSearchText(event.target.value);
        },
        placeholder: value,
        sx: {
          width: "100%",
          "& .MuiOutlinedInput-input": {
            fontWeight: 400,
            fontSize: "14px"
          }
        }
      })
    }), /* @__PURE__ */ jsx(Button$1, {
      sx: {
        ml: "10px"
      },
      color: "primary",
      variant: "contained",
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "Search"
      })
    })]
  });
};
const isArray$1 = (fieldType) => fieldType === "Array" || fieldType === "array";
const isObject$3 = (fieldType) => fieldType === "Object" || fieldType === "object";
const isLeaf = (field) => (field == null ? void 0 : field.name) && (field == null ? void 0 : field.name) !== "id" && !isArray$1(field == null ? void 0 : field.type) && !isObject$3(field == null ? void 0 : field.type);
const translateNestedField = (currentField, entityName) => {
  var _a2, _b, _c, _d;
  if (isArray$1(currentField == null ? void 0 : currentField.type) || isObject$3(currentField == null ? void 0 : currentField.type)) {
    const objectWithName = (_b = (_a2 = currentField == null ? void 0 : currentField.entityFields) == null ? void 0 : _a2.fields) == null ? void 0 : _b.find((field) => isLeaf(field));
    if (objectWithName) {
      return {
        fieldName: objectWithName.name,
        entityName: currentField.name
      };
    } else {
      const nestedObject = (_d = (_c = currentField == null ? void 0 : currentField.entityFields) == null ? void 0 : _c.fields) == null ? void 0 : _d.find((field) => isObject$3(field == null ? void 0 : field.type) || isArray$1(field == null ? void 0 : field.type));
      if (nestedObject) {
        return translateNestedField(nestedObject, currentField.name);
      } else {
        return { fieldName: currentField.name, entityName };
      }
    }
  }
  return { fieldName: currentField == null ? void 0 : currentField.name, entityName };
};
const isObject$2 = (fieldType) => fieldType === "Object" || fieldType === "object";
const isArray = (fieldType) => fieldType === "Array" || fieldType === "array";
const objectRelations = (props) => {
  var _a2, _b, _c, _d;
  let column = 0;
  while ((_a2 = props.entityFields) == null ? void 0 : _a2.fields[column]) {
    const field = (_b = props.entityFields) == null ? void 0 : _b.fields[column];
    if (isObject$2(field.type) || isArray(field.type)) {
      const fields = (_c = field.entityFields) == null ? void 0 : _c.fields.map((nestedField) => {
        if (nestedField.name !== "id") {
          const nestedName = field.name + "." + nestedField.name;
          props.data.map((eF) => {
            var _a3;
            return eF[nestedName] = (_a3 = eF[field.name]) == null ? void 0 : _a3[nestedField.name];
          });
          nestedField.name = nestedName;
          return nestedField;
        }
        return null;
      }).filter((field2) => field2 !== null);
      (_d = props.entityFields) == null ? void 0 : _d.fields.splice(column, 1, ...fields);
      column += (fields == null ? void 0 : fields.length) - 1;
    } else {
      column++;
    }
  }
  return props;
};
const columnFromField = (field) => {
  const intl = useIntl();
  return {
    field: field.name,
    flex: 1,
    type: field.type,
    valueFormatter: valueFormatterFunction(field.type, intl),
    renderHeader: () => {
      var _a2;
      return /* @__PURE__ */ jsx(Translate, {
        entityName: ((_a2 = field.entityFields) == null ? void 0 : _a2.name) || "",
        fieldName: field.name
      });
    }
  };
};
var lib$a = { exports: {} };
var hasProperty = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};
var _apply;
function _classPrivateFieldLooseBase$9(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$9 = 0;
function _classPrivateFieldLooseKey$9(name) {
  return "__private_" + id$9++ + "_" + name;
}
const has2 = hasProperty;
function insertReplacement(source, rx, replacement) {
  const newParts = [];
  source.forEach((chunk) => {
    if (typeof chunk !== "string") {
      return newParts.push(chunk);
    }
    return rx[Symbol.split](chunk).forEach((raw, i2, list) => {
      if (raw !== "") {
        newParts.push(raw);
      }
      if (i2 < list.length - 1) {
        newParts.push(replacement);
      }
    });
  });
  return newParts;
}
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */
function interpolate(phrase, options) {
  const dollarRegex = /\$/g;
  const dollarBillsYall = "$$$$";
  let interpolated = [phrase];
  if (options == null)
    return interpolated;
  for (const arg of Object.keys(options)) {
    if (arg !== "_") {
      let replacement = options[arg];
      if (typeof replacement === "string") {
        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
      }
      interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, "g"), replacement);
    }
  }
  return interpolated;
}
var Translator_1 = (_apply = /* @__PURE__ */ _classPrivateFieldLooseKey$9("apply"), class Translator {
  constructor(locales) {
    Object.defineProperty(this, _apply, {
      value: _apply2
    });
    this.locale = {
      strings: {},
      pluralize(n2) {
        if (n2 === 1) {
          return 0;
        }
        return 1;
      }
    };
    if (Array.isArray(locales)) {
      locales.forEach(_classPrivateFieldLooseBase$9(this, _apply)[_apply], this);
    } else {
      _classPrivateFieldLooseBase$9(this, _apply)[_apply](locales);
    }
  }
  translate(key, options) {
    return this.translateArray(key, options).join("");
  }
  translateArray(key, options) {
    if (!has2(this.locale.strings, key)) {
      throw new Error(`missing string: ${key}`);
    }
    const string = this.locale.strings[key];
    const hasPluralForms = typeof string === "object";
    if (hasPluralForms) {
      if (options && typeof options.smart_count !== "undefined") {
        const plural = this.locale.pluralize(options.smart_count);
        return interpolate(string[plural], options);
      }
      throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
    }
    return interpolate(string, options);
  }
});
function _apply2(locale2) {
  if (!(locale2 != null && locale2.strings)) {
    return;
  }
  const prevLocale = this.locale;
  this.locale = __spreadProps(__spreadValues({}, prevLocale), {
    strings: __spreadValues(__spreadValues({}, prevLocale.strings), locale2.strings)
  });
  this.locale.pluralize = locale2.pluralize || prevLocale.pluralize;
}
var namespaceEmitter = function createNamespaceEmitter() {
  var emitter = {};
  var _fns = emitter._fns = {};
  emitter.emit = function emit(event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event);
    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6]);
    }
  };
  emitter.on = function on(event, fn) {
    if (!_fns[event]) {
      _fns[event] = [];
    }
    _fns[event].push(fn);
  };
  emitter.once = function once(event, fn) {
    function one() {
      fn.apply(this, arguments);
      emitter.off(event, one);
    }
    this.on(event, one);
  };
  emitter.off = function off(event, fn) {
    var keep = [];
    if (event && fn) {
      var fns = this._fns[event];
      var i2 = 0;
      var l2 = fns ? fns.length : 0;
      for (i2; i2 < l2; i2++) {
        if (fns[i2] !== fn) {
          keep.push(fns[i2]);
        }
      }
    }
    keep.length ? this._fns[event] = keep : delete this._fns[event];
  };
  function getListeners(e2) {
    var out = _fns[e2] ? _fns[e2] : [];
    var idx = e2.indexOf(":");
    var args = idx === -1 ? [e2] : [e2.substring(0, idx), e2.substring(idx + 1)];
    var keys2 = Object.keys(_fns);
    var i2 = 0;
    var l2 = keys2.length;
    for (i2; i2 < l2; i2++) {
      var key = keys2[i2];
      if (key === "*") {
        out = out.concat(_fns[key]);
      }
      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key]);
        break;
      }
    }
    return out;
  }
  function emitAll(e2, fns, args) {
    var i2 = 0;
    var l2 = fns.length;
    for (i2; i2 < l2; i2++) {
      if (!fns[i2])
        break;
      fns[i2].event = e2;
      fns[i2].apply(fns[i2], args);
    }
  }
  return emitter;
};
let urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id2 = "";
    let i2 = size;
    while (i2--) {
      id2 += alphabet[Math.random() * alphabet.length | 0];
    }
    return id2;
  };
};
let nanoid$3 = (size = 21) => {
  let id2 = "";
  let i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var nonSecure = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nanoid: nanoid$3,
  customAlphabet
}, Symbol.toStringTag, { value: "Module" }));
var require$$9 = /* @__PURE__ */ getAugmentedNamespace(nonSecure);
var FUNC_ERROR_TEXT$1 = "Expected a function";
var NAN$1 = 0 / 0;
var symbolTag$1 = "[object Symbol]";
var reTrim$1 = /^\s+|\s+$/g;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
var objectProto$1 = Object.prototype;
var objectToString$1 = objectProto$1.toString;
var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
var now$1 = function() {
  return root$1.Date.now();
};
function debounce$3(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function throttle$3(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$1(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$3(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
}
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$1(value)) {
    return NAN$1;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, "");
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var lodash_throttle = throttle$3;
var prettierBytes$3 = function prettierBytes(num) {
  if (typeof num !== "number" || isNaN(num)) {
    throw new TypeError("Expected a number, got " + typeof num);
  }
  var neg = num < 0;
  var units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  if (neg) {
    num = -num;
  }
  if (num < 1) {
    return (neg ? "-" : "") + num + " B";
  }
  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
  num = Number(num / Math.pow(1024, exponent));
  var unit = units[exponent];
  if (num >= 10 || num % 1 === 0) {
    return (neg ? "-" : "") + num.toFixed(0) + " " + unit;
  } else {
    return (neg ? "-" : "") + num.toFixed(1) + " " + unit;
  }
};
function WildcardMatcher(text, separator2) {
  this.text = text = text || "";
  this.hasWild = ~text.indexOf("*");
  this.separator = separator2;
  this.parts = text.split(separator2);
}
WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;
  if (typeof input == "string" || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || "").split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === "*") {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }
      matches = matches && testParts;
    }
  } else if (typeof input.splice == "function") {
    matches = [];
    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  } else if (typeof input == "object") {
    matches = {};
    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }
  return matches;
};
var wildcard$1 = function(text, test, separator2) {
  var matcher = new WildcardMatcher(text, separator2 || /[\/\.]/);
  if (typeof test != "undefined") {
    return matcher.match(test);
  }
  return matcher;
};
var wildcard = wildcard$1;
var reMimePartSplit = /[\/\+\.]/;
var mimeMatch = function(target, pattern) {
  function test(pattern2) {
    var result = wildcard(pattern2, target, reMimePartSplit);
    return result && result.length >= 2;
  }
  return pattern ? test(pattern.split(";")[0]) : test;
};
function _classPrivateFieldLooseBase$8(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$8 = 0;
function _classPrivateFieldLooseKey$8(name) {
  return "__private_" + id$8++ + "_" + name;
}
var _publish = /* @__PURE__ */ _classPrivateFieldLooseKey$8("publish");
class DefaultStore$1 {
  constructor() {
    Object.defineProperty(this, _publish, {
      value: _publish2
    });
    this.state = {};
    this.callbacks = [];
  }
  getState() {
    return this.state;
  }
  setState(patch) {
    const prevState = __spreadValues({}, this.state);
    const nextState = __spreadValues(__spreadValues({}, this.state), patch);
    this.state = nextState;
    _classPrivateFieldLooseBase$8(this, _publish)[_publish](prevState, nextState, patch);
  }
  subscribe(listener) {
    this.callbacks.push(listener);
    return () => {
      this.callbacks.splice(this.callbacks.indexOf(listener), 1);
    };
  }
}
function _publish2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  this.callbacks.forEach((listener) => {
    listener(...args);
  });
}
DefaultStore$1.VERSION = "2.0.3";
var lib$9 = function defaultStore() {
  return new DefaultStore$1();
};
var getFileNameAndExtension$2 = function getFileNameAndExtension(fullFileName) {
  const lastDot = fullFileName.lastIndexOf(".");
  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: void 0
    };
  }
  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};
var mimeTypes$1 = {
  md: "text/markdown",
  markdown: "text/markdown",
  mp4: "video/mp4",
  mp3: "audio/mp3",
  svg: "image/svg+xml",
  jpg: "image/jpeg",
  png: "image/png",
  gif: "image/gif",
  heic: "image/heic",
  heif: "image/heif",
  yaml: "text/yaml",
  yml: "text/yaml",
  csv: "text/csv",
  tsv: "text/tab-separated-values",
  tab: "text/tab-separated-values",
  avi: "video/x-msvideo",
  mks: "video/x-matroska",
  mkv: "video/x-matroska",
  mov: "video/quicktime",
  doc: "application/msword",
  docm: "application/vnd.ms-word.document.macroenabled.12",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  dot: "application/msword",
  dotm: "application/vnd.ms-word.template.macroenabled.12",
  dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  xla: "application/vnd.ms-excel",
  xlam: "application/vnd.ms-excel.addin.macroenabled.12",
  xlc: "application/vnd.ms-excel",
  xlf: "application/x-xliff+xml",
  xlm: "application/vnd.ms-excel",
  xls: "application/vnd.ms-excel",
  xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
  xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xlt: "application/vnd.ms-excel",
  xltm: "application/vnd.ms-excel.template.macroenabled.12",
  xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  xlw: "application/vnd.ms-excel",
  txt: "text/plain",
  text: "text/plain",
  conf: "text/plain",
  log: "text/plain",
  pdf: "application/pdf",
  zip: "application/zip",
  "7z": "application/x-7z-compressed",
  rar: "application/x-rar-compressed",
  tar: "application/x-tar",
  gz: "application/gzip",
  dmg: "application/x-apple-diskimage"
};
const getFileNameAndExtension$1 = getFileNameAndExtension$2;
const mimeTypes = mimeTypes$1;
var getFileType$1 = function getFileType(file) {
  var _getFileNameAndExtens;
  if (file.type)
    return file.type;
  const fileExtension2 = file.name ? (_getFileNameAndExtens = getFileNameAndExtension$1(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;
  if (fileExtension2 && fileExtension2 in mimeTypes) {
    return mimeTypes[fileExtension2];
  }
  return "application/octet-stream";
};
function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}
function encodeFilename(name) {
  let suffix = "";
  return name.replace(/[^A-Z0-9]/ig, (character) => {
    suffix += `-${encodeCharacter(character)}`;
    return "/";
  }) + suffix;
}
var generateFileID$1 = function generateFileID(file) {
  let id2 = "uppy";
  if (typeof file.name === "string") {
    id2 += `-${encodeFilename(file.name.toLowerCase())}`;
  }
  if (file.type !== void 0) {
    id2 += `-${file.type}`;
  }
  if (file.meta && typeof file.meta.relativePath === "string") {
    id2 += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
  }
  if (file.data.size !== void 0) {
    id2 += `-${file.data.size}`;
  }
  if (file.data.lastModified !== void 0) {
    id2 += `-${file.data.lastModified}`;
  }
  return id2;
};
var supportsUploadProgress$1 = function supportsUploadProgress(userAgent) {
  if (userAgent == null) {
    userAgent = typeof navigator !== "undefined" ? navigator.userAgent : null;
  }
  if (!userAgent)
    return true;
  const m2 = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m2)
    return true;
  const edgeVersion = m2[1];
  let [major, minor] = edgeVersion.split(".");
  major = parseInt(major, 10);
  minor = parseInt(minor, 10);
  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  }
  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  }
  return false;
};
var getFileName$1 = function getFileName(fileType, fileDescriptor) {
  if (fileDescriptor.name) {
    return fileDescriptor.name;
  }
  if (fileType.split("/")[0] === "image") {
    return `${fileType.split("/")[0]}.${fileType.split("/")[1]}`;
  }
  return "noname";
};
function pad(number) {
  return number < 10 ? `0${number}` : number.toString();
}
var getTimeStamp$1 = function getTimeStamp() {
  const date = new Date();
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${hours}:${minutes}:${seconds}`;
};
const getTimeStamp2 = getTimeStamp$1;
const justErrorsLogger$1 = {
  debug: () => {
  },
  warn: () => {
  },
  error: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return console.error(`[Uppy] [${getTimeStamp2()}]`, ...args);
  }
};
const debugLogger$2 = {
  debug: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return console.debug(`[Uppy] [${getTimeStamp2()}]`, ...args);
  },
  warn: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return console.warn(`[Uppy] [${getTimeStamp2()}]`, ...args);
  },
  error: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return console.error(`[Uppy] [${getTimeStamp2()}]`, ...args);
  }
};
var loggers = {
  justErrorsLogger: justErrorsLogger$1,
  debugLogger: debugLogger$2
};
var locale$d = {
  strings: {
    addBulkFilesFailed: {
      0: "Failed to add %{smart_count} file due to an internal error",
      1: "Failed to add %{smart_count} files due to internal errors"
    },
    youCanOnlyUploadX: {
      0: "You can only upload %{smart_count} file",
      1: "You can only upload %{smart_count} files"
    },
    youHaveToAtLeastSelectX: {
      0: "You have to select at least %{smart_count} file",
      1: "You have to select at least %{smart_count} files"
    },
    exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
    missingRequiredMetaField: "Missing required meta fields",
    missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
    inferiorSize: "This file is smaller than the allowed size of %{size}",
    youCanOnlyUploadFileTypes: "You can only upload: %{types}",
    noMoreFilesAllowed: "Cannot add more files",
    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
    companionError: "Connection with Companion failed",
    authAborted: "Authentication aborted",
    companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
    failedToUpload: "Failed to upload %{file}",
    noInternetConnection: "No Internet connection",
    connectedToInternet: "Connected to the Internet",
    noFilesFound: "You have no files or folders here",
    selectX: {
      0: "Select %{smart_count}",
      1: "Select %{smart_count}"
    },
    allFilesFromFolderNamed: "All files from folder %{name}",
    openFolderNamed: "Open folder %{name}",
    cancel: "Cancel",
    logOut: "Log out",
    filter: "Filter",
    resetFilter: "Reset filter",
    loading: "Loading...",
    authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
    authenticateWith: "Connect to %{pluginName}",
    signInWithGoogle: "Sign in with Google",
    searchImages: "Search for images",
    enterTextToSearch: "Enter text to search for images",
    search: "Search",
    emptyFolderAdded: "No files were added from empty folder",
    folderAlreadyAdded: 'The folder "%{folder}" was already added',
    folderAdded: {
      0: "Added %{smart_count} file from %{folder}",
      1: "Added %{smart_count} files from %{folder}"
    }
  }
};
let _Symbol$for$2, _Symbol$for2$1;
function _classPrivateFieldLooseBase$7(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$7 = 0;
function _classPrivateFieldLooseKey$7(name) {
  return "__private_" + id$7++ + "_" + name;
}
const Translator$1 = Translator_1;
const ee$1 = namespaceEmitter;
const {
  nanoid: nanoid$2
} = require$$9;
const throttle$2 = lodash_throttle;
const prettierBytes$2 = prettierBytes$3;
const match$2 = mimeMatch;
const DefaultStore = lib$9;
const getFileType2 = getFileType$1;
const getFileNameAndExtension2 = getFileNameAndExtension$2;
const generateFileID2 = generateFileID$1;
const supportsUploadProgress2 = supportsUploadProgress$1;
const getFileName2 = getFileName$1;
const {
  justErrorsLogger,
  debugLogger: debugLogger$1
} = loggers;
const locale$c = locale$d;
class RestrictionError extends Error {
  constructor() {
    super(...arguments);
    this.isRestriction = true;
  }
}
if (typeof AggregateError === "undefined") {
  globalThis.AggregateError = class AggregateError extends Error {
    constructor(errors, message) {
      super(message);
      this.errors = errors;
    }
  };
}
class AggregateRestrictionError extends AggregateError {
  constructor() {
    super(...arguments);
    this.isRestriction = true;
  }
}
var _plugins = /* @__PURE__ */ _classPrivateFieldLooseKey$7("plugins");
var _storeUnsubscribe = /* @__PURE__ */ _classPrivateFieldLooseKey$7("storeUnsubscribe");
var _emitter$2 = /* @__PURE__ */ _classPrivateFieldLooseKey$7("emitter");
var _preProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$7("preProcessors");
var _uploaders = /* @__PURE__ */ _classPrivateFieldLooseKey$7("uploaders");
var _postProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$7("postProcessors");
var _checkRestrictions = /* @__PURE__ */ _classPrivateFieldLooseKey$7("checkRestrictions");
var _checkMinNumberOfFiles = /* @__PURE__ */ _classPrivateFieldLooseKey$7("checkMinNumberOfFiles");
var _checkRequiredMetaFieldsOnFile = /* @__PURE__ */ _classPrivateFieldLooseKey$7("checkRequiredMetaFieldsOnFile");
var _checkRequiredMetaFields = /* @__PURE__ */ _classPrivateFieldLooseKey$7("checkRequiredMetaFields");
var _showOrLogErrorAndThrow = /* @__PURE__ */ _classPrivateFieldLooseKey$7("showOrLogErrorAndThrow");
var _assertNewUploadAllowed = /* @__PURE__ */ _classPrivateFieldLooseKey$7("assertNewUploadAllowed");
var _checkAndCreateFileStateObject = /* @__PURE__ */ _classPrivateFieldLooseKey$7("checkAndCreateFileStateObject");
var _startIfAutoProceed = /* @__PURE__ */ _classPrivateFieldLooseKey$7("startIfAutoProceed");
var _addListeners = /* @__PURE__ */ _classPrivateFieldLooseKey$7("addListeners");
var _updateOnlineStatus = /* @__PURE__ */ _classPrivateFieldLooseKey$7("updateOnlineStatus");
var _createUpload$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$7("createUpload");
var _getUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$7("getUpload");
var _removeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$7("removeUpload");
var _runUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$7("runUpload");
_Symbol$for$2 = Symbol.for("uppy test: getPlugins");
_Symbol$for2$1 = Symbol.for("uppy test: createUpload");
class Uppy$2 {
  constructor(_opts) {
    Object.defineProperty(this, _runUpload, {
      value: _runUpload2
    });
    Object.defineProperty(this, _removeUpload, {
      value: _removeUpload2
    });
    Object.defineProperty(this, _getUpload, {
      value: _getUpload2
    });
    Object.defineProperty(this, _createUpload$1, {
      value: _createUpload2$1
    });
    Object.defineProperty(this, _addListeners, {
      value: _addListeners2
    });
    Object.defineProperty(this, _startIfAutoProceed, {
      value: _startIfAutoProceed2
    });
    Object.defineProperty(this, _checkAndCreateFileStateObject, {
      value: _checkAndCreateFileStateObject2
    });
    Object.defineProperty(this, _assertNewUploadAllowed, {
      value: _assertNewUploadAllowed2
    });
    Object.defineProperty(this, _showOrLogErrorAndThrow, {
      value: _showOrLogErrorAndThrow2
    });
    Object.defineProperty(this, _checkRequiredMetaFields, {
      value: _checkRequiredMetaFields2
    });
    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
      value: _checkRequiredMetaFieldsOnFile2
    });
    Object.defineProperty(this, _checkMinNumberOfFiles, {
      value: _checkMinNumberOfFiles2
    });
    Object.defineProperty(this, _checkRestrictions, {
      value: _checkRestrictions2
    });
    Object.defineProperty(this, _plugins, {
      writable: true,
      value: /* @__PURE__ */ Object.create(null)
    });
    Object.defineProperty(this, _storeUnsubscribe, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emitter$2, {
      writable: true,
      value: ee$1()
    });
    Object.defineProperty(this, _preProcessors, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _uploaders, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _postProcessors, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _updateOnlineStatus, {
      writable: true,
      value: this.updateOnlineStatus.bind(this)
    });
    this.defaultLocale = locale$c;
    const defaultOptions2 = {
      id: "uppy",
      autoProceed: false,
      allowMultipleUploads: true,
      allowMultipleUploadBatches: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null,
        requiredMetaFields: []
      },
      meta: {},
      onBeforeFileAdded: (currentFile) => currentFile,
      onBeforeUpload: (files) => files,
      store: DefaultStore(),
      logger: justErrorsLogger,
      infoTimeout: 5e3
    };
    this.opts = __spreadProps(__spreadValues(__spreadValues({}, defaultOptions2), _opts), {
      restrictions: __spreadValues(__spreadValues({}, defaultOptions2.restrictions), _opts && _opts.restrictions)
    });
    if (_opts && _opts.logger && _opts.debug) {
      this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning");
    } else if (_opts && _opts.debug) {
      this.opts.logger = debugLogger$1;
    }
    this.log(`Using Core v${this.constructor.VERSION}`);
    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError("`restrictions.allowedFileTypes` must be an array");
    }
    this.i18nInit();
    this.calculateProgress = throttle$2(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress2(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: __spreadValues({}, this.opts.meta),
      info: [],
      recoveredState: null
    });
    _classPrivateFieldLooseBase$7(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {
      this.emit("state-update", prevState, nextState, patch);
      this.updateAll(nextState);
    });
    if (this.opts.debug && typeof window !== "undefined") {
      window[this.opts.id] = this;
    }
    _classPrivateFieldLooseBase$7(this, _addListeners)[_addListeners]();
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    _classPrivateFieldLooseBase$7(this, _emitter$2)[_emitter$2].emit(event, ...args);
  }
  on(event, callback) {
    _classPrivateFieldLooseBase$7(this, _emitter$2)[_emitter$2].on(event, callback);
    return this;
  }
  once(event, callback) {
    _classPrivateFieldLooseBase$7(this, _emitter$2)[_emitter$2].once(event, callback);
    return this;
  }
  off(event, callback) {
    _classPrivateFieldLooseBase$7(this, _emitter$2)[_emitter$2].off(event, callback);
    return this;
  }
  updateAll(state) {
    this.iteratePlugins((plugin) => {
      plugin.update(state);
    });
  }
  setState(patch) {
    this.store.setState(patch);
  }
  getState() {
    return this.store.getState();
  }
  get state() {
    return this.getState();
  }
  setFileState(fileID, state) {
    if (!this.getState().files[fileID]) {
      throw new Error(`Can\u2019t set state for ${fileID} (the file could have been removed)`);
    }
    this.setState({
      files: __spreadProps(__spreadValues({}, this.getState().files), {
        [fileID]: __spreadValues(__spreadValues({}, this.getState().files[fileID]), state)
      })
    });
  }
  i18nInit() {
    const translator = new Translator$1([this.defaultLocale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.locale = translator.locale;
  }
  setOptions(newOpts) {
    this.opts = __spreadProps(__spreadValues(__spreadValues({}, this.opts), newOpts), {
      restrictions: __spreadValues(__spreadValues({}, this.opts.restrictions), newOpts && newOpts.restrictions)
    });
    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }
    this.i18nInit();
    if (newOpts.locale) {
      this.iteratePlugins((plugin) => {
        plugin.setOptions();
      });
    }
    this.setState();
  }
  resetProgress() {
    const defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };
    const files = __spreadValues({}, this.getState().files);
    const updatedFiles = {};
    Object.keys(files).forEach((fileID) => {
      const updatedFile = __spreadValues({}, files[fileID]);
      updatedFile.progress = __spreadValues(__spreadValues({}, updatedFile.progress), defaultProgress);
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit("reset-progress");
  }
  addPreProcessor(fn) {
    _classPrivateFieldLooseBase$7(this, _preProcessors)[_preProcessors].add(fn);
  }
  removePreProcessor(fn) {
    return _classPrivateFieldLooseBase$7(this, _preProcessors)[_preProcessors].delete(fn);
  }
  addPostProcessor(fn) {
    _classPrivateFieldLooseBase$7(this, _postProcessors)[_postProcessors].add(fn);
  }
  removePostProcessor(fn) {
    return _classPrivateFieldLooseBase$7(this, _postProcessors)[_postProcessors].delete(fn);
  }
  addUploader(fn) {
    _classPrivateFieldLooseBase$7(this, _uploaders)[_uploaders].add(fn);
  }
  removeUploader(fn) {
    return _classPrivateFieldLooseBase$7(this, _uploaders)[_uploaders].delete(fn);
  }
  setMeta(data) {
    const updatedMeta = __spreadValues(__spreadValues({}, this.getState().meta), data);
    const updatedFiles = __spreadValues({}, this.getState().files);
    Object.keys(updatedFiles).forEach((fileID) => {
      updatedFiles[fileID] = __spreadProps(__spreadValues({}, updatedFiles[fileID]), {
        meta: __spreadValues(__spreadValues({}, updatedFiles[fileID].meta), data)
      });
    });
    this.log("Adding metadata:");
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  }
  setFileMeta(fileID, data) {
    const updatedFiles = __spreadValues({}, this.getState().files);
    if (!updatedFiles[fileID]) {
      this.log("Was trying to set metadata for a file that has been removed: ", fileID);
      return;
    }
    const newMeta = __spreadValues(__spreadValues({}, updatedFiles[fileID].meta), data);
    updatedFiles[fileID] = __spreadProps(__spreadValues({}, updatedFiles[fileID]), {
      meta: newMeta
    });
    this.setState({
      files: updatedFiles
    });
  }
  getFile(fileID) {
    return this.getState().files[fileID];
  }
  getFiles() {
    const {
      files
    } = this.getState();
    return Object.values(files);
  }
  getObjectOfFilesPerState() {
    const {
      files: filesObject,
      totalProgress,
      error
    } = this.getState();
    const files = Object.values(filesObject);
    const inProgressFiles = files.filter((_ref) => {
      let {
        progress
      } = _ref;
      return !progress.uploadComplete && progress.uploadStarted;
    });
    const newFiles = files.filter((file) => !file.progress.uploadStarted);
    const startedFiles = files.filter((file) => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess);
    const uploadStartedFiles = files.filter((file) => file.progress.uploadStarted);
    const pausedFiles = files.filter((file) => file.isPaused);
    const completeFiles = files.filter((file) => file.progress.uploadComplete);
    const erroredFiles = files.filter((file) => file.error);
    const inProgressNotPausedFiles = inProgressFiles.filter((file) => !file.isPaused);
    const processingFiles = files.filter((file) => file.progress.preprocess || file.progress.postprocess);
    return {
      newFiles,
      startedFiles,
      uploadStartedFiles,
      pausedFiles,
      completeFiles,
      erroredFiles,
      inProgressFiles,
      inProgressNotPausedFiles,
      processingFiles,
      isUploadStarted: uploadStartedFiles.length > 0,
      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,
      isAllErrored: !!error && erroredFiles.length === files.length,
      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,
      isUploadInProgress: inProgressFiles.length > 0,
      isSomeGhost: files.some((file) => file.isGhost)
    };
  }
  validateRestrictions(file, files) {
    try {
      _classPrivateFieldLooseBase$7(this, _checkRestrictions)[_checkRestrictions](file, files);
      return {
        result: true
      };
    } catch (err) {
      return {
        result: false,
        reason: err.message
      };
    }
  }
  checkIfFileAlreadyExists(fileID) {
    const {
      files
    } = this.getState();
    if (files[fileID] && !files[fileID].isGhost) {
      return true;
    }
    return false;
  }
  addFile(file) {
    _classPrivateFieldLooseBase$7(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);
    const {
      files
    } = this.getState();
    let newFile = _classPrivateFieldLooseBase$7(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file);
    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = __spreadProps(__spreadValues({}, files[newFile.id]), {
        data: file.data,
        isGhost: false
      });
      this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
    }
    this.setState({
      files: __spreadProps(__spreadValues({}, files), {
        [newFile.id]: newFile
      })
    });
    this.emit("file-added", newFile);
    this.emit("files-added", [newFile]);
    this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);
    _classPrivateFieldLooseBase$7(this, _startIfAutoProceed)[_startIfAutoProceed]();
    return newFile.id;
  }
  addFiles(fileDescriptors) {
    _classPrivateFieldLooseBase$7(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
    const files = __spreadValues({}, this.getState().files);
    const newFiles = [];
    const errors = [];
    for (let i2 = 0; i2 < fileDescriptors.length; i2++) {
      try {
        let newFile = _classPrivateFieldLooseBase$7(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i2]);
        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = __spreadProps(__spreadValues({}, files[newFile.id]), {
            data: fileDescriptors[i2].data,
            isGhost: false
          });
          this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
        }
        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }
    this.setState({
      files
    });
    newFiles.forEach((newFile) => {
      this.emit("file-added", newFile);
    });
    this.emit("files-added", newFiles);
    if (newFiles.length > 5) {
      this.log(`Added batch of ${newFiles.length} files`);
    } else {
      Object.keys(newFiles).forEach((fileID) => {
        this.log(`Added file: ${newFiles[fileID].name}
 id: ${newFiles[fileID].id}
 type: ${newFiles[fileID].type}`);
      });
    }
    if (newFiles.length > 0) {
      _classPrivateFieldLooseBase$7(this, _startIfAutoProceed)[_startIfAutoProceed]();
    }
    if (errors.length > 0) {
      let message = "Multiple errors occurred while adding files:\n";
      errors.forEach((subError) => {
        message += `
 * ${subError.message}`;
      });
      this.info({
        message: this.i18n("addBulkFilesFailed", {
          smart_count: errors.length
        }),
        details: message
      }, "error", this.opts.infoTimeout);
      if (typeof AggregateError === "function") {
        throw new AggregateError(errors, message);
      } else {
        const err = new Error(message);
        err.errors = errors;
        throw err;
      }
    }
  }
  removeFiles(fileIDs, reason) {
    const {
      files,
      currentUploads
    } = this.getState();
    const updatedFiles = __spreadValues({}, files);
    const updatedUploads = __spreadValues({}, currentUploads);
    const removedFiles = /* @__PURE__ */ Object.create(null);
    fileIDs.forEach((fileID) => {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    });
    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === void 0;
    }
    Object.keys(updatedUploads).forEach((uploadID) => {
      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);
      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }
      updatedUploads[uploadID] = __spreadProps(__spreadValues({}, currentUploads[uploadID]), {
        fileIDs: newFileIDs
      });
    });
    const stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    };
    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }
    this.setState(stateUpdate);
    this.calculateTotalProgress();
    const removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach((fileID) => {
      this.emit("file-removed", removedFiles[fileID], reason);
    });
    if (removedFileIDs.length > 5) {
      this.log(`Removed ${removedFileIDs.length} files`);
    } else {
      this.log(`Removed files: ${removedFileIDs.join(", ")}`);
    }
  }
  removeFile(fileID, reason) {
    if (reason === void 0) {
      reason = null;
    }
    this.removeFiles([fileID], reason);
  }
  pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return void 0;
    }
    const wasPaused = this.getFile(fileID).isPaused || false;
    const isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused
    });
    this.emit("upload-pause", fileID, isPaused);
    return isPaused;
  }
  pauseAll() {
    const updatedFiles = __spreadValues({}, this.getState().files);
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach((file) => {
      const updatedFile = __spreadProps(__spreadValues({}, updatedFiles[file]), {
        isPaused: true
      });
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit("pause-all");
  }
  resumeAll() {
    const updatedFiles = __spreadValues({}, this.getState().files);
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach((file) => {
      const updatedFile = __spreadProps(__spreadValues({}, updatedFiles[file]), {
        isPaused: false,
        error: null
      });
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit("resume-all");
  }
  retryAll() {
    const updatedFiles = __spreadValues({}, this.getState().files);
    const filesToRetry = Object.keys(updatedFiles).filter((file) => {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach((file) => {
      const updatedFile = __spreadProps(__spreadValues({}, updatedFiles[file]), {
        isPaused: false,
        error: null
      });
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit("retry-all", filesToRetry);
    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }
    const uploadID = _classPrivateFieldLooseBase$7(this, _createUpload$1)[_createUpload$1](filesToRetry, {
      forceAllowNewUpload: true
    });
    return _classPrivateFieldLooseBase$7(this, _runUpload)[_runUpload](uploadID);
  }
  cancelAll() {
    this.emit("cancel-all");
    const {
      files
    } = this.getState();
    const fileIDs = Object.keys(files);
    if (fileIDs.length) {
      this.removeFiles(fileIDs, "cancel-all");
    }
    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  }
  retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit("upload-retry", fileID);
    const uploadID = _classPrivateFieldLooseBase$7(this, _createUpload$1)[_createUpload$1]([fileID], {
      forceAllowNewUpload: true
    });
    return _classPrivateFieldLooseBase$7(this, _runUpload)[_runUpload](uploadID);
  }
  reset() {
    this.cancelAll();
  }
  logout() {
    this.iteratePlugins((plugin) => {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  }
  calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const canHavePercentage = Number.isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: __spreadProps(__spreadValues({}, this.getFile(file.id).progress), {
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      })
    });
    this.calculateTotalProgress();
  }
  calculateTotalProgress() {
    const files = this.getFiles();
    const inProgress = files.filter((file) => {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    if (inProgress.length === 0) {
      this.emit("progress", 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }
    const sizedFiles = inProgress.filter((file) => file.progress.bytesTotal != null);
    const unsizedFiles = inProgress.filter((file) => file.progress.bytesTotal == null);
    if (sizedFiles.length === 0) {
      const progressMax = inProgress.length * 100;
      const currentProgress = unsizedFiles.reduce((acc, file) => {
        return acc + file.progress.percentage;
      }, 0);
      const totalProgress2 = Math.round(currentProgress / progressMax * 100);
      this.setState({
        totalProgress: totalProgress2
      });
      return;
    }
    let totalSize = sizedFiles.reduce((acc, file) => {
      return acc + file.progress.bytesTotal;
    }, 0);
    const averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    let uploadedSize = 0;
    sizedFiles.forEach((file) => {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach((file) => {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);
    if (totalProgress > 100) {
      totalProgress = 100;
    }
    this.setState({
      totalProgress
    });
    this.emit("progress", totalProgress);
  }
  updateOnlineStatus() {
    const online = typeof window.navigator.onLine !== "undefined" ? window.navigator.onLine : true;
    if (!online) {
      this.emit("is-offline");
      this.info(this.i18n("noInternetConnection"), "error", 0);
      this.wasOffline = true;
    } else {
      this.emit("is-online");
      if (this.wasOffline) {
        this.emit("back-online");
        this.info(this.i18n("connectedToInternet"), "success", 3e3);
        this.wasOffline = false;
      }
    }
  }
  getID() {
    return this.opts.id;
  }
  use(Plugin, opts) {
    if (typeof Plugin !== "function") {
      const msg = `Expected a plugin class, but got ${Plugin === null ? "null" : typeof Plugin}. Please verify that the plugin was imported and spelled correctly.`;
      throw new TypeError(msg);
    }
    const plugin = new Plugin(this, opts);
    const pluginId = plugin.id;
    if (!pluginId) {
      throw new Error("Your plugin must have an id");
    }
    if (!plugin.type) {
      throw new Error("Your plugin must have a type");
    }
    const existsPluginAlready = this.getPlugin(pluginId);
    if (existsPluginAlready) {
      const msg = `Already found a plugin named '${existsPluginAlready.id}'. Tried to use: '${pluginId}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;
      throw new Error(msg);
    }
    if (Plugin.VERSION) {
      this.log(`Using ${pluginId} v${Plugin.VERSION}`);
    }
    if (plugin.type in _classPrivateFieldLooseBase$7(this, _plugins)[_plugins]) {
      _classPrivateFieldLooseBase$7(this, _plugins)[_plugins][plugin.type].push(plugin);
    } else {
      _classPrivateFieldLooseBase$7(this, _plugins)[_plugins][plugin.type] = [plugin];
    }
    plugin.install();
    return this;
  }
  getPlugin(id2) {
    for (const plugins2 of Object.values(_classPrivateFieldLooseBase$7(this, _plugins)[_plugins])) {
      const foundPlugin = plugins2.find((plugin) => plugin.id === id2);
      if (foundPlugin != null)
        return foundPlugin;
    }
    return void 0;
  }
  [_Symbol$for$2](type) {
    return _classPrivateFieldLooseBase$7(this, _plugins)[_plugins][type];
  }
  iteratePlugins(method) {
    Object.values(_classPrivateFieldLooseBase$7(this, _plugins)[_plugins]).flat(1).forEach(method);
  }
  removePlugin(instance) {
    this.log(`Removing plugin ${instance.id}`);
    this.emit("plugin-remove", instance);
    if (instance.uninstall) {
      instance.uninstall();
    }
    const list = _classPrivateFieldLooseBase$7(this, _plugins)[_plugins][instance.type];
    const index = list.findIndex((item) => item.id === instance.id);
    if (index !== -1) {
      list.splice(index, 1);
    }
    const state = this.getState();
    const updatedState = {
      plugins: __spreadProps(__spreadValues({}, state.plugins), {
        [instance.id]: void 0
      })
    };
    this.setState(updatedState);
  }
  close() {
    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
    this.reset();
    _classPrivateFieldLooseBase$7(this, _storeUnsubscribe)[_storeUnsubscribe]();
    this.iteratePlugins((plugin) => {
      this.removePlugin(plugin);
    });
    if (typeof window !== "undefined" && window.removeEventListener) {
      window.removeEventListener("online", _classPrivateFieldLooseBase$7(this, _updateOnlineStatus)[_updateOnlineStatus]);
      window.removeEventListener("offline", _classPrivateFieldLooseBase$7(this, _updateOnlineStatus)[_updateOnlineStatus]);
    }
  }
  hideInfo() {
    const {
      info
    } = this.getState();
    this.setState({
      info: info.slice(1)
    });
    this.emit("info-hidden");
  }
  info(message, type, duration2) {
    if (type === void 0) {
      type = "info";
    }
    if (duration2 === void 0) {
      duration2 = 3e3;
    }
    const isComplexMessage = typeof message === "object";
    this.setState({
      info: [...this.getState().info, {
        type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }]
    });
    setTimeout(() => this.hideInfo(), duration2);
    this.emit("info-visible");
  }
  log(message, type) {
    const {
      logger
    } = this.opts;
    switch (type) {
      case "error":
        logger.error(message);
        break;
      case "warning":
        logger.warn(message);
        break;
      default:
        logger.debug(message);
        break;
    }
  }
  restore(uploadID) {
    this.log(`Core: attempting to restore upload "${uploadID}"`);
    if (!this.getState().currentUploads[uploadID]) {
      _classPrivateFieldLooseBase$7(this, _removeUpload)[_removeUpload](uploadID);
      return Promise.reject(new Error("Nonexistent upload"));
    }
    return _classPrivateFieldLooseBase$7(this, _runUpload)[_runUpload](uploadID);
  }
  [_Symbol$for2$1]() {
    return _classPrivateFieldLooseBase$7(this, _createUpload$1)[_createUpload$1](...arguments);
  }
  addResultData(uploadID, data) {
    if (!_classPrivateFieldLooseBase$7(this, _getUpload)[_getUpload](uploadID)) {
      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
      return;
    }
    const {
      currentUploads
    } = this.getState();
    const currentUpload = __spreadProps(__spreadValues({}, currentUploads[uploadID]), {
      result: __spreadValues(__spreadValues({}, currentUploads[uploadID].result), data)
    });
    this.setState({
      currentUploads: __spreadProps(__spreadValues({}, currentUploads), {
        [uploadID]: currentUpload
      })
    });
  }
  upload() {
    var _classPrivateFieldLoo;
    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase$7(this, _plugins)[_plugins].uploader) != null && _classPrivateFieldLoo.length)) {
      this.log("No uploader type plugins are used", "warning");
    }
    let {
      files
    } = this.getState();
    const onBeforeUploadResult = this.opts.onBeforeUpload(files);
    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false"));
    }
    if (onBeforeUploadResult && typeof onBeforeUploadResult === "object") {
      files = onBeforeUploadResult;
      this.setState({
        files
      });
    }
    return Promise.resolve().then(() => {
      _classPrivateFieldLooseBase$7(this, _checkMinNumberOfFiles)[_checkMinNumberOfFiles](files);
      _classPrivateFieldLooseBase$7(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files);
    }).catch((err) => {
      _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err);
    }).then(() => {
      const {
        currentUploads
      } = this.getState();
      const currentlyUploadingFiles = Object.values(currentUploads).flatMap((curr) => curr.fileIDs);
      const waitingFileIDs = [];
      Object.keys(files).forEach((fileID) => {
        const file = this.getFile(fileID);
        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });
      const uploadID = _classPrivateFieldLooseBase$7(this, _createUpload$1)[_createUpload$1](waitingFileIDs);
      return _classPrivateFieldLooseBase$7(this, _runUpload)[_runUpload](uploadID);
    }).catch((err) => {
      _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
        showInformer: false
      });
    });
  }
}
function _checkRestrictions2(file, files) {
  if (files === void 0) {
    files = this.getFiles();
  }
  const {
    maxFileSize,
    minFileSize,
    maxTotalFileSize,
    maxNumberOfFiles,
    allowedFileTypes
  } = this.opts.restrictions;
  if (maxNumberOfFiles) {
    if (files.length + 1 > maxNumberOfFiles) {
      throw new RestrictionError(`${this.i18n("youCanOnlyUploadX", {
        smart_count: maxNumberOfFiles
      })}`);
    }
  }
  if (allowedFileTypes) {
    const isCorrectFileType = allowedFileTypes.some((type) => {
      if (type.indexOf("/") > -1) {
        if (!file.type)
          return false;
        return match$2(file.type.replace(/;.*?$/, ""), type);
      }
      if (type[0] === "." && file.extension) {
        return file.extension.toLowerCase() === type.substr(1).toLowerCase();
      }
      return false;
    });
    if (!isCorrectFileType) {
      const allowedFileTypesString = allowedFileTypes.join(", ");
      throw new RestrictionError(this.i18n("youCanOnlyUploadFileTypes", {
        types: allowedFileTypesString
      }));
    }
  }
  if (maxTotalFileSize && file.size != null) {
    let totalFilesSize = 0;
    totalFilesSize += file.size;
    files.forEach((f2) => {
      totalFilesSize += f2.size;
    });
    if (totalFilesSize > maxTotalFileSize) {
      throw new RestrictionError(this.i18n("exceedsSize", {
        size: prettierBytes$2(maxTotalFileSize),
        file: file.name
      }));
    }
  }
  if (maxFileSize && file.size != null) {
    if (file.size > maxFileSize) {
      throw new RestrictionError(this.i18n("exceedsSize", {
        size: prettierBytes$2(maxFileSize),
        file: file.name
      }));
    }
  }
  if (minFileSize && file.size != null) {
    if (file.size < minFileSize) {
      throw new RestrictionError(this.i18n("inferiorSize", {
        size: prettierBytes$2(minFileSize)
      }));
    }
  }
}
function _checkMinNumberOfFiles2(files) {
  const {
    minNumberOfFiles
  } = this.opts.restrictions;
  if (Object.keys(files).length < minNumberOfFiles) {
    throw new RestrictionError(`${this.i18n("youHaveToAtLeastSelectX", {
      smart_count: minNumberOfFiles
    })}`);
  }
}
function _checkRequiredMetaFieldsOnFile2(file) {
  const {
    requiredMetaFields
  } = this.opts.restrictions;
  const {
    hasOwnProperty: hasOwnProperty2
  } = Object.prototype;
  const errors = [];
  const missingFields = [];
  for (let i2 = 0; i2 < requiredMetaFields.length; i2++) {
    if (!hasOwnProperty2.call(file.meta, requiredMetaFields[i2]) || file.meta[requiredMetaFields[i2]] === "") {
      const err = new RestrictionError(`${this.i18n("missingRequiredMetaFieldOnFile", {
        fileName: file.name
      })}`);
      errors.push(err);
      missingFields.push(requiredMetaFields[i2]);
      _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
        file,
        showInformer: false,
        throwErr: false
      });
    }
  }
  this.setFileState(file.id, {
    missingRequiredMetaFields: missingFields
  });
  return errors;
}
function _checkRequiredMetaFields2(files) {
  const errors = Object.keys(files).flatMap((fileID) => {
    const file = this.getFile(fileID);
    return _classPrivateFieldLooseBase$7(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
  });
  if (errors.length) {
    throw new AggregateRestrictionError(errors, `${this.i18n("missingRequiredMetaField")}`);
  }
}
function _showOrLogErrorAndThrow2(err, _temp2) {
  let {
    showInformer = true,
    file = null,
    throwErr = true
  } = _temp2 === void 0 ? {} : _temp2;
  const message = typeof err === "object" ? err.message : err;
  const details = typeof err === "object" && err.details ? err.details : "";
  let logMessageWithDetails = message;
  if (details) {
    logMessageWithDetails += ` ${details}`;
  }
  if (err.isRestriction) {
    this.log(logMessageWithDetails);
    this.emit("restriction-failed", file, err);
  } else {
    this.log(logMessageWithDetails, "error");
  }
  if (showInformer) {
    this.info({
      message,
      details
    }, "error", this.opts.infoTimeout);
  }
  if (throwErr) {
    throw typeof err === "object" ? err : new Error(err);
  }
}
function _assertNewUploadAllowed2(file) {
  const {
    allowNewUpload
  } = this.getState();
  if (allowNewUpload === false) {
    _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError(this.i18n("noMoreFilesAllowed")), {
      file
    });
  }
}
function _checkAndCreateFileStateObject2(files, fileDescriptor) {
  const fileType = getFileType2(fileDescriptor);
  const fileName = getFileName2(fileType, fileDescriptor);
  const fileExtension2 = getFileNameAndExtension2(fileName).extension;
  const isRemote = Boolean(fileDescriptor.isRemote);
  const fileID = generateFileID2(__spreadProps(__spreadValues({}, fileDescriptor), {
    type: fileType
  }));
  if (this.checkIfFileAlreadyExists(fileID)) {
    const error = new RestrictionError(this.i18n("noDuplicates", {
      fileName
    }));
    _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
      file: fileDescriptor
    });
  }
  const meta = fileDescriptor.meta || {};
  meta.name = fileName;
  meta.type = fileType;
  const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
  let newFile = {
    source: fileDescriptor.source || "",
    id: fileID,
    name: fileName,
    extension: fileExtension2 || "",
    meta: __spreadValues(__spreadValues({}, this.getState().meta), meta),
    type: fileType,
    data: fileDescriptor.data,
    progress: {
      percentage: 0,
      bytesUploaded: 0,
      bytesTotal: size,
      uploadComplete: false,
      uploadStarted: null
    },
    size,
    isRemote,
    remote: fileDescriptor.remote || "",
    preview: fileDescriptor.preview
  };
  const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);
  if (onBeforeFileAddedResult === false) {
    _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError("Cannot add the file because onBeforeFileAdded returned false."), {
      showInformer: false,
      fileDescriptor
    });
  } else if (typeof onBeforeFileAddedResult === "object" && onBeforeFileAddedResult !== null) {
    newFile = onBeforeFileAddedResult;
  }
  try {
    const filesArray = Object.keys(files).map((i2) => files[i2]);
    _classPrivateFieldLooseBase$7(this, _checkRestrictions)[_checkRestrictions](newFile, filesArray);
  } catch (err) {
    _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err, {
      file: newFile
    });
  }
  return newFile;
}
function _startIfAutoProceed2() {
  if (this.opts.autoProceed && !this.scheduledAutoProceed) {
    this.scheduledAutoProceed = setTimeout(() => {
      this.scheduledAutoProceed = null;
      this.upload().catch((err) => {
        if (!err.isRestriction) {
          this.log(err.stack || err.message || err);
        }
      });
    }, 4);
  }
}
function _addListeners2() {
  const errorHandler = (error, file, response) => {
    let errorMsg = error.message || "Unknown error";
    if (error.details) {
      errorMsg += ` ${error.details}`;
    }
    this.setState({
      error: errorMsg
    });
    if (file != null && file.id in this.getState().files) {
      this.setFileState(file.id, {
        error: errorMsg,
        response
      });
    }
  };
  this.on("error", errorHandler);
  this.on("upload-error", (file, error, response) => {
    errorHandler(error, file, response);
    if (typeof error === "object" && error.message) {
      const newError = new Error(error.message);
      newError.details = error.message;
      if (error.details) {
        newError.details += ` ${error.details}`;
      }
      newError.message = this.i18n("failedToUpload", {
        file: file.name
      });
      _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](newError, {
        throwErr: false
      });
    } else {
      _classPrivateFieldLooseBase$7(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
        throwErr: false
      });
    }
  });
  this.on("upload", () => {
    this.setState({
      error: null
    });
  });
  this.on("upload-started", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: {
        uploadStarted: Date.now(),
        uploadComplete: false,
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: file.size
      }
    });
  });
  this.on("upload-progress", this.calculateProgress);
  this.on("upload-success", (file, uploadResp) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const currentProgress = this.getFile(file.id).progress;
    this.setFileState(file.id, {
      progress: __spreadProps(__spreadValues({}, currentProgress), {
        postprocess: _classPrivateFieldLooseBase$7(this, _postProcessors)[_postProcessors].size > 0 ? {
          mode: "indeterminate"
        } : null,
        uploadComplete: true,
        percentage: 100,
        bytesUploaded: currentProgress.bytesTotal
      }),
      response: uploadResp,
      uploadURL: uploadResp.uploadURL,
      isPaused: false
    });
    if (file.size == null) {
      this.setFileState(file.id, {
        size: uploadResp.bytesUploaded || currentProgress.bytesTotal
      });
    }
    this.calculateTotalProgress();
  });
  this.on("preprocess-progress", (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: __spreadProps(__spreadValues({}, this.getFile(file.id).progress), {
        preprocess: progress
      })
    });
  });
  this.on("preprocess-complete", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const files = __spreadValues({}, this.getState().files);
    files[file.id] = __spreadProps(__spreadValues({}, files[file.id]), {
      progress: __spreadValues({}, files[file.id].progress)
    });
    delete files[file.id].progress.preprocess;
    this.setState({
      files
    });
  });
  this.on("postprocess-progress", (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: __spreadProps(__spreadValues({}, this.getState().files[file.id].progress), {
        postprocess: progress
      })
    });
  });
  this.on("postprocess-complete", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const files = __spreadValues({}, this.getState().files);
    files[file.id] = __spreadProps(__spreadValues({}, files[file.id]), {
      progress: __spreadValues({}, files[file.id].progress)
    });
    delete files[file.id].progress.postprocess;
    this.setState({
      files
    });
  });
  this.on("restored", () => {
    this.calculateTotalProgress();
  });
  this.on("dashboard:file-edit-complete", (file) => {
    if (file) {
      _classPrivateFieldLooseBase$7(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
    }
  });
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("online", _classPrivateFieldLooseBase$7(this, _updateOnlineStatus)[_updateOnlineStatus]);
    window.addEventListener("offline", _classPrivateFieldLooseBase$7(this, _updateOnlineStatus)[_updateOnlineStatus]);
    setTimeout(_classPrivateFieldLooseBase$7(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3);
  }
}
function _createUpload2$1(fileIDs, opts) {
  if (opts === void 0) {
    opts = {};
  }
  const {
    forceAllowNewUpload = false
  } = opts;
  const {
    allowNewUpload,
    currentUploads
  } = this.getState();
  if (!allowNewUpload && !forceAllowNewUpload) {
    throw new Error("Cannot create a new upload: already uploading.");
  }
  const uploadID = nanoid$2();
  this.emit("upload", {
    id: uploadID,
    fileIDs
  });
  this.setState({
    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,
    currentUploads: __spreadProps(__spreadValues({}, currentUploads), {
      [uploadID]: {
        fileIDs,
        step: 0,
        result: {}
      }
    })
  });
  return uploadID;
}
function _getUpload2(uploadID) {
  const {
    currentUploads
  } = this.getState();
  return currentUploads[uploadID];
}
function _removeUpload2(uploadID) {
  const currentUploads = __spreadValues({}, this.getState().currentUploads);
  delete currentUploads[uploadID];
  this.setState({
    currentUploads
  });
}
async function _runUpload2(uploadID) {
  let {
    currentUploads
  } = this.getState();
  let currentUpload = currentUploads[uploadID];
  const restoreStep = currentUpload.step || 0;
  const steps = [..._classPrivateFieldLooseBase$7(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase$7(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase$7(this, _postProcessors)[_postProcessors]];
  try {
    for (let step = restoreStep; step < steps.length; step++) {
      if (!currentUpload) {
        break;
      }
      const fn = steps[step];
      const updatedUpload = __spreadProps(__spreadValues({}, currentUpload), {
        step
      });
      this.setState({
        currentUploads: __spreadProps(__spreadValues({}, currentUploads), {
          [uploadID]: updatedUpload
        })
      });
      await fn(updatedUpload.fileIDs, uploadID);
      currentUploads = this.getState().currentUploads;
      currentUpload = currentUploads[uploadID];
    }
  } catch (err) {
    this.emit("error", err);
    _classPrivateFieldLooseBase$7(this, _removeUpload)[_removeUpload](uploadID);
    throw err;
  }
  if (currentUpload) {
    currentUpload.fileIDs.forEach((fileID) => {
      const file = this.getFile(fileID);
      if (file && file.progress.postprocess) {
        this.emit("postprocess-complete", file);
      }
    });
    const files = currentUpload.fileIDs.map((fileID) => this.getFile(fileID));
    const successful = files.filter((file) => !file.error);
    const failed = files.filter((file) => file.error);
    await this.addResultData(uploadID, {
      successful,
      failed,
      uploadID
    });
    currentUploads = this.getState().currentUploads;
    currentUpload = currentUploads[uploadID];
  }
  let result;
  if (currentUpload) {
    result = currentUpload.result;
    this.emit("complete", result);
    _classPrivateFieldLooseBase$7(this, _removeUpload)[_removeUpload](uploadID);
  }
  if (result == null) {
    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
  }
  return result;
}
Uppy$2.VERSION = "2.1.5";
var Uppy_1 = Uppy$2;
var n, l, u, i, t, o, r, f, e = {}, c = [], s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function a(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function h$v(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function v(l2, u2, i2) {
  var t2, o2, r2, f2 = {};
  for (r2 in u2)
    r2 == "key" ? t2 = u2[r2] : r2 == "ref" ? o2 = u2[r2] : f2[r2] = u2[r2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : i2), typeof l2 == "function" && l2.defaultProps != null)
    for (r2 in l2.defaultProps)
      f2[r2] === void 0 && (f2[r2] = l2.defaultProps[r2]);
  return y(l2, f2, t2, o2, null);
}
function y(n2, i2, t2, o2, r2) {
  var f2 = { type: n2, props: i2, key: t2, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r2 == null ? ++u : r2 };
  return r2 == null && l.vnode != null && l.vnode(f2), f2;
}
function p() {
  return { current: null };
}
function d(n2) {
  return n2.children;
}
function _(n2, l2) {
  this.props = n2, this.context = l2;
}
function k(n2, l2) {
  if (l2 == null)
    return n2.__ ? k(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? k(n2) : null;
}
function b(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return b(n2);
  }
}
function m(n2) {
  (!n2.__d && (n2.__d = true) && t.push(n2) && !g.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)(g);
}
function g() {
  for (var n2; g.__r = t.length; )
    n2 = t.sort(function(n3, l2) {
      return n3.__v.__b - l2.__v.__b;
    }), t = [], n2.some(function(n3) {
      var l2, u2, i2, t2, o2, r2;
      n3.__d && (o2 = (t2 = (l2 = n3).__v).__e, (r2 = l2.__P) && (u2 = [], (i2 = a({}, t2)).__v = t2.__v + 1, j(r2, t2, i2, l2.__n, r2.ownerSVGElement !== void 0, t2.__h != null ? [o2] : null, u2, o2 == null ? k(t2) : o2, t2.__h), z(u2, t2), t2.__e != o2 && b(t2)));
    });
}
function w(n2, l2, u2, i2, t2, o2, r2, f2, s2, a2) {
  var h2, v2, p2, _2, b2, m2, g2, w2 = i2 && i2.__k || c, A2 = w2.length;
  for (u2.__k = [], h2 = 0; h2 < l2.length; h2++)
    if ((_2 = u2.__k[h2] = (_2 = l2[h2]) == null || typeof _2 == "boolean" ? null : typeof _2 == "string" || typeof _2 == "number" || typeof _2 == "bigint" ? y(null, _2, null, null, _2) : Array.isArray(_2) ? y(d, { children: _2 }, null, null, null) : _2.__b > 0 ? y(_2.type, _2.props, _2.key, null, _2.__v) : _2) != null) {
      if (_2.__ = u2, _2.__b = u2.__b + 1, (p2 = w2[h2]) === null || p2 && _2.key == p2.key && _2.type === p2.type)
        w2[h2] = void 0;
      else
        for (v2 = 0; v2 < A2; v2++) {
          if ((p2 = w2[v2]) && _2.key == p2.key && _2.type === p2.type) {
            w2[v2] = void 0;
            break;
          }
          p2 = null;
        }
      j(n2, _2, p2 = p2 || e, t2, o2, r2, f2, s2, a2), b2 = _2.__e, (v2 = _2.ref) && p2.ref != v2 && (g2 || (g2 = []), p2.ref && g2.push(p2.ref, null, _2), g2.push(v2, _2.__c || b2, _2)), b2 != null ? (m2 == null && (m2 = b2), typeof _2.type == "function" && _2.__k === p2.__k ? _2.__d = s2 = x(_2, s2, n2) : s2 = P(n2, _2, p2, w2, b2, s2), typeof u2.type == "function" && (u2.__d = s2)) : s2 && p2.__e == s2 && s2.parentNode != n2 && (s2 = k(p2));
    }
  for (u2.__e = m2, h2 = A2; h2--; )
    w2[h2] != null && (typeof u2.type == "function" && w2[h2].__e != null && w2[h2].__e == u2.__d && (u2.__d = k(i2, h2 + 1)), N(w2[h2], w2[h2]));
  if (g2)
    for (h2 = 0; h2 < g2.length; h2++)
      M(g2[h2], g2[++h2], g2[++h2]);
}
function x(n2, l2, u2) {
  for (var i2, t2 = n2.__k, o2 = 0; t2 && o2 < t2.length; o2++)
    (i2 = t2[o2]) && (i2.__ = n2, l2 = typeof i2.type == "function" ? x(i2, l2, u2) : P(u2, i2, i2, t2, i2.__e, l2));
  return l2;
}
function A(n2, l2) {
  return l2 = l2 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    A(n3, l2);
  }) : l2.push(n2)), l2;
}
function P(n2, l2, u2, i2, t2, o2) {
  var r2, f2, e2;
  if (l2.__d !== void 0)
    r2 = l2.__d, l2.__d = void 0;
  else if (u2 == null || t2 != o2 || t2.parentNode == null)
    n:
      if (o2 == null || o2.parentNode !== n2)
        n2.appendChild(t2), r2 = null;
      else {
        for (f2 = o2, e2 = 0; (f2 = f2.nextSibling) && e2 < i2.length; e2 += 2)
          if (f2 == t2)
            break n;
        n2.insertBefore(t2, o2), r2 = o2;
      }
  return r2 !== void 0 ? r2 : t2.nextSibling;
}
function C(n2, l2, u2, i2, t2) {
  var o2;
  for (o2 in u2)
    o2 === "children" || o2 === "key" || o2 in l2 || H(n2, o2, null, u2[o2], i2);
  for (o2 in l2)
    t2 && typeof l2[o2] != "function" || o2 === "children" || o2 === "key" || o2 === "value" || o2 === "checked" || u2[o2] === l2[o2] || H(n2, o2, l2[o2], u2[o2], i2);
}
function $(n2, l2, u2) {
  l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || s.test(l2) ? u2 : u2 + "px";
}
function H(n2, l2, u2, i2, t2) {
  var o2;
  n:
    if (l2 === "style")
      if (typeof u2 == "string")
        n2.style.cssText = u2;
      else {
        if (typeof i2 == "string" && (n2.style.cssText = i2 = ""), i2)
          for (l2 in i2)
            u2 && l2 in u2 || $(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            i2 && u2[l2] === i2[l2] || $(n2.style, l2, u2[l2]);
      }
    else if (l2[0] === "o" && l2[1] === "n")
      o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? i2 || n2.addEventListener(l2, o2 ? T : I, o2) : n2.removeEventListener(l2, o2 ? T : I, o2);
    else if (l2 !== "dangerouslySetInnerHTML") {
      if (t2)
        l2 = l2.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l2 !== "href" && l2 !== "list" && l2 !== "form" && l2 !== "tabIndex" && l2 !== "download" && l2 in n2)
        try {
          n2[l2] = u2 == null ? "" : u2;
          break n;
        } catch (n3) {
        }
      typeof u2 == "function" || (u2 != null && (u2 !== false || l2[0] === "a" && l2[1] === "r") ? n2.setAttribute(l2, u2) : n2.removeAttribute(l2));
    }
}
function I(n2) {
  this.l[n2.type + false](l.event ? l.event(n2) : n2);
}
function T(n2) {
  this.l[n2.type + true](l.event ? l.event(n2) : n2);
}
function j(n2, u2, i2, t2, o2, r2, f2, e2, c2) {
  var s2, h2, v2, y2, p2, k2, b2, m2, g2, x2, A2, P2 = u2.type;
  if (u2.constructor !== void 0)
    return null;
  i2.__h != null && (c2 = i2.__h, e2 = u2.__e = i2.__e, u2.__h = null, r2 = [e2]), (s2 = l.__b) && s2(u2);
  try {
    n:
      if (typeof P2 == "function") {
        if (m2 = u2.props, g2 = (s2 = P2.contextType) && t2[s2.__c], x2 = s2 ? g2 ? g2.props.value : s2.__ : t2, i2.__c ? b2 = (h2 = u2.__c = i2.__c).__ = h2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = h2 = new P2(m2, x2) : (u2.__c = h2 = new _(m2, x2), h2.constructor = P2, h2.render = O), g2 && g2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = x2, h2.__n = t2, v2 = h2.__d = true, h2.__h = []), h2.__s == null && (h2.__s = h2.state), P2.getDerivedStateFromProps != null && (h2.__s == h2.state && (h2.__s = a({}, h2.__s)), a(h2.__s, P2.getDerivedStateFromProps(m2, h2.__s))), y2 = h2.props, p2 = h2.state, v2)
          P2.getDerivedStateFromProps == null && h2.componentWillMount != null && h2.componentWillMount(), h2.componentDidMount != null && h2.__h.push(h2.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && m2 !== y2 && h2.componentWillReceiveProps != null && h2.componentWillReceiveProps(m2, x2), !h2.__e && h2.shouldComponentUpdate != null && h2.shouldComponentUpdate(m2, h2.__s, x2) === false || u2.__v === i2.__v) {
            h2.props = m2, h2.state = h2.__s, u2.__v !== i2.__v && (h2.__d = false), h2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), h2.__h.length && f2.push(h2);
            break n;
          }
          h2.componentWillUpdate != null && h2.componentWillUpdate(m2, h2.__s, x2), h2.componentDidUpdate != null && h2.__h.push(function() {
            h2.componentDidUpdate(y2, p2, k2);
          });
        }
        h2.context = x2, h2.props = m2, h2.state = h2.__s, (s2 = l.__r) && s2(u2), h2.__d = false, h2.__v = u2, h2.__P = n2, s2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s, h2.getChildContext != null && (t2 = a(a({}, t2), h2.getChildContext())), v2 || h2.getSnapshotBeforeUpdate == null || (k2 = h2.getSnapshotBeforeUpdate(y2, p2)), A2 = s2 != null && s2.type === d && s2.key == null ? s2.props.children : s2, w(n2, Array.isArray(A2) ? A2 : [A2], u2, i2, t2, o2, r2, f2, e2, c2), h2.base = u2.__e, u2.__h = null, h2.__h.length && f2.push(h2), b2 && (h2.__E = h2.__ = null), h2.__e = false;
      } else
        r2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = L(i2.__e, u2, i2, t2, o2, r2, f2, c2);
    (s2 = l.diffed) && s2(u2);
  } catch (n3) {
    u2.__v = null, (c2 || r2 != null) && (u2.__e = e2, u2.__h = !!c2, r2[r2.indexOf(e2)] = null), l.__e(n3, u2, i2);
  }
}
function z(n2, u2) {
  l.__c && l.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l.__e(n3, u3.__v);
    }
  });
}
function L(l2, u2, i2, t2, o2, r2, f2, c2) {
  var s2, a2, v2, y2 = i2.props, p2 = u2.props, d2 = u2.type, _2 = 0;
  if (d2 === "svg" && (o2 = true), r2 != null) {
    for (; _2 < r2.length; _2++)
      if ((s2 = r2[_2]) && "setAttribute" in s2 == !!d2 && (d2 ? s2.localName === d2 : s2.nodeType === 3)) {
        l2 = s2, r2[_2] = null;
        break;
      }
  }
  if (l2 == null) {
    if (d2 === null)
      return document.createTextNode(p2);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p2.is && p2), r2 = null, c2 = false;
  }
  if (d2 === null)
    y2 === p2 || c2 && l2.data === p2 || (l2.data = p2);
  else {
    if (r2 = r2 && n.call(l2.childNodes), a2 = (y2 = i2.props || e).dangerouslySetInnerHTML, v2 = p2.dangerouslySetInnerHTML, !c2) {
      if (r2 != null)
        for (y2 = {}, _2 = 0; _2 < l2.attributes.length; _2++)
          y2[l2.attributes[_2].name] = l2.attributes[_2].value;
      (v2 || a2) && (v2 && (a2 && v2.__html == a2.__html || v2.__html === l2.innerHTML) || (l2.innerHTML = v2 && v2.__html || ""));
    }
    if (C(l2, p2, y2, o2, c2), v2)
      u2.__k = [];
    else if (_2 = u2.props.children, w(l2, Array.isArray(_2) ? _2 : [_2], u2, i2, t2, o2 && d2 !== "foreignObject", r2, f2, r2 ? r2[0] : i2.__k && k(i2, 0), c2), r2 != null)
      for (_2 = r2.length; _2--; )
        r2[_2] != null && h$v(r2[_2]);
    c2 || ("value" in p2 && (_2 = p2.value) !== void 0 && (_2 !== l2.value || d2 === "progress" && !_2 || d2 === "option" && _2 !== y2.value) && H(l2, "value", _2, y2.value, false), "checked" in p2 && (_2 = p2.checked) !== void 0 && _2 !== l2.checked && H(l2, "checked", _2, y2.checked, false));
  }
  return l2;
}
function M(n2, u2, i2) {
  try {
    typeof n2 == "function" ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l.__e(n3, i2);
  }
}
function N(n2, u2, i2) {
  var t2, o2;
  if (l.unmount && l.unmount(n2), (t2 = n2.ref) && (t2.current && t2.current !== n2.__e || M(t2, null, u2)), (t2 = n2.__c) != null) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u2);
      }
    t2.base = t2.__P = null;
  }
  if (t2 = n2.__k)
    for (o2 = 0; o2 < t2.length; o2++)
      t2[o2] && N(t2[o2], u2, typeof n2.type != "function");
  i2 || n2.__e == null || h$v(n2.__e), n2.__e = n2.__d = void 0;
}
function O(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function S(u2, i2, t2) {
  var o2, r2, f2;
  l.__ && l.__(u2, i2), r2 = (o2 = typeof t2 == "function") ? null : t2 && t2.__k || i2.__k, f2 = [], j(i2, u2 = (!o2 && t2 || i2).__k = v(d, null, [u2]), r2 || e, e, i2.ownerSVGElement !== void 0, !o2 && t2 ? [t2] : r2 ? null : i2.firstChild ? n.call(i2.childNodes) : null, f2, !o2 && t2 ? t2 : r2 ? r2.__e : i2.firstChild, o2), z(f2, u2);
}
function q(n2, l2) {
  S(n2, l2, q);
}
function B(l2, u2, i2) {
  var t2, o2, r2, f2 = a({}, l2.props);
  for (r2 in u2)
    r2 == "key" ? t2 = u2[r2] : r2 == "ref" ? o2 = u2[r2] : f2[r2] = u2[r2];
  return arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : i2), y(l2.type, f2, t2 || l2.key, o2 || l2.ref, null);
}
function D(n2, l2) {
  var u2 = { __c: l2 = "__cC" + f++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var u3, i2;
    return this.getChildContext || (u3 = [], (i2 = {})[l2] = this, this.getChildContext = function() {
      return i2;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u3.some(m);
    }, this.sub = function(n4) {
      u3.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
n = c.slice, l = { __e: function(n2, l2) {
  for (var u2, i2, t2; l2 = l2.__; )
    if ((u2 = l2.__c) && !u2.__)
      try {
        if ((i2 = u2.constructor) && i2.getDerivedStateFromError != null && (u2.setState(i2.getDerivedStateFromError(n2)), t2 = u2.__d), u2.componentDidCatch != null && (u2.componentDidCatch(n2), t2 = u2.__d), t2)
          return u2.__E = u2;
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return n2 != null && n2.constructor === void 0;
}, _.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a({}, this.state), typeof n2 == "function" && (n2 = n2(a({}, u2), this.props)), n2 && a(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), m(this));
}, _.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), m(this));
}, _.prototype.render = d, t = [], o = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g.__r = 0, f = 0;
var preact_module = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  render: S,
  hydrate: q,
  createElement: v,
  h: v,
  Fragment: d,
  createRef: p,
  get isValidElement() {
    return i;
  },
  Component: _,
  cloneElement: B,
  createContext: D,
  toChildArray: A,
  get options() {
    return l;
  }
}, Symbol.toStringTag, { value: "Module" }));
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(preact_module);
var isDOMElement$3 = function isDOMElement(obj) {
  return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
};
const isDOMElement$2 = isDOMElement$3;
var findDOMElement$1 = function findDOMElement(element, context) {
  if (context === void 0) {
    context = document;
  }
  if (typeof element === "string") {
    return context.querySelector(element);
  }
  if (isDOMElement$2(element)) {
    return element;
  }
  return null;
};
const Translator2 = Translator_1;
var BasePlugin_1 = class BasePlugin {
  constructor(uppy2, opts) {
    if (opts === void 0) {
      opts = {};
    }
    this.uppy = uppy2;
    this.opts = opts;
  }
  getPluginState() {
    const {
      plugins: plugins2
    } = this.uppy.getState();
    return plugins2[this.id] || {};
  }
  setPluginState(update) {
    const {
      plugins: plugins2
    } = this.uppy.getState();
    this.uppy.setState({
      plugins: __spreadProps(__spreadValues({}, plugins2), {
        [this.id]: __spreadValues(__spreadValues({}, plugins2[this.id]), update)
      })
    });
  }
  setOptions(newOpts) {
    this.opts = __spreadValues(__spreadValues({}, this.opts), newOpts);
    this.setPluginState();
    this.i18nInit();
  }
  i18nInit() {
    const translator = new Translator2([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.setPluginState();
  }
  addTarget() {
    throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
  }
  install() {
  }
  uninstall() {
  }
  render() {
    throw new Error("Extend the render method to add your plugin to a DOM element");
  }
  update() {
  }
  afterUpdate() {
  }
};
function _classPrivateFieldLooseBase$6(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$6 = 0;
function _classPrivateFieldLooseKey$6(name) {
  return "__private_" + id$6++ + "_" + name;
}
const {
  render
} = require$$1;
const findDOMElement2 = findDOMElement$1;
const BasePlugin$2 = BasePlugin_1;
function debounce$2(fn) {
  let calling = null;
  let latestArgs = null;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    latestArgs = args;
    if (!calling) {
      calling = Promise.resolve().then(() => {
        calling = null;
        return fn(...latestArgs);
      });
    }
    return calling;
  };
}
var _updateUI = /* @__PURE__ */ _classPrivateFieldLooseKey$6("updateUI");
class UIPlugin$7 extends BasePlugin$2 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _updateUI, {
      writable: true,
      value: void 0
    });
  }
  mount(target, plugin) {
    const callerPluginName = plugin.id;
    const targetElement = findDOMElement2(target);
    if (targetElement) {
      this.isTargetDOMEl = true;
      const uppyRootElement = document.createDocumentFragment();
      _classPrivateFieldLooseBase$6(this, _updateUI)[_updateUI] = debounce$2((state) => {
        if (!this.uppy.getPlugin(this.id))
          return;
        render(this.render(state), uppyRootElement);
        this.afterUpdate();
      });
      this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);
      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = "";
      }
      render(this.render(this.uppy.getState()), uppyRootElement);
      this.el = uppyRootElement.firstElementChild;
      targetElement.appendChild(uppyRootElement);
      this.onMount();
      return this.el;
    }
    let targetPlugin;
    if (typeof target === "object" && target instanceof UIPlugin$7) {
      targetPlugin = target;
    } else if (typeof target === "function") {
      const Target = target;
      this.uppy.iteratePlugins((p2) => {
        if (p2 instanceof Target) {
          targetPlugin = p2;
          return false;
        }
      });
    }
    if (targetPlugin) {
      this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }
    this.uppy.log(`Not installing ${callerPluginName}`);
    let message = `Invalid target option given to ${callerPluginName}.`;
    if (typeof target === "function") {
      message += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.";
    } else {
      message += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.";
    }
    throw new Error(message);
  }
  update(state) {
    if (this.el != null) {
      var _classPrivateFieldLoo, _classPrivateFieldLoo2;
      (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase$6(this, _updateUI))[_updateUI]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
    }
  }
  unmount() {
    if (this.isTargetDOMEl) {
      var _this$el;
      (_this$el = this.el) == null ? void 0 : _this$el.remove();
    }
    this.onUnmount();
  }
  onMount() {
  }
  onUnmount() {
  }
}
var UIPlugin_1 = UIPlugin$7;
const Uppy = Uppy_1;
const UIPlugin$6 = UIPlugin_1;
const BasePlugin$1 = BasePlugin_1;
const {
  debugLogger
} = loggers;
lib$a.exports = Uppy;
lib$a.exports.Uppy = Uppy;
lib$a.exports.UIPlugin = UIPlugin$6;
lib$a.exports.BasePlugin = BasePlugin$1;
lib$a.exports.debugLogger = debugLogger;
var Uppy$1 = lib$a.exports;
class NetworkError$1 extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
}
var NetworkError_1 = NetworkError$1;
const NetworkError = NetworkError_1;
var fetchWithNetworkError$1 = function fetchWithNetworkError() {
  return fetch(...arguments).catch((err) => {
    if (err.name === "AbortError") {
      throw err;
    } else {
      throw new NetworkError(err);
    }
  });
};
class AuthError$1 extends Error {
  constructor() {
    super("Authorization required");
    this.name = "AuthError";
    this.isAuthError = true;
  }
}
var AuthError_1 = AuthError$1;
var _class$7, _getPostResponseFunc, _getUrl, _errorHandler, _temp$7;
function _classPrivateFieldLooseBase$5(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$5 = 0;
function _classPrivateFieldLooseKey$5(name) {
  return "__private_" + id$5++ + "_" + name;
}
const fetchWithNetworkError2 = fetchWithNetworkError$1;
const AuthError = AuthError_1;
function stripSlash(url) {
  return url.replace(/\/$/, "");
}
async function handleJSONResponse(res) {
  if (res.status === 401) {
    throw new AuthError();
  }
  const jsonPromise = res.json();
  if (res.status < 200 || res.status > 300) {
    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
    try {
      const errData = await jsonPromise;
      errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
      errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
    } finally {
      throw new Error(errMsg);
    }
  }
  return jsonPromise;
}
var RequestClient_1 = (_temp$7 = (_getPostResponseFunc = /* @__PURE__ */ _classPrivateFieldLooseKey$5("getPostResponseFunc"), _getUrl = /* @__PURE__ */ _classPrivateFieldLooseKey$5("getUrl"), _errorHandler = /* @__PURE__ */ _classPrivateFieldLooseKey$5("errorHandler"), _class$7 = class RequestClient {
  constructor(uppy2, opts) {
    Object.defineProperty(this, _errorHandler, {
      value: _errorHandler2
    });
    Object.defineProperty(this, _getUrl, {
      value: _getUrl2
    });
    Object.defineProperty(this, _getPostResponseFunc, {
      writable: true,
      value: (skip) => (response) => skip ? response : this.onReceiveResponse(response)
    });
    this.uppy = uppy2;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ["accept", "content-type", "uppy-auth-token"];
    this.preflightDone = false;
  }
  get hostname() {
    const {
      companion
    } = this.uppy.getState();
    const host = this.opts.companionUrl;
    return stripSlash(companion && companion[host] ? companion[host] : host);
  }
  headers() {
    const userHeaders = this.opts.companionHeaders || {};
    return Promise.resolve(__spreadValues(__spreadValues({}, RequestClient.defaultHeaders), userHeaders));
  }
  onReceiveResponse(response) {
    const state = this.uppy.getState();
    const companion = state.companion || {};
    const host = this.opts.companionUrl;
    const {
      headers
    } = response;
    if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
      this.uppy.setState({
        companion: __spreadProps(__spreadValues({}, companion), {
          [host]: headers.get("i-am")
        })
      });
    }
    return response;
  }
  preflight(path) {
    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }
    return fetch(_classPrivateFieldLooseBase$5(this, _getUrl)[_getUrl](path), {
      method: "OPTIONS"
    }).then((response) => {
      if (response.headers.has("access-control-allow-headers")) {
        this.allowedHeaders = response.headers.get("access-control-allow-headers").split(",").map((headerName) => headerName.trim().toLowerCase());
      }
      this.preflightDone = true;
      return this.allowedHeaders.slice();
    }).catch((err) => {
      this.uppy.log(`[CompanionClient] unable to make preflight request ${err}`, "warning");
      this.preflightDone = true;
      return this.allowedHeaders.slice();
    });
  }
  preflightAndHeaders(path) {
    return Promise.all([this.preflight(path), this.headers()]).then((_ref) => {
      let [allowedHeaders, headers] = _ref;
      Object.keys(headers).forEach((header) => {
        if (!allowedHeaders.includes(header.toLowerCase())) {
          this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
          delete headers[header];
        }
      });
      return headers;
    });
  }
  get(path, skipPostResponse) {
    const method = "get";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError2(_classPrivateFieldLooseBase$5(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin"
    })).then(_classPrivateFieldLooseBase$5(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$5(this, _errorHandler)[_errorHandler](method, path));
  }
  post(path, data, skipPostResponse) {
    const method = "post";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError2(_classPrivateFieldLooseBase$5(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin",
      body: JSON.stringify(data)
    })).then(_classPrivateFieldLooseBase$5(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$5(this, _errorHandler)[_errorHandler](method, path));
  }
  delete(path, data, skipPostResponse) {
    const method = "delete";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError2(`${this.hostname}/${path}`, {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin",
      body: data ? JSON.stringify(data) : null
    })).then(_classPrivateFieldLooseBase$5(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$5(this, _errorHandler)[_errorHandler](method, path));
  }
}), _class$7.VERSION = "2.0.5", _class$7.defaultHeaders = {
  Accept: "application/json",
  "Content-Type": "application/json",
  "Uppy-Versions": `@uppy/companion-client=${_class$7.VERSION}`
}, _temp$7);
function _getUrl2(url) {
  if (/^(https?:|)\/\//.test(url)) {
    return url;
  }
  return `${this.hostname}/${url}`;
}
function _errorHandler2(method, path) {
  return (err) => {
    var _err;
    if (!((_err = err) != null && _err.isAuthError)) {
      const error = new Error(`Could not ${method} ${_classPrivateFieldLooseBase$5(this, _getUrl)[_getUrl](path)}`);
      error.cause = err;
      err = error;
    }
    return Promise.reject(err);
  };
}
var tokenStorage$1 = {};
tokenStorage$1.setItem = (key, value) => {
  return new Promise((resolve) => {
    localStorage.setItem(key, value);
    resolve();
  });
};
tokenStorage$1.getItem = (key) => {
  return Promise.resolve(localStorage.getItem(key));
};
tokenStorage$1.removeItem = (key) => {
  return new Promise((resolve) => {
    localStorage.removeItem(key);
    resolve();
  });
};
const RequestClient$3 = RequestClient_1;
const tokenStorage = tokenStorage$1;
const getName$1 = (id2) => {
  return id2.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
};
var Provider_1 = class Provider extends RequestClient$3 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName$1(this.id);
    this.pluginId = this.opts.pluginId;
    this.tokenKey = `companion-${this.pluginId}-auth-token`;
    this.companionKeysParams = this.opts.companionKeysParams;
    this.preAuthToken = null;
  }
  headers() {
    return Promise.all([super.headers(), this.getAuthToken()]).then((_ref) => {
      let [headers, token] = _ref;
      const authHeaders = {};
      if (token) {
        authHeaders["uppy-auth-token"] = token;
      }
      if (this.companionKeysParams) {
        authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
          params: this.companionKeysParams
        }));
      }
      return __spreadValues(__spreadValues({}, headers), authHeaders);
    });
  }
  onReceiveResponse(response) {
    response = super.onReceiveResponse(response);
    const plugin = this.uppy.getPlugin(this.pluginId);
    const oldAuthenticated = plugin.getPluginState().authenticated;
    const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated
    });
    return response;
  }
  setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  }
  getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  }
  async ensurePreAuth() {
    if (this.companionKeysParams && !this.preAuthToken) {
      await this.fetchPreAuthToken();
      if (!this.preAuthToken) {
        throw new Error("Could not load authentication data required for third-party login. Please try again later.");
      }
    }
  }
  authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }
    const params = new URLSearchParams(queries);
    if (this.preAuthToken) {
      params.set("uppyPreAuthToken", this.preAuthToken);
    }
    return `${this.hostname}/${this.id}/connect?${params}`;
  }
  fileUrl(id2) {
    return `${this.hostname}/${this.id}/get/${id2}`;
  }
  async fetchPreAuthToken() {
    if (!this.companionKeysParams) {
      return;
    }
    try {
      const res = await this.post(`${this.id}/preauth/`, {
        params: this.companionKeysParams
      });
      this.preAuthToken = res.token;
    } catch (err) {
      this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err}`, "warning");
    }
  }
  list(directory) {
    return this.get(`${this.id}/list/${directory || ""}`);
  }
  logout() {
    return this.get(`${this.id}/logout`).then((response) => Promise.all([response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)])).then((_ref2) => {
      let [response] = _ref2;
      return response;
    });
  }
  static initPlugin(plugin, opts, defaultOpts) {
    plugin.type = "acquirer";
    plugin.files = [];
    if (defaultOpts) {
      plugin.opts = __spreadValues(__spreadValues({}, defaultOpts), opts);
    }
    if (opts.serverUrl || opts.serverPattern) {
      throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
    }
    if (opts.companionAllowedHosts) {
      const pattern = opts.companionAllowedHosts;
      if (typeof pattern !== "string" && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
      }
      plugin.opts.companionAllowedHosts = pattern;
    } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
      plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`;
    } else {
      plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
    }
    plugin.storage = plugin.opts.storage || tokenStorage;
  }
};
const RequestClient$2 = RequestClient_1;
const getName = (id2) => {
  return id2.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
};
var SearchProvider_1 = class SearchProvider extends RequestClient$2 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName(this.id);
    this.pluginId = this.opts.pluginId;
  }
  fileUrl(id2) {
    return `${this.hostname}/search/${this.id}/get/${id2}`;
  }
  search(text, queries) {
    queries = queries ? `&${queries}` : "";
    return this.get(`search/${this.id}/list?q=${encodeURIComponent(text)}${queries}`);
  }
};
var _queued, _emitter$1, _isOpen, _socket, _handleMessage;
let _Symbol$for$1, _Symbol$for2;
function _classPrivateFieldLooseBase$4(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$4 = 0;
function _classPrivateFieldLooseKey$4(name) {
  return "__private_" + id$4++ + "_" + name;
}
const ee = namespaceEmitter;
var Socket$2 = (_queued = /* @__PURE__ */ _classPrivateFieldLooseKey$4("queued"), _emitter$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$4("emitter"), _isOpen = /* @__PURE__ */ _classPrivateFieldLooseKey$4("isOpen"), _socket = /* @__PURE__ */ _classPrivateFieldLooseKey$4("socket"), _handleMessage = /* @__PURE__ */ _classPrivateFieldLooseKey$4("handleMessage"), _Symbol$for$1 = Symbol.for("uppy test: getSocket"), _Symbol$for2 = Symbol.for("uppy test: getQueued"), class UppySocket {
  constructor(opts) {
    Object.defineProperty(this, _queued, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _emitter$1, {
      writable: true,
      value: ee()
    });
    Object.defineProperty(this, _isOpen, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _socket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleMessage, {
      writable: true,
      value: (e2) => {
        try {
          const message = JSON.parse(e2.data);
          this.emit(message.action, message.payload);
        } catch (err) {
          console.log(err);
        }
      }
    });
    this.opts = opts;
    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }
  get isOpen() {
    return _classPrivateFieldLooseBase$4(this, _isOpen)[_isOpen];
  }
  [_Symbol$for$1]() {
    return _classPrivateFieldLooseBase$4(this, _socket)[_socket];
  }
  [_Symbol$for2]() {
    return _classPrivateFieldLooseBase$4(this, _queued)[_queued];
  }
  open() {
    _classPrivateFieldLooseBase$4(this, _socket)[_socket] = new WebSocket(this.opts.target);
    _classPrivateFieldLooseBase$4(this, _socket)[_socket].onopen = () => {
      _classPrivateFieldLooseBase$4(this, _isOpen)[_isOpen] = true;
      while (_classPrivateFieldLooseBase$4(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase$4(this, _isOpen)[_isOpen]) {
        const first = _classPrivateFieldLooseBase$4(this, _queued)[_queued].shift();
        this.send(first.action, first.payload);
      }
    };
    _classPrivateFieldLooseBase$4(this, _socket)[_socket].onclose = () => {
      _classPrivateFieldLooseBase$4(this, _isOpen)[_isOpen] = false;
    };
    _classPrivateFieldLooseBase$4(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase$4(this, _handleMessage)[_handleMessage];
  }
  close() {
    var _classPrivateFieldLoo;
    (_classPrivateFieldLoo = _classPrivateFieldLooseBase$4(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
  }
  send(action, payload) {
    if (!_classPrivateFieldLooseBase$4(this, _isOpen)[_isOpen]) {
      _classPrivateFieldLooseBase$4(this, _queued)[_queued].push({
        action,
        payload
      });
      return;
    }
    _classPrivateFieldLooseBase$4(this, _socket)[_socket].send(JSON.stringify({
      action,
      payload
    }));
  }
  on(action, handler) {
    _classPrivateFieldLooseBase$4(this, _emitter$1)[_emitter$1].on(action, handler);
  }
  emit(action, payload) {
    _classPrivateFieldLooseBase$4(this, _emitter$1)[_emitter$1].emit(action, payload);
  }
  once(action, handler) {
    _classPrivateFieldLooseBase$4(this, _emitter$1)[_emitter$1].once(action, handler);
  }
});
const RequestClient$1 = RequestClient_1;
const Provider$1 = Provider_1;
const SearchProvider2 = SearchProvider_1;
const Socket$1 = Socket$2;
var lib$8 = {
  RequestClient: RequestClient$1,
  Provider: Provider$1,
  SearchProvider: SearchProvider2,
  Socket: Socket$1
};
var _emitter, _events;
function _classPrivateFieldLooseBase$3(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$3 = 0;
function _classPrivateFieldLooseKey$3(name) {
  return "__private_" + id$3++ + "_" + name;
}
var EventTracker_1 = (_emitter = /* @__PURE__ */ _classPrivateFieldLooseKey$3("emitter"), _events = /* @__PURE__ */ _classPrivateFieldLooseKey$3("events"), class EventTracker {
  constructor(emitter) {
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase$3(this, _emitter)[_emitter] = emitter;
  }
  on(event, fn) {
    _classPrivateFieldLooseBase$3(this, _events)[_events].push([event, fn]);
    return _classPrivateFieldLooseBase$3(this, _emitter)[_emitter].on(event, fn);
  }
  remove() {
    for (const [event, fn] of _classPrivateFieldLooseBase$3(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase$3(this, _emitter)[_emitter].off(event, fn);
    }
  }
});
const throttle$1 = lodash_throttle;
function emitSocketProgress$1(uploader, progressData, file) {
  const {
    progress,
    bytesUploaded,
    bytesTotal
  } = progressData;
  if (progress) {
    uploader.uppy.log(`Upload progress: ${progress}`);
    uploader.uppy.emit("upload-progress", file, {
      uploader,
      bytesUploaded,
      bytesTotal
    });
  }
}
var emitSocketProgress_1 = throttle$1(emitSocketProgress$1, 300, {
  leading: true,
  trailing: true
});
var getSocketHost$1 = function getSocketHost(url) {
  const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  const host = regex.exec(url)[1];
  const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
  return `${socketProtocol}://${host}`;
};
function _classPrivateFieldLooseBase$2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$2 = 0;
function _classPrivateFieldLooseKey$2(name) {
  return "__private_" + id$2++ + "_" + name;
}
function createCancelError() {
  return new Error("Cancelled");
}
var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey$2("activeRequests");
var _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey$2("queuedHandlers");
var _paused = /* @__PURE__ */ _classPrivateFieldLooseKey$2("paused");
var _pauseTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$2("pauseTimer");
var _downLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$2("downLimit");
var _upperLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$2("upperLimit");
var _rateLimitingTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$2("rateLimitingTimer");
var _call = /* @__PURE__ */ _classPrivateFieldLooseKey$2("call");
var _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey$2("queueNext");
var _next = /* @__PURE__ */ _classPrivateFieldLooseKey$2("next");
var _queue = /* @__PURE__ */ _classPrivateFieldLooseKey$2("queue");
var _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey$2("dequeue");
var _resume = /* @__PURE__ */ _classPrivateFieldLooseKey$2("resume");
var _increaseLimit = /* @__PURE__ */ _classPrivateFieldLooseKey$2("increaseLimit");
class RateLimitedQueue$1 {
  constructor(limit) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _paused, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _pauseTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _downLimit, {
      writable: true,
      value: 1
    });
    Object.defineProperty(this, _upperLimit, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rateLimitingTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _resume, {
      writable: true,
      value: () => this.resume()
    });
    Object.defineProperty(this, _increaseLimit, {
      writable: true,
      value: () => {
        if (_classPrivateFieldLooseBase$2(this, _paused)[_paused]) {
          _classPrivateFieldLooseBase$2(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$2(this, _increaseLimit)[_increaseLimit], 0);
          return;
        }
        _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit] = this.limit;
        this.limit = Math.ceil((_classPrivateFieldLooseBase$2(this, _upperLimit)[_upperLimit] + _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit]) / 2);
        for (let i2 = _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit]; i2 <= this.limit; i2++) {
          _classPrivateFieldLooseBase$2(this, _queueNext)[_queueNext]();
        }
        if (_classPrivateFieldLooseBase$2(this, _upperLimit)[_upperLimit] - _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit] > 3) {
          _classPrivateFieldLooseBase$2(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$2(this, _increaseLimit)[_increaseLimit], 2e3);
        } else {
          _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit] = Math.floor(_classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit] / 2);
        }
      }
    });
    if (typeof limit !== "number" || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }
  }
  run(fn, queueOptions) {
    if (!_classPrivateFieldLooseBase$2(this, _paused)[_paused] && _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase$2(this, _call)[_call](fn);
    }
    return _classPrivateFieldLooseBase$2(this, _queue)[_queue](fn, queueOptions);
  }
  wrapPromiseFunction(fn, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = _this.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn(...args));
          } catch (err) {
            innerPromise = Promise.reject(err);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, (err) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return () => {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });
      outerPromise.abort = () => {
        queuedRequest.abort();
      };
      return outerPromise;
    };
  }
  resume() {
    _classPrivateFieldLooseBase$2(this, _paused)[_paused] = false;
    clearTimeout(_classPrivateFieldLooseBase$2(this, _pauseTimer)[_pauseTimer]);
    for (let i2 = 0; i2 < this.limit; i2++) {
      _classPrivateFieldLooseBase$2(this, _queueNext)[_queueNext]();
    }
  }
  pause(duration2) {
    if (duration2 === void 0) {
      duration2 = null;
    }
    _classPrivateFieldLooseBase$2(this, _paused)[_paused] = true;
    clearTimeout(_classPrivateFieldLooseBase$2(this, _pauseTimer)[_pauseTimer]);
    if (duration2 != null) {
      _classPrivateFieldLooseBase$2(this, _pauseTimer)[_pauseTimer] = setTimeout(_classPrivateFieldLooseBase$2(this, _resume)[_resume], duration2);
    }
  }
  rateLimit(duration2) {
    clearTimeout(_classPrivateFieldLooseBase$2(this, _rateLimitingTimer)[_rateLimitingTimer]);
    this.pause(duration2);
    if (this.limit > 1 && Number.isFinite(this.limit)) {
      _classPrivateFieldLooseBase$2(this, _upperLimit)[_upperLimit] = this.limit - 1;
      this.limit = _classPrivateFieldLooseBase$2(this, _downLimit)[_downLimit];
      _classPrivateFieldLooseBase$2(this, _rateLimitingTimer)[_rateLimitingTimer] = setTimeout(_classPrivateFieldLooseBase$2(this, _increaseLimit)[_increaseLimit], duration2);
    }
  }
  get isPaused() {
    return _classPrivateFieldLooseBase$2(this, _paused)[_paused];
  }
}
function _call2(fn) {
  _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn();
  } catch (err) {
    _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] -= 1;
    throw err;
  }
  return {
    abort: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive();
      _classPrivateFieldLooseBase$2(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase$2(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase$2(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase$2(this, _paused)[_paused] || _classPrivateFieldLooseBase$2(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].shift();
  const handler = _classPrivateFieldLooseBase$2(this, _call)[_call](next.fn);
  next.abort = handler.abort;
  next.done = handler.done;
}
function _queue2(fn, options) {
  if (options === void 0) {
    options = {};
  }
  const handler = {
    fn,
    priority: options.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase$2(this, _dequeue)[_dequeue](handler);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index = _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler.priority > other.priority;
  });
  if (index === -1) {
    _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].push(handler);
  } else {
    _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler);
  }
  return handler;
}
function _dequeue2(handler) {
  const index = _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].indexOf(handler);
  if (index !== -1) {
    _classPrivateFieldLooseBase$2(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}
var RateLimitedQueue_1 = {
  RateLimitedQueue: RateLimitedQueue$1,
  internalRateLimitedQueue: Symbol("__queue")
};
var AbortController$1 = {};
AbortController$1.AbortController = globalThis.AbortController;
AbortController$1.AbortSignal = globalThis.AbortSignal;
AbortController$1.createAbortError = function(message) {
  if (message === void 0) {
    message = "Aborted";
  }
  return new DOMException(message, "AbortError");
};
const {
  createAbortError: createAbortError$1
} = AbortController$1;
var delay$1 = function delay(ms, opts) {
  return new Promise((resolve, reject) => {
    var _opts$signal, _opts$signal2;
    if (opts != null && (_opts$signal = opts.signal) != null && _opts$signal.aborted) {
      return reject(createAbortError$1());
    }
    const timeout = setTimeout(() => {
      cleanup();
      resolve();
    }, ms);
    function onabort() {
      clearTimeout(timeout);
      cleanup();
      reject(createAbortError$1());
    }
    opts == null ? void 0 : (_opts$signal2 = opts.signal) == null ? void 0 : _opts$signal2.addEventListener("abort", onabort);
    function cleanup() {
      var _opts$signal3;
      opts == null ? void 0 : (_opts$signal3 = opts.signal) == null ? void 0 : _opts$signal3.removeEventListener("abort", onabort);
    }
    return void 0;
  });
};
function _classPrivateFieldLooseBase$1(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$1 = 0;
function _classPrivateFieldLooseKey$1(name) {
  return "__private_" + id$1++ + "_" + name;
}
const {
  AbortController,
  createAbortError
} = AbortController$1;
const delay2 = delay$1;
const MB = 1024 * 1024;
const defaultOptions = {
  limit: 1,
  retryDelays: [0, 1e3, 3e3, 5e3],
  getChunkSize(file) {
    return Math.ceil(file.size / 1e4);
  },
  onStart() {
  },
  onProgress() {
  },
  onPartComplete() {
  },
  onSuccess() {
  },
  onError(err) {
    throw err;
  }
};
function ensureInt(value) {
  if (typeof value === "string") {
    return parseInt(value, 10);
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError("Expected a number");
}
var _aborted = /* @__PURE__ */ _classPrivateFieldLooseKey$1("aborted");
var _initChunks = /* @__PURE__ */ _classPrivateFieldLooseKey$1("initChunks");
var _createUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$1("createUpload");
var _resumeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$1("resumeUpload");
var _uploadParts = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadParts");
var _retryable = /* @__PURE__ */ _classPrivateFieldLooseKey$1("retryable");
var _prepareUploadParts = /* @__PURE__ */ _classPrivateFieldLooseKey$1("prepareUploadParts");
var _uploadPartRetryable = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadPartRetryable");
var _uploadPart = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadPart");
var _onPartProgress = /* @__PURE__ */ _classPrivateFieldLooseKey$1("onPartProgress");
var _onPartComplete = /* @__PURE__ */ _classPrivateFieldLooseKey$1("onPartComplete");
var _uploadPartBytes = /* @__PURE__ */ _classPrivateFieldLooseKey$1("uploadPartBytes");
var _completeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$1("completeUpload");
var _abortUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$1("abortUpload");
var _onError = /* @__PURE__ */ _classPrivateFieldLooseKey$1("onError");
class MultipartUploader$1 {
  constructor(file, options) {
    Object.defineProperty(this, _onError, {
      value: _onError2
    });
    Object.defineProperty(this, _abortUpload, {
      value: _abortUpload2
    });
    Object.defineProperty(this, _completeUpload, {
      value: _completeUpload2
    });
    Object.defineProperty(this, _uploadPartBytes, {
      value: _uploadPartBytes2
    });
    Object.defineProperty(this, _onPartComplete, {
      value: _onPartComplete2
    });
    Object.defineProperty(this, _onPartProgress, {
      value: _onPartProgress2
    });
    Object.defineProperty(this, _uploadPart, {
      value: _uploadPart2
    });
    Object.defineProperty(this, _uploadPartRetryable, {
      value: _uploadPartRetryable2
    });
    Object.defineProperty(this, _prepareUploadParts, {
      value: _prepareUploadParts2
    });
    Object.defineProperty(this, _retryable, {
      value: _retryable2
    });
    Object.defineProperty(this, _uploadParts, {
      value: _uploadParts2
    });
    Object.defineProperty(this, _resumeUpload, {
      value: _resumeUpload2
    });
    Object.defineProperty(this, _createUpload, {
      value: _createUpload2
    });
    Object.defineProperty(this, _initChunks, {
      value: _initChunks2
    });
    Object.defineProperty(this, _aborted, {
      value: _aborted2
    });
    this.options = __spreadValues(__spreadValues({}, defaultOptions), options);
    if (!this.options.getChunkSize) {
      this.options.getChunkSize = defaultOptions.getChunkSize;
    }
    this.file = file;
    this.abortController = new AbortController();
    this.key = this.options.key || null;
    this.uploadId = this.options.uploadId || null;
    this.parts = [];
    this.createdPromise = Promise.reject();
    this.isPaused = false;
    this.partsInProgress = 0;
    this.chunks = null;
    this.chunkState = null;
    _classPrivateFieldLooseBase$1(this, _initChunks)[_initChunks]();
    this.createdPromise.catch(() => {
    });
  }
  start() {
    this.isPaused = false;
    if (this.uploadId) {
      _classPrivateFieldLooseBase$1(this, _resumeUpload)[_resumeUpload]();
    } else {
      _classPrivateFieldLooseBase$1(this, _createUpload)[_createUpload]();
    }
  }
  pause() {
    this.abortController.abort();
    this.abortController = new AbortController();
    this.isPaused = true;
  }
  abort(opts) {
    var _opts;
    if (opts === void 0) {
      opts = void 0;
    }
    if ((_opts = opts) != null && _opts.really)
      _classPrivateFieldLooseBase$1(this, _abortUpload)[_abortUpload]();
    else
      this.pause();
  }
}
function _aborted2() {
  return this.abortController.signal.aborted;
}
function _initChunks2() {
  const chunks2 = [];
  const desiredChunkSize = this.options.getChunkSize(this.file);
  const minChunkSize = Math.max(5 * MB, Math.ceil(this.file.size / 1e4));
  const chunkSize = Math.max(desiredChunkSize, minChunkSize);
  if (this.file.size === 0) {
    chunks2.push(this.file);
  } else {
    for (let i2 = 0; i2 < this.file.size; i2 += chunkSize) {
      const end = Math.min(this.file.size, i2 + chunkSize);
      chunks2.push(this.file.slice(i2, end));
    }
  }
  this.chunks = chunks2;
  this.chunkState = chunks2.map(() => ({
    uploaded: 0,
    busy: false,
    done: false
  }));
}
function _createUpload2() {
  this.createdPromise = Promise.resolve().then(() => this.options.createMultipartUpload());
  return this.createdPromise.then((result) => {
    if (_classPrivateFieldLooseBase$1(this, _aborted)[_aborted]())
      throw createAbortError();
    const valid = typeof result === "object" && result && typeof result.uploadId === "string" && typeof result.key === "string";
    if (!valid) {
      throw new TypeError("AwsS3/Multipart: Got incorrect result from `createMultipartUpload()`, expected an object `{ uploadId, key }`.");
    }
    this.key = result.key;
    this.uploadId = result.uploadId;
    this.options.onStart(result);
    _classPrivateFieldLooseBase$1(this, _uploadParts)[_uploadParts]();
  }).catch((err) => {
    _classPrivateFieldLooseBase$1(this, _onError)[_onError](err);
  });
}
async function _resumeUpload2() {
  try {
    const parts = await this.options.listParts({
      uploadId: this.uploadId,
      key: this.key
    });
    if (_classPrivateFieldLooseBase$1(this, _aborted)[_aborted]())
      throw createAbortError();
    parts.forEach((part) => {
      const i2 = part.PartNumber - 1;
      this.chunkState[i2] = {
        uploaded: ensureInt(part.Size),
        etag: part.ETag,
        done: true
      };
      if (!this.parts.some((p2) => p2.PartNumber === part.PartNumber)) {
        this.parts.push({
          PartNumber: part.PartNumber,
          ETag: part.ETag
        });
      }
    });
    _classPrivateFieldLooseBase$1(this, _uploadParts)[_uploadParts]();
  } catch (err) {
    _classPrivateFieldLooseBase$1(this, _onError)[_onError](err);
  }
}
function _uploadParts2() {
  if (this.isPaused)
    return;
  if (this.chunkState.every((state) => state.done)) {
    _classPrivateFieldLooseBase$1(this, _completeUpload)[_completeUpload]();
    return;
  }
  const need = this.options.limit - this.partsInProgress;
  const completeChunks = this.chunkState.filter((state) => state.done).length;
  const remainingChunks = this.chunks.length - completeChunks;
  let minNeeded = Math.ceil(this.options.limit / 2);
  if (minNeeded > remainingChunks) {
    minNeeded = remainingChunks;
  }
  if (need < minNeeded)
    return;
  const candidates = [];
  for (let i2 = 0; i2 < this.chunkState.length; i2++) {
    const state = this.chunkState[i2];
    if (state.done || state.busy)
      continue;
    candidates.push(i2);
    if (candidates.length >= need) {
      break;
    }
  }
  if (candidates.length === 0)
    return;
  _classPrivateFieldLooseBase$1(this, _prepareUploadParts)[_prepareUploadParts](candidates).then((result) => {
    candidates.forEach((index) => {
      const partNumber = index + 1;
      const prePreparedPart = {
        url: result.presignedUrls[partNumber],
        headers: result.headers
      };
      _classPrivateFieldLooseBase$1(this, _uploadPartRetryable)[_uploadPartRetryable](index, prePreparedPart).then(() => {
        _classPrivateFieldLooseBase$1(this, _uploadParts)[_uploadParts]();
      }, (err) => {
        _classPrivateFieldLooseBase$1(this, _onError)[_onError](err);
      });
    });
  });
}
function _retryable2(_ref) {
  let {
    before,
    attempt,
    after
  } = _ref;
  const {
    retryDelays
  } = this.options;
  const {
    signal
  } = this.abortController;
  if (before)
    before();
  function shouldRetry(err) {
    if (err.source && typeof err.source.status === "number") {
      const {
        status
      } = err.source;
      return status === 0 || status === 409 || status === 423 || status >= 500 && status < 600;
    }
    return false;
  }
  const doAttempt = (retryAttempt) => attempt().catch((err) => {
    if (_classPrivateFieldLooseBase$1(this, _aborted)[_aborted]())
      throw createAbortError();
    if (shouldRetry(err) && retryAttempt < retryDelays.length) {
      return delay2(retryDelays[retryAttempt], {
        signal
      }).then(() => doAttempt(retryAttempt + 1));
    }
    throw err;
  });
  return doAttempt(0).then((result) => {
    if (after)
      after();
    return result;
  }, (err) => {
    if (after)
      after();
    throw err;
  });
}
async function _prepareUploadParts2(candidates) {
  candidates.forEach((i2) => {
    this.chunkState[i2].busy = true;
  });
  const result = await _classPrivateFieldLooseBase$1(this, _retryable)[_retryable]({
    attempt: () => this.options.prepareUploadParts({
      key: this.key,
      uploadId: this.uploadId,
      partNumbers: candidates.map((index) => index + 1),
      chunks: candidates.reduce((chunks2, candidate) => __spreadProps(__spreadValues({}, chunks2), {
        [candidate + 1]: this.chunks[candidate]
      }), {})
    })
  });
  if (typeof (result == null ? void 0 : result.presignedUrls) !== "object") {
    throw new TypeError("AwsS3/Multipart: Got incorrect result from `prepareUploadParts()`, expected an object `{ presignedUrls }`.");
  }
  return result;
}
function _uploadPartRetryable2(index, prePreparedPart) {
  return _classPrivateFieldLooseBase$1(this, _retryable)[_retryable]({
    before: () => {
      this.partsInProgress += 1;
    },
    attempt: () => _classPrivateFieldLooseBase$1(this, _uploadPart)[_uploadPart](index, prePreparedPart),
    after: () => {
      this.partsInProgress -= 1;
    }
  });
}
function _uploadPart2(index, prePreparedPart) {
  this.chunkState[index].busy = true;
  const valid = typeof (prePreparedPart == null ? void 0 : prePreparedPart.url) === "string";
  if (!valid) {
    throw new TypeError("AwsS3/Multipart: Got incorrect result for `prePreparedPart`, expected an object `{ url }`.");
  }
  const {
    url,
    headers
  } = prePreparedPart;
  if (_classPrivateFieldLooseBase$1(this, _aborted)[_aborted]()) {
    this.chunkState[index].busy = false;
    throw createAbortError();
  }
  return _classPrivateFieldLooseBase$1(this, _uploadPartBytes)[_uploadPartBytes](index, url, headers);
}
function _onPartProgress2(index, sent) {
  this.chunkState[index].uploaded = ensureInt(sent);
  const totalUploaded = this.chunkState.reduce((n2, c2) => n2 + c2.uploaded, 0);
  this.options.onProgress(totalUploaded, this.file.size);
}
function _onPartComplete2(index, etag) {
  this.chunkState[index].etag = etag;
  this.chunkState[index].done = true;
  const part = {
    PartNumber: index + 1,
    ETag: etag
  };
  this.parts.push(part);
  this.options.onPartComplete(part);
}
function _uploadPartBytes2(index, url, headers) {
  const body = this.chunks[index];
  const {
    signal
  } = this.abortController;
  let defer;
  const promise = new Promise((resolve, reject) => {
    defer = {
      resolve,
      reject
    };
  });
  const xhr = new XMLHttpRequest();
  xhr.open("PUT", url, true);
  if (headers) {
    Object.keys(headers).forEach((key) => {
      xhr.setRequestHeader(key, headers[key]);
    });
  }
  xhr.responseType = "text";
  function cleanup() {
    signal.removeEventListener("abort", onabort);
  }
  function onabort() {
    xhr.abort();
  }
  signal.addEventListener("abort", onabort);
  xhr.upload.addEventListener("progress", (ev) => {
    if (!ev.lengthComputable)
      return;
    _classPrivateFieldLooseBase$1(this, _onPartProgress)[_onPartProgress](index, ev.loaded, ev.total);
  });
  xhr.addEventListener("abort", () => {
    cleanup();
    this.chunkState[index].busy = false;
    defer.reject(createAbortError());
  });
  xhr.addEventListener("load", (ev) => {
    cleanup();
    this.chunkState[index].busy = false;
    if (ev.target.status < 200 || ev.target.status >= 300) {
      const error = new Error("Non 2xx");
      error.source = ev.target;
      defer.reject(error);
      return;
    }
    this.chunks[index] = null;
    _classPrivateFieldLooseBase$1(this, _onPartProgress)[_onPartProgress](index, body.size, body.size);
    const etag = ev.target.getResponseHeader("ETag");
    if (etag === null) {
      defer.reject(new Error("AwsS3/Multipart: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions."));
      return;
    }
    _classPrivateFieldLooseBase$1(this, _onPartComplete)[_onPartComplete](index, etag);
    defer.resolve();
  });
  xhr.addEventListener("error", (ev) => {
    cleanup();
    this.chunkState[index].busy = false;
    const error = new Error("Unknown error");
    error.source = ev.target;
    defer.reject(error);
  });
  xhr.send(body);
  return promise;
}
async function _completeUpload2() {
  this.parts.sort((a2, b2) => a2.PartNumber - b2.PartNumber);
  try {
    const result = await this.options.completeMultipartUpload({
      key: this.key,
      uploadId: this.uploadId,
      parts: this.parts
    });
    this.options.onSuccess(result);
  } catch (err) {
    _classPrivateFieldLooseBase$1(this, _onError)[_onError](err);
  }
}
function _abortUpload2() {
  this.abortController.abort();
  this.createdPromise.then(() => {
    this.options.abortMultipartUpload({
      key: this.key,
      uploadId: this.uploadId
    });
  }, () => {
  });
}
function _onError2(err) {
  if (err && err.name === "AbortError") {
    return;
  }
  this.options.onError(err);
}
var MultipartUploader_1 = MultipartUploader$1;
var _class$6, _temp$6;
const BasePlugin2 = BasePlugin_1;
const {
  Socket,
  Provider: Provider2,
  RequestClient: RequestClient2
} = lib$8;
const EventTracker2 = EventTracker_1;
const emitSocketProgress = emitSocketProgress_1;
const getSocketHost2 = getSocketHost$1;
const {
  RateLimitedQueue
} = RateLimitedQueue_1;
const MultipartUploader = MultipartUploader_1;
function assertServerError(res) {
  if (res && res.error) {
    const error = new Error(res.message);
    Object.assign(error, res.error);
    throw error;
  }
  return res;
}
var lib$7 = (_temp$6 = _class$6 = class AwsS3Multipart extends BasePlugin2 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.type = "uploader";
    this.id = this.opts.id || "AwsS3Multipart";
    this.title = "AWS S3 Multipart";
    this.client = new RequestClient2(uppy2, opts);
    const defaultOptions2 = {
      timeout: 30 * 1e3,
      limit: 0,
      retryDelays: [0, 1e3, 3e3, 5e3],
      createMultipartUpload: this.createMultipartUpload.bind(this),
      listParts: this.listParts.bind(this),
      prepareUploadParts: this.prepareUploadParts.bind(this),
      abortMultipartUpload: this.abortMultipartUpload.bind(this),
      completeMultipartUpload: this.completeMultipartUpload.bind(this)
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
    this.upload = this.upload.bind(this);
    this.requests = new RateLimitedQueue(this.opts.limit);
    this.uploaders = /* @__PURE__ */ Object.create(null);
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
    this.uploaderSockets = /* @__PURE__ */ Object.create(null);
  }
  resetUploaderReferences(fileID, opts) {
    if (opts === void 0) {
      opts = {};
    }
    if (this.uploaders[fileID]) {
      this.uploaders[fileID].abort({
        really: opts.abort || false
      });
      this.uploaders[fileID] = null;
    }
    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }
    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  assertHost(method) {
    if (!this.opts.companionUrl) {
      throw new Error(`Expected a \`companionUrl\` option containing a Companion address, or if you are not using Companion, a custom \`${method}\` implementation.`);
    }
  }
  createMultipartUpload(file) {
    this.assertHost("createMultipartUpload");
    const metadata = {};
    Object.keys(file.meta).forEach((key) => {
      if (file.meta[key] != null) {
        metadata[key] = file.meta[key].toString();
      }
    });
    return this.client.post("s3/multipart", {
      filename: file.name,
      type: file.type,
      metadata
    }).then(assertServerError);
  }
  listParts(file, _ref) {
    let {
      key,
      uploadId
    } = _ref;
    this.assertHost("listParts");
    const filename = encodeURIComponent(key);
    return this.client.get(`s3/multipart/${uploadId}?key=${filename}`).then(assertServerError);
  }
  prepareUploadParts(file, _ref2) {
    let {
      key,
      uploadId,
      partNumbers
    } = _ref2;
    this.assertHost("prepareUploadParts");
    const filename = encodeURIComponent(key);
    return this.client.get(`s3/multipart/${uploadId}/batch?key=${filename}&partNumbers=${partNumbers.join(",")}`).then(assertServerError);
  }
  completeMultipartUpload(file, _ref3) {
    let {
      key,
      uploadId,
      parts
    } = _ref3;
    this.assertHost("completeMultipartUpload");
    const filename = encodeURIComponent(key);
    const uploadIdEnc = encodeURIComponent(uploadId);
    return this.client.post(`s3/multipart/${uploadIdEnc}/complete?key=${filename}`, {
      parts
    }).then(assertServerError);
  }
  abortMultipartUpload(file, _ref4) {
    let {
      key,
      uploadId
    } = _ref4;
    this.assertHost("abortMultipartUpload");
    const filename = encodeURIComponent(key);
    const uploadIdEnc = encodeURIComponent(uploadId);
    return this.client.delete(`s3/multipart/${uploadIdEnc}?key=${filename}`).then(assertServerError);
  }
  uploadFile(file) {
    return new Promise((resolve, reject) => {
      const onStart = (data) => {
        const cFile = this.uppy.getFile(file.id);
        this.uppy.setFileState(file.id, {
          s3Multipart: __spreadProps(__spreadValues({}, cFile.s3Multipart), {
            key: data.key,
            uploadId: data.uploadId
          })
        });
      };
      const onProgress = (bytesUploaded, bytesTotal) => {
        this.uppy.emit("upload-progress", file, {
          uploader: this,
          bytesUploaded,
          bytesTotal
        });
      };
      const onError = (err) => {
        this.uppy.log(err);
        this.uppy.emit("upload-error", file, err);
        queuedRequest.done();
        this.resetUploaderReferences(file.id);
        reject(err);
      };
      const onSuccess = (result) => {
        const uploadResp = {
          body: __spreadValues({}, result),
          uploadURL: result.location
        };
        queuedRequest.done();
        this.resetUploaderReferences(file.id);
        const cFile = this.uppy.getFile(file.id);
        this.uppy.emit("upload-success", cFile || file, uploadResp);
        if (result.location) {
          this.uppy.log(`Download ${upload.file.name} from ${result.location}`);
        }
        resolve(upload);
      };
      const onPartComplete = (part) => {
        const cFile = this.uppy.getFile(file.id);
        if (!cFile) {
          return;
        }
        this.uppy.emit("s3-multipart:part-uploaded", cFile, part);
      };
      const upload = new MultipartUploader(file.data, __spreadValues({
        createMultipartUpload: this.opts.createMultipartUpload.bind(this, file),
        listParts: this.opts.listParts.bind(this, file),
        prepareUploadParts: this.opts.prepareUploadParts.bind(this, file),
        completeMultipartUpload: this.opts.completeMultipartUpload.bind(this, file),
        abortMultipartUpload: this.opts.abortMultipartUpload.bind(this, file),
        getChunkSize: this.opts.getChunkSize ? this.opts.getChunkSize.bind(this) : null,
        onStart,
        onProgress,
        onError,
        onSuccess,
        onPartComplete,
        limit: this.opts.limit || 5,
        retryDelays: this.opts.retryDelays || []
      }, file.s3Multipart));
      this.uploaders[file.id] = upload;
      this.uploaderEvents[file.id] = new EventTracker2(this.uppy);
      let queuedRequest = this.requests.run(() => {
        if (!file.isPaused) {
          upload.start();
        }
        return () => {
        };
      });
      this.onFileRemove(file.id, (removed) => {
        queuedRequest.abort();
        this.resetUploaderReferences(file.id, {
          abort: true
        });
        resolve(`upload ${removed.id} was removed`);
      });
      this.onCancelAll(file.id, () => {
        queuedRequest.abort();
        this.resetUploaderReferences(file.id, {
          abort: true
        });
        resolve(`upload ${file.id} was canceled`);
      });
      this.onFilePause(file.id, (isPaused) => {
        if (isPaused) {
          queuedRequest.abort();
          upload.pause();
        } else {
          queuedRequest.abort();
          queuedRequest = this.requests.run(() => {
            upload.start();
            return () => {
            };
          });
        }
      });
      this.onPauseAll(file.id, () => {
        queuedRequest.abort();
        upload.pause();
      });
      this.onResumeAll(file.id, () => {
        queuedRequest.abort();
        if (file.error) {
          upload.abort();
        }
        queuedRequest = this.requests.run(() => {
          upload.start();
          return () => {
          };
        });
      });
      if (!file.progress.uploadStarted || !file.isRestored) {
        this.uppy.emit("upload-started", file);
      }
    });
  }
  uploadRemote(file) {
    this.resetUploaderReferences(file.id);
    if (!file.progress.uploadStarted || !file.isRestored) {
      this.uppy.emit("upload-started", file);
    }
    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }
    return new Promise((resolve, reject) => {
      const Client = file.remote.providerOptions.provider ? Provider2 : RequestClient2;
      const client = new Client(this.uppy, file.remote.providerOptions);
      client.post(file.remote.url, __spreadProps(__spreadValues({}, file.remote.body), {
        protocol: "s3-multipart",
        size: file.data.size,
        metadata: file.meta
      })).then((res) => {
        this.uppy.setFileState(file.id, {
          serverToken: res.token
        });
        file = this.uppy.getFile(file.id);
        return file;
      }).then((file2) => {
        return this.connectToServerSocket(file2);
      }).then(() => {
        resolve();
      }).catch((err) => {
        this.uppy.emit("upload-error", file, err);
        reject(err);
      });
    });
  }
  connectToServerSocket(file) {
    return new Promise((resolve, reject) => {
      const token = file.serverToken;
      const host = getSocketHost2(file.remote.companionUrl);
      const socket = new Socket({
        target: `${host}/api/${token}`,
        autoOpen: false
      });
      this.uploaderSockets[file.id] = socket;
      this.uploaderEvents[file.id] = new EventTracker2(this.uppy);
      this.onFileRemove(file.id, () => {
        queuedRequest.abort();
        socket.send("cancel", {});
        this.resetUploaderReferences(file.id, {
          abort: true
        });
        resolve(`upload ${file.id} was removed`);
      });
      this.onFilePause(file.id, (isPaused) => {
        if (isPaused) {
          queuedRequest.abort();
          socket.send("pause", {});
        } else {
          queuedRequest.abort();
          queuedRequest = this.requests.run(() => {
            socket.send("resume", {});
            return () => {
            };
          });
        }
      });
      this.onPauseAll(file.id, () => {
        queuedRequest.abort();
        socket.send("pause", {});
      });
      this.onCancelAll(file.id, () => {
        queuedRequest.abort();
        socket.send("cancel", {});
        this.resetUploaderReferences(file.id);
        resolve(`upload ${file.id} was canceled`);
      });
      this.onResumeAll(file.id, () => {
        queuedRequest.abort();
        if (file.error) {
          socket.send("pause", {});
        }
        queuedRequest = this.requests.run(() => {
          socket.send("resume", {});
        });
      });
      this.onRetry(file.id, () => {
        if (socket.isOpen) {
          socket.send("pause", {});
          socket.send("resume", {});
        }
      });
      this.onRetryAll(file.id, () => {
        if (socket.isOpen) {
          socket.send("pause", {});
          socket.send("resume", {});
        }
      });
      socket.on("progress", (progressData) => emitSocketProgress(this, progressData, file));
      socket.on("error", (errData) => {
        this.uppy.emit("upload-error", file, new Error(errData.error));
        this.resetUploaderReferences(file.id);
        queuedRequest.done();
        reject(new Error(errData.error));
      });
      socket.on("success", (data) => {
        const uploadResp = {
          uploadURL: data.url
        };
        this.uppy.emit("upload-success", file, uploadResp);
        this.resetUploaderReferences(file.id);
        queuedRequest.done();
        resolve();
      });
      let queuedRequest = this.requests.run(() => {
        socket.open();
        if (file.isPaused) {
          socket.send("pause", {});
        }
        return () => {
        };
      });
    });
  }
  upload(fileIDs) {
    if (fileIDs.length === 0)
      return Promise.resolve();
    const promises = fileIDs.map((id2) => {
      const file = this.uppy.getFile(id2);
      if (file.isRemote) {
        return this.uploadRemote(file);
      }
      return this.uploadFile(file);
    });
    return Promise.all(promises);
  }
  onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on("file-removed", (file) => {
      if (fileID === file.id)
        cb(file.id);
    });
  }
  onFilePause(fileID, cb) {
    this.uploaderEvents[fileID].on("upload-pause", (targetFileID, isPaused) => {
      if (fileID === targetFileID) {
        cb(isPaused);
      }
    });
  }
  onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on("upload-retry", (targetFileID) => {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.uploaderEvents[fileID].on("retry-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  onPauseAll(fileID, cb) {
    this.uploaderEvents[fileID].on("pause-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  onCancelAll(fileID, cb) {
    this.uploaderEvents[fileID].on("cancel-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  onResumeAll(fileID, cb) {
    this.uploaderEvents[fileID].on("resume-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  install() {
    const {
      capabilities
    } = this.uppy.getState();
    this.uppy.setState({
      capabilities: __spreadProps(__spreadValues({}, capabilities), {
        resumableUploads: true
      })
    });
    this.uppy.addUploader(this.upload);
  }
  uninstall() {
    const {
      capabilities
    } = this.uppy.getState();
    this.uppy.setState({
      capabilities: __spreadProps(__spreadValues({}, capabilities), {
        resumableUploads: false
      })
    });
    this.uppy.removeUploader(this.upload);
  }
}, _class$6.VERSION = "2.2.1", _temp$6);
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign$1(__assign$1({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse$2(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i2) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i2 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var gql$1 = gql;
const DownloadGetUrlDocument = gql$1`
    query downloadGetUrl($fileKey: String!) {
  downloadGetUrl(fileKey: $fileKey) {
    url
  }
}
    `;
const DownloadGetUrlsDocument = gql$1`
    query downloadGetUrls($fileKeys: [String]!) {
  downloadGetUrls(fileKeys: $fileKeys) {
    urls
  }
}
    `;
const CreateMultipartUploadDocument = gql$1`
    mutation createMultipartUpload($fileKey: String!) {
  createMultipartUpload(fileKey: $fileKey) {
    uploadId
    key
  }
}
    `;
const PrepareUploadPartsDocument = gql$1`
    query prepareUploadParts($fileKey: String!, $uploadId: String!, $partNumber: Int!) {
  prepareUploadParts(
    fileKey: $fileKey
    uploadId: $uploadId
    partNumber: $partNumber
  ) {
    url
  }
}
    `;
const ListPartsDocument = gql$1`
    query listParts($fileKey: String!, $uploadId: String!) {
  listParts(fileKey: $fileKey, uploadId: $uploadId) {
    ETag
    size
    PartNumber
  }
}
    `;
const AbortMultipartUploadDocument = gql$1`
    mutation abortMultipartUpload($fileKey: String!, $uploadId: String!) {
  abortMultipartUpload(fileKey: $fileKey, uploadId: $uploadId) {
    message
  }
}
    `;
const CompleteMultipartUploadDocument = gql$1`
    mutation completeMultipartUpload($fileKey: String!, $uploadId: String!, $parts: [PartInput]!) {
  completeMultipartUpload(fileKey: $fileKey, uploadId: $uploadId, parts: $parts) {
    location
  }
}
    `;
const uploadedParts = {};
function getUploadedParts(uploadId) {
  const _uploadedParts = uploadedParts[uploadId] || [];
  uploadedParts[uploadId] = _uploadedParts;
  return _uploadedParts;
}
window["uploadedParts"] = uploadedParts;
async function getDownloadUrls(urqlClient, fileKeys) {
  const request = createRequest(DownloadGetUrlsDocument, {
    fileKeys
  });
  return await new Promise((resolve) => {
    try {
      urqlClient.executeQuery(request)((result) => {
        if (typeof result === "object") {
          const { data } = result[0];
          if (data) {
            const { urls } = data.downloadGetUrls;
            resolve({ urls });
          }
        }
      });
    } catch (error) {
      console.log(error.message);
    }
  });
}
async function getDownloadUrl(urqlClient, fileKey) {
  const request = createRequest(DownloadGetUrlDocument, {
    fileKey
  });
  return await new Promise((resolve) => {
    try {
      urqlClient.executeQuery(request)((result) => {
        if (typeof result === "object") {
          const { data } = result[0];
          if (data) {
            const { url } = data.downloadGetUrl;
            resolve({ url });
          }
        }
      });
    } catch (error) {
      console.log(error.message);
    }
  });
}
function getUppy(urqlClient, allowedFileTypes) {
  const uppy2 = new Uppy$1({
    meta: { type: "avatar" },
    restrictions: {
      allowedFileTypes
    },
    autoProceed: true,
    debug: true
  });
  uppy2.use(lib$7, {
    createMultipartUpload,
    prepareUploadParts,
    listParts,
    completeMultipartUpload,
    abortMultipartUpload
  });
  uppy2.on("s3-multipart:part-uploaded", (file, part) => {
    const uploadedParts2 = getUploadedParts(file.s3Multipart.uploadId);
    uploadedParts2.push(part);
  });
  window["uppy"] = uppy2;
  return uppy2;
  async function createMultipartUpload({
    name
  }) {
    const request = createRequest(CreateMultipartUploadDocument, {
      fileKey: name
    });
    return await new Promise((resolve) => {
      try {
        urqlClient.executeMutation(request)((result) => {
          if (typeof result === "object") {
            const { data } = result[0];
            if (data) {
              const { key, uploadId } = data.createMultipartUpload;
              resolve({ key, uploadId });
            }
          }
        });
      } catch (error) {
        console.log(error.message);
      }
    });
  }
  async function prepareUploadParts(data, metadata) {
    const urls = {};
    try {
      for (const partNumber of metadata.partNumbers) {
        const request = createRequest(PrepareUploadPartsDocument, {
          fileKey: metadata.key,
          uploadId: metadata.uploadId,
          partNumber
        });
        await new Promise((r2) => {
          urqlClient.executeQuery(request)((result) => {
            if (typeof result === "object") {
              const { data: data2 } = result[0];
              if (data2) {
                const { url } = data2.prepareUploadParts;
                urls[partNumber] = url;
                r2(void 0);
              }
            }
          });
        });
      }
    } catch (error) {
      console.log(error.message);
    }
    return { presignedUrls: urls };
  }
  async function listParts(file, { uploadId, key }) {
    const request = createRequest(ListPartsDocument, {
      fileKey: key,
      uploadId
    });
    return await new Promise((r2) => {
      try {
        urqlClient.executeQuery(request)((result) => {
          if (typeof result === "object") {
            const { data } = result[0];
            if (data) {
              const parts = data.listParts;
              const _parts = parts.map((part) => ({
                ETag: part.ETag,
                PartNumber: part.PartNumber,
                Size: part.Size
              })).filter((part) => getUploadedParts(uploadId).find((p2) => p2.PartNumber === part.PartNumber));
              r2(_parts);
            }
          }
        });
      } catch (error) {
        console.log(error.message);
      }
    });
  }
  async function completeMultipartUpload(file, {
    uploadId,
    key,
    parts
  }) {
    const request = createRequest(CompleteMultipartUploadDocument, {
      fileKey: key,
      uploadId,
      parts
    });
    return await new Promise((r2) => {
      try {
        urqlClient.executeMutation(request)((result) => {
          if (typeof result === "object") {
            const { data } = result[0];
            if (data) {
              const { location: location2 } = data.completeMultipartUpload;
              r2({ location: location2 });
            }
          }
        });
        delete uploadedParts[uploadId];
      } catch (error) {
        console.log(error.message);
      }
    });
  }
  async function abortMultipartUpload(file, { key, uploadId }) {
    try {
      const request = createRequest(AbortMultipartUploadDocument, {
        fileKey: key,
        uploadId
      });
      return await new Promise((r2) => {
        urqlClient.executeMutation(request)((result) => {
          if (typeof result === "object") {
            const { data } = result[0];
            if (data)
              r2();
          }
        });
        delete uploadedParts[uploadId];
      });
    } catch (error) {
      console.log(error.message);
    }
  }
}
const downloadAs = (url, fileName) => {
  fetch(url, {
    method: "GET"
  }).then(function(resp) {
    return resp.blob();
  }).then(function(blob) {
    const newBlob = new Blob([blob]);
    const nav = window.navigator;
    if (nav && nav.msSaveOrOpenBlob) {
      nav.msSaveOrOpenBlob(newBlob);
      return;
    }
    const data = window.URL.createObjectURL(newBlob);
    const link = document.createElement("a");
    link.href = data;
    link.download = fileName;
    link.dispatchEvent(new MouseEvent("click"));
    setTimeout(function() {
      window.URL.revokeObjectURL(data);
    });
  });
};
const FileDownloadTableCell = ({
  tableCellStyle,
  filePath,
  fileName
}) => {
  let url;
  if (filePath) {
    filePath.match(/^HTTPS:\/\//i) ? url = filePath : "";
    filePath.match(/^HTTP:\/\//i) ? url = filePath : "";
  }
  return /* @__PURE__ */ jsx(TableCell, {
    padding: "none",
    style: __spreadProps(__spreadValues({}, tableCellStyle), {
      width: 50
    }),
    children: /* @__PURE__ */ jsx(IconButton$1, {
      color: "primary",
      onClick: () => {
        url ? downloadAs(url, fileName) : "";
      },
      children: /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx(FileDownloadRounded, {}), /* @__PURE__ */ jsx(Typography, {
          variant: "h5",
          children: fileName.match(/\.[0-9a-z]{1,4}$/i)
        })]
      })
    })
  });
};
var getSpeed$1 = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded)
    return 0;
  const timeElapsed = Date.now() - fileProgress.uploadStarted;
  const uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1e3);
  return uploadSpeed;
};
var getBytesRemaining$1 = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};
function getTextDirection$3(element) {
  var _element;
  while (element && !element.dir) {
    element = element.parentNode;
  }
  return (_element = element) == null ? void 0 : _element.dir;
}
var getTextDirection_1$1 = getTextDirection$3;
var StatusBarStates = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete"
};
var classnames = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes2 = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes2.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes2.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key in arg) {
              if (hasOwn2.call(arg, key) && arg[key]) {
                classes2.push(key);
              }
            }
          } else {
            classes2.push(arg.toString());
          }
        }
      }
      return classes2.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var calculateProcessingProgress$1 = function calculateProcessingProgress(files) {
  const values2 = [];
  let mode;
  let message;
  for (const {
    progress
  } of Object.values(files)) {
    const {
      preprocess,
      postprocess
    } = progress;
    if (message == null && (preprocess || postprocess)) {
      ({
        mode,
        message
      } = preprocess || postprocess);
    }
    if ((preprocess == null ? void 0 : preprocess.mode) === "determinate")
      values2.push(preprocess.value);
    if ((postprocess == null ? void 0 : postprocess.mode) === "determinate")
      values2.push(postprocess.value);
  }
  const value = values2.reduce((total, progressValue) => {
    return total + progressValue / values2.length;
  }, 0);
  return {
    mode,
    message,
    value
  };
};
var secondsToTime$1 = function secondsToTime(rawSeconds) {
  const hours = Math.floor(rawSeconds / 3600) % 24;
  const minutes = Math.floor(rawSeconds / 60) % 60;
  const seconds = Math.floor(rawSeconds % 60);
  return {
    hours,
    minutes,
    seconds
  };
};
const secondsToTime2 = secondsToTime$1;
var prettyETA$1 = function prettyETA(seconds) {
  const time = secondsToTime2(seconds);
  const hoursStr = time.hours === 0 ? "" : `${time.hours}h`;
  const minutesStr = time.minutes === 0 ? "" : `${time.hours === 0 ? time.minutes : ` ${time.minutes.toString(10).padStart(2, "0")}`}m`;
  const secondsStr = time.hours !== 0 ? "" : `${time.minutes === 0 ? time.seconds : ` ${time.seconds.toString(10).padStart(2, "0")}`}s`;
  return `${hoursStr}${minutesStr}${secondsStr}`;
};
const classNames$9 = classnames.exports;
const throttle = lodash_throttle;
const prettierBytes$1 = prettierBytes$3;
const prettyETA2 = prettyETA$1;
const {
  h: h$u
} = require$$1;
const statusBarStates$2 = StatusBarStates;
const DOT = `\xB7`;
const renderDot = () => ` ${DOT} `;
function UploadBtn$1(props) {
  const {
    newFiles,
    isUploadStarted,
    recoveredState,
    i18n,
    uploadState,
    isSomeGhost,
    startUpload
  } = props;
  const uploadBtnClassNames = classNames$9("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--upload", {
    "uppy-c-btn-primary": uploadState === statusBarStates$2.STATE_WAITING
  }, {
    "uppy-StatusBar-actionBtn--disabled": isSomeGhost
  });
  const uploadBtnText = newFiles && isUploadStarted && !recoveredState ? i18n("uploadXNewFiles", {
    smart_count: newFiles
  }) : i18n("uploadXFiles", {
    smart_count: newFiles
  });
  return h$u("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": i18n("uploadXFiles", {
      smart_count: newFiles
    }),
    onClick: startUpload,
    disabled: isSomeGhost,
    "data-uppy-super-focusable": true
  }, uploadBtnText);
}
function RetryBtn$1(props) {
  const {
    i18n,
    uppy: uppy2
  } = props;
  return h$u("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": i18n("retryUpload"),
    onClick: () => uppy2.retryAll(),
    "data-uppy-super-focusable": true
  }, h$u("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h$u("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), i18n("retry"));
}
function CancelBtn$1(props) {
  const {
    i18n,
    uppy: uppy2
  } = props;
  return h$u("button", {
    type: "button",
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: i18n("cancel"),
    "aria-label": i18n("cancel"),
    onClick: () => uppy2.cancelAll(),
    "data-uppy-super-focusable": true
  }, h$u("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h$u("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h$u("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h$u("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
}
function PauseResumeButton$1(props) {
  const {
    isAllPaused,
    i18n,
    isAllComplete,
    resumableUploads,
    uppy: uppy2
  } = props;
  const title = isAllPaused ? i18n("resume") : i18n("pause");
  function togglePauseResume() {
    if (isAllComplete)
      return null;
    if (!resumableUploads) {
      return uppy2.cancelAll();
    }
    if (isAllPaused) {
      return uppy2.resumeAll();
    }
    return uppy2.pauseAll();
  }
  return h$u("button", {
    title,
    "aria-label": title,
    className: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onClick: togglePauseResume,
    "data-uppy-super-focusable": true
  }, h$u("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h$u("g", {
    fill: "none",
    fillRule: "evenodd"
  }, h$u("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h$u("path", {
    fill: "#FFF",
    d: isAllPaused ? "M6 4.25L11.5 8 6 11.75z" : "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z"
  }))));
}
function DoneBtn$1(props) {
  const {
    i18n,
    doneButtonHandler
  } = props;
  return h$u("button", {
    type: "button",
    className: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--done",
    onClick: doneButtonHandler,
    "data-uppy-super-focusable": true
  }, i18n("done"));
}
function LoadingSpinner() {
  return h$u("svg", {
    className: "uppy-StatusBar-spinner",
    "aria-hidden": "true",
    focusable: "false",
    width: "14",
    height: "14"
  }, h$u("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    fillRule: "evenodd"
  }));
}
function ProgressBarProcessing$1(props) {
  const {
    progress
  } = props;
  const {
    value,
    mode,
    message
  } = progress;
  const roundedValue = Math.round(value * 100);
  const dot = `\xB7`;
  return h$u("div", {
    className: "uppy-StatusBar-content"
  }, h$u(LoadingSpinner, null), mode === "determinate" ? `${roundedValue}% ${dot} ` : "", message);
}
function ProgressDetails(props) {
  const {
    numUploads,
    complete,
    totalUploadedSize,
    totalSize,
    totalETA,
    i18n
  } = props;
  const ifShowFilesUploadedOfTotal = numUploads > 1;
  return h$u("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && i18n("filesUploadedOfTotal", {
    complete,
    smart_count: numUploads
  }), h$u("span", {
    className: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), i18n("dataUploadedOfTotal", {
    complete: prettierBytes$1(totalUploadedSize),
    total: prettierBytes$1(totalSize)
  }), renderDot(), i18n("xTimeLeft", {
    time: prettyETA2(totalETA)
  })));
}
function FileUploadCount(props) {
  const {
    i18n,
    complete,
    numUploads
  } = props;
  return h$u("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, i18n("filesUploadedOfTotal", {
    complete,
    smart_count: numUploads
  }));
}
function UploadNewlyAddedFiles(props) {
  const {
    i18n,
    newFiles,
    startUpload
  } = props;
  const uploadBtnClassNames = classNames$9("uppy-u-reset", "uppy-c-btn", "uppy-StatusBar-actionBtn", "uppy-StatusBar-actionBtn--uploadNewlyAdded");
  return h$u("div", {
    className: "uppy-StatusBar-statusSecondary"
  }, h$u("div", {
    className: "uppy-StatusBar-statusSecondaryHint"
  }, i18n("xMoreFilesAdded", {
    smart_count: newFiles
  })), h$u("button", {
    type: "button",
    className: uploadBtnClassNames,
    "aria-label": i18n("uploadXFiles", {
      smart_count: newFiles
    }),
    onClick: startUpload
  }, i18n("upload")));
}
const ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});
function ProgressBarUploading$1(props) {
  const {
    i18n,
    supportsUploadProgress: supportsUploadProgress3,
    totalProgress,
    showProgressDetails,
    isUploadStarted,
    isAllComplete,
    isAllPaused,
    newFiles,
    numUploads,
    complete,
    totalUploadedSize,
    totalSize,
    totalETA,
    startUpload
  } = props;
  const showUploadNewlyAddedFiles = newFiles && isUploadStarted;
  if (!isUploadStarted || isAllComplete) {
    return null;
  }
  const title = isAllPaused ? i18n("paused") : i18n("uploading");
  function renderProgressDetails() {
    if (!isAllPaused && !showUploadNewlyAddedFiles && showProgressDetails) {
      if (supportsUploadProgress3) {
        return h$u(ThrottledProgressDetails, {
          numUploads,
          complete,
          totalUploadedSize,
          totalSize,
          totalETA,
          i18n
        });
      }
      return h$u(FileUploadCount, {
        i18n,
        complete,
        numUploads
      });
    }
    return null;
  }
  return h$u("div", {
    className: "uppy-StatusBar-content",
    "aria-label": title,
    title
  }, !isAllPaused ? h$u(LoadingSpinner, null) : null, h$u("div", {
    className: "uppy-StatusBar-status"
  }, h$u("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, supportsUploadProgress3 ? `${title}: ${totalProgress}%` : title), renderProgressDetails(), showUploadNewlyAddedFiles ? h$u(UploadNewlyAddedFiles, {
    i18n,
    newFiles,
    startUpload
  }) : null));
}
function ProgressBarComplete$1(props) {
  const {
    i18n
  } = props;
  return h$u("div", {
    className: "uppy-StatusBar-content",
    role: "status",
    title: i18n("complete")
  }, h$u("div", {
    className: "uppy-StatusBar-status"
  }, h$u("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, h$u("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h$u("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n("complete"))));
}
function ProgressBarError$1(props) {
  const {
    error,
    i18n,
    complete,
    numUploads
  } = props;
  function displayErrorAlert() {
    const errorMessage = `${i18n("uploadFailed")} 

 ${error}`;
    alert(errorMessage);
  }
  return h$u("div", {
    className: "uppy-StatusBar-content",
    title: i18n("uploadFailed")
  }, h$u("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-StatusBar-statusIndicator uppy-c-icon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h$u("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), h$u("div", {
    className: "uppy-StatusBar-status"
  }, h$u("div", {
    className: "uppy-StatusBar-statusPrimary"
  }, i18n("uploadFailed"), h$u("button", {
    className: "uppy-u-reset uppy-StatusBar-details",
    "aria-label": i18n("showErrorDetails"),
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    onClick: displayErrorAlert,
    type: "button"
  }, "?")), h$u(FileUploadCount, {
    i18n,
    complete,
    numUploads
  })));
}
var Components = {
  UploadBtn: UploadBtn$1,
  RetryBtn: RetryBtn$1,
  CancelBtn: CancelBtn$1,
  PauseResumeButton: PauseResumeButton$1,
  DoneBtn: DoneBtn$1,
  LoadingSpinner,
  ProgressDetails,
  ProgressBarProcessing: ProgressBarProcessing$1,
  ProgressBarError: ProgressBarError$1,
  ProgressBarUploading: ProgressBarUploading$1,
  ProgressBarComplete: ProgressBarComplete$1
};
const {
  h: h$t
} = require$$1;
const classNames$8 = classnames.exports;
const statusBarStates$1 = StatusBarStates;
const calculateProcessingProgress2 = calculateProcessingProgress$1;
const {
  UploadBtn,
  RetryBtn,
  CancelBtn,
  PauseResumeButton,
  DoneBtn,
  ProgressBarProcessing,
  ProgressBarError,
  ProgressBarUploading,
  ProgressBarComplete
} = Components;
const {
  STATE_ERROR,
  STATE_WAITING,
  STATE_PREPROCESSING,
  STATE_UPLOADING,
  STATE_POSTPROCESSING,
  STATE_COMPLETE
} = statusBarStates$1;
var StatusBar_1$1 = StatusBar$2;
function StatusBar$2(props) {
  const {
    newFiles,
    allowNewUpload,
    isUploadInProgress,
    isAllPaused,
    resumableUploads,
    error,
    hideUploadButton,
    hidePauseResumeButton,
    hideCancelButton,
    hideRetryButton,
    recoveredState,
    uploadState,
    totalProgress,
    files,
    supportsUploadProgress: supportsUploadProgress3,
    hideAfterFinish,
    isSomeGhost,
    isTargetDOMEl,
    doneButtonHandler,
    isUploadStarted,
    i18n,
    startUpload,
    uppy: uppy2,
    isAllComplete,
    showProgressDetails,
    numUploads,
    complete,
    totalSize,
    totalETA,
    totalUploadedSize
  } = props;
  function getProgressValue() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const progress = calculateProcessingProgress2(files);
        if (progress.mode === "determinate") {
          return progress.value * 100;
        }
        return totalProgress;
      }
      case STATE_ERROR: {
        return null;
      }
      case STATE_UPLOADING: {
        if (!supportsUploadProgress3) {
          return null;
        }
        return totalProgress;
      }
      default:
        return totalProgress;
    }
  }
  function getIsIndeterminate() {
    switch (uploadState) {
      case STATE_POSTPROCESSING:
      case STATE_PREPROCESSING: {
        const {
          mode
        } = calculateProcessingProgress2(files);
        return mode === "indeterminate";
      }
      case STATE_UPLOADING: {
        if (!supportsUploadProgress3) {
          return true;
        }
        return false;
      }
      default:
        return false;
    }
  }
  function getIsHidden() {
    if (recoveredState) {
      return false;
    }
    switch (uploadState) {
      case STATE_WAITING:
        return hideUploadButton || newFiles === 0;
      case STATE_COMPLETE:
        return hideAfterFinish;
      default:
        return false;
    }
  }
  const progressValue = getProgressValue();
  const isHidden2 = getIsHidden();
  const width = progressValue != null ? progressValue : 100;
  const showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;
  const showCancelBtn = !hideCancelButton && uploadState !== STATE_WAITING && uploadState !== STATE_COMPLETE;
  const showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState === STATE_UPLOADING;
  const showRetryBtn = error && !isAllComplete && !hideRetryButton;
  const showDoneBtn = doneButtonHandler && uploadState === STATE_COMPLETE;
  const progressClassNames = classNames$8("uppy-StatusBar-progress", {
    "is-indeterminate": getIsIndeterminate()
  });
  const statusBarClassNames = classNames$8({
    "uppy-Root": isTargetDOMEl
  }, "uppy-StatusBar", `is-${uploadState}`, {
    "has-ghosts": isSomeGhost
  });
  return h$t("div", {
    className: statusBarClassNames,
    "aria-hidden": isHidden2
  }, h$t("div", {
    className: progressClassNames,
    style: {
      width: `${width}%`
    },
    role: "progressbar",
    "aria-label": `${width}%`,
    "aria-valuetext": `${width}%`,
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), (() => {
    switch (uploadState) {
      case STATE_PREPROCESSING:
      case STATE_POSTPROCESSING:
        return h$t(ProgressBarProcessing, {
          progress: calculateProcessingProgress2(files)
        });
      case STATE_COMPLETE:
        return h$t(ProgressBarComplete, {
          i18n
        });
      case STATE_ERROR:
        return h$t(ProgressBarError, {
          error,
          i18n,
          numUploads,
          complete
        });
      case STATE_UPLOADING:
        return h$t(ProgressBarUploading, {
          i18n,
          supportsUploadProgress: supportsUploadProgress3,
          totalProgress,
          showProgressDetails,
          isUploadStarted,
          isAllComplete,
          isAllPaused,
          newFiles,
          numUploads,
          complete,
          totalUploadedSize,
          totalSize,
          totalETA,
          startUpload
        });
      default:
        return null;
    }
  })(), h$t("div", {
    className: "uppy-StatusBar-actions"
  }, recoveredState || showUploadBtn ? h$t(UploadBtn, {
    newFiles,
    isUploadStarted,
    recoveredState,
    i18n,
    isSomeGhost,
    startUpload,
    uploadState
  }) : null, showRetryBtn ? h$t(RetryBtn, {
    i18n,
    uppy: uppy2
  }) : null, showPauseResumeBtn ? h$t(PauseResumeButton, {
    isAllPaused,
    i18n,
    isAllComplete,
    resumableUploads,
    uppy: uppy2
  }) : null, showCancelBtn ? h$t(CancelBtn, {
    i18n,
    uppy: uppy2
  }) : null, showDoneBtn ? h$t(DoneBtn, {
    i18n,
    doneButtonHandler
  }) : null));
}
var locale$b = {
  strings: {
    uploading: "Uploading",
    complete: "Complete",
    uploadFailed: "Upload failed",
    paused: "Paused",
    retry: "Retry",
    cancel: "Cancel",
    pause: "Pause",
    resume: "Resume",
    done: "Done",
    filesUploadedOfTotal: {
      0: "%{complete} of %{smart_count} file uploaded",
      1: "%{complete} of %{smart_count} files uploaded"
    },
    dataUploadedOfTotal: "%{complete} of %{total}",
    xTimeLeft: "%{time} left",
    uploadXFiles: {
      0: "Upload %{smart_count} file",
      1: "Upload %{smart_count} files"
    },
    uploadXNewFiles: {
      0: "Upload +%{smart_count} file",
      1: "Upload +%{smart_count} files"
    },
    upload: "Upload",
    retryUpload: "Retry upload",
    xMoreFilesAdded: {
      0: "%{smart_count} more file added",
      1: "%{smart_count} more files added"
    },
    showErrorDetails: "Show error details"
  }
};
var _class$5, _temp$5;
const {
  UIPlugin: UIPlugin$5
} = lib$a.exports;
const getSpeed2 = getSpeed$1;
const getBytesRemaining2 = getBytesRemaining$1;
const getTextDirection$2 = getTextDirection_1$1;
const statusBarStates = StatusBarStates;
const StatusBarUI = StatusBar_1$1;
const locale$a = locale$b;
var lib$6 = (_temp$5 = _class$5 = class StatusBar extends UIPlugin$5 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.startUpload = () => {
      const {
        recoveredState
      } = this.uppy.getState();
      if (recoveredState) {
        this.uppy.emit("restore-confirmed");
        return void 0;
      }
      return this.uppy.upload().catch(() => {
      });
    };
    this.id = this.opts.id || "StatusBar";
    this.title = "StatusBar";
    this.type = "progressindicator";
    this.defaultLocale = locale$a;
    const defaultOptions2 = {
      target: "body",
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true,
      doneButtonHandler: null
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
    this.i18nInit();
    this.render = this.render.bind(this);
    this.install = this.install.bind(this);
  }
  render(state) {
    const {
      capabilities,
      files,
      allowNewUpload,
      totalProgress,
      error,
      recoveredState
    } = state;
    const {
      newFiles,
      startedFiles,
      completeFiles,
      inProgressNotPausedFiles,
      isUploadStarted,
      isAllComplete,
      isAllErrored,
      isAllPaused,
      isUploadInProgress,
      isSomeGhost
    } = this.uppy.getObjectOfFilesPerState();
    const newFilesOrRecovered = recoveredState ? Object.values(files) : newFiles;
    const totalETA = getTotalETA(inProgressNotPausedFiles);
    const resumableUploads = !!capabilities.resumableUploads;
    const supportsUploadProgress3 = capabilities.uploadProgress !== false;
    let totalSize = 0;
    let totalUploadedSize = 0;
    startedFiles.forEach((file) => {
      totalSize += file.progress.bytesTotal || 0;
      totalUploadedSize += file.progress.bytesUploaded || 0;
    });
    return StatusBarUI({
      error,
      uploadState: getUploadingState$1(error, isAllComplete, recoveredState, state.files || {}),
      allowNewUpload,
      totalProgress,
      totalSize,
      totalUploadedSize,
      isAllComplete: false,
      isAllPaused,
      isAllErrored,
      isUploadStarted,
      isUploadInProgress,
      isSomeGhost,
      recoveredState,
      complete: completeFiles.length,
      newFiles: newFilesOrRecovered.length,
      numUploads: startedFiles.length,
      totalETA,
      files,
      i18n: this.i18n,
      uppy: this.uppy,
      startUpload: this.startUpload,
      doneButtonHandler: this.opts.doneButtonHandler,
      resumableUploads,
      supportsUploadProgress: supportsUploadProgress3,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  }
  onMount() {
    const element = this.el;
    const direction = getTextDirection$2(element);
    if (!direction) {
      element.dir = "ltr";
    }
  }
  install() {
    const {
      target
    } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
}, _class$5.VERSION = "2.1.2", _temp$5);
function getTotalSpeed(files) {
  let totalSpeed = 0;
  files.forEach((file) => {
    totalSpeed += getSpeed2(file.progress);
  });
  return totalSpeed;
}
function getTotalETA(files) {
  const totalSpeed = getTotalSpeed(files);
  if (totalSpeed === 0) {
    return 0;
  }
  const totalBytesRemaining = files.reduce((total, file) => {
    return total + getBytesRemaining2(file.progress);
  }, 0);
  return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
}
function getUploadingState$1(error, isAllComplete, recoveredState, files) {
  if (error && !isAllComplete) {
    return statusBarStates.STATE_ERROR;
  }
  if (isAllComplete) {
    return statusBarStates.STATE_COMPLETE;
  }
  if (recoveredState) {
    return statusBarStates.STATE_WAITING;
  }
  let state = statusBarStates.STATE_WAITING;
  const fileIDs = Object.keys(files);
  for (let i2 = 0; i2 < fileIDs.length; i2++) {
    const {
      progress
    } = files[fileIDs[i2]];
    if (progress.uploadStarted && !progress.uploadComplete) {
      return statusBarStates.STATE_UPLOADING;
    }
    if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
      state = statusBarStates.STATE_PREPROCESSING;
    }
    if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
      state = statusBarStates.STATE_POSTPROCESSING;
    }
  }
  return state;
}
const {
  h: h$s,
  Component: Component$6,
  createRef
} = require$$1;
const TRANSITION_MS = 300;
var FadeIn_1 = class FadeIn extends Component$6 {
  constructor() {
    super(...arguments);
    this.ref = createRef();
  }
  componentWillEnter(callback) {
    this.ref.current.style.opacity = "1";
    this.ref.current.style.transform = "none";
    setTimeout(callback, TRANSITION_MS);
  }
  componentWillLeave(callback) {
    this.ref.current.style.opacity = "0";
    this.ref.current.style.transform = "translateY(350%)";
    setTimeout(callback, TRANSITION_MS);
  }
  render() {
    const {
      children
    } = this.props;
    return h$s("div", {
      className: "uppy-Informer-animated",
      ref: this.ref
    }, children);
  }
};
const {
  Component: Component$5,
  cloneElement: cloneElement$1,
  h: h$r,
  toChildArray: toChildArray$1
} = require$$1;
function assign$1(obj, props) {
  return Object.assign(obj, props);
}
function getKey(vnode, fallback) {
  var _vnode$key;
  return (_vnode$key = vnode == null ? void 0 : vnode.key) != null ? _vnode$key : fallback;
}
function linkRef(component, name) {
  const cache2 = component._ptgLinkedRefs || (component._ptgLinkedRefs = {});
  return cache2[name] || (cache2[name] = (c2) => {
    component.refs[name] = c2;
  });
}
function getChildMapping$1(children) {
  const out = {};
  for (let i2 = 0; i2 < children.length; i2++) {
    if (children[i2] != null) {
      const key = getKey(children[i2], i2.toString(36));
      out[key] = children[i2];
    }
  }
  return out;
}
function mergeChildMappings$1(prev, next) {
  prev = prev || {};
  next = next || {};
  const getValueForKey = (key) => next.hasOwnProperty(key) ? next[key] : prev[key];
  const nextKeysPending = {};
  let pendingKeys = [];
  for (const prevKey in prev) {
    if (next.hasOwnProperty(prevKey)) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  const childMapping = {};
  for (const nextKey in next) {
    if (nextKeysPending.hasOwnProperty(nextKey)) {
      for (let i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        const pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (let i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
const identity = (i2) => i2;
class TransitionGroup$3 extends Component$5 {
  constructor(props, context) {
    super(props, context);
    this.refs = {};
    this.state = {
      children: getChildMapping$1(toChildArray$1(toChildArray$1(this.props.children)) || [])
    };
    this.performAppear = this.performAppear.bind(this);
    this.performEnter = this.performEnter.bind(this);
    this.performLeave = this.performLeave.bind(this);
  }
  componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToAbortLeave = [];
    this.keysToEnter = [];
    this.keysToLeave = [];
  }
  componentDidMount() {
    const initialChildMapping = this.state.children;
    for (const key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  }
  componentWillReceiveProps(nextProps) {
    const nextChildMapping = getChildMapping$1(toChildArray$1(nextProps.children) || []);
    const prevChildMapping = this.state.children;
    this.setState((prevState) => ({
      children: mergeChildMappings$1(prevState.children, nextChildMapping)
    }));
    let key;
    for (key in nextChildMapping) {
      if (nextChildMapping.hasOwnProperty(key)) {
        const hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
        if (nextChildMapping[key] && hasPrev && this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
          this.keysToAbortLeave.push(key);
        } else if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
          this.keysToEnter.push(key);
        }
      }
    }
    for (key in prevChildMapping) {
      if (prevChildMapping.hasOwnProperty(key)) {
        const hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
        if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
          this.keysToLeave.push(key);
        }
      }
    }
  }
  componentDidUpdate() {
    const {
      keysToEnter
    } = this;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    const {
      keysToLeave
    } = this;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  }
  _finishAbort(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      this.keysToAbortLeave.splice(idx, 1);
    }
  }
  performAppear(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component.componentWillAppear) {
      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
    } else {
      this._handleDoneAppearing(key);
    }
  }
  _handleDoneAppearing(key) {
    const component = this.refs[key];
    if (component.componentDidAppear) {
      component.componentDidAppear();
    }
    delete this.currentlyTransitioningKeys[key];
    this._finishAbort(key);
    const currentChildMapping = getChildMapping$1(toChildArray$1(this.props.children) || []);
    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      this.performLeave(key);
    }
  }
  performEnter(key) {
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component.componentWillEnter) {
      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
    } else {
      this._handleDoneEntering(key);
    }
  }
  _handleDoneEntering(key) {
    const component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }
    delete this.currentlyTransitioningKeys[key];
    this._finishAbort(key);
    const currentChildMapping = getChildMapping$1(toChildArray$1(this.props.children) || []);
    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      this.performLeave(key);
    }
  }
  performLeave(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      return;
    }
    this.currentlyTransitioningKeys[key] = true;
    const component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      this._handleDoneLeaving(key);
    }
  }
  _handleDoneLeaving(key) {
    const idx = this.keysToAbortLeave.indexOf(key);
    if (idx !== -1) {
      return;
    }
    const component = this.refs[key];
    if (component.componentDidLeave) {
      component.componentDidLeave();
    }
    delete this.currentlyTransitioningKeys[key];
    const currentChildMapping = getChildMapping$1(toChildArray$1(this.props.children) || []);
    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      this.performEnter(key);
    } else {
      const children = assign$1({}, this.state.children);
      delete children[key];
      this.setState({
        children
      });
    }
  }
  render(_ref, _ref2) {
    let _a2 = _ref, {
      childFactory: childFactory2,
      transitionLeave,
      transitionName: transitionName2,
      transitionAppear,
      transitionEnter,
      transitionLeaveTimeout,
      transitionEnterTimeout,
      transitionAppearTimeout,
      component
    } = _a2, props = __objRest(_a2, [
      "childFactory",
      "transitionLeave",
      "transitionName",
      "transitionAppear",
      "transitionEnter",
      "transitionLeaveTimeout",
      "transitionEnterTimeout",
      "transitionAppearTimeout",
      "component"
    ]);
    let {
      children
    } = _ref2;
    const childrenToRender = [];
    for (const key in children) {
      if (children.hasOwnProperty(key)) {
        const child = children[key];
        if (child) {
          const ref = linkRef(this, key), el = cloneElement$1(childFactory2(child), {
            ref,
            key
          });
          childrenToRender.push(el);
        }
      }
    }
    return h$r(component, props, childrenToRender);
  }
}
TransitionGroup$3.defaultProps = {
  component: "span",
  childFactory: identity
};
var TransitionGroup_1 = TransitionGroup$3;
var _class$4, _temp$4;
const {
  h: h$q
} = require$$1;
const {
  UIPlugin: UIPlugin$4
} = lib$a.exports;
const FadeIn2 = FadeIn_1;
const TransitionGroup$2 = TransitionGroup_1;
var lib$5 = (_temp$4 = _class$4 = class Informer extends UIPlugin$4 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.render = (state) => {
      return h$q("div", {
        className: "uppy uppy-Informer"
      }, h$q(TransitionGroup$2, null, state.info.map((info) => h$q(FadeIn2, {
        key: info.message
      }, h$q("p", {
        role: "alert"
      }, info.message, " ", info.details && h$q("span", {
        "aria-label": info.details,
        "data-microtip-position": "top-left",
        "data-microtip-size": "medium",
        role: "tooltip",
        onClick: () => alert(`${info.message} 

 ${info.details}`)
      }, "?"))))));
    };
    this.type = "progressindicator";
    this.id = this.opts.id || "Informer";
    this.title = "Informer";
    const defaultOptions2 = {};
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
  }
  install() {
    const {
      target
    } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
}, _class$4.VERSION = "2.0.5", _temp$4);
const DATA_URL_PATTERN = /^data:([^/]+\/[^,;]+(?:[^,]*?))(;base64)?,([\s\S]*)$/;
var dataURItoBlob$1 = function dataURItoBlob(dataURI, opts, toFile) {
  var _ref, _opts$mimeType;
  const dataURIData = DATA_URL_PATTERN.exec(dataURI);
  const mimeType = (_ref = (_opts$mimeType = opts.mimeType) != null ? _opts$mimeType : dataURIData == null ? void 0 : dataURIData[1]) != null ? _ref : "plain/text";
  let data;
  if (dataURIData[2] != null) {
    const binary = atob(decodeURIComponent(dataURIData[3]));
    const bytes = new Uint8Array(binary.length);
    for (let i2 = 0; i2 < binary.length; i2++) {
      bytes[i2] = binary.charCodeAt(i2);
    }
    data = [bytes];
  } else {
    data = [decodeURIComponent(dataURIData[3])];
  }
  if (toFile) {
    return new File(data, opts.name || "", {
      type: mimeType
    });
  }
  return new Blob(data, {
    type: mimeType
  });
};
var isObjectURL$1 = function isObjectURL(url) {
  return url.startsWith("blob:");
};
var isPreviewSupported$1 = function isPreviewSupported(fileType) {
  if (!fileType)
    return false;
  return /^[^/]+\/(jpe?g|gif|png|svg|svg\+xml|bmp|webp|avif)$/.test(fileType);
};
var mini_umd = { exports: {} };
(function(module2, exports2) {
  !function(e2, t2) {
    t2(exports2);
  }(commonjsGlobal, function(e2) {
    function t2(e3, t3, s3) {
      return t3 in e3 ? Object.defineProperty(e3, t3, { value: s3, enumerable: true, configurable: true, writable: true }) : e3[t3] = s3, e3;
    }
    var s2 = typeof self != "undefined" ? self : commonjsGlobal;
    const i2 = typeof navigator != "undefined", n2 = i2 && typeof HTMLImageElement == "undefined", r2 = !(typeof commonjsGlobal == "undefined" || typeof process == "undefined" || !process.versions || !process.versions.node), a2 = s2.Buffer, h2 = !!a2, f2 = (e3) => e3 !== void 0;
    function l2(e3) {
      return e3 === void 0 || (e3 instanceof Map ? e3.size === 0 : Object.values(e3).filter(f2).length === 0);
    }
    function o2(e3) {
      let t3 = new Error(e3);
      throw delete t3.stack, t3;
    }
    function u2(e3) {
      let t3 = function(e4) {
        let t4 = 0;
        return e4.ifd0.enabled && (t4 += 1024), e4.exif.enabled && (t4 += 2048), e4.makerNote && (t4 += 2048), e4.userComment && (t4 += 1024), e4.gps.enabled && (t4 += 512), e4.interop.enabled && (t4 += 100), e4.ifd1.enabled && (t4 += 1024), t4 + 2048;
      }(e3);
      return e3.jfif.enabled && (t3 += 50), e3.xmp.enabled && (t3 += 2e4), e3.iptc.enabled && (t3 += 14e3), e3.icc.enabled && (t3 += 6e3), t3;
    }
    const d2 = (e3) => String.fromCharCode.apply(null, e3), c2 = typeof TextDecoder != "undefined" ? new TextDecoder("utf-8") : void 0;
    class p2 {
      static from(e3, t3) {
        return e3 instanceof this && e3.le === t3 ? e3 : new p2(e3, void 0, void 0, t3);
      }
      constructor(e3, t3 = 0, s3, i3) {
        if (typeof i3 == "boolean" && (this.le = i3), Array.isArray(e3) && (e3 = new Uint8Array(e3)), e3 === 0)
          this.byteOffset = 0, this.byteLength = 0;
        else if (e3 instanceof ArrayBuffer) {
          s3 === void 0 && (s3 = e3.byteLength - t3);
          let i4 = new DataView(e3, t3, s3);
          this._swapDataView(i4);
        } else if (e3 instanceof Uint8Array || e3 instanceof DataView || e3 instanceof p2) {
          s3 === void 0 && (s3 = e3.byteLength - t3), (t3 += e3.byteOffset) + s3 > e3.byteOffset + e3.byteLength && o2("Creating view outside of available memory in ArrayBuffer");
          let i4 = new DataView(e3.buffer, t3, s3);
          this._swapDataView(i4);
        } else if (typeof e3 == "number") {
          let t4 = new DataView(new ArrayBuffer(e3));
          this._swapDataView(t4);
        } else
          o2("Invalid input argument for BufferView: " + e3);
      }
      _swapArrayBuffer(e3) {
        this._swapDataView(new DataView(e3));
      }
      _swapBuffer(e3) {
        this._swapDataView(new DataView(e3.buffer, e3.byteOffset, e3.byteLength));
      }
      _swapDataView(e3) {
        this.dataView = e3, this.buffer = e3.buffer, this.byteOffset = e3.byteOffset, this.byteLength = e3.byteLength;
      }
      _lengthToEnd(e3) {
        return this.byteLength - e3;
      }
      set(e3, t3, s3 = p2) {
        return e3 instanceof DataView || e3 instanceof p2 ? e3 = new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3)), e3 instanceof Uint8Array || o2("BufferView.set(): Invalid data argument."), this.toUint8().set(e3, t3), new s3(this, t3, e3.byteLength);
      }
      subarray(e3, t3) {
        return t3 = t3 || this._lengthToEnd(e3), new p2(this, e3, t3);
      }
      toUint8() {
        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);
      }
      getUint8Array(e3, t3) {
        return new Uint8Array(this.buffer, this.byteOffset + e3, t3);
      }
      getString(e3 = 0, t3 = this.byteLength) {
        let s3 = this.getUint8Array(e3, t3);
        return i3 = s3, c2 ? c2.decode(i3) : h2 ? Buffer.from(i3).toString("utf8") : decodeURIComponent(escape(d2(i3)));
        var i3;
      }
      getLatin1String(e3 = 0, t3 = this.byteLength) {
        let s3 = this.getUint8Array(e3, t3);
        return d2(s3);
      }
      getUnicodeString(e3 = 0, t3 = this.byteLength) {
        const s3 = [];
        for (let i3 = 0; i3 < t3 && e3 + i3 < this.byteLength; i3 += 2)
          s3.push(this.getUint16(e3 + i3));
        return d2(s3);
      }
      getInt8(e3) {
        return this.dataView.getInt8(e3);
      }
      getUint8(e3) {
        return this.dataView.getUint8(e3);
      }
      getInt16(e3, t3 = this.le) {
        return this.dataView.getInt16(e3, t3);
      }
      getInt32(e3, t3 = this.le) {
        return this.dataView.getInt32(e3, t3);
      }
      getUint16(e3, t3 = this.le) {
        return this.dataView.getUint16(e3, t3);
      }
      getUint32(e3, t3 = this.le) {
        return this.dataView.getUint32(e3, t3);
      }
      getFloat32(e3, t3 = this.le) {
        return this.dataView.getFloat32(e3, t3);
      }
      getFloat64(e3, t3 = this.le) {
        return this.dataView.getFloat64(e3, t3);
      }
      getFloat(e3, t3 = this.le) {
        return this.dataView.getFloat32(e3, t3);
      }
      getDouble(e3, t3 = this.le) {
        return this.dataView.getFloat64(e3, t3);
      }
      getUintBytes(e3, t3, s3) {
        switch (t3) {
          case 1:
            return this.getUint8(e3, s3);
          case 2:
            return this.getUint16(e3, s3);
          case 4:
            return this.getUint32(e3, s3);
          case 8:
            return this.getUint64 && this.getUint64(e3, s3);
        }
      }
      getUint(e3, t3, s3) {
        switch (t3) {
          case 8:
            return this.getUint8(e3, s3);
          case 16:
            return this.getUint16(e3, s3);
          case 32:
            return this.getUint32(e3, s3);
          case 64:
            return this.getUint64 && this.getUint64(e3, s3);
        }
      }
      toString(e3) {
        return this.dataView.toString(e3, this.constructor.name);
      }
      ensureChunk() {
      }
    }
    function g2(e3, t3) {
      o2(`${e3} '${t3}' was not loaded, try using full build of exifr.`);
    }
    class m2 extends Map {
      constructor(e3) {
        super(), this.kind = e3;
      }
      get(e3, t3) {
        return this.has(e3) || g2(this.kind, e3), t3 && (e3 in t3 || function(e4, t4) {
          o2(`Unknown ${e4} '${t4}'.`);
        }(this.kind, e3), t3[e3].enabled || g2(this.kind, e3)), super.get(e3);
      }
      keyList() {
        return Array.from(this.keys());
      }
    }
    var y2 = new m2("file parser"), b2 = new m2("segment parser"), w2 = new m2("file reader");
    let k2 = s2.fetch;
    const O2 = "Invalid input argument";
    function v2(e3, t3) {
      return (s3 = e3).startsWith("data:") || s3.length > 1e4 ? A2(e3, t3, "base64") : r2 && e3.includes("://") ? S2(e3, t3, "url", U) : r2 ? A2(e3, t3, "fs") : i2 ? S2(e3, t3, "url", U) : void o2(O2);
      var s3;
    }
    async function S2(e3, t3, s3, i3) {
      return w2.has(s3) ? A2(e3, t3, s3) : i3 ? async function(e4, t4) {
        let s4 = await t4(e4);
        return new p2(s4);
      }(e3, i3) : void o2(`Parser ${s3} is not loaded`);
    }
    async function A2(e3, t3, s3) {
      let i3 = new (w2.get(s3))(e3, t3);
      return await i3.read(), i3;
    }
    const U = (e3) => k2(e3).then((e4) => e4.arrayBuffer()), x2 = (e3) => new Promise((t3, s3) => {
      let i3 = new FileReader();
      i3.onloadend = () => t3(i3.result || new ArrayBuffer()), i3.onerror = s3, i3.readAsArrayBuffer(e3);
    });
    class C2 extends Map {
      get tagKeys() {
        return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;
      }
      get tagValues() {
        return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;
      }
    }
    function B2(e3, t3, s3) {
      let i3 = new C2();
      for (let [e4, t4] of s3)
        i3.set(e4, t4);
      if (Array.isArray(t3))
        for (let s4 of t3)
          e3.set(s4, i3);
      else
        e3.set(t3, i3);
      return i3;
    }
    function V(e3, t3, s3) {
      let i3, n3 = e3.get(t3);
      for (i3 of s3)
        n3.set(i3[0], i3[1]);
    }
    const I2 = /* @__PURE__ */ new Map(), L2 = /* @__PURE__ */ new Map(), T2 = /* @__PURE__ */ new Map(), P2 = 37500, z2 = 37510, F = 33723, j2 = 34675, E = 34665, _2 = 34853, D2 = 40965, M2 = ["chunked", "firstChunkSize", "firstChunkSizeNode", "firstChunkSizeBrowser", "chunkSize", "chunkLimit"], N2 = ["jfif", "xmp", "icc", "iptc", "ihdr"], R = ["tiff", ...N2], $2 = ["ifd0", "ifd1", "exif", "gps", "interop"], K = [...R, ...$2], W = ["makerNote", "userComment"], X = ["translateKeys", "translateValues", "reviveValues", "multiSegment"], H2 = [...X, "sanitize", "mergeOutput", "silentErrors"];
    class Y {
      get translate() {
        return this.translateKeys || this.translateValues || this.reviveValues;
      }
    }
    class G extends Y {
      get needed() {
        return this.enabled || this.deps.size > 0;
      }
      constructor(e3, s3, i3, n3) {
        if (super(), t2(this, "enabled", false), t2(this, "skip", /* @__PURE__ */ new Set()), t2(this, "pick", /* @__PURE__ */ new Set()), t2(this, "deps", /* @__PURE__ */ new Set()), t2(this, "translateKeys", false), t2(this, "translateValues", false), t2(this, "reviveValues", false), this.key = e3, this.enabled = s3, this.parse = this.enabled, this.applyInheritables(n3), this.canBeFiltered = $2.includes(e3), this.canBeFiltered && (this.dict = I2.get(e3)), i3 !== void 0)
          if (Array.isArray(i3))
            this.parse = this.enabled = true, this.canBeFiltered && i3.length > 0 && this.translateTagSet(i3, this.pick);
          else if (typeof i3 == "object") {
            if (this.enabled = true, this.parse = i3.parse !== false, this.canBeFiltered) {
              let { pick: e4, skip: t3 } = i3;
              e4 && e4.length > 0 && this.translateTagSet(e4, this.pick), t3 && t3.length > 0 && this.translateTagSet(t3, this.skip);
            }
            this.applyInheritables(i3);
          } else
            i3 === true || i3 === false ? this.parse = this.enabled = i3 : o2(`Invalid options argument: ${i3}`);
      }
      applyInheritables(e3) {
        let t3, s3;
        for (t3 of X)
          s3 = e3[t3], s3 !== void 0 && (this[t3] = s3);
      }
      translateTagSet(e3, t3) {
        if (this.dict) {
          let s3, i3, { tagKeys: n3, tagValues: r3 } = this.dict;
          for (s3 of e3)
            typeof s3 == "string" ? (i3 = r3.indexOf(s3), i3 === -1 && (i3 = n3.indexOf(Number(s3))), i3 !== -1 && t3.add(Number(n3[i3]))) : t3.add(s3);
        } else
          for (let s3 of e3)
            t3.add(s3);
      }
      finalizeFilters() {
        !this.enabled && this.deps.size > 0 ? (this.enabled = true, te(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && te(this.pick, this.deps);
      }
    }
    var J = { jfif: false, tiff: true, xmp: false, icc: false, iptc: false, ifd0: true, ifd1: false, exif: true, gps: true, interop: false, ihdr: void 0, makerNote: false, userComment: false, multiSegment: false, skip: [], pick: [], translateKeys: true, translateValues: true, reviveValues: true, sanitize: true, mergeOutput: true, silentErrors: true, chunked: true, firstChunkSize: void 0, firstChunkSizeNode: 512, firstChunkSizeBrowser: 65536, chunkSize: 65536, chunkLimit: 5 }, q2 = /* @__PURE__ */ new Map();
    class Q extends Y {
      static useCached(e3) {
        let t3 = q2.get(e3);
        return t3 !== void 0 || (t3 = new this(e3), q2.set(e3, t3)), t3;
      }
      constructor(e3) {
        super(), e3 === true ? this.setupFromTrue() : e3 === void 0 ? this.setupFromUndefined() : Array.isArray(e3) ? this.setupFromArray(e3) : typeof e3 == "object" ? this.setupFromObject(e3) : o2(`Invalid options argument ${e3}`), this.firstChunkSize === void 0 && (this.firstChunkSize = i2 ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = false), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();
      }
      setupFromUndefined() {
        let e3;
        for (e3 of M2)
          this[e3] = J[e3];
        for (e3 of H2)
          this[e3] = J[e3];
        for (e3 of W)
          this[e3] = J[e3];
        for (e3 of K)
          this[e3] = new G(e3, J[e3], void 0, this);
      }
      setupFromTrue() {
        let e3;
        for (e3 of M2)
          this[e3] = J[e3];
        for (e3 of H2)
          this[e3] = J[e3];
        for (e3 of W)
          this[e3] = true;
        for (e3 of K)
          this[e3] = new G(e3, true, void 0, this);
      }
      setupFromArray(e3) {
        let t3;
        for (t3 of M2)
          this[t3] = J[t3];
        for (t3 of H2)
          this[t3] = J[t3];
        for (t3 of W)
          this[t3] = J[t3];
        for (t3 of K)
          this[t3] = new G(t3, false, void 0, this);
        this.setupGlobalFilters(e3, void 0, $2);
      }
      setupFromObject(e3) {
        let t3;
        for (t3 of ($2.ifd0 = $2.ifd0 || $2.image, $2.ifd1 = $2.ifd1 || $2.thumbnail, Object.assign(this, e3), M2))
          this[t3] = ee2(e3[t3], J[t3]);
        for (t3 of H2)
          this[t3] = ee2(e3[t3], J[t3]);
        for (t3 of W)
          this[t3] = ee2(e3[t3], J[t3]);
        for (t3 of R)
          this[t3] = new G(t3, J[t3], e3[t3], this);
        for (t3 of $2)
          this[t3] = new G(t3, J[t3], e3[t3], this.tiff);
        this.setupGlobalFilters(e3.pick, e3.skip, $2, K), e3.tiff === true ? this.batchEnableWithBool($2, true) : e3.tiff === false ? this.batchEnableWithUserValue($2, e3) : Array.isArray(e3.tiff) ? this.setupGlobalFilters(e3.tiff, void 0, $2) : typeof e3.tiff == "object" && this.setupGlobalFilters(e3.tiff.pick, e3.tiff.skip, $2);
      }
      batchEnableWithBool(e3, t3) {
        for (let s3 of e3)
          this[s3].enabled = t3;
      }
      batchEnableWithUserValue(e3, t3) {
        for (let s3 of e3) {
          let e4 = t3[s3];
          this[s3].enabled = e4 !== false && e4 !== void 0;
        }
      }
      setupGlobalFilters(e3, t3, s3, i3 = s3) {
        if (e3 && e3.length) {
          for (let e4 of i3)
            this[e4].enabled = false;
          let t4 = Z(e3, s3);
          for (let [e4, s4] of t4)
            te(this[e4].pick, s4), this[e4].enabled = true;
        } else if (t3 && t3.length) {
          let e4 = Z(t3, s3);
          for (let [t4, s4] of e4)
            te(this[t4].skip, s4);
        }
      }
      filterNestedSegmentTags() {
        let { ifd0: e3, exif: t3, xmp: s3, iptc: i3, icc: n3 } = this;
        this.makerNote ? t3.deps.add(P2) : t3.skip.add(P2), this.userComment ? t3.deps.add(z2) : t3.skip.add(z2), s3.enabled || e3.skip.add(700), i3.enabled || e3.skip.add(F), n3.enabled || e3.skip.add(j2);
      }
      traverseTiffDependencyTree() {
        let { ifd0: e3, exif: t3, gps: s3, interop: i3 } = this;
        i3.needed && (t3.deps.add(D2), e3.deps.add(D2)), t3.needed && e3.deps.add(E), s3.needed && e3.deps.add(_2), this.tiff.enabled = $2.some((e4) => this[e4].enabled === true) || this.makerNote || this.userComment;
        for (let e4 of $2)
          this[e4].finalizeFilters();
      }
      get onlyTiff() {
        return !N2.map((e3) => this[e3].enabled).some((e3) => e3 === true) && this.tiff.enabled;
      }
      checkLoadedPlugins() {
        for (let e3 of R)
          this[e3].enabled && !b2.has(e3) && g2("segment parser", e3);
      }
    }
    function Z(e3, t3) {
      let s3, i3, n3, r3, a3 = [];
      for (n3 of t3) {
        for (r3 of (s3 = I2.get(n3), i3 = [], s3))
          (e3.includes(r3[0]) || e3.includes(r3[1])) && i3.push(r3[0]);
        i3.length && a3.push([n3, i3]);
      }
      return a3;
    }
    function ee2(e3, t3) {
      return e3 !== void 0 ? e3 : t3 !== void 0 ? t3 : void 0;
    }
    function te(e3, t3) {
      for (let s3 of t3)
        e3.add(s3);
    }
    t2(Q, "default", J);
    class se {
      constructor(e3) {
        t2(this, "parsers", {}), t2(this, "output", {}), t2(this, "errors", []), t2(this, "pushToErrors", (e4) => this.errors.push(e4)), this.options = Q.useCached(e3);
      }
      async read(e3) {
        this.file = await function(e4, t3) {
          return typeof e4 == "string" ? v2(e4, t3) : i2 && !n2 && e4 instanceof HTMLImageElement ? v2(e4.src, t3) : e4 instanceof Uint8Array || e4 instanceof ArrayBuffer || e4 instanceof DataView ? new p2(e4) : i2 && e4 instanceof Blob ? S2(e4, t3, "blob", x2) : void o2(O2);
        }(e3, this.options);
      }
      setup() {
        if (this.fileParser)
          return;
        let { file: e3 } = this, t3 = e3.getUint16(0);
        for (let [s3, i3] of y2)
          if (i3.canHandle(e3, t3))
            return this.fileParser = new i3(this.options, this.file, this.parsers), e3[s3] = true;
        this.file.close && this.file.close(), o2("Unknown file format");
      }
      async parse() {
        let { output: e3, errors: t3 } = this;
        return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t3.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t3.length > 0 && (e3.errors = t3), l2(s3 = e3) ? void 0 : s3;
        var s3;
      }
      async executeParsers() {
        let { output: e3 } = this;
        await this.fileParser.parse();
        let t3 = Object.values(this.parsers).map(async (t4) => {
          let s3 = await t4.parse();
          t4.assignToOutput(e3, s3);
        });
        this.options.silentErrors && (t3 = t3.map((e4) => e4.catch(this.pushToErrors))), await Promise.all(t3);
      }
      async extractThumbnail() {
        this.setup();
        let { options: e3, file: t3 } = this, s3 = b2.get("tiff", e3);
        var i3;
        if (t3.tiff ? i3 = { start: 0, type: "tiff" } : t3.jpeg && (i3 = await this.fileParser.getOrFindSegment("tiff")), i3 === void 0)
          return;
        let n3 = await this.fileParser.ensureSegmentChunk(i3), r3 = this.parsers.tiff = new s3(n3, e3, t3), a3 = await r3.extractThumbnail();
        return t3.close && t3.close(), a3;
      }
    }
    async function ie(e3, t3) {
      let s3 = new se(t3);
      return await s3.read(e3), s3.parse();
    }
    var ne = Object.freeze({ __proto__: null, parse: ie, Exifr: se, fileParsers: y2, segmentParsers: b2, fileReaders: w2, tagKeys: I2, tagValues: L2, tagRevivers: T2, createDictionary: B2, extendDictionary: V, fetchUrlAsArrayBuffer: U, readBlobAsArrayBuffer: x2, chunkedProps: M2, otherSegments: N2, segments: R, tiffBlocks: $2, segmentsAndBlocks: K, tiffExtractables: W, inheritables: X, allFormatters: H2, Options: Q });
    class re {
      static findPosition(e3, t3) {
        let s3 = e3.getUint16(t3 + 2) + 2, i3 = typeof this.headerLength == "function" ? this.headerLength(e3, t3, s3) : this.headerLength, n3 = t3 + i3, r3 = s3 - i3;
        return { offset: t3, length: s3, headerLength: i3, start: n3, size: r3, end: n3 + r3 };
      }
      static parse(e3, t3 = {}) {
        return new this(e3, new Q({ [this.type]: t3 }), e3).parse();
      }
      normalizeInput(e3) {
        return e3 instanceof p2 ? e3 : new p2(e3);
      }
      constructor(e3, s3 = {}, i3) {
        t2(this, "errors", []), t2(this, "raw", /* @__PURE__ */ new Map()), t2(this, "handleError", (e4) => {
          if (!this.options.silentErrors)
            throw e4;
          this.errors.push(e4.message);
        }), this.chunk = this.normalizeInput(e3), this.file = i3, this.type = this.constructor.type, this.globalOptions = this.options = s3, this.localOptions = s3[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;
      }
      translate() {
        this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));
      }
      get output() {
        return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;
      }
      translateBlock(e3, t3) {
        let s3 = T2.get(t3), i3 = L2.get(t3), n3 = I2.get(t3), r3 = this.options[t3], a3 = r3.reviveValues && !!s3, h3 = r3.translateValues && !!i3, f3 = r3.translateKeys && !!n3, l3 = {};
        for (let [t4, r4] of e3)
          a3 && s3.has(t4) ? r4 = s3.get(t4)(r4) : h3 && i3.has(t4) && (r4 = this.translateValue(r4, i3.get(t4))), f3 && n3.has(t4) && (t4 = n3.get(t4) || t4), l3[t4] = r4;
        return l3;
      }
      translateValue(e3, t3) {
        return t3[e3] || t3.DEFAULT || e3;
      }
      assignToOutput(e3, t3) {
        this.assignObjectToOutput(e3, this.constructor.type, t3);
      }
      assignObjectToOutput(e3, t3, s3) {
        if (this.globalOptions.mergeOutput)
          return Object.assign(e3, s3);
        e3[t3] ? Object.assign(e3[t3], s3) : e3[t3] = s3;
      }
    }
    t2(re, "headerLength", 4), t2(re, "type", void 0), t2(re, "multiSegment", false), t2(re, "canHandle", () => false);
    function ae(e3) {
      return e3 === 192 || e3 === 194 || e3 === 196 || e3 === 219 || e3 === 221 || e3 === 218 || e3 === 254;
    }
    function he(e3) {
      return e3 >= 224 && e3 <= 239;
    }
    function fe(e3, t3, s3) {
      for (let [i3, n3] of b2)
        if (n3.canHandle(e3, t3, s3))
          return i3;
    }
    class le extends class {
      constructor(e3, s3, i3) {
        t2(this, "errors", []), t2(this, "ensureSegmentChunk", async (e4) => {
          let t3 = e4.start, s4 = e4.size || 65536;
          if (this.file.chunked)
            if (this.file.available(t3, s4))
              e4.chunk = this.file.subarray(t3, s4);
            else
              try {
                e4.chunk = await this.file.readChunk(t3, s4);
              } catch (t4) {
                o2(`Couldn't read segment: ${JSON.stringify(e4)}. ${t4.message}`);
              }
          else
            this.file.byteLength > t3 + s4 ? e4.chunk = this.file.subarray(t3, s4) : e4.size === void 0 ? e4.chunk = this.file.subarray(t3) : o2("Segment unreachable: " + JSON.stringify(e4));
          return e4.chunk;
        }), this.extendOptions && this.extendOptions(e3), this.options = e3, this.file = s3, this.parsers = i3;
      }
      injectSegment(e3, t3) {
        this.options[e3].enabled && this.createParser(e3, t3);
      }
      createParser(e3, t3) {
        let s3 = new (b2.get(e3))(t3, this.options, this.file);
        return this.parsers[e3] = s3;
      }
      createParsers(e3) {
        for (let t3 of e3) {
          let { type: e4, chunk: s3 } = t3, i3 = this.options[e4];
          if (i3 && i3.enabled) {
            let t4 = this.parsers[e4];
            t4 && t4.append || t4 || this.createParser(e4, s3);
          }
        }
      }
      async readSegments(e3) {
        let t3 = e3.map(this.ensureSegmentChunk);
        await Promise.all(t3);
      }
    } {
      constructor(...e3) {
        super(...e3), t2(this, "appSegments", []), t2(this, "jpegSegments", []), t2(this, "unknownSegments", []);
      }
      static canHandle(e3, t3) {
        return t3 === 65496;
      }
      async parse() {
        await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);
      }
      setupSegmentFinderArgs(e3) {
        e3 === true ? (this.findAll = true, this.wanted = new Set(b2.keyList())) : (e3 = e3 === void 0 ? b2.keyList().filter((e4) => this.options[e4].enabled) : e3.filter((e4) => this.options[e4].enabled && b2.has(e4)), this.findAll = false, this.remaining = new Set(e3), this.wanted = new Set(e3)), this.unfinishedMultiSegment = false;
      }
      async findAppSegments(e3 = 0, t3) {
        this.setupSegmentFinderArgs(t3);
        let { file: s3, findAll: i3, wanted: n3, remaining: r3 } = this;
        if (!i3 && this.file.chunked && (i3 = Array.from(n3).some((e4) => {
          let t4 = b2.get(e4), s4 = this.options[e4];
          return t4.multiSegment && s4.multiSegment;
        }), i3 && await this.file.readWhole()), e3 = this.findAppSegmentsInRange(e3, s3.byteLength), !this.options.onlyTiff && s3.chunked) {
          let t4 = false;
          for (; r3.size > 0 && !t4 && (s3.canReadNextChunk || this.unfinishedMultiSegment); ) {
            let { nextChunkOffset: i4 } = s3, n4 = this.appSegments.some((e4) => !this.file.available(e4.offset || e4.start, e4.length || e4.size));
            if (t4 = e3 > i4 && !n4 ? !await s3.readNextChunk(e3) : !await s3.readNextChunk(i4), (e3 = this.findAppSegmentsInRange(e3, s3.byteLength)) === void 0)
              return;
          }
        }
      }
      findAppSegmentsInRange(e3, t3) {
        t3 -= 2;
        let s3, i3, n3, r3, a3, h3, { file: f3, findAll: l3, wanted: o3, remaining: u3, options: d3 } = this;
        for (; e3 < t3; e3++)
          if (f3.getUint8(e3) === 255) {
            if (s3 = f3.getUint8(e3 + 1), he(s3)) {
              if (i3 = f3.getUint16(e3 + 2), n3 = fe(f3, e3, i3), n3 && o3.has(n3) && (r3 = b2.get(n3), a3 = r3.findPosition(f3, e3), h3 = d3[n3], a3.type = n3, this.appSegments.push(a3), !l3 && (r3.multiSegment && h3.multiSegment ? (this.unfinishedMultiSegment = a3.chunkNumber < a3.chunkCount, this.unfinishedMultiSegment || u3.delete(n3)) : u3.delete(n3), u3.size === 0)))
                break;
              d3.recordUnknownSegments && (a3 = re.findPosition(f3, e3), a3.marker = s3, this.unknownSegments.push(a3)), e3 += i3 + 1;
            } else if (ae(s3)) {
              if (i3 = f3.getUint16(e3 + 2), s3 === 218 && d3.stopAfterSos !== false)
                return;
              d3.recordJpegSegments && this.jpegSegments.push({ offset: e3, length: i3, marker: s3 }), e3 += i3 + 1;
            }
          }
        return e3;
      }
      mergeMultiSegments() {
        if (!this.appSegments.some((e4) => e4.multiSegment))
          return;
        let e3 = function(e4, t3) {
          let s3, i3, n3, r3 = /* @__PURE__ */ new Map();
          for (let a3 = 0; a3 < e4.length; a3++)
            s3 = e4[a3], i3 = s3[t3], r3.has(i3) ? n3 = r3.get(i3) : r3.set(i3, n3 = []), n3.push(s3);
          return Array.from(r3);
        }(this.appSegments, "type");
        this.mergedAppSegments = e3.map(([e4, t3]) => {
          let s3 = b2.get(e4, this.options);
          if (s3.handleMultiSegments) {
            return { type: e4, chunk: s3.handleMultiSegments(t3) };
          }
          return t3[0];
        });
      }
      getSegment(e3) {
        return this.appSegments.find((t3) => t3.type === e3);
      }
      async getOrFindSegment(e3) {
        let t3 = this.getSegment(e3);
        return t3 === void 0 && (await this.findAppSegments(0, [e3]), t3 = this.getSegment(e3)), t3;
      }
    }
    t2(le, "type", "jpeg"), y2.set("jpeg", le);
    const oe = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];
    class ue extends re {
      parseHeader() {
        var e3 = this.chunk.getUint16();
        e3 === 18761 ? this.le = true : e3 === 19789 && (this.le = false), this.chunk.le = this.le, this.headerParsed = true;
      }
      parseTags(e3, t3, s3 = /* @__PURE__ */ new Map()) {
        let { pick: i3, skip: n3 } = this.options[t3];
        i3 = new Set(i3);
        let r3 = i3.size > 0, a3 = n3.size === 0, h3 = this.chunk.getUint16(e3);
        e3 += 2;
        for (let f3 = 0; f3 < h3; f3++) {
          let h4 = this.chunk.getUint16(e3);
          if (r3) {
            if (i3.has(h4) && (s3.set(h4, this.parseTag(e3, h4, t3)), i3.delete(h4), i3.size === 0))
              break;
          } else
            !a3 && n3.has(h4) || s3.set(h4, this.parseTag(e3, h4, t3));
          e3 += 12;
        }
        return s3;
      }
      parseTag(e3, t3, s3) {
        let { chunk: i3 } = this, n3 = i3.getUint16(e3 + 2), r3 = i3.getUint32(e3 + 4), a3 = oe[n3];
        if (a3 * r3 <= 4 ? e3 += 8 : e3 = i3.getUint32(e3 + 8), (n3 < 1 || n3 > 13) && o2(`Invalid TIFF value type. block: ${s3.toUpperCase()}, tag: ${t3.toString(16)}, type: ${n3}, offset ${e3}`), e3 > i3.byteLength && o2(`Invalid TIFF value offset. block: ${s3.toUpperCase()}, tag: ${t3.toString(16)}, type: ${n3}, offset ${e3} is outside of chunk size ${i3.byteLength}`), n3 === 1)
          return i3.getUint8Array(e3, r3);
        if (n3 === 2)
          return (h3 = function(e4) {
            for (; e4.endsWith("\0"); )
              e4 = e4.slice(0, -1);
            return e4;
          }(h3 = i3.getString(e3, r3)).trim()) === "" ? void 0 : h3;
        var h3;
        if (n3 === 7)
          return i3.getUint8Array(e3, r3);
        if (r3 === 1)
          return this.parseTagValue(n3, e3);
        {
          let t4 = new (function(e4) {
            switch (e4) {
              case 1:
                return Uint8Array;
              case 3:
                return Uint16Array;
              case 4:
                return Uint32Array;
              case 5:
                return Array;
              case 6:
                return Int8Array;
              case 8:
                return Int16Array;
              case 9:
                return Int32Array;
              case 10:
                return Array;
              case 11:
                return Float32Array;
              case 12:
                return Float64Array;
              default:
                return Array;
            }
          }(n3))(r3), s4 = a3;
          for (let i4 = 0; i4 < r3; i4++)
            t4[i4] = this.parseTagValue(n3, e3), e3 += s4;
          return t4;
        }
      }
      parseTagValue(e3, t3) {
        let { chunk: s3 } = this;
        switch (e3) {
          case 1:
            return s3.getUint8(t3);
          case 3:
            return s3.getUint16(t3);
          case 4:
            return s3.getUint32(t3);
          case 5:
            return s3.getUint32(t3) / s3.getUint32(t3 + 4);
          case 6:
            return s3.getInt8(t3);
          case 8:
            return s3.getInt16(t3);
          case 9:
            return s3.getInt32(t3);
          case 10:
            return s3.getInt32(t3) / s3.getInt32(t3 + 4);
          case 11:
            return s3.getFloat(t3);
          case 12:
            return s3.getDouble(t3);
          case 13:
            return s3.getUint32(t3);
          default:
            o2(`Invalid tiff type ${e3}`);
        }
      }
    }
    class de extends ue {
      static canHandle(e3, t3) {
        return e3.getUint8(t3 + 1) === 225 && e3.getUint32(t3 + 4) === 1165519206 && e3.getUint16(t3 + 8) === 0;
      }
      async parse() {
        this.parseHeader();
        let { options: e3 } = this;
        return e3.ifd0.enabled && await this.parseIfd0Block(), e3.exif.enabled && await this.safeParse("parseExifBlock"), e3.gps.enabled && await this.safeParse("parseGpsBlock"), e3.interop.enabled && await this.safeParse("parseInteropBlock"), e3.ifd1.enabled && await this.safeParse("parseThumbnailBlock"), this.createOutput();
      }
      safeParse(e3) {
        let t3 = this[e3]();
        return t3.catch !== void 0 && (t3 = t3.catch(this.handleError)), t3;
      }
      findIfd0Offset() {
        this.ifd0Offset === void 0 && (this.ifd0Offset = this.chunk.getUint32(4));
      }
      findIfd1Offset() {
        if (this.ifd1Offset === void 0) {
          this.findIfd0Offset();
          let e3 = this.chunk.getUint16(this.ifd0Offset), t3 = this.ifd0Offset + 2 + 12 * e3;
          this.ifd1Offset = this.chunk.getUint32(t3);
        }
      }
      parseBlock(e3, t3) {
        let s3 = /* @__PURE__ */ new Map();
        return this[t3] = s3, this.parseTags(e3, t3, s3), s3;
      }
      async parseIfd0Block() {
        if (this.ifd0)
          return;
        let { file: e3 } = this;
        this.findIfd0Offset(), this.ifd0Offset < 8 && o2("Malformed EXIF data"), !e3.chunked && this.ifd0Offset > e3.byteLength && o2(`IFD0 offset points to outside of file.
this.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e3.byteLength}`), e3.tiff && await e3.ensureChunk(this.ifd0Offset, u2(this.options));
        let t3 = this.parseBlock(this.ifd0Offset, "ifd0");
        return t3.size !== 0 ? (this.exifOffset = t3.get(E), this.interopOffset = t3.get(D2), this.gpsOffset = t3.get(_2), this.xmp = t3.get(700), this.iptc = t3.get(F), this.icc = t3.get(j2), this.options.sanitize && (t3.delete(E), t3.delete(D2), t3.delete(_2), t3.delete(700), t3.delete(F), t3.delete(j2)), t3) : void 0;
      }
      async parseExifBlock() {
        if (this.exif)
          return;
        if (this.ifd0 || await this.parseIfd0Block(), this.exifOffset === void 0)
          return;
        this.file.tiff && await this.file.ensureChunk(this.exifOffset, u2(this.options));
        let e3 = this.parseBlock(this.exifOffset, "exif");
        return this.interopOffset || (this.interopOffset = e3.get(D2)), this.makerNote = e3.get(P2), this.userComment = e3.get(z2), this.options.sanitize && (e3.delete(D2), e3.delete(P2), e3.delete(z2)), this.unpack(e3, 41728), this.unpack(e3, 41729), e3;
      }
      unpack(e3, t3) {
        let s3 = e3.get(t3);
        s3 && s3.length === 1 && e3.set(t3, s3[0]);
      }
      async parseGpsBlock() {
        if (this.gps)
          return;
        if (this.ifd0 || await this.parseIfd0Block(), this.gpsOffset === void 0)
          return;
        let e3 = this.parseBlock(this.gpsOffset, "gps");
        return e3 && e3.has(2) && e3.has(4) && (e3.set("latitude", ce(...e3.get(2), e3.get(1))), e3.set("longitude", ce(...e3.get(4), e3.get(3)))), e3;
      }
      async parseInteropBlock() {
        if (!this.interop && (this.ifd0 || await this.parseIfd0Block(), this.interopOffset !== void 0 || this.exif || await this.parseExifBlock(), this.interopOffset !== void 0))
          return this.parseBlock(this.interopOffset, "interop");
      }
      async parseThumbnailBlock(e3 = false) {
        if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e3))
          return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, "ifd1"), this.ifd1Parsed = true), this.ifd1;
      }
      async extractThumbnail() {
        if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || await this.parseThumbnailBlock(true), this.ifd1 === void 0)
          return;
        let e3 = this.ifd1.get(513), t3 = this.ifd1.get(514);
        return this.chunk.getUint8Array(e3, t3);
      }
      get image() {
        return this.ifd0;
      }
      get thumbnail() {
        return this.ifd1;
      }
      createOutput() {
        let e3, t3, s3, i3 = {};
        for (t3 of $2)
          if (e3 = this[t3], !l2(e3))
            if (s3 = this.canTranslate ? this.translateBlock(e3, t3) : Object.fromEntries(e3), this.options.mergeOutput) {
              if (t3 === "ifd1")
                continue;
              Object.assign(i3, s3);
            } else
              i3[t3] = s3;
        return this.makerNote && (i3.makerNote = this.makerNote), this.userComment && (i3.userComment = this.userComment), i3;
      }
      assignToOutput(e3, t3) {
        if (this.globalOptions.mergeOutput)
          Object.assign(e3, t3);
        else
          for (let [s3, i3] of Object.entries(t3))
            this.assignObjectToOutput(e3, s3, i3);
      }
    }
    function ce(e3, t3, s3, i3) {
      var n3 = e3 + t3 / 60 + s3 / 3600;
      return i3 !== "S" && i3 !== "W" || (n3 *= -1), n3;
    }
    t2(de, "type", "tiff"), t2(de, "headerLength", 10), b2.set("tiff", de);
    var pe = Object.freeze({ __proto__: null, default: ne, Exifr: se, fileParsers: y2, segmentParsers: b2, fileReaders: w2, tagKeys: I2, tagValues: L2, tagRevivers: T2, createDictionary: B2, extendDictionary: V, fetchUrlAsArrayBuffer: U, readBlobAsArrayBuffer: x2, chunkedProps: M2, otherSegments: N2, segments: R, tiffBlocks: $2, segmentsAndBlocks: K, tiffExtractables: W, inheritables: X, allFormatters: H2, Options: Q, parse: ie });
    const ge = { ifd0: false, ifd1: false, exif: false, gps: false, interop: false, sanitize: false, reviveValues: true, translateKeys: false, translateValues: false, mergeOutput: false }, me = Object.assign({}, ge, { firstChunkSize: 4e4, gps: [1, 2, 3, 4] });
    const ye = Object.assign({}, ge, { tiff: false, ifd1: true, mergeOutput: false });
    const be = Object.assign({}, ge, { firstChunkSize: 4e4, ifd0: [274] });
    async function we(e3) {
      let t3 = new se(be);
      await t3.read(e3);
      let s3 = await t3.parse();
      if (s3 && s3.ifd0)
        return s3.ifd0[274];
    }
    const ke = Object.freeze({ 1: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 0, rad: 0 }, 2: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 0, rad: 0 }, 3: { dimensionSwapped: false, scaleX: 1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 4: { dimensionSwapped: false, scaleX: -1, scaleY: 1, deg: 180, rad: 180 * Math.PI / 180 }, 5: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 90, rad: 90 * Math.PI / 180 }, 6: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 90, rad: 90 * Math.PI / 180 }, 7: { dimensionSwapped: true, scaleX: 1, scaleY: -1, deg: 270, rad: 270 * Math.PI / 180 }, 8: { dimensionSwapped: true, scaleX: 1, scaleY: 1, deg: 270, rad: 270 * Math.PI / 180 } });
    if (e2.rotateCanvas = true, e2.rotateCss = true, typeof navigator == "object") {
      let t3 = navigator.userAgent;
      if (t3.includes("iPad") || t3.includes("iPhone")) {
        let s3 = t3.match(/OS (\d+)_(\d+)/);
        if (s3) {
          let [, t4, i3] = s3, n3 = Number(t4) + 0.1 * Number(i3);
          e2.rotateCanvas = n3 < 13.4, e2.rotateCss = false;
        }
      } else if (t3.includes("OS X 10")) {
        let [, s3] = t3.match(/OS X 10[_.](\d+)/);
        e2.rotateCanvas = e2.rotateCss = Number(s3) < 15;
      }
      if (t3.includes("Chrome/")) {
        let [, s3] = t3.match(/Chrome\/(\d+)/);
        e2.rotateCanvas = e2.rotateCss = Number(s3) < 81;
      } else if (t3.includes("Firefox/")) {
        let [, s3] = t3.match(/Firefox\/(\d+)/);
        e2.rotateCanvas = e2.rotateCss = Number(s3) < 77;
      }
    }
    class Oe extends p2 {
      constructor(...e3) {
        super(...e3), t2(this, "ranges", new ve()), this.byteLength !== 0 && this.ranges.add(0, this.byteLength);
      }
      _tryExtend(e3, t3, s3) {
        if (e3 === 0 && this.byteLength === 0 && s3) {
          let e4 = new DataView(s3.buffer || s3, s3.byteOffset, s3.byteLength);
          this._swapDataView(e4);
        } else {
          let s4 = e3 + t3;
          if (s4 > this.byteLength) {
            let { dataView: e4 } = this._extend(s4);
            this._swapDataView(e4);
          }
        }
      }
      _extend(e3) {
        let t3;
        t3 = h2 ? a2.allocUnsafe(e3) : new Uint8Array(e3);
        let s3 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
        return t3.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), { uintView: t3, dataView: s3 };
      }
      subarray(e3, t3, s3 = false) {
        return t3 = t3 || this._lengthToEnd(e3), s3 && this._tryExtend(e3, t3), this.ranges.add(e3, t3), super.subarray(e3, t3);
      }
      set(e3, t3, s3 = false) {
        s3 && this._tryExtend(t3, e3.byteLength, e3);
        let i3 = super.set(e3, t3);
        return this.ranges.add(t3, i3.byteLength), i3;
      }
      async ensureChunk(e3, t3) {
        this.chunked && (this.ranges.available(e3, t3) || await this.readChunk(e3, t3));
      }
      available(e3, t3) {
        return this.ranges.available(e3, t3);
      }
    }
    class ve {
      constructor() {
        t2(this, "list", []);
      }
      get length() {
        return this.list.length;
      }
      add(e3, t3, s3 = 0) {
        let i3 = e3 + t3, n3 = this.list.filter((t4) => Se(e3, t4.offset, i3) || Se(e3, t4.end, i3));
        if (n3.length > 0) {
          e3 = Math.min(e3, ...n3.map((e4) => e4.offset)), i3 = Math.max(i3, ...n3.map((e4) => e4.end)), t3 = i3 - e3;
          let s4 = n3.shift();
          s4.offset = e3, s4.length = t3, s4.end = i3, this.list = this.list.filter((e4) => !n3.includes(e4));
        } else
          this.list.push({ offset: e3, length: t3, end: i3 });
      }
      available(e3, t3) {
        let s3 = e3 + t3;
        return this.list.some((t4) => t4.offset <= e3 && s3 <= t4.end);
      }
    }
    function Se(e3, t3, s3) {
      return e3 <= t3 && t3 <= s3;
    }
    class Ae extends Oe {
      constructor(e3, s3) {
        super(0), t2(this, "chunksRead", 0), this.input = e3, this.options = s3;
      }
      async readWhole() {
        this.chunked = false, await this.readChunk(this.nextChunkOffset);
      }
      async readChunked() {
        this.chunked = true, await this.readChunk(0, this.options.firstChunkSize);
      }
      async readNextChunk(e3 = this.nextChunkOffset) {
        if (this.fullyRead)
          return this.chunksRead++, false;
        let t3 = this.options.chunkSize, s3 = await this.readChunk(e3, t3);
        return !!s3 && s3.byteLength === t3;
      }
      async readChunk(e3, t3) {
        if (this.chunksRead++, (t3 = this.safeWrapAddress(e3, t3)) !== 0)
          return this._readChunk(e3, t3);
      }
      safeWrapAddress(e3, t3) {
        return this.size !== void 0 && e3 + t3 > this.size ? Math.max(0, this.size - e3) : t3;
      }
      get nextChunkOffset() {
        if (this.ranges.list.length !== 0)
          return this.ranges.list[0].length;
      }
      get canReadNextChunk() {
        return this.chunksRead < this.options.chunkLimit;
      }
      get fullyRead() {
        return this.size !== void 0 && this.nextChunkOffset === this.size;
      }
      read() {
        return this.options.chunked ? this.readChunked() : this.readWhole();
      }
      close() {
      }
    }
    w2.set("blob", class extends Ae {
      async readWhole() {
        this.chunked = false;
        let e3 = await x2(this.input);
        this._swapArrayBuffer(e3);
      }
      readChunked() {
        return this.chunked = true, this.size = this.input.size, super.readChunked();
      }
      async _readChunk(e3, t3) {
        let s3 = t3 ? e3 + t3 : void 0, i3 = this.input.slice(e3, s3), n3 = await x2(i3);
        return this.set(n3, e3, true);
      }
    }), e2.Exifr = se, e2.Options = Q, e2.allFormatters = H2, e2.chunkedProps = M2, e2.createDictionary = B2, e2.default = pe, e2.extendDictionary = V, e2.fetchUrlAsArrayBuffer = U, e2.fileParsers = y2, e2.fileReaders = w2, e2.gps = async function(e3) {
      let t3 = new se(me);
      await t3.read(e3);
      let s3 = await t3.parse();
      if (s3 && s3.gps) {
        let { latitude: e4, longitude: t4 } = s3.gps;
        return { latitude: e4, longitude: t4 };
      }
    }, e2.gpsOnlyOptions = me, e2.inheritables = X, e2.orientation = we, e2.orientationOnlyOptions = be, e2.otherSegments = N2, e2.parse = ie, e2.readBlobAsArrayBuffer = x2, e2.rotation = async function(t3) {
      let s3 = await we(t3);
      return Object.assign({ canvas: e2.rotateCanvas, css: e2.rotateCss }, ke[s3]);
    }, e2.rotations = ke, e2.segmentParsers = b2, e2.segments = R, e2.segmentsAndBlocks = K, e2.tagKeys = I2, e2.tagRevivers = T2, e2.tagValues = L2, e2.thumbnail = async function(e3) {
      let t3 = new se(ye);
      await t3.read(e3);
      let s3 = await t3.extractThumbnail();
      return s3 && h2 ? a2.from(s3) : s3;
    }, e2.thumbnailOnlyOptions = ye, e2.thumbnailUrl = async function(e3) {
      let t3 = await this.thumbnail(e3);
      if (t3 !== void 0) {
        let e4 = new Blob([t3]);
        return URL.createObjectURL(e4);
      }
    }, e2.tiffBlocks = $2, e2.tiffExtractables = W, Object.defineProperty(e2, "__esModule", { value: true });
  });
})(mini_umd, mini_umd.exports);
var locale$9 = {
  strings: {
    generatingThumbnails: "Generating thumbnails..."
  }
};
var _class$3, _temp$3;
const {
  UIPlugin: UIPlugin$3
} = lib$a.exports;
const dataURItoBlob2 = dataURItoBlob$1;
const isObjectURL2 = isObjectURL$1;
const isPreviewSupported2 = isPreviewSupported$1;
const {
  rotation
} = mini_umd.exports;
const locale$8 = locale$9;
var lib$4 = (_temp$3 = _class$3 = class ThumbnailGenerator extends UIPlugin$3 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.onFileAdded = (file) => {
      if (!file.preview && file.data && isPreviewSupported2(file.type) && !file.isRemote) {
        this.addToQueue(file.id);
      }
    };
    this.onCancelRequest = (file) => {
      const index = this.queue.indexOf(file.id);
      if (index !== -1) {
        this.queue.splice(index, 1);
      }
    };
    this.onFileRemoved = (file) => {
      const index = this.queue.indexOf(file.id);
      if (index !== -1) {
        this.queue.splice(index, 1);
      }
      if (file.preview && isObjectURL2(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };
    this.onRestored = () => {
      const restoredFiles = this.uppy.getFiles().filter((file) => file.isRestored);
      restoredFiles.forEach((file) => {
        if (!file.preview || isObjectURL2(file.preview)) {
          this.addToQueue(file.id);
        }
      });
    };
    this.onAllFilesRemoved = () => {
      this.queue = [];
    };
    this.waitUntilAllProcessed = (fileIDs) => {
      fileIDs.forEach((fileID) => {
        const file = this.uppy.getFile(fileID);
        this.uppy.emit("preprocess-progress", file, {
          mode: "indeterminate",
          message: this.i18n("generatingThumbnails")
        });
      });
      const emitPreprocessCompleteForAll = () => {
        fileIDs.forEach((fileID) => {
          const file = this.uppy.getFile(fileID);
          this.uppy.emit("preprocess-complete", file);
        });
      };
      return new Promise((resolve) => {
        if (this.queueProcessing) {
          this.uppy.once("thumbnail:all-generated", () => {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };
    this.type = "modifier";
    this.id = this.opts.id || "ThumbnailGenerator";
    this.title = "Thumbnail Generator";
    this.queue = [];
    this.queueProcessing = false;
    this.defaultThumbnailDimension = 200;
    this.thumbnailType = this.opts.thumbnailType || "image/jpeg";
    this.defaultLocale = locale$8;
    const defaultOptions2 = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false,
      lazy: false
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
    this.i18nInit();
    if (this.opts.lazy && this.opts.waitForThumbnailsBeforeUpload) {
      throw new Error("ThumbnailGenerator: The `lazy` and `waitForThumbnailsBeforeUpload` options are mutually exclusive. Please ensure at most one of them is set to `true`.");
    }
  }
  createThumbnail(file, targetWidth, targetHeight) {
    const originalUrl = URL.createObjectURL(file.data);
    const onload = new Promise((resolve, reject) => {
      const image = new Image();
      image.src = originalUrl;
      image.addEventListener("load", () => {
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener("error", (event) => {
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error("Could not create thumbnail"));
      });
    });
    const orientationPromise = rotation(file.data).catch(() => 1);
    return Promise.all([onload, orientationPromise]).then((_ref) => {
      let [image, orientation] = _ref;
      const dimensions = this.getProportionalDimensions(image, targetWidth, targetHeight, orientation.deg);
      const rotatedImage = this.rotateImage(image, orientation);
      const resizedImage = this.resizeImage(rotatedImage, dimensions.width, dimensions.height);
      return this.canvasToBlob(resizedImage, this.thumbnailType, 80);
    }).then((blob) => {
      return URL.createObjectURL(blob);
    });
  }
  getProportionalDimensions(img, width, height, rotation2) {
    let aspect = img.width / img.height;
    if (rotation2 === 90 || rotation2 === 270) {
      aspect = img.height / img.width;
    }
    if (width != null) {
      return {
        width,
        height: Math.round(width / aspect)
      };
    }
    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height
      };
    }
    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  }
  protect(image) {
    const ratio = image.width / image.height;
    const maxSquare = 5e6;
    const maxSize = 4096;
    let maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    let maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));
    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }
    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }
    if (image.width > maxW) {
      const canvas = document.createElement("canvas");
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext("2d").drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }
    return image;
  }
  resizeImage(image, targetWidth, targetHeight) {
    image = this.protect(image);
    let steps = Math.ceil(Math.log2(image.width / targetWidth));
    if (steps < 1) {
      steps = 1;
    }
    let sW = targetWidth * 2 ** (steps - 1);
    let sH = targetHeight * 2 ** (steps - 1);
    const x2 = 2;
    while (steps--) {
      const canvas = document.createElement("canvas");
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext("2d").drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x2);
      sH = Math.round(sH / x2);
    }
    return image;
  }
  rotateImage(image, translate) {
    let w2 = image.width;
    let h2 = image.height;
    if (translate.deg === 90 || translate.deg === 270) {
      w2 = image.height;
      h2 = image.width;
    }
    const canvas = document.createElement("canvas");
    canvas.width = w2;
    canvas.height = h2;
    const context = canvas.getContext("2d");
    context.translate(w2 / 2, h2 / 2);
    if (translate.canvas) {
      context.rotate(translate.rad);
      context.scale(translate.scaleX, translate.scaleY);
    }
    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext("2d").getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error("cannot read image, probably an svg with external resources"));
      }
    }
    if (canvas.toBlob) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, type, quality);
      }).then((blob) => {
        if (blob === null) {
          throw new Error("cannot read image, probably an svg with external resources");
        }
        return blob;
      });
    }
    return Promise.resolve().then(() => {
      return dataURItoBlob2(canvas.toDataURL(type, quality), {});
    }).then((blob) => {
      if (blob === null) {
        throw new Error("could not extract blob, probably an old browser");
      }
      return blob;
    });
  }
  setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview
    });
  }
  addToQueue(item) {
    this.queue.push(item);
    if (this.queueProcessing === false) {
      this.processQueue();
    }
  }
  processQueue() {
    this.queueProcessing = true;
    if (this.queue.length > 0) {
      const current = this.uppy.getFile(this.queue.shift());
      if (!current) {
        this.uppy.log("[ThumbnailGenerator] file was removed before a thumbnail could be generated, but not removed from the queue. This is probably a bug", "error");
        return;
      }
      return this.requestThumbnail(current).catch(() => {
      }).then(() => this.processQueue());
    }
    this.queueProcessing = false;
    this.uppy.log("[ThumbnailGenerator] Emptied thumbnail queue");
    this.uppy.emit("thumbnail:all-generated");
  }
  requestThumbnail(file) {
    if (isPreviewSupported2(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then((preview) => {
        this.setPreviewURL(file.id, preview);
        this.uppy.log(`[ThumbnailGenerator] Generated thumbnail for ${file.id}`);
        this.uppy.emit("thumbnail:generated", this.uppy.getFile(file.id), preview);
      }).catch((err) => {
        this.uppy.log(`[ThumbnailGenerator] Failed thumbnail for ${file.id}:`, "warning");
        this.uppy.log(err, "warning");
        this.uppy.emit("thumbnail:error", this.uppy.getFile(file.id), err);
      });
    }
    return Promise.resolve();
  }
  install() {
    this.uppy.on("file-removed", this.onFileRemoved);
    this.uppy.on("cancel-all", this.onAllFilesRemoved);
    if (this.opts.lazy) {
      this.uppy.on("thumbnail:request", this.onFileAdded);
      this.uppy.on("thumbnail:cancel", this.onCancelRequest);
    } else {
      this.uppy.on("file-added", this.onFileAdded);
      this.uppy.on("restored", this.onRestored);
    }
    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  }
  uninstall() {
    this.uppy.off("file-removed", this.onFileRemoved);
    this.uppy.off("cancel-all", this.onAllFilesRemoved);
    if (this.opts.lazy) {
      this.uppy.off("thumbnail:request", this.onFileAdded);
      this.uppy.off("thumbnail:cancel", this.onCancelRequest);
    } else {
      this.uppy.off("file-added", this.onFileAdded);
      this.uppy.off("restored", this.onRestored);
    }
    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  }
}, _class$3.VERSION = "2.1.1", _temp$3);
var isDOMElement$1 = function isDOMElement2(obj) {
  return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
};
const isDOMElement3 = isDOMElement$1;
var findAllDOMElements$1 = function findAllDOMElements(element) {
  if (typeof element === "string") {
    const elements = document.querySelectorAll(element);
    return elements.length === 0 ? null : Array.from(elements);
  }
  if (typeof element === "object" && isDOMElement3(element)) {
    return [element];
  }
  return null;
};
var toArray$9 = Array.from;
var getRelativePath$3 = function getRelativePath(fileEntry) {
  if (!fileEntry.fullPath || fileEntry.fullPath === `/${fileEntry.name}`) {
    return null;
  }
  return fileEntry.fullPath;
};
var getFilesAndDirectoriesFromDirectory$3 = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
  let {
    onSuccess
  } = _ref;
  directoryReader.readEntries((entries) => {
    const newEntries = [...oldEntries, ...entries];
    if (entries.length) {
      setTimeout(() => {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess
        });
      }, 0);
    } else {
      onSuccess(newEntries);
    }
  }, (error) => {
    logDropError(error);
    onSuccess(oldEntries);
  });
};
const toArray$8 = toArray$9;
const getRelativePath$2 = getRelativePath$3;
const getFilesAndDirectoriesFromDirectory$2 = getFilesAndDirectoriesFromDirectory$3;
var webkitGetAsEntryApi$3 = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  const files = [];
  const rootPromises = [];
  const createPromiseToAddFileOrParseDirectory = (entry) => new Promise((resolve) => {
    if (entry.isFile) {
      entry.file((file) => {
        file.relativePath = getRelativePath$2(entry);
        files.push(file);
        resolve();
      }, (error) => {
        logDropError(error);
        resolve();
      });
    } else if (entry.isDirectory) {
      const directoryReader = entry.createReader();
      getFilesAndDirectoriesFromDirectory$2(directoryReader, [], logDropError, {
        onSuccess: (entries) => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))
      });
    }
  });
  toArray$8(dataTransfer.items).forEach((item) => {
    const entry = item.webkitGetAsEntry();
    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(() => files);
};
const toArray$7 = toArray$9;
var fallbackApi$3 = function fallbackApi(dataTransfer) {
  const files = toArray$7(dataTransfer.files);
  return Promise.resolve(files);
};
const webkitGetAsEntryApi$2 = webkitGetAsEntryApi$3;
const fallbackApi$2 = fallbackApi$3;
var getDroppedFiles$3 = function getDroppedFiles(dataTransfer, _temp2) {
  var _dataTransfer$items;
  let {
    logDropError = () => {
    }
  } = _temp2 === void 0 ? {} : _temp2;
  if ((_dataTransfer$items = dataTransfer.items) != null && _dataTransfer$items[0] && "webkitGetAsEntry" in dataTransfer.items[0]) {
    return webkitGetAsEntryApi$2(dataTransfer, logDropError);
  }
  return fallbackApi$2(dataTransfer);
};
function getTextDirection$1(element) {
  var _element;
  while (element && !element.dir) {
    element = element.parentNode;
  }
  return (_element = element) == null ? void 0 : _element.dir;
}
var getTextDirection_1 = getTextDirection$1;
var FOCUSABLE_ELEMENTS$3 = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', "input:not([disabled]):not([inert]):not([aria-hidden])", "select:not([disabled]):not([inert]):not([aria-hidden])", "textarea:not([disabled]):not([inert]):not([aria-hidden])", "button:not([disabled]):not([inert]):not([aria-hidden])", 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];
var getActiveOverlayEl$2 = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    const overlayEl = dashboardEl.querySelector(`[data-uppy-paneltype="${activeOverlayType}"]`);
    if (overlayEl)
      return overlayEl;
  }
  return dashboardEl;
};
const toArray$6 = toArray$9;
const FOCUSABLE_ELEMENTS$2 = FOCUSABLE_ELEMENTS$3;
const getActiveOverlayEl$1 = getActiveOverlayEl$2;
function focusOnFirstNode(event, nodes) {
  const node = nodes[0];
  if (node) {
    node.focus();
    event.preventDefault();
  }
}
function focusOnLastNode(event, nodes) {
  const node = nodes[nodes.length - 1];
  if (node) {
    node.focus();
    event.preventDefault();
  }
}
function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}
function trapFocus$1(event, activeOverlayType, dashboardEl) {
  const activeOverlayEl = getActiveOverlayEl$1(dashboardEl, activeOverlayType);
  const focusableNodes = toArray$6(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS$2));
  const focusedItemIndex = focusableNodes.indexOf(document.activeElement);
  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes);
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes);
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}
var trapFocus_1 = {
  forModal: (event, activeOverlayType, dashboardEl) => {
    trapFocus$1(event, activeOverlayType, dashboardEl);
  },
  forInline: (event, activeOverlayType, dashboardEl) => {
    if (activeOverlayType === null)
      ;
    else {
      trapFocus$1(event, activeOverlayType, dashboardEl);
    }
  }
};
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now = function() {
  return root.Date.now();
};
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject2(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject2(value) {
  var type = typeof value;
  return !!value && (type == "object" || type == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_debounce = debounce$1;
const debounce = lodash_debounce;
const FOCUSABLE_ELEMENTS$1 = FOCUSABLE_ELEMENTS$3;
const getActiveOverlayEl2 = getActiveOverlayEl$2;
var createSuperFocus$1 = function createSuperFocus() {
  let lastFocusWasOnSuperFocusableEl = false;
  const superFocus = (dashboardEl, activeOverlayType) => {
    const overlayEl = getActiveOverlayEl2(dashboardEl, activeOverlayType);
    const isFocusInOverlay2 = overlayEl.contains(document.activeElement);
    if (isFocusInOverlay2 && lastFocusWasOnSuperFocusableEl)
      return;
    const superFocusableEl = overlayEl.querySelector("[data-uppy-super-focusable]");
    if (isFocusInOverlay2 && !superFocusableEl)
      return;
    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      const firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS$1);
      firstEl == null ? void 0 : firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  };
  return debounce(superFocus, 260);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$1(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i2 = 0; i2 < newInputs.length; i2++) {
    if (!isEqual$1(newInputs[i2], lastInputs[i2])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual2(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoizeOne_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": memoizeOne
}, Symbol.toStringTag, { value: "Module" }));
var require$$12 = /* @__PURE__ */ getAugmentedNamespace(memoizeOne_esm);
var isDragDropSupported$3 = function isDragDropSupported() {
  const div = document.body;
  if (!("draggable" in div) || !("ondragstart" in div && "ondrop" in div)) {
    return false;
  }
  if (!("FormData" in window)) {
    return false;
  }
  if (!("FileReader" in window)) {
    return false;
  }
  return true;
};
var isShallowEqual = function isShallowEqual2(a2, b2) {
  if (a2 === b2)
    return true;
  for (var i2 in a2)
    if (!(i2 in b2))
      return false;
  for (var i2 in b2)
    if (a2[i2] !== b2[i2])
      return false;
  return true;
};
const {
  h: h$p
} = require$$1;
function iconImage() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("g", {
    fill: "#686DE0",
    fillRule: "evenodd"
  }, h$p("path", {
    d: "M5 7v10h15V7H5zm0-1h15a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1z",
    fillRule: "nonzero"
  }), h$p("path", {
    d: "M6.35 17.172l4.994-5.026a.5.5 0 0 1 .707 0l2.16 2.16 3.505-3.505a.5.5 0 0 1 .707 0l2.336 2.31-.707.72-1.983-1.97-3.505 3.505a.5.5 0 0 1-.707 0l-2.16-2.159-3.938 3.939-1.409.026z",
    fillRule: "nonzero"
  }), h$p("circle", {
    cx: "7.5",
    cy: "9.5",
    r: "1.5"
  })));
}
function iconAudio() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    fillRule: "nonzero"
  }));
}
function iconVideo() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    fillRule: "nonzero"
  }));
}
function iconPDF() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    fillRule: "nonzero"
  }));
}
function iconArchive() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("path", {
    d: "M10.45 2.05h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V2.55a.5.5 0 0 1 .5-.5zm2.05 1.024h1.05a.5.5 0 0 1 .5.5V3.6a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5v-.001zM10.45 0h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5V.5a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 3.074h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-2.05 1.024h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm-2.05 1.025h1.05a.5.5 0 0 1 .5.5v.025a.5.5 0 0 1-.5.5h-1.05a.5.5 0 0 1-.5-.5v-.025a.5.5 0 0 1 .5-.5zm2.05 1.025h1.05a.5.5 0 0 1 .5.5v.024a.5.5 0 0 1-.5.5H12.5a.5.5 0 0 1-.5-.5v-.024a.5.5 0 0 1 .5-.5zm-1.656 3.074l-.82 5.946c.52.302 1.174.458 1.976.458.803 0 1.455-.156 1.975-.458l-.82-5.946h-2.311zm0-1.025h2.312c.512 0 .946.378 1.015.885l.82 5.946c.056.412-.142.817-.501 1.026-.686.398-1.515.597-2.49.597-.974 0-1.804-.199-2.49-.597a1.025 1.025 0 0 1-.5-1.026l.819-5.946c.07-.507.503-.885 1.015-.885zm.545 6.6a.5.5 0 0 1-.397-.561l.143-.999a.5.5 0 0 1 .495-.429h.74a.5.5 0 0 1 .495.43l.143.998a.5.5 0 0 1-.397.561c-.404.08-.819.08-1.222 0z",
    fill: "#00C469",
    fillRule: "nonzero"
  }));
}
function iconFile() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("g", {
    fill: "#A7AFB7",
    fillRule: "nonzero"
  }, h$p("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h$p("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}
function iconText() {
  return h$p("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h$p("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    fillRule: "nonzero"
  }));
}
var getFileTypeIcon$3 = function getIconByMime(fileType) {
  const defaultChoice = {
    color: "#838999",
    icon: iconFile()
  };
  if (!fileType)
    return defaultChoice;
  const fileTypeGeneral = fileType.split("/")[0];
  const fileTypeSpecific = fileType.split("/")[1];
  if (fileTypeGeneral === "text") {
    return {
      color: "#5a5e69",
      icon: iconText()
    };
  }
  if (fileTypeGeneral === "image") {
    return {
      color: "#686de0",
      icon: iconImage()
    };
  }
  if (fileTypeGeneral === "audio") {
    return {
      color: "#068dbb",
      icon: iconAudio()
    };
  }
  if (fileTypeGeneral === "video") {
    return {
      color: "#19af67",
      icon: iconVideo()
    };
  }
  if (fileTypeGeneral === "application" && fileTypeSpecific === "pdf") {
    return {
      color: "#e25149",
      icon: iconPDF()
    };
  }
  const archiveTypes = ["zip", "x-7z-compressed", "x-rar-compressed", "x-tar", "x-gzip", "x-apple-diskimage"];
  if (fileTypeGeneral === "application" && archiveTypes.indexOf(fileTypeSpecific) !== -1) {
    return {
      color: "#00C469",
      icon: iconArchive()
    };
  }
  return defaultChoice;
};
const {
  h: h$o
} = require$$1;
const getFileTypeIcon$2 = getFileTypeIcon$3;
var FilePreview$2 = function FilePreview(props) {
  const {
    file
  } = props;
  if (file.preview) {
    return h$o("img", {
      className: "uppy-Dashboard-Item-previewImg",
      alt: file.name,
      src: file.preview
    });
  }
  const {
    color,
    icon
  } = getFileTypeIcon$2(file.type);
  return h$o("div", {
    className: "uppy-Dashboard-Item-previewIconWrap"
  }, h$o("span", {
    className: "uppy-Dashboard-Item-previewIcon",
    style: {
      color
    }
  }, icon), h$o("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-Dashboard-Item-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h$o("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    fillRule: "evenodd"
  })));
};
const {
  h: h$n
} = require$$1;
const metaFieldIdToName = (metaFieldId, metaFields2) => {
  const field = metaFields2.filter((f2) => f2.id === metaFieldId);
  return field[0].name;
};
var MetaErrorMessage$2 = function renderMissingMetaFieldsError(props) {
  const {
    file,
    toggleFileCard,
    i18n,
    metaFields: metaFields2
  } = props;
  const {
    missingRequiredMetaFields
  } = file;
  if (!(missingRequiredMetaFields != null && missingRequiredMetaFields.length)) {
    return null;
  }
  const metaFieldsString = missingRequiredMetaFields.map((missingMetaField) => metaFieldIdToName(missingMetaField, metaFields2)).join(", ");
  return h$n("div", {
    className: "uppy-Dashboard-Item-errorMessage"
  }, i18n("missingRequiredMetaFields", {
    smart_count: missingRequiredMetaFields.length,
    fields: metaFieldsString
  }), " ", h$n("button", {
    type: "button",
    class: "uppy-u-reset uppy-Dashboard-Item-errorMessageBtn",
    onClick: () => toggleFileCard(true, file.id)
  }, i18n("editFile")));
};
const {
  h: h$m
} = require$$1;
const FilePreview$1 = FilePreview$2;
const MetaErrorMessage$1 = MetaErrorMessage$2;
const getFileTypeIcon$1 = getFileTypeIcon$3;
var FilePreviewAndLink$1 = function FilePreviewAndLink(props) {
  return h$m("div", {
    className: "uppy-Dashboard-Item-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon$1(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h$m("a", {
    className: "uppy-Dashboard-Item-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }, h$m("span", {
    hidden: true
  }, props.file.meta.name)), h$m(FilePreview$1, {
    file: props.file
  }), h$m(MetaErrorMessage$1, {
    file: props.file,
    i18n: props.i18n,
    toggleFileCard: props.toggleFileCard,
    metaFields: props.metaFields
  }));
};
const {
  h: h$l
} = require$$1;
function onPauseResumeCancelRetry(props) {
  if (props.isUploaded)
    return;
  if (props.error && !props.hideRetryButton) {
    props.uppy.retryUpload(props.file.id);
    return;
  }
  if (props.resumableUploads && !props.hidePauseResumeButton) {
    props.uppy.pauseResume(props.file.id);
  } else if (props.individualCancellation && !props.hideCancelButton) {
    props.uppy.removeFile(props.file.id);
  }
}
function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n("uploadComplete");
  }
  if (props.error) {
    return props.i18n("retryUpload");
  }
  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n("resumeUpload");
    }
    return props.i18n("pauseUpload");
  }
  if (props.individualCancellation) {
    return props.i18n("cancelUpload");
  }
  return "";
}
function ProgressIndicatorButton(props) {
  return h$l("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h$l("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-progressIndicator",
    type: "button",
    "aria-label": progressIndicatorTitle(props),
    title: progressIndicatorTitle(props),
    onClick: () => onPauseResumeCancelRetry(props)
  }, props.children));
}
function ProgressCircleContainer(_ref) {
  let {
    children
  } = _ref;
  return h$l("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--circle"
  }, children);
}
function ProgressCircle(_ref2) {
  let {
    progress
  } = _ref2;
  const circleLength = 2 * Math.PI * 15;
  return h$l("g", null, h$l("circle", {
    className: "uppy-Dashboard-Item-progressIcon--bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h$l("circle", {
    className: "uppy-Dashboard-Item-progressIcon--progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    fill: "none",
    "stroke-width": "2",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * progress
  }));
}
var FileProgress$1 = function FileProgress(props) {
  if (!props.file.progress.uploadStarted) {
    return null;
  }
  if (props.isUploaded) {
    return h$l("div", {
      className: "uppy-Dashboard-Item-progress"
    }, h$l("div", {
      className: "uppy-Dashboard-Item-progressIndicator"
    }, h$l(ProgressCircleContainer, null, h$l("circle", {
      r: "15",
      cx: "18",
      cy: "18",
      fill: "#1bb240"
    }), h$l("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--check",
      transform: "translate(2, 3)",
      points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
    }))));
  }
  if (props.recoveredState) {
    return;
  }
  if (props.error && !props.hideRetryButton) {
    return h$l(ProgressIndicatorButton, props, h$l("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-Item-progressIcon--retry",
      width: "28",
      height: "31",
      viewBox: "0 0 16 19"
    }, h$l("path", {
      d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
    }), h$l("path", {
      d: "M7.9 3H10v2H7.9z"
    }), h$l("path", {
      d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
    }), h$l("path", {
      d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
    })));
  }
  if (props.resumableUploads && !props.hidePauseResumeButton) {
    return h$l(ProgressIndicatorButton, props, h$l(ProgressCircleContainer, null, h$l(ProgressCircle, {
      progress: props.file.progress.percentage
    }), props.file.isPaused ? h$l("polygon", {
      className: "uppy-Dashboard-Item-progressIcon--play",
      transform: "translate(3, 3)",
      points: "12 20 12 10 20 15"
    }) : h$l("g", {
      className: "uppy-Dashboard-Item-progressIcon--pause",
      transform: "translate(14.5, 13)"
    }, h$l("rect", {
      x: "0",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }), h$l("rect", {
      x: "5",
      y: "0",
      width: "2",
      height: "10",
      rx: "0"
    }))));
  }
  if (!props.resumableUploads && props.individualCancellation && !props.hideCancelButton) {
    return h$l(ProgressIndicatorButton, props, h$l(ProgressCircleContainer, null, h$l(ProgressCircle, {
      progress: props.file.progress.percentage
    }), h$l("polygon", {
      className: "cancel",
      transform: "translate(2, 2)",
      points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
    })));
  }
  return h$l("div", {
    className: "uppy-Dashboard-Item-progress"
  }, h$l("div", {
    className: "uppy-Dashboard-Item-progressIndicator"
  }, h$l(ProgressCircleContainer, null, h$l(ProgressCircle, {
    progress: props.file.progress.percentage
  }))));
};
const separator = "...";
var truncateString$1 = function truncateString(string, maxLength) {
  if (maxLength === 0)
    return "";
  if (string.length <= maxLength)
    return string;
  if (maxLength <= separator.length + 1)
    return `${string.slice(0, maxLength - 1)}\u2026`;
  const charsToShow = maxLength - separator.length;
  const frontChars = Math.ceil(charsToShow / 2);
  const backChars = Math.floor(charsToShow / 2);
  return string.slice(0, frontChars) + separator + string.slice(-backChars);
};
const {
  h: h$k,
  Fragment
} = require$$1;
const prettierBytes2 = prettierBytes$3;
const truncateString2 = truncateString$1;
const MetaErrorMessage = MetaErrorMessage$2;
const renderFileName = (props) => {
  const {
    author,
    name
  } = props.file.meta;
  function getMaxNameLength() {
    if (props.containerWidth <= 352) {
      return 35;
    }
    if (props.containerWidth <= 576) {
      return 60;
    }
    return author ? 20 : 30;
  }
  return h$k("div", {
    className: "uppy-Dashboard-Item-name",
    title: name
  }, truncateString2(name, getMaxNameLength()));
};
const renderAuthor = (props) => {
  const {
    author
  } = props.file.meta;
  const {
    providerName
  } = props.file.remote;
  const dot = `\xB7`;
  if (!author) {
    return null;
  }
  return h$k("div", {
    className: "uppy-Dashboard-Item-author"
  }, h$k("a", {
    href: `${author.url}?utm_source=Companion&utm_medium=referral`,
    target: "_blank",
    rel: "noopener noreferrer"
  }, truncateString2(author.name, 13)), providerName ? h$k(Fragment, null, ` ${dot} `, providerName, ` ${dot} `) : null);
};
const renderFileSize = (props) => props.file.size && h$k("div", {
  className: "uppy-Dashboard-Item-statusSize"
}, prettierBytes2(props.file.size));
const ReSelectButton = (props) => props.file.isGhost && h$k("span", null, " \u2022 ", h$k("button", {
  className: "uppy-u-reset uppy-c-btn uppy-Dashboard-Item-reSelect",
  type: "button",
  onClick: props.toggleAddFilesPanel
}, props.i18n("reSelect")));
const ErrorButton = (_ref) => {
  let {
    file,
    onClick
  } = _ref;
  if (file.error) {
    return h$k("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-errorDetails",
      "aria-label": file.error,
      "data-microtip-position": "bottom",
      "data-microtip-size": "medium",
      onClick,
      type: "button"
    }, "?");
  }
  return null;
};
var FileInfo$1 = function FileInfo(props) {
  const {
    file
  } = props;
  return h$k("div", {
    className: "uppy-Dashboard-Item-fileInfo",
    "data-uppy-file-source": file.source
  }, h$k("div", {
    className: "uppy-Dashboard-Item-fileName"
  }, renderFileName(props), h$k(ErrorButton, {
    file: props.file,
    onClick: () => alert(props.file.error)
  })), h$k("div", {
    className: "uppy-Dashboard-Item-status"
  }, renderAuthor(props), renderFileSize(props), ReSelectButton(props)), h$k(MetaErrorMessage, {
    file: props.file,
    i18n: props.i18n,
    toggleFileCard: props.toggleFileCard,
    metaFields: props.metaFields
  }));
};
var copyToClipboard$1 = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || "Copy the URL below";
  return new Promise((resolve) => {
    const textArea = document.createElement("textarea");
    textArea.setAttribute("style", {
      position: "fixed",
      top: 0,
      left: 0,
      width: "2em",
      height: "2em",
      padding: 0,
      border: "none",
      outline: "none",
      boxShadow: "none",
      background: "transparent"
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();
    const magicCopyFailed = () => {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };
    try {
      const successful = document.execCommand("copy");
      if (!successful) {
        return magicCopyFailed("copy command unavailable");
      }
      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};
const {
  h: h$j
} = require$$1;
const copyToClipboard2 = copyToClipboard$1;
function EditButton(_ref) {
  let {
    file,
    uploadInProgressOrComplete,
    metaFields: metaFields2,
    canEditFile,
    i18n,
    onClick
  } = _ref;
  if (!uploadInProgressOrComplete && metaFields2 && metaFields2.length > 0 || !uploadInProgressOrComplete && canEditFile(file)) {
    return h$j("button", {
      className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--edit",
      type: "button",
      "aria-label": i18n("editFileWithFilename", {
        file: file.meta.name
      }),
      title: i18n("editFileWithFilename", {
        file: file.meta.name
      }),
      onClick: () => onClick()
    }, h$j("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon",
      width: "14",
      height: "14",
      viewBox: "0 0 14 14"
    }, h$j("g", {
      fillRule: "evenodd"
    }, h$j("path", {
      d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
      fillRule: "nonzero"
    }), h$j("rect", {
      x: "1",
      y: "12.293",
      width: "11",
      height: "1",
      rx: ".5"
    }), h$j("path", {
      fillRule: "nonzero",
      d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
    }))));
  }
  return null;
}
function RemoveButton(_ref2) {
  let {
    i18n,
    onClick,
    file
  } = _ref2;
  return h$j("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--remove",
    type: "button",
    "aria-label": i18n("removeFile", {
      file: file.meta.name
    }),
    title: i18n("removeFile", {
      file: file.meta.name
    }),
    onClick: () => onClick()
  }, h$j("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h$j("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h$j("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  })));
}
const copyLinkToClipboard = (event, props) => {
  copyToClipboard2(props.file.uploadURL, props.i18n("copyLinkToClipboardFallback")).then(() => {
    props.uppy.log("Link copied to clipboard.");
    props.uppy.info(props.i18n("copyLinkToClipboardSuccess"), "info", 3e3);
  }).catch(props.uppy.log).then(() => event.target.focus({
    preventScroll: true
  }));
};
function CopyLinkButton(props) {
  const {
    i18n
  } = props;
  return h$j("button", {
    className: "uppy-u-reset uppy-Dashboard-Item-action uppy-Dashboard-Item-action--copyLink",
    type: "button",
    "aria-label": i18n("copyLink"),
    title: i18n("copyLink"),
    onClick: (event) => copyLinkToClipboard(event, props)
  }, h$j("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h$j("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  })));
}
var Buttons$1 = function Buttons(props) {
  const {
    uppy: uppy2,
    file,
    uploadInProgressOrComplete,
    canEditFile,
    metaFields: metaFields2,
    showLinkToFileUploadResult,
    showRemoveButton,
    i18n,
    toggleFileCard,
    openFileEditor
  } = props;
  const editAction = () => {
    if (metaFields2 && metaFields2.length > 0) {
      toggleFileCard(true, file.id);
    } else {
      openFileEditor(file);
    }
  };
  return h$j("div", {
    className: "uppy-Dashboard-Item-actionWrapper"
  }, h$j(EditButton, {
    i18n,
    file,
    uploadInProgressOrComplete,
    canEditFile,
    metaFields: metaFields2,
    onClick: editAction
  }), showLinkToFileUploadResult && file.uploadURL ? h$j(CopyLinkButton, {
    file,
    uppy: uppy2,
    i18n
  }) : null, showRemoveButton ? h$j(RemoveButton, {
    i18n,
    file,
    uppy: uppy2,
    onClick: () => props.uppy.removeFile(file.id, "removed-by-user")
  }) : null);
};
const {
  h: h$i,
  Component: Component$4
} = require$$1;
const classNames$7 = classnames.exports;
const shallowEqual = isShallowEqual;
const FilePreviewAndLink2 = FilePreviewAndLink$1;
const FileProgress2 = FileProgress$1;
const FileInfo2 = FileInfo$1;
const Buttons2 = Buttons$1;
var FileItem_1 = class FileItem extends Component$4 {
  componentDidMount() {
    const {
      file
    } = this.props;
    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }
  shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  }
  componentDidUpdate() {
    const {
      file
    } = this.props;
    if (!file.preview) {
      this.props.handleRequestThumbnail(file);
    }
  }
  componentWillUnmount() {
    const {
      file
    } = this.props;
    if (!file.preview) {
      this.props.handleCancelThumbnail(file);
    }
  }
  render() {
    const {
      file
    } = this.props;
    const isProcessing = file.progress.preprocess || file.progress.postprocess;
    const isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    const uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    const uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    const error = file.error || false;
    const {
      isGhost
    } = file;
    let showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;
    if (isUploaded && this.props.showRemoveButtonAfterComplete) {
      showRemoveButton = true;
    }
    const dashboardItemClass = classNames$7({
      "uppy-Dashboard-Item": true,
      "is-inprogress": uploadInProgress && !this.props.recoveredState,
      "is-processing": isProcessing,
      "is-complete": isUploaded,
      "is-error": !!error,
      "is-resumable": this.props.resumableUploads,
      "is-noIndividualCancellation": !this.props.individualCancellation,
      "is-ghost": isGhost
    });
    return h$i("div", {
      className: dashboardItemClass,
      id: `uppy_${file.id}`,
      role: this.props.role
    }, h$i("div", {
      className: "uppy-Dashboard-Item-preview"
    }, h$i(FilePreviewAndLink2, {
      file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      i18n: this.props.i18n,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields
    }), h$i(FileProgress2, {
      uppy: this.props.uppy,
      file,
      error,
      isUploaded,
      hideRetryButton: this.props.hideRetryButton,
      hideCancelButton: this.props.hideCancelButton,
      hidePauseResumeButton: this.props.hidePauseResumeButton,
      recoveredState: this.props.recoveredState,
      showRemoveButtonAfterComplete: this.props.showRemoveButtonAfterComplete,
      resumableUploads: this.props.resumableUploads,
      individualCancellation: this.props.individualCancellation,
      i18n: this.props.i18n
    })), h$i("div", {
      className: "uppy-Dashboard-Item-fileInfoAndButtons"
    }, h$i(FileInfo2, {
      file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n,
      toggleAddFilesPanel: this.props.toggleAddFilesPanel,
      toggleFileCard: this.props.toggleFileCard,
      metaFields: this.props.metaFields
    }), h$i(Buttons2, {
      file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton,
      canEditFile: this.props.canEditFile,
      uploadInProgressOrComplete,
      toggleFileCard: this.props.toggleFileCard,
      openFileEditor: this.props.openFileEditor,
      uppy: this.props.uppy,
      i18n: this.props.i18n
    })));
  }
};
function _extends$3() {
  _extends$3 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const {
  h: h$h,
  Component: Component$3
} = require$$1;
const STYLE_INNER = {
  position: "relative",
  width: "100%",
  minHeight: "100%"
};
const STYLE_CONTENT = {
  position: "absolute",
  top: 0,
  left: 0,
  width: "100%",
  overflow: "visible"
};
class VirtualList$1 extends Component$3 {
  constructor(props) {
    super(props);
    this.handleScroll = () => {
      this.setState({
        offset: this.base.scrollTop
      });
    };
    this.handleResize = () => {
      this.resize();
    };
    this.focusElement = null;
    this.state = {
      offset: 0,
      height: 0
    };
  }
  componentDidMount() {
    this.resize();
    window.addEventListener("resize", this.handleResize);
  }
  componentWillUpdate() {
    if (this.base.contains(document.activeElement)) {
      this.focusElement = document.activeElement;
    }
  }
  componentDidUpdate() {
    if (this.focusElement && this.focusElement.parentNode && document.activeElement !== this.focusElement) {
      this.focusElement.focus();
    }
    this.focusElement = null;
    this.resize();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleResize);
  }
  resize() {
    const {
      height
    } = this.state;
    if (height !== this.base.offsetHeight) {
      this.setState({
        height: this.base.offsetHeight
      });
    }
  }
  render(_ref) {
    let _a2 = _ref, {
      data,
      rowHeight,
      renderRow,
      overscanCount = 10
    } = _a2, props = __objRest(_a2, [
      "data",
      "rowHeight",
      "renderRow",
      "overscanCount"
    ]);
    const {
      offset,
      height
    } = this.state;
    let start = Math.floor(offset / rowHeight);
    let visibleRowCount = Math.floor(height / rowHeight);
    if (overscanCount) {
      start = Math.max(0, start - start % overscanCount);
      visibleRowCount += overscanCount;
    }
    const end = start + visibleRowCount + 4;
    const selection = data.slice(start, end);
    const styleInner = __spreadProps(__spreadValues({}, STYLE_INNER), {
      height: data.length * rowHeight
    });
    const styleContent = __spreadProps(__spreadValues({}, STYLE_CONTENT), {
      top: start * rowHeight
    });
    return h$h("div", _extends$3({
      onScroll: this.handleScroll
    }, props), h$h("div", {
      role: "presentation",
      style: styleInner
    }, h$h("div", {
      role: "presentation",
      style: styleContent
    }, selection.map(renderRow))));
  }
}
var VirtualList_1 = VirtualList$1;
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
const classNames$6 = classnames.exports;
const {
  h: h$g
} = require$$1;
const FileItem2 = FileItem_1;
const VirtualList = VirtualList_1;
function chunks(list, size) {
  const chunked = [];
  let currentChunk = [];
  list.forEach((item) => {
    if (currentChunk.length < size) {
      currentChunk.push(item);
    } else {
      chunked.push(currentChunk);
      currentChunk = [item];
    }
  });
  if (currentChunk.length)
    chunked.push(currentChunk);
  return chunked;
}
var FileList$1 = (props) => {
  const noFiles = props.totalFileCount === 0;
  const dashboardFilesClass = classNames$6("uppy-Dashboard-files", {
    "uppy-Dashboard-files--noFiles": noFiles
  });
  const rowHeight = props.itemsPerRow === 1 ? 71 : 200;
  const fileProps = {
    id: props.id,
    error: props.error,
    i18n: props.i18n,
    uppy: props.uppy,
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeButton: props.hidePauseResumeButton,
    hideCancelButton: props.hideCancelButton,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    showRemoveButtonAfterComplete: props.showRemoveButtonAfterComplete,
    isWide: props.isWide,
    metaFields: props.metaFields,
    recoveredState: props.recoveredState,
    toggleFileCard: props.toggleFileCard,
    handleRequestThumbnail: props.handleRequestThumbnail,
    handleCancelThumbnail: props.handleCancelThumbnail
  };
  const sortByGhostComesFirst = (file1, file2) => {
    return props.files[file2].isGhost - props.files[file1].isGhost;
  };
  const files = Object.keys(props.files);
  if (props.recoveredState)
    files.sort(sortByGhostComesFirst);
  const rows = chunks(files, props.itemsPerRow);
  const renderRow = (row) => h$g("div", {
    role: "presentation",
    key: row[0]
  }, row.map((fileID) => h$g(FileItem2, _extends$2({
    key: fileID,
    uppy: props.uppy
  }, fileProps, {
    role: "listitem",
    openFileEditor: props.openFileEditor,
    canEditFile: props.canEditFile,
    toggleAddFilesPanel: props.toggleAddFilesPanel,
    file: props.files[fileID]
  }))));
  return h$g(VirtualList, {
    class: dashboardFilesClass,
    role: "list",
    data: rows,
    renderRow,
    rowHeight
  });
};
let _Symbol$for;
const {
  h: h$f,
  Component: Component$2
} = require$$1;
_Symbol$for = Symbol.for("uppy test: disable unused locale key warning");
class AddFiles$2 extends Component$2 {
  constructor() {
    super(...arguments);
    this.triggerFileInputClick = () => {
      this.fileInput.click();
    };
    this.triggerFolderInputClick = () => {
      this.folderInput.click();
    };
    this.onFileInputChange = (event) => {
      this.props.handleInputChange(event);
      event.target.value = null;
    };
    this.renderHiddenInput = (isFolder, refCallback) => {
      return h$f("input", {
        className: "uppy-Dashboard-input",
        hidden: true,
        "aria-hidden": "true",
        tabIndex: -1,
        webkitdirectory: isFolder,
        type: "file",
        name: "files[]",
        multiple: this.props.maxNumberOfFiles !== 1,
        onChange: this.onFileInputChange,
        accept: this.props.allowedFileTypes,
        ref: refCallback
      });
    };
    this.renderMyDeviceAcquirer = () => {
      return h$f("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": "MyDevice"
      }, h$f("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-uppy-super-focusable": true,
        onClick: this.triggerFileInputClick
      }, h$f("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      }, h$f("g", {
        fill: "none",
        fillRule: "evenodd"
      }, h$f("rect", {
        className: "uppy-ProviderIconBg",
        width: "32",
        height: "32",
        rx: "16",
        fill: "#2275D7"
      }), h$f("path", {
        d: "M21.973 21.152H9.863l-1.108-5.087h14.464l-1.246 5.087zM9.935 11.37h3.958l.886 1.444a.673.673 0 0 0 .585.316h6.506v1.37H9.935v-3.13zm14.898 3.44a.793.793 0 0 0-.616-.31h-.978v-2.126c0-.379-.275-.613-.653-.613H15.75l-.886-1.445a.673.673 0 0 0-.585-.316H9.232c-.378 0-.667.209-.667.587V14.5h-.782a.793.793 0 0 0-.61.303.795.795 0 0 0-.155.663l1.45 6.633c.078.36.396.618.764.618h13.354c.36 0 .674-.246.76-.595l1.631-6.636a.795.795 0 0 0-.144-.675z",
        fill: "#FFF"
      }))), h$f("div", {
        className: "uppy-DashboardTab-name"
      }, this.props.i18n("myDevice"))));
    };
    this.renderBrowseButton = (text, onClickFn) => {
      const numberOfAcquirers = this.props.acquirers.length;
      return h$f("button", {
        type: "button",
        className: "uppy-u-reset uppy-Dashboard-browse",
        onClick: onClickFn,
        "data-uppy-super-focusable": numberOfAcquirers === 0
      }, text);
    };
    this.renderDropPasteBrowseTagline = () => {
      const numberOfAcquirers = this.props.acquirers.length;
      const browseFiles = this.renderBrowseButton(this.props.i18n("browseFiles"), this.triggerFileInputClick);
      const browseFolders = this.renderBrowseButton(this.props.i18n("browseFolders"), this.triggerFolderInputClick);
      const lowerFMSelectionType = this.props.fileManagerSelectionType;
      const camelFMSelectionType = lowerFMSelectionType.charAt(0).toUpperCase() + lowerFMSelectionType.slice(1);
      return h$f("div", {
        class: "uppy-Dashboard-AddFiles-title"
      }, this.props.disableLocalFiles ? this.props.i18n("importFiles") : numberOfAcquirers > 0 ? this.props.i18nArray(`dropPasteImport${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }) : this.props.i18nArray(`dropPaste${camelFMSelectionType}`, {
        browseFiles,
        browseFolders,
        browse: browseFiles
      }));
    };
    this.renderAcquirer = (acquirer) => {
      return h$f("div", {
        className: "uppy-DashboardTab",
        role: "presentation",
        "data-uppy-acquirer-id": acquirer.id
      }, h$f("button", {
        type: "button",
        className: "uppy-u-reset uppy-c-btn uppy-DashboardTab-btn",
        role: "tab",
        tabIndex: 0,
        "data-cy": acquirer.id,
        "aria-controls": `uppy-DashboardContent-panel--${acquirer.id}`,
        "aria-selected": this.props.activePickerPanel.id === acquirer.id,
        "data-uppy-super-focusable": true,
        onClick: () => this.props.showPanel(acquirer.id)
      }, acquirer.icon(), h$f("div", {
        className: "uppy-DashboardTab-name"
      }, acquirer.name)));
    };
    this.renderAcquirers = (acquirers, disableLocalFiles) => {
      const acquirersWithoutLastTwo = [...acquirers];
      const lastTwoAcquirers = acquirersWithoutLastTwo.splice(acquirers.length - 2, acquirers.length);
      return h$f("div", {
        className: "uppy-Dashboard-AddFiles-list",
        role: "tablist"
      }, !disableLocalFiles && this.renderMyDeviceAcquirer(), acquirersWithoutLastTwo.map((acquirer) => this.renderAcquirer(acquirer)), h$f("span", {
        role: "presentation",
        style: {
          "white-space": "nowrap"
        }
      }, lastTwoAcquirers.map((acquirer) => this.renderAcquirer(acquirer))));
    };
  }
  [_Symbol$for]() {
    this.props.i18nArray("dropPasteBoth");
    this.props.i18nArray("dropPasteFiles");
    this.props.i18nArray("dropPasteFolders");
    this.props.i18nArray("dropPasteImportBoth");
    this.props.i18nArray("dropPasteImportFiles");
    this.props.i18nArray("dropPasteImportFolders");
  }
  renderPoweredByUppy() {
    const {
      i18nArray
    } = this.props;
    const uppyBranding = h$f("span", null, h$f("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h$f("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      fillRule: "evenodd"
    })), h$f("span", {
      className: "uppy-Dashboard-poweredByUppy"
    }, "Uppy"));
    const linkText = i18nArray("poweredBy", {
      uppy: uppyBranding
    });
    return h$f("a", {
      tabIndex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      className: "uppy-Dashboard-poweredBy"
    }, linkText);
  }
  render() {
    return h$f("div", {
      className: "uppy-Dashboard-AddFiles"
    }, this.renderHiddenInput(false, (ref) => {
      this.fileInput = ref;
    }), this.renderHiddenInput(true, (ref) => {
      this.folderInput = ref;
    }), this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && this.renderAcquirers(this.props.acquirers, this.props.disableLocalFiles), h$f("div", {
      className: "uppy-Dashboard-AddFiles-info"
    }, this.props.note && h$f("div", {
      className: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props)));
  }
}
var AddFiles_1 = AddFiles$2;
const {
  h: h$e
} = require$$1;
const classNames$5 = classnames.exports;
const AddFiles$1 = AddFiles_1;
const AddFilesPanel$1 = (props) => {
  return h$e("div", {
    className: classNames$5("uppy-Dashboard-AddFilesPanel", props.className),
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h$e("div", {
    className: "uppy-DashboardContent-bar"
  }, h$e("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n("addingMoreFiles")), h$e("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: () => props.toggleAddFilesPanel(false)
  }, props.i18n("back"))), h$e(AddFiles$1, props));
};
var AddFilesPanel_1 = AddFilesPanel$1;
function ignoreEvent$2(ev) {
  const {
    tagName
  } = ev.target;
  if (tagName === "INPUT" || tagName === "TEXTAREA") {
    ev.stopPropagation();
    return;
  }
  ev.preventDefault();
  ev.stopPropagation();
}
var ignoreEvent_1 = ignoreEvent$2;
const {
  h: h$d
} = require$$1;
const classNames$4 = classnames.exports;
const ignoreEvent$1 = ignoreEvent_1;
function PickerPanelContent$1(props) {
  return h$d("div", {
    className: classNames$4("uppy-DashboardContent-panel", props.className),
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: `uppy-DashboardContent-panel--${props.activePickerPanel.id}`,
    onDragOver: ignoreEvent$1,
    onDragLeave: ignoreEvent$1,
    onDrop: ignoreEvent$1,
    onPaste: ignoreEvent$1
  }, h$d("div", {
    className: "uppy-DashboardContent-bar"
  }, h$d("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18n("importFrom", {
    name: props.activePickerPanel.name
  })), h$d("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n("cancel"))), h$d("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.uppy.getPlugin(props.activePickerPanel.id).render(props.state)));
}
var PickerPanelContent_1 = PickerPanelContent$1;
const {
  h: h$c
} = require$$1;
const classNames$3 = classnames.exports;
function EditorPanel$1(props) {
  const file = props.files[props.fileCardFor];
  return h$c("div", {
    className: classNames$3("uppy-DashboardContent-panel", props.className),
    role: "tabpanel",
    "data-uppy-panelType": "FileEditor",
    id: "uppy-DashboardContent-panel--editor"
  }, h$c("div", {
    className: "uppy-DashboardContent-bar"
  }, h$c("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, props.i18nArray("editing", {
    file: h$c("span", {
      className: "uppy-DashboardContent-titleFile"
    }, file.meta ? file.meta.name : file.name)
  })), h$c("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: props.hideAllPanels
  }, props.i18n("cancel")), h$c("button", {
    className: "uppy-DashboardContent-save",
    type: "button",
    onClick: props.saveFileEditor
  }, props.i18n("save"))), h$c("div", {
    className: "uppy-DashboardContent-panelBody"
  }, props.editors.map((target) => {
    return props.uppy.getPlugin(target.id).render(props.state);
  })));
}
var EditorPanel_1 = EditorPanel$1;
const {
  h: h$b
} = require$$1;
const uploadStates = {
  STATE_ERROR: "error",
  STATE_WAITING: "waiting",
  STATE_PREPROCESSING: "preprocessing",
  STATE_UPLOADING: "uploading",
  STATE_POSTPROCESSING: "postprocessing",
  STATE_COMPLETE: "complete",
  STATE_PAUSED: "paused"
};
function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
  if (files === void 0) {
    files = {};
  }
  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }
  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }
  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }
  let state = uploadStates.STATE_WAITING;
  const fileIDs = Object.keys(files);
  for (let i2 = 0; i2 < fileIDs.length; i2++) {
    const {
      progress
    } = files[fileIDs[i2]];
    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    }
    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    }
    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }
  return state;
}
function UploadStatus(props) {
  const uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);
  switch (uploadingState) {
    case "uploading":
      return props.i18n("uploadingXFiles", {
        smart_count: props.inProgressNotPausedFiles.length
      });
    case "preprocessing":
    case "postprocessing":
      return props.i18n("processingXFiles", {
        smart_count: props.processingFiles.length
      });
    case "paused":
      return props.i18n("uploadPaused");
    case "waiting":
      return props.i18n("xFilesSelected", {
        smart_count: props.newFiles.length
      });
    case "complete":
      return props.i18n("uploadComplete");
  }
}
function PanelTopBar$1(props) {
  let {
    allowNewUpload
  } = props;
  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }
  return h$b("div", {
    className: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h$b("button", {
    className: "uppy-DashboardContent-back",
    type: "button",
    onClick: () => props.uppy.cancelAll()
  }, props.i18n("cancel")) : h$b("div", null), h$b("div", {
    className: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "1"
  }, h$b(UploadStatus, props)), allowNewUpload ? h$b("button", {
    className: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n("addMoreFiles"),
    title: props.i18n("addMoreFiles"),
    onClick: () => props.toggleAddFilesPanel(true)
  }, h$b("svg", {
    "aria-hidden": "true",
    focusable: "false",
    className: "uppy-c-icon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h$b("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  })), h$b("span", {
    className: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n("addMore"))) : h$b("div", null));
}
var PickerPanelTopBar = PanelTopBar$1;
const {
  h: h$a,
  Component: Component$1
} = require$$1;
const classNames$2 = classnames.exports;
const {
  nanoid: nanoid$1
} = require$$9;
const getFileTypeIcon = getFileTypeIcon$3;
const ignoreEvent = ignoreEvent_1;
const FilePreview2 = FilePreview$2;
class FileCard$1 extends Component$1 {
  constructor(props) {
    super(props);
    this.form = document.createElement("form");
    this.updateMeta = (newVal, name) => {
      this.setState((_ref) => {
        let {
          formState
        } = _ref;
        return {
          formState: __spreadProps(__spreadValues({}, formState), {
            [name]: newVal
          })
        };
      });
    };
    this.handleSave = (e2) => {
      e2.preventDefault();
      const fileID = this.props.fileCardFor;
      this.props.saveFileCard(this.state.formState, fileID);
    };
    this.handleCancel = () => {
      this.props.toggleFileCard(false);
    };
    this.saveOnEnter = (ev) => {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        const file = this.props.files[this.props.fileCardFor];
        this.props.saveFileCard(this.state.formState, file.id);
      }
    };
    this.renderMetaFields = () => {
      const metaFields2 = this.getMetaFields() || [];
      const fieldCSSClasses = {
        text: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input"
      };
      return metaFields2.map((field) => {
        const id2 = `uppy-Dashboard-FileCard-input-${field.id}`;
        const required = this.props.requiredMetaFields.includes(field.id);
        return h$a("fieldset", {
          key: field.id,
          className: "uppy-Dashboard-FileCard-fieldset"
        }, h$a("label", {
          className: "uppy-Dashboard-FileCard-label",
          htmlFor: id2
        }, field.name), field.render !== void 0 ? field.render({
          value: this.state.formState[field.id],
          onChange: (newVal) => this.updateMeta(newVal, field.id),
          fieldCSSClasses,
          required,
          form: this.form.id
        }, h$a) : h$a("input", {
          className: fieldCSSClasses.text,
          id: id2,
          form: this.form.id,
          type: field.type || "text",
          required,
          value: this.state.formState[field.id],
          placeholder: field.placeholder,
          onKeyUp: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
          onKeyDown: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
          onKeyPress: "form" in HTMLInputElement.prototype ? void 0 : this.saveOnEnter,
          onInput: (ev) => this.updateMeta(ev.target.value, field.id),
          "data-uppy-super-focusable": true
        }));
      });
    };
    const _file = this.props.files[this.props.fileCardFor];
    const _metaFields = this.getMetaFields() || [];
    const storedMetaData = {};
    _metaFields.forEach((field) => {
      storedMetaData[field.id] = _file.meta[field.id] || "";
    });
    this.state = {
      formState: storedMetaData
    };
    this.form.id = nanoid$1();
  }
  componentWillMount() {
    this.form.addEventListener("submit", this.handleSave);
    document.body.appendChild(this.form);
  }
  componentWillUnmount() {
    this.form.removeEventListener("submit", this.handleSave);
    document.body.removeChild(this.form);
  }
  getMetaFields() {
    return typeof this.props.metaFields === "function" ? this.props.metaFields(this.props.files[this.props.fileCardFor]) : this.props.metaFields;
  }
  render() {
    const file = this.props.files[this.props.fileCardFor];
    const showEditButton = this.props.canEditFile(file);
    return h$a("div", {
      className: classNames$2("uppy-Dashboard-FileCard", this.props.className),
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h$a("div", {
      className: "uppy-DashboardContent-bar"
    }, h$a("div", {
      className: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "1"
    }, this.props.i18nArray("editing", {
      file: h$a("span", {
        className: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h$a("button", {
      className: "uppy-DashboardContent-back",
      type: "button",
      form: this.form.id,
      title: this.props.i18n("finishEditingFile"),
      onClick: this.handleCancel
    }, this.props.i18n("cancel"))), h$a("div", {
      className: "uppy-Dashboard-FileCard-inner"
    }, h$a("div", {
      className: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h$a(FilePreview2, {
      file
    }), showEditButton && h$a("button", {
      type: "button",
      className: "uppy-u-reset uppy-c-btn uppy-Dashboard-FileCard-edit",
      onClick: (event) => {
        this.handleSave(event);
        this.props.openFileEditor(file);
      },
      form: this.form.id
    }, this.props.i18n("editFile"))), h$a("div", {
      className: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h$a("div", {
      className: "uppy-Dashboard-FileCard-actions"
    }, h$a("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      type: "form" in HTMLButtonElement.prototype ? "submit" : "button",
      onClick: "form" in HTMLButtonElement.prototype ? void 0 : this.handleSave,
      form: this.form.id
    }, this.props.i18n("saveChanges")), h$a("button", {
      className: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onClick: this.handleCancel,
      form: this.form.id
    }, this.props.i18n("cancel")))));
  }
}
var FileCard_1 = FileCard$1;
const {
  cloneElement,
  Component,
  toChildArray
} = require$$1;
const classNames$1 = classnames.exports;
const transitionName = "uppy-transition-slideDownUp";
const duration = 250;
class Slide$1 extends Component {
  constructor(props) {
    super(props);
    this.state = {
      cachedChildren: null,
      className: ""
    };
  }
  componentWillUpdate(nextProps) {
    const {
      cachedChildren
    } = this.state;
    const child = toChildArray(nextProps.children)[0];
    if (cachedChildren === child)
      return null;
    const patch = {
      cachedChildren: child
    };
    if (child && !cachedChildren) {
      patch.className = `${transitionName}-enter`;
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.leaveTimeout);
      this.leaveTimeout = void 0;
      this.animationFrame = requestAnimationFrame(() => {
        this.setState({
          className: `${transitionName}-enter ${transitionName}-enter-active`
        });
        this.enterTimeout = setTimeout(() => {
          this.setState({
            className: ""
          });
        }, duration);
      });
    }
    if (cachedChildren && !child && this.leaveTimeout === void 0) {
      patch.cachedChildren = cachedChildren;
      patch.className = `${transitionName}-leave`;
      cancelAnimationFrame(this.animationFrame);
      clearTimeout(this.enterTimeout);
      this.enterTimeout = void 0;
      this.animationFrame = requestAnimationFrame(() => {
        this.setState({
          className: `${transitionName}-leave ${transitionName}-leave-active`
        });
        this.leaveTimeout = setTimeout(() => {
          this.setState({
            cachedChildren: null,
            className: ""
          });
        }, duration);
      });
    }
    this.setState(patch);
  }
  render() {
    const {
      cachedChildren,
      className
    } = this.state;
    if (!cachedChildren) {
      return null;
    }
    return cloneElement(cachedChildren, {
      className: classNames$1(className, cachedChildren.props.className)
    });
  }
}
var Slide_1 = Slide$1;
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const {
  h: h$9
} = require$$1;
const classNames = classnames.exports;
const isDragDropSupported$2 = isDragDropSupported$3;
const FileList = FileList$1;
const AddFiles = AddFiles_1;
const AddFilesPanel = AddFilesPanel_1;
const PickerPanelContent = PickerPanelContent_1;
const EditorPanel = EditorPanel_1;
const PanelTopBar = PickerPanelTopBar;
const FileCard = FileCard_1;
const Slide = Slide_1;
const WIDTH_XL = 900;
const WIDTH_LG = 700;
const WIDTH_MD = 576;
const HEIGHT_MD = 400;
var Dashboard$1 = function Dashboard(props) {
  const noFiles = props.totalFileCount === 0;
  const isSizeMD = props.containerWidth > WIDTH_MD;
  const wrapperClassName = classNames({
    "uppy-Root": props.isTargetDOMEl
  });
  const dashboardClassName = classNames({
    "uppy-Dashboard": true,
    "uppy-Dashboard--isDisabled": props.disabled,
    "uppy-Dashboard--animateOpenClose": props.animateOpenClose,
    "uppy-Dashboard--isClosing": props.isClosing,
    "uppy-Dashboard--isDraggingOver": props.isDraggingOver,
    "uppy-Dashboard--modal": !props.inline,
    "uppy-size--md": props.containerWidth > WIDTH_MD,
    "uppy-size--lg": props.containerWidth > WIDTH_LG,
    "uppy-size--xl": props.containerWidth > WIDTH_XL,
    "uppy-size--height-md": props.containerHeight > HEIGHT_MD,
    "uppy-Dashboard--isAddFilesPanelVisible": props.showAddFilesPanel,
    "uppy-Dashboard--isInnerWrapVisible": props.areInsidesReadyToBeVisible
  });
  let itemsPerRow = 1;
  if (props.containerWidth > WIDTH_XL) {
    itemsPerRow = 5;
  } else if (props.containerWidth > WIDTH_LG) {
    itemsPerRow = 4;
  } else if (props.containerWidth > WIDTH_MD) {
    itemsPerRow = 3;
  }
  const showFileList = props.showSelectedFiles && !noFiles;
  const numberOfFilesForRecovery = props.recoveredState ? Object.keys(props.recoveredState.files).length : null;
  const numberOfGhosts = props.files ? Object.keys(props.files).filter((fileID) => props.files[fileID].isGhost).length : null;
  const renderRestoredText = () => {
    if (numberOfGhosts > 0) {
      return props.i18n("recoveredXFiles", {
        smart_count: numberOfGhosts
      });
    }
    return props.i18n("recoveredAllFiles");
  };
  const dashboard2 = h$9("div", {
    className: dashboardClassName,
    "data-uppy-theme": props.theme,
    "data-uppy-num-acquirers": props.acquirers.length,
    "data-uppy-drag-drop-supported": !props.disableLocalFiles && isDragDropSupported$2(),
    "aria-hidden": props.inline ? "false" : props.isHidden,
    "aria-disabled": props.disabled,
    "aria-label": !props.inline ? props.i18n("dashboardWindowTitle") : props.i18n("dashboardTitle"),
    onPaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h$9("div", {
    "aria-hidden": "true",
    className: "uppy-Dashboard-overlay",
    tabIndex: -1,
    onClick: props.handleClickOutside
  }), h$9("div", {
    className: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && "true",
    role: !props.inline && "dialog",
    style: {
      width: props.inline && props.width ? props.width : "",
      height: props.inline && props.height ? props.height : ""
    }
  }, !props.inline ? h$9("button", {
    className: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n("closeModal"),
    title: props.i18n("closeModal"),
    onClick: props.closeModal
  }, h$9("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h$9("div", {
    className: "uppy-Dashboard-innerWrap"
  }, h$9("div", {
    className: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n("dropHint")), showFileList && h$9(PanelTopBar, props), numberOfFilesForRecovery && h$9("div", {
    className: "uppy-Dashboard-serviceMsg"
  }, h$9("svg", {
    className: "uppy-Dashboard-serviceMsg-icon",
    "aria-hidden": "true",
    focusable: "false",
    width: "21",
    height: "16",
    viewBox: "0 0 24 19"
  }, h$9("g", {
    transform: "translate(0 -1)",
    fill: "none",
    fillRule: "evenodd"
  }, h$9("path", {
    d: "M12.857 1.43l10.234 17.056A1 1 0 0122.234 20H1.766a1 1 0 01-.857-1.514L11.143 1.429a1 1 0 011.714 0z",
    fill: "#FFD300"
  }), h$9("path", {
    fill: "#000",
    d: "M11 6h2l-.3 8h-1.4z"
  }), h$9("circle", {
    fill: "#000",
    cx: "12",
    cy: "17",
    r: "1"
  }))), h$9("strong", {
    className: "uppy-Dashboard-serviceMsg-title"
  }, props.i18n("sessionRestored")), h$9("div", {
    className: "uppy-Dashboard-serviceMsg-text"
  }, renderRestoredText())), showFileList ? h$9(FileList, _extends$1({}, props, {
    itemsPerRow
  })) : h$9(AddFiles, _extends$1({}, props, {
    isSizeMD
  })), h$9(Slide, null, props.showAddFilesPanel ? h$9(AddFilesPanel, _extends$1({
    key: "AddFiles"
  }, props, {
    isSizeMD
  })) : null), h$9(Slide, null, props.fileCardFor ? h$9(FileCard, _extends$1({
    key: "FileCard"
  }, props)) : null), h$9(Slide, null, props.activePickerPanel ? h$9(PickerPanelContent, _extends$1({
    key: "Picker"
  }, props)) : null), h$9(Slide, null, props.showFileEditor ? h$9(EditorPanel, _extends$1({
    key: "Editor"
  }, props)) : null), h$9("div", {
    className: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map((target) => {
    return props.uppy.getPlugin(target.id).render(props.state);
  })))));
  return h$9("div", {
    className: wrapperClassName,
    dir: props.direction
  }, dashboard2);
};
var locale$7 = {
  strings: {
    closeModal: "Close Modal",
    addMoreFiles: "Add more files",
    addingMoreFiles: "Adding more files",
    importFrom: "Import from %{name}",
    dashboardWindowTitle: "Uppy Dashboard Window (Press escape to close)",
    dashboardTitle: "Uppy Dashboard",
    copyLinkToClipboardSuccess: "Link copied to clipboard.",
    copyLinkToClipboardFallback: "Copy the URL below",
    copyLink: "Copy link",
    back: "Back",
    removeFile: "Remove file",
    editFile: "Edit file",
    editing: "Editing %{file}",
    finishEditingFile: "Finish editing file",
    saveChanges: "Save changes",
    myDevice: "My Device",
    dropHint: "Drop your files here",
    uploadComplete: "Upload complete",
    uploadPaused: "Upload paused",
    resumeUpload: "Resume upload",
    pauseUpload: "Pause upload",
    retryUpload: "Retry upload",
    cancelUpload: "Cancel upload",
    xFilesSelected: {
      0: "%{smart_count} file selected",
      1: "%{smart_count} files selected"
    },
    uploadingXFiles: {
      0: "Uploading %{smart_count} file",
      1: "Uploading %{smart_count} files"
    },
    processingXFiles: {
      0: "Processing %{smart_count} file",
      1: "Processing %{smart_count} files"
    },
    poweredBy: "Powered by %{uppy}",
    addMore: "Add more",
    editFileWithFilename: "Edit file %{file}",
    save: "Save",
    cancel: "Cancel",
    dropPasteFiles: "Drop files here or %{browseFiles}",
    dropPasteFolders: "Drop files here or %{browseFolders}",
    dropPasteBoth: "Drop files here, %{browseFiles} or %{browseFolders}",
    dropPasteImportFiles: "Drop files here, %{browseFiles} or import from:",
    dropPasteImportFolders: "Drop files here, %{browseFolders} or import from:",
    dropPasteImportBoth: "Drop files here, %{browseFiles}, %{browseFolders} or import from:",
    importFiles: "Import files from:",
    browseFiles: "browse files",
    browseFolders: "browse folders",
    recoveredXFiles: {
      0: "We could not fully recover 1 file. Please re-select it and resume the upload.",
      1: "We could not fully recover %{smart_count} files. Please re-select them and resume the upload."
    },
    recoveredAllFiles: "We restored all files. You can now resume the upload.",
    sessionRestored: "Session restored",
    reSelect: "Re-select",
    missingRequiredMetaFields: {
      0: "Missing required meta field: %{fields}.",
      1: "Missing required meta fields: %{fields}."
    }
  }
};
var _class$2, _openFileEditorWhenFilesAdded, _attachRenderFunctionToTarget, _isTargetSupported, _getAcquirers, _getProgressIndicators, _getEditors, _temp$2;
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}
const {
  h: h$8
} = require$$1;
const {
  UIPlugin: UIPlugin$2
} = lib$a.exports;
const StatusBar$1 = lib$6;
const Informer2 = lib$5;
const ThumbnailGenerator2 = lib$4;
const findAllDOMElements2 = findAllDOMElements$1;
const toArray$5 = toArray$9;
const getDroppedFiles$2 = getDroppedFiles$3;
const getTextDirection = getTextDirection_1;
const {
  nanoid
} = require$$9;
const trapFocus = trapFocus_1;
const createSuperFocus2 = createSuperFocus$1;
const memoize = require$$12.default || require$$12;
const FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS$3;
const DashboardUI = Dashboard$1;
const locale$6 = locale$7;
const TAB_KEY = 9;
const ESC_KEY = 27;
function createPromise() {
  const o2 = {};
  o2.promise = new Promise((resolve, reject) => {
    o2.resolve = resolve;
    o2.reject = reject;
  });
  return o2;
}
function defaultPickerIcon() {
  return h$8("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h$8("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}
var lib$3 = (_temp$2 = (_openFileEditorWhenFilesAdded = /* @__PURE__ */ _classPrivateFieldLooseKey("openFileEditorWhenFilesAdded"), _attachRenderFunctionToTarget = /* @__PURE__ */ _classPrivateFieldLooseKey("attachRenderFunctionToTarget"), _isTargetSupported = /* @__PURE__ */ _classPrivateFieldLooseKey("isTargetSupported"), _getAcquirers = /* @__PURE__ */ _classPrivateFieldLooseKey("getAcquirers"), _getProgressIndicators = /* @__PURE__ */ _classPrivateFieldLooseKey("getProgressIndicators"), _getEditors = /* @__PURE__ */ _classPrivateFieldLooseKey("getEditors"), _class$2 = class Dashboard2 extends UIPlugin$2 {
  constructor(uppy2, _opts) {
    var _this;
    super(uppy2, _opts);
    _this = this;
    this.removeTarget = (plugin) => {
      const pluginState = this.getPluginState();
      const newTargets = pluginState.targets.filter((target) => target.id !== plugin.id);
      this.setPluginState({
        targets: newTargets
      });
    };
    this.addTarget = (plugin) => {
      const callerPluginId = plugin.id || plugin.constructor.name;
      const callerPluginName = plugin.title || callerPluginId;
      const callerPluginType = plugin.type;
      if (callerPluginType !== "acquirer" && callerPluginType !== "progressindicator" && callerPluginType !== "editor") {
        const msg = "Dashboard: can only be targeted by plugins of types: acquirer, progressindicator, editor";
        this.uppy.log(msg, "error");
        return;
      }
      const target = {
        id: callerPluginId,
        name: callerPluginName,
        type: callerPluginType
      };
      const state = this.getPluginState();
      const newTargets = state.targets.slice();
      newTargets.push(target);
      this.setPluginState({
        targets: newTargets
      });
      return this.el;
    };
    this.hideAllPanels = () => {
      const state = this.getPluginState();
      const update = {
        activePickerPanel: false,
        showAddFilesPanel: false,
        activeOverlayType: null,
        fileCardFor: null,
        showFileEditor: false
      };
      if (state.activePickerPanel === update.activePickerPanel && state.showAddFilesPanel === update.showAddFilesPanel && state.showFileEditor === update.showFileEditor && state.activeOverlayType === update.activeOverlayType) {
        return;
      }
      this.setPluginState(update);
    };
    this.showPanel = (id2) => {
      const {
        targets
      } = this.getPluginState();
      const activePickerPanel = targets.filter((target) => {
        return target.type === "acquirer" && target.id === id2;
      })[0];
      this.setPluginState({
        activePickerPanel,
        activeOverlayType: "PickerPanel"
      });
    };
    this.canEditFile = (file) => {
      const {
        targets
      } = this.getPluginState();
      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
      return editors.some((target) => this.uppy.getPlugin(target.id).canEditFile(file));
    };
    this.openFileEditor = (file) => {
      const {
        targets
      } = this.getPluginState();
      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
      this.setPluginState({
        showFileEditor: true,
        fileCardFor: file.id || null,
        activeOverlayType: "FileEditor"
      });
      editors.forEach((editor) => {
        this.uppy.getPlugin(editor.id).selectFile(file);
      });
    };
    this.saveFileEditor = () => {
      const {
        targets
      } = this.getPluginState();
      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](targets);
      editors.forEach((editor) => {
        this.uppy.getPlugin(editor.id).save();
      });
      this.hideAllPanels();
    };
    this.openModal = () => {
      const {
        promise,
        resolve
      } = createPromise();
      this.savedScrollPosition = window.pageYOffset;
      this.savedActiveElement = document.activeElement;
      if (this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.add("uppy-Dashboard-isFixed");
      }
      if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
        const handler = () => {
          this.setPluginState({
            isHidden: false
          });
          this.el.removeEventListener("animationend", handler, false);
          resolve();
        };
        this.el.addEventListener("animationend", handler, false);
      } else {
        this.setPluginState({
          isHidden: false
        });
        resolve();
      }
      if (this.opts.browserBackButtonClose) {
        this.updateBrowserHistory();
      }
      document.addEventListener("keydown", this.handleKeyDownInModal);
      this.uppy.emit("dashboard:modal-open");
      return promise;
    };
    this.closeModal = function(opts) {
      if (opts === void 0) {
        opts = {};
      }
      const {
        manualClose = true
      } = opts;
      const {
        isHidden: isHidden2,
        isClosing
      } = _this.getPluginState();
      if (isHidden2 || isClosing) {
        return;
      }
      const {
        promise,
        resolve
      } = createPromise();
      if (_this.opts.disablePageScrollWhenModalOpen) {
        document.body.classList.remove("uppy-Dashboard-isFixed");
      }
      if (_this.opts.animateOpenClose) {
        _this.setPluginState({
          isClosing: true
        });
        const handler = () => {
          _this.setPluginState({
            isHidden: true,
            isClosing: false
          });
          _this.superFocus.cancel();
          _this.savedActiveElement.focus();
          _this.el.removeEventListener("animationend", handler, false);
          resolve();
        };
        _this.el.addEventListener("animationend", handler, false);
      } else {
        _this.setPluginState({
          isHidden: true
        });
        _this.superFocus.cancel();
        _this.savedActiveElement.focus();
        resolve();
      }
      document.removeEventListener("keydown", _this.handleKeyDownInModal);
      if (manualClose) {
        if (_this.opts.browserBackButtonClose) {
          var _history$state;
          if ((_history$state = history.state) != null && _history$state[_this.modalName]) {
            history.back();
          }
        }
      }
      _this.uppy.emit("dashboard:modal-closed");
      return promise;
    };
    this.isModalOpen = () => {
      return !this.getPluginState().isHidden || false;
    };
    this.requestCloseModal = () => {
      if (this.opts.onRequestCloseModal) {
        return this.opts.onRequestCloseModal();
      }
      return this.closeModal();
    };
    this.setDarkModeCapability = (isDarkModeOn) => {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: __spreadProps(__spreadValues({}, capabilities), {
          darkMode: isDarkModeOn
        })
      });
    };
    this.handleSystemDarkModeChange = (event) => {
      const isDarkModeOnNow = event.matches;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnNow ? "on" : "off"}`);
      this.setDarkModeCapability(isDarkModeOnNow);
    };
    this.toggleFileCard = (show, fileID) => {
      const file = this.uppy.getFile(fileID);
      if (show) {
        this.uppy.emit("dashboard:file-edit-start", file);
      } else {
        this.uppy.emit("dashboard:file-edit-complete", file);
      }
      this.setPluginState({
        fileCardFor: show ? fileID : null,
        activeOverlayType: show ? "FileCard" : null
      });
    };
    this.toggleAddFilesPanel = (show) => {
      this.setPluginState({
        showAddFilesPanel: show,
        activeOverlayType: show ? "AddFiles" : null
      });
    };
    this.addFiles = (files) => {
      const descriptors = files.map((file) => ({
        source: this.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          relativePath: file.relativePath || null
        }
      }));
      try {
        this.uppy.addFiles(descriptors);
      } catch (err) {
        this.uppy.log(err);
      }
    };
    this.startListeningToResize = () => {
      this.resizeObserver = new ResizeObserver((entries) => {
        const uppyDashboardInnerEl = entries[0];
        const {
          width,
          height
        } = uppyDashboardInnerEl.contentRect;
        this.uppy.log(`[Dashboard] resized: ${width} / ${height}`, "debug");
        this.setPluginState({
          containerWidth: width,
          containerHeight: height,
          areInsidesReadyToBeVisible: true
        });
      });
      this.resizeObserver.observe(this.el.querySelector(".uppy-Dashboard-inner"));
      this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(() => {
        const pluginState = this.getPluginState();
        const isModalAndClosed = !this.opts.inline && pluginState.isHidden;
        if (!pluginState.areInsidesReadyToBeVisible && !isModalAndClosed) {
          this.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", "debug");
          this.setPluginState({
            areInsidesReadyToBeVisible: true
          });
        }
      }, 1e3);
    };
    this.stopListeningToResize = () => {
      this.resizeObserver.disconnect();
      clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
    };
    this.recordIfFocusedOnUppyRecently = (event) => {
      if (this.el.contains(event.target)) {
        this.ifFocusedOnUppyRecently = true;
      } else {
        this.ifFocusedOnUppyRecently = false;
        this.superFocus.cancel();
      }
    };
    this.disableAllFocusableElements = (disable) => {
      const focusableNodes = toArray$5(this.el.querySelectorAll(FOCUSABLE_ELEMENTS));
      if (disable) {
        focusableNodes.forEach((node) => {
          const currentTabIndex = node.getAttribute("tabindex");
          if (currentTabIndex) {
            node.dataset.inertTabindex = currentTabIndex;
          }
          node.setAttribute("tabindex", "-1");
        });
      } else {
        focusableNodes.forEach((node) => {
          if ("inertTabindex" in node.dataset) {
            node.setAttribute("tabindex", node.dataset.inertTabindex);
          } else {
            node.removeAttribute("tabindex");
          }
        });
      }
      this.dashboardIsDisabled = disable;
    };
    this.updateBrowserHistory = () => {
      var _history$state2;
      if (!((_history$state2 = history.state) != null && _history$state2[this.modalName])) {
        history.pushState(__spreadProps(__spreadValues({}, history.state), {
          [this.modalName]: true
        }), "");
      }
      window.addEventListener("popstate", this.handlePopState, false);
    };
    this.handlePopState = (event) => {
      var _event$state;
      if (this.isModalOpen() && (!event.state || !event.state[this.modalName])) {
        this.closeModal({
          manualClose: false
        });
      }
      if (!this.isModalOpen() && (_event$state = event.state) != null && _event$state[this.modalName]) {
        history.back();
      }
    };
    this.handleKeyDownInModal = (event) => {
      if (event.keyCode === ESC_KEY)
        this.requestCloseModal(event);
      if (event.keyCode === TAB_KEY)
        trapFocus.forModal(event, this.getPluginState().activeOverlayType, this.el);
    };
    this.handleClickOutside = () => {
      if (this.opts.closeModalOnClickOutside)
        this.requestCloseModal();
    };
    this.handlePaste = (event) => {
      this.uppy.iteratePlugins((plugin) => {
        if (plugin.type === "acquirer") {
          plugin.handleRootPaste == null ? void 0 : plugin.handleRootPaste(event);
        }
      });
      const files = toArray$5(event.clipboardData.files);
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files pasted");
        this.addFiles(files);
      }
    };
    this.handleInputChange = (event) => {
      event.preventDefault();
      const files = toArray$5(event.target.files);
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files selected through input");
        this.addFiles(files);
      }
    };
    this.handleDragOver = (event) => {
      var _this$opts$onDragOver, _this$opts;
      event.preventDefault();
      event.stopPropagation();
      const canSomePluginHandleRootDrop = () => {
        let somePluginCanHandleRootDrop2 = true;
        this.uppy.iteratePlugins((plugin) => {
          if (plugin.canHandleRootDrop != null && plugin.canHandleRootDrop(event)) {
            somePluginCanHandleRootDrop2 = true;
          }
        });
        return somePluginCanHandleRootDrop2;
      };
      const doesEventHaveFiles = () => {
        const {
          types
        } = event.dataTransfer;
        return types.some((type) => type === "Files");
      };
      const somePluginCanHandleRootDrop = canSomePluginHandleRootDrop();
      const hasFiles = doesEventHaveFiles();
      if (!somePluginCanHandleRootDrop && !hasFiles || this.opts.disabled || this.opts.disableLocalFiles && (hasFiles || !somePluginCanHandleRootDrop) || !this.uppy.getState().allowNewUpload) {
        event.dataTransfer.dropEffect = "none";
        clearTimeout(this.removeDragOverClassTimeout);
        return;
      }
      event.dataTransfer.dropEffect = "copy";
      clearTimeout(this.removeDragOverClassTimeout);
      this.setPluginState({
        isDraggingOver: true
      });
      (_this$opts$onDragOver = (_this$opts = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts, event);
    };
    this.handleDragLeave = (event) => {
      var _this$opts$onDragLeav, _this$opts2;
      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout);
      this.removeDragOverClassTimeout = setTimeout(() => {
        this.setPluginState({
          isDraggingOver: false
        });
      }, 50);
      (_this$opts$onDragLeav = (_this$opts2 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts2, event);
    };
    this.handleDrop = async (event) => {
      var _this$opts$onDrop, _this$opts3;
      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout);
      this.setPluginState({
        isDraggingOver: false
      });
      this.uppy.iteratePlugins((plugin) => {
        if (plugin.type === "acquirer") {
          plugin.handleRootDrop == null ? void 0 : plugin.handleRootDrop(event);
        }
      });
      let executedDropErrorOnce = false;
      const logDropError = (error) => {
        this.uppy.log(error, "error");
        if (!executedDropErrorOnce) {
          this.uppy.info(error.message, "error");
          executedDropErrorOnce = true;
        }
      };
      const files = await getDroppedFiles$2(event.dataTransfer, {
        logDropError
      });
      if (files.length > 0) {
        this.uppy.log("[Dashboard] Files dropped");
        this.addFiles(files);
      }
      (_this$opts$onDrop = (_this$opts3 = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts3, event);
    };
    this.handleRequestThumbnail = (file) => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit("thumbnail:request", file);
      }
    };
    this.handleCancelThumbnail = (file) => {
      if (!this.opts.waitForThumbnailsBeforeUpload) {
        this.uppy.emit("thumbnail:cancel", file);
      }
    };
    this.handleKeyDownInInline = (event) => {
      if (event.keyCode === TAB_KEY)
        trapFocus.forInline(event, this.getPluginState().activeOverlayType, this.el);
    };
    this.handlePasteOnBody = (event) => {
      const isFocusInOverlay2 = this.el.contains(document.activeElement);
      if (isFocusInOverlay2) {
        this.handlePaste(event);
      }
    };
    this.handleComplete = (_ref) => {
      let {
        failed
      } = _ref;
      if (this.opts.closeAfterFinish && failed.length === 0) {
        this.requestCloseModal();
      }
    };
    this.handleCancelRestore = () => {
      this.uppy.emit("restore-canceled");
    };
    Object.defineProperty(this, _openFileEditorWhenFilesAdded, {
      writable: true,
      value: (files) => {
        const firstFile = files[0];
        if (this.canEditFile(firstFile)) {
          this.openFileEditor(firstFile);
        }
      }
    });
    this.initEvents = () => {
      if (this.opts.trigger && !this.opts.inline) {
        const showModalTrigger = findAllDOMElements2(this.opts.trigger);
        if (showModalTrigger) {
          showModalTrigger.forEach((trigger) => trigger.addEventListener("click", this.openModal));
        } else {
          this.uppy.log("Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options, unless you are planning to call `dashboard.openModal()` method yourself", "warning");
        }
      }
      this.startListeningToResize();
      document.addEventListener("paste", this.handlePasteOnBody);
      this.uppy.on("plugin-remove", this.removeTarget);
      this.uppy.on("file-added", this.hideAllPanels);
      this.uppy.on("dashboard:modal-closed", this.hideAllPanels);
      this.uppy.on("file-editor:complete", this.hideAllPanels);
      this.uppy.on("complete", this.handleComplete);
      document.addEventListener("focus", this.recordIfFocusedOnUppyRecently, true);
      document.addEventListener("click", this.recordIfFocusedOnUppyRecently, true);
      if (this.opts.inline) {
        this.el.addEventListener("keydown", this.handleKeyDownInInline);
      }
      if (this.opts.autoOpenFileEditor) {
        this.uppy.on("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
      }
    };
    this.removeEvents = () => {
      const showModalTrigger = findAllDOMElements2(this.opts.trigger);
      if (!this.opts.inline && showModalTrigger) {
        showModalTrigger.forEach((trigger) => trigger.removeEventListener("click", this.openModal));
      }
      this.stopListeningToResize();
      document.removeEventListener("paste", this.handlePasteOnBody);
      window.removeEventListener("popstate", this.handlePopState, false);
      this.uppy.off("plugin-remove", this.removeTarget);
      this.uppy.off("file-added", this.hideAllPanels);
      this.uppy.off("dashboard:modal-closed", this.hideAllPanels);
      this.uppy.off("file-editor:complete", this.hideAllPanels);
      this.uppy.off("complete", this.handleComplete);
      document.removeEventListener("focus", this.recordIfFocusedOnUppyRecently);
      document.removeEventListener("click", this.recordIfFocusedOnUppyRecently);
      if (this.opts.inline) {
        this.el.removeEventListener("keydown", this.handleKeyDownInInline);
      }
      if (this.opts.autoOpenFileEditor) {
        this.uppy.off("files-added", _classPrivateFieldLooseBase(this, _openFileEditorWhenFilesAdded)[_openFileEditorWhenFilesAdded]);
      }
    };
    this.superFocusOnEachUpdate = () => {
      const isFocusInUppy = this.el.contains(document.activeElement);
      const isFocusNowhere = document.activeElement === document.body || document.activeElement === null;
      const isInformerHidden = this.uppy.getState().info.length === 0;
      const isModal = !this.opts.inline;
      if (isInformerHidden && (isModal || isFocusInUppy || isFocusNowhere && this.ifFocusedOnUppyRecently)) {
        this.superFocus(this.el, this.getPluginState().activeOverlayType);
      } else {
        this.superFocus.cancel();
      }
    };
    this.afterUpdate = () => {
      if (this.opts.disabled && !this.dashboardIsDisabled) {
        this.disableAllFocusableElements(true);
        return;
      }
      if (!this.opts.disabled && this.dashboardIsDisabled) {
        this.disableAllFocusableElements(false);
      }
      this.superFocusOnEachUpdate();
    };
    this.saveFileCard = (meta, fileID) => {
      this.uppy.setFileMeta(fileID, meta);
      this.toggleFileCard(false, fileID);
    };
    Object.defineProperty(this, _attachRenderFunctionToTarget, {
      writable: true,
      value: (target) => {
        const plugin = this.uppy.getPlugin(target.id);
        return __spreadProps(__spreadValues({}, target), {
          icon: plugin.icon || this.opts.defaultPickerIcon,
          render: plugin.render
        });
      }
    });
    Object.defineProperty(this, _isTargetSupported, {
      writable: true,
      value: (target) => {
        const plugin = this.uppy.getPlugin(target.id);
        if (typeof plugin.isSupported !== "function") {
          return true;
        }
        return plugin.isSupported();
      }
    });
    Object.defineProperty(this, _getAcquirers, {
      writable: true,
      value: memoize((targets) => {
        return targets.filter((target) => target.type === "acquirer" && _classPrivateFieldLooseBase(this, _isTargetSupported)[_isTargetSupported](target)).map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });
    Object.defineProperty(this, _getProgressIndicators, {
      writable: true,
      value: memoize((targets) => {
        return targets.filter((target) => target.type === "progressindicator").map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });
    Object.defineProperty(this, _getEditors, {
      writable: true,
      value: memoize((targets) => {
        return targets.filter((target) => target.type === "editor").map(_classPrivateFieldLooseBase(this, _attachRenderFunctionToTarget)[_attachRenderFunctionToTarget]);
      })
    });
    this.render = (state) => {
      const pluginState = this.getPluginState();
      const {
        files,
        capabilities,
        allowNewUpload
      } = state;
      const {
        newFiles,
        uploadStartedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted,
        isAllComplete,
        isAllErrored,
        isAllPaused
      } = this.uppy.getObjectOfFilesPerState();
      const acquirers = _classPrivateFieldLooseBase(this, _getAcquirers)[_getAcquirers](pluginState.targets);
      const progressindicators = _classPrivateFieldLooseBase(this, _getProgressIndicators)[_getProgressIndicators](pluginState.targets);
      const editors = _classPrivateFieldLooseBase(this, _getEditors)[_getEditors](pluginState.targets);
      let theme;
      if (this.opts.theme === "auto") {
        theme = capabilities.darkMode ? "dark" : "light";
      } else {
        theme = this.opts.theme;
      }
      if (["files", "folders", "both"].indexOf(this.opts.fileManagerSelectionType) < 0) {
        this.opts.fileManagerSelectionType = "files";
        console.warn(`Unsupported option for "fileManagerSelectionType". Using default of "${this.opts.fileManagerSelectionType}".`);
      }
      return DashboardUI({
        state,
        isHidden: pluginState.isHidden,
        files,
        newFiles,
        uploadStartedFiles,
        completeFiles,
        erroredFiles,
        inProgressFiles,
        inProgressNotPausedFiles,
        processingFiles,
        isUploadStarted,
        isAllComplete,
        isAllErrored,
        isAllPaused,
        totalFileCount: Object.keys(files).length,
        totalProgress: state.totalProgress,
        allowNewUpload,
        acquirers,
        theme,
        disabled: this.opts.disabled,
        disableLocalFiles: this.opts.disableLocalFiles,
        direction: this.opts.direction,
        activePickerPanel: pluginState.activePickerPanel,
        showFileEditor: pluginState.showFileEditor,
        saveFileEditor: this.saveFileEditor,
        disableAllFocusableElements: this.disableAllFocusableElements,
        animateOpenClose: this.opts.animateOpenClose,
        isClosing: pluginState.isClosing,
        progressindicators,
        editors,
        autoProceed: this.uppy.opts.autoProceed,
        id: this.id,
        closeModal: this.requestCloseModal,
        handleClickOutside: this.handleClickOutside,
        handleInputChange: this.handleInputChange,
        handlePaste: this.handlePaste,
        inline: this.opts.inline,
        showPanel: this.showPanel,
        hideAllPanels: this.hideAllPanels,
        i18n: this.i18n,
        i18nArray: this.i18nArray,
        uppy: this.uppy,
        note: this.opts.note,
        recoveredState: state.recoveredState,
        metaFields: pluginState.metaFields,
        resumableUploads: capabilities.resumableUploads || false,
        individualCancellation: capabilities.individualCancellation,
        isMobileDevice: capabilities.isMobileDevice,
        fileCardFor: pluginState.fileCardFor,
        toggleFileCard: this.toggleFileCard,
        toggleAddFilesPanel: this.toggleAddFilesPanel,
        showAddFilesPanel: pluginState.showAddFilesPanel,
        saveFileCard: this.saveFileCard,
        openFileEditor: this.openFileEditor,
        canEditFile: this.canEditFile,
        width: this.opts.width,
        height: this.opts.height,
        showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
        fileManagerSelectionType: this.opts.fileManagerSelectionType,
        proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
        hideCancelButton: this.opts.hideCancelButton,
        hideRetryButton: this.opts.hideRetryButton,
        hidePauseResumeButton: this.opts.hidePauseResumeButton,
        showRemoveButtonAfterComplete: this.opts.showRemoveButtonAfterComplete,
        containerWidth: pluginState.containerWidth,
        containerHeight: pluginState.containerHeight,
        areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
        isTargetDOMEl: this.isTargetDOMEl,
        parentElement: this.el,
        allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
        maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
        requiredMetaFields: this.uppy.opts.restrictions.requiredMetaFields,
        showSelectedFiles: this.opts.showSelectedFiles,
        handleCancelRestore: this.handleCancelRestore,
        handleRequestThumbnail: this.handleRequestThumbnail,
        handleCancelThumbnail: this.handleCancelThumbnail,
        isDraggingOver: pluginState.isDraggingOver,
        handleDragOver: this.handleDragOver,
        handleDragLeave: this.handleDragLeave,
        handleDrop: this.handleDrop
      });
    };
    this.discoverProviderPlugins = () => {
      this.uppy.iteratePlugins((plugin) => {
        if (plugin && !plugin.target && plugin.opts && plugin.opts.target === this.constructor) {
          this.addTarget(plugin);
        }
      });
    };
    this.install = () => {
      this.setPluginState({
        isHidden: true,
        fileCardFor: null,
        activeOverlayType: null,
        showAddFilesPanel: false,
        activePickerPanel: false,
        showFileEditor: false,
        metaFields: this.opts.metaFields,
        targets: [],
        areInsidesReadyToBeVisible: false,
        isDraggingOver: false
      });
      const {
        inline,
        closeAfterFinish
      } = this.opts;
      if (inline && closeAfterFinish) {
        throw new Error("[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.");
      }
      const {
        allowMultipleUploads,
        allowMultipleUploadBatches
      } = this.uppy.opts;
      if ((allowMultipleUploads || allowMultipleUploadBatches) && closeAfterFinish) {
        this.uppy.log("[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploadBatches` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true", "warning");
      }
      const {
        target
      } = this.opts;
      if (target) {
        this.mount(target, this);
      }
      const plugins2 = this.opts.plugins || [];
      plugins2.forEach((pluginID) => {
        const plugin = this.uppy.getPlugin(pluginID);
        if (plugin) {
          plugin.mount(this, plugin);
        }
      });
      if (!this.opts.disableStatusBar) {
        this.uppy.use(StatusBar$1, {
          id: `${this.id}:StatusBar`,
          target: this,
          hideUploadButton: this.opts.hideUploadButton,
          hideRetryButton: this.opts.hideRetryButton,
          hidePauseResumeButton: this.opts.hidePauseResumeButton,
          hideCancelButton: this.opts.hideCancelButton,
          showProgressDetails: this.opts.showProgressDetails,
          hideAfterFinish: this.opts.hideProgressAfterFinish,
          locale: this.opts.locale,
          doneButtonHandler: this.opts.doneButtonHandler
        });
      }
      if (!this.opts.disableInformer) {
        this.uppy.use(Informer2, {
          id: `${this.id}:Informer`,
          target: this
        });
      }
      if (!this.opts.disableThumbnailGenerator) {
        this.uppy.use(ThumbnailGenerator2, {
          id: `${this.id}:ThumbnailGenerator`,
          thumbnailWidth: this.opts.thumbnailWidth,
          thumbnailHeight: this.opts.thumbnailHeight,
          thumbnailType: this.opts.thumbnailType,
          waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload,
          lazy: !this.opts.waitForThumbnailsBeforeUpload
        });
      }
      this.darkModeMediaQuery = typeof window !== "undefined" && window.matchMedia ? window.matchMedia("(prefers-color-scheme: dark)") : null;
      const isDarkModeOnFromTheStart = this.darkModeMediaQuery ? this.darkModeMediaQuery.matches : false;
      this.uppy.log(`[Dashboard] Dark mode is ${isDarkModeOnFromTheStart ? "on" : "off"}`);
      this.setDarkModeCapability(isDarkModeOnFromTheStart);
      if (this.opts.theme === "auto") {
        this.darkModeMediaQuery.addListener(this.handleSystemDarkModeChange);
      }
      this.discoverProviderPlugins();
      this.initEvents();
    };
    this.uninstall = () => {
      if (!this.opts.disableInformer) {
        const informer = this.uppy.getPlugin(`${this.id}:Informer`);
        if (informer)
          this.uppy.removePlugin(informer);
      }
      if (!this.opts.disableStatusBar) {
        const statusBar = this.uppy.getPlugin(`${this.id}:StatusBar`);
        if (statusBar)
          this.uppy.removePlugin(statusBar);
      }
      if (!this.opts.disableThumbnailGenerator) {
        const thumbnail = this.uppy.getPlugin(`${this.id}:ThumbnailGenerator`);
        if (thumbnail)
          this.uppy.removePlugin(thumbnail);
      }
      const plugins2 = this.opts.plugins || [];
      plugins2.forEach((pluginID) => {
        const plugin = this.uppy.getPlugin(pluginID);
        if (plugin)
          plugin.unmount();
      });
      if (this.opts.theme === "auto") {
        this.darkModeMediaQuery.removeListener(this.handleSystemDarkModeChange);
      }
      this.unmount();
      this.removeEvents();
    };
    this.id = this.opts.id || "Dashboard";
    this.title = "Dashboard";
    this.type = "orchestrator";
    this.modalName = `uppy-Dashboard-${nanoid()}`;
    this.defaultLocale = locale$6;
    const defaultOptions2 = {
      target: "body",
      metaFields: [],
      trigger: null,
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      thumbnailType: "image/jpeg",
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon,
      showLinkToFileUploadResult: false,
      showProgressDetails: false,
      hideUploadButton: false,
      hideCancelButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideProgressAfterFinish: false,
      doneButtonHandler: () => {
        this.uppy.reset();
        this.requestCloseModal();
      },
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      fileManagerSelectionType: "files",
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: () => this.closeModal(),
      showSelectedFiles: true,
      showRemoveButtonAfterComplete: false,
      browserBackButtonClose: false,
      theme: "light",
      autoOpenFileEditor: false,
      disabled: false,
      disableLocalFiles: false
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), _opts);
    this.i18nInit();
    this.superFocus = createSuperFocus2();
    this.ifFocusedOnUppyRecently = false;
    this.makeDashboardInsidesVisibleAnywayTimeout = null;
    this.removeDragOverClassTimeout = null;
  }
  onMount() {
    const element = this.el;
    const direction = getTextDirection(element);
    if (!direction) {
      element.dir = "ltr";
    }
  }
}), _class$2.VERSION = "2.1.4", _temp$2);
const PropTypes$4 = propTypes$3.exports;
const UppyCore = lib$a.exports.Uppy;
const uppy = PropTypes$4.instanceOf(UppyCore).isRequired;
const plugins = PropTypes$4.arrayOf(PropTypes$4.string);
const locale$5 = PropTypes$4.shape({
  strings: PropTypes$4.object,
  pluralize: PropTypes$4.func
});
const metaField = PropTypes$4.shape({
  id: PropTypes$4.string.isRequired,
  name: PropTypes$4.string.isRequired,
  placeholder: PropTypes$4.string
});
const metaFields = PropTypes$4.oneOfType([PropTypes$4.arrayOf(metaField), PropTypes$4.func]);
const cssSize = PropTypes$4.oneOfType([PropTypes$4.string, PropTypes$4.number]);
const dashboard = {
  uppy,
  inline: PropTypes$4.bool,
  plugins,
  width: cssSize,
  height: cssSize,
  showProgressDetails: PropTypes$4.bool,
  hideUploadButton: PropTypes$4.bool,
  hideProgressAfterFinish: PropTypes$4.bool,
  note: PropTypes$4.string,
  metaFields,
  proudlyDisplayPoweredByUppy: PropTypes$4.bool,
  disableStatusBar: PropTypes$4.bool,
  disableInformer: PropTypes$4.bool,
  disableThumbnailGenerator: PropTypes$4.bool,
  thumbnailWidth: PropTypes$4.number,
  locale: locale$5
};
var propTypes$2 = {
  uppy,
  locale: locale$5,
  dashboard
};
const reactSupportedHtmlAttr = [
  "defaultChecked",
  "defaultValue",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "dangerouslySetInnerHTML",
  "accessKey",
  "className",
  "contentEditable",
  "contextMenu",
  "dir",
  "draggable",
  "hidden",
  "id",
  "lang",
  "placeholder",
  "slot",
  "spellCheck",
  "style",
  "tabIndex",
  "title",
  "translate",
  "radioGroup",
  "role",
  "about",
  "datatype",
  "inlist",
  "prefix",
  "property",
  "resource",
  "typeof",
  "vocab",
  "autoCapitalize",
  "autoCorrect",
  "autoSave",
  "color",
  "itemProp",
  "itemScope",
  "itemType",
  "itemID",
  "itemRef",
  "results",
  "security",
  "unselectable",
  "inputMode",
  "is",
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onChangeCapture",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  "onLoad",
  "onLoadCapture",
  "onError",
  "onErrorCapture",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onSelectCapture",
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerMoveCapture",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerEnterCapture",
  "onPointerLeave",
  "onPointerLeaveCapture",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  "onScroll",
  "onScrollCapture",
  "onWheel",
  "onWheelCapture",
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  "onTransitionEnd",
  "onTransitionEndCapture"
];
const validHTMLAttribute = /^(aria-|data-)/;
const getHTMLProps$5 = (props) => {
  return Object.fromEntries(Object.entries(props).filter((_ref) => {
    let [key] = _ref;
    return validHTMLAttribute.test(key) || reactSupportedHtmlAttr.includes(key);
  }));
};
var getHTMLProps_1 = getHTMLProps$5;
const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var nonHtmlPropsHaveChanged$5 = function nonHtmlPropsHaveChanged(component, prevProps) {
  return Object.keys(component.props).some((key) => !hasOwn(component.validProps, key) && component.props[key] !== prevProps[key]);
};
const React$5 = React__default;
const DashboardPlugin$1 = lib$3;
const basePropTypes$1 = propTypes$2.dashboard;
const getHTMLProps$4 = getHTMLProps_1;
const nonHtmlPropsHaveChanged$4 = nonHtmlPropsHaveChanged$5;
const h$7 = React$5.createElement;
class Dashboard3 extends React$5.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged$4(this, prevProps)) {
      const options = __spreadProps(__spreadValues({}, this.props), {
        target: this.container
      });
      delete options.uppy;
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:Dashboard"
    }, this.props), {
      target: this.container
    });
    delete options.uppy;
    uppy2.use(DashboardPlugin$1, options);
    this.plugin = uppy2.getPlugin(options.id);
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    this.validProps = getHTMLProps$4(this.props);
    return h$7("div", __spreadValues({
      ref: (container) => {
        this.container = container;
      }
    }, this.validProps));
  }
}
Dashboard3.propTypes = basePropTypes$1;
Dashboard3.defaultProps = {
  inline: true
};
const React$4 = React__default;
const PropTypes$3 = propTypes$3.exports;
const DashboardPlugin = lib$3;
const basePropTypes = propTypes$2.dashboard;
const getHTMLProps$3 = getHTMLProps_1;
const nonHtmlPropsHaveChanged$3 = nonHtmlPropsHaveChanged$5;
const h$6 = React$4.createElement;
class DashboardModal extends React$4.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged$3(this, prevProps)) {
      const options = __spreadProps(__spreadValues({}, this.props), {
        onRequestCloseModal: this.props.onRequestClose
      });
      delete options.uppy;
      this.plugin.setOptions(options);
    }
    if (prevProps.open && !this.props.open) {
      this.plugin.closeModal();
    } else if (!prevProps.open && this.props.open) {
      this.plugin.openModal();
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:DashboardModal"
    }, this.props), {
      onRequestCloseModal: this.props.onRequestClose
    });
    if (!options.target) {
      options.target = this.container;
    }
    delete options.uppy;
    uppy2.use(DashboardPlugin, options);
    this.plugin = uppy2.getPlugin(options.id);
    if (this.props.open) {
      this.plugin.openModal();
    }
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    this.validProps = getHTMLProps$3(this.props);
    return h$6("div", __spreadValues({
      ref: (container) => {
        this.container = container;
      }
    }, this.validProps));
  }
}
DashboardModal.propTypes = __spreadValues({
  target: typeof window !== "undefined" ? PropTypes$3.instanceOf(window.HTMLElement) : PropTypes$3.any,
  open: PropTypes$3.bool,
  onRequestClose: PropTypes$3.func,
  closeModalOnClickOutside: PropTypes$3.bool,
  disablePageScrollWhenModalOpen: PropTypes$3.bool
}, basePropTypes);
var toArray$4 = Array.from;
var isDragDropSupported$1 = function isDragDropSupported2() {
  const div = document.body;
  if (!("draggable" in div) || !("ondragstart" in div && "ondrop" in div)) {
    return false;
  }
  if (!("FormData" in window)) {
    return false;
  }
  if (!("FileReader" in window)) {
    return false;
  }
  return true;
};
var getRelativePath$1 = function getRelativePath2(fileEntry) {
  if (!fileEntry.fullPath || fileEntry.fullPath === `/${fileEntry.name}`) {
    return null;
  }
  return fileEntry.fullPath;
};
var getFilesAndDirectoriesFromDirectory$1 = function getFilesAndDirectoriesFromDirectory2(directoryReader, oldEntries, logDropError, _ref) {
  let {
    onSuccess
  } = _ref;
  directoryReader.readEntries((entries) => {
    const newEntries = [...oldEntries, ...entries];
    if (entries.length) {
      setTimeout(() => {
        getFilesAndDirectoriesFromDirectory2(directoryReader, newEntries, logDropError, {
          onSuccess
        });
      }, 0);
    } else {
      onSuccess(newEntries);
    }
  }, (error) => {
    logDropError(error);
    onSuccess(oldEntries);
  });
};
const toArray$3 = toArray$4;
const getRelativePath3 = getRelativePath$1;
const getFilesAndDirectoriesFromDirectory3 = getFilesAndDirectoriesFromDirectory$1;
var webkitGetAsEntryApi$1 = function webkitGetAsEntryApi2(dataTransfer, logDropError) {
  const files = [];
  const rootPromises = [];
  const createPromiseToAddFileOrParseDirectory = (entry) => new Promise((resolve) => {
    if (entry.isFile) {
      entry.file((file) => {
        file.relativePath = getRelativePath3(entry);
        files.push(file);
        resolve();
      }, (error) => {
        logDropError(error);
        resolve();
      });
    } else if (entry.isDirectory) {
      const directoryReader = entry.createReader();
      getFilesAndDirectoriesFromDirectory3(directoryReader, [], logDropError, {
        onSuccess: (entries) => resolve(Promise.all(entries.map(createPromiseToAddFileOrParseDirectory)))
      });
    }
  });
  toArray$3(dataTransfer.items).forEach((item) => {
    const entry = item.webkitGetAsEntry();
    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(() => files);
};
const toArray$2 = toArray$4;
var fallbackApi$1 = function fallbackApi2(dataTransfer) {
  const files = toArray$2(dataTransfer.files);
  return Promise.resolve(files);
};
const webkitGetAsEntryApi3 = webkitGetAsEntryApi$1;
const fallbackApi3 = fallbackApi$1;
var getDroppedFiles$1 = function getDroppedFiles2(dataTransfer, _temp2) {
  var _dataTransfer$items;
  let {
    logDropError = () => {
    }
  } = _temp2 === void 0 ? {} : _temp2;
  if ((_dataTransfer$items = dataTransfer.items) != null && _dataTransfer$items[0] && "webkitGetAsEntry" in dataTransfer.items[0]) {
    return webkitGetAsEntryApi3(dataTransfer, logDropError);
  }
  return fallbackApi3(dataTransfer);
};
var locale$4 = {
  strings: {
    dropHereOr: "Drop here or %{browse}",
    browse: "browse"
  }
};
var _class$1, _temp$1;
const {
  UIPlugin: UIPlugin$1
} = lib$a.exports;
const toArray$1 = toArray$4;
const isDragDropSupported3 = isDragDropSupported$1;
const getDroppedFiles3 = getDroppedFiles$1;
const {
  h: h$5
} = require$$1;
const locale$3 = locale$4;
var lib$2 = (_temp$1 = _class$1 = class DragDrop extends UIPlugin$1 {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.handleDrop = async (event) => {
      var _this$opts$onDrop, _this$opts;
      event.preventDefault();
      event.stopPropagation();
      clearTimeout(this.removeDragOverClassTimeout);
      this.setPluginState({
        isDraggingOver: false
      });
      const logDropError = (error) => {
        this.uppy.log(error, "error");
      };
      const files = await getDroppedFiles3(event.dataTransfer, {
        logDropError
      });
      if (files.length > 0) {
        this.uppy.log("[DragDrop] Files dropped");
        this.addFiles(files);
      }
      (_this$opts$onDrop = (_this$opts = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts, event);
    };
    this.type = "acquirer";
    this.id = this.opts.id || "DragDrop";
    this.title = "Drag & Drop";
    this.defaultLocale = locale$3;
    const defaultOpts = {
      target: null,
      inputName: "files[]",
      width: "100%",
      height: "100%",
      note: null
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOpts), opts);
    this.i18nInit();
    this.isDragDropSupported = isDragDropSupported3();
    this.removeDragOverClassTimeout = null;
    this.onInputChange = this.onInputChange.bind(this);
    this.handleDragOver = this.handleDragOver.bind(this);
    this.handleDragLeave = this.handleDragLeave.bind(this);
    this.handleDrop = this.handleDrop.bind(this);
    this.addFiles = this.addFiles.bind(this);
    this.render = this.render.bind(this);
  }
  addFiles(files) {
    const descriptors = files.map((file) => ({
      source: this.id,
      name: file.name,
      type: file.type,
      data: file,
      meta: {
        relativePath: file.relativePath || null
      }
    }));
    try {
      this.uppy.addFiles(descriptors);
    } catch (err) {
      this.uppy.log(err);
    }
  }
  onInputChange(event) {
    const files = toArray$1(event.target.files);
    if (files.length > 0) {
      this.uppy.log("[DragDrop] Files selected through input");
      this.addFiles(files);
    }
    event.target.value = null;
  }
  handleDragOver(event) {
    var _this$opts$onDragOver, _this$opts2;
    event.preventDefault();
    event.stopPropagation();
    const {
      types
    } = event.dataTransfer;
    const hasFiles = types.some((type) => type === "Files");
    const {
      allowNewUpload
    } = this.uppy.getState();
    if (!hasFiles || !allowNewUpload) {
      event.dataTransfer.dropEffect = "none";
      clearTimeout(this.removeDragOverClassTimeout);
      return;
    }
    event.dataTransfer.dropEffect = "copy";
    clearTimeout(this.removeDragOverClassTimeout);
    this.setPluginState({
      isDraggingOver: true
    });
    (_this$opts$onDragOver = (_this$opts2 = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts2, event);
  }
  handleDragLeave(event) {
    var _this$opts$onDragLeav, _this$opts3;
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this.removeDragOverClassTimeout);
    this.removeDragOverClassTimeout = setTimeout(() => {
      this.setPluginState({
        isDraggingOver: false
      });
    }, 50);
    (_this$opts$onDragLeav = (_this$opts3 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts3, event);
  }
  renderHiddenFileInput() {
    const {
      restrictions
    } = this.uppy.opts;
    return h$5("input", {
      className: "uppy-DragDrop-input",
      type: "file",
      hidden: true,
      ref: (ref) => {
        this.fileInputRef = ref;
      },
      name: this.opts.inputName,
      multiple: restrictions.maxNumberOfFiles !== 1,
      accept: restrictions.allowedFileTypes,
      onChange: this.onInputChange
    });
  }
  static renderArrowSvg() {
    return h$5("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: "uppy-c-icon uppy-DragDrop-arrow",
      width: "16",
      height: "16",
      viewBox: "0 0 16 16"
    }, h$5("path", {
      d: "M11 10V0H5v10H2l6 6 6-6h-3zm0 0",
      fillRule: "evenodd"
    }));
  }
  renderLabel() {
    return h$5("div", {
      className: "uppy-DragDrop-label"
    }, this.i18nArray("dropHereOr", {
      browse: h$5("span", {
        className: "uppy-DragDrop-browse"
      }, this.i18n("browse"))
    }));
  }
  renderNote() {
    return h$5("span", {
      className: "uppy-DragDrop-note"
    }, this.opts.note);
  }
  render() {
    const dragDropClass = `uppy-Root
      uppy-u-reset
      uppy-DragDrop-container
      ${this.isDragDropSupported ? "uppy-DragDrop--isDragDropSupported" : ""}
      ${this.getPluginState().isDraggingOver ? "uppy-DragDrop--isDraggingOver" : ""}
    `;
    const dragDropStyle = {
      width: this.opts.width,
      height: this.opts.height
    };
    return h$5("button", {
      type: "button",
      className: dragDropClass,
      style: dragDropStyle,
      onClick: () => this.fileInputRef.click(),
      onDragOver: this.handleDragOver,
      onDragLeave: this.handleDragLeave,
      onDrop: this.handleDrop
    }, this.renderHiddenFileInput(), h$5("div", {
      className: "uppy-DragDrop-inner"
    }, DragDrop.renderArrowSvg(), this.renderLabel(), this.renderNote()));
  }
  install() {
    const {
      target
    } = this.opts;
    this.setPluginState({
      isDraggingOver: false
    });
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
}, _class$1.VERSION = "2.0.6", _temp$1);
const React$3 = React__default;
const DragDropPlugin = lib$2;
const propTypes$1 = propTypes$2;
const getHTMLProps$2 = getHTMLProps_1;
const nonHtmlPropsHaveChanged$2 = nonHtmlPropsHaveChanged$5;
const h$4 = React$3.createElement;
class DragDrop2 extends React$3.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged$2(this, prevProps)) {
      const options = __spreadProps(__spreadValues({}, this.props), {
        target: this.container
      });
      delete options.uppy;
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:DragDrop"
    }, this.props), {
      target: this.container
    });
    delete options.uppy;
    uppy2.use(DragDropPlugin, options);
    this.plugin = uppy2.getPlugin(options.id);
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    this.validProps = getHTMLProps$2(this.props);
    return h$4("div", __spreadValues({
      ref: (container) => {
        this.container = container;
      }
    }, this.validProps));
  }
}
DragDrop2.propTypes = {
  uppy: propTypes$1.uppy,
  locale: propTypes$1.locale
};
DragDrop2.defaultProps = {};
var DragDrop_1 = DragDrop2;
var _class, _temp;
const {
  UIPlugin
} = lib$a.exports;
const {
  h: h$3
} = require$$1;
var lib$1 = (_temp = _class = class ProgressBar extends UIPlugin {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.id = this.opts.id || "ProgressBar";
    this.title = "Progress Bar";
    this.type = "progressindicator";
    const defaultOptions2 = {
      target: "body",
      fixed: false,
      hideAfterFinish: true
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
    this.render = this.render.bind(this);
  }
  render(state) {
    const progress = state.totalProgress || 0;
    const isHidden2 = (progress === 0 || progress === 100) && this.opts.hideAfterFinish;
    return h$3("div", {
      className: "uppy uppy-ProgressBar",
      style: {
        position: this.opts.fixed ? "fixed" : "initial"
      },
      "aria-hidden": isHidden2
    }, h$3("div", {
      className: "uppy-ProgressBar-inner",
      style: {
        width: `${progress}%`
      }
    }), h$3("div", {
      className: "uppy-ProgressBar-percentage"
    }, progress));
  }
  install() {
    const {
      target
    } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
}, _class.VERSION = "2.0.4", _temp);
const React$2 = React__default;
const PropTypes$2 = propTypes$3.exports;
const ProgressBarPlugin = lib$1;
const uppyPropType$1 = propTypes$2.uppy;
const getHTMLProps$1 = getHTMLProps_1;
const nonHtmlPropsHaveChanged$1 = nonHtmlPropsHaveChanged$5;
const h$2 = React$2.createElement;
class ProgressBar2 extends React$2.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged$1(this, prevProps)) {
      const options = __spreadProps(__spreadValues({}, this.props), {
        target: this.container
      });
      delete options.uppy;
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:ProgressBar"
    }, this.props), {
      target: this.container
    });
    delete options.uppy;
    uppy2.use(ProgressBarPlugin, options);
    this.plugin = uppy2.getPlugin(options.id);
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    this.validProps = getHTMLProps$1(this.props);
    return h$2("div", __spreadValues({
      ref: (container) => {
        this.container = container;
      }
    }, this.validProps));
  }
}
ProgressBar2.propTypes = {
  uppy: uppyPropType$1,
  fixed: PropTypes$2.bool,
  hideAfterFinish: PropTypes$2.bool
};
ProgressBar2.defaultProps = {};
const React$1 = React__default;
const PropTypes$1 = propTypes$3.exports;
const StatusBarPlugin = lib$6;
const uppyPropType = propTypes$2.uppy;
const getHTMLProps = getHTMLProps_1;
const nonHtmlPropsHaveChanged2 = nonHtmlPropsHaveChanged$5;
const h$1 = React$1.createElement;
class StatusBar2 extends React$1.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    } else if (nonHtmlPropsHaveChanged2(this, prevProps)) {
      const options = __spreadProps(__spreadValues({}, this.props), {
        target: this.container
      });
      delete options.uppy;
      this.plugin.setOptions(options);
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:StatusBar"
    }, this.props), {
      target: this.container
    });
    delete options.uppy;
    uppy2.use(StatusBarPlugin, options);
    this.plugin = uppy2.getPlugin(options.id);
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    this.validProps = getHTMLProps(this.props);
    return h$1("div", __spreadValues({
      ref: (container) => {
        this.container = container;
      }
    }, this.validProps));
  }
}
StatusBar2.propTypes = {
  uppy: uppyPropType,
  hideAfterFinish: PropTypes$1.bool,
  showProgressDetails: PropTypes$1.bool
};
StatusBar2.defaultProps = {};
var StatusBar_1 = StatusBar2;
var locale$2 = {
  strings: {
    chooseFiles: "Choose files"
  }
};
var _core = lib$a.exports;
var _preact = require$$1;
const toArray = toArray$9;
const packageJson = {
  "version": "2.0.6"
};
const locale$1 = locale$2;
class FileInput$1 extends _core.UIPlugin {
  constructor(uppy2, opts) {
    super(uppy2, opts);
    this.id = this.opts.id || "FileInput";
    this.title = "File Input";
    this.type = "acquirer";
    this.defaultLocale = locale$1;
    const defaultOptions2 = {
      target: null,
      pretty: true,
      inputName: "files[]"
    };
    this.opts = __spreadValues(__spreadValues({}, defaultOptions2), opts);
    this.i18nInit();
    this.render = this.render.bind(this);
    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }
  addFiles(files) {
    const descriptors = files.map((file) => ({
      source: this.id,
      name: file.name,
      type: file.type,
      data: file
    }));
    try {
      this.uppy.addFiles(descriptors);
    } catch (err) {
      this.uppy.log(err);
    }
  }
  handleInputChange(event) {
    this.uppy.log("[FileInput] Something selected through input...");
    const files = toArray(event.target.files);
    this.addFiles(files);
    event.target.value = null;
  }
  handleClick() {
    this.input.click();
  }
  render() {
    const hiddenInputStyle = {
      width: "0.1px",
      height: "0.1px",
      opacity: 0,
      overflow: "hidden",
      position: "absolute",
      zIndex: -1
    };
    const {
      restrictions
    } = this.uppy.opts;
    const accept = restrictions.allowedFileTypes ? restrictions.allowedFileTypes.join(",") : null;
    return (0, _preact.h)("div", {
      className: "uppy-Root uppy-FileInput-container"
    }, (0, _preact.h)("input", {
      className: "uppy-FileInput-input",
      style: this.opts.pretty && hiddenInputStyle,
      type: "file",
      name: this.opts.inputName,
      onChange: this.handleInputChange,
      multiple: restrictions.maxNumberOfFiles !== 1,
      accept,
      ref: (input) => {
        this.input = input;
      }
    }), this.opts.pretty && (0, _preact.h)("button", {
      className: "uppy-FileInput-btn",
      type: "button",
      onClick: this.handleClick
    }, this.i18n("chooseFiles")));
  }
  install() {
    const {
      target
    } = this.opts;
    if (target) {
      this.mount(target, this);
    }
  }
  uninstall() {
    this.unmount();
  }
}
FileInput$1.VERSION = packageJson.version;
var FileInput_1 = FileInput$1;
var lib = FileInput_1;
const PropTypes = propTypes$3.exports;
const React = React__default;
const FileInputPlugin = lib;
const propTypes = propTypes$2;
const h = React.createElement;
class FileInput extends React.Component {
  componentDidMount() {
    this.installPlugin();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.uppy !== this.props.uppy) {
      this.uninstallPlugin(prevProps);
      this.installPlugin();
    }
  }
  componentWillUnmount() {
    this.uninstallPlugin();
  }
  installPlugin() {
    const {
      uppy: uppy2
    } = this.props;
    const options = __spreadProps(__spreadValues({
      id: "react:FileInput"
    }, this.props), {
      target: this.container
    });
    delete options.uppy;
    uppy2.use(FileInputPlugin, options);
    this.plugin = uppy2.getPlugin(options.id);
  }
  uninstallPlugin(props) {
    if (props === void 0) {
      props = this.props;
    }
    const {
      uppy: uppy2
    } = props;
    uppy2.removePlugin(this.plugin);
  }
  render() {
    return h("div", {
      ref: (container) => {
        this.container = container;
      }
    });
  }
}
FileInput.propTypes = {
  uppy: propTypes.uppy,
  locale: propTypes.locale,
  pretty: PropTypes.bool,
  inputName: PropTypes.string
};
FileInput.defaultProps = {};
lib$a.exports.Uppy;
const EntityCard = ({
  title,
  action,
  children
}) => {
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Typography, {
      sx: {
        marginY: "12px",
        textTransform: "uppercase"
      },
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: title,
        defaultMessage: stringPrettyCapitalize(title)
      })
    }), action, /* @__PURE__ */ jsx(Table, {
      sx: {
        tableLayout: "fixed"
      },
      children: /* @__PURE__ */ jsx(TableBody, {
        children
      })
    })]
  });
};
const I18nProvider = ({
  children,
  locale: locale2,
  messages
}) => {
  return /* @__PURE__ */ jsx(IntlProvider$1, {
    onError: () => {
    },
    locale: locale2,
    textComponent: Fragment$2,
    messages,
    children
  });
};
const LocaleContext = createContext({
  state: {
    locale: "en"
  },
  dispatch: () => {
  }
});
const reducer$1 = (state, action) => {
  switch (action.type) {
    case "setLocale":
      localStorage.setItem("langLocale", action.locale);
      return __spreadProps(__spreadValues({}, state), {
        locale: action.locale
      });
  }
};
const LocaleContextProvider = ({
  children
}) => {
  var _a2, _b;
  const [state, dispatch] = useReducer(reducer$1, {
    locale: (_b = (_a2 = localStorage.getItem("langLocale")) != null ? _a2 : navigator.language) != null ? _b : "en"
  });
  const value = {
    state,
    dispatch
  };
  return /* @__PURE__ */ jsx(LocaleContext.Provider, {
    value,
    children
  });
};
const LocaleContextConsumer = LocaleContext.Consumer;
const useLocale = () => {
  var _a2;
  const { state } = useContext(LocaleContext);
  return (_a2 = state == null ? void 0 : state.locale) != null ? _a2 : "en";
};
const useSetLocale = () => {
  const { state, dispatch } = useContext(LocaleContext);
  return useCallback((newLocale) => new Promise((resolve) => {
    resolve(I18nProvider);
  }).then(() => {
    const locale2 = newLocale;
    dispatch({ type: "setLocale", locale: locale2 });
  }).catch((error) => {
    console.error(error);
  }), [state, dispatch]);
};
const LocaleSwitch = ({
  locales
}) => {
  const locale2 = useLocale();
  const setLocale = useSetLocale();
  const getEventValue = (event) => {
    var _a2, _b;
    const locale22 = (_b = (_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.value) != null ? _b : "en";
    setLocale(locale22);
  };
  return /* @__PURE__ */ jsx(FormControl$1, {
    variant: "standard",
    children: /* @__PURE__ */ jsx(Select, {
      className: "MuiSelect-root",
      labelId: "select-locale",
      value: locale2.split("-")[0],
      onChange: getEventValue,
      children: Object.keys(locales).map(function(locale22) {
        return /* @__PURE__ */ jsx(MenuItem$1, {
          value: locales[locale22],
          children: locale22.toUpperCase()
        }, locale22);
      })
    })
  });
};
const knownError = (errors, callback) => {
  var _a2, _b, _c, _d;
  console.log("knownError", errors);
  let title;
  if ((_b = (_a2 = errors == null ? void 0 : errors.message) == null ? void 0 : _a2.includes) == null ? void 0 : _b.call(_a2, "JWTExpired")) {
    title = "Error loading (expired) - please login";
    callback(true);
  } else if ((_d = (_c = errors == null ? void 0 : errors.message) == null ? void 0 : _c.includes) == null ? void 0 : _d.call(_c, "not found in type")) {
    title = "Error loading (permissions not set properly)";
  } else {
    title = "Error loading";
  }
  return {
    title,
    body: errors == null ? void 0 : errors.message
  };
};
const QueryBoundary = (props) => {
  var _a2, _b;
  const [tokenExpired, setTokenExpired] = useState(false);
  const [textObj, setTextObj] = useState({
    title: "Something went wrong",
    body: "Please try agin"
  });
  const navigate = useNavigate();
  useEffect(() => {
    var _a3, _b2, _c, _d, _e, _f, _g;
    setTokenExpired(false);
    if ((_b2 = (_a3 = props.queryResponse) == null ? void 0 : _a3.error) == null ? void 0 : _b2.networkError) {
      setTextObj({
        title: "Network Error",
        body: "There was an error connecting. Please check your internet."
      });
    } else if (((_d = (_c = props.queryResponse) == null ? void 0 : _c.error) == null ? void 0 : _d.name) && ((_f = (_e = props.queryResponse) == null ? void 0 : _e.error) == null ? void 0 : _f.message)) {
      setTextObj(knownError((_g = props.queryResponse) == null ? void 0 : _g.error, setTokenExpired));
    } else {
      setTextObj({
        title: "Something went wrong",
        body: "Please try agin"
      });
    }
  }, [(_a2 = props.queryResponse) == null ? void 0 : _a2.error]);
  const handleLoginButton = () => {
    if (tokenExpired)
      return /* @__PURE__ */ jsx(Box, {
        sx: {
          marginTop: "15px",
          textAlign: "center"
        },
        children: /* @__PURE__ */ jsx(Button$1, {
          color: "primary",
          variant: "contained",
          onClick: () => navigate("/login"),
          children: /* @__PURE__ */ jsx(Translate, {
            entityName: "Login"
          })
        })
      });
    return /* @__PURE__ */ jsx(Fragment$1, {});
  };
  if ((_b = props.queryResponse) == null ? void 0 : _b.error) {
    return /* @__PURE__ */ jsxs(Card, {
      sx: {
        maxWidth: "50%"
      },
      children: [/* @__PURE__ */ jsx(CardHeader, {
        sx: {
          background: "crimson",
          color: "white"
        },
        title: textObj.title
      }), /* @__PURE__ */ jsxs(CardContent, {
        children: [/* @__PURE__ */ jsx(Typography, {
          variant: "body1",
          color: "text.secondary",
          children: textObj.body
        }), handleLoginButton()]
      })]
    });
  }
  return props.children;
};
const EntityListContainer = (props) => {
  const filterProps2 = useFilter();
  const result = useEntityList(props.entity, filterProps2);
  return /* @__PURE__ */ jsx(ErrorBoundary, {
    children: /* @__PURE__ */ jsx(QueryBoundary, {
      queryResponse: result,
      children: /* @__PURE__ */ jsx(ListPagePlaceholder, __spreadValues(__spreadValues({
        loading: result == null ? void 0 : result.fetching,
        data: result == null ? void 0 : result.data,
        entityFields: result == null ? void 0 : result.entityFields
      }, props), filterProps2))
    })
  });
};
const calculateDialogSize = (field) => {
  var _a2, _b;
  const columnSize = 170;
  const fieldsCount = ((_b = (_a2 = field.entityFields) == null ? void 0 : _a2.fields) == null ? void 0 : _b.length) || 1;
  const width = columnSize * fieldsCount;
  if (width >= 960) {
    return "lg";
  }
  if (width >= 600) {
    return "md";
  }
  return "sm";
};
const EntityListDialog = ({
  children,
  entityField,
  onClickRow,
  setRowClickDisabled
}) => {
  var _a2;
  const [open, setOpen] = React__default.useState(false);
  const objectRef = ((_a2 = entityField.entityFields) == null ? void 0 : _a2.fields.find((field) => field.type === "object")) || entityField;
  const handleClickOpen = () => {
    setOpen(true);
    if (setRowClickDisabled)
      setRowClickDisabled(false);
  };
  const handleClose = () => {
    setOpen(false);
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [React__default.Children.map(children, (child) => {
      if (React__default.isValidElement(child)) {
        return React__default.cloneElement(child, {
          onClick: handleClickOpen
        });
      }
      return child;
    }), /* @__PURE__ */ jsxs(Dialog, {
      fullWidth: true,
      maxWidth: calculateDialogSize(objectRef),
      open,
      onClose: handleClose,
      children: [/* @__PURE__ */ jsx(DialogTitle, {
        children: /* @__PURE__ */ jsxs(Grid, {
          container: true,
          children: [/* @__PURE__ */ jsx(Grid, {
            item: true,
            xs: true,
            children: /* @__PURE__ */ jsx(Translate, {
              entityName: objectRef.name,
              defaultMessage: stringPrettyCapitalize(objectRef.name)
            })
          }), /* @__PURE__ */ jsx(Grid, {
            item: true,
            children: /* @__PURE__ */ jsx(IconButton$1, {
              "aria-label": "close",
              onClick: handleClose,
              children: /* @__PURE__ */ jsx(Close, {})
            })
          })]
        })
      }), /* @__PURE__ */ jsx(DialogContent, {
        children: /* @__PURE__ */ jsx(EntityListContainer, {
          entity: objectRef.name,
          onClickRow: (e2) => {
            if (onClickRow) {
              onClickRow(e2.row);
            }
            setOpen(false);
          }
        })
      })]
    })]
  });
};
const deleteFieldsOptions = [
  { name: "platny", deleted: false, notDeleted: true },
  { name: "isDeleted", deleted: true, notDeleted: false }
];
const guessEntityDeleteField = (entity) => {
  var _a2;
  return (_a2 = entity == null ? void 0 : entity.fields) == null ? void 0 : _a2.find((field) => deleteFieldsOptions.some((f2) => (f2 == null ? void 0 : f2.name) === (field == null ? void 0 : field.name)));
};
const getEntityDeleteFieldOptions = (field) => {
  return deleteFieldsOptions.find((f2) => f2.name === field.name);
};
const isDeleted = (field, item) => {
  const entityDeleteFieldOptions = getEntityDeleteFieldOptions(field);
  if (entityDeleteFieldOptions) {
    return item[entityDeleteFieldOptions.name] === entityDeleteFieldOptions.deleted;
  }
};
const setDeleted = (field, item, deleted) => {
  const entityDeleteFieldOptions = getEntityDeleteFieldOptions(field);
  if (entityDeleteFieldOptions) {
    item[field.name] = deleted ? entityDeleteFieldOptions.deleted : entityDeleteFieldOptions.notDeleted;
  }
  return item;
};
const detailPageRegex = /^-?\d+$/;
const detailPageFullRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
const getEntityNameFromUrl = () => {
  const url = window.location.href;
  const urlParts = url.split("/").filter(Boolean);
  if (detailPageRegex.test(urlParts[urlParts.length - 1]) || detailPageFullRegex.test(urlParts[urlParts.length - 1]) || urlParts[urlParts.length - 1] === "create") {
    return urlParts[urlParts.length - 2];
  } else
    return urlParts[urlParts.length - 1];
};
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function composeClasses(slots, getUtilityClass, classes2) {
  const output = {};
  Object.keys(slots).forEach((slot) => {
    output[slot] = slots[slot].reduce((acc, key) => {
      if (key) {
        if (classes2 && classes2[key]) {
          acc.push(classes2[key]);
        }
        acc.push(getUtilityClass(key));
      }
      return acc;
    }, []).join(" ");
  });
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
var ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
  active: "Mui-active",
  checked: "Mui-checked",
  completed: "Mui-completed",
  disabled: "Mui-disabled",
  error: "Mui-error",
  expanded: "Mui-expanded",
  focused: "Mui-focused",
  focusVisible: "Mui-focusVisible",
  required: "Mui-required",
  selected: "Mui-selected"
};
function generateUtilityClass(componentName, slot) {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass || `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots) {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot);
  });
  return result;
}
function arrayIncludes(array, itemOrItems) {
  if (Array.isArray(itemOrItems)) {
    return itemOrItems.every((item) => array.indexOf(item) !== -1);
  }
  return array.indexOf(itemOrItems) !== -1;
}
const onSpaceOrEnter = (innerFn, onFocus) => (event) => {
  if (event.key === "Enter" || event.key === " ") {
    innerFn();
    event.preventDefault();
    event.stopPropagation();
  }
  if (onFocus) {
    onFocus(event);
  }
};
const pipe = (...fns) => fns.reduceRight((prevFn, nextFn) => (...args) => nextFn(prevFn(...args)), (value) => value);
function createDelegatedEventHandler(fn, onEvent) {
  return (event) => {
    fn(event);
    if (onEvent) {
      onEvent(event);
    }
  };
}
const _excluded$k = ["disabled", "onSelect", "selected", "value"];
const classes$6 = generateUtilityClasses("PrivatePickersMonth", ["root", "selected"]);
const PickersMonthRoot = styled(Typography$1)(({
  theme
}) => _extends({
  flex: "1 0 33.33%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus, &:hover": {
    backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  "&:disabled": {
    pointerEvents: "none",
    color: theme.palette.text.secondary
  },
  [`&.${classes$6.selected}`]: {
    color: theme.palette.primary.contrastText,
    backgroundColor: theme.palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: theme.palette.primary.dark
    }
  }
}));
const PickersMonth = (props) => {
  const {
    disabled,
    onSelect,
    selected,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const handleSelection = () => {
    onSelect(value);
  };
  return /* @__PURE__ */ jsx(PickersMonthRoot, _extends({
    component: "button",
    className: clsx(classes$6.root, selected && classes$6.selected),
    tabIndex: disabled ? -1 : 0,
    onClick: handleSelection,
    onKeyDown: onSpaceOrEnter(handleSelection),
    color: selected ? "primary" : void 0,
    variant: selected ? "h5" : "subtitle1",
    disabled
  }, other));
};
var PickersMonth$1 = PickersMonth;
const MuiPickersAdapterContext = /* @__PURE__ */ React$6.createContext(null);
function LocalizationProvider(props) {
  const {
    children,
    dateAdapter: Utils,
    dateFormats: dateFormats2,
    dateLibInstance,
    locale: locale2
  } = props;
  const utils = React$6.useMemo(() => new Utils({
    locale: locale2,
    formats: dateFormats2,
    instance: dateLibInstance
  }), [Utils, locale2, dateFormats2, dateLibInstance]);
  const defaultDates = React$6.useMemo(() => {
    return {
      minDate: utils.date("1900-01-01T00:00:00.000"),
      maxDate: utils.date("2099-12-31T00:00:00.000")
    };
  }, [utils]);
  const contextValue = React$6.useMemo(() => {
    return {
      utils,
      defaultDates
    };
  }, [defaultDates, utils]);
  return /* @__PURE__ */ jsx(MuiPickersAdapterContext.Provider, {
    value: contextValue,
    children
  });
}
function useLocalizationContext() {
  const localization = React$6.useContext(MuiPickersAdapterContext);
  if (localization === null) {
    throw new Error(formatMuiErrorMessage(13));
  }
  return localization;
}
function useUtils() {
  return useLocalizationContext().utils;
}
function useDefaultDates() {
  return useLocalizationContext().defaultDates;
}
function useNow() {
  const utils = useUtils();
  const now2 = React$6.useRef(utils.date());
  return now2.current;
}
const _excluded$j = ["className", "date", "disabled", "disableFuture", "disablePast", "maxDate", "minDate", "onChange", "onMonthChange", "readOnly"];
function getMonthPickerUtilityClass(slot) {
  return generateUtilityClass("MuiMonthPicker", slot);
}
generateUtilityClasses("MuiMonthPicker", ["root"]);
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMonthPickerUtilityClass, classes2);
};
const MonthPickerRoot = styled("div", {
  name: "MuiMonthPicker",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  width: 310,
  display: "flex",
  flexWrap: "wrap",
  alignContent: "stretch",
  margin: "0 4px"
});
const MonthPicker = /* @__PURE__ */ React$6.forwardRef(function MonthPicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMonthPicker"
  });
  const {
    className,
    date,
    disabled,
    disableFuture,
    disablePast,
    maxDate,
    minDate,
    onChange,
    onMonthChange,
    readOnly
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const ownerState = props;
  const classes2 = useUtilityClasses$6(ownerState);
  const utils = useUtils();
  const now2 = useNow();
  const currentMonth = utils.getMonth(date || now2);
  const shouldDisableMonth = (month) => {
    const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now2, minDate) ? now2 : minDate);
    const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now2, maxDate) ? now2 : maxDate);
    const isBeforeFirstEnabled = utils.isBefore(month, firstEnabledMonth);
    const isAfterLastEnabled = utils.isAfter(month, lastEnabledMonth);
    return isBeforeFirstEnabled || isAfterLastEnabled;
  };
  const onMonthSelect = (month) => {
    if (readOnly) {
      return;
    }
    const newDate = utils.setMonth(date || now2, month);
    onChange(newDate, "finish");
    if (onMonthChange) {
      onMonthChange(newDate);
    }
  };
  return /* @__PURE__ */ jsx(MonthPickerRoot, _extends({
    ref,
    className: clsx(classes2.root, className),
    ownerState
  }, other, {
    children: utils.getMonthArray(date || now2).map((month) => {
      const monthNumber = utils.getMonth(month);
      const monthText = utils.format(month, "monthShort");
      return /* @__PURE__ */ jsx(PickersMonth$1, {
        value: monthNumber,
        selected: monthNumber === currentMonth,
        onSelect: onMonthSelect,
        disabled: disabled || shouldDisableMonth(month),
        children: monthText
      }, monthText);
    })
  }));
});
var MonthPicker$1 = MonthPicker;
const findClosestEnabledDate = ({
  date,
  disableFuture,
  disablePast,
  maxDate,
  minDate,
  shouldDisableDate,
  utils
}) => {
  const today = utils.startOfDay(utils.date());
  if (disablePast && utils.isBefore(minDate, today)) {
    minDate = today;
  }
  if (disableFuture && utils.isAfter(maxDate, today)) {
    maxDate = today;
  }
  let forward = date;
  let backward = date;
  if (utils.isBefore(date, minDate)) {
    forward = utils.date(minDate);
    backward = null;
  }
  if (utils.isAfter(date, maxDate)) {
    if (backward) {
      backward = utils.date(maxDate);
    }
    forward = null;
  }
  while (forward || backward) {
    if (forward && utils.isAfter(forward, maxDate)) {
      forward = null;
    }
    if (backward && utils.isBefore(backward, minDate)) {
      backward = null;
    }
    if (forward) {
      if (!shouldDisableDate(forward)) {
        return forward;
      }
      forward = utils.addDays(forward, 1);
    }
    if (backward) {
      if (!shouldDisableDate(backward)) {
        return backward;
      }
      backward = utils.addDays(backward, -1);
    }
  }
  return today;
};
function parsePickerInputValue(utils, value) {
  const parsedValue = utils.date(value);
  return utils.isValid(parsedValue) ? parsedValue : null;
}
const validateDate$1 = (utils, value, {
  disablePast,
  disableFuture,
  minDate,
  maxDate,
  shouldDisableDate
}) => {
  const now2 = utils.date();
  const date = utils.date(value);
  if (date === null) {
    return null;
  }
  switch (true) {
    case !utils.isValid(value):
      return "invalidDate";
    case Boolean(shouldDisableDate && shouldDisableDate(date)):
      return "shouldDisableDate";
    case Boolean(disableFuture && utils.isAfterDay(date, now2)):
      return "disableFuture";
    case Boolean(disablePast && utils.isBeforeDay(date, now2)):
      return "disablePast";
    case Boolean(minDate && utils.isBeforeDay(date, minDate)):
      return "minDate";
    case Boolean(maxDate && utils.isAfterDay(date, maxDate)):
      return "maxDate";
    default:
      return null;
  }
};
const createCalendarStateReducer = (reduceAnimations, disableSwitchToMonthOnDayFocus, utils) => (state, action) => {
  switch (action.type) {
    case "changeMonth":
      return _extends({}, state, {
        slideDirection: action.direction,
        currentMonth: action.newMonth,
        isMonthSwitchingAnimating: !reduceAnimations
      });
    case "finishMonthSwitchingAnimation":
      return _extends({}, state, {
        isMonthSwitchingAnimating: false
      });
    case "changeFocusedDay": {
      if (state.focusedDay !== null && utils.isSameDay(action.focusedDay, state.focusedDay)) {
        return state;
      }
      const needMonthSwitch = Boolean(action.focusedDay) && !disableSwitchToMonthOnDayFocus && !utils.isSameMonth(state.currentMonth, action.focusedDay);
      return _extends({}, state, {
        focusedDay: action.focusedDay,
        isMonthSwitchingAnimating: needMonthSwitch && !reduceAnimations,
        currentMonth: needMonthSwitch ? utils.startOfMonth(action.focusedDay) : state.currentMonth,
        slideDirection: utils.isAfterDay(action.focusedDay, state.currentMonth) ? "left" : "right"
      });
    }
    default:
      throw new Error("missing support");
  }
};
function useCalendarState({
  date,
  defaultCalendarMonth,
  disableFuture,
  disablePast,
  disableSwitchToMonthOnDayFocus = false,
  maxDate,
  minDate,
  onMonthChange,
  reduceAnimations,
  shouldDisableDate
}) {
  var _ref;
  const now2 = useNow();
  const utils = useUtils();
  const reducerFn = React$6.useRef(createCalendarStateReducer(Boolean(reduceAnimations), disableSwitchToMonthOnDayFocus, utils)).current;
  const [calendarState, dispatch] = React$6.useReducer(reducerFn, {
    isMonthSwitchingAnimating: false,
    focusedDay: date || now2,
    currentMonth: utils.startOfMonth((_ref = date != null ? date : defaultCalendarMonth) != null ? _ref : now2),
    slideDirection: "left"
  });
  const handleChangeMonth = React$6.useCallback((payload) => {
    dispatch(_extends({
      type: "changeMonth"
    }, payload));
    if (onMonthChange) {
      onMonthChange(payload.newMonth);
    }
  }, [onMonthChange]);
  const changeMonth = React$6.useCallback((newDate) => {
    const newDateRequested = newDate != null ? newDate : now2;
    if (utils.isSameMonth(newDateRequested, calendarState.currentMonth)) {
      return;
    }
    handleChangeMonth({
      newMonth: utils.startOfMonth(newDateRequested),
      direction: utils.isAfterDay(newDateRequested, calendarState.currentMonth) ? "left" : "right"
    });
  }, [calendarState.currentMonth, handleChangeMonth, now2, utils]);
  const isDateDisabled = React$6.useCallback((day) => validateDate$1(utils, day, {
    disablePast,
    disableFuture,
    minDate,
    maxDate,
    shouldDisableDate
  }) !== null, [disableFuture, disablePast, maxDate, minDate, shouldDisableDate, utils]);
  const onMonthSwitchingAnimationEnd = React$6.useCallback(() => {
    dispatch({
      type: "finishMonthSwitchingAnimation"
    });
  }, []);
  const changeFocusedDay = React$6.useCallback((newFocusedDate) => {
    if (!isDateDisabled(newFocusedDate)) {
      dispatch({
        type: "changeFocusedDay",
        focusedDay: newFocusedDate
      });
    }
  }, [isDateDisabled]);
  return {
    calendarState,
    changeMonth,
    changeFocusedDay,
    isDateDisabled,
    onMonthSwitchingAnimationEnd,
    handleChangeMonth
  };
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
var config = {
  disabled: false
};
var TransitionGroupContext = React__default.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render2() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: null
    }, typeof children === "function" ? children(status, childProps) : React__default.cloneElement(React__default.Children.only(children), childProps));
  };
  return Transition2;
}(React__default.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition$1 = Transition;
var _addClass = function addClass$1(node, classes2) {
  return node && classes2 && classes2.split(" ").forEach(function(c2) {
    return addClass(node, c2);
  });
};
var removeClass = function removeClass2(node, classes2) {
  return node && classes2 && classes2.split(" ").forEach(function(c2) {
    return removeClass$1(node, c2);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames2 = _this.props.classNames;
      var isStringClassNames = typeof classNames2 === "string";
      var prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React__default.createElement(Transition$1, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React__default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
var CSSTransition$1 = CSSTransition;
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return cloneElement$2(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = cloneElement$2(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = cloneElement$2(child, {
        in: false
      });
    } else if (hasNext && hasPrev && isValidElement(prevChild)) {
      children[key] = cloneElement$2(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render2() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React__default.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React__default.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(React__default.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup$1 = TransitionGroup;
const classes$5 = generateUtilityClasses("PrivatePickersFadeTransitionGroup", ["root"]);
const animationDuration = 500;
const PickersFadeTransitionGroupRoot = styled(TransitionGroup$1)({
  display: "block",
  position: "relative"
});
const PickersFadeTransitionGroup = ({
  children,
  className,
  reduceAnimations,
  transKey
}) => {
  if (reduceAnimations) {
    return children;
  }
  return /* @__PURE__ */ jsx(PickersFadeTransitionGroupRoot, {
    className: clsx(classes$5.root, className),
    children: /* @__PURE__ */ jsx(Fade, {
      appear: false,
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: {
        appear: animationDuration,
        enter: animationDuration / 2,
        exit: 0
      },
      children
    }, transKey)
  });
};
var FadeTransitionGroup = PickersFadeTransitionGroup;
const DAY_SIZE = 36;
const DAY_MARGIN = 2;
const DIALOG_WIDTH = 320;
const VIEW_HEIGHT = 358;
const _excluded$i = ["allowSameDateSelection", "autoFocus", "className", "day", "disabled", "disableHighlightToday", "disableMargin", "hidden", "isAnimating", "onClick", "onDayFocus", "onDaySelect", "onFocus", "onKeyDown", "outsideCurrentMonth", "selected", "showDaysOutsideCurrentMonth", "children", "today"];
function getPickersDayUtilityClass(slot) {
  return generateUtilityClass("MuiPickersDay", slot);
}
const pickersDayClasses = generateUtilityClasses("MuiPickersDay", ["root", "dayWithMargin", "dayOutsideMonth", "hiddenDaySpacingFiller", "today", "selected", "disabled"]);
const useUtilityClasses$5 = (ownerState) => {
  const {
    selected,
    disableMargin,
    disableHighlightToday,
    today,
    outsideCurrentMonth,
    showDaysOutsideCurrentMonth,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", !disableMargin && "dayWithMargin", !disableHighlightToday && today && "today", outsideCurrentMonth && showDaysOutsideCurrentMonth && "dayOutsideMonth"],
    hiddenDaySpacingFiller: ["hiddenDaySpacingFiller"]
  };
  return composeClasses(slots, getPickersDayUtilityClass, classes2);
};
const styleArg = ({
  theme,
  ownerState
}) => _extends({}, theme.typography.caption, {
  width: DAY_SIZE,
  height: DAY_SIZE,
  borderRadius: "50%",
  padding: 0,
  backgroundColor: theme.palette.background.paper,
  color: theme.palette.text.primary,
  "&:hover": {
    backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  "&:focus": {
    backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
    [`&.${pickersDayClasses.selected}`]: {
      willChange: "background-color",
      backgroundColor: theme.palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.selected}`]: {
    color: theme.palette.primary.contrastText,
    backgroundColor: theme.palette.primary.main,
    fontWeight: theme.typography.fontWeightMedium,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.short
    }),
    "&:hover": {
      willChange: "background-color",
      backgroundColor: theme.palette.primary.dark
    }
  },
  [`&.${pickersDayClasses.disabled}`]: {
    color: theme.palette.text.disabled
  }
}, !ownerState.disableMargin && {
  margin: `0 ${DAY_MARGIN}px`
}, ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && {
  color: theme.palette.text.secondary
}, !ownerState.disableHighlightToday && ownerState.today && {
  [`&:not(.${pickersDayClasses.selected})`]: {
    border: `1px solid ${theme.palette.text.secondary}`
  }
});
const overridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, !ownerState.disableMargin && styles.dayWithMargin, !ownerState.disableHighlightToday && ownerState.today && styles.today, !ownerState.outsideCurrentMonth && ownerState.showDaysOutsideCurrentMonth && styles.dayOutsideMonth, ownerState.outsideCurrentMonth && !ownerState.showDaysOutsideCurrentMonth && styles.hiddenDaySpacingFiller];
};
const PickersDayRoot = styled(ButtonBase, {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(styleArg);
const PickersDayFiller = styled("div", {
  name: "MuiPickersDay",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends({}, styleArg({
  theme,
  ownerState
}), {
  visibility: "hidden"
}));
const noop = () => {
};
const PickersDay = /* @__PURE__ */ React$6.forwardRef(function PickersDay2(inProps, forwardedRef) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPickersDay"
  });
  const {
    allowSameDateSelection = false,
    autoFocus = false,
    className,
    day,
    disabled = false,
    disableHighlightToday = false,
    disableMargin = false,
    isAnimating,
    onClick,
    onDayFocus = noop,
    onDaySelect,
    onFocus,
    onKeyDown,
    outsideCurrentMonth,
    selected = false,
    showDaysOutsideCurrentMonth = false,
    children,
    today: isToday = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const ownerState = _extends({}, props, {
    allowSameDateSelection,
    autoFocus,
    disabled,
    disableHighlightToday,
    disableMargin,
    selected,
    showDaysOutsideCurrentMonth,
    today: isToday
  });
  const classes2 = useUtilityClasses$5(ownerState);
  const utils = useUtils();
  const ref = React$6.useRef(null);
  const handleRef = useForkRef(ref, forwardedRef);
  useEnhancedEffect$1(() => {
    if (autoFocus && !disabled && !isAnimating && !outsideCurrentMonth) {
      ref.current.focus();
    }
  }, [autoFocus, disabled, isAnimating, outsideCurrentMonth]);
  const handleFocus = (event) => {
    if (onDayFocus) {
      onDayFocus(day);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  const handleClick = (event) => {
    if (!allowSameDateSelection && selected) {
      return;
    }
    if (!disabled) {
      onDaySelect(day, "finish");
    }
    if (onClick) {
      onClick(event);
    }
  };
  const theme = useTheme();
  function handleKeyDown(event) {
    if (onKeyDown !== void 0) {
      onKeyDown(event);
    }
    switch (event.key) {
      case "ArrowUp":
        onDayFocus(utils.addDays(day, -7));
        event.preventDefault();
        break;
      case "ArrowDown":
        onDayFocus(utils.addDays(day, 7));
        event.preventDefault();
        break;
      case "ArrowLeft":
        onDayFocus(utils.addDays(day, theme.direction === "ltr" ? -1 : 1));
        event.preventDefault();
        break;
      case "ArrowRight":
        onDayFocus(utils.addDays(day, theme.direction === "ltr" ? 1 : -1));
        event.preventDefault();
        break;
      case "Home":
        onDayFocus(utils.startOfWeek(day));
        event.preventDefault();
        break;
      case "End":
        onDayFocus(utils.endOfWeek(day));
        event.preventDefault();
        break;
      case "PageUp":
        onDayFocus(utils.getNextMonth(day));
        event.preventDefault();
        break;
      case "PageDown":
        onDayFocus(utils.getPreviousMonth(day));
        event.preventDefault();
        break;
    }
  }
  if (outsideCurrentMonth && !showDaysOutsideCurrentMonth) {
    return /* @__PURE__ */ jsx(PickersDayFiller, {
      className: clsx(classes2.root, classes2.hiddenDaySpacingFiller, className),
      ownerState
    });
  }
  return /* @__PURE__ */ jsx(PickersDayRoot, _extends({
    className: clsx(classes2.root, className),
    ownerState,
    ref: handleRef,
    centerRipple: true,
    disabled,
    "aria-label": !children ? utils.format(day, "fullDate") : void 0,
    tabIndex: selected ? 0 : -1,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown,
    onClick: handleClick
  }, other, {
    children: !children ? utils.format(day, "dayOfMonth") : children
  }));
});
const areDayPropsEqual = (prevProps, nextProps) => {
  return prevProps.autoFocus === nextProps.autoFocus && prevProps.isAnimating === nextProps.isAnimating && prevProps.today === nextProps.today && prevProps.disabled === nextProps.disabled && prevProps.selected === nextProps.selected && prevProps.disableMargin === nextProps.disableMargin && prevProps.showDaysOutsideCurrentMonth === nextProps.showDaysOutsideCurrentMonth && prevProps.disableHighlightToday === nextProps.disableHighlightToday && prevProps.className === nextProps.className && prevProps.outsideCurrentMonth === nextProps.outsideCurrentMonth && prevProps.onDayFocus === nextProps.onDayFocus && prevProps.onDaySelect === nextProps.onDaySelect;
};
var PickersDay$1 = /* @__PURE__ */ React$6.memo(PickersDay, areDayPropsEqual);
const _excluded$h = ["children", "className", "reduceAnimations", "slideDirection", "transKey"];
const classes$4 = generateUtilityClasses("PrivatePickersSlideTransition", ["root", "slideEnter-left", "slideEnter-right", "slideEnterActive", "slideEnterActive", "slideExit", "slideExitActiveLeft-left", "slideExitActiveLeft-right"]);
const slideAnimationDuration = 350;
const PickersSlideTransitionRoot = styled(TransitionGroup$1)(({
  theme
}) => {
  const slideTransition = theme.transitions.create("transform", {
    duration: slideAnimationDuration,
    easing: "cubic-bezier(0.35, 0.8, 0.4, 1)"
  });
  return {
    display: "block",
    position: "relative",
    overflowX: "hidden",
    "& > *": {
      position: "absolute",
      top: 0,
      right: 0,
      left: 0
    },
    [`& .${classes$4["slideEnter-left"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      zIndex: 1
    },
    [`& .${classes$4["slideEnter-right"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      zIndex: 1
    },
    [`& .${classes$4.slideEnterActive}`]: {
      transform: "translate(0%)",
      transition: slideTransition
    },
    [`& .${classes$4.slideExit}`]: {
      transform: "translate(0%)"
    },
    [`& .${classes$4["slideExitActiveLeft-left"]}`]: {
      willChange: "transform",
      transform: "translate(-100%)",
      transition: slideTransition,
      zIndex: 0
    },
    [`& .${classes$4["slideExitActiveLeft-right"]}`]: {
      willChange: "transform",
      transform: "translate(100%)",
      transition: slideTransition,
      zIndex: 0
    }
  };
});
const PickersSlideTransition = (_ref) => {
  let {
    children,
    className,
    reduceAnimations,
    slideDirection,
    transKey
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$h);
  if (reduceAnimations) {
    return /* @__PURE__ */ jsx("div", {
      className: clsx(classes$4.root, className),
      children
    });
  }
  const transitionClasses = {
    exit: classes$4.slideExit,
    enterActive: classes$4.slideEnterActive,
    enter: classes$4[`slideEnter-${slideDirection}`],
    exitActive: classes$4[`slideExitActiveLeft-${slideDirection}`]
  };
  return /* @__PURE__ */ jsx(PickersSlideTransitionRoot, {
    className: clsx(classes$4.root, className),
    childFactory: (element) => /* @__PURE__ */ React$6.cloneElement(element, {
      classNames: transitionClasses
    }),
    children: /* @__PURE__ */ jsx(CSSTransition$1, _extends({
      mountOnEnter: true,
      unmountOnExit: true,
      timeout: slideAnimationDuration,
      classNames: transitionClasses
    }, other, {
      children
    }), transKey)
  });
};
var SlideTransition = PickersSlideTransition;
var _span$1;
const weeksContainerHeight = (DAY_SIZE + DAY_MARGIN * 4) * 6;
const PickersCalendarDayHeader = styled("div")({
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
const PickersCalendarWeekDayLabel = styled(Typography$1)(({
  theme
}) => ({
  width: 36,
  height: 40,
  margin: "0 2px",
  textAlign: "center",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  color: theme.palette.text.secondary
}));
const PickersCalendarLoadingContainer = styled("div")({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  minHeight: weeksContainerHeight
});
const PickersCalendarSlideTransition = styled(SlideTransition)({
  minHeight: weeksContainerHeight
});
const PickersCalendarWeekContainer = styled("div")({
  overflow: "hidden"
});
const PickersCalendarWeek = styled("div")({
  margin: `${DAY_MARGIN}px 0`,
  display: "flex",
  justifyContent: "center"
});
function PickersCalendar(props) {
  const {
    allowSameDateSelection,
    autoFocus,
    onFocusedDayChange: changeFocusedDay,
    className,
    currentMonth,
    date,
    disabled,
    disableHighlightToday,
    focusedDay,
    isDateDisabled,
    isMonthSwitchingAnimating,
    loading,
    onChange,
    onMonthSwitchingAnimationEnd,
    readOnly,
    reduceAnimations,
    renderDay,
    renderLoading = () => _span$1 || (_span$1 = /* @__PURE__ */ jsx("span", {
      children: "..."
    })),
    showDaysOutsideCurrentMonth,
    slideDirection,
    TransitionProps
  } = props;
  const now2 = useNow();
  const utils = useUtils();
  const handleDaySelect = React$6.useCallback((day, isFinish = "finish") => {
    if (readOnly) {
      return;
    }
    const finalDate = Array.isArray(date) ? day : utils.mergeDateAndTime(day, date || now2);
    onChange(finalDate, isFinish);
  }, [date, now2, onChange, readOnly, utils]);
  const currentMonthNumber = utils.getMonth(currentMonth);
  const selectedDates = (Array.isArray(date) ? date : [date]).filter(Boolean).map((selectedDateItem) => selectedDateItem && utils.startOfDay(selectedDateItem));
  const transitionKey = currentMonthNumber;
  const slideNodeRef = React$6.useMemo(() => /* @__PURE__ */ React$6.createRef(), [transitionKey]);
  return /* @__PURE__ */ jsxs(React$6.Fragment, {
    children: [/* @__PURE__ */ jsx(PickersCalendarDayHeader, {
      children: utils.getWeekdays().map((day, i2) => /* @__PURE__ */ jsx(PickersCalendarWeekDayLabel, {
        "aria-hidden": true,
        variant: "caption",
        children: day.charAt(0).toUpperCase()
      }, day + i2.toString()))
    }), loading ? /* @__PURE__ */ jsx(PickersCalendarLoadingContainer, {
      children: renderLoading()
    }) : /* @__PURE__ */ jsx(PickersCalendarSlideTransition, _extends({
      transKey: transitionKey,
      onExited: onMonthSwitchingAnimationEnd,
      reduceAnimations,
      slideDirection,
      className
    }, TransitionProps, {
      nodeRef: slideNodeRef,
      children: /* @__PURE__ */ jsx(PickersCalendarWeekContainer, {
        ref: slideNodeRef,
        role: "grid",
        children: utils.getWeekArray(currentMonth).map((week) => /* @__PURE__ */ jsx(PickersCalendarWeek, {
          role: "row",
          children: week.map((day) => {
            const pickersDayProps = {
              key: day == null ? void 0 : day.toString(),
              day,
              isAnimating: isMonthSwitchingAnimating,
              disabled: disabled || isDateDisabled(day),
              allowSameDateSelection,
              autoFocus: autoFocus && focusedDay !== null && utils.isSameDay(day, focusedDay),
              today: utils.isSameDay(day, now2),
              outsideCurrentMonth: utils.getMonth(day) !== currentMonthNumber,
              selected: selectedDates.some((selectedDate) => selectedDate && utils.isSameDay(selectedDate, day)),
              disableHighlightToday,
              showDaysOutsideCurrentMonth,
              onDayFocus: changeFocusedDay,
              onDaySelect: handleDaySelect
            };
            return renderDay ? renderDay(day, selectedDates, pickersDayProps) : /* @__PURE__ */ jsx("div", {
              role: "cell",
              children: /* @__PURE__ */ jsx(PickersDay$1, _extends({}, pickersDayProps))
            }, pickersDayProps.key);
          })
        }, `week-${week[0]}`))
      })
    }))]
  });
}
function useViews({
  onChange,
  onViewChange,
  openTo,
  view,
  views
}) {
  var _views, _views2;
  const [openView, setOpenView] = useControlled({
    name: "Picker",
    state: "view",
    controlled: view,
    default: openTo && arrayIncludes(views, openTo) ? openTo : views[0]
  });
  const previousView = (_views = views[views.indexOf(openView) - 1]) != null ? _views : null;
  const nextView = (_views2 = views[views.indexOf(openView) + 1]) != null ? _views2 : null;
  const changeView = React$6.useCallback((newView) => {
    setOpenView(newView);
    if (onViewChange) {
      onViewChange(newView);
    }
  }, [setOpenView, onViewChange]);
  const openNext = React$6.useCallback(() => {
    if (nextView) {
      changeView(nextView);
    }
  }, [nextView, changeView]);
  const handleChangeAndOpenNext = React$6.useCallback((date, currentViewSelectionState) => {
    const isSelectionFinishedOnCurrentView = currentViewSelectionState === "finish";
    const globalSelectionState = isSelectionFinishedOnCurrentView && Boolean(nextView) ? "partial" : currentViewSelectionState;
    onChange(date, globalSelectionState);
    if (isSelectionFinishedOnCurrentView) {
      openNext();
    }
  }, [nextView, onChange, openNext]);
  return {
    handleChangeAndOpenNext,
    nextView,
    previousView,
    openNext,
    openView,
    setOpenView: changeView
  };
}
var ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
var ArrowLeftIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
}), "ArrowLeft");
var ArrowRightIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"
}), "ArrowRight");
const _excluded$g = ["children", "className", "components", "componentsProps", "isLeftDisabled", "isLeftHidden", "isRightDisabled", "isRightHidden", "leftArrowButtonText", "onLeftClick", "onRightClick", "rightArrowButtonText"];
const PickersArrowSwitcherRoot = styled("div")({
  display: "flex"
});
const PickersArrowSwitcherSpacer = styled("div")(({
  theme
}) => ({
  width: theme.spacing(3)
}));
const PickersArrowSwitcherButton = styled(IconButton)(({
  ownerState
}) => _extends({}, ownerState.hidden && {
  visibility: "hidden"
}));
const PickersArrowSwitcher = /* @__PURE__ */ React$6.forwardRef(function PickersArrowSwitcher2(props, ref) {
  const {
    children,
    className,
    components = {},
    componentsProps = {},
    isLeftDisabled,
    isLeftHidden,
    isRightDisabled,
    isRightHidden,
    leftArrowButtonText,
    onLeftClick,
    onRightClick,
    rightArrowButtonText
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const theme = useTheme();
  const isRtl = theme.direction === "rtl";
  const leftArrowButtonProps = componentsProps.leftArrowButton || {};
  const LeftArrowIcon = components.LeftArrowIcon || ArrowLeftIcon;
  const rightArrowButtonProps = componentsProps.rightArrowButton || {};
  const RightArrowIcon = components.RightArrowIcon || ArrowRightIcon;
  const ownerState = props;
  return /* @__PURE__ */ jsxs(PickersArrowSwitcherRoot, _extends({
    ref,
    className,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsx(PickersArrowSwitcherButton, _extends({
      as: components.LeftArrowButton,
      size: "small",
      "aria-label": leftArrowButtonText,
      title: leftArrowButtonText,
      disabled: isLeftDisabled,
      edge: "end",
      onClick: onLeftClick
    }, leftArrowButtonProps, {
      className: leftArrowButtonProps.className,
      ownerState: _extends({}, ownerState, leftArrowButtonProps, {
        hidden: isLeftHidden
      }),
      children: isRtl ? /* @__PURE__ */ jsx(RightArrowIcon, {}) : /* @__PURE__ */ jsx(LeftArrowIcon, {})
    })), children ? /* @__PURE__ */ jsx(Typography$1, {
      variant: "subtitle1",
      component: "span",
      children
    }) : /* @__PURE__ */ jsx(PickersArrowSwitcherSpacer, {
      ownerState
    }), /* @__PURE__ */ jsx(PickersArrowSwitcherButton, _extends({
      as: components.RightArrowButton,
      size: "small",
      "aria-label": rightArrowButtonText,
      title: rightArrowButtonText,
      edge: "start",
      disabled: isRightDisabled,
      onClick: onRightClick
    }, rightArrowButtonProps, {
      className: rightArrowButtonProps.className,
      ownerState: _extends({}, ownerState, rightArrowButtonProps, {
        hidden: isRightHidden
      }),
      children: isRtl ? /* @__PURE__ */ jsx(LeftArrowIcon, {}) : /* @__PURE__ */ jsx(RightArrowIcon, {})
    }))]
  }));
});
var PickersArrowSwitcher$1 = PickersArrowSwitcher;
const getMeridiem = (date, utils) => {
  if (!date) {
    return null;
  }
  return utils.getHours(date) >= 12 ? "pm" : "am";
};
const convertValueToMeridiem = (value, meridiem, ampm) => {
  if (ampm) {
    const currentMeridiem = value >= 12 ? "pm" : "am";
    if (currentMeridiem !== meridiem) {
      return meridiem === "am" ? value - 12 : value + 12;
    }
  }
  return value;
};
const convertToMeridiem = (time, meridiem, ampm, utils) => {
  const newHoursAmount = convertValueToMeridiem(utils.getHours(time), meridiem, ampm);
  return utils.setHours(time, newHoursAmount);
};
function getSecondsInDay(date, utils) {
  return utils.getHours(date) * 3600 + utils.getMinutes(date) * 60 + utils.getSeconds(date);
}
const createIsAfterIgnoreDatePart = (disableIgnoringDatePartForTimeValidation, utils) => (dateLeft, dateRight) => {
  if (disableIgnoringDatePartForTimeValidation) {
    return utils.isAfter(dateLeft, dateRight);
  }
  return getSecondsInDay(dateLeft, utils) > getSecondsInDay(dateRight, utils);
};
const validateTime$1 = (utils, value, {
  minTime,
  maxTime,
  shouldDisableTime,
  disableIgnoringDatePartForTimeValidation
}) => {
  const date = utils.date(value);
  const isAfterComparingFn = createIsAfterIgnoreDatePart(Boolean(disableIgnoringDatePartForTimeValidation), utils);
  if (value === null) {
    return null;
  }
  switch (true) {
    case !utils.isValid(value):
      return "invalidDate";
    case Boolean(minTime && isAfterComparingFn(minTime, date)):
      return "minTime";
    case Boolean(maxTime && isAfterComparingFn(date, maxTime)):
      return "maxTime";
    case Boolean(shouldDisableTime && shouldDisableTime(utils.getHours(date), "hours")):
      return "shouldDisableTime-hours";
    case Boolean(shouldDisableTime && shouldDisableTime(utils.getMinutes(date), "minutes")):
      return "shouldDisableTime-minutes";
    case Boolean(shouldDisableTime && shouldDisableTime(utils.getSeconds(date), "seconds")):
      return "shouldDisableTime-seconds";
    default:
      return null;
  }
};
function useNextMonthDisabled(month, {
  disableFuture,
  maxDate
}) {
  const utils = useUtils();
  return React$6.useMemo(() => {
    const now2 = utils.date();
    const lastEnabledMonth = utils.startOfMonth(disableFuture && utils.isBefore(now2, maxDate) ? now2 : maxDate);
    return !utils.isAfter(lastEnabledMonth, month);
  }, [disableFuture, maxDate, month, utils]);
}
function usePreviousMonthDisabled(month, {
  disablePast,
  minDate
}) {
  const utils = useUtils();
  return React$6.useMemo(() => {
    const now2 = utils.date();
    const firstEnabledMonth = utils.startOfMonth(disablePast && utils.isAfter(now2, minDate) ? now2 : minDate);
    return !utils.isBefore(firstEnabledMonth, month);
  }, [disablePast, minDate, month, utils]);
}
function useMeridiemMode(date, ampm, onChange) {
  const utils = useUtils();
  const meridiemMode = getMeridiem(date, utils);
  const handleMeridiemChange = React$6.useCallback((mode) => {
    const timeWithMeridiem = convertToMeridiem(date, mode, Boolean(ampm), utils);
    onChange(timeWithMeridiem, "partial");
  }, [ampm, date, onChange, utils]);
  return {
    meridiemMode,
    handleMeridiemChange
  };
}
const PickersCalendarHeaderRoot = styled("div")({
  display: "flex",
  alignItems: "center",
  marginTop: 16,
  marginBottom: 8,
  paddingLeft: 24,
  paddingRight: 12,
  maxHeight: 30,
  minHeight: 30
});
const PickersCalendarHeaderLabel = styled("div")(({
  theme
}) => _extends({
  display: "flex",
  maxHeight: 30,
  overflow: "hidden",
  alignItems: "center",
  cursor: "pointer",
  marginRight: "auto"
}, theme.typography.body1, {
  fontWeight: theme.typography.fontWeightMedium
}));
const PickersCalendarHeaderLabelItem = styled("div")({
  marginRight: 6
});
const PickersCalendarHeaderSwitchViewButton = styled(IconButton)({
  marginRight: "auto"
});
const PickersCalendarHeaderSwitchView = styled(ArrowDropDownIcon)(({
  theme,
  ownerState
}) => _extends({
  willChange: "transform",
  transition: theme.transitions.create("transform"),
  transform: "rotate(0deg)"
}, ownerState.openView === "year" && {
  transform: "rotate(180deg)"
}));
function getSwitchingViewAriaText(view) {
  return view === "year" ? "year view is open, switch to calendar view" : "calendar view is open, switch to year view";
}
function PickersCalendarHeader(props) {
  const {
    components = {},
    componentsProps = {},
    currentMonth: month,
    disabled,
    disableFuture,
    disablePast,
    getViewSwitchingButtonText = getSwitchingViewAriaText,
    leftArrowButtonText = "Previous month",
    maxDate,
    minDate,
    onMonthChange,
    onViewChange,
    openView: currentView,
    reduceAnimations,
    rightArrowButtonText = "Next month",
    views
  } = props;
  const utils = useUtils();
  const switchViewButtonProps = componentsProps.switchViewButton || {};
  const selectNextMonth = () => onMonthChange(utils.getNextMonth(month), "left");
  const selectPreviousMonth = () => onMonthChange(utils.getPreviousMonth(month), "right");
  const isNextMonthDisabled = useNextMonthDisabled(month, {
    disableFuture: disableFuture || disabled,
    maxDate
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(month, {
    disablePast: disablePast || disabled,
    minDate
  });
  const handleToggleView = () => {
    if (views.length === 1 || !onViewChange || disabled) {
      return;
    }
    if (views.length === 2) {
      onViewChange(views.find((view) => view !== currentView) || views[0]);
    } else {
      const nextIndexToOpen = views.indexOf(currentView) !== 0 ? 0 : 1;
      onViewChange(views[nextIndexToOpen]);
    }
  };
  if (views.length === 1 && views[0] === "year") {
    return null;
  }
  const ownerState = props;
  return /* @__PURE__ */ jsxs(PickersCalendarHeaderRoot, {
    ownerState,
    children: [/* @__PURE__ */ jsxs(PickersCalendarHeaderLabel, {
      role: "presentation",
      onClick: handleToggleView,
      ownerState,
      children: [/* @__PURE__ */ jsx(FadeTransitionGroup, {
        reduceAnimations,
        transKey: utils.format(month, "month"),
        children: /* @__PURE__ */ jsx(PickersCalendarHeaderLabelItem, {
          "aria-live": "polite",
          ownerState,
          children: utils.format(month, "month")
        })
      }), /* @__PURE__ */ jsx(FadeTransitionGroup, {
        reduceAnimations,
        transKey: utils.format(month, "year"),
        children: /* @__PURE__ */ jsx(PickersCalendarHeaderLabelItem, {
          "aria-live": "polite",
          ownerState,
          children: utils.format(month, "year")
        })
      }), views.length > 1 && !disabled && /* @__PURE__ */ jsx(PickersCalendarHeaderSwitchViewButton, _extends({
        size: "small",
        as: components.SwitchViewButton,
        "aria-label": getViewSwitchingButtonText(currentView)
      }, switchViewButtonProps, {
        children: /* @__PURE__ */ jsx(PickersCalendarHeaderSwitchView, {
          as: components.SwitchViewIcon,
          ownerState
        })
      }))]
    }), /* @__PURE__ */ jsx(Fade, {
      in: currentView === "day",
      children: /* @__PURE__ */ jsx(PickersArrowSwitcher$1, {
        leftArrowButtonText,
        rightArrowButtonText,
        components,
        componentsProps,
        onLeftClick: selectPreviousMonth,
        onRightClick: selectNextMonth,
        isLeftDisabled: isPreviousMonthDisabled,
        isRightDisabled: isNextMonthDisabled
      })
    })]
  });
}
const WrapperVariantContext = /* @__PURE__ */ React$6.createContext(null);
function getPickersYearUtilityClass(slot) {
  return generateUtilityClass("PrivatePickersYear", slot);
}
const pickersYearClasses = generateUtilityClasses("PrivatePickersYear", ["root", "modeMobile", "modeDesktop", "yearButton", "disabled", "selected"]);
const useUtilityClasses$4 = (ownerState) => {
  const {
    wrapperVariant,
    disabled,
    selected,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", wrapperVariant && `mode${capitalize(wrapperVariant)}`],
    yearButton: ["yearButton", disabled && "disabled", selected && "selected"]
  };
  return composeClasses(slots, getPickersYearUtilityClass, classes2);
};
const PickersYearRoot = styled("div")(({
  ownerState
}) => _extends({
  flexBasis: "33.3%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
}, (ownerState == null ? void 0 : ownerState.wrapperVariant) === "desktop" && {
  flexBasis: "25%"
}));
const PickersYearButton = styled("button")(({
  theme
}) => _extends({
  color: "unset",
  backgroundColor: "transparent",
  border: 0,
  outline: 0
}, theme.typography.subtitle1, {
  margin: "8px 0",
  height: 36,
  width: 72,
  borderRadius: 18,
  cursor: "pointer",
  "&:focus, &:hover": {
    backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity)
  },
  [`&.${pickersYearClasses.disabled}`]: {
    color: theme.palette.text.secondary
  },
  [`&.${pickersYearClasses.selected}`]: {
    color: theme.palette.primary.contrastText,
    backgroundColor: theme.palette.primary.main,
    "&:focus, &:hover": {
      backgroundColor: theme.palette.primary.dark
    }
  }
}));
const PickersYear = /* @__PURE__ */ React$6.forwardRef(function PickersYear2(props, forwardedRef) {
  const {
    autoFocus,
    className,
    children,
    disabled,
    onClick,
    onKeyDown,
    selected,
    value
  } = props;
  const ref = React$6.useRef(null);
  const refHandle = useForkRef(ref, forwardedRef);
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const ownerState = _extends({}, props, {
    wrapperVariant
  });
  const classes2 = useUtilityClasses$4(ownerState);
  React$6.useEffect(() => {
    if (autoFocus) {
      ref.current.focus();
    }
  }, [autoFocus]);
  return /* @__PURE__ */ jsx(PickersYearRoot, {
    className: clsx(classes2.root, className),
    ownerState,
    children: /* @__PURE__ */ jsx(PickersYearButton, {
      ref: refHandle,
      disabled,
      type: "button",
      tabIndex: selected ? 0 : -1,
      onClick: (event) => onClick(event, value),
      onKeyDown: (event) => onKeyDown(event, value),
      className: classes2.yearButton,
      ownerState,
      children
    })
  });
});
var PickersYear$1 = PickersYear;
function getYearPickerUtilityClass(slot) {
  return generateUtilityClass("MuiYearPicker", slot);
}
generateUtilityClasses("MuiYearPicker", ["root"]);
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getYearPickerUtilityClass, classes2);
};
const YearPickerRoot = styled("div", {
  name: "MuiYearPicker",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  overflowY: "auto",
  height: "100%",
  margin: "0 4px"
});
const YearPicker = /* @__PURE__ */ React$6.forwardRef(function YearPicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiYearPicker"
  });
  const {
    autoFocus,
    className,
    date,
    disabled,
    disableFuture,
    disablePast,
    isDateDisabled,
    maxDate,
    minDate,
    onChange,
    onFocusedDayChange,
    onYearChange,
    readOnly,
    shouldDisableYear
  } = props;
  const ownerState = props;
  const classes2 = useUtilityClasses$3(ownerState);
  const now2 = useNow();
  const theme = useTheme();
  const utils = useUtils();
  const selectedDate = date || now2;
  const currentYear = utils.getYear(selectedDate);
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const selectedYearRef = React$6.useRef(null);
  const [focusedYear, setFocusedYear] = React$6.useState(currentYear);
  const handleYearSelection = (event, year, isFinish = "finish") => {
    if (readOnly) {
      return;
    }
    const submitDate = (newDate2) => {
      onChange(newDate2, isFinish);
      if (onFocusedDayChange) {
        onFocusedDayChange(newDate2 || now2);
      }
      if (onYearChange) {
        onYearChange(newDate2);
      }
    };
    const newDate = utils.setYear(selectedDate, year);
    if (isDateDisabled(newDate)) {
      const closestEnabledDate = findClosestEnabledDate({
        utils,
        date: newDate,
        minDate,
        maxDate,
        disablePast: Boolean(disablePast),
        disableFuture: Boolean(disableFuture),
        shouldDisableDate: isDateDisabled
      });
      submitDate(closestEnabledDate || now2);
    } else {
      submitDate(newDate);
    }
  };
  const focusYear = React$6.useCallback((year) => {
    if (!isDateDisabled(utils.setYear(selectedDate, year))) {
      setFocusedYear(year);
    }
  }, [selectedDate, isDateDisabled, utils]);
  const yearsInRow = wrapperVariant === "desktop" ? 4 : 3;
  const handleKeyDown = (event, year) => {
    switch (event.key) {
      case "ArrowUp":
        focusYear(year - yearsInRow);
        event.preventDefault();
        break;
      case "ArrowDown":
        focusYear(year + yearsInRow);
        event.preventDefault();
        break;
      case "ArrowLeft":
        focusYear(year + (theme.direction === "ltr" ? -1 : 1));
        event.preventDefault();
        break;
      case "ArrowRight":
        focusYear(year + (theme.direction === "ltr" ? 1 : -1));
        event.preventDefault();
        break;
    }
  };
  return /* @__PURE__ */ jsx(YearPickerRoot, {
    ref,
    className: clsx(classes2.root, className),
    ownerState,
    children: utils.getYearRange(minDate, maxDate).map((year) => {
      const yearNumber = utils.getYear(year);
      const selected = yearNumber === currentYear;
      return /* @__PURE__ */ jsx(PickersYear$1, {
        selected,
        value: yearNumber,
        onClick: handleYearSelection,
        onKeyDown: handleKeyDown,
        autoFocus: autoFocus && yearNumber === focusedYear,
        ref: selected ? selectedYearRef : void 0,
        disabled: disabled || disablePast && utils.isBeforeYear(year, now2) || disableFuture && utils.isAfterYear(year, now2) || shouldDisableYear && shouldDisableYear(year),
        children: utils.format(year, "year")
      }, utils.format(year, "year"));
    })
  });
});
var YearPicker$1 = YearPicker;
const PickerView = styled("div")({
  overflowX: "hidden",
  width: DIALOG_WIDTH,
  maxHeight: VIEW_HEIGHT,
  display: "flex",
  flexDirection: "column",
  margin: "0 auto"
});
var PickerView$1 = PickerView;
var _span;
const _excluded$f = ["autoFocus", "onViewChange", "date", "disableFuture", "disablePast", "defaultCalendarMonth", "loading", "maxDate", "minDate", "onChange", "onMonthChange", "reduceAnimations", "renderLoading", "shouldDisableDate", "shouldDisableYear", "view", "views", "openTo", "className"];
function getCalendarPickerUtilityClass(slot) {
  return generateUtilityClass("MuiCalendarPicker", slot);
}
generateUtilityClasses("MuiCalendarPicker", ["root", "viewTransitionContainer"]);
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    viewTransitionContainer: ["viewTransitionContainer"]
  };
  return composeClasses(slots, getCalendarPickerUtilityClass, classes2);
};
const CalendarPickerRoot = styled(PickerView$1, {
  name: "MuiCalendarPicker",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "column"
});
const CalendarPickerViewTransitionContainer = styled(FadeTransitionGroup, {
  name: "MuiCalendarPicker",
  slot: "ViewTransitionContainer",
  overridesResolver: (props, styles) => styles.viewTransitionContainer
})({
  overflowY: "auto"
});
const defaultReduceAnimations = typeof navigator !== "undefined" && /(android)/i.test(navigator.userAgent);
const CalendarPicker = /* @__PURE__ */ React$6.forwardRef(function CalendarPicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCalendarPicker"
  });
  const {
    autoFocus,
    onViewChange,
    date,
    disableFuture = false,
    disablePast = false,
    defaultCalendarMonth,
    loading = false,
    maxDate: maxDateProp,
    minDate: minDateProp,
    onChange,
    onMonthChange,
    reduceAnimations = defaultReduceAnimations,
    renderLoading = () => _span || (_span = /* @__PURE__ */ jsx("span", {
      children: "..."
    })),
    shouldDisableDate,
    shouldDisableYear,
    view,
    views = ["year", "day"],
    openTo = "day",
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const minDate = minDateProp != null ? minDateProp : defaultDates.minDate;
  const maxDate = maxDateProp != null ? maxDateProp : defaultDates.maxDate;
  const {
    openView,
    setOpenView
  } = useViews({
    view,
    views,
    openTo,
    onChange,
    onViewChange
  });
  const {
    calendarState,
    changeFocusedDay,
    changeMonth,
    isDateDisabled,
    handleChangeMonth,
    onMonthSwitchingAnimationEnd
  } = useCalendarState({
    date,
    defaultCalendarMonth,
    reduceAnimations,
    onMonthChange,
    minDate,
    maxDate,
    shouldDisableDate,
    disablePast,
    disableFuture
  });
  React$6.useEffect(() => {
    if (date && isDateDisabled(date)) {
      const closestEnabledDate = findClosestEnabledDate({
        utils,
        date,
        minDate,
        maxDate,
        disablePast,
        disableFuture,
        shouldDisableDate: isDateDisabled
      });
      onChange(closestEnabledDate, "partial");
    }
  }, []);
  React$6.useEffect(() => {
    if (date) {
      changeMonth(date);
    }
  }, [date]);
  const ownerState = props;
  const classes2 = useUtilityClasses$2(ownerState);
  const monthPickerProps = {
    className,
    date,
    disabled: other.disabled,
    disablePast,
    disableFuture,
    onChange,
    minDate,
    maxDate,
    onMonthChange,
    readOnly: other.readOnly
  };
  return /* @__PURE__ */ jsxs(CalendarPickerRoot, {
    ref,
    className: clsx(classes2.root, className),
    ownerState,
    children: [/* @__PURE__ */ jsx(PickersCalendarHeader, _extends({}, other, {
      views,
      openView,
      currentMonth: calendarState.currentMonth,
      onViewChange: setOpenView,
      onMonthChange: (newMonth, direction) => handleChangeMonth({
        newMonth,
        direction
      }),
      minDate,
      maxDate,
      disablePast,
      disableFuture,
      reduceAnimations
    })), /* @__PURE__ */ jsx(CalendarPickerViewTransitionContainer, {
      reduceAnimations,
      className: classes2.viewTransitionContainer,
      transKey: openView,
      ownerState,
      children: /* @__PURE__ */ jsxs("div", {
        children: [openView === "year" && /* @__PURE__ */ jsx(YearPicker$1, _extends({}, other, {
          autoFocus,
          date,
          onChange,
          minDate,
          maxDate,
          disableFuture,
          disablePast,
          isDateDisabled,
          shouldDisableYear,
          onFocusedDayChange: changeFocusedDay
        })), openView === "month" && /* @__PURE__ */ jsx(MonthPicker$1, _extends({}, monthPickerProps)), openView === "day" && /* @__PURE__ */ jsx(PickersCalendar, _extends({}, other, calendarState, {
          autoFocus,
          onMonthSwitchingAnimationEnd,
          onFocusedDayChange: changeFocusedDay,
          reduceAnimations,
          date,
          onChange,
          isDateDisabled,
          loading,
          renderLoading
        }))]
      })
    })]
  });
});
var CalendarPicker$1 = CalendarPicker;
const CLOCK_WIDTH = 220;
const CLOCK_HOUR_WIDTH = 36;
const clockCenter = {
  x: CLOCK_WIDTH / 2,
  y: CLOCK_WIDTH / 2
};
const baseClockPoint = {
  x: clockCenter.x,
  y: 0
};
const cx = baseClockPoint.x - clockCenter.x;
const cy = baseClockPoint.y - clockCenter.y;
const rad2deg = (rad) => rad * (180 / Math.PI);
const getAngleValue = (step, offsetX, offsetY) => {
  const x2 = offsetX - clockCenter.x;
  const y2 = offsetY - clockCenter.y;
  const atan = Math.atan2(cx, cy) - Math.atan2(x2, y2);
  let deg = rad2deg(atan);
  deg = Math.round(deg / step) * step;
  deg %= 360;
  const value = Math.floor(deg / step) || 0;
  const delta = x2 ** 2 + y2 ** 2;
  const distance = Math.sqrt(delta);
  return {
    value,
    distance
  };
};
const getMinutes = (offsetX, offsetY, step = 1) => {
  const angleStep = step * 6;
  let {
    value
  } = getAngleValue(angleStep, offsetX, offsetY);
  value = value * step % 60;
  return value;
};
const getHours$1 = (offsetX, offsetY, ampm) => {
  const {
    value,
    distance
  } = getAngleValue(30, offsetX, offsetY);
  let hour = value || 12;
  if (!ampm) {
    if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
      hour += 12;
      hour %= 24;
    }
  } else {
    hour %= 12;
  }
  return hour;
};
const _excluded$e = ["className", "hasSelected", "isInner", "type", "value"];
const ClockPointerRoot = styled("div")(({
  theme,
  ownerState
}) => _extends({
  width: 2,
  backgroundColor: theme.palette.primary.main,
  position: "absolute",
  left: "calc(50% - 1px)",
  bottom: "50%",
  transformOrigin: "center bottom 0px"
}, ownerState.toAnimateTransform && {
  transition: theme.transitions.create(["transform", "height"])
}));
const ClockPointerThumb = styled("div")(({
  theme,
  ownerState
}) => _extends({
  width: 4,
  height: 4,
  backgroundColor: theme.palette.primary.contrastText,
  borderRadius: "50%",
  position: "absolute",
  top: -21,
  left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
  border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${theme.palette.primary.main}`,
  boxSizing: "content-box"
}, ownerState.hasSelected && {
  backgroundColor: theme.palette.primary.main
}));
class ClockPointer extends React$6.Component {
  constructor(...args) {
    super(...args);
    this.state = {
      toAnimateTransform: false,
      previousType: void 0
    };
  }
  render() {
    const _this$props = this.props, {
      className,
      isInner,
      type,
      value
    } = _this$props, other = _objectWithoutPropertiesLoose(_this$props, _excluded$e);
    const ownerState = _extends({}, this.props, this.state);
    const getAngleStyle = () => {
      const max = type === "hours" ? 12 : 60;
      let angle = 360 / max * value;
      if (type === "hours" && value > 12) {
        angle -= 360;
      }
      return {
        height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
        transform: `rotateZ(${angle}deg)`
      };
    };
    return /* @__PURE__ */ jsx(ClockPointerRoot, _extends({
      style: getAngleStyle(),
      className,
      ownerState
    }, other, {
      children: /* @__PURE__ */ jsx(ClockPointerThumb, {
        ownerState
      })
    }));
  }
}
ClockPointer.getDerivedStateFromProps = (nextProps, state) => {
  if (nextProps.type !== state.previousType) {
    return {
      toAnimateTransform: true,
      previousType: nextProps.type
    };
  }
  return {
    toAnimateTransform: false,
    previousType: nextProps.type
  };
};
var ClockPointer$1 = ClockPointer;
var _ClockPin, _Typography, _Typography2;
const ClockRoot = styled("div")(({
  theme
}) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  margin: theme.spacing(2)
}));
const ClockClock = styled("div")({
  backgroundColor: "rgba(0,0,0,.07)",
  borderRadius: "50%",
  height: 220,
  width: 220,
  flexShrink: 0,
  position: "relative",
  pointerEvents: "none"
});
const ClockSquareMask = styled("div")({
  width: "100%",
  height: "100%",
  position: "absolute",
  pointerEvents: "auto",
  outline: 0,
  touchAction: "none",
  userSelect: "none",
  "@media (pointer: fine)": {
    cursor: "pointer",
    borderRadius: "50%"
  },
  "&:active": {
    cursor: "move"
  }
});
const ClockPin = styled("div")(({
  theme
}) => ({
  width: 6,
  height: 6,
  borderRadius: "50%",
  backgroundColor: theme.palette.primary.main,
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)"
}));
const ClockAmButton = styled(IconButton)(({
  theme,
  ownerState
}) => _extends({
  zIndex: 1,
  position: "absolute",
  bottom: ownerState.ampmInClock ? 64 : 8,
  left: 8
}, ownerState.meridiemMode === "am" && {
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  "&:hover": {
    backgroundColor: theme.palette.primary.light
  }
}));
const ClockPmButton = styled(IconButton)(({
  theme,
  ownerState
}) => _extends({
  zIndex: 1,
  position: "absolute",
  bottom: ownerState.ampmInClock ? 64 : 8,
  right: 8
}, ownerState.meridiemMode === "pm" && {
  backgroundColor: theme.palette.primary.main,
  color: theme.palette.primary.contrastText,
  "&:hover": {
    backgroundColor: theme.palette.primary.light
  }
}));
function Clock(props) {
  const {
    ampm,
    ampmInClock,
    autoFocus,
    children,
    date,
    getClockLabelText,
    handleMeridiemChange,
    isTimeDisabled,
    meridiemMode,
    minutesStep = 1,
    onChange,
    selectedId,
    type,
    value
  } = props;
  const ownerState = props;
  const utils = useUtils();
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const isMoving = React$6.useRef(false);
  const isSelectedTimeDisabled = isTimeDisabled(value, type);
  const isPointerInner = !ampm && type === "hours" && (value < 1 || value > 12);
  const handleValueChange = (newValue, isFinish) => {
    if (isTimeDisabled(newValue, type)) {
      return;
    }
    onChange(newValue, isFinish);
  };
  const setTime = (event, isFinish) => {
    let {
      offsetX,
      offsetY
    } = event;
    if (offsetX === void 0) {
      const rect = event.target.getBoundingClientRect();
      offsetX = event.changedTouches[0].clientX - rect.left;
      offsetY = event.changedTouches[0].clientY - rect.top;
    }
    const newSelectedValue = type === "seconds" || type === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours$1(offsetX, offsetY, Boolean(ampm));
    handleValueChange(newSelectedValue, isFinish);
  };
  const handleTouchMove = (event) => {
    isMoving.current = true;
    setTime(event, "shallow");
  };
  const handleTouchEnd = (event) => {
    if (isMoving.current) {
      setTime(event, "finish");
      isMoving.current = false;
    }
  };
  const handleMouseMove = (event) => {
    if (event.buttons > 0) {
      setTime(event.nativeEvent, "shallow");
    }
  };
  const handleMouseUp = (event) => {
    if (isMoving.current) {
      isMoving.current = false;
    }
    setTime(event.nativeEvent, "finish");
  };
  const hasSelected = React$6.useMemo(() => {
    if (type === "hours") {
      return true;
    }
    return value % 5 === 0;
  }, [type, value]);
  const keyboardControlStep = type === "minutes" ? minutesStep : 1;
  const listboxRef = React$6.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      listboxRef.current.focus();
    }
  }, [autoFocus]);
  const handleKeyDown = (event) => {
    if (isMoving.current) {
      return;
    }
    switch (event.key) {
      case "Home":
        handleValueChange(0, "partial");
        event.preventDefault();
        break;
      case "End":
        handleValueChange(type === "minutes" ? 59 : 23, "partial");
        event.preventDefault();
        break;
      case "ArrowUp":
        handleValueChange(value + keyboardControlStep, "partial");
        event.preventDefault();
        break;
      case "ArrowDown":
        handleValueChange(value - keyboardControlStep, "partial");
        event.preventDefault();
        break;
    }
  };
  return /* @__PURE__ */ jsxs(ClockRoot, {
    children: [/* @__PURE__ */ jsxs(ClockClock, {
      children: [/* @__PURE__ */ jsx(ClockSquareMask, {
        onTouchMove: handleTouchMove,
        onTouchEnd: handleTouchEnd,
        onMouseUp: handleMouseUp,
        onMouseMove: handleMouseMove
      }), !isSelectedTimeDisabled && /* @__PURE__ */ jsxs(React$6.Fragment, {
        children: [_ClockPin || (_ClockPin = /* @__PURE__ */ jsx(ClockPin, {})), date && /* @__PURE__ */ jsx(ClockPointer$1, {
          type,
          value,
          isInner: isPointerInner,
          hasSelected
        })]
      }), /* @__PURE__ */ jsx("div", {
        "aria-activedescendant": selectedId,
        "aria-label": getClockLabelText(type, date, utils),
        ref: listboxRef,
        role: "listbox",
        onKeyDown: handleKeyDown,
        tabIndex: 0,
        children
      })]
    }), ampm && (wrapperVariant === "desktop" || ampmInClock) && /* @__PURE__ */ jsxs(React$6.Fragment, {
      children: [/* @__PURE__ */ jsx(ClockAmButton, {
        onClick: () => handleMeridiemChange("am"),
        disabled: meridiemMode === null,
        ownerState,
        children: _Typography || (_Typography = /* @__PURE__ */ jsx(Typography$1, {
          variant: "caption",
          children: "AM"
        }))
      }), /* @__PURE__ */ jsx(ClockPmButton, {
        disabled: meridiemMode === null,
        onClick: () => handleMeridiemChange("pm"),
        ownerState,
        children: _Typography2 || (_Typography2 = /* @__PURE__ */ jsx(Typography$1, {
          variant: "caption",
          children: "PM"
        }))
      })]
    })]
  });
}
const _excluded$d = ["className", "disabled", "index", "inner", "label", "selected"];
const classes$3 = generateUtilityClasses("PrivateClockNumber", ["selected", "disabled"]);
const ClockNumberRoot = styled("span")(({
  theme,
  ownerState
}) => _extends({
  height: CLOCK_HOUR_WIDTH,
  width: CLOCK_HOUR_WIDTH,
  position: "absolute",
  left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  color: theme.palette.text.primary,
  fontFamily: theme.typography.fontFamily,
  "&:focused": {
    backgroundColor: theme.palette.background.paper
  },
  [`&.${classes$3.selected}`]: {
    color: theme.palette.primary.contrastText
  },
  [`&.${classes$3.disabled}`]: {
    pointerEvents: "none",
    color: theme.palette.text.disabled
  }
}, ownerState.inner && _extends({}, theme.typography.body2, {
  color: theme.palette.text.secondary
})));
function ClockNumber(props) {
  const {
    className,
    disabled,
    index,
    inner,
    label,
    selected
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const ownerState = props;
  const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
  const length = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
  const x2 = Math.round(Math.cos(angle) * length);
  const y2 = Math.round(Math.sin(angle) * length);
  return /* @__PURE__ */ jsx(ClockNumberRoot, _extends({
    className: clsx(className, selected && classes$3.selected, disabled && classes$3.disabled),
    "aria-disabled": disabled ? true : void 0,
    "aria-selected": selected ? true : void 0,
    role: "option",
    style: {
      transform: `translate(${x2}px, ${y2 + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
    },
    ownerState
  }, other, {
    children: label
  }));
}
const getHourNumbers = ({
  ampm,
  date,
  getClockNumberText,
  isDisabled,
  selectedId,
  utils
}) => {
  const currentHours = date ? utils.getHours(date) : null;
  const hourNumbers = [];
  const startHour = ampm ? 1 : 0;
  const endHour = ampm ? 12 : 23;
  const isSelected = (hour) => {
    if (currentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return currentHours === 12 || currentHours === 0;
      }
      return currentHours === hour || currentHours - 12 === hour;
    }
    return currentHours === hour;
  };
  for (let hour = startHour; hour <= endHour; hour += 1) {
    let label = hour.toString();
    if (hour === 0) {
      label = "00";
    }
    const inner = !ampm && (hour === 0 || hour > 12);
    label = utils.formatNumber(label);
    const selected = isSelected(hour);
    hourNumbers.push(/* @__PURE__ */ jsx(ClockNumber, {
      id: selected ? selectedId : void 0,
      index: hour,
      inner,
      selected,
      disabled: isDisabled(hour),
      label,
      "aria-label": getClockNumberText(label)
    }, hour));
  }
  return hourNumbers;
};
const getMinutesNumbers = ({
  utils,
  value,
  isDisabled,
  getClockNumberText,
  selectedId
}) => {
  const f2 = utils.formatNumber;
  return [[5, f2("05")], [10, f2("10")], [15, f2("15")], [20, f2("20")], [25, f2("25")], [30, f2("30")], [35, f2("35")], [40, f2("40")], [45, f2("45")], [50, f2("50")], [55, f2("55")], [0, f2("00")]].map(([numberValue, label], index) => {
    const selected = numberValue === value;
    return /* @__PURE__ */ jsx(ClockNumber, {
      label,
      id: selected ? selectedId : void 0,
      index: index + 1,
      inner: false,
      disabled: isDisabled(numberValue),
      selected,
      "aria-label": getClockNumberText(label)
    }, numberValue);
  });
};
function getClockPickerUtilityClass(slot) {
  return generateUtilityClass("MuiClockPicker", slot);
}
generateUtilityClasses("MuiClockPicker", ["arrowSwitcher"]);
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    arrowSwitcher: ["arrowSwitcher"]
  };
  return composeClasses(slots, getClockPickerUtilityClass, classes2);
};
const ClockPickerArrowSwitcher = styled(PickersArrowSwitcher$1, {
  name: "MuiClockPicker",
  slot: "ArrowSwitcher",
  overridesResolver: (props, styles) => styles.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
});
const defaultGetClockLabelText = (view, time, adapter) => `Select ${view}. ${time === null ? "No time selected" : `Selected time is ${adapter.format(time, "fullTime")}`}`;
const defaultGetMinutesClockNumberText = (minutes) => `${minutes} minutes`;
const defaultGetHoursClockNumberText = (hours) => `${hours} hours`;
const defaultGetSecondsClockNumberText = (seconds) => `${seconds} seconds`;
function ClockPicker(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClockPicker"
  });
  const {
    ampm = false,
    ampmInClock = false,
    autoFocus,
    components,
    componentsProps,
    date,
    disableIgnoringDatePartForTimeValidation = false,
    getClockLabelText = defaultGetClockLabelText,
    getHoursClockNumberText = defaultGetHoursClockNumberText,
    getMinutesClockNumberText = defaultGetMinutesClockNumberText,
    getSecondsClockNumberText = defaultGetSecondsClockNumberText,
    leftArrowButtonText = "open previous view",
    maxTime,
    minTime,
    minutesStep = 1,
    nextViewAvailable,
    onChange,
    openNextView,
    openPreviousView,
    previousViewAvailable,
    rightArrowButtonText = "open next view",
    shouldDisableTime,
    showViewSwitcher,
    view
  } = props;
  const now2 = useNow();
  const utils = useUtils();
  const midnight = utils.setSeconds(utils.setMinutes(utils.setHours(now2, 0), 0), 0);
  const dateOrMidnight = date || midnight;
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(dateOrMidnight, ampm, onChange);
  const isTimeDisabled = React$6.useCallback((rawValue, viewType) => {
    if (date === null) {
      return false;
    }
    const validateTimeValue = (getRequestedTimePoint) => {
      const isAfterComparingFn = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
      return Boolean(minTime && isAfterComparingFn(minTime, getRequestedTimePoint("end")) || maxTime && isAfterComparingFn(getRequestedTimePoint("start"), maxTime) || shouldDisableTime && shouldDisableTime(rawValue, viewType));
    };
    switch (viewType) {
      case "hours": {
        const hoursWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        return validateTimeValue((when) => pipe((currentDate) => utils.setHours(currentDate, hoursWithMeridiem), (dateWithHours) => utils.setMinutes(dateWithHours, when === "start" ? 0 : 59), (dateWithMinutes) => utils.setSeconds(dateWithMinutes, when === "start" ? 0 : 59))(date));
      }
      case "minutes":
        return validateTimeValue((when) => pipe((currentDate) => utils.setMinutes(currentDate, rawValue), (dateWithMinutes) => utils.setSeconds(dateWithMinutes, when === "start" ? 0 : 59))(date));
      case "seconds":
        return validateTimeValue(() => utils.setSeconds(date, rawValue));
      default:
        throw new Error("not supported");
    }
  }, [ampm, date, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, shouldDisableTime, utils]);
  const selectedId = useId();
  const viewProps = React$6.useMemo(() => {
    switch (view) {
      case "hours": {
        const handleHoursChange = (value, isFinish) => {
          const valueWithMeridiem = convertValueToMeridiem(value, meridiemMode, ampm);
          onChange(utils.setHours(dateOrMidnight, valueWithMeridiem), isFinish);
        };
        return {
          onChange: handleHoursChange,
          value: utils.getHours(dateOrMidnight),
          children: getHourNumbers({
            date,
            utils,
            ampm,
            onChange: handleHoursChange,
            getClockNumberText: getHoursClockNumberText,
            isDisabled: (value) => isTimeDisabled(value, "hours"),
            selectedId
          })
        };
      }
      case "minutes": {
        const minutesValue = utils.getMinutes(dateOrMidnight);
        const handleMinutesChange = (value, isFinish) => {
          onChange(utils.setMinutes(dateOrMidnight, value), isFinish);
        };
        return {
          value: minutesValue,
          onChange: handleMinutesChange,
          children: getMinutesNumbers({
            utils,
            value: minutesValue,
            onChange: handleMinutesChange,
            getClockNumberText: getMinutesClockNumberText,
            isDisabled: (value) => isTimeDisabled(value, "minutes"),
            selectedId
          })
        };
      }
      case "seconds": {
        const secondsValue = utils.getSeconds(dateOrMidnight);
        const handleSecondsChange = (value, isFinish) => {
          onChange(utils.setSeconds(dateOrMidnight, value), isFinish);
        };
        return {
          value: secondsValue,
          onChange: handleSecondsChange,
          children: getMinutesNumbers({
            utils,
            value: secondsValue,
            onChange: handleSecondsChange,
            getClockNumberText: getSecondsClockNumberText,
            isDisabled: (value) => isTimeDisabled(value, "seconds"),
            selectedId
          })
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [view, utils, date, ampm, getHoursClockNumberText, getMinutesClockNumberText, getSecondsClockNumberText, meridiemMode, onChange, dateOrMidnight, isTimeDisabled, selectedId]);
  const ownerState = props;
  const classes2 = useUtilityClasses$1(ownerState);
  return /* @__PURE__ */ jsxs(React$6.Fragment, {
    children: [showViewSwitcher && /* @__PURE__ */ jsx(ClockPickerArrowSwitcher, {
      className: classes2.arrowSwitcher,
      leftArrowButtonText,
      rightArrowButtonText,
      components,
      componentsProps,
      onLeftClick: openPreviousView,
      onRightClick: openNextView,
      isLeftDisabled: previousViewAvailable,
      isRightDisabled: nextViewAvailable,
      ownerState
    }), /* @__PURE__ */ jsx(Clock, _extends({
      autoFocus,
      date,
      ampmInClock,
      type: view,
      ampm,
      getClockLabelText,
      minutesStep,
      isTimeDisabled,
      meridiemMode,
      handleMeridiemChange,
      selectedId
    }, viewProps))]
  });
}
var PenIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
}), "Pen");
var CalendarIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
}), "Calendar");
var ClockIcon = createSvgIcon(/* @__PURE__ */ jsxs(React$6.Fragment, {
  children: [/* @__PURE__ */ jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Clock");
var _ClockIcon, _CalendarIcon, _PenIcon;
const classes$2 = generateUtilityClasses("PrivatePickersToolbar", ["root", "dateTitleContainer"]);
const PickersToolbarRoot = styled("div")(({
  theme,
  ownerState
}) => _extends({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "space-between",
  padding: theme.spacing(2, 3)
}, ownerState.isLandscape && {
  height: "auto",
  maxWidth: 160,
  padding: 16,
  justifyContent: "flex-start",
  flexWrap: "wrap"
}));
const PickersToolbarGrid = styled(Grid$1)({
  flex: 1
});
const getViewTypeIcon = (viewType) => viewType === "clock" ? _ClockIcon || (_ClockIcon = /* @__PURE__ */ jsx(ClockIcon, {
  color: "inherit"
})) : _CalendarIcon || (_CalendarIcon = /* @__PURE__ */ jsx(CalendarIcon, {
  color: "inherit"
}));
function defaultGetKeyboardInputSwitchingButtonText(isKeyboardInputOpen, viewType) {
  return isKeyboardInputOpen ? `text input view is open, go to ${viewType} view` : `${viewType} view is open, go to text input view`;
}
const PickersToolbar = /* @__PURE__ */ React$6.forwardRef(function PickersToolbar2(props, ref) {
  const {
    children,
    className,
    getMobileKeyboardInputViewButtonText = defaultGetKeyboardInputSwitchingButtonText,
    isLandscape,
    isMobileKeyboardViewOpen,
    landscapeDirection = "column",
    penIconClassName,
    toggleMobileKeyboardView,
    toolbarTitle,
    viewType = "calendar"
  } = props;
  const ownerState = props;
  return /* @__PURE__ */ jsxs(PickersToolbarRoot, {
    ref,
    className: clsx(classes$2.root, className),
    ownerState,
    children: [/* @__PURE__ */ jsx(Typography$1, {
      color: "text.secondary",
      variant: "overline",
      children: toolbarTitle
    }), /* @__PURE__ */ jsxs(PickersToolbarGrid, {
      container: true,
      justifyContent: "space-between",
      className: classes$2.dateTitleContainer,
      direction: isLandscape ? landscapeDirection : "row",
      alignItems: isLandscape ? "flex-start" : "flex-end",
      children: [children, /* @__PURE__ */ jsx(IconButton, {
        onClick: toggleMobileKeyboardView,
        className: penIconClassName,
        color: "inherit",
        "aria-label": getMobileKeyboardInputViewButtonText(isMobileKeyboardViewOpen, viewType),
        children: isMobileKeyboardViewOpen ? getViewTypeIcon(viewType) : _PenIcon || (_PenIcon = /* @__PURE__ */ jsx(PenIcon, {
          color: "inherit"
        }))
      })]
    })]
  });
});
var PickersToolbar$1 = PickersToolbar;
const _excluded$c = ["onClick", "onTouchStart"];
const PickersPopperRoot = styled(Popper)(({
  theme
}) => ({
  zIndex: theme.zIndex.modal
}));
const PickersPopperPaper = styled(Paper)(({
  ownerState
}) => _extends({
  transformOrigin: "top center",
  outline: 0
}, ownerState.placement === "top" && {
  transformOrigin: "bottom center"
}));
const PickersPopperAction = styled(DialogActions)(({
  ownerState
}) => _extends({}, ownerState.clearable ? {
  justifyContent: "flex-start",
  "& > *:first-of-type": {
    marginRight: "auto"
  }
} : {
  padding: 0
}));
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function useClickAwayListener(active, onClickAway) {
  const movedRef = React$6.useRef(false);
  const syntheticEventRef = React$6.useRef(false);
  const nodeRef = React$6.useRef(null);
  const activatedRef = React$6.useRef(false);
  React$6.useEffect(() => {
    if (!active) {
      return void 0;
    }
    function armClickAwayListener() {
      activatedRef.current = true;
    }
    document.addEventListener("mousedown", armClickAwayListener, true);
    document.addEventListener("touchstart", armClickAwayListener, true);
    return () => {
      document.removeEventListener("mousedown", armClickAwayListener, true);
      document.removeEventListener("touchstart", armClickAwayListener, true);
      activatedRef.current = false;
    };
  }, [active]);
  const handleClickAway = useEventCallback$1((event) => {
    if (!activatedRef.current) {
      return;
    }
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
    }
    if (!insideDOM && !insideReactTree) {
      onClickAway(event);
    }
  });
  const handleSynthetic = () => {
    syntheticEventRef.current = true;
  };
  React$6.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener("touchstart", handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener("touchstart", handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  React$6.useEffect(() => {
    if (active) {
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener("click", handleClickAway);
      return () => {
        doc.removeEventListener("click", handleClickAway);
        syntheticEventRef.current = false;
      };
    }
    return void 0;
  }, [active, handleClickAway]);
  return [nodeRef, handleSynthetic, handleSynthetic];
}
const PickersPopper = (props) => {
  var _Button;
  const {
    anchorEl,
    children,
    containerRef = null,
    onClose,
    onClear,
    clearable = false,
    clearText = "Clear",
    open,
    PopperProps,
    role,
    TransitionComponent = Grow,
    TrapFocusProps,
    PaperProps = {}
  } = props;
  React$6.useEffect(() => {
    function handleKeyDown(nativeEvent) {
      if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
        onClose();
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [onClose]);
  const lastFocusedElementRef = React$6.useRef(null);
  React$6.useEffect(() => {
    if (role === "tooltip") {
      return;
    }
    if (open) {
      lastFocusedElementRef.current = document.activeElement;
    } else if (lastFocusedElementRef.current && lastFocusedElementRef.current instanceof HTMLElement) {
      lastFocusedElementRef.current.focus();
    }
  }, [open, role]);
  const [clickAwayRef, onPaperClick, onPaperTouchStart] = useClickAwayListener(open, onClose);
  const paperRef = React$6.useRef(null);
  const handleRef = useForkRef(paperRef, containerRef);
  const handlePaperRef = useForkRef(handleRef, clickAwayRef);
  const ownerState = props;
  const {
    onClick: onPaperClickProp,
    onTouchStart: onPaperTouchStartProp
  } = PaperProps, otherPaperProps = _objectWithoutPropertiesLoose(PaperProps, _excluded$c);
  return /* @__PURE__ */ jsx(PickersPopperRoot, _extends({
    transition: true,
    role,
    open,
    anchorEl,
    ownerState
  }, PopperProps, {
    children: ({
      TransitionProps,
      placement
    }) => /* @__PURE__ */ jsx(TrapFocus, _extends({
      open,
      disableAutoFocus: true,
      disableEnforceFocus: role === "tooltip",
      isEnabled: () => true
    }, TrapFocusProps, {
      children: /* @__PURE__ */ jsx(TransitionComponent, _extends({}, TransitionProps, {
        children: /* @__PURE__ */ jsxs(PickersPopperPaper, _extends({
          tabIndex: -1,
          elevation: 8,
          ref: handlePaperRef,
          onClick: (event) => {
            onPaperClick(event);
            if (onPaperClickProp) {
              onPaperClickProp(event);
            }
          },
          onTouchStart: (event) => {
            onPaperTouchStart(event);
            if (onPaperTouchStartProp) {
              onPaperTouchStartProp(event);
            }
          },
          ownerState: _extends({}, ownerState, {
            placement
          })
        }, otherPaperProps, {
          children: [children, /* @__PURE__ */ jsx(PickersPopperAction, {
            ownerState,
            children: clearable && (_Button || (_Button = /* @__PURE__ */ jsx(Button, {
              onClick: onClear,
              children: clearText
            })))
          })]
        }))
      }))
    }))
  }));
};
var PickersPopper$1 = PickersPopper;
function DesktopWrapper(props) {
  const {
    children,
    DateInputProps,
    KeyboardDateInputComponent,
    onDismiss,
    open,
    PopperProps,
    PaperProps,
    TransitionComponent,
    onClear,
    clearText,
    clearable
  } = props;
  const ownInputRef = React$6.useRef(null);
  const inputRef = useForkRef(DateInputProps.inputRef, ownInputRef);
  return /* @__PURE__ */ jsxs(WrapperVariantContext.Provider, {
    value: "desktop",
    children: [/* @__PURE__ */ jsx(KeyboardDateInputComponent, _extends({}, DateInputProps, {
      inputRef
    })), /* @__PURE__ */ jsx(PickersPopper$1, {
      role: "dialog",
      open,
      anchorEl: ownInputRef.current,
      TransitionComponent,
      PopperProps,
      PaperProps,
      onClose: onDismiss,
      onClear,
      clearText,
      clearable,
      children
    })]
  });
}
const useRifm = (props) => {
  const [, refresh] = useReducer((c2) => c2 + 1, 0);
  const valueRef = useRef(null);
  const {
    replace: replace3,
    append
  } = props;
  const userValue = replace3 ? replace3(props.format(props.value)) : props.format(props.value);
  const isDeleleteButtonDownRef = useRef(false);
  const onChange = (evt) => {
    const eventValue = evt.target.value;
    valueRef.current = [
      eventValue,
      evt.target,
      eventValue.length > userValue.length,
      isDeleleteButtonDownRef.current,
      userValue === props.format(eventValue)
    ];
    refresh();
  };
  {
    useLayoutEffect(() => {
      if (valueRef.current == null)
        return;
      let [
        eventValue,
        input,
        isSizeIncreaseOperation,
        isDeleleteButtonDown,
        isNoOperation
      ] = valueRef.current;
      valueRef.current = null;
      const deleteWasNoOp = isDeleleteButtonDown && isNoOperation;
      const valueAfterSelectionStart = eventValue.slice(input.selectionStart);
      const acceptedCharIndexAfterDelete = valueAfterSelectionStart.search(props.accept || /\d/g);
      const charsToSkipAfterDelete = acceptedCharIndexAfterDelete !== -1 ? acceptedCharIndexAfterDelete : 0;
      const clean = (str) => (str.match(props.accept || /\d/g) || []).join("");
      const valueBeforeSelectionStart = clean(eventValue.substr(0, input.selectionStart));
      const getCursorPosition = (val) => {
        let start = 0;
        let cleanPos = 0;
        for (let i2 = 0; i2 !== valueBeforeSelectionStart.length; ++i2) {
          let newPos = val.indexOf(valueBeforeSelectionStart[i2], start) + 1;
          let newCleanPos = clean(val).indexOf(valueBeforeSelectionStart[i2], cleanPos) + 1;
          if (newCleanPos - cleanPos > 1) {
            newPos = start;
            newCleanPos = cleanPos;
          }
          cleanPos = Math.max(newCleanPos, cleanPos);
          start = Math.max(start, newPos);
        }
        return start;
      };
      if (props.mask === true && isSizeIncreaseOperation && !isNoOperation) {
        let start = getCursorPosition(eventValue);
        const c2 = clean(eventValue.substr(start))[0];
        start = eventValue.indexOf(c2, start);
        eventValue = `${eventValue.substr(0, start)}${eventValue.substr(start + 1)}`;
      }
      let formattedValue = props.format(eventValue);
      if (append != null && input.selectionStart === eventValue.length && !isNoOperation) {
        if (isSizeIncreaseOperation) {
          formattedValue = append(formattedValue);
        } else {
          if (clean(formattedValue.slice(-1)) === "") {
            formattedValue = formattedValue.slice(0, -1);
          }
        }
      }
      const replacedValue = replace3 ? replace3(formattedValue) : formattedValue;
      if (userValue === replacedValue) {
        refresh();
      } else {
        props.onChange(replacedValue);
      }
      return () => {
        let start = getCursorPosition(formattedValue);
        if (props.mask != null && (isSizeIncreaseOperation || isDeleleteButtonDown && !deleteWasNoOp)) {
          while (formattedValue[start] && clean(formattedValue[start]) === "") {
            start += 1;
          }
        }
        input.selectionStart = input.selectionEnd = start + (deleteWasNoOp ? 1 + charsToSkipAfterDelete : 0);
      };
    });
  }
  useEffect(() => {
    const handleKeyDown = (evt) => {
      if (evt.code === "Delete") {
        isDeleleteButtonDownRef.current = true;
      }
    };
    const handleKeyUp = (evt) => {
      if (evt.code === "Delete") {
        isDeleleteButtonDownRef.current = false;
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    };
  }, []);
  return {
    value: valueRef.current != null ? valueRef.current[0] : userValue,
    onChange
  };
};
function getTextFieldAriaText(rawValue, utils) {
  return rawValue && utils.isValid(utils.date(rawValue)) ? `Choose date, selected date is ${utils.format(utils.date(rawValue), "fullDate")}` : "Choose date";
}
const getDisplayDate = (utils, value, inputFormat) => {
  const date = utils.date(value);
  const isEmpty = value === null;
  if (isEmpty) {
    return "";
  }
  return utils.isValid(date) ? utils.formatByString(date, inputFormat) : "";
};
function pick12hOr24hFormat(userFormat, ampm, formats) {
  if (userFormat) {
    return userFormat;
  }
  if (typeof ampm === "undefined") {
    return formats.localized;
  }
  return ampm ? formats["12h"] : formats["24h"];
}
const MASK_USER_INPUT_SYMBOL = "_";
const staticDateWith2DigitTokens = "2019-11-21T22:30:00.000";
const staticDateWith1DigitTokens = "2019-01-01T09:00:00.000";
function checkMaskIsValidForCurrentFormat(mask, format2, acceptRegex, utils) {
  const formattedDateWith1Digit = utils.formatByString(utils.date(staticDateWith1DigitTokens), format2);
  const inferredFormatPatternWith1Digits = formattedDateWith1Digit.replace(acceptRegex, MASK_USER_INPUT_SYMBOL);
  const inferredFormatPatternWith2Digits = utils.formatByString(utils.date(staticDateWith2DigitTokens), format2).replace(acceptRegex, "_");
  const isMaskValid = inferredFormatPatternWith2Digits === mask && inferredFormatPatternWith1Digits === mask;
  if (!isMaskValid && utils.lib !== "luxon" && false) {
    console.warn(`The mask "${mask}" you passed is not valid for the format used ${format2}. Falling down to uncontrolled not-masked input.`);
  }
  return isMaskValid;
}
const maskedDateFormatter = (mask, acceptRegexp) => (value) => {
  return value.split("").map((char, i2) => {
    acceptRegexp.lastIndex = 0;
    if (i2 > mask.length - 1) {
      return "";
    }
    const maskChar = mask[i2];
    const nextMaskChar = mask[i2 + 1];
    const acceptedChar = acceptRegexp.test(char) ? char : "";
    const formattedChar = maskChar === MASK_USER_INPUT_SYMBOL ? acceptedChar : maskChar + acceptedChar;
    if (i2 === value.length - 1 && nextMaskChar && nextMaskChar !== MASK_USER_INPUT_SYMBOL) {
      return formattedChar ? formattedChar + nextMaskChar : "";
    }
    return formattedChar;
  }).join("");
};
function useMaskedInput({
  acceptRegex = /[\d]/gi,
  disabled,
  disableMaskedInput,
  ignoreInvalidInputs,
  inputFormat,
  inputProps,
  label,
  mask,
  onChange,
  rawValue,
  readOnly,
  rifmFormatter,
  TextFieldProps,
  validationError
}) {
  const utils = useUtils();
  const [isFocused, setIsFocused] = React$6.useState(false);
  const formatHelperText = utils.getFormatHelperText(inputFormat);
  const shouldUseMaskedInput = React$6.useMemo(() => {
    if (!mask || disableMaskedInput) {
      return false;
    }
    return checkMaskIsValidForCurrentFormat(mask, inputFormat, acceptRegex, utils);
  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);
  const formatter = React$6.useMemo(() => shouldUseMaskedInput && mask ? maskedDateFormatter(mask, acceptRegex) : (st) => st, [acceptRegex, mask, shouldUseMaskedInput]);
  const currentInputValue = getDisplayDate(utils, rawValue, inputFormat);
  const [innerInputValue, setInnerInputValue] = React$6.useState(currentInputValue);
  const previousInputValueRef = React$6.useRef(currentInputValue);
  React$6.useEffect(() => {
    previousInputValueRef.current = currentInputValue;
  }, [currentInputValue]);
  const notTyping = !isFocused;
  const valueChanged = previousInputValueRef.current !== currentInputValue;
  if (notTyping && valueChanged && (rawValue === null || utils.isValid(rawValue))) {
    if (currentInputValue !== innerInputValue) {
      setInnerInputValue(currentInputValue);
    }
  }
  const handleChange = (text) => {
    const finalString = text === "" || text === mask ? "" : text;
    setInnerInputValue(finalString);
    const date = finalString === null ? null : utils.parse(finalString, inputFormat);
    if (ignoreInvalidInputs && !utils.isValid(date)) {
      return;
    }
    onChange(date, finalString || void 0);
  };
  const rifmProps = useRifm({
    value: innerInputValue,
    onChange: handleChange,
    format: rifmFormatter || formatter
  });
  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {
    value: innerInputValue,
    onChange: (event) => {
      handleChange(event.currentTarget.value);
    }
  };
  return _extends({
    label,
    disabled,
    error: validationError,
    inputProps: _extends({}, inputStateArgs, {
      disabled,
      placeholder: formatHelperText,
      readOnly,
      type: shouldUseMaskedInput ? "tel" : "text"
    }, inputProps, {
      onFocus: createDelegatedEventHandler(() => {
        setIsFocused(true);
      }, inputProps == null ? void 0 : inputProps.onFocus),
      onBlur: createDelegatedEventHandler(() => {
        setIsFocused(false);
      }, inputProps == null ? void 0 : inputProps.onBlur)
    })
  }, TextFieldProps);
}
const _excluded$b = ["components", "disableOpenPicker", "getOpenDialogAriaText", "InputAdornmentProps", "InputProps", "inputRef", "openPicker", "OpenPickerButtonProps", "renderInput"];
const KeyboardDateInput = /* @__PURE__ */ React$6.forwardRef(function KeyboardDateInput2(props, ref) {
  const {
    components = {},
    disableOpenPicker,
    getOpenDialogAriaText = getTextFieldAriaText,
    InputAdornmentProps,
    InputProps,
    inputRef,
    openPicker,
    OpenPickerButtonProps,
    renderInput
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const utils = useUtils();
  const textFieldProps = useMaskedInput(other);
  const adornmentPosition = (InputAdornmentProps == null ? void 0 : InputAdornmentProps.position) || "end";
  const OpenPickerIcon = components.OpenPickerIcon || CalendarIcon;
  return renderInput(_extends({
    ref,
    inputRef
  }, textFieldProps, {
    InputProps: _extends({}, InputProps, {
      [`${adornmentPosition}Adornment`]: disableOpenPicker ? void 0 : /* @__PURE__ */ jsx(InputAdornment, _extends({
        position: adornmentPosition
      }, InputAdornmentProps, {
        children: /* @__PURE__ */ jsx(IconButton, _extends({
          edge: adornmentPosition,
          disabled: other.disabled || other.readOnly,
          "aria-label": getOpenDialogAriaText(other.rawValue, utils)
        }, OpenPickerButtonProps, {
          onClick: openPicker,
          children: /* @__PURE__ */ jsx(OpenPickerIcon, {})
        }))
      }))
    })
  }));
});
function getOrientation() {
  if (typeof window === "undefined") {
    return "portrait";
  }
  if (window.screen && window.screen.orientation && window.screen.orientation.angle) {
    return Math.abs(window.screen.orientation.angle) === 90 ? "landscape" : "portrait";
  }
  if (window.orientation) {
    return Math.abs(Number(window.orientation)) === 90 ? "landscape" : "portrait";
  }
  return "portrait";
}
function useIsLandscape(views, customOrientation) {
  const [orientation, setOrientation] = React$6.useState(getOrientation);
  useEnhancedEffect$1(() => {
    const eventHandler = () => {
      setOrientation(getOrientation());
    };
    window.addEventListener("orientationchange", eventHandler);
    return () => {
      window.removeEventListener("orientationchange", eventHandler);
    };
  }, []);
  if (arrayIncludes(views, ["hours", "minutes", "seconds"])) {
    return false;
  }
  const orientationToUse = customOrientation || orientation;
  return orientationToUse === "landscape";
}
const _excluded$a = ["autoFocus", "className", "date", "DateInputProps", "isMobileKeyboardViewOpen", "onDateChange", "onViewChange", "openTo", "orientation", "showToolbar", "toggleMobileKeyboardView", "ToolbarComponent", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views"];
const MobileKeyboardInputView = styled("div")({
  padding: "16px 24px"
});
const PickerRoot = styled("div")(({
  ownerState
}) => _extends({
  display: "flex",
  flexDirection: "column"
}, ownerState.isLandscape && {
  flexDirection: "row"
}));
const MobileKeyboardTextFieldProps = {
  fullWidth: true
};
const isDatePickerView = (view) => view === "year" || view === "month" || view === "day";
const isTimePickerView = (view) => view === "hours" || view === "minutes" || view === "seconds";
function Picker(props) {
  const {
    autoFocus,
    date,
    DateInputProps,
    isMobileKeyboardViewOpen,
    onDateChange,
    onViewChange,
    openTo,
    orientation,
    showToolbar,
    toggleMobileKeyboardView,
    ToolbarComponent = () => null,
    toolbarFormat,
    toolbarPlaceholder,
    toolbarTitle,
    views
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const isLandscape = useIsLandscape(views, orientation);
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const toShowToolbar = typeof showToolbar === "undefined" ? wrapperVariant !== "desktop" : showToolbar;
  const handleDateChange = React$6.useCallback((newDate, selectionState) => {
    onDateChange(newDate, wrapperVariant, selectionState);
  }, [onDateChange, wrapperVariant]);
  const handleViewChange = React$6.useCallback((newView) => {
    if (isMobileKeyboardViewOpen) {
      toggleMobileKeyboardView();
    }
    if (onViewChange) {
      onViewChange(newView);
    }
  }, [isMobileKeyboardViewOpen, onViewChange, toggleMobileKeyboardView]);
  const {
    openView,
    nextView,
    previousView,
    setOpenView,
    handleChangeAndOpenNext
  } = useViews({
    view: void 0,
    views,
    openTo,
    onChange: handleDateChange,
    onViewChange: handleViewChange
  });
  return /* @__PURE__ */ jsxs(PickerRoot, {
    ownerState: {
      isLandscape
    },
    children: [toShowToolbar && /* @__PURE__ */ jsx(ToolbarComponent, _extends({}, other, {
      views,
      isLandscape,
      date,
      onChange: handleDateChange,
      setOpenView,
      openView,
      toolbarTitle,
      toolbarFormat,
      toolbarPlaceholder,
      isMobileKeyboardViewOpen,
      toggleMobileKeyboardView
    })), /* @__PURE__ */ jsx(PickerView$1, {
      children: isMobileKeyboardViewOpen ? /* @__PURE__ */ jsx(MobileKeyboardInputView, {
        children: /* @__PURE__ */ jsx(KeyboardDateInput, _extends({}, DateInputProps, {
          ignoreInvalidInputs: true,
          disableOpenPicker: true,
          TextFieldProps: MobileKeyboardTextFieldProps
        }))
      }) : /* @__PURE__ */ jsxs(React$6.Fragment, {
        children: [isDatePickerView(openView) && /* @__PURE__ */ jsx(CalendarPicker$1, _extends({
          autoFocus,
          date,
          onViewChange: setOpenView,
          onChange: handleChangeAndOpenNext,
          view: openView,
          views: views.filter(isDatePickerView)
        }, other)), isTimePickerView(openView) && /* @__PURE__ */ jsx(ClockPicker, _extends({}, other, {
          autoFocus,
          date,
          view: openView,
          onChange: handleChangeAndOpenNext,
          openNextView: () => setOpenView(nextView),
          openPreviousView: () => setOpenView(previousView),
          nextViewAvailable: !nextView,
          previousViewAvailable: !previousView || isDatePickerView(previousView),
          showViewSwitcher: wrapperVariant === "desktop"
        }))]
      })
    })]
  });
}
const _excluded$9 = ["minDate", "maxDate", "disableFuture", "shouldDisableDate", "disablePast"];
function validateDateTime(utils, value, _ref) {
  let {
    minDate,
    maxDate,
    disableFuture,
    shouldDisableDate,
    disablePast
  } = _ref, timeValidationProps = _objectWithoutPropertiesLoose(_ref, _excluded$9);
  const dateValidationResult = validateDate$1(utils, value, {
    minDate,
    maxDate,
    disableFuture,
    shouldDisableDate,
    disablePast
  });
  if (dateValidationResult !== null) {
    return dateValidationResult;
  }
  return validateTime$1(utils, value, timeValidationProps);
}
function isSameDateOrTimeError(a2, b2) {
  return a2 === b2;
}
function useValidation(props, validate, isSameError = isSameDateOrTimeError) {
  const {
    value,
    onError
  } = props;
  const utils = useUtils();
  const previousValidationErrorRef = React$6.useRef(null);
  const validationError = validate(utils, value, props);
  React$6.useEffect(() => {
    if (onError && !isSameError(validationError, previousValidationErrorRef.current)) {
      onError(validationError, value);
    }
    previousValidationErrorRef.current = validationError;
  }, [isSameError, onError, previousValidationErrorRef, validationError, value]);
  return validationError;
}
function useDateTimeValidation(props) {
  return useValidation(props, validateDateTime, isSameDateOrTimeError);
}
function useOpenState({
  open,
  onOpen,
  onClose
}) {
  const isControllingOpenProp = React$6.useRef(typeof open === "boolean").current;
  const [openState, setIsOpenState] = React$6.useState(false);
  React$6.useEffect(() => {
    if (isControllingOpenProp) {
      if (typeof open !== "boolean") {
        throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");
      }
      setIsOpenState(open);
    }
  }, [isControllingOpenProp, open]);
  const setIsOpen = React$6.useCallback((newIsOpen) => {
    if (!isControllingOpenProp) {
      setIsOpenState(newIsOpen);
    }
    if (newIsOpen && onOpen) {
      onOpen();
    }
    if (!newIsOpen && onClose) {
      onClose();
    }
  }, [isControllingOpenProp, onOpen, onClose]);
  return {
    isOpen: openState,
    setIsOpen
  };
}
function usePickerState(props, valueManager2) {
  const {
    disableCloseOnSelect,
    onAccept,
    onChange,
    value
  } = props;
  const utils = useUtils();
  const {
    isOpen,
    setIsOpen
  } = useOpenState(props);
  function initDraftableDate(date) {
    return {
      committed: date,
      draft: date
    };
  }
  const parsedDateValue = valueManager2.parseInput(utils, value);
  const [draftState, dispatch] = React$6.useReducer((state, action) => {
    switch (action.type) {
      case "reset":
        return initDraftableDate(action.payload);
      case "update":
        return _extends({}, state, {
          draft: action.payload
        });
      default:
        return state;
    }
  }, parsedDateValue, initDraftableDate);
  if (!valueManager2.areValuesEqual(utils, draftState.committed, parsedDateValue)) {
    dispatch({
      type: "reset",
      payload: parsedDateValue
    });
  }
  const [initialDate, setInitialDate] = React$6.useState(draftState.committed);
  const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = React$6.useState(false);
  const acceptDate = React$6.useCallback((acceptedDate, needClosePicker) => {
    onChange(acceptedDate);
    if (needClosePicker) {
      setIsOpen(false);
      setInitialDate(acceptedDate);
      if (onAccept) {
        onAccept(acceptedDate);
      }
    }
  }, [onAccept, onChange, setIsOpen]);
  const wrapperProps = React$6.useMemo(() => ({
    open: isOpen,
    onClear: () => acceptDate(valueManager2.emptyValue, true),
    onAccept: () => acceptDate(draftState.draft, true),
    onDismiss: () => acceptDate(initialDate, true),
    onSetToday: () => {
      const now2 = utils.date();
      dispatch({
        type: "update",
        payload: now2
      });
      acceptDate(now2, !disableCloseOnSelect);
    }
  }), [acceptDate, disableCloseOnSelect, isOpen, utils, draftState.draft, valueManager2.emptyValue, initialDate]);
  const pickerProps = React$6.useMemo(() => ({
    date: draftState.draft,
    isMobileKeyboardViewOpen,
    toggleMobileKeyboardView: () => setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen),
    onDateChange: (newDate, wrapperVariant, selectionState = "partial") => {
      dispatch({
        type: "update",
        payload: newDate
      });
      if (selectionState === "partial") {
        acceptDate(newDate, false);
      }
      if (selectionState === "finish") {
        const shouldCloseOnSelect = !(disableCloseOnSelect != null ? disableCloseOnSelect : wrapperVariant === "mobile");
        acceptDate(newDate, shouldCloseOnSelect);
      }
    }
  }), [acceptDate, disableCloseOnSelect, isMobileKeyboardViewOpen, draftState.draft]);
  const inputProps = React$6.useMemo(() => ({
    onChange,
    open: isOpen,
    rawValue: value,
    openPicker: () => setIsOpen(true)
  }), [onChange, isOpen, value, setIsOpen]);
  const pickerState = {
    pickerProps,
    inputProps,
    wrapperProps
  };
  React$6.useDebugValue(pickerState, () => ({
    MuiPickerState: {
      pickerDraft: draftState,
      other: pickerState
    }
  }));
  return pickerState;
}
const PickersModalDialogRoot = styled(Dialog$1)({
  [`& .${dialogClasses.container}`]: {
    outline: 0
  },
  [`& .${dialogClasses.paper}`]: {
    outline: 0,
    minWidth: DIALOG_WIDTH
  }
});
const PickersModalDialogContent = styled(DialogContent$1)({
  "&:first-of-type": {
    padding: 0
  }
});
const PickersModalDialogActions = styled(DialogActions)(({
  ownerState
}) => _extends({}, (ownerState.clearable || ownerState.showTodayButton) && {
  justifyContent: "flex-start",
  "& > *:first-of-type": {
    marginRight: "auto"
  }
}));
const PickersModalDialog = (props) => {
  const {
    cancelText = "Cancel",
    children,
    clearable = false,
    clearText = "Clear",
    DialogProps = {},
    okText = "OK",
    onAccept,
    onClear,
    onDismiss,
    onSetToday,
    open,
    showTodayButton = false,
    todayText = "Today"
  } = props;
  const ownerState = props;
  return /* @__PURE__ */ jsxs(PickersModalDialogRoot, _extends({
    open,
    onClose: onDismiss
  }, DialogProps, {
    children: [/* @__PURE__ */ jsx(PickersModalDialogContent, {
      children
    }), /* @__PURE__ */ jsxs(PickersModalDialogActions, {
      ownerState,
      children: [clearable && /* @__PURE__ */ jsx(Button, {
        onClick: onClear,
        children: clearText
      }), showTodayButton && /* @__PURE__ */ jsx(Button, {
        onClick: onSetToday,
        children: todayText
      }), cancelText && /* @__PURE__ */ jsx(Button, {
        onClick: onDismiss,
        children: cancelText
      }), okText && /* @__PURE__ */ jsx(Button, {
        onClick: onAccept,
        children: okText
      })]
    })]
  }));
};
var PickersModalDialog$1 = PickersModalDialog;
const _excluded$8 = ["cancelText", "children", "clearable", "clearText", "DateInputProps", "DialogProps", "okText", "onAccept", "onClear", "onDismiss", "onSetToday", "open", "PureDateInputComponent", "showTodayButton", "todayText"];
function MobileWrapper(props) {
  const {
    cancelText,
    children,
    clearable,
    clearText,
    DateInputProps,
    DialogProps,
    okText,
    onAccept,
    onClear,
    onDismiss,
    onSetToday,
    open,
    PureDateInputComponent,
    showTodayButton,
    todayText
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  return /* @__PURE__ */ jsxs(WrapperVariantContext.Provider, {
    value: "mobile",
    children: [/* @__PURE__ */ jsx(PureDateInputComponent, _extends({}, other, DateInputProps)), /* @__PURE__ */ jsx(PickersModalDialog$1, {
      cancelText,
      clearable,
      clearText,
      DialogProps,
      okText,
      onAccept,
      onClear,
      onDismiss,
      onSetToday,
      open,
      showTodayButton,
      todayText,
      children
    })]
  });
}
const PureDateInput = /* @__PURE__ */ React$6.forwardRef(function PureDateInput2(props, ref) {
  const {
    disabled,
    getOpenDialogAriaText = getTextFieldAriaText,
    inputFormat,
    InputProps,
    inputRef,
    label,
    openPicker: onOpen,
    rawValue,
    renderInput,
    TextFieldProps = {},
    validationError
  } = props;
  const utils = useUtils();
  const PureDateInputProps = React$6.useMemo(() => _extends({}, InputProps, {
    readOnly: true
  }), [InputProps]);
  const inputValue = getDisplayDate(utils, rawValue, inputFormat);
  return renderInput(_extends({
    label,
    disabled,
    ref,
    inputRef,
    error: validationError,
    InputProps: PureDateInputProps,
    inputProps: _extends({
      disabled,
      readOnly: true,
      "aria-readonly": true,
      "aria-label": getOpenDialogAriaText(rawValue, utils),
      value: inputValue
    }, !props.readOnly && {
      onClick: onOpen
    }, {
      onKeyDown: onSpaceOrEnter(onOpen)
    })
  }, TextFieldProps));
});
PureDateInput.propTypes = {
  getOpenDialogAriaText: PropTypes$5.func,
  renderInput: PropTypes$5.func.isRequired
};
const _excluded$7 = ["className", "selected", "value"];
const classes$1 = generateUtilityClasses("PrivatePickersToolbarText", ["selected"]);
const PickersToolbarTextRoot = styled(Typography$1)(({
  theme
}) => ({
  transition: theme.transitions.create("color"),
  color: theme.palette.text.secondary,
  [`&.${classes$1.selected}`]: {
    color: theme.palette.text.primary
  }
}));
const PickersToolbarText = /* @__PURE__ */ React$6.forwardRef(function PickersToolbarText2(props, ref) {
  const {
    className,
    selected,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
  return /* @__PURE__ */ jsx(PickersToolbarTextRoot, _extends({
    ref,
    className: clsx(className, selected && classes$1.selected),
    component: "span"
  }, other, {
    children: value
  }));
});
var PickersToolbarText$1 = PickersToolbarText;
const _excluded$6 = ["align", "className", "selected", "typographyClassName", "value", "variant"];
const PickersToolbarButtonRoot = styled(Button)({
  padding: 0,
  minWidth: 16,
  textTransform: "none"
});
const PickersToolbarButton = /* @__PURE__ */ React$6.forwardRef(function PickersToolbarButton2(props, ref) {
  const {
    align,
    className,
    selected,
    typographyClassName,
    value,
    variant
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
  return /* @__PURE__ */ jsx(PickersToolbarButtonRoot, _extends({
    variant: "text",
    ref,
    className
  }, other, {
    children: /* @__PURE__ */ jsx(PickersToolbarText$1, {
      align,
      className: typographyClassName,
      variant,
      value,
      selected
    })
  }));
});
var PickersToolbarButton$1 = PickersToolbarButton;
const _excluded$5 = ["ampm", "inputFormat", "maxDate", "maxDateTime", "maxTime", "minDate", "minDateTime", "minTime", "openTo", "orientation", "views"];
function useDateTimePickerDefaultizedProps(_ref, name) {
  let {
    ampm,
    inputFormat,
    maxDate: maxDateProp,
    maxDateTime,
    maxTime,
    minDate: minDateProp,
    minDateTime,
    minTime,
    openTo = "day",
    orientation = "portrait",
    views = ["year", "day", "hours", "minutes"]
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$5);
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const minDate = minDateProp != null ? minDateProp : defaultDates.minDate;
  const maxDate = maxDateProp != null ? maxDateProp : defaultDates.maxDate;
  const willUseAmPm = ampm != null ? ampm : utils.is12HourCycleInCurrentLocale();
  if (orientation !== "portrait") {
    throw new Error("We are not supporting custom orientation for DateTimePicker yet :(");
  }
  return useThemeProps({
    props: _extends({
      openTo,
      views,
      ampm: willUseAmPm,
      ampmInClock: true,
      orientation,
      showToolbar: true,
      allowSameDateSelection: true,
      minDate: minDateTime != null ? minDateTime : minDate,
      minTime: minDateTime != null ? minDateTime : minTime,
      maxDate: maxDateTime != null ? maxDateTime : maxDate,
      maxTime: maxDateTime != null ? maxDateTime : maxTime,
      disableIgnoringDatePartForTimeValidation: Boolean(minDateTime || maxDateTime),
      acceptRegex: willUseAmPm ? /[\dap]/gi : /\d/gi,
      mask: "__/__/____ __:__",
      disableMaskedInput: willUseAmPm,
      inputFormat: pick12hOr24hFormat(inputFormat, willUseAmPm, {
        localized: utils.formats.keyboardDateTime,
        "12h": utils.formats.keyboardDateTime12h,
        "24h": utils.formats.keyboardDateTime24h
      })
    }, other),
    name
  });
}
var TimeIcon = createSvgIcon(/* @__PURE__ */ jsxs(React$6.Fragment, {
  children: [/* @__PURE__ */ jsx("path", {
    d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  }), /* @__PURE__ */ jsx("path", {
    d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"
  })]
}), "Time");
var DateRangeIcon = createSvgIcon(/* @__PURE__ */ jsx("path", {
  d: "M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"
}), "DateRange");
var _DateRangeIcon, _TimeIcon;
const viewToTab = (openView) => {
  if (["day", "month", "year"].includes(openView)) {
    return "date";
  }
  return "time";
};
const tabToView = (tab) => {
  if (tab === "date") {
    return "day";
  }
  return "hours";
};
const DateTimePickerTabsRoot = styled(Tabs)(({
  ownerState,
  theme
}) => _extends({
  boxShadow: `0 -1px 0 0 inset ${theme.palette.divider}`
}, ownerState.wrapperVariant === "desktop" && {
  order: 1,
  boxShadow: `0 1px 0 0 inset ${theme.palette.divider}`,
  [`& .${tabsClasses.indicator}`]: {
    bottom: "auto",
    top: 0
  }
}));
const DateTimePickerTabs = (props) => {
  const {
    dateRangeIcon = _DateRangeIcon || (_DateRangeIcon = /* @__PURE__ */ jsx(DateRangeIcon, {})),
    onChange,
    timeIcon = _TimeIcon || (_TimeIcon = /* @__PURE__ */ jsx(TimeIcon, {})),
    view
  } = props;
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const ownerState = _extends({}, props, {
    wrapperVariant
  });
  const handleChange = (event, value) => {
    onChange(tabToView(value));
  };
  return /* @__PURE__ */ jsxs(DateTimePickerTabsRoot, {
    ownerState,
    variant: "fullWidth",
    value: viewToTab(view),
    onChange: handleChange,
    children: [/* @__PURE__ */ jsx(Tab, {
      value: "date",
      "aria-label": "pick date",
      icon: /* @__PURE__ */ jsx(React$6.Fragment, {
        children: dateRangeIcon
      })
    }), /* @__PURE__ */ jsx(Tab, {
      value: "time",
      "aria-label": "pick time",
      icon: /* @__PURE__ */ jsx(React$6.Fragment, {
        children: timeIcon
      })
    })]
  });
};
var DateTimePickerTabs$1 = DateTimePickerTabs;
var _DateTimePickerToolba, _DateTimePickerToolba2;
const _excluded$4 = ["ampm", "date", "dateRangeIcon", "hideTabs", "isMobileKeyboardViewOpen", "onChange", "openView", "setOpenView", "timeIcon", "toggleMobileKeyboardView", "toolbarFormat", "toolbarPlaceholder", "toolbarTitle", "views"];
const classes = generateUtilityClasses("PrivateDateTimePickerToolbar", ["penIcon"]);
const DateTimePickerToolbarRoot = styled(PickersToolbar$1)({
  paddingLeft: 16,
  paddingRight: 16,
  justifyContent: "space-around",
  [`& .${classes.penIcon}`]: {
    position: "absolute",
    top: 8,
    right: 8
  }
});
const DateTimePickerToolbarDateContainer = styled("div")({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start"
});
const DateTimePickerToolbarTimeContainer = styled("div")({
  display: "flex"
});
const DateTimePickerToolbarSeparator = styled(PickersToolbarText$1)({
  margin: "0 4px 0 2px",
  cursor: "default"
});
const DateTimePickerToolbar = (props) => {
  const {
    ampm,
    date,
    dateRangeIcon,
    hideTabs,
    isMobileKeyboardViewOpen,
    openView,
    setOpenView,
    timeIcon,
    toggleMobileKeyboardView,
    toolbarFormat,
    toolbarPlaceholder = "\u2013\u2013",
    toolbarTitle = "Select date & time",
    views
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const utils = useUtils();
  const wrapperVariant = React$6.useContext(WrapperVariantContext);
  const showTabs = wrapperVariant === "desktop" ? true : !hideTabs && typeof window !== "undefined" && window.innerHeight > 667;
  const formatHours = (time) => ampm ? utils.format(time, "hours12h") : utils.format(time, "hours24h");
  const dateText = React$6.useMemo(() => {
    if (!date) {
      return toolbarPlaceholder;
    }
    if (toolbarFormat) {
      return utils.formatByString(date, toolbarFormat);
    }
    return utils.format(date, "shortDate");
  }, [date, toolbarFormat, toolbarPlaceholder, utils]);
  return /* @__PURE__ */ jsxs(React$6.Fragment, {
    children: [wrapperVariant !== "desktop" && /* @__PURE__ */ jsxs(DateTimePickerToolbarRoot, _extends({
      toolbarTitle,
      penIconClassName: classes.penIcon,
      isMobileKeyboardViewOpen,
      toggleMobileKeyboardView
    }, other, {
      isLandscape: false,
      children: [/* @__PURE__ */ jsxs(DateTimePickerToolbarDateContainer, {
        children: [views.includes("year") && /* @__PURE__ */ jsx(PickersToolbarButton$1, {
          tabIndex: -1,
          variant: "subtitle1",
          onClick: () => setOpenView("year"),
          selected: openView === "year",
          value: date ? utils.format(date, "year") : "\u2013"
        }), views.includes("day") && /* @__PURE__ */ jsx(PickersToolbarButton$1, {
          tabIndex: -1,
          variant: "h4",
          onClick: () => setOpenView("day"),
          selected: openView === "day",
          value: dateText
        })]
      }), /* @__PURE__ */ jsxs(DateTimePickerToolbarTimeContainer, {
        children: [views.includes("hours") && /* @__PURE__ */ jsx(PickersToolbarButton$1, {
          variant: "h3",
          onClick: () => setOpenView("hours"),
          selected: openView === "hours",
          value: date ? formatHours(date) : "--"
        }), views.includes("minutes") && /* @__PURE__ */ jsxs(React$6.Fragment, {
          children: [_DateTimePickerToolba || (_DateTimePickerToolba = /* @__PURE__ */ jsx(DateTimePickerToolbarSeparator, {
            variant: "h3",
            value: ":"
          })), /* @__PURE__ */ jsx(PickersToolbarButton$1, {
            variant: "h3",
            onClick: () => setOpenView("minutes"),
            selected: openView === "minutes",
            value: date ? utils.format(date, "minutes") : "--"
          })]
        }), views.includes("seconds") && /* @__PURE__ */ jsxs(React$6.Fragment, {
          children: [_DateTimePickerToolba2 || (_DateTimePickerToolba2 = /* @__PURE__ */ jsx(DateTimePickerToolbarSeparator, {
            variant: "h3",
            value: ":"
          })), /* @__PURE__ */ jsx(PickersToolbarButton$1, {
            variant: "h3",
            onClick: () => setOpenView("seconds"),
            selected: openView === "seconds",
            value: date ? utils.format(date, "seconds") : "--"
          })]
        })]
      })]
    })), showTabs && /* @__PURE__ */ jsx(DateTimePickerTabs$1, {
      dateRangeIcon,
      timeIcon,
      view: openView,
      onChange: setOpenView
    })]
  });
};
var DateTimePickerToolbar$1 = DateTimePickerToolbar;
const _excluded$3 = ["onChange", "PopperProps", "ToolbarComponent", "TransitionComponent", "value"];
const valueManager$1 = {
  emptyValue: null,
  parseInput: parsePickerInputValue,
  areValuesEqual: (utils, a2, b2) => utils.isEqual(a2, b2)
};
const DesktopDateTimePicker = /* @__PURE__ */ React$6.forwardRef(function DesktopDateTimePicker2(inProps, ref) {
  const props = useDateTimePickerDefaultizedProps(inProps, "MuiDesktopDateTimePicker");
  const validationError = useDateTimeValidation(props) !== null;
  const {
    pickerProps,
    inputProps,
    wrapperProps
  } = usePickerState(props, valueManager$1);
  const {
    PopperProps,
    ToolbarComponent = DateTimePickerToolbar$1,
    TransitionComponent
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const AllDateInputProps = _extends({}, inputProps, other, {
    ref,
    validationError
  });
  return /* @__PURE__ */ jsx(DesktopWrapper, _extends({}, wrapperProps, {
    DateInputProps: AllDateInputProps,
    KeyboardDateInputComponent: KeyboardDateInput,
    PopperProps,
    TransitionComponent,
    children: /* @__PURE__ */ jsx(Picker, _extends({}, pickerProps, {
      autoFocus: true,
      toolbarTitle: props.label || props.toolbarTitle,
      ToolbarComponent,
      DateInputProps: AllDateInputProps
    }, other))
  }));
});
var DesktopDateTimePicker$1 = DesktopDateTimePicker;
const _excluded$2 = ["ToolbarComponent", "value", "onChange"];
const valueManager = {
  emptyValue: null,
  parseInput: parsePickerInputValue,
  areValuesEqual: (utils, a2, b2) => utils.isEqual(a2, b2)
};
const MobileDateTimePicker = /* @__PURE__ */ React$6.forwardRef(function MobileDateTimePicker2(inProps, ref) {
  const props = useDateTimePickerDefaultizedProps(inProps, "MuiMobileDateTimePicker");
  const validationError = useDateTimeValidation(props) !== null;
  const {
    pickerProps,
    inputProps,
    wrapperProps
  } = usePickerState(props, valueManager);
  const {
    ToolbarComponent = DateTimePickerToolbar$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const DateInputProps = _extends({}, inputProps, other, {
    ref,
    validationError
  });
  return /* @__PURE__ */ jsx(MobileWrapper, _extends({}, other, wrapperProps, {
    DateInputProps,
    PureDateInputComponent: PureDateInput,
    children: /* @__PURE__ */ jsx(Picker, _extends({}, pickerProps, {
      autoFocus: true,
      toolbarTitle: props.label || props.toolbarTitle,
      ToolbarComponent,
      DateInputProps
    }, other))
  }));
});
var MobileDateTimePicker$1 = MobileDateTimePicker;
const _excluded$1 = ["cancelText", "clearable", "clearText", "desktopModeMediaQuery", "DialogProps", "okText", "PopperProps", "showTodayButton", "todayText", "TransitionComponent"];
const DateTimePicker = /* @__PURE__ */ React$6.forwardRef(function DateTimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePicker"
  });
  const {
    cancelText,
    clearable,
    clearText,
    desktopModeMediaQuery = "@media (pointer: fine)",
    DialogProps,
    okText,
    PopperProps,
    showTodayButton,
    todayText,
    TransitionComponent
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const isDesktop = useMediaQuery(desktopModeMediaQuery);
  return isDesktop ? /* @__PURE__ */ jsx(DesktopDateTimePicker$1, _extends({
    ref,
    PopperProps,
    TransitionComponent
  }, other)) : /* @__PURE__ */ jsx(MobileDateTimePicker$1, _extends({
    ref,
    cancelText,
    clearable,
    clearText,
    DialogProps,
    okText,
    showTodayButton,
    todayText
  }, other));
});
var DateTimePicker$1 = DateTimePicker;
function getLoadingButtonUtilityClass(slot) {
  return generateUtilityClass("MuiLoadingButton", slot);
}
const loadingButtonClasses = generateUtilityClasses("MuiLoadingButton", ["root", "loading", "loadingIndicator", "loadingIndicatorCenter", "loadingIndicatorStart", "loadingIndicatorEnd", "endIconLoadingEnd", "startIconLoadingStart"]);
var loadingButtonClasses$1 = loadingButtonClasses;
const _excluded = ["children", "disabled", "id", "loading", "loadingIndicator", "loadingPosition", "variant"];
const useUtilityClasses = (ownerState) => {
  const {
    loading,
    loadingPosition,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", loading && "loading"],
    startIcon: [loading && `startIconLoading${capitalize(loadingPosition)}`],
    endIcon: [loading && `endIconLoading${capitalize(loadingPosition)}`],
    loadingIndicator: ["loadingIndicator", loading && `loadingIndicator${capitalize(loadingPosition)}`]
  };
  const composedClasses = composeClasses(slots, getLoadingButtonUtilityClass, classes2);
  return _extends({}, classes2, composedClasses);
};
const rootShouldForwardProp = (prop) => prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as" && prop !== "classes";
const LoadingButtonRoot = styled(Button, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiLoadingButton",
  slot: "Root",
  overridesResolver: (props, styles) => {
    return [styles.root, styles.startIconLoadingStart && {
      [`& .${loadingButtonClasses$1.startIconLoadingStart}`]: styles.startIconLoadingStart
    }, styles.endIconLoadingEnd && {
      [`& .${loadingButtonClasses$1.endIconLoadingEnd}`]: styles.endIconLoadingEnd
    }];
  }
})(({
  ownerState,
  theme
}) => _extends({
  [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
    transition: theme.transitions.create(["opacity"], {
      duration: theme.transitions.duration.short
    }),
    opacity: 0
  }
}, ownerState.loadingPosition === "center" && {
  transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
    duration: theme.transitions.duration.short
  }),
  [`&.${loadingButtonClasses$1.loading}`]: {
    color: "transparent"
  }
}, ownerState.loadingPosition === "start" && ownerState.fullWidth && {
  [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
    transition: theme.transitions.create(["opacity"], {
      duration: theme.transitions.duration.short
    }),
    opacity: 0,
    marginRight: -8
  }
}, ownerState.loadingPosition === "end" && ownerState.fullWidth && {
  [`& .${loadingButtonClasses$1.startIconLoadingStart}, & .${loadingButtonClasses$1.endIconLoadingEnd}`]: {
    transition: theme.transitions.create(["opacity"], {
      duration: theme.transitions.duration.short
    }),
    opacity: 0,
    marginLeft: -8
  }
}));
const LoadingButtonLoadingIndicator = styled("div", {
  name: "MuiLoadingButton",
  slot: "LoadingIndicator",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.loadingIndicator, styles[`loadingIndicator${capitalize(ownerState.loadingPosition)}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  position: "absolute",
  visibility: "visible",
  display: "flex"
}, ownerState.loadingPosition === "start" && (ownerState.variant === "outlined" || ownerState.variant === "contained") && {
  left: 14
}, ownerState.loadingPosition === "start" && ownerState.variant === "text" && {
  left: 6
}, ownerState.loadingPosition === "center" && {
  left: "50%",
  transform: "translate(-50%)",
  color: theme.palette.action.disabled
}, ownerState.loadingPosition === "end" && (ownerState.variant === "outlined" || ownerState.variant === "contained") && {
  right: 14
}, ownerState.loadingPosition === "end" && ownerState.variant === "text" && {
  right: 6
}, ownerState.loadingPosition === "start" && ownerState.fullWidth && {
  position: "relative",
  left: -10
}, ownerState.loadingPosition === "end" && ownerState.fullWidth && {
  position: "relative",
  right: -10
}));
const LoadingButton = /* @__PURE__ */ React$6.forwardRef(function LoadingButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLoadingButton"
  });
  const {
    children,
    disabled = false,
    id: idProp,
    loading = false,
    loadingIndicator: loadingIndicatorProp,
    loadingPosition = "center",
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const id2 = unstable_useId(idProp);
  const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ jsx(CircularProgress, {
    "aria-labelledby": id2,
    color: "inherit",
    size: 16
  });
  const ownerState = _extends({}, props, {
    disabled,
    loading,
    loadingIndicator,
    loadingPosition,
    variant
  });
  const classes2 = useUtilityClasses(ownerState);
  return /* @__PURE__ */ jsx(LoadingButtonRoot, _extends({
    disabled: disabled || loading,
    id: id2,
    ref
  }, other, {
    variant,
    classes: classes2,
    ownerState,
    children: ownerState.loadingPosition === "end" ? /* @__PURE__ */ jsxs(React$6.Fragment, {
      children: [children, loading && /* @__PURE__ */ jsx(LoadingButtonLoadingIndicator, {
        className: classes2.loadingIndicator,
        ownerState,
        children: loadingIndicator
      })]
    }) : /* @__PURE__ */ jsxs(React$6.Fragment, {
      children: [loading && /* @__PURE__ */ jsx(LoadingButtonLoadingIndicator, {
        className: classes2.loadingIndicator,
        ownerState,
        children: loadingIndicator
      }), children]
    })
  }));
});
var LoadingButton$1 = LoadingButton;
var style$2 = "";
var style$1 = "";
var style = "";
const BIG_CARD$2 = 12;
const pathToFile = new RegExp("(.*/).*");
const fileExtension = new RegExp(/\.[^/.]+$/);
const isGlbPath = (fields) => {
  if (fields) {
    const glbPath = fields.find((field) => field.name.match(/.*glbPath$/i));
    if (glbPath)
      return glbPath;
  }
  return;
};
const getExtensionsFromEntityFields = (fields) => {
  return fields.map((field) => {
    if (field.name.match(/([A-Z].*)Path$/))
      return field.name.match(/([A-Z].*)Path$/);
    if (field.name.match(/(.*)Path$/))
      return field.name.match(/(.*)Path$/);
  }).filter(Boolean);
};
const getFolders = (filePaths) => {
  return [...new Set(filePaths.current.map((path) => {
    var _a2;
    if ((_a2 = path == null ? void 0 : path.data) == null ? void 0 : _a2.relativePath)
      return path.data.relativePath.match(pathToFile)[1];
    else
      return null;
  }))];
};
const getUniqueFileNames = (filesInFolder) => {
  return [...new Set(filesInFolder.map((path) => {
    return path.data.name.replace(fileExtension, "");
  }))];
};
const getFilesInFolder = (filePaths, folder) => {
  return filePaths.current.filter((path) => {
    var _a2, _b;
    if ((_a2 = path == null ? void 0 : path.data) == null ? void 0 : _a2.relativePath) {
      if (folder == path.data.relativePath.match(pathToFile)[1]) {
        return path;
      }
    }
    if (folder == null && !((_b = path == null ? void 0 : path.data) == null ? void 0 : _b.relativePath))
      return path;
  });
};
const fillDynamicProps = (uniqueFileNames, filesInFolder, acceptedExtensions, acceptedImageExtensions, props, entityField) => {
  uniqueFileNames.forEach((fileName) => {
    var dynamicProps = {
      name: fileName
    };
    filesInFolder.forEach((path) => {
      if (fileName == path.data.name.replace(fileExtension, "")) {
        acceptedExtensions == null ? void 0 : acceptedExtensions.find((ext) => {
          if (path.extension == (ext == null ? void 0 : ext[1])) {
            dynamicProps[ext == null ? void 0 : ext[0]] = path.s3Multipart.key;
          }
          if (acceptedImageExtensions.includes(path.extension))
            dynamicProps["modelThumbnailPath"] = path.s3Multipart.key;
        });
      }
    });
    props.data[entityField.name].push(dynamicProps);
  });
};
const DragDropModelForm = ({
  props,
  formikProps,
  entityField
}) => {
  var _a2;
  const acceptedImageExtensions = ["jpg", "jpeg", "png"];
  let acceptedFileExtension = [".jpg", ".jpeg", ".png"];
  const acceptedExtensions = getExtensionsFromEntityFields((_a2 = entityField.entityFields) == null ? void 0 : _a2.fields);
  acceptedExtensions == null ? void 0 : acceptedExtensions.forEach((ext) => {
    var _a3;
    if (((_a3 = ext == null ? void 0 : ext[1]) == null ? void 0 : _a3.length) <= 4)
      acceptedFileExtension.push(`.${ext == null ? void 0 : ext[1]}`);
  });
  const [uppy2] = React__default.useState(getUppy(useClient(), acceptedFileExtension));
  let filePaths = React__default.useRef([""]);
  filePaths.current.pop();
  useEffect(() => {
    uppy2.on("file-added", (file) => {
      file.name = `${props.entityFields.name}/${v4()}_${file.name}`;
    });
    uppy2.on("upload-success", (file, response) => {
      filePaths.current.push(file);
    });
    uppy2.on("complete", (response) => {
      const folders = getFolders(filePaths);
      folders.map((folder) => {
        const filesInFolder = getFilesInFolder(filePaths, folder);
        const uniqueFileNames = getUniqueFileNames(filesInFolder);
        fillDynamicProps(uniqueFileNames, filesInFolder, acceptedExtensions, acceptedImageExtensions, props, entityField);
      });
      formikProps.setFieldValue(entityField.name, props.data[entityField.name]);
    });
  }, [uppy2]);
  return /* @__PURE__ */ jsx(Grid, {
    item: true,
    md: BIG_CARD$2,
    children: /* @__PURE__ */ jsxs(EntityCard, {
      title: entityField.name,
      children: [formInputWrapper({
        entityName: props.entityFields.name,
        entityField,
        value: formikProps.values[`${entityField.name}`],
        label: getInputLabel,
        formikProps
      }), /* @__PURE__ */ jsxs(Grid, {
        item: true,
        xs: BIG_CARD$2,
        children: [/* @__PURE__ */ jsx(DragDrop_1, {
          id: "dragDropOptimizedFiles",
          uppy: uppy2,
          locale: {
            strings: {
              dropHereOr: "Drop optimized files here or %{browse}",
              browse: "browse"
            }
          }
        }), /* @__PURE__ */ jsx("div", {
          className: "progress",
          style: {
            paddingTop: 20,
            paddingBottom: 20
          },
          children: /* @__PURE__ */ jsx(StatusBar_1, {
            uppy: uppy2,
            hideUploadButton: true,
            id: "statusBar",
            hideAfterFinish: true,
            hidePauseResumeButton: true,
            showProgressDetails: true
          })
        })]
      })]
    })
  });
};
const SMALL_CARD$1 = 6;
const isImagePath = (field) => {
  if (field.name.match(/.*thumbnailPath$/i))
    return field.name;
  if (field.name.match(/.*logoPath$/i))
    return field.name;
  if (field.name.match(/.*ImgPath$/i))
    return field.name;
  return "";
};
const DragDropImageForm = ({
  props,
  formikProps,
  entityField
}) => {
  const [signedSource, setSignedSource] = React__default.useState("");
  const [uppy2] = React__default.useState(getUppy(useClient(), ["image/*"]));
  const key = entityField.name;
  useEffect(() => {
    uppy2.on("file-added", (file) => {
      file.name = `${props.entityFields.name}/${v4()}_thumbnail_${file.name}`;
    });
    uppy2.on("upload-success", (file, response) => {
      formikProps.setFieldValue(key, file.name);
    });
  }, [uppy2]);
  getDownloadUrl(useClient(), formikProps.values[key]).then((promise) => {
    setSignedSource(promise.url);
  });
  return /* @__PURE__ */ jsxs(EntityCard, {
    title: entityField.name,
    children: [/* @__PURE__ */ jsx(Grid, {
      item: true,
      xs: SMALL_CARD$1,
      children: /* @__PURE__ */ jsx("img", {
        alt: "thumbnail",
        src: signedSource,
        style: {
          maxWidth: "200px",
          maxHeight: "200px"
        }
      })
    }), /* @__PURE__ */ jsxs(Grid, {
      item: true,
      xs: SMALL_CARD$1,
      children: [/* @__PURE__ */ jsx(DragDrop_1, {
        height: "200px",
        id: `dragDrop${key}`,
        uppy: uppy2,
        locale: {
          strings: {
            dropHereOr: "Drop thumbnail here or %{browse}",
            browse: "browse"
          }
        }
      }), /* @__PURE__ */ jsx("div", {
        className: "progress3",
        style: {
          paddingTop: 20,
          paddingBottom: 20
        },
        children: /* @__PURE__ */ jsx(StatusBar_1, {
          uppy: uppy2,
          hideUploadButton: true,
          id: `statusBar${key}`,
          hideAfterFinish: true,
          hidePauseResumeButton: true,
          showProgressDetails: true
        })
      })]
    })]
  });
};
const SMALL_CARD = 6;
const BIG_CARD$1 = 12;
const findNested = (entityField) => {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = entityField.entityFields) == null ? void 0 : _a2.fields) == null ? void 0 : _b.length) != null ? _c : 1;
};
const calculateVisibleFields = (visibleFields) => visibleFields.filter((field) => field.type !== "array").map((entityField) => findNested(entityField)).reduce((previous, next) => previous + next);
const getInputLabel = (entityName, fieldName) => {
  return /* @__PURE__ */ jsx(Translate, {
    entityName,
    fieldName,
    defaultMessage: stringPrettyCapitalize(fieldName)
  });
};
const formInputWrapper = ({
  entityName,
  entityField,
  value,
  label,
  formikProps,
  index
}) => {
  return formInput({
    entityName,
    entityField,
    name: entityField.name,
    value,
    label: label || getInputLabel,
    formikProps,
    index,
    render: ({
      entityField: entityField2,
      children
    }) => {
      return /* @__PURE__ */ jsx(Fragment$1, {
        children
      });
    }
  });
};
const EntityForm = (props) => {
  const navigate = useNavigate();
  const visibleFields = getVisibleFields(props.entityFields);
  const [open, setOpen] = React$6.useState(false);
  const fields = (formikProps) => {
    let fieldIndex = 0;
    let entityFieldIndex = 1;
    return /* @__PURE__ */ jsxs(Fragment$1, {
      children: [/* @__PURE__ */ jsxs(Grid, {
        container: true,
        justifyContent: "space-between",
        children: [/* @__PURE__ */ jsx(Grid, {
          item: true,
          padding: "25px",
          md: calculateVisibleFields(visibleFields) > SMALL_CARD + 1 ? SMALL_CARD : SMALL_CARD,
          children: /* @__PURE__ */ jsx(EntityCard, {
            title: props.entityFields.name,
            children: visibleFields.filter((field) => field.type !== "array" && field.type !== "object").map((entityField) => {
              return formInputWrapper({
                entityName: props.entityFields.name,
                entityField,
                value: formikProps.values[`${entityField.name}`],
                index: fieldIndex++,
                formikProps
              });
            })
          })
        }), visibleFields.filter((field) => {
          var _a2;
          return (field.type === "array" || field.type === "object") && !isPath((_a2 = field == null ? void 0 : field.entityFields) == null ? void 0 : _a2.fields);
        }).map((entityField) => {
          return /* @__PURE__ */ jsx(Grid, {
            item: true,
            padding: "32px",
            md: findNested(entityField) > SMALL_CARD - 3 ? BIG_CARD$1 : SMALL_CARD,
            children: /* @__PURE__ */ jsx(EntityCard, {
              title: entityField.name,
              action: entityField.type === "object" ? /* @__PURE__ */ jsx(EntityListDialog, {
                entityField,
                onClickRow: (entity) => {
                  formikProps.setFieldValue(entityField.name, entity, false);
                },
                children: /* @__PURE__ */ jsx(Button$1, {
                  variant: "contained",
                  startIcon: /* @__PURE__ */ jsx(Search, {}),
                  style: {
                    margin: "16px 0"
                  },
                  children: "Lookup"
                })
              }) : void 0,
              children: formInputWrapper({
                entityName: props.entityFields.name,
                entityField,
                value: formikProps.values[`${entityField.name}`],
                label: getInputLabel,
                index: entityFieldIndex,
                formikProps
              })
            })
          });
        }), /* @__PURE__ */ jsx(Grid, {
          item: true,
          md: SMALL_CARD,
          children: props.entityFields.fields.filter((field) => isImagePath(field) !== "").map((entityField) => {
            return /* @__PURE__ */ jsx(DragDropImageForm, {
              props,
              formikProps,
              entityField
            });
          })
        }), /* @__PURE__ */ jsx(Grid, {
          item: true,
          md: BIG_CARD$1,
          children: props.entityFields.fields.filter((field) => {
            var _a2;
            return isFilePath((_a2 = field == null ? void 0 : field.entityFields) == null ? void 0 : _a2.fields) !== "";
          }).map((entityField) => {
            return /* @__PURE__ */ jsx(DragDropForm, {
              props,
              formikProps,
              entityField
            });
          })
        }), /* @__PURE__ */ jsx(Grid, {
          item: true,
          md: BIG_CARD$1,
          children: props.entityFields.fields.filter((field) => {
            var _a2;
            return isGlbPath((_a2 = field == null ? void 0 : field.entityFields) == null ? void 0 : _a2.fields);
          }).map((entityField) => {
            return /* @__PURE__ */ jsx(DragDropModelForm, {
              props,
              formikProps,
              entityField
            });
          })
        })]
      }), /* @__PURE__ */ jsx(Divider, {
        sx: {
          marginY: "20px"
        }
      })]
    });
  };
  return /* @__PURE__ */ jsxs("div", {
    style: {
      marginLeft: 25,
      marginRight: 25
    },
    children: [/* @__PURE__ */ jsxs(Button$1, {
      onClick: () => {
        var _a2, _b;
        navigate(findPathRoot((_a2 = props.entityFields) == null ? void 0 : _a2.name) + "/" + ((_b = props.entityFields) == null ? void 0 : _b.name));
      },
      children: [/* @__PURE__ */ jsx(ArrowBack, {}), /* @__PURE__ */ jsx(Translate, {
        entityName: "Back"
      })]
    }), /* @__PURE__ */ jsx(Box, {
      sx: {
        marginY: 2
      },
      children: /* @__PURE__ */ jsx(Card, {
        children: /* @__PURE__ */ jsx(CardContent, {
          children: /* @__PURE__ */ jsx(Formik, {
            initialValues: props.data,
            onSubmit: props.onSubmit,
            validateOnChange: false,
            validateOnBlur: false,
            children: (formikProps) => {
              var _a2, _b, _c;
              return /* @__PURE__ */ jsxs("form", {
                onSubmit: formikProps.handleSubmit,
                children: [fields(formikProps), /* @__PURE__ */ jsxs(CardActions, {
                  children: [/* @__PURE__ */ jsx(LoadingButton$1, {
                    disabled: props.saveButtonDisabled,
                    loadingPosition: "start",
                    startIcon: /* @__PURE__ */ jsx(Save, {}),
                    style: {
                      margin: "12px auto"
                    },
                    variant: "contained",
                    onMouseUp: () => {
                      formikProps.handleSubmit();
                    },
                    children: /* @__PURE__ */ jsx(Translate, {
                      entityName: "Save"
                    })
                  }), /* @__PURE__ */ jsx(LoadingButton$1, {
                    disabled: props.saveButtonDisabled || formikProps.values.isDeleted == null,
                    loadingPosition: "start",
                    startIcon: formikProps.values.isDeleted ? /* @__PURE__ */ jsx(Undo, {}) : /* @__PURE__ */ jsx(Delete, {}),
                    style: {
                      margin: "12px auto"
                    },
                    variant: "contained",
                    onMouseUp: () => {
                      if (formikProps.values.isDeleted) {
                        formikProps.setFieldValue("isDeleted", false);
                        formikProps.handleSubmit();
                      } else {
                        setOpen(true);
                      }
                    },
                    children: /* @__PURE__ */ jsx(Translate, {
                      entityName: formikProps.values.isDeleted ? "Restore" : "Delete"
                    })
                  }), props.onCopy !== void 0 && /* @__PURE__ */ jsx(LoadingButton$1, {
                    disabled: props.saveButtonDisabled,
                    color: "primary",
                    loadingPosition: "start",
                    startIcon: /* @__PURE__ */ jsx(ContentCopy, {}),
                    style: {
                      margin: "12px auto"
                    },
                    variant: "contained",
                    onMouseUp: () => {
                      if (props.onCopy) {
                        props.onCopy(props.data);
                      }
                    },
                    children: /* @__PURE__ */ jsx(Translate, {
                      entityName: "Copy"
                    })
                  })]
                }), /* @__PURE__ */ jsx(DeleteModal, {
                  open,
                  handleClose: () => setOpen(false),
                  handleDelete: () => {
                    setOpen(false);
                    formikProps.setFieldValue("isDeleted", true);
                    formikProps.handleSubmit();
                  },
                  value: (_c = (_a2 = formikProps == null ? void 0 : formikProps.values) == null ? void 0 : _a2.name) != null ? _c : (_b = formikProps == null ? void 0 : formikProps.values) == null ? void 0 : _b.id
                })]
              });
            }
          })
        })
      })
    })]
  });
};
const BIG_CARD = 12;
const isFilePath = (fields) => {
  if (fields) {
    const filePath = fields.find((field) => field.name.match(/.*filePath$/i));
    if (filePath && filePath.name)
      return filePath.name;
  }
  return "";
};
const DragDropForm = ({
  props,
  formikProps,
  entityField
}) => {
  const [uppy2] = React__default.useState(getUppy(useClient(), null));
  useEffect(() => {
    uppy2.on("file-added", (file) => {
      file.name = `${props.entityFields.name}/${v4()}_attachment_${file.name}`;
    });
    uppy2.on("upload-success", (file, response) => {
      var _a2;
      const fileProp = {
        filePath: file.name,
        name: file.data.name
      };
      const key = (_a2 = props == null ? void 0 : props.entityFields) == null ? void 0 : _a2.fields.filter((field) => {
        var _a3;
        return isFilePath((_a3 = field == null ? void 0 : field.entityFields) == null ? void 0 : _a3.fields) !== "";
      });
      props.data[key[0].name].push(fileProp);
      formikProps.setFieldValue(key[0].name, props.data[key[0].name]);
    });
  }, [uppy2]);
  return /* @__PURE__ */ jsx(Grid, {
    item: true,
    md: BIG_CARD,
    children: /* @__PURE__ */ jsxs(EntityCard, {
      title: "Attachments",
      children: [formInputWrapper({
        entityName: props.entityFields.name,
        entityField,
        value: formikProps.values[`${entityField.name}`],
        label: getInputLabel,
        formikProps
      }), /* @__PURE__ */ jsxs(Grid, {
        item: true,
        xs: BIG_CARD,
        children: [/* @__PURE__ */ jsx(DragDrop_1, {
          id: "dragDropAttachments",
          uppy: uppy2,
          locale: {
            strings: {
              dropHereOr: "Drop attachments here or %{browse}",
              browse: "browse"
            }
          }
        }), /* @__PURE__ */ jsx("div", {
          className: "progress",
          style: {
            paddingTop: 20,
            paddingBottom: 20
          },
          children: /* @__PURE__ */ jsx(StatusBar_1, {
            uppy: uppy2,
            hideUploadButton: false,
            id: "statusBar",
            hideAfterFinish: true,
            hidePauseResumeButton: true,
            showProgressDetails: true
          })
        })]
      })]
    })
  });
};
const getDeepVisibleFields = (entityFields) => {
  let result = [];
  getVisibleFields(entityFields.entityFields).forEach((field) => {
    field.columnName = entityFields.name;
    result = field.type === "object" ? [...result, ...getDeepVisibleFields(field)] : [...result, field];
  });
  return result;
};
const isPath = (fields) => {
  if (fields) {
    const filePath = fields.filter((field) => field.name.match(/.*Path$/i));
    if (filePath.length > 0)
      return filePath;
  }
};
const FormEntityTable = ({
  name,
  data,
  entityField,
  formikProps
}) => {
  var _a2;
  const fieldName = name || entityField.name;
  const visibleFields = getVisibleFields(entityField.entityFields);
  const deepVisibleFields = getDeepVisibleFields(entityField);
  const [signedUrls, setSignedUrls] = React__default.useState([""]);
  const [rowClickDisabled, setRowClickDisabled] = React__default.useState(false);
  let filePaths = [""];
  filePaths.pop();
  data == null ? void 0 : data.map((item, index) => {
    var _a3, _b;
    return (_b = isPath((_a3 = entityField == null ? void 0 : entityField.entityFields) == null ? void 0 : _a3.fields)) == null ? void 0 : _b.map((field) => {
      if (item[field == null ? void 0 : field.name] && !filePaths.includes(item[field == null ? void 0 : field.name]))
        filePaths.push(item[field == null ? void 0 : field.name]);
    });
  });
  getDownloadUrls(useClient(), filePaths).then((promise) => {
    setSignedUrls(promise.urls);
  });
  const acceptedExtensions = getExtensionsFromEntityFields((_a2 = entityField.entityFields) == null ? void 0 : _a2.fields).filter((extension) => {
    if (!["file", "thumbnail", "glb"].includes(extension == null ? void 0 : extension[1].toLowerCase()))
      return extension;
  });
  return /* @__PURE__ */ jsx(FieldArray, {
    name: fieldName,
    render: (arrayHelpers) => {
      var _a3;
      const tableCellStyle = {
        borderBottom: 0,
        paddingBottom: 0
      };
      const entityDeleteField = entityField.entityFields ? guessEntityDeleteField(entityField.entityFields) : void 0;
      return /* @__PURE__ */ jsx(Fragment$1, {
        children: /* @__PURE__ */ jsx(TableContainer, {
          children: /* @__PURE__ */ jsxs(Table, {
            stickyHeader: true,
            children: [/* @__PURE__ */ jsx(TableHead, {
              children: /* @__PURE__ */ jsxs(TableRow, {
                children: [deepVisibleFields.map((field) => {
                  return /* @__PURE__ */ jsx(TableCell, {
                    children: /* @__PURE__ */ jsx(Translate, {
                      entityName: field.columnName,
                      fieldName: field.name,
                      defaultMessage: stringPrettyCapitalize(field.name)
                    })
                  });
                }), entityDeleteField && /* @__PURE__ */ jsx(TableCell, {}), /* @__PURE__ */ jsx(TableCell, {})]
              })
            }), /* @__PURE__ */ jsx(TableBody, {
              children: data == null ? void 0 : data.map((item, index) => {
                var _a4, _b;
                const itemDeleted = entityDeleteField ? isDeleted(entityDeleteField, item) : false;
                return /* @__PURE__ */ jsxs(TableRow, {
                  children: [visibleFields.map((field) => {
                    return /* @__PURE__ */ jsx(FieldItem, {
                      name: `${fieldName}.${index}.${field.name}`,
                      value: item == null ? void 0 : item[field.name],
                      entityName: entityField.name,
                      entityField: field,
                      render: ({
                        entityField: entityField2,
                        children
                      }) => /* @__PURE__ */ jsx(TableCell, {
                        style: itemDeleted ? __spreadProps(__spreadValues({}, tableCellStyle), {
                          opacity: 0.3
                        }) : tableCellStyle,
                        children
                      }),
                      formikProps
                    });
                  }), entityDeleteField && /* @__PURE__ */ jsx(TableCell, {
                    padding: "none",
                    style: __spreadProps(__spreadValues({}, tableCellStyle), {
                      width: 50
                    }),
                    children: /* @__PURE__ */ jsx(IconButton$1, {
                      color: "primary",
                      onClick: () => {
                        arrayHelpers.replace(index, setDeleted(entityDeleteField, item, !itemDeleted));
                      },
                      children: itemDeleted ? /* @__PURE__ */ jsx(Undo, {}) : /* @__PURE__ */ jsx(Delete, {})
                    })
                  }), isFilePath((_a4 = entityField == null ? void 0 : entityField.entityFields) == null ? void 0 : _a4.fields) !== "" && /* @__PURE__ */ jsx(FileDownloadTableCell, {
                    tableCellStyle,
                    filePath: signedUrls && signedUrls.find((url) => {
                      var _a5;
                      return url && url.includes(item[isFilePath((_a5 = entityField == null ? void 0 : entityField.entityFields) == null ? void 0 : _a5.fields)]);
                    }),
                    fileName: item.name
                  }), acceptedExtensions.map((ext) => {
                    return item[ext == null ? void 0 : ext[0]] && /* @__PURE__ */ jsx(FileDownloadTableCell, {
                      tableCellStyle,
                      filePath: signedUrls && signedUrls.find((url) => url && url.includes(item[ext == null ? void 0 : ext[0]])),
                      fileName: item.name.concat(`.${ext == null ? void 0 : ext[1]}`)
                    });
                  }), !isPath((_b = entityField == null ? void 0 : entityField.entityFields) == null ? void 0 : _b.fields) && /* @__PURE__ */ jsx(TableCell, {
                    padding: "none",
                    style: __spreadProps(__spreadValues({}, tableCellStyle), {
                      width: 50
                    }),
                    children: /* @__PURE__ */ jsx(IconButton$1, {
                      color: "primary",
                      onClick: () => arrayHelpers.push(deepClone(item)),
                      children: /* @__PURE__ */ jsx(ContentCopy, {})
                    })
                  })]
                });
              })
            }), /* @__PURE__ */ jsx(TableFooter, {
              children: /* @__PURE__ */ jsx(EntityListDialog, {
                entityField,
                setRowClickDisabled,
                onClickRow: (entity) => {
                  if (!rowClickDisabled.valueOf()) {
                    setRowClickDisabled(true);
                    if (entity.__typename) {
                      const newItem = __spreadValues({}, fillFlatEntityFieldValueObject(generateEntityFieldValueObject(entityField, 0), entity));
                      arrayHelpers.push(newItem);
                    }
                  }
                },
                children: !isPath((_a3 = entityField == null ? void 0 : entityField.entityFields) == null ? void 0 : _a3.fields) && /* @__PURE__ */ jsx(Button$1, {
                  style: {
                    margin: "12px",
                    float: "left"
                  },
                  variant: "contained",
                  color: "primary",
                  children: /* @__PURE__ */ jsx(Translate, {
                    entityName: "Add"
                  })
                })
              })
            })]
          })
        })
      });
    }
  });
};
const EntityTable = (props) => {
  var _a2, _b;
  const intl = useIntl();
  const location2 = useLocation();
  const [hideNextButton, setHideNextButton] = useState(false);
  const entityDeleteField = props.onDeleteRow ? guessEntityDeleteField(props.entityFields) : void 0;
  const originalEF = {
    name: props.entity,
    type: "array",
    entityFields: structuredClone(props.entityFields)
  };
  const onDeleteRestore = (entityDeleteField2, item, itemDeleted) => {
    setDeleted(entityDeleteField2, item, !itemDeleted);
    let newItem = __spreadProps(__spreadValues({}, fillFlatEntityFieldValueObject(generateEntityFieldValueObject(originalEF, 0), item.valueOf())), {
      id: item.id,
      isDeleted: item.isDeleted
    });
    if (props.onDeleteRow) {
      props.onDeleteRow(newItem);
    }
  };
  props = objectRelations(props);
  const columns = (_b = (_a2 = getVisibleFields(props.entityFields)) == null ? void 0 : _a2.map((eF) => {
    var _a3;
    const nestedTranslation = translateNestedField(eF, props.entityFields.name);
    return (entityDeleteField == null ? void 0 : entityDeleteField.name) === eF.name ? {
      field: eF.name,
      disableColumnMenu: true,
      sortable: false,
      minWidth: 68,
      flex: 1,
      renderHeader: () => /* @__PURE__ */ jsx(Translate, {
        entityName: nestedTranslation.entityName,
        fieldName: nestedTranslation.fieldName,
        defaultMessage: stringPrettyCapitalize(nestedTranslation.fieldName)
      }),
      renderCell: (params) => {
        const item = params.row;
        const itemDeleted = isDeleted(entityDeleteField, item);
        return /* @__PURE__ */ jsx(DeleteIconContainer, {
          onDeleteRestore,
          entityDeleteField,
          item,
          itemDeleted
        });
      }
    } : {
      field: eF.name,
      type: dataGridColumnType(eF.type),
      renderCell: valueFormatterFunction(eF.type, intl, (_a3 = props.entityFields) != null ? _a3 : []),
      renderHeader: () => /* @__PURE__ */ jsx(Translate, {
        entityName: nestedTranslation.entityName,
        fieldName: nestedTranslation.fieldName,
        defaultMessage: stringPrettyCapitalize(nestedTranslation.fieldName)
      }),
      minWidth: 150,
      flex: 2,
      columnType: eF.type
    };
  })) != null ? _b : [];
  addCustomFilterOpperations(columns);
  const [siblingCount, setSiblingCount] = useState(1);
  const [searchText, setSearchText] = useState("");
  useState(null);
  const {
    data,
    onChangePage,
    onPageSize,
    onSort,
    onFilter,
    onClickRow,
    setCountToRows,
    countRows,
    pageSize,
    loading,
    error,
    page
  } = props;
  const handlePage = (event, newPage) => {
    onChangePage(newPage);
  };
  const handlePageSize = (event) => {
    onPageSize(event.target.value);
    onChangePage(1);
  };
  const handleSort = (sort) => {
    onSort(sortQueryFromGridData(sort));
  };
  const handleFilter = useCallback((filter2) => {
    onFilter(filterDataGrid(filter2, columns));
    onChangePage(1);
  }, [onFilter, handlePage]);
  useEffect(() => {
    if (!loading) {
      controlNextButton({
        data,
        countRows,
        hideNextButton,
        setCountToRows,
        setHideNextButton,
        page,
        pageSize
      });
      controlSiblings(data, pageSize, page, setSiblingCount);
    }
  }, [data]);
  useEffect(() => {
    const delayDebounceFn = setTimeout(() => {
      let search = null;
      if (searchText != "") {
        props.entityFields.fields.forEach((field) => {
          if (field.type === "String") {
            if (!search)
              search = [];
            search.push({
              [field.name]: {
                _ilike: `%${searchText}%`
              }
            });
          }
        });
      }
      onFilter({
        _or: search != null ? search : {}
      });
      onChangePage(1);
    }, 300);
    return () => clearTimeout(delayDebounceFn);
  }, [searchText]);
  useEffect(() => {
    if (typeof onFilter == "function")
      onFilter({
        _or: {}
      });
    setSearchText("");
  }, [location2.pathname]);
  return /* @__PURE__ */ jsxs(Card, {
    children: [/* @__PURE__ */ jsx(Toolbar, {
      props,
      searchText,
      setSearchText
    }), /* @__PURE__ */ jsx(DataGrid2, {
      onRowClick: onClickRow,
      columns,
      rows: data,
      sortingMode: "server",
      filterMode: "server",
      autoHeight: true,
      onSortModelChange: handleSort,
      onFilterModelChange: handleFilter,
      pageSize,
      loading,
      error,
      hideFooterPagination: true,
      components: {
        LoadingOverlay: LinearProgress,
        Footer: () => /* @__PURE__ */ jsxs(Grid, {
          container: true,
          children: [/* @__PURE__ */ jsx(TablePagination, {
            countRows,
            page,
            handlePage,
            siblingCount,
            hideNextButton
          }), /* @__PURE__ */ jsx(SelectPerPage, {
            pageSize,
            handlePageSize
          })]
        })
      }
    })]
  });
};
const DetailPagePlaceholder = (props) => {
  return /* @__PURE__ */ jsx(EntityForm, __spreadValues({}, props));
};
const ErrorView = () => /* @__PURE__ */ jsx(Container, {
  maxWidth: "md",
  children: /* @__PURE__ */ jsx(Grid, {
    container: true,
    justifyContent: "center",
    alignItems: "center",
    height: "90vmin",
    flexDirection: "column",
    gap: "30px",
    children: /* @__PURE__ */ jsxs(Grid, {
      item: true,
      textAlign: "center",
      marginTop: "16px",
      children: [/* @__PURE__ */ jsx(Typography, {
        variant: "h4",
        children: "Something went wrong!"
      }), /* @__PURE__ */ jsx(Typography, {
        marginTop: "6px",
        display: "inline-block",
        textAlign: "center",
        fontSize: "1rem",
        fontWeight: 400,
        lineHeight: "26px",
        color: "#354967",
        children: "Try reloading the page or contact administrator."
      })]
    })
  })
});
class ErrorBoundary extends Component$7 {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      hasError: false
    });
  }
  static getDerivedStateFromError(_2) {
    return {
      hasError: true
    };
  }
  componentDidCatch(error, errorInfo) {
    return {
      error,
      errorInfo
    };
  }
  render() {
    var _a2, _b, _c, _d;
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx(ErrorView, {}), /* @__PURE__ */ jsxs("details", {
          style: {
            whiteSpace: "pre-wrap",
            marginLeft: "10vmin"
          },
          children: [((_a2 = this.state) == null ? void 0 : _a2.error) && ((_b = this.state) == null ? void 0 : _b.error.toString()), /* @__PURE__ */ jsx("br", {}), (_d = (_c = this.state) == null ? void 0 : _c.errorInfo) == null ? void 0 : _d.componentStack]
        })]
      });
    }
    return this.props.children;
  }
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
var MILLISECONDS_IN_MINUTE$1 = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$1);
}
var MILLISECONDS_IN_HOUR$1 = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$1);
}
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - Number(isLastYearNotFull));
  return result === 0 ? 0 : result;
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  }
};
var defaultRoundingMethod = "trunc";
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}
function differenceInQuarters(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMonths(dateLeft, dateRight) / 3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference);
  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function differenceInWeeks(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInDays(dateLeft, dateRight) / 7;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
function differenceInHours(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInMinutes(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function eachDayOfInterval(dirtyInterval, options) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = options && "step" in options ? Number(options.step) : 1;
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
function endOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  y: function(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var lightFormatters = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters.y(date, token);
  },
  Y: function(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters.d(date, token);
  },
  D: function(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters.h(date, token);
  },
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters.H(date, token);
  },
  K: function(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters.m(date, token);
  },
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters.s(date, token);
  },
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  X: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var formatters$1 = formatters;
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters$2 = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$3 = longFormatters$2;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$3[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}
function isSameHour(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}
function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  dirtyObject = dirtyObject || {};
  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }
  return target;
}
function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var MILLISECONDS_IN_SECOND = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n2, string, valueCallback) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), string, valueCallback);
  }
}
function parseNDigitsSigned(n2, string, valueCallback) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  G: {
    priority: 140,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(string, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(string, {
            width: "wide"
          }) || match2.era(string, {
            width: "abbreviated"
          }) || match2.era(string, {
            width: "narrow"
          });
      }
    },
    set: function(date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["R", "u", "t", "T"]
  },
  y: {
    priority: 130,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return parseNDigits(4, string, valueCallback);
        case "yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]
  },
  Y: {
    priority: 130,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return parseNDigits(4, string, valueCallback);
        case "Yo":
          return match2.ordinalNumber(string, {
            unit: "year",
            valueCallback
          });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  R: {
    priority: 130,
    parse: function(string, token, _match, _options) {
      if (token === "R") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  u: {
    priority: 130,
    parse: function(string, token, _match, _options) {
      if (token === "u") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]
  },
  Q: {
    priority: 120,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, string);
        case "Qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  q: {
    priority: 120,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, string);
        case "qo":
          return match2.ordinalNumber(string, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(string, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]
  },
  M: {
    priority: 110,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "MM":
          return parseNDigits(2, string, valueCallback);
        case "Mo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "MMM":
          return match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(string, {
            width: "wide",
            context: "formatting"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  L: {
    priority: 110,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "LL":
          return parseNDigits(2, string, valueCallback);
        case "Lo":
          return match2.ordinalNumber(string, {
            unit: "month",
            valueCallback
          });
        case "LLL":
          return match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(string, {
            width: "wide",
            context: "standalone"
          }) || match2.month(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  w: {
    priority: 100,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, string);
        case "wo":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]
  },
  I: {
    priority: 100,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, string);
        case "Io":
          return match2.ordinalNumber(string, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function(date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]
  },
  d: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, string);
        case "do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]
  },
  D: {
    priority: 90,
    subPriority: 1,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case "Do":
          return match2.ordinalNumber(string, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]
  },
  E: {
    priority: 90,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["D", "i", "e", "c", "t", "T"]
  },
  e: {
    priority: 90,
    parse: function(string, token, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return parseNDigits(token.length, string, valueCallback);
        case "eo":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "eee":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(string, {
            width: "short",
            context: "formatting"
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]
  },
  c: {
    priority: 90,
    parse: function(string, token, match2, options) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return parseNDigits(token.length, string, valueCallback);
        case "co":
          return match2.ordinalNumber(string, {
            unit: "day",
            valueCallback
          });
        case "ccc":
          return match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(string, {
            width: "wide",
            context: "standalone"
          }) || match2.day(string, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(string, {
            width: "short",
            context: "standalone"
          }) || match2.day(string, {
            width: "narrow",
            context: "standalone"
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]
  },
  i: {
    priority: 90,
    parse: function(string, token, match2, _options) {
      var valueCallback = function(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, string);
        case "io":
          return match2.ordinalNumber(string, {
            unit: "day"
          });
        case "iii":
          return match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiii":
          return match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiiiii":
          return match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
        case "iiii":
        default:
          return match2.day(string, {
            width: "wide",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "abbreviated",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "short",
            context: "formatting",
            valueCallback
          }) || match2.day(string, {
            width: "narrow",
            context: "formatting",
            valueCallback
          });
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function(date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]
  },
  a: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["b", "B", "H", "k", "t", "T"]
  },
  b: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "B", "H", "k", "t", "T"]
  },
  B: {
    priority: 80,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(string, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(string, {
            width: "narrow",
            context: "formatting"
          });
      }
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "t", "T"]
  },
  h: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, string);
        case "ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["H", "K", "k", "t", "T"]
  },
  H: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, string);
        case "Ho":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "K", "k", "t", "T"]
  },
  K: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, string);
        case "Ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function(date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    },
    incompatibleTokens: ["h", "H", "k", "t", "T"]
  },
  k: {
    priority: 70,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, string);
        case "ko":
          return match2.ordinalNumber(string, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function(date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ["a", "b", "h", "H", "K", "t", "T"]
  },
  m: {
    priority: 60,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, string);
        case "mo":
          return match2.ordinalNumber(string, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  s: {
    priority: 50,
    parse: function(string, token, match2, _options) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, string);
        case "so":
          return match2.ordinalNumber(string, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function(date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  S: {
    priority: 30,
    parse: function(string, token, _match, _options) {
      var valueCallback = function(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return parseNDigits(token.length, string, valueCallback);
    },
    set: function(date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ["t", "T"]
  },
  X: {
    priority: 10,
    parse: function(string, token, _match, _options) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "x"]
  },
  x: {
    priority: 10,
    parse: function(string, token, _match, _options) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ["t", "T", "X"]
  },
  t: {
    priority: 40,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  },
  T: {
    priority: 20,
    parse: function(string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function(_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: "*"
  }
};
var parsers$1 = parsers;
var TIMEZONE_UNIT_PRIORITY = 10;
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale2 = options.locale || defaultLocale;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i2;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter2 = substring[0];
    if (firstCharacter2 === "p" || firstCharacter2 === "P") {
      var longFormatter = longFormatters$3[firstCharacter2];
      return longFormatter(substring, locale2.formatLong, subFnOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  for (i2 = 0; i2 < tokens.length; i2++) {
    var token = tokens[i2];
    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }
    var firstCharacter = token[0];
    var parser = parsers$1[firstCharacter];
    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;
      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;
        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;
          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }
        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }
      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale2.match, subFnOptions);
      if (!parseResult) {
        return new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }
      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a2, b2) {
    return b2 - a2;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a2, b2) {
      return b2.subPriority - a2.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date)) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  for (i2 = 0; i2 < uniquePrioritySetters.length; i2++) {
    var setter = uniquePrioritySetters[i2];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }
    var result = setter.set(utcDate, flags, setter.value, subFnOptions);
    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]);
    } else {
      utcDate = result;
    }
  }
  return utcDate;
}
function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }
  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function parseISO(argument, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? 2 : toInteger(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
function formatISO(date, options) {
  requiredArgs(1, arguments);
  var originalDate = toDate(date);
  if (isNaN(originalDate.getTime())) {
    throw new RangeError("Invalid time value");
  }
  var format2 = !(options !== null && options !== void 0 && options.format) ? "extended" : String(options.format);
  var representation = !(options !== null && options !== void 0 && options.representation) ? "complete" : String(options.representation);
  if (format2 !== "extended" && format2 !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var tzOffset = "";
  var dateDelimiter = format2 === "extended" ? "-" : "";
  var timeDelimiter = format2 === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var offset = originalDate.getTimezoneOffset();
    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      var sign = offset < 0 ? "+" : "-";
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = "Z";
    }
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator2 = result === "" ? "" : "T";
    var time = [hour, minute, second].join(timeDelimiter);
    result = "".concat(result).concat(separator2).concat(time).concat(tzOffset);
  }
  return result;
}
function isWithinInterval(dirtyDate, interval) {
  requiredArgs(2, arguments);
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time >= startTime && time <= endTime;
}
var longFormatters$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = void 0;
  function dateLongFormatter2(pattern, formatLong2) {
    switch (pattern) {
      case "P":
        return formatLong2.date({
          width: "short"
        });
      case "PP":
        return formatLong2.date({
          width: "medium"
        });
      case "PPP":
        return formatLong2.date({
          width: "long"
        });
      case "PPPP":
      default:
        return formatLong2.date({
          width: "full"
        });
    }
  }
  function timeLongFormatter2(pattern, formatLong2) {
    switch (pattern) {
      case "p":
        return formatLong2.time({
          width: "short"
        });
      case "pp":
        return formatLong2.time({
          width: "medium"
        });
      case "ppp":
        return formatLong2.time({
          width: "long"
        });
      case "pppp":
      default:
        return formatLong2.time({
          width: "full"
        });
    }
  }
  function dateTimeLongFormatter2(pattern, formatLong2) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter2(pattern, formatLong2);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({
          width: "short"
        });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({
          width: "full"
        });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter2(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter2(timePattern, formatLong2));
  }
  var longFormatters2 = {
    p: timeLongFormatter2,
    P: dateTimeLongFormatter2
  };
  var _default = longFormatters2;
  exports2.default = _default;
  module2.exports = exports2.default;
})(longFormatters$1, longFormatters$1.exports);
var longFormatters = /* @__PURE__ */ getDefaultExportFromCjs(longFormatters$1.exports);
var defaultFormats = {
  dayOfMonth: "d",
  fullDate: "PP",
  fullDateWithWeekday: "PPPP",
  fullDateTime: "PP p",
  fullDateTime12h: "PP hh:mm aaa",
  fullDateTime24h: "PP HH:mm",
  fullTime: "p",
  fullTime12h: "hh:mm aaa",
  fullTime24h: "HH:mm",
  hours12h: "hh",
  hours24h: "HH",
  keyboardDate: "P",
  keyboardDateTime: "P p",
  keyboardDateTime12h: "P hh:mm aaa",
  keyboardDateTime24h: "P HH:mm",
  minutes: "mm",
  month: "LLLL",
  monthAndDate: "MMMM d",
  monthAndYear: "LLLL yyyy",
  monthShort: "MMM",
  weekday: "EEEE",
  weekdayShort: "EEE",
  normalDate: "d MMMM",
  normalDateWithWeekday: "EEE, MMM d",
  seconds: "ss",
  shortDate: "MMM d",
  year: "yyyy"
};
var DateFnsUtils = function() {
  function DateFnsUtils2(_a2) {
    var _this = this;
    var _b = _a2 === void 0 ? {} : _a2, locale2 = _b.locale, formats = _b.formats;
    this.lib = "date-fns";
    this.is12HourCycleInCurrentLocale = function() {
      if (_this.locale) {
        return /a/.test(_this.locale.formatLong.time());
      }
      return true;
    };
    this.getFormatHelperText = function(format2) {
      var longFormatRegexp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
      var locale3 = _this.locale || defaultLocale;
      return format2.match(longFormatRegexp).map(function(token) {
        var firstCharacter = token[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(token, locale3.formatLong, {});
        }
        return token;
      }).join("").replace(/(aaa|aa|a)/g, "(a|p)m").toLocaleLowerCase();
    };
    this.parseISO = function(isoString) {
      return parseISO(isoString);
    };
    this.toISO = function(value) {
      return formatISO(value, { format: "extended" });
    };
    this.getCurrentLocaleCode = function() {
      var _a3;
      return ((_a3 = _this.locale) === null || _a3 === void 0 ? void 0 : _a3.code) || "en-US";
    };
    this.addSeconds = function(value, count) {
      return addSeconds(value, count);
    };
    this.addMinutes = function(value, count) {
      return addMinutes(value, count);
    };
    this.addHours = function(value, count) {
      return addHours(value, count);
    };
    this.addDays = function(value, count) {
      return addDays(value, count);
    };
    this.addWeeks = function(value, count) {
      return addWeeks(value, count);
    };
    this.addMonths = function(value, count) {
      return addMonths(value, count);
    };
    this.isValid = function(value) {
      return isValid(_this.date(value));
    };
    this.getDiff = function(value, comparing, unit) {
      switch (unit) {
        case "years":
          return differenceInYears(value, _this.date(comparing));
        case "quarters":
          return differenceInQuarters(value, _this.date(comparing));
        case "months":
          return differenceInMonths(value, _this.date(comparing));
        case "weeks":
          return differenceInWeeks(value, _this.date(comparing));
        case "days":
          return differenceInDays(value, _this.date(comparing));
        case "hours":
          return differenceInHours(value, _this.date(comparing));
        case "minutes":
          return differenceInMinutes(value, _this.date(comparing));
        case "seconds":
          return differenceInSeconds(value, _this.date(comparing));
        default: {
          return differenceInMilliseconds(value, _this.date(comparing));
        }
      }
    };
    this.isAfter = function(value, comparing) {
      return isAfter(value, comparing);
    };
    this.isBefore = function(value, comparing) {
      return isBefore(value, comparing);
    };
    this.startOfDay = function(value) {
      return startOfDay(value);
    };
    this.endOfDay = function(value) {
      return endOfDay(value);
    };
    this.getHours = function(value) {
      return getHours(value);
    };
    this.setHours = function(value, count) {
      return setHours(value, count);
    };
    this.setMinutes = function(value, count) {
      return setMinutes(value, count);
    };
    this.getSeconds = function(value) {
      return getSeconds(value);
    };
    this.setSeconds = function(value, count) {
      return setSeconds(value, count);
    };
    this.isSameDay = function(value, comparing) {
      return isSameDay(value, comparing);
    };
    this.isSameMonth = function(value, comparing) {
      return isSameMonth(value, comparing);
    };
    this.isSameYear = function(value, comparing) {
      return isSameYear(value, comparing);
    };
    this.isSameHour = function(value, comparing) {
      return isSameHour(value, comparing);
    };
    this.startOfMonth = function(value) {
      return startOfMonth(value);
    };
    this.endOfMonth = function(value) {
      return endOfMonth(value);
    };
    this.startOfWeek = function(value) {
      return startOfWeek(value, { locale: _this.locale });
    };
    this.endOfWeek = function(value) {
      return endOfWeek(value, { locale: _this.locale });
    };
    this.getYear = function(value) {
      return getYear(value);
    };
    this.setYear = function(value, count) {
      return setYear(value, count);
    };
    this.date = function(value) {
      if (typeof value === "undefined") {
        return new Date();
      }
      if (value === null) {
        return null;
      }
      return new Date(value);
    };
    this.toJsDate = function(value) {
      return value;
    };
    this.parse = function(value, formatString) {
      if (value === "") {
        return null;
      }
      return parse(value, formatString, new Date(), { locale: _this.locale });
    };
    this.format = function(date, formatKey) {
      return _this.formatByString(date, _this.formats[formatKey]);
    };
    this.formatByString = function(date, formatString) {
      return format(date, formatString, { locale: _this.locale });
    };
    this.isEqual = function(date, comparing) {
      if (date === null && comparing === null) {
        return true;
      }
      return isEqual(date, comparing);
    };
    this.isNull = function(date) {
      return date === null;
    };
    this.isAfterDay = function(date, value) {
      return isAfter(date, endOfDay(value));
    };
    this.isBeforeDay = function(date, value) {
      return isBefore(date, startOfDay(value));
    };
    this.isBeforeYear = function(date, value) {
      return isBefore(date, startOfYear(value));
    };
    this.isAfterYear = function(date, value) {
      return isAfter(date, endOfYear(value));
    };
    this.isWithinRange = function(date, _a3) {
      var start = _a3[0], end = _a3[1];
      return isWithinInterval(date, { start, end });
    };
    this.formatNumber = function(numberToFormat) {
      return numberToFormat;
    };
    this.getMinutes = function(date) {
      return date.getMinutes();
    };
    this.getMonth = function(date) {
      return date.getMonth();
    };
    this.getDaysInMonth = function(date) {
      return getDaysInMonth(date);
    };
    this.setMonth = function(date, count) {
      return setMonth(date, count);
    };
    this.getMeridiemText = function(ampm) {
      return ampm === "am" ? "AM" : "PM";
    };
    this.getNextMonth = function(date) {
      return addMonths(date, 1);
    };
    this.getPreviousMonth = function(date) {
      return addMonths(date, -1);
    };
    this.getMonthArray = function(date) {
      var firstMonth = startOfYear(date);
      var monthArray = [firstMonth];
      while (monthArray.length < 12) {
        var prevMonth = monthArray[monthArray.length - 1];
        monthArray.push(_this.getNextMonth(prevMonth));
      }
      return monthArray;
    };
    this.mergeDateAndTime = function(date, time) {
      return _this.setSeconds(_this.setMinutes(_this.setHours(date, _this.getHours(time)), _this.getMinutes(time)), _this.getSeconds(time));
    };
    this.getWeekdays = function() {
      var now2 = new Date();
      return eachDayOfInterval({
        start: startOfWeek(now2, { locale: _this.locale }),
        end: endOfWeek(now2, { locale: _this.locale })
      }).map(function(day) {
        return _this.formatByString(day, "EEEEEE");
      });
    };
    this.getWeekArray = function(date) {
      var start = startOfWeek(startOfMonth(date), { locale: _this.locale });
      var end = endOfWeek(endOfMonth(date), { locale: _this.locale });
      var count = 0;
      var current = start;
      var nestedWeeks = [];
      var lastDay = null;
      while (isBefore(current, end)) {
        var weekNumber = Math.floor(count / 7);
        nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
        var day = getDay(current);
        if (lastDay !== day) {
          lastDay = day;
          nestedWeeks[weekNumber].push(current);
          count += 1;
        }
        current = addDays(current, 1);
      }
      return nestedWeeks;
    };
    this.getYearRange = function(start, end) {
      var startDate = startOfYear(start);
      var endDate = endOfYear(end);
      var years = [];
      var current = startDate;
      while (isBefore(current, endDate)) {
        years.push(current);
        current = addYears(current, 1);
      }
      return years;
    };
    this.locale = locale2;
    this.formats = Object.assign({}, defaultFormats, formats);
  }
  return DateFnsUtils2;
}();
const DateTimeField = ({
  entityName,
  entityField,
  name,
  value
}) => {
  const inputProps = {
    fullWidth: true,
    name,
    type: entityField.type,
    value,
    required: entityField.required,
    error: !value && entityField.required
  };
  return /* @__PURE__ */ jsx(FastField, {
    name,
    component: ({
      field,
      form,
      meta
    }) => {
      return /* @__PURE__ */ jsx(LocalizationProvider, {
        dateAdapter: DateFnsUtils,
        children: /* @__PURE__ */ jsx(DateTimePicker$1, {
          renderInput: (props) => /* @__PURE__ */ jsx(TextField$2, __spreadValues(__spreadValues({}, inputProps), props)),
          label: entityField.name,
          value,
          onChange: (newValue) => {
            console.log("DateTimePicker.onChange", newValue, name);
          },
          onAccept: (newValue) => {
            console.log("DateTimePicker.onAccept", newValue, name);
          }
        })
      });
    }
  });
};
const css = `.progress-bar {
  display: block;
  width: 33%;
  height: 10%;
  max-height: 2%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  border-radius: 25px;
  box-shadow: 0px 3px 10px 3px rgba(0, 0, 0, 0.5), 0px 0px 5px 1px rgba(0, 0, 0, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.9);
  background-color: rgba(0, 0, 0, 0.5);
}

.progress-bar.hide {
  visibility: hidden;
  transition: visibility 0.3s;
}

.update-bar {
  background-color: rgba(255, 255, 255, 0.9);
  width: 0%;
  height: 100%;
  border-radius: 25px;
  float: left;
  transition: width 0.3s;
}`;
const ModelView = ({
  thumbnailSource,
  glbSource
}) => {
  const [open, setOpen] = React__default.useState(false);
  const handleOpen = () => {
    if (glbSource)
      setOpen(true);
  };
  const handleClose = () => setOpen(false);
  const onProgress = (event) => {
    const progressBar = event.target.querySelector(".progress-bar");
    const updatingBar = event.target.querySelector(".update-bar");
    updatingBar.style.width = `${event.detail.totalProgress * 100}%`;
    if (event.detail.totalProgress === 1) {
      progressBar.classList.add("hide");
    } else {
      progressBar.classList.remove("hide");
      if (event.detail.totalProgress === 0) {
        event.target.querySelector(".center-pre-prompt").classList.add("hide");
      }
    }
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx("style", {
      children: css
    }), /* @__PURE__ */ jsx(Modal, {
      open,
      onClose: handleClose,
      "aria-labelledby": "modal-modal-title",
      "aria-describedby": "modal-modal-description",
      children: /* @__PURE__ */ jsx(Fragment$1, {
        children: /* @__PURE__ */ jsx("model-viewer", {
          id: "modelviewer2",
          autoplay: true,
          src: glbSource,
          "camera-controls": true,
          style: {
            width: "100%",
            height: "100%"
          },
          ref: (ref) => {
            if (ref)
              ref.addEventListener("progress", onProgress);
          },
          children: /* @__PURE__ */ jsx("div", {
            className: "progress-bar hide",
            slot: "progress-bar",
            children: /* @__PURE__ */ jsx("div", {
              className: "update-bar"
            })
          })
        })
      })
    }), thumbnailSource === "" ? /* @__PURE__ */ jsx(Fragment$1, {}) : /* @__PURE__ */ jsx("img", {
      alt: "thumbnail",
      src: thumbnailSource,
      style: {
        maxWidth: "200px",
        maxHeight: "200px"
      },
      width: "50%",
      height: "50%",
      onClick: handleOpen
    })]
  });
};
const ListPagePlaceholder = (props) => {
  return /* @__PURE__ */ jsx(EntityTable, __spreadValues({}, props));
};
function getNestedOfType(field) {
  var _a2;
  let actualType = (_a2 = field.type) != null ? _a2 : field.ofType;
  while (actualType.ofType)
    actualType = actualType.ofType;
  if (actualType.name)
    return actualType;
  else
    return { name: field.type, kind: "" };
}
function isListField(field) {
  var _a2;
  let actualType = (_a2 = field.type) != null ? _a2 : field.ofType;
  do {
    if ((actualType == null ? void 0 : actualType.kind) == "LIST") {
      return true;
    }
  } while (actualType = actualType.ofType);
  return false;
}
const getUpsertQuery = (values2, graphqlGen) => {
  return {
    on_conflict: getOnConflictFields(values2.__typename, graphqlGen, values2),
    [values2.__typename]: insertInput(values2, false, graphqlGen)
  };
};
const insertInput = (values2, ignoreId, graphqlGen) => {
  let obj = {};
  Object.keys(values2).filter((key) => key !== "__typename").forEach((key) => {
    let value = values2[key];
    if (Array.isArray(value)) {
      obj[key] = {
        data: value.map((item) => insertInput(item, ignoreId, graphqlGen)),
        on_conflict: getOnConflictFields(key, graphqlGen, value)
      };
    } else if (typeof value === "object" && value !== null && value !== void 0) {
      obj[key] = {
        data: insertInput(value, false, graphqlGen),
        on_conflict: getOnConflictFields(key, graphqlGen, value)
      };
    } else {
      if (ignoreId) {
        if (key !== "id") {
          obj[key] = value;
        }
      } else {
        obj[key] = value;
      }
    }
  });
  return obj;
};
const getOnConflictFields = (key, graphqlGen, values2) => {
  const update = getEnumValues(key, graphqlGen);
  const contraints = getConstraintValues(key, graphqlGen);
  const pkey = contraints.find((c2) => c2.concat("pkey"));
  const filtered = update.filter((i2) => {
    if (values2[i2] || values2[i2] == false || values2[i2] === null)
      return i2;
    if (Array.isArray(values2)) {
      const found = values2.some((k2) => k2[i2] || k2[i2] === false);
      if (found)
        return i2;
    }
    const lastPart = i2 == null ? void 0 : i2.slice(-2).toLocaleLowerCase();
    const firstPart = i2 == null ? void 0 : i2.slice(0, -2);
    if (lastPart == "id" && (values2[firstPart] && typeof values2[firstPart] == "object" || values2[`${firstPart}s`] && typeof values2[`${firstPart}s`] == "object"))
      return i2;
  });
  return {
    ["constraint"]: pkey,
    ["update_columns"]: filtered
  };
};
const getEnumValues = (objectName, graphqlGen) => {
  const on = Object.keys(graphqlGen).find((key) => key.toLowerCase() === `${objectName}_update_column`.toLowerCase());
  if (on)
    return Object.values(graphqlGen[on]);
  return [];
};
const getConstraintValues = (objectName, graphqlGen) => {
  const on = Object.keys(graphqlGen).find((key) => key.toLowerCase() === `${objectName}_Constraint`.toLowerCase());
  if (on)
    return Object.values(graphqlGen[on]);
  return [];
};
const isDocumentForDetailPage = (node) => {
  if (node.kind === "Document") {
    const operationDefinition = getOperationDefinition(node);
    const isQueryOperation = (operationDefinition == null ? void 0 : operationDefinition.operation) === "query";
    if (!isQueryOperation)
      return false;
    const hasIdVariable = operationDefinitionHasVariableWithName(operationDefinition, "id");
    if (hasIdVariable)
      return true;
  }
  return false;
};
const isDocumentForListPage = (node) => {
  if (node.kind === "Document") {
    const operationDefinition = getOperationDefinition(node);
    const isQueryOperation = (operationDefinition == null ? void 0 : operationDefinition.operation) === "query";
    if (!isQueryOperation)
      return false;
    const hasIdVariable = operationDefinitionHasVariableWithName(operationDefinition, "where");
    if (hasIdVariable)
      return true;
  }
  return false;
};
const operationDefinitionHasVariableWithName = (operationDefinition, variableName) => {
  var _a2;
  return (_a2 = operationDefinition == null ? void 0 : operationDefinition.variableDefinitions) == null ? void 0 : _a2.find((definition) => {
    var _a3, _b;
    return ((_b = (_a3 = definition == null ? void 0 : definition.variable) == null ? void 0 : _a3.name) == null ? void 0 : _b.value) === variableName;
  });
};
const getOperationDefinition = (node) => {
  var _a2;
  return (_a2 = node == null ? void 0 : node.definitions) == null ? void 0 : _a2.find((definition) => (definition == null ? void 0 : definition.kind) === "OperationDefinition");
};
const getFragmentDefinition = (node) => {
  var _a2;
  return (_a2 = node == null ? void 0 : node.definitions) == null ? void 0 : _a2.find((definition) => (definition == null ? void 0 : definition.kind) === "FragmentDefinition");
};
const getEntityNameFromFragmentDefinitionNode = (fragmentDefinition) => {
  var _a2, _b;
  return (_b = (_a2 = fragmentDefinition == null ? void 0 : fragmentDefinition.typeCondition) == null ? void 0 : _a2.name) == null ? void 0 : _b.value;
};
const calculateMenuItems = (graphqlGen, usersIcon, codeIcon) => {
  const items = /* @__PURE__ */ new Map();
  const detailDocuments = Object.values(graphqlGen).filter((node) => isDocumentForDetailPage(node));
  detailDocuments == null ? void 0 : detailDocuments.forEach((document2) => {
    const fragmentDefinition = getFragmentDefinition(document2);
    const entityName = getEntityNameFromFragmentDefinitionNode(fragmentDefinition);
    if (entityName) {
      items.set(entityName, {
        href: "/app/" + entityName,
        icon: usersIcon,
        label: "menu." + entityName,
        title: stringPrettyCapitalize(entityName),
        codeHref: "/test/" + entityName,
        codeIcon
      });
    }
  });
  return [...items.values()].sort((item1, item2) => item1.title.localeCompare(item2.title));
};
const MenuItems = ({
  items
}) => {
  const {
    pathname
  } = useLocation();
  const navigate = useNavigate();
  const theme = useTheme$1();
  const active = (path) => path ? !!matchPath({
    path,
    end: false
  }, pathname) : false;
  const generatedHref = (item, isActiveRoot) => {
    if (item.codeHref && item.codeIcon) {
      return /* @__PURE__ */ jsx(ListItemButton, {
        onClick: () => navigate(item.codeHref),
        children: /* @__PURE__ */ jsx(ListItemIcon, {
          children: /* @__PURE__ */ jsx(item.codeIcon, {
            color: isActiveRoot ? theme.palette.primary.contrastText : theme.palette.text.primary,
            size: "20"
          })
        })
      });
    }
  };
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: items.map((item) => {
      const isActiveRoot = active(item.href) || active(item.codeHref);
      return /* @__PURE__ */ jsxs(ListItem, {
        style: {
          cursor: "pointer",
          borderRadius: "20px",
          color: isActiveRoot ? theme.palette.primary.contrastText : theme.palette.text.primary,
          background: isActiveRoot && theme.palette.primary.main
        },
        children: [/* @__PURE__ */ jsxs(ListItemButton, {
          onClick: () => navigate(item.href),
          children: [/* @__PURE__ */ jsx(ListItemIcon, {
            children: /* @__PURE__ */ jsx(item.icon, {
              color: isActiveRoot ? theme.palette.primary.contrastText : theme.palette.text.primary,
              size: "20"
            })
          }), /* @__PURE__ */ jsx(ListItemText, {
            primary: item.title
          })]
        }), generatedHref(item, isActiveRoot)]
      }, item.title);
    })
  });
};
const ErrorCard = (props) => {
  const textObj = function() {
    if (props.error.networkError) {
      return {
        title: "Network Error",
        body: "There was an error connecting. Please check your internet."
      };
    }
    if (props.error.name && props.error.message) {
      return {
        title: props.error.name,
        body: props.error.message
      };
    }
    return {
      title: "Something went wrong",
      body: "Please try agin"
    };
  }();
  return /* @__PURE__ */ jsxs(Card, {
    sx: {
      maxWidth: "50%"
    },
    children: [/* @__PURE__ */ jsx(CardHeader, {
      sx: {
        background: "crimson",
        color: "white"
      },
      title: textObj.title
    }), /* @__PURE__ */ jsx(CardContent, {
      children: /* @__PURE__ */ jsx(Typography, {
        variant: "body1",
        color: "text.secondary",
        children: textObj.body
      })
    })]
  });
};
const Error$1 = ({
  error
}) => /* @__PURE__ */ jsx(ErrorCard, {
  error
});
const Fetching = () => /* @__PURE__ */ jsx(Fragment$1, {
  children: /* @__PURE__ */ jsx(CircularProgress$1, {})
});
const DeleteModal = ({
  open,
  handleClose,
  handleDelete,
  value
}) => /* @__PURE__ */ jsxs(Dialog, {
  open,
  onClose: handleClose,
  "aria-labelledby": "alert-dialog-title",
  "aria-describedby": "alert-dialog-description",
  children: [/* @__PURE__ */ jsx(DialogTitle, {
    id: "alert-dialog-title",
    children: /* @__PURE__ */ jsx("h2", {
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "deleteDialogTitle",
        defaultMessage: "Delete?"
      })
    })
  }), /* @__PURE__ */ jsx(DialogContent, {
    children: /* @__PURE__ */ jsx(DialogContentText, {
      id: "alert-dialog-description",
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "deleteDialogText",
        defaultMessage: "Are you sure you want to delete {value}?",
        values: {
          value: `<b>${value}</b>`
        }
      })
    })
  }), /* @__PURE__ */ jsxs(DialogActions$1, {
    children: [/* @__PURE__ */ jsx(Button$1, {
      onClick: handleClose,
      autoFocus: true,
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "No"
      })
    }), /* @__PURE__ */ jsx(Button$1, {
      onClick: handleDelete,
      children: /* @__PURE__ */ jsx(Translate, {
        entityName: "Yes"
      })
    })]
  })]
});
const DeleteIconContainer = ({
  onDeleteRestore,
  entityDeleteField,
  item,
  itemDeleted
}) => {
  var _a2;
  const [open, setOpen] = React$6.useState(false);
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(IconButton$1, {
      color: "primary",
      onClick: (event) => {
        event.stopPropagation();
        if (item == null ? void 0 : item.isDeleted) {
          onDeleteRestore(entityDeleteField, item, itemDeleted);
        } else {
          setOpen(true);
        }
      },
      children: itemDeleted ? /* @__PURE__ */ jsx(Undo, {}) : /* @__PURE__ */ jsx(Delete, {})
    }), /* @__PURE__ */ jsx(DeleteModal, {
      open,
      value: (_a2 = item == null ? void 0 : item.name) != null ? _a2 : item == null ? void 0 : item.id,
      handleClose: () => setOpen(false),
      handleDelete: () => {
        setOpen(false);
        onDeleteRestore(entityDeleteField, item, itemDeleted);
      }
    })]
  });
};
var toastify = { exports: {} };
/*!
 * Toastify js 1.11.2
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */
(function(module2) {
  (function(root2, factory) {
    if (module2.exports) {
      module2.exports = factory();
    } else {
      root2.Toastify = factory();
    }
  })(commonjsGlobal, function(global2) {
    var Toastify2 = function(options) {
      return new Toastify2.lib.init(options);
    }, version = "1.11.2";
    Toastify2.defaults = {
      oldestFirst: true,
      text: "Toastify is awesome!",
      node: void 0,
      duration: 3e3,
      selector: void 0,
      callback: function() {
      },
      destination: void 0,
      newWindow: false,
      close: false,
      gravity: "toastify-top",
      positionLeft: false,
      position: "",
      backgroundColor: "",
      avatar: "",
      className: "",
      stopOnFocus: true,
      onClick: function() {
      },
      offset: { x: 0, y: 0 },
      escapeMarkup: true,
      style: { background: "" }
    };
    Toastify2.lib = Toastify2.prototype = {
      toastify: version,
      constructor: Toastify2,
      init: function(options) {
        if (!options) {
          options = {};
        }
        this.options = {};
        this.toastElement = null;
        this.options.text = options.text || Toastify2.defaults.text;
        this.options.node = options.node || Toastify2.defaults.node;
        this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify2.defaults.duration;
        this.options.selector = options.selector || Toastify2.defaults.selector;
        this.options.callback = options.callback || Toastify2.defaults.callback;
        this.options.destination = options.destination || Toastify2.defaults.destination;
        this.options.newWindow = options.newWindow || Toastify2.defaults.newWindow;
        this.options.close = options.close || Toastify2.defaults.close;
        this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify2.defaults.gravity;
        this.options.positionLeft = options.positionLeft || Toastify2.defaults.positionLeft;
        this.options.position = options.position || Toastify2.defaults.position;
        this.options.backgroundColor = options.backgroundColor || Toastify2.defaults.backgroundColor;
        this.options.avatar = options.avatar || Toastify2.defaults.avatar;
        this.options.className = options.className || Toastify2.defaults.className;
        this.options.stopOnFocus = options.stopOnFocus === void 0 ? Toastify2.defaults.stopOnFocus : options.stopOnFocus;
        this.options.onClick = options.onClick || Toastify2.defaults.onClick;
        this.options.offset = options.offset || Toastify2.defaults.offset;
        this.options.escapeMarkup = options.escapeMarkup !== void 0 ? options.escapeMarkup : Toastify2.defaults.escapeMarkup;
        this.options.style = options.style || Toastify2.defaults.style;
        if (options.backgroundColor) {
          this.options.style.background = options.backgroundColor;
        }
        return this;
      },
      buildToast: function() {
        if (!this.options) {
          throw "Toastify is not initialized";
        }
        var divElement = document.createElement("div");
        divElement.className = "toastify on " + this.options.className;
        if (!!this.options.position) {
          divElement.className += " toastify-" + this.options.position;
        } else {
          if (this.options.positionLeft === true) {
            divElement.className += " toastify-left";
            console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.");
          } else {
            divElement.className += " toastify-right";
          }
        }
        divElement.className += " " + this.options.gravity;
        if (this.options.backgroundColor) {
          console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
        }
        for (var property in this.options.style) {
          divElement.style[property] = this.options.style[property];
        }
        if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
          divElement.appendChild(this.options.node);
        } else {
          if (this.options.escapeMarkup) {
            divElement.innerText = this.options.text;
          } else {
            divElement.innerHTML = this.options.text;
          }
          if (this.options.avatar !== "") {
            var avatarElement = document.createElement("img");
            avatarElement.src = this.options.avatar;
            avatarElement.className = "toastify-avatar";
            if (this.options.position == "left" || this.options.positionLeft === true) {
              divElement.appendChild(avatarElement);
            } else {
              divElement.insertAdjacentElement("afterbegin", avatarElement);
            }
          }
        }
        if (this.options.close === true) {
          var closeElement = document.createElement("span");
          closeElement.innerHTML = "&#10006;";
          closeElement.className = "toast-close";
          closeElement.addEventListener("click", function(event) {
            event.stopPropagation();
            this.removeElement(this.toastElement);
            window.clearTimeout(this.toastElement.timeOutValue);
          }.bind(this));
          var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
            divElement.insertAdjacentElement("afterbegin", closeElement);
          } else {
            divElement.appendChild(closeElement);
          }
        }
        if (this.options.stopOnFocus && this.options.duration > 0) {
          var self2 = this;
          divElement.addEventListener("mouseover", function(event) {
            window.clearTimeout(divElement.timeOutValue);
          });
          divElement.addEventListener("mouseleave", function() {
            divElement.timeOutValue = window.setTimeout(function() {
              self2.removeElement(divElement);
            }, self2.options.duration);
          });
        }
        if (typeof this.options.destination !== "undefined") {
          divElement.addEventListener("click", function(event) {
            event.stopPropagation();
            if (this.options.newWindow === true) {
              window.open(this.options.destination, "_blank");
            } else {
              window.location = this.options.destination;
            }
          }.bind(this));
        }
        if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
          divElement.addEventListener("click", function(event) {
            event.stopPropagation();
            this.options.onClick();
          }.bind(this));
        }
        if (typeof this.options.offset === "object") {
          var x2 = getAxisOffsetAValue("x", this.options);
          var y2 = getAxisOffsetAValue("y", this.options);
          var xOffset = this.options.position == "left" ? x2 : "-" + x2;
          var yOffset = this.options.gravity == "toastify-top" ? y2 : "-" + y2;
          divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";
        }
        return divElement;
      },
      showToast: function() {
        this.toastElement = this.buildToast();
        var rootElement;
        if (typeof this.options.selector === "string") {
          rootElement = document.getElementById(this.options.selector);
        } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== "undefined" && this.options.selector instanceof ShadowRoot) {
          rootElement = this.options.selector;
        } else {
          rootElement = document.body;
        }
        if (!rootElement) {
          throw "Root element is not defined";
        }
        var elementToInsert = Toastify2.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
        rootElement.insertBefore(this.toastElement, elementToInsert);
        Toastify2.reposition();
        if (this.options.duration > 0) {
          this.toastElement.timeOutValue = window.setTimeout(function() {
            this.removeElement(this.toastElement);
          }.bind(this), this.options.duration);
        }
        return this;
      },
      hideToast: function() {
        if (this.toastElement.timeOutValue) {
          clearTimeout(this.toastElement.timeOutValue);
        }
        this.removeElement(this.toastElement);
      },
      removeElement: function(toastElement) {
        toastElement.className = toastElement.className.replace(" on", "");
        window.setTimeout(function() {
          if (this.options.node && this.options.node.parentNode) {
            this.options.node.parentNode.removeChild(this.options.node);
          }
          if (toastElement.parentNode) {
            toastElement.parentNode.removeChild(toastElement);
          }
          this.options.callback.call(toastElement);
          Toastify2.reposition();
        }.bind(this), 400);
      }
    };
    Toastify2.reposition = function() {
      var topLeftOffsetSize = {
        top: 15,
        bottom: 15
      };
      var topRightOffsetSize = {
        top: 15,
        bottom: 15
      };
      var offsetSize = {
        top: 15,
        bottom: 15
      };
      var allToasts = document.getElementsByClassName("toastify");
      var classUsed;
      for (var i2 = 0; i2 < allToasts.length; i2++) {
        if (containsClass(allToasts[i2], "toastify-top") === true) {
          classUsed = "toastify-top";
        } else {
          classUsed = "toastify-bottom";
        }
        var height = allToasts[i2].offsetHeight;
        classUsed = classUsed.substr(9, classUsed.length - 1);
        var offset = 15;
        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (width <= 360) {
          allToasts[i2].style[classUsed] = offsetSize[classUsed] + "px";
          offsetSize[classUsed] += height + offset;
        } else {
          if (containsClass(allToasts[i2], "toastify-left") === true) {
            allToasts[i2].style[classUsed] = topLeftOffsetSize[classUsed] + "px";
            topLeftOffsetSize[classUsed] += height + offset;
          } else {
            allToasts[i2].style[classUsed] = topRightOffsetSize[classUsed] + "px";
            topRightOffsetSize[classUsed] += height + offset;
          }
        }
      }
      return this;
    };
    function getAxisOffsetAValue(axis, options) {
      if (options.offset[axis]) {
        if (isNaN(options.offset[axis])) {
          return options.offset[axis];
        } else {
          return options.offset[axis] + "px";
        }
      }
      return "0px";
    }
    function containsClass(elem, yourClass) {
      if (!elem || typeof yourClass !== "string") {
        return false;
      } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
        return true;
      } else {
        return false;
      }
    }
    Toastify2.lib.init.prototype = Toastify2.lib;
    return Toastify2;
  });
})(toastify);
var Toastify = toastify.exports;
const colors = {
  error: "rgb(229, 57, 53)",
  success: "rgb(45, 196, 51)",
  info: "rgb(57, 73, 171)",
  warn: "rgb(255, 192, 0)",
  load: "#7819A2"
};
const icons = {
  error: "https://img.icons8.com/color/20/undefined/cancel--v1.png",
  success: "https://img.icons8.com/color/20/undefined/ok--v1.png",
  info: "https://img.icons8.com/color/20/undefined/info--v1.png",
  warn: "https://img.icons8.com/color/20/undefined/error--v1.png",
  load: "https://img.icons8.com/fluency/20/undefined/spinner-frame-5.png"
};
const toast = (options) => {
  var _a2, _b, _c;
  Toastify({
    text: options.message,
    className: `iteria-snackbar ${options.type}`,
    duration: options.type === "load" ? 1500 : 5e3,
    avatar: icons[options.type],
    style: {
      transition: "0.3s",
      display: "flex",
      alignItems: "center",
      background: "rgba(36, 36, 36, 0.75)",
      padding: "15px 25px",
      color: "#FFF",
      fontSize: "0.9rem",
      maxWidth: "35vh",
      zIndex: "2500",
      position: "fixed",
      top: "80px",
      right: "30px",
      borderRadius: "4px",
      borderLeft: `3px solid ${colors[options.type]}`,
      boxShadow: "0 4px 12px rgb(0 0 0 / 15%)"
    }
  }).showToast();
  (_c = (_b = (_a2 = document.getElementsByClassName("toastify")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.classList) == null ? void 0 : _c.add("iteria-ignore");
};
const showErrorSnackbar = (message) => {
  toast({
    type: "error",
    message
  });
};
const showSuccessSnackbar = (message) => {
  toast({
    type: "success",
    message
  });
};
const showInfoSnackbar = (message) => {
  toast({
    type: "info",
    message
  });
};
const showWarningSnackbar = (message) => {
  toast({
    type: "warn",
    message
  });
};
const showLoadingSnackbar = (message) => {
  toast({
    type: "load",
    message
  });
};
const parseRequestErrors = (error, intl) => {
  var _a2, _b, _c;
  switch (true) {
    case ((_a2 = error == null ? void 0 : error.includes) == null ? void 0 : _a2.call(error, "hasura cloud limit")):
      return intl.formatMessage({
        id: "errorHasuraRateLimit",
        defaultMessage: "Database rate limit exceeded"
      });
    case ((_b = error == null ? void 0 : error.includes) == null ? void 0 : _b.call(error, "JWTExpired")):
      return intl.formatMessage({
        id: "errorJWTExpired",
        defaultMessage: "Login token expired - please re-login"
      });
    case ((_c = error == null ? void 0 : error.includes) == null ? void 0 : _c.call(error, "not found in type")):
      return intl.formatMessage({
        id: "errorPermissins",
        defaultMessage: "Insufficient permissions"
      });
    default:
      return error;
  }
};
const DetailPageContainer = () => {
  useParams();
  const [result] = useGeneratedByIdQuery();
  const useEntityFieldsQuery = () => {
    return {
      name: "",
      fields: []
    };
  };
  const entityFields = useEntityFieldsQuery();
  const handleSubmit = (_values) => {
  };
  if (result.fetching)
    return /* @__PURE__ */ jsx(Fetching, {});
  if (result.error)
    return /* @__PURE__ */ jsx(Error$1, {
      error: result.error
    });
  return /* @__PURE__ */ jsx(DetailPagePlaceholder, {
    data: result.data,
    entityFields,
    onSubmit: handleSubmit
  });
};
const filterInitialState = {
  page: 0,
  pageSize: 2
};
const filter = (state) => {
  const offset = state.page * state.pageSize;
  return {
    limit: state.pageSize,
    offset
  };
};
const ListPageContainer = () => {
  const [whereOrderByPagination, onChangeFilter] = useReducer((state, newState) => __spreadValues(__spreadValues({}, state), newState), filterInitialState);
  const [result] = useGeneratedQuery({
    variables: filter(whereOrderByPagination)
  });
  const useEntityFieldsQuery = () => {
    return {
      name: "",
      fields: []
    };
  };
  const onClickRow = () => {
    return 1;
  };
  const entityFields = useEntityFieldsQuery();
  return /* @__PURE__ */ jsx(ListPagePlaceholder, {
    data: result.data,
    loading: result.fetching,
    error: result.error,
    onChangeFilter,
    entityFields,
    onClickRow
  });
};
const isAutoGeneratedIdField = (field) => {
  return field.name === "id" && field.type !== "uuid";
};
const generateEntityFieldValue = (entityField, depth) => {
  const entityDeleteFieldOptions = getEntityDeleteFieldOptions(entityField);
  if (entityDeleteFieldOptions) {
    return entityDeleteFieldOptions.notDeleted;
  } else {
    switch (entityField.type.toLocaleLowerCase()) {
      case "array":
        return [];
      case "object":
        return generateEntityFieldValueObject(entityField, depth + 1);
      case "boolean":
        return false;
      case "uuid":
        if (!depth || depth < 1)
          return v4();
        return null;
      default:
        return null;
    }
  }
};
const generateEntityValueObject = (entity) => {
  let generatedItem = {};
  entity.fields.filter((field) => !isAutoGeneratedIdField(field)).forEach((field) => {
    generatedItem[field.name] = generateEntityFieldValue(field, -1e5);
  });
  return __spreadProps(__spreadValues({}, generatedItem), { __typename: entity.name });
};
const generateEntityFieldValueObject = (entityField, depth) => {
  var _a2;
  let generatedItem = {};
  (_a2 = entityField.entityFields) == null ? void 0 : _a2.fields.filter((field) => !isAutoGeneratedIdField(field)).forEach((field) => {
    generatedItem[field.name] = generateEntityFieldValue(field, depth);
  });
  return __spreadProps(__spreadValues({}, generatedItem), { __typename: entityField.name });
};
const fillFlatEntityFieldValueObject = (object, entity) => {
  const entries = Object.entries(object);
  const flatEntries = entries.map((e2) => {
    if (e2[0] == "id" && e2[1])
      return e2;
    if (e2[1] == void 0 || typeof e2[1] === "boolean" || e2[1].constructor === Array) {
      return [e2[0], entity[e2[0]]];
    }
    if (e2[1].constructor === Object) {
      if (entity.__typename == e2[0])
        return [e2[0], fillFlatEntityFieldValueObject(e2[1], entity)];
      else
        return [e2[0], fillFlatEntityFieldValueObject(e2[1], entity[e2[0]])];
    }
    return e2;
  });
  return Object.fromEntries(flatEntries);
};
const isHidden = (entityField) => {
  return entityField.name === "id" || entityField.name === "platny" || entityField.name.match(/.*Path$/i) !== null;
};
const getVisibleFields = (entityField) => {
  return entityField ? entityField.fields.filter((field) => isHidden(field) === false) : [];
};
const deepClone = (data, keepIds = false) => {
  const isArray2 = Array.isArray(data);
  const result = isArray2 ? [] : {};
  if (typeof data !== "object" || data === null) {
    return data;
  }
  for (const key in data) {
    if (!keepIds && key === "id") {
      if (!Number.isInteger(parseInt(data[key]))) {
        result[key] = v4();
      }
    } else {
      result[key] = deepClone(data[key], !isArray2);
    }
  }
  return result;
};
const findPathRoot = (entityName) => {
  if (!entityName)
    return window.location.hostname;
  const loc = location.pathname.toLowerCase().split("/");
  const index = loc.indexOf(entityName.toLowerCase());
  return loc.slice(0, index).join("/");
};
const isRequired = (entityName, field, graphqlgen, introspection) => {
  var _a2;
  const entityFields = graphqlEntityFields(getDetailEntityDocument(entityName, graphqlgen), introspection.__schema);
  const found = entityFields.fields.find((f2) => f2.name === field);
  return found ? (_a2 = found.required) != null ? _a2 : false : false;
};
const createEmptyObject = (entityName, graphqlgen, introspection) => {
  const entityFields = graphqlEntityFields(getDetailEntityDocument(entityName, graphqlgen), introspection.__schema);
  const object = generateEntityValueObject(entityFields);
  const timeFormats2 = ["timestamptz", "timestamp", "datetime"];
  const dateTimes = entityFields.fields.filter((f2) => timeFormats2.includes(f2.type));
  dateTimes.forEach((dateTime) => {
    object[`${dateTime.name}`] = new Date().toISOString();
  });
  object.__typename = entityName;
  return object;
};
const getDetailEntityDocument = (entityName, graphqlgen) => {
  const detailDocuments = Object.values(graphqlgen).filter((node) => isDocumentForDetailPage(node));
  const detailDocumentWithEntityName = detailDocuments.find((document2) => {
    var _a2, _b;
    const fragmentDefinition = getFragmentDefinition(document2);
    if (((_b = (_a2 = fragmentDefinition == null ? void 0 : fragmentDefinition.typeCondition) == null ? void 0 : _a2.name) == null ? void 0 : _b.value) === entityName)
      return true;
  });
  return detailDocumentWithEntityName;
};
const lowerFirstLetter = (text) => {
  return text.charAt(0).toLowerCase() + text.slice(1);
};
class GraphqlcodegenDataProvider {
  constructor(graphqlgen, intro) {
    __publicField(this, "getDetailEntityDocument");
    __publicField(this, "getListEntityDocument");
    __publicField(this, "getQueryHook");
    __publicField(this, "listPageQueryName");
    __publicField(this, "detailPageQueryName");
    __publicField(this, "entityUpsertMutation");
    __publicField(this, "capitalize");
    __publicField(this, "intro");
    __publicField(this, "graphqlgen");
    __publicField(this, "getMany", (entityName, filterProps2) => {
      var _a2, _b, _c;
      const queryHook = this.getQueryHook(entityName, 0);
      if (typeof queryHook != "function")
        return queryHook;
      const [result] = queryHook({
        variables: {
          where: filterProps2.filter,
          limit: filterProps2.pageSize + filterProps2.pageSize,
          offset: filterProps2.offset,
          order_by: filterProps2.sort
        }
      });
      const entityFields = graphqlEntityFields(this.getListEntityDocument(entityName), this.intro);
      const listPageQueryName = (_a2 = this.listPageQueryName(entityName)) != null ? _a2 : entityName;
      return {
        data: (_c = (_b = result.data) == null ? void 0 : _b[listPageQueryName]) != null ? _c : [],
        fetching: result.fetching,
        error: result.error,
        entityFields
      };
    });
    __publicField(this, "getOne", (entityName, options) => {
      var _a2, _b, _c, _d;
      const creating = ((_a2 = options.variables) == null ? void 0 : _a2.id) === "create";
      const [result] = this.getQueryHook(entityName, 1)(__spreadProps(__spreadValues({}, options), {
        pause: creating
      }));
      const entityFields = graphqlEntityFields(this.getDetailEntityDocument(entityName), this.intro);
      if (entityFields) {
        entityFields.name = entityName;
      }
      const detailPageQueryName = (_b = this.detailPageQueryName(entityName)) != null ? _b : entityName;
      return {
        data: creating ? generateEntityValueObject(entityFields) : (_d = (_c = result.data) == null ? void 0 : _c[detailPageQueryName]) != null ? _d : {},
        fetching: result.fetching,
        error: result.error,
        entityFields
      };
    });
    __publicField(this, "upsert", (entityName) => {
      if (this.entityUpsertMutation(entityName)) {
        const [, save] = this.entityUpsertMutation(entityName)();
        return {
          execute: (entityValue) => {
            const options = getUpsertQuery(entityValue, this.graphqlgen);
            return save(options);
          }
        };
      }
    });
    __publicField(this, "isReadOnly", (entityName) => {
      if (this.entityUpsertMutation(entityName))
        return true;
      else
        return false;
    });
    this.intro = intro;
    this.graphqlgen = graphqlgen;
    this.getDetailEntityDocument = (entityName) => {
      return getDetailEntityDocument(entityName, this.graphqlgen);
    };
    this.getListEntityDocument = (entityName) => {
      const detailDocuments = Object.values(this.graphqlgen).filter((node) => isDocumentForListPage(node));
      const detailDocumentWithEntityName = detailDocuments.find((document2) => {
        var _a2, _b;
        const fragmentDefinition = getFragmentDefinition(document2);
        if (((_b = (_a2 = fragmentDefinition == null ? void 0 : fragmentDefinition.typeCondition) == null ? void 0 : _a2.name) == null ? void 0 : _b.value) === entityName)
          return true;
      });
      return detailDocumentWithEntityName;
    };
    this.capitalize = (name) => {
      return name.charAt(0).toUpperCase() + name.slice(1);
    };
    this.getQueryHook = (entityName, page) => {
      var _a2;
      let pageQueryName;
      if (page === 0)
        pageQueryName = this.listPageQueryName(entityName);
      if (page === 1)
        pageQueryName = this.detailPageQueryName(entityName);
      if (!pageQueryName)
        return {
          error: {
            name: "Introspection error",
            message: `Table ${entityName} not found in introspection.json`
          }
        };
      const formattedQueryName = pageQueryName.split("_").map((string) => this.capitalize(string)).join("_");
      const queryHookName = `use${formattedQueryName}Query`;
      const queryByPkHookName = `use${formattedQueryName}_By_PkQuery`;
      const queryHookByPk = page === 1 ? graphqlgen[queryByPkHookName] : void 0;
      const queryHook = graphqlgen[queryHookName];
      return (_a2 = queryHookByPk != null ? queryHookByPk : queryHook) != null ? _a2 : {
        error: {
          name: "Introspection error",
          message: `Query ${queryHookName} or ${queryByPkHookName} not found in graphgl.ts`
        }
      };
    };
    this.detailPageQueryName = (entityName) => {
      var _a2;
      const queryRoot = this.intro.types.find((type) => {
        var _a3;
        return type.name === ((_a3 = this.intro.queryType) == null ? void 0 : _a3.name);
      });
      const queriesReturningEntity = (_a2 = queryRoot == null ? void 0 : queryRoot.fields) == null ? void 0 : _a2.filter((field) => getNestedOfType(field).name === entityName);
      const detailPageQuery = queriesReturningEntity == null ? void 0 : queriesReturningEntity.find((query) => query.args.some((arg) => arg.name === "id"));
      if (!detailPageQuery)
        return;
      return detailPageQuery.name;
    };
    this.listPageQueryName = (entityName) => {
      var _a2;
      const queryRoot = this.intro.types.find((type) => {
        var _a3;
        return type.name === ((_a3 = this.intro.queryType) == null ? void 0 : _a3.name);
      });
      const queriesReturningEntity = (_a2 = queryRoot == null ? void 0 : queryRoot.fields) == null ? void 0 : _a2.filter((field) => getNestedOfType(field).name === entityName);
      const listPageQueryName = queriesReturningEntity == null ? void 0 : queriesReturningEntity.find((query) => query.args.some((arg) => arg.name === "where"));
      if (!listPageQueryName)
        return;
      return listPageQueryName.name;
    };
    this.entityUpsertMutation = (entityName) => {
      const mutationName = Object.keys(graphqlgen).find((key) => key.toUpperCase() === `useInsert_${this.capitalize(entityName)}Mutation`.toUpperCase() || key.toUpperCase() === `useInsert${this.capitalize(entityName)}Mutation`.toUpperCase());
      if (mutationName)
        return graphqlgen[mutationName];
    };
  }
}
const graphqlEntityFields = (queryAST, introspection) => {
  var _a2, _b, _c, _d, _e;
  const objectTypes = introspectionObjectTypesMap(introspection);
  const queryRootName = (_b = (_a2 = introspection == null ? void 0 : introspection.queryType) == null ? void 0 : _a2.name) != null ? _b : "query_root";
  const fragments = fragmentsEntityFields(queryAST, objectTypes);
  const operations = operationsEntityFields(queryAST, objectTypes, queryRootName, fragments);
  return (_e = (_d = (_c = operations == null ? void 0 : operations[0]) == null ? void 0 : _c.fields) == null ? void 0 : _d[0]) == null ? void 0 : _e.entityFields;
};
const introspectionObjectTypesMap = (introspection) => {
  return introspection.types.filter((objectType) => objectType.kind == "OBJECT").reduce((ret, objectType) => {
    ret[objectType.name] = objectType;
    return ret;
  }, {});
};
class Hierarchy {
  constructor(parentEntityName, objectTypes) {
    __publicField(this, "parent");
    __publicField(this, "ancestors", []);
    __publicField(this, "objectTypes");
    this.parent = {
      from: objectTypes[parentEntityName],
      to: { name: parentEntityName, fields: [] }
    };
    this.objectTypes = objectTypes;
  }
  enterField(node) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const name = node.name.value;
    const introField = (_c = (_b = (_a2 = this.parent) == null ? void 0 : _a2.from) == null ? void 0 : _b.fields) == null ? void 0 : _c.find((introField2) => introField2.name == name);
    if (introField && this.parent) {
      if (node.selectionSet) {
        const type = isListField(introField) ? "array" : "object";
        const newEntity = { name, fields: [] };
        (_f = (_e = (_d = this == null ? void 0 : this.parent) == null ? void 0 : _d.to) == null ? void 0 : _e.fields) == null ? void 0 : _f.push({ name, type, entityFields: newEntity });
        this.ancestors.push(this.parent);
        const introFieldType = getNestedOfType(introField);
        if (introFieldType == null ? void 0 : introFieldType.name) {
          const objectType = this.objectTypes[introFieldType.name];
          this.parent = { from: objectType, to: newEntity };
        }
      } else {
        const introFieldType = getNestedOfType(introField);
        (_k = (_h = (_g = this.parent) == null ? void 0 : _g.to) == null ? void 0 : _h.fields) == null ? void 0 : _k.push({
          name,
          type: (_i = introFieldType.name) != null ? _i : "String",
          required: ((_j = introField == null ? void 0 : introField.type) == null ? void 0 : _j.kind) === "NON_NULL"
        });
      }
    }
  }
  leaveField(node) {
    if (node.selectionSet) {
      this.parent = this.ancestors.pop();
    }
  }
}
const fragmentsEntityFields = (queryAST, objectTypes) => {
  let hierarchy;
  const fragments = {};
  visit(queryAST, {
    enter: {
      FragmentDefinition(node) {
        var _a2, _b;
        const fragmentType = node.typeCondition.name.value;
        hierarchy = new Hierarchy(fragmentType, objectTypes);
        if ((_a2 = hierarchy.parent) == null ? void 0 : _a2.to) {
          fragments[node.name.value] = (_b = hierarchy.parent) == null ? void 0 : _b.to;
        }
        return node;
      },
      Field(node) {
        if (hierarchy) {
          hierarchy.enterField(node);
        }
        return node;
      }
    },
    leave: {
      FragmentDefinition(node) {
        hierarchy = void 0;
        return node;
      },
      Field(node) {
        if (hierarchy) {
          hierarchy.leaveField(node);
        }
        return node;
      }
    }
  });
  return fragments;
};
function operationsEntityFields(queryAST, objectTypes, queryRootName, fragments) {
  let hierarchy;
  const operations = [];
  visit(queryAST, {
    enter: {
      OperationDefinition(node) {
        var _a2, _b;
        if ((_a2 = node == null ? void 0 : node.name) == null ? void 0 : _a2.value) {
          hierarchy = new Hierarchy(queryRootName, objectTypes);
          if ((_b = hierarchy.parent) == null ? void 0 : _b.to) {
            operations.push(hierarchy.parent.to);
          }
        }
        return node;
      },
      Field(node) {
        if (hierarchy) {
          hierarchy.enterField(node);
        }
        return node;
      },
      FragmentSpread(node) {
        var _a2;
        const fragment = fragments[node.name.value];
        if (fragment) {
          (_a2 = fragment.fields) == null ? void 0 : _a2.forEach((item) => {
            var _a3, _b, _c;
            return (_c = (_b = (_a3 = hierarchy == null ? void 0 : hierarchy.parent) == null ? void 0 : _a3.to) == null ? void 0 : _b.fields) == null ? void 0 : _c.push(item);
          });
        }
      }
    },
    leave: {
      OperationDefinition(node) {
        hierarchy = void 0;
        return node;
      },
      Field(node) {
        if (hierarchy) {
          hierarchy.leaveField(node);
        }
        return node;
      }
    }
  });
  return operations;
}
const App = ({
  messages,
  locale: locale2
}) => {
  return /* @__PURE__ */ jsx(I18nProvider, {
    locale: locale2,
    messages,
    children: /* @__PURE__ */ jsx(EntityTable, {
      data: [],
      entityFields: {
        name: "entity",
        fields: []
      }
    })
  });
};
const EntityListPageEditable = (props) => {
  const navigate = useNavigate();
  const {
    upsert
  } = useDataContext(props.entity);
  return /* @__PURE__ */ jsx(EntityListContainer, {
    entity: props.entity,
    onClickRow: (props2) => {
      return navigate(props2.id.toString());
    },
    onDeleteRow: (value) => {
      upsert(value);
    },
    onClickCreate: () => {
      navigate("create");
    }
  });
};
const EntityListPageReadOnly = (props) => {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsx(EntityListContainer, {
    entity: props.entity,
    onClickRow: (props2) => {
      return navigate(props2.id.toString());
    },
    onClickCreate: () => {
      navigate("create");
    }
  });
};
const EntityListPage = (props) => {
  const dataContext = useContext(DataContext);
  if (dataContext.isReadOnly(props.entity) == false)
    return /* @__PURE__ */ jsx(EntityListPageReadOnly, {
      entity: props.entity
    });
  else
    return /* @__PURE__ */ jsx(EntityListPageEditable, {
      entity: props.entity
    });
};
class ErrorWithCode extends Error {
  constructor(message, code) {
    super(message);
    __publicField(this, "code");
    __publicField(this, "timeStamp");
    Object.setPrototypeOf(this, ErrorWithCode.prototype);
    this.name = this.constructor.name;
    this.message = message;
    this.code = code;
    this.timeStamp = new Date();
  }
}
const EntityDetailContainer = (props) => {
  const {
    id: id2
  } = useParams();
  const navigate = useNavigate();
  const intl = useIntl();
  const {
    getOne,
    upsert,
    upsertDisabled
  } = useDataContext(props.entity);
  const result = getOne({
    variables: {
      id: id2
    }
  });
  const handleSubmit = (values2) => {
    showLoadingSnackbar(intl.formatMessage({
      id: "snackbarSubmitting",
      defaultMessage: "Submitting..."
    }));
    if (upsertDisabled)
      throw new ErrorWithCode(`Upserting is disabled for the entity:"${props.entity}"`, "ERR_UPSERT_DISABLED");
    const eF = {
      name: props.entity,
      type: "array",
      entityFields: result == null ? void 0 : result.entityFields
    };
    const newItem = __spreadProps(__spreadValues({}, fillFlatEntityFieldValueObject(generateEntityFieldValueObject(eF, 0), values2)), {
      id: values2.id
    });
    if (values2.isDeleted)
      newItem.isDeleted = values2 == null ? void 0 : values2.isDeleted;
    upsert(newItem).then((response) => {
      var _a2, _b, _c, _d;
      if (response.error) {
        showErrorSnackbar(intl.formatMessage({
          id: "snackbarSubmitFailed",
          defaultMessage: "Submit failed: "
        }) + parseRequestErrors(response.error.message, intl));
        console.error("Submit error:", response.error);
      } else {
        showSuccessSnackbar(intl.formatMessage({
          id: "snackbarSubmitOk",
          defaultMessage: "Submit successful"
        }));
        const newId = (_d = (_c = (_b = (_a2 = response.data) == null ? void 0 : _a2[`${Object.keys(response.data)[0]}`]) == null ? void 0 : _b.returning) == null ? void 0 : _c[0]) == null ? void 0 : _d.id;
        if (newId) {
          navigate(-1);
        }
      }
    });
  };
  const handleCopy = (values2) => {
    handleSubmit(deepClone(values2));
  };
  if (result.fetching)
    return /* @__PURE__ */ jsx(Grid, {
      container: true,
      justifyContent: "center",
      alignItems: "center",
      sx: {
        width: "100%",
        height: "70vh"
      },
      children: /* @__PURE__ */ jsx(CircularProgress$1, {})
    });
  return /* @__PURE__ */ jsx(ErrorBoundary, {
    children: /* @__PURE__ */ jsx(QueryBoundary, {
      queryResponse: result,
      children: /* @__PURE__ */ jsx(EntityForm, {
        data: result == null ? void 0 : result.data,
        entityFields: result == null ? void 0 : result.entityFields,
        onSubmit: handleSubmit,
        onCopy: handleCopy,
        saveButtonDisabled: upsertDisabled
      })
    })
  });
};
const generatePagesRoutes = (graphqlGen) => {
  const routes = Object.values(graphqlGen).map((node) => {
    if (isDocumentForDetailPage(node)) {
      const fragmentDefinition = getFragmentDefinition(node);
      const entityName = getEntityNameFromFragmentDefinitionNode(fragmentDefinition);
      if (entityName) {
        return {
          path: `${entityName}/:id/`,
          element: /* @__PURE__ */ jsx(EntityDetailContainer, {
            entity: entityName
          })
        };
      }
    } else if (isDocumentForListPage(node)) {
      const fragmentDefinition = getFragmentDefinition(node);
      const entityName = getEntityNameFromFragmentDefinitionNode(fragmentDefinition);
      if (entityName) {
        return {
          path: `${entityName}`,
          element: /* @__PURE__ */ jsx(EntityListPage, {
            entity: entityName
          })
        };
      }
    }
  }).filter(Boolean);
  return routes;
};
const ThemeContext = createContext();
const reducer = (state, action) => {
  switch (action.type) {
    case "setTheme":
      return __spreadProps(__spreadValues({}, state), {
        theme: action.theme
      });
  }
};
const ThemeContextProvider = ({
  children
}) => {
  const [state, dispatch] = useReducer(reducer, {});
  const value = {
    state,
    dispatch
  };
  return /* @__PURE__ */ jsx(ThemeContext.Provider, {
    value,
    children
  });
};
const ThemeContextConsumer = ThemeContext.Consumer;
const ThemeProvider = ({
  children,
  theme
}) => {
  return /* @__PURE__ */ jsx(ThemeProvider$1, {
    theme,
    children
  });
};
ReactDOM.render(/* @__PURE__ */ jsx(BrowserRouter, {
  children: /* @__PURE__ */ jsx(App, {
    messages: null,
    locale: "en"
  })
}), document.getElementById("root"));
export { CheckboxField, DataContext, DateTimeField, DeleteIconContainer, DeleteModal, DetailPageContainer, DetailPagePlaceholder, EntityCard, EntityDetailContainer, EntityDialog, EntityForm, EntityListContainer, EntityListDialog, EntityListPage, EntityTable, Error$1 as Error, ErrorBoundary, ErrorView, Fetching, FieldItem, FormEntityTable, generated as GraphqlGenerated, GraphqlcodegenDataProvider, I18nProvider, ListPageContainer, ListPagePlaceholder, LocaleContext, LocaleContextConsumer, LocaleContextProvider, LocaleSwitch, MenuItems, ModelView, ObjectField, QueryBoundary, SelectPerPage, TablePagination, TextField, ThemeContext, ThemeContextConsumer, ThemeContextProvider, ThemeProvider, Toolbar, Translate, addCustomFilterOpperations, booleanFormatTemplate, calculateMenuItems, columnFromField, controlNextButton, controlSiblings, createEmptyObject, createUuidColumnType, dataGridColumnType, deepClone, deleteFieldsOptions, detailPageFullRegex, detailPageRegex, fillFlatEntityFieldValueObject, filterColumnFieldFromDataGrid, filterDataGrid, filterValueFromDataGrid, findPathRoot, formInput, formInputWrapper, generateEntityFieldValue, generateEntityFieldValueObject, generateEntityValueObject, generatePagesRoutes, getBooleanFilterOperator, getDateFilterOperator, getDetailEntityDocument, getEntityDeleteFieldOptions, getEntityNameFromUrl, getInputLabel, getNumberFilterOperator, getQueryFromDataGrid, getStringFilterOperator, getVisibleFields, guessEntityDeleteField, guessEntityFieldTitle, isAutoGeneratedIdField, isDeleted, isHidden, isPath, isRequired, lowerFirstLetter, numberColumnType, objectRelations, parseRequestErrors, setDeleted, showErrorSnackbar, showInfoSnackbar, showLoadingSnackbar, showSuccessSnackbar, showWarningSnackbar, sortQueryFromGridData, stringPrettyCapitalize, translateNestedField, useDataContext, useEntityDetails, useEntityList, useFilter, useLocale, useSetLocale, uuidColumnType, valueFormatterFunction };
