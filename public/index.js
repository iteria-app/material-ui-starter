var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj2, key, value2) => key in obj2 ? __defProp2(obj2, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj2[key] = value2;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField2 = (obj2, key, value2) => {
  __defNormalProp2(obj2, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
import ts, { factory } from "https://esm.sh/typescript";
import { h as hideSpinner } from "./loader.js";
function _mergeNamespaces(n2, m) {
  m.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d = Object.getOwnPropertyDescriptor(e, k2);
        Object.defineProperty(n2, k2, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k2];
          }
        });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj2, key, value2) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj2[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj2, key, value2) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __decorate$1(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
const $global = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  try {
    return new Function("return this")();
  } catch (_a2) {
    return {};
  }
}();
if ($global.trustedTypes === void 0) {
  $global.trustedTypes = { createPolicy: (n2, r) => r };
}
const propConfig = {
  configurable: false,
  enumerable: false,
  writable: false
};
if ($global.FAST === void 0) {
  Reflect.defineProperty($global, "FAST", Object.assign({ value: /* @__PURE__ */ Object.create(null) }, propConfig));
}
const FAST = $global.FAST;
if (FAST.getById === void 0) {
  const storage2 = /* @__PURE__ */ Object.create(null);
  Reflect.defineProperty(FAST, "getById", Object.assign({ value(id, initialize) {
    let found = storage2[id];
    if (found === void 0) {
      found = initialize ? storage2[id] = initialize() : null;
    }
    return found;
  } }, propConfig));
}
const emptyArray = Object.freeze([]);
const updateQueue = $global.FAST.getById(1, () => {
  const tasks2 = [];
  const pendingErrors = [];
  function throwFirstError() {
    if (pendingErrors.length) {
      throw pendingErrors.shift();
    }
  }
  function tryRunTask(task) {
    try {
      task.call();
    } catch (error2) {
      pendingErrors.push(error2);
      setTimeout(throwFirstError, 0);
    }
  }
  function process2() {
    const capacity = 1024;
    let index2 = 0;
    while (index2 < tasks2.length) {
      tryRunTask(tasks2[index2]);
      index2++;
      if (index2 > capacity) {
        for (let scan2 = 0, newLength = tasks2.length - index2; scan2 < newLength; scan2++) {
          tasks2[scan2] = tasks2[scan2 + index2];
        }
        tasks2.length -= index2;
        index2 = 0;
      }
    }
    tasks2.length = 0;
  }
  function enqueue(callable) {
    if (tasks2.length < 1) {
      $global.requestAnimationFrame(process2);
    }
    tasks2.push(callable);
  }
  return Object.freeze({
    enqueue,
    process: process2
  });
});
const fastHTMLPolicy = $global.trustedTypes.createPolicy("fast-html", {
  createHTML: (html2) => html2
});
let htmlPolicy = fastHTMLPolicy;
const marker$1 = `fast-${Math.random().toString(36).substring(2, 8)}`;
const _interpolationStart = `${marker$1}{`;
const _interpolationEnd = `}${marker$1}`;
const DOM = Object.freeze({
  supportsAdoptedStyleSheets: Array.isArray(document.adoptedStyleSheets) && "replace" in CSSStyleSheet.prototype,
  setHTMLPolicy(policy2) {
    if (htmlPolicy !== fastHTMLPolicy) {
      throw new Error("The HTML policy can only be set once.");
    }
    htmlPolicy = policy2;
  },
  createHTML(html2) {
    return htmlPolicy.createHTML(html2);
  },
  isMarker(node) {
    return node && node.nodeType === 8 && node.data.startsWith(marker$1);
  },
  extractDirectiveIndexFromMarker(node) {
    return parseInt(node.data.replace(`${marker$1}:`, ""));
  },
  createInterpolationPlaceholder(index2) {
    return `${_interpolationStart}${index2}${_interpolationEnd}`;
  },
  createCustomAttributePlaceholder(attributeName, index2) {
    return `${attributeName}="${this.createInterpolationPlaceholder(index2)}"`;
  },
  createBlockPlaceholder(index2) {
    return `<!--${marker$1}:${index2}-->`;
  },
  queueUpdate: updateQueue.enqueue,
  processUpdates: updateQueue.process,
  nextUpdate() {
    return new Promise(updateQueue.enqueue);
  },
  setAttribute(element2, attributeName, value2) {
    if (value2 === null || value2 === void 0) {
      element2.removeAttribute(attributeName);
    } else {
      element2.setAttribute(attributeName, value2);
    }
  },
  setBooleanAttribute(element2, attributeName, value2) {
    value2 ? element2.setAttribute(attributeName, "") : element2.removeAttribute(attributeName);
  },
  removeChildNodes(parent) {
    for (let child = parent.firstChild; child !== null; child = parent.firstChild) {
      parent.removeChild(child);
    }
  },
  createTemplateWalker(fragment) {
    return document.createTreeWalker(fragment, 133, null, false);
  }
});
function spilloverSubscribe(subscriber) {
  const spillover = this.spillover;
  const index2 = spillover.indexOf(subscriber);
  if (index2 === -1) {
    spillover.push(subscriber);
  }
}
function spilloverUnsubscribe(subscriber) {
  const spillover = this.spillover;
  const index2 = spillover.indexOf(subscriber);
  if (index2 !== -1) {
    spillover.splice(index2, 1);
  }
}
function spilloverNotifySubscribers(args2) {
  const spillover = this.spillover;
  const source = this.source;
  for (let i2 = 0, ii = spillover.length; i2 < ii; ++i2) {
    spillover[i2].handleChange(source, args2);
  }
}
function spilloverHas(subscriber) {
  return this.spillover.indexOf(subscriber) !== -1;
}
class SubscriberSet {
  constructor(source, initialSubscriber) {
    this.sub1 = void 0;
    this.sub2 = void 0;
    this.spillover = void 0;
    this.source = source;
    this.sub1 = initialSubscriber;
  }
  has(subscriber) {
    return this.sub1 === subscriber || this.sub2 === subscriber;
  }
  subscribe(subscriber) {
    if (this.has(subscriber)) {
      return;
    }
    if (this.sub1 === void 0) {
      this.sub1 = subscriber;
      return;
    }
    if (this.sub2 === void 0) {
      this.sub2 = subscriber;
      return;
    }
    this.spillover = [this.sub1, this.sub2, subscriber];
    this.subscribe = spilloverSubscribe;
    this.unsubscribe = spilloverUnsubscribe;
    this.notify = spilloverNotifySubscribers;
    this.has = spilloverHas;
    this.sub1 = void 0;
    this.sub2 = void 0;
  }
  unsubscribe(subscriber) {
    if (this.sub1 === subscriber) {
      this.sub1 = void 0;
    } else if (this.sub2 === subscriber) {
      this.sub2 = void 0;
    }
  }
  notify(args2) {
    const sub1 = this.sub1;
    const sub2 = this.sub2;
    const source = this.source;
    if (sub1 !== void 0) {
      sub1.handleChange(source, args2);
    }
    if (sub2 !== void 0) {
      sub2.handleChange(source, args2);
    }
  }
}
class PropertyChangeNotifier {
  constructor(source) {
    this.subscribers = {};
    this.sourceSubscribers = null;
    this.source = source;
  }
  notify(propertyName) {
    var _a2;
    const subscribers = this.subscribers[propertyName];
    if (subscribers !== void 0) {
      subscribers.notify(propertyName);
    }
    (_a2 = this.sourceSubscribers) === null || _a2 === void 0 ? void 0 : _a2.notify(propertyName);
  }
  subscribe(subscriber, propertyToWatch) {
    var _a2;
    if (propertyToWatch) {
      let subscribers = this.subscribers[propertyToWatch];
      if (subscribers === void 0) {
        this.subscribers[propertyToWatch] = subscribers = new SubscriberSet(this.source);
      }
      subscribers.subscribe(subscriber);
    } else {
      this.sourceSubscribers = (_a2 = this.sourceSubscribers) !== null && _a2 !== void 0 ? _a2 : new SubscriberSet(this.source);
      this.sourceSubscribers.subscribe(subscriber);
    }
  }
  unsubscribe(subscriber, propertyToUnwatch) {
    var _a2;
    if (propertyToUnwatch) {
      const subscribers = this.subscribers[propertyToUnwatch];
      if (subscribers !== void 0) {
        subscribers.unsubscribe(subscriber);
      }
    } else {
      (_a2 = this.sourceSubscribers) === null || _a2 === void 0 ? void 0 : _a2.unsubscribe(subscriber);
    }
  }
}
const Observable = FAST.getById(2, () => {
  const volatileRegex = /(:|&&|\|\||if)/;
  const notifierLookup = /* @__PURE__ */ new WeakMap();
  const accessorLookup = /* @__PURE__ */ new WeakMap();
  const queueUpdate = DOM.queueUpdate;
  let watcher = void 0;
  let createArrayObserver = (array) => {
    throw new Error("Must call enableArrayObservation before observing arrays.");
  };
  function getNotifier(source) {
    let found = source.$fastController || notifierLookup.get(source);
    if (found === void 0) {
      if (Array.isArray(source)) {
        found = createArrayObserver(source);
      } else {
        notifierLookup.set(source, found = new PropertyChangeNotifier(source));
      }
    }
    return found;
  }
  function getAccessors(target) {
    let accessors = accessorLookup.get(target);
    if (accessors === void 0) {
      let currentTarget = Reflect.getPrototypeOf(target);
      while (accessors === void 0 && currentTarget !== null) {
        accessors = accessorLookup.get(currentTarget);
        currentTarget = Reflect.getPrototypeOf(currentTarget);
      }
      if (accessors === void 0) {
        accessors = [];
      } else {
        accessors = accessors.slice(0);
      }
      accessorLookup.set(target, accessors);
    }
    return accessors;
  }
  class DefaultObservableAccessor {
    constructor(name) {
      this.name = name;
      this.field = `_${name}`;
      this.callback = `${name}Changed`;
    }
    getValue(source) {
      if (watcher !== void 0) {
        watcher.watch(source, this.name);
      }
      return source[this.field];
    }
    setValue(source, newValue) {
      const field = this.field;
      const oldValue = source[field];
      if (oldValue !== newValue) {
        source[field] = newValue;
        const callback = source[this.callback];
        if (typeof callback === "function") {
          callback.call(source, oldValue, newValue);
        }
        getNotifier(source).notify(this.name);
      }
    }
  }
  class BindingObserverImplementation extends SubscriberSet {
    constructor(binding, initialSubscriber, isVolatileBinding = false) {
      super(binding, initialSubscriber);
      this.binding = binding;
      this.isVolatileBinding = isVolatileBinding;
      this.needsRefresh = true;
      this.needsQueue = true;
      this.first = this;
      this.last = null;
      this.propertySource = void 0;
      this.propertyName = void 0;
      this.notifier = void 0;
      this.next = void 0;
    }
    observe(source, context) {
      if (this.needsRefresh && this.last !== null) {
        this.disconnect();
      }
      const previousWatcher = watcher;
      watcher = this.needsRefresh ? this : void 0;
      this.needsRefresh = this.isVolatileBinding;
      const result2 = this.binding(source, context);
      watcher = previousWatcher;
      return result2;
    }
    disconnect() {
      if (this.last !== null) {
        let current = this.first;
        while (current !== void 0) {
          current.notifier.unsubscribe(this, current.propertyName);
          current = current.next;
        }
        this.last = null;
        this.needsRefresh = this.needsQueue = true;
      }
    }
    watch(propertySource, propertyName) {
      const prev = this.last;
      const notifier = getNotifier(propertySource);
      const current = prev === null ? this.first : {};
      current.propertySource = propertySource;
      current.propertyName = propertyName;
      current.notifier = notifier;
      notifier.subscribe(this, propertyName);
      if (prev !== null) {
        if (!this.needsRefresh) {
          let prevValue;
          watcher = void 0;
          prevValue = prev.propertySource[prev.propertyName];
          watcher = this;
          if (propertySource === prevValue) {
            this.needsRefresh = true;
          }
        }
        prev.next = current;
      }
      this.last = current;
    }
    handleChange() {
      if (this.needsQueue) {
        this.needsQueue = false;
        queueUpdate(this);
      }
    }
    call() {
      if (this.last !== null) {
        this.needsQueue = true;
        this.notify(this);
      }
    }
    records() {
      let next2 = this.first;
      return {
        next: () => {
          const current = next2;
          if (current === void 0) {
            return { value: void 0, done: true };
          } else {
            next2 = next2.next;
            return {
              value: current,
              done: false
            };
          }
        },
        [Symbol.iterator]: function() {
          return this;
        }
      };
    }
  }
  return Object.freeze({
    setArrayObserverFactory(factory2) {
      createArrayObserver = factory2;
    },
    getNotifier,
    track(source, propertyName) {
      if (watcher !== void 0) {
        watcher.watch(source, propertyName);
      }
    },
    trackVolatile() {
      if (watcher !== void 0) {
        watcher.needsRefresh = true;
      }
    },
    notify(source, args2) {
      getNotifier(source).notify(args2);
    },
    defineProperty(target, nameOrAccessor) {
      if (typeof nameOrAccessor === "string") {
        nameOrAccessor = new DefaultObservableAccessor(nameOrAccessor);
      }
      getAccessors(target).push(nameOrAccessor);
      Reflect.defineProperty(target, nameOrAccessor.name, {
        enumerable: true,
        get: function() {
          return nameOrAccessor.getValue(this);
        },
        set: function(newValue) {
          nameOrAccessor.setValue(this, newValue);
        }
      });
    },
    getAccessors,
    binding(binding, initialSubscriber, isVolatileBinding = this.isVolatileBinding(binding)) {
      return new BindingObserverImplementation(binding, initialSubscriber, isVolatileBinding);
    },
    isVolatileBinding(binding) {
      return volatileRegex.test(binding.toString());
    }
  });
});
function observable(target, nameOrAccessor) {
  Observable.defineProperty(target, nameOrAccessor);
}
const contextEvent = FAST.getById(3, () => {
  let current = null;
  return {
    get() {
      return current;
    },
    set(event2) {
      current = event2;
    }
  };
});
class ExecutionContext {
  constructor() {
    this.index = 0;
    this.length = 0;
    this.parent = null;
    this.parentContext = null;
  }
  get event() {
    return contextEvent.get();
  }
  get isEven() {
    return this.index % 2 === 0;
  }
  get isOdd() {
    return this.index % 2 !== 0;
  }
  get isFirst() {
    return this.index === 0;
  }
  get isInMiddle() {
    return !this.isFirst && !this.isLast;
  }
  get isLast() {
    return this.index === this.length - 1;
  }
  static setEvent(event2) {
    contextEvent.set(event2);
  }
}
Observable.defineProperty(ExecutionContext.prototype, "index");
Observable.defineProperty(ExecutionContext.prototype, "length");
const defaultExecutionContext = Object.seal(new ExecutionContext());
class HTMLDirective {
  constructor() {
    this.targetIndex = 0;
  }
}
class TargetedHTMLDirective extends HTMLDirective {
  constructor() {
    super(...arguments);
    this.createPlaceholder = DOM.createInterpolationPlaceholder;
  }
}
class AttachedBehaviorHTMLDirective extends HTMLDirective {
  constructor(name, behavior, options2) {
    super();
    this.name = name;
    this.behavior = behavior;
    this.options = options2;
  }
  createPlaceholder(index2) {
    return DOM.createCustomAttributePlaceholder(this.name, index2);
  }
  createBehavior(target) {
    return new this.behavior(target, this.options);
  }
}
function normalBind(source, context) {
  this.source = source;
  this.context = context;
  if (this.bindingObserver === null) {
    this.bindingObserver = Observable.binding(this.binding, this, this.isBindingVolatile);
  }
  this.updateTarget(this.bindingObserver.observe(source, context));
}
function triggerBind(source, context) {
  this.source = source;
  this.context = context;
  this.target.addEventListener(this.targetName, this);
}
function normalUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
}
function contentUnbind() {
  this.bindingObserver.disconnect();
  this.source = null;
  this.context = null;
  const view = this.target.$fastView;
  if (view !== void 0 && view.isComposed) {
    view.unbind();
    view.needsBindOnly = true;
  }
}
function triggerUnbind() {
  this.target.removeEventListener(this.targetName, this);
  this.source = null;
  this.context = null;
}
function updateAttributeTarget(value2) {
  DOM.setAttribute(this.target, this.targetName, value2);
}
function updateBooleanAttributeTarget(value2) {
  DOM.setBooleanAttribute(this.target, this.targetName, value2);
}
function updateContentTarget(value2) {
  if (value2 === null || value2 === void 0) {
    value2 = "";
  }
  if (value2.create) {
    this.target.textContent = "";
    let view = this.target.$fastView;
    if (view === void 0) {
      view = value2.create();
    } else {
      if (this.target.$fastTemplate !== value2) {
        if (view.isComposed) {
          view.remove();
          view.unbind();
        }
        view = value2.create();
      }
    }
    if (!view.isComposed) {
      view.isComposed = true;
      view.bind(this.source, this.context);
      view.insertBefore(this.target);
      this.target.$fastView = view;
      this.target.$fastTemplate = value2;
    } else if (view.needsBindOnly) {
      view.needsBindOnly = false;
      view.bind(this.source, this.context);
    }
  } else {
    const view = this.target.$fastView;
    if (view !== void 0 && view.isComposed) {
      view.isComposed = false;
      view.remove();
      if (view.needsBindOnly) {
        view.needsBindOnly = false;
      } else {
        view.unbind();
      }
    }
    this.target.textContent = value2;
  }
}
function updatePropertyTarget(value2) {
  this.target[this.targetName] = value2;
}
function updateClassTarget(value2) {
  const classVersions = this.classVersions || /* @__PURE__ */ Object.create(null);
  const target = this.target;
  let version2 = this.version || 0;
  if (value2 !== null && value2 !== void 0 && value2.length) {
    const names = value2.split(/\s+/);
    for (let i2 = 0, ii = names.length; i2 < ii; ++i2) {
      const currentName = names[i2];
      if (currentName === "") {
        continue;
      }
      classVersions[currentName] = version2;
      target.classList.add(currentName);
    }
  }
  this.classVersions = classVersions;
  this.version = version2 + 1;
  if (version2 === 0) {
    return;
  }
  version2 -= 1;
  for (const name in classVersions) {
    if (classVersions[name] === version2) {
      target.classList.remove(name);
    }
  }
}
class HTMLBindingDirective extends TargetedHTMLDirective {
  constructor(binding) {
    super();
    this.binding = binding;
    this.bind = normalBind;
    this.unbind = normalUnbind;
    this.updateTarget = updateAttributeTarget;
    this.isBindingVolatile = Observable.isVolatileBinding(this.binding);
  }
  get targetName() {
    return this.originalTargetName;
  }
  set targetName(value2) {
    this.originalTargetName = value2;
    if (value2 === void 0) {
      return;
    }
    switch (value2[0]) {
      case ":":
        this.cleanedTargetName = value2.substr(1);
        this.updateTarget = updatePropertyTarget;
        if (this.cleanedTargetName === "innerHTML") {
          const binding = this.binding;
          this.binding = (s, c2) => DOM.createHTML(binding(s, c2));
        }
        break;
      case "?":
        this.cleanedTargetName = value2.substr(1);
        this.updateTarget = updateBooleanAttributeTarget;
        break;
      case "@":
        this.cleanedTargetName = value2.substr(1);
        this.bind = triggerBind;
        this.unbind = triggerUnbind;
        break;
      default:
        this.cleanedTargetName = value2;
        if (value2 === "class") {
          this.updateTarget = updateClassTarget;
        }
        break;
    }
  }
  targetAtContent() {
    this.updateTarget = updateContentTarget;
    this.unbind = contentUnbind;
  }
  createBehavior(target) {
    return new BindingBehavior(target, this.binding, this.isBindingVolatile, this.bind, this.unbind, this.updateTarget, this.cleanedTargetName);
  }
}
class BindingBehavior {
  constructor(target, binding, isBindingVolatile, bind2, unbind, updateTarget, targetName) {
    this.source = null;
    this.context = null;
    this.bindingObserver = null;
    this.target = target;
    this.binding = binding;
    this.isBindingVolatile = isBindingVolatile;
    this.bind = bind2;
    this.unbind = unbind;
    this.updateTarget = updateTarget;
    this.targetName = targetName;
  }
  handleChange() {
    this.updateTarget(this.bindingObserver.observe(this.source, this.context));
  }
  handleEvent(event2) {
    ExecutionContext.setEvent(event2);
    const result2 = this.binding(this.source, this.context);
    ExecutionContext.setEvent(null);
    if (result2 !== true) {
      event2.preventDefault();
    }
  }
}
let sharedContext = null;
class CompilationContext {
  addFactory(factory2) {
    factory2.targetIndex = this.targetIndex;
    this.behaviorFactories.push(factory2);
  }
  captureContentBinding(directive2) {
    directive2.targetAtContent();
    this.addFactory(directive2);
  }
  reset() {
    this.behaviorFactories = [];
    this.targetIndex = -1;
  }
  release() {
    sharedContext = this;
  }
  static borrow(directives2) {
    const shareable = sharedContext || new CompilationContext();
    shareable.directives = directives2;
    shareable.reset();
    sharedContext = null;
    return shareable;
  }
}
function createAggregateBinding(parts2) {
  if (parts2.length === 1) {
    return parts2[0];
  }
  let targetName;
  const partCount = parts2.length;
  const finalParts = parts2.map((x2) => {
    if (typeof x2 === "string") {
      return () => x2;
    }
    targetName = x2.targetName || targetName;
    return x2.binding;
  });
  const binding = (scope, context) => {
    let output = "";
    for (let i2 = 0; i2 < partCount; ++i2) {
      output += finalParts[i2](scope, context);
    }
    return output;
  };
  const directive2 = new HTMLBindingDirective(binding);
  directive2.targetName = targetName;
  return directive2;
}
const interpolationEndLength = _interpolationEnd.length;
function parseContent$1(context, value2) {
  const valueParts = value2.split(_interpolationStart);
  if (valueParts.length === 1) {
    return null;
  }
  const bindingParts = [];
  for (let i2 = 0, ii = valueParts.length; i2 < ii; ++i2) {
    const current = valueParts[i2];
    const index2 = current.indexOf(_interpolationEnd);
    let literal;
    if (index2 === -1) {
      literal = current;
    } else {
      const directiveIndex = parseInt(current.substring(0, index2));
      bindingParts.push(context.directives[directiveIndex]);
      literal = current.substring(index2 + interpolationEndLength);
    }
    if (literal !== "") {
      bindingParts.push(literal);
    }
  }
  return bindingParts;
}
function compileAttributes(context, node, includeBasicValues = false) {
  const attributes = node.attributes;
  for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
    const attr2 = attributes[i2];
    const attrValue = attr2.value;
    const parseResult = parseContent$1(context, attrValue);
    let result2 = null;
    if (parseResult === null) {
      if (includeBasicValues) {
        result2 = new HTMLBindingDirective(() => attrValue);
        result2.targetName = attr2.name;
      }
    } else {
      result2 = createAggregateBinding(parseResult);
    }
    if (result2 !== null) {
      node.removeAttributeNode(attr2);
      i2--;
      ii--;
      context.addFactory(result2);
    }
  }
}
function compileContent(context, node, walker) {
  const parseResult = parseContent$1(context, node.textContent);
  if (parseResult !== null) {
    let lastNode = node;
    for (let i2 = 0, ii = parseResult.length; i2 < ii; ++i2) {
      const currentPart = parseResult[i2];
      const currentNode = i2 === 0 ? node : lastNode.parentNode.insertBefore(document.createTextNode(""), lastNode.nextSibling);
      if (typeof currentPart === "string") {
        currentNode.textContent = currentPart;
      } else {
        currentNode.textContent = " ";
        context.captureContentBinding(currentPart);
      }
      lastNode = currentNode;
      context.targetIndex++;
      if (currentNode !== node) {
        walker.nextNode();
      }
    }
    context.targetIndex--;
  }
}
function compileTemplate(template2, directives2) {
  const fragment = template2.content;
  document.adoptNode(fragment);
  const context = CompilationContext.borrow(directives2);
  compileAttributes(context, template2, true);
  const hostBehaviorFactories = context.behaviorFactories;
  context.reset();
  const walker = DOM.createTemplateWalker(fragment);
  let node;
  while (node = walker.nextNode()) {
    context.targetIndex++;
    switch (node.nodeType) {
      case 1:
        compileAttributes(context, node);
        break;
      case 3:
        compileContent(context, node, walker);
        break;
      case 8:
        if (DOM.isMarker(node)) {
          context.addFactory(directives2[DOM.extractDirectiveIndexFromMarker(node)]);
        }
    }
  }
  let targetOffset = 0;
  if (DOM.isMarker(fragment.firstChild) || fragment.childNodes.length === 1 && directives2.length) {
    fragment.insertBefore(document.createComment(""), fragment.firstChild);
    targetOffset = -1;
  }
  const viewBehaviorFactories = context.behaviorFactories;
  context.release();
  return {
    fragment,
    viewBehaviorFactories,
    hostBehaviorFactories,
    targetOffset
  };
}
const range = document.createRange();
class HTMLView {
  constructor(fragment, behaviors) {
    this.fragment = fragment;
    this.behaviors = behaviors;
    this.source = null;
    this.context = null;
    this.firstChild = fragment.firstChild;
    this.lastChild = fragment.lastChild;
  }
  appendTo(node) {
    node.appendChild(this.fragment);
  }
  insertBefore(node) {
    if (this.fragment.hasChildNodes()) {
      node.parentNode.insertBefore(this.fragment, node);
    } else {
      const parentNode = node.parentNode;
      const end = this.lastChild;
      let current = this.firstChild;
      let next2;
      while (current !== end) {
        next2 = current.nextSibling;
        parentNode.insertBefore(current, node);
        current = next2;
      }
      parentNode.insertBefore(end, node);
    }
  }
  remove() {
    const fragment = this.fragment;
    const end = this.lastChild;
    let current = this.firstChild;
    let next2;
    while (current !== end) {
      next2 = current.nextSibling;
      fragment.appendChild(current);
      current = next2;
    }
    fragment.appendChild(end);
  }
  dispose() {
    const parent = this.firstChild.parentNode;
    const end = this.lastChild;
    let current = this.firstChild;
    let next2;
    while (current !== end) {
      next2 = current.nextSibling;
      parent.removeChild(current);
      current = next2;
    }
    parent.removeChild(end);
    const behaviors = this.behaviors;
    const oldSource = this.source;
    for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
      behaviors[i2].unbind(oldSource);
    }
  }
  bind(source, context) {
    const behaviors = this.behaviors;
    if (this.source === source) {
      return;
    } else if (this.source !== null) {
      const oldSource = this.source;
      this.source = source;
      this.context = context;
      for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
        const current = behaviors[i2];
        current.unbind(oldSource);
        current.bind(source, context);
      }
    } else {
      this.source = source;
      this.context = context;
      for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
        behaviors[i2].bind(source, context);
      }
    }
  }
  unbind() {
    if (this.source === null) {
      return;
    }
    const behaviors = this.behaviors;
    const oldSource = this.source;
    for (let i2 = 0, ii = behaviors.length; i2 < ii; ++i2) {
      behaviors[i2].unbind(oldSource);
    }
    this.source = null;
  }
  static disposeContiguousBatch(views) {
    if (views.length === 0) {
      return;
    }
    range.setStartBefore(views[0].firstChild);
    range.setEndAfter(views[views.length - 1].lastChild);
    range.deleteContents();
    for (let i2 = 0, ii = views.length; i2 < ii; ++i2) {
      const view = views[i2];
      const behaviors = view.behaviors;
      const oldSource = view.source;
      for (let j2 = 0, jj = behaviors.length; j2 < jj; ++j2) {
        behaviors[j2].unbind(oldSource);
      }
    }
  }
}
class ViewTemplate {
  constructor(html2, directives2) {
    this.behaviorCount = 0;
    this.hasHostBehaviors = false;
    this.fragment = null;
    this.targetOffset = 0;
    this.viewBehaviorFactories = null;
    this.hostBehaviorFactories = null;
    this.html = html2;
    this.directives = directives2;
  }
  create(hostBindingTarget) {
    if (this.fragment === null) {
      let template2;
      const html2 = this.html;
      if (typeof html2 === "string") {
        template2 = document.createElement("template");
        template2.innerHTML = DOM.createHTML(html2);
        const fec = template2.content.firstElementChild;
        if (fec !== null && fec.tagName === "TEMPLATE") {
          template2 = fec;
        }
      } else {
        template2 = html2;
      }
      const result2 = compileTemplate(template2, this.directives);
      this.fragment = result2.fragment;
      this.viewBehaviorFactories = result2.viewBehaviorFactories;
      this.hostBehaviorFactories = result2.hostBehaviorFactories;
      this.targetOffset = result2.targetOffset;
      this.behaviorCount = this.viewBehaviorFactories.length + this.hostBehaviorFactories.length;
      this.hasHostBehaviors = this.hostBehaviorFactories.length > 0;
    }
    const fragment = this.fragment.cloneNode(true);
    const viewFactories = this.viewBehaviorFactories;
    const behaviors = new Array(this.behaviorCount);
    const walker = DOM.createTemplateWalker(fragment);
    let behaviorIndex = 0;
    let targetIndex = this.targetOffset;
    let node = walker.nextNode();
    for (let ii = viewFactories.length; behaviorIndex < ii; ++behaviorIndex) {
      const factory2 = viewFactories[behaviorIndex];
      const factoryIndex = factory2.targetIndex;
      while (node !== null) {
        if (targetIndex === factoryIndex) {
          behaviors[behaviorIndex] = factory2.createBehavior(node);
          break;
        } else {
          node = walker.nextNode();
          targetIndex++;
        }
      }
    }
    if (this.hasHostBehaviors) {
      const hostFactories = this.hostBehaviorFactories;
      for (let i2 = 0, ii = hostFactories.length; i2 < ii; ++i2, ++behaviorIndex) {
        behaviors[behaviorIndex] = hostFactories[i2].createBehavior(hostBindingTarget);
      }
    }
    return new HTMLView(fragment, behaviors);
  }
  render(source, host, hostBindingTarget) {
    if (typeof host === "string") {
      host = document.getElementById(host);
    }
    if (hostBindingTarget === void 0) {
      hostBindingTarget = host;
    }
    const view = this.create(hostBindingTarget);
    view.bind(source, defaultExecutionContext);
    view.appendTo(host);
    return view;
  }
}
const lastAttributeNameRegex$1 = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
function html$1$1(strings2, ...values) {
  const directives2 = [];
  let html2 = "";
  for (let i2 = 0, ii = strings2.length - 1; i2 < ii; ++i2) {
    const currentString = strings2[i2];
    let value2 = values[i2];
    html2 += currentString;
    if (value2 instanceof ViewTemplate) {
      const template2 = value2;
      value2 = () => template2;
    }
    if (typeof value2 === "function") {
      value2 = new HTMLBindingDirective(value2);
    }
    if (value2 instanceof TargetedHTMLDirective) {
      const match = lastAttributeNameRegex$1.exec(currentString);
      if (match !== null) {
        value2.targetName = match[2];
      }
    }
    if (value2 instanceof HTMLDirective) {
      html2 += value2.createPlaceholder(directives2.length);
      directives2.push(value2);
    } else {
      html2 += value2;
    }
  }
  html2 += strings2[strings2.length - 1];
  return new ViewTemplate(html2, directives2);
}
class ElementStyles {
  constructor() {
    this.targets = /* @__PURE__ */ new WeakSet();
    this.behaviors = null;
  }
  addStylesTo(target) {
    this.targets.add(target);
  }
  removeStylesFrom(target) {
    this.targets.delete(target);
  }
  isAttachedTo(target) {
    return this.targets.has(target);
  }
  withBehaviors(...behaviors) {
    this.behaviors = this.behaviors === null ? behaviors : this.behaviors.concat(behaviors);
    return this;
  }
}
ElementStyles.create = (() => {
  if (DOM.supportsAdoptedStyleSheets) {
    const styleSheetCache = /* @__PURE__ */ new Map();
    return (styles2) => new AdoptedStyleSheetsStyles(styles2, styleSheetCache);
  }
  return (styles2) => new StyleElementStyles(styles2);
})();
function reduceStyles(styles2) {
  return styles2.map((x2) => x2 instanceof ElementStyles ? reduceStyles(x2.styles) : [x2]).reduce((prev, curr) => prev.concat(curr), []);
}
function reduceBehaviors(styles2) {
  return styles2.map((x2) => x2 instanceof ElementStyles ? x2.behaviors : null).reduce((prev, curr) => {
    if (curr === null) {
      return prev;
    }
    if (prev === null) {
      prev = [];
    }
    return prev.concat(curr);
  }, null);
}
class AdoptedStyleSheetsStyles extends ElementStyles {
  constructor(styles2, styleSheetCache) {
    super();
    this.styles = styles2;
    this.styleSheetCache = styleSheetCache;
    this._styleSheets = void 0;
    this.behaviors = reduceBehaviors(styles2);
  }
  get styleSheets() {
    if (this._styleSheets === void 0) {
      const styles2 = this.styles;
      const styleSheetCache = this.styleSheetCache;
      this._styleSheets = reduceStyles(styles2).map((x2) => {
        if (x2 instanceof CSSStyleSheet) {
          return x2;
        }
        let sheet = styleSheetCache.get(x2);
        if (sheet === void 0) {
          sheet = new CSSStyleSheet();
          sheet.replaceSync(x2);
          styleSheetCache.set(x2, sheet);
        }
        return sheet;
      });
    }
    return this._styleSheets;
  }
  addStylesTo(target) {
    target.adoptedStyleSheets = [...target.adoptedStyleSheets, ...this.styleSheets];
    super.addStylesTo(target);
  }
  removeStylesFrom(target) {
    const sourceSheets = this.styleSheets;
    target.adoptedStyleSheets = target.adoptedStyleSheets.filter((x2) => sourceSheets.indexOf(x2) === -1);
    super.removeStylesFrom(target);
  }
}
let styleClassId = 0;
function getNextStyleClass() {
  return `fast-style-class-${++styleClassId}`;
}
class StyleElementStyles extends ElementStyles {
  constructor(styles2) {
    super();
    this.styles = styles2;
    this.behaviors = null;
    this.behaviors = reduceBehaviors(styles2);
    this.styleSheets = reduceStyles(styles2);
    this.styleClass = getNextStyleClass();
  }
  addStylesTo(target) {
    const styleSheets = this.styleSheets;
    const styleClass = this.styleClass;
    target = this.normalizeTarget(target);
    for (let i2 = 0; i2 < styleSheets.length; i2++) {
      const element2 = document.createElement("style");
      element2.innerHTML = styleSheets[i2];
      element2.className = styleClass;
      target.append(element2);
    }
    super.addStylesTo(target);
  }
  removeStylesFrom(target) {
    target = this.normalizeTarget(target);
    const styles2 = target.querySelectorAll(`.${this.styleClass}`);
    for (let i2 = 0, ii = styles2.length; i2 < ii; ++i2) {
      target.removeChild(styles2[i2]);
    }
    super.removeStylesFrom(target);
  }
  isAttachedTo(target) {
    return super.isAttachedTo(this.normalizeTarget(target));
  }
  normalizeTarget(target) {
    return target === document ? document.body : target;
  }
}
const booleanConverter = {
  toView(value2) {
    return value2 ? "true" : "false";
  },
  fromView(value2) {
    if (value2 === null || value2 === void 0 || value2 === "false" || value2 === false || value2 === 0) {
      return false;
    }
    return true;
  }
};
const nullableNumberConverter = {
  toView(value2) {
    if (value2 === null || value2 === void 0) {
      return null;
    }
    const number2 = value2 * 1;
    return isNaN(number2) ? null : number2.toString();
  },
  fromView(value2) {
    if (value2 === null || value2 === void 0) {
      return null;
    }
    const number2 = value2 * 1;
    return isNaN(number2) ? null : number2;
  }
};
class AttributeDefinition {
  constructor(Owner, name, attribute = name.toLowerCase(), mode = "reflect", converter) {
    this.guards = /* @__PURE__ */ new Set();
    this.Owner = Owner;
    this.name = name;
    this.attribute = attribute;
    this.mode = mode;
    this.converter = converter;
    this.fieldName = `_${name}`;
    this.callbackName = `${name}Changed`;
    this.hasCallback = this.callbackName in Owner.prototype;
    if (mode === "boolean" && converter === void 0) {
      this.converter = booleanConverter;
    }
  }
  setValue(source, newValue) {
    const oldValue = source[this.fieldName];
    const converter = this.converter;
    if (converter !== void 0) {
      newValue = converter.fromView(newValue);
    }
    if (oldValue !== newValue) {
      source[this.fieldName] = newValue;
      this.tryReflectToAttribute(source);
      if (this.hasCallback) {
        source[this.callbackName](oldValue, newValue);
      }
      source.$fastController.notify(this.name);
    }
  }
  getValue(source) {
    Observable.track(source, this.name);
    return source[this.fieldName];
  }
  onAttributeChangedCallback(element2, value2) {
    if (this.guards.has(element2)) {
      return;
    }
    this.guards.add(element2);
    this.setValue(element2, value2);
    this.guards.delete(element2);
  }
  tryReflectToAttribute(element2) {
    const mode = this.mode;
    const guards = this.guards;
    if (guards.has(element2) || mode === "fromView") {
      return;
    }
    DOM.queueUpdate(() => {
      guards.add(element2);
      const latestValue = element2[this.fieldName];
      switch (mode) {
        case "reflect":
          const converter = this.converter;
          DOM.setAttribute(element2, this.attribute, converter !== void 0 ? converter.toView(latestValue) : latestValue);
          break;
        case "boolean":
          DOM.setBooleanAttribute(element2, this.attribute, latestValue);
          break;
      }
      guards.delete(element2);
    });
  }
  static collect(Owner, ...attributeLists) {
    const attributes = [];
    attributeLists.push(Owner.attributes);
    for (let i2 = 0, ii = attributeLists.length; i2 < ii; ++i2) {
      const list = attributeLists[i2];
      if (list === void 0) {
        continue;
      }
      for (let j2 = 0, jj = list.length; j2 < jj; ++j2) {
        const config2 = list[j2];
        if (typeof config2 === "string") {
          attributes.push(new AttributeDefinition(Owner, config2));
        } else {
          attributes.push(new AttributeDefinition(Owner, config2.property, config2.attribute, config2.mode, config2.converter));
        }
      }
    }
    return attributes;
  }
}
function attr$1(configOrTarget, prop) {
  let config2;
  function decorator($target, $prop) {
    if (arguments.length > 1) {
      config2.property = $prop;
    }
    const attributes = $target.constructor.attributes || ($target.constructor.attributes = []);
    attributes.push(config2);
  }
  if (arguments.length > 1) {
    config2 = {};
    decorator(configOrTarget, prop);
    return;
  }
  config2 = configOrTarget === void 0 ? {} : configOrTarget;
  return decorator;
}
const defaultShadowOptions = { mode: "open" };
const defaultElementOptions = {};
const fastRegistry = FAST.getById(4, () => {
  const typeToDefinition = /* @__PURE__ */ new Map();
  return Object.freeze({
    register(definition) {
      if (typeToDefinition.has(definition.type)) {
        return false;
      }
      typeToDefinition.set(definition.type, definition);
      return true;
    },
    getByType(key) {
      return typeToDefinition.get(key);
    }
  });
});
class FASTElementDefinition {
  constructor(type2, nameOrConfig = type2.definition) {
    if (typeof nameOrConfig === "string") {
      nameOrConfig = { name: nameOrConfig };
    }
    this.type = type2;
    this.name = nameOrConfig.name;
    this.template = nameOrConfig.template;
    const attributes = AttributeDefinition.collect(type2, nameOrConfig.attributes);
    const observedAttributes = new Array(attributes.length);
    const propertyLookup = {};
    const attributeLookup = {};
    for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
      const current = attributes[i2];
      observedAttributes[i2] = current.attribute;
      propertyLookup[current.name] = current;
      attributeLookup[current.attribute] = current;
    }
    this.attributes = attributes;
    this.observedAttributes = observedAttributes;
    this.propertyLookup = propertyLookup;
    this.attributeLookup = attributeLookup;
    this.shadowOptions = nameOrConfig.shadowOptions === void 0 ? defaultShadowOptions : nameOrConfig.shadowOptions === null ? void 0 : Object.assign(Object.assign({}, defaultShadowOptions), nameOrConfig.shadowOptions);
    this.elementOptions = nameOrConfig.elementOptions === void 0 ? defaultElementOptions : Object.assign(Object.assign({}, defaultElementOptions), nameOrConfig.elementOptions);
    this.styles = nameOrConfig.styles === void 0 ? void 0 : Array.isArray(nameOrConfig.styles) ? ElementStyles.create(nameOrConfig.styles) : nameOrConfig.styles instanceof ElementStyles ? nameOrConfig.styles : ElementStyles.create([nameOrConfig.styles]);
  }
  get isDefined() {
    return !!fastRegistry.getByType(this.type);
  }
  define(registry = customElements) {
    const type2 = this.type;
    if (fastRegistry.register(this)) {
      const attributes = this.attributes;
      const proto = type2.prototype;
      for (let i2 = 0, ii = attributes.length; i2 < ii; ++i2) {
        Observable.defineProperty(proto, attributes[i2]);
      }
      Reflect.defineProperty(type2, "observedAttributes", {
        value: this.observedAttributes,
        enumerable: true
      });
    }
    if (!registry.get(this.name)) {
      registry.define(this.name, type2, this.elementOptions);
    }
    return this;
  }
}
FASTElementDefinition.forType = fastRegistry.getByType;
const shadowRoots = /* @__PURE__ */ new WeakMap();
const defaultEventOptions = {
  bubbles: true,
  composed: true,
  cancelable: true
};
function getShadowRoot(element2) {
  return element2.shadowRoot || shadowRoots.get(element2) || null;
}
class Controller extends PropertyChangeNotifier {
  constructor(element2, definition) {
    super(element2);
    this.boundObservables = null;
    this.behaviors = null;
    this.needsInitialization = true;
    this._template = null;
    this._styles = null;
    this._isConnected = false;
    this.$fastController = this;
    this.view = null;
    this.element = element2;
    this.definition = definition;
    const shadowOptions = definition.shadowOptions;
    if (shadowOptions !== void 0) {
      const shadowRoot = element2.attachShadow(shadowOptions);
      if (shadowOptions.mode === "closed") {
        shadowRoots.set(element2, shadowRoot);
      }
    }
    const accessors = Observable.getAccessors(element2);
    if (accessors.length > 0) {
      const boundObservables = this.boundObservables = /* @__PURE__ */ Object.create(null);
      for (let i2 = 0, ii = accessors.length; i2 < ii; ++i2) {
        const propertyName = accessors[i2].name;
        const value2 = element2[propertyName];
        if (value2 !== void 0) {
          delete element2[propertyName];
          boundObservables[propertyName] = value2;
        }
      }
    }
  }
  get isConnected() {
    Observable.track(this, "isConnected");
    return this._isConnected;
  }
  setIsConnected(value2) {
    this._isConnected = value2;
    Observable.notify(this, "isConnected");
  }
  get template() {
    return this._template;
  }
  set template(value2) {
    if (this._template === value2) {
      return;
    }
    this._template = value2;
    if (!this.needsInitialization) {
      this.renderTemplate(value2);
    }
  }
  get styles() {
    return this._styles;
  }
  set styles(value2) {
    if (this._styles === value2) {
      return;
    }
    if (this._styles !== null) {
      this.removeStyles(this._styles);
    }
    this._styles = value2;
    if (!this.needsInitialization && value2 !== null) {
      this.addStyles(value2);
    }
  }
  addStyles(styles2) {
    const target = getShadowRoot(this.element) || this.element.getRootNode();
    if (styles2 instanceof HTMLStyleElement) {
      target.append(styles2);
    } else if (!styles2.isAttachedTo(target)) {
      const sourceBehaviors = styles2.behaviors;
      styles2.addStylesTo(target);
      if (sourceBehaviors !== null) {
        this.addBehaviors(sourceBehaviors);
      }
    }
  }
  removeStyles(styles2) {
    const target = getShadowRoot(this.element) || this.element.getRootNode();
    if (styles2 instanceof HTMLStyleElement) {
      target.removeChild(styles2);
    } else if (styles2.isAttachedTo(target)) {
      const sourceBehaviors = styles2.behaviors;
      styles2.removeStylesFrom(target);
      if (sourceBehaviors !== null) {
        this.removeBehaviors(sourceBehaviors);
      }
    }
  }
  addBehaviors(behaviors) {
    const targetBehaviors = this.behaviors || (this.behaviors = /* @__PURE__ */ new Map());
    const length = behaviors.length;
    const behaviorsToBind = [];
    for (let i2 = 0; i2 < length; ++i2) {
      const behavior = behaviors[i2];
      if (targetBehaviors.has(behavior)) {
        targetBehaviors.set(behavior, targetBehaviors.get(behavior) + 1);
      } else {
        targetBehaviors.set(behavior, 1);
        behaviorsToBind.push(behavior);
      }
    }
    if (this._isConnected) {
      const element2 = this.element;
      for (let i2 = 0; i2 < behaviorsToBind.length; ++i2) {
        behaviorsToBind[i2].bind(element2, defaultExecutionContext);
      }
    }
  }
  removeBehaviors(behaviors, force = false) {
    const targetBehaviors = this.behaviors;
    if (targetBehaviors === null) {
      return;
    }
    const length = behaviors.length;
    const behaviorsToUnbind = [];
    for (let i2 = 0; i2 < length; ++i2) {
      const behavior = behaviors[i2];
      if (targetBehaviors.has(behavior)) {
        const count = targetBehaviors.get(behavior) - 1;
        count === 0 || force ? targetBehaviors.delete(behavior) && behaviorsToUnbind.push(behavior) : targetBehaviors.set(behavior, count);
      }
    }
    if (this._isConnected) {
      const element2 = this.element;
      for (let i2 = 0; i2 < behaviorsToUnbind.length; ++i2) {
        behaviorsToUnbind[i2].unbind(element2);
      }
    }
  }
  onConnectedCallback() {
    if (this._isConnected) {
      return;
    }
    const element2 = this.element;
    if (this.needsInitialization) {
      this.finishInitialization();
    } else if (this.view !== null) {
      this.view.bind(element2, defaultExecutionContext);
    }
    const behaviors = this.behaviors;
    if (behaviors !== null) {
      for (const [behavior] of behaviors) {
        behavior.bind(element2, defaultExecutionContext);
      }
    }
    this.setIsConnected(true);
  }
  onDisconnectedCallback() {
    if (!this._isConnected) {
      return;
    }
    this.setIsConnected(false);
    const view = this.view;
    if (view !== null) {
      view.unbind();
    }
    const behaviors = this.behaviors;
    if (behaviors !== null) {
      const element2 = this.element;
      for (const [behavior] of behaviors) {
        behavior.unbind(element2);
      }
    }
  }
  onAttributeChangedCallback(name, oldValue, newValue) {
    const attrDef = this.definition.attributeLookup[name];
    if (attrDef !== void 0) {
      attrDef.onAttributeChangedCallback(this.element, newValue);
    }
  }
  emit(type2, detail, options2) {
    if (this._isConnected) {
      return this.element.dispatchEvent(new CustomEvent(type2, Object.assign(Object.assign({ detail }, defaultEventOptions), options2)));
    }
    return false;
  }
  finishInitialization() {
    const element2 = this.element;
    const boundObservables = this.boundObservables;
    if (boundObservables !== null) {
      const propertyNames = Object.keys(boundObservables);
      for (let i2 = 0, ii = propertyNames.length; i2 < ii; ++i2) {
        const propertyName = propertyNames[i2];
        element2[propertyName] = boundObservables[propertyName];
      }
      this.boundObservables = null;
    }
    const definition = this.definition;
    if (this._template === null) {
      if (this.element.resolveTemplate) {
        this._template = this.element.resolveTemplate();
      } else if (definition.template) {
        this._template = definition.template || null;
      }
    }
    if (this._template !== null) {
      this.renderTemplate(this._template);
    }
    if (this._styles === null) {
      if (this.element.resolveStyles) {
        this._styles = this.element.resolveStyles();
      } else if (definition.styles) {
        this._styles = definition.styles || null;
      }
    }
    if (this._styles !== null) {
      this.addStyles(this._styles);
    }
    this.needsInitialization = false;
  }
  renderTemplate(template2) {
    const element2 = this.element;
    const host = getShadowRoot(element2) || element2;
    if (this.view !== null) {
      this.view.dispose();
      this.view = null;
    } else if (!this.needsInitialization) {
      DOM.removeChildNodes(host);
    }
    if (template2) {
      this.view = template2.render(element2, host, element2);
    }
  }
  static forCustomElement(element2) {
    const controller = element2.$fastController;
    if (controller !== void 0) {
      return controller;
    }
    const definition = FASTElementDefinition.forType(element2.constructor);
    if (definition === void 0) {
      throw new Error("Missing FASTElement definition.");
    }
    return element2.$fastController = new Controller(element2, definition);
  }
}
function createFASTElement(BaseType) {
  return class extends BaseType {
    constructor() {
      super();
      Controller.forCustomElement(this);
    }
    $emit(type2, detail, options2) {
      return this.$fastController.emit(type2, detail, options2);
    }
    connectedCallback() {
      this.$fastController.onConnectedCallback();
    }
    disconnectedCallback() {
      this.$fastController.onDisconnectedCallback();
    }
    attributeChangedCallback(name, oldValue, newValue) {
      this.$fastController.onAttributeChangedCallback(name, oldValue, newValue);
    }
  };
}
const FASTElement = Object.assign(createFASTElement(HTMLElement), {
  from(BaseType) {
    return createFASTElement(BaseType);
  },
  define(type2, nameOrDef) {
    return new FASTElementDefinition(type2, nameOrDef).define().type;
  }
});
function customElement$1(nameOrDef) {
  return function(type2) {
    new FASTElementDefinition(type2, nameOrDef).define();
  };
}
class CSSDirective {
  createCSS() {
    return "";
  }
  createBehavior() {
    return void 0;
  }
}
function collectStyles(strings2, values) {
  const styles2 = [];
  let cssString = "";
  const behaviors = [];
  for (let i2 = 0, ii = strings2.length - 1; i2 < ii; ++i2) {
    cssString += strings2[i2];
    let value2 = values[i2];
    if (value2 instanceof CSSDirective) {
      const behavior = value2.createBehavior();
      value2 = value2.createCSS();
      if (behavior) {
        behaviors.push(behavior);
      }
    }
    if (value2 instanceof ElementStyles || value2 instanceof CSSStyleSheet) {
      if (cssString.trim() !== "") {
        styles2.push(cssString);
        cssString = "";
      }
      styles2.push(value2);
    } else {
      cssString += value2;
    }
  }
  cssString += strings2[strings2.length - 1];
  if (cssString.trim() !== "") {
    styles2.push(cssString);
  }
  return {
    styles: styles2,
    behaviors
  };
}
function css$4(strings2, ...values) {
  const { styles: styles2, behaviors } = collectStyles(strings2, values);
  const elementStyles = ElementStyles.create(styles2);
  if (behaviors.length) {
    elementStyles.withBehaviors(...behaviors);
  }
  return elementStyles;
}
class RefBehavior {
  constructor(target, propertyName) {
    this.target = target;
    this.propertyName = propertyName;
  }
  bind(source) {
    source[this.propertyName] = this.target;
  }
  unbind() {
  }
}
function ref(propertyName) {
  return new AttachedBehaviorHTMLDirective("fast-ref", RefBehavior, propertyName);
}
function when(binding, templateOrTemplateBinding) {
  const getTemplate = typeof templateOrTemplateBinding === "function" ? templateOrTemplateBinding : () => templateOrTemplateBinding;
  return (source, context) => binding(source, context) ? getTemplate(source, context) : null;
}
function elements(selector) {
  if (selector) {
    return function(value2, index2, array) {
      return value2.nodeType === 1 && value2.matches(selector);
    };
  }
  return function(value2, index2, array) {
    return value2.nodeType === 1;
  };
}
class NodeObservationBehavior {
  constructor(target, options2) {
    this.target = target;
    this.options = options2;
    this.source = null;
  }
  bind(source) {
    const name = this.options.property;
    this.shouldUpdate = Observable.getAccessors(source).some((x2) => x2.name === name);
    this.source = source;
    this.updateTarget(this.computeNodes());
    if (this.shouldUpdate) {
      this.observe();
    }
  }
  unbind() {
    this.updateTarget(emptyArray);
    this.source = null;
    if (this.shouldUpdate) {
      this.disconnect();
    }
  }
  handleEvent() {
    this.updateTarget(this.computeNodes());
  }
  computeNodes() {
    let nodes = this.getNodes();
    if (this.options.filter !== void 0) {
      nodes = nodes.filter(this.options.filter);
    }
    return nodes;
  }
  updateTarget(value2) {
    this.source[this.options.property] = value2;
  }
}
class SlottedBehavior extends NodeObservationBehavior {
  constructor(target, options2) {
    super(target, options2);
  }
  observe() {
    this.target.addEventListener("slotchange", this);
  }
  disconnect() {
    this.target.removeEventListener("slotchange", this);
  }
  getNodes() {
    return this.target.assignedNodes(this.options);
  }
}
function slotted(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = { property: propertyOrOptions };
  }
  return new AttachedBehaviorHTMLDirective("fast-slotted", SlottedBehavior, propertyOrOptions);
}
class ChildrenBehavior extends NodeObservationBehavior {
  constructor(target, options2) {
    super(target, options2);
    this.observer = null;
    options2.childList = true;
  }
  observe() {
    if (this.observer === null) {
      this.observer = new MutationObserver(this.handleEvent.bind(this));
    }
    this.observer.observe(this.target, this.options);
  }
  disconnect() {
    this.observer.disconnect();
  }
  getNodes() {
    if ("subtree" in this.options) {
      return Array.from(this.target.querySelectorAll(this.options.selector));
    }
    return Array.from(this.target.childNodes);
  }
}
function children$1(propertyOrOptions) {
  if (typeof propertyOrOptions === "string") {
    propertyOrOptions = {
      property: propertyOrOptions
    };
  }
  return new AttachedBehaviorHTMLDirective("fast-children", ChildrenBehavior, propertyOrOptions);
}
class StartEnd {
  handleStartContentChange() {
    this.startContainer.classList.toggle("start", this.start.assignedNodes().length > 0);
  }
  handleEndContentChange() {
    this.endContainer.classList.toggle("end", this.end.assignedNodes().length > 0);
  }
}
const endTemplate = html$1$1`
    <span part="end" ${ref("endContainer")}>
        <slot
            name="end"
            ${ref("end")}
            @slotchange="${(x2) => x2.handleEndContentChange()}"
        ></slot>
    </span>
`;
const startTemplate = html$1$1`
    <span part="start" ${ref("startContainer")}>
        <slot
            name="start"
            ${ref("start")}
            @slotchange="${(x2) => x2.handleStartContentChange()}"
        ></slot>
    </span>
`;
const AccordionItemTemplate = html$1$1`
    <template
        class="${(x2) => x2.expanded ? "expanded" : ""}"
        slot="item"
    >
        <div
            class="heading"
            part="heading"
            role="heading"
            aria-level="${(x2) => x2.headinglevel}"
        >
            <button
                class="button"
                part="button"
                ${ref("expandbutton")}
                aria-expanded="${(x2) => x2.expanded}"
                aria-controls="${(x2) => x2.id}-panel"
                id="${(x2) => x2.id}"
                @click="${(x2, c2) => x2.clickHandler(c2.event)}"
            >
                <span class="heading">
                    <slot name="heading" part="heading"></slot>
                </span>
            </button>
            ${startTemplate}
            ${endTemplate}
            <span class="icon" part="icon" aria-hidden="true">
                <slot name="expanded-icon" part="expanded-icon">
                    <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path
                            fill-rule="evenodd"
                            clip-rule="evenodd"
                            d="M3.78 3h12.44c.43 0 .78.35.78.78v12.44c0 .43-.35.78-.78.78H3.78a.78.78 0 01-.78-.78V3.78c0-.43.35-.78.78-.78zm12.44-1H3.78C2.8 2 2 2.8 2 3.78v12.44C2 17.2 2.8 18 3.78 18h12.44c.98 0 1.78-.8 1.78-1.78V3.78C18 2.8 17.2 2 16.22 2zM14 9H6v2h8V9z"
                        />
                    </svg>
                </slot>
                <slot name="collapsed-icon" part="collapsed-icon">
                    <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <path
                            fill-rule="evenodd"
                            clip-rule="evenodd"
                            d="M16.22 3H3.78a.78.78 0 00-.78.78v12.44c0 .43.35.78.78.78h12.44c.43 0 .78-.35.78-.78V3.78a.78.78 0 00-.78-.78zM3.78 2h12.44C17.2 2 18 2.8 18 3.78v12.44c0 .98-.8 1.78-1.78 1.78H3.78C2.8 18 2 17.2 2 16.22V3.78C2 2.8 2.8 2 3.78 2zM11 9h3v2h-3v3H9v-3H6V9h3V6h2v3z"
                        />
                    </svg>
                </slot>
            <span>
        </div>
        <div
            class="region"
            part="region"
            id="${(x2) => x2.id}-panel"
            role="region"
            aria-labelledby="${(x2) => x2.id}"
        >
            <slot></slot>
        </div>
    </template>
`;
function applyMixins(derivedCtor, ...baseCtors) {
  baseCtors.forEach((baseCtor) => {
    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
    });
    if (baseCtor.attributes) {
      const existing = derivedCtor.attributes || [];
      derivedCtor.attributes = existing.concat(baseCtor.attributes);
    }
  });
}
class AccordionItem extends FASTElement {
  constructor() {
    super(...arguments);
    this.headinglevel = 2;
    this.expanded = false;
    this.clickHandler = (e) => {
      this.expanded = !this.expanded;
      this.change();
    };
    this.change = () => {
      this.$emit("change");
    };
  }
}
__decorate$1([
  attr$1({
    attribute: "heading-level",
    mode: "fromView",
    converter: nullableNumberConverter
  })
], AccordionItem.prototype, "headinglevel", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], AccordionItem.prototype, "expanded", void 0);
__decorate$1([
  attr$1
], AccordionItem.prototype, "id", void 0);
applyMixins(AccordionItem, StartEnd);
const AccordionTemplate = html$1$1`
    <template>
        <slot name="item" part="item" ${slotted("accordionItems")}></slot>
    </template>
`;
var Orientation;
(function(Orientation2) {
  Orientation2["horizontal"] = "horizontal";
  Orientation2["vertical"] = "vertical";
})(Orientation || (Orientation = {}));
var freeGlobal$5 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1$1 = freeGlobal$5;
var freeSelf$3 = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal$1$1 || freeSelf$3 || Function("return this")();
var root$1$1 = root$8;
var Symbol$1$1 = root$1$1.Symbol;
var Symbol$2$1 = Symbol$1$1;
var objectProto$4$1 = Object.prototype;
var hasOwnProperty$3$1 = objectProto$4$1.hasOwnProperty;
var nativeObjectToString$1$1 = objectProto$4$1.toString;
var symToStringTag$1$1 = Symbol$2$1 ? Symbol$2$1.toStringTag : void 0;
function getRawTag$3(value2) {
  var isOwn = hasOwnProperty$3$1.call(value2, symToStringTag$1$1), tag = value2[symToStringTag$1$1];
  try {
    value2[symToStringTag$1$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$1$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1$1] = tag;
    } else {
      delete value2[symToStringTag$1$1];
    }
  }
  return result2;
}
var objectProto$3$1 = Object.prototype;
var nativeObjectToString$4 = objectProto$3$1.toString;
function objectToString$4(value2) {
  return nativeObjectToString$4.call(value2);
}
var nullTag$2 = "[object Null]", undefinedTag$2 = "[object Undefined]";
var symToStringTag$4 = Symbol$2$1 ? Symbol$2$1.toStringTag : void 0;
function baseGetTag$6(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag$2 : nullTag$2;
  }
  return symToStringTag$4 && symToStringTag$4 in Object(value2) ? getRawTag$3(value2) : objectToString$4(value2);
}
function isObjectLike$9(value2) {
  return value2 != null && typeof value2 == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol$1(value2) {
  return typeof value2 == "symbol" || isObjectLike$9(value2) && baseGetTag$6(value2) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index2 < length) {
    result2[index2] = iteratee(array[index2], index2, array);
  }
  return result2;
}
var isArray$5 = Array.isArray;
var isArray$1$1 = isArray$5;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2$1 ? Symbol$2$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$1$1(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol$1(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result2 = value2 + "";
  return result2 == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result2;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$f(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var NAN$1 = 0 / 0;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
function toNumber$1(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol$1(value2)) {
    return NAN$1;
  }
  if (isObject$f(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$f(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary2 = reIsBinary$1.test(value2);
  return isBinary2 || reIsOctal$1.test(value2) ? freeParseInt$1(value2.slice(2), isBinary2 ? 2 : 8) : reIsBadHex$1.test(value2) ? NAN$1 : +value2;
}
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber$1(value2);
  if (value2 === INFINITY || value2 === -INFINITY) {
    var sign = value2 < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
var asyncTag$2 = "[object AsyncFunction]", funcTag$4 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$2 = "[object Proxy]";
function isFunction$5(value2) {
  if (!isObject$f(value2)) {
    return false;
  }
  var tag = baseGetTag$6(value2);
  return tag == funcTag$4 || tag == genTag$2 || tag == asyncTag$2 || tag == proxyTag$2;
}
var coreJsData$4 = root$1$1["__core-js_shared__"];
var coreJsData$1$1 = coreJsData$4;
var maskSrcKey$2 = function() {
  var uid = /[^.]+$/.exec(coreJsData$1$1 && coreJsData$1$1.keys && coreJsData$1$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$3(func) {
  return !!maskSrcKey$2 && maskSrcKey$2 in func;
}
var funcProto$1$1 = Function.prototype;
var funcToString$1$1 = funcProto$1$1.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$1$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;
var funcProto$6 = Function.prototype, objectProto$2$1 = Object.prototype;
var funcToString$6 = funcProto$6.toString;
var hasOwnProperty$2$1 = objectProto$2$1.hasOwnProperty;
var reIsNative$2 = RegExp("^" + funcToString$6.call(hasOwnProperty$2$1).replace(reRegExpChar$2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$3(value2) {
  if (!isObject$f(value2) || isMasked$3(value2)) {
    return false;
  }
  var pattern = isFunction$5(value2) ? reIsNative$2 : reIsHostCtor$2;
  return pattern.test(toSource$3(value2));
}
function getValue$3(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative$5(object, key) {
  var value2 = getValue$3(object, key);
  return baseIsNative$3(value2) ? value2 : void 0;
}
function eq$6(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var nativeCreate$7 = getNative$5(Object, "create");
var nativeCreate$1$1 = nativeCreate$7;
function hashClear$3() {
  this.__data__ = nativeCreate$1$1 ? nativeCreate$1$1(null) : {};
  this.size = 0;
}
function hashDelete$3(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var HASH_UNDEFINED$1$1 = "__lodash_hash_undefined__";
var objectProto$1$1 = Object.prototype;
var hasOwnProperty$1$1 = objectProto$1$1.hasOwnProperty;
function hashGet$3(key) {
  var data = this.__data__;
  if (nativeCreate$1$1) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED$1$1 ? void 0 : result2;
  }
  return hasOwnProperty$1$1.call(data, key) ? data[key] : void 0;
}
var objectProto$n = Object.prototype;
var hasOwnProperty$k = objectProto$n.hasOwnProperty;
function hashHas$3(key) {
  var data = this.__data__;
  return nativeCreate$1$1 ? data[key] !== void 0 : hasOwnProperty$k.call(data, key);
}
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$3(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1$1 && value2 === void 0 ? HASH_UNDEFINED$4 : value2;
  return this;
}
function Hash$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$3.prototype.clear = hashClear$3;
Hash$3.prototype["delete"] = hashDelete$3;
Hash$3.prototype.get = hashGet$3;
Hash$3.prototype.has = hashHas$3;
Hash$3.prototype.set = hashSet$3;
function listCacheClear$3() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf$6(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$6(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto$2 = Array.prototype;
var splice$2 = arrayProto$2.splice;
function listCacheDelete$3(key) {
  var data = this.__data__, index2 = assocIndexOf$6(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet$3(key) {
  var data = this.__data__, index2 = assocIndexOf$6(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$3(key) {
  return assocIndexOf$6(this.__data__, key) > -1;
}
function listCacheSet$3(key, value2) {
  var data = this.__data__, index2 = assocIndexOf$6(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
function ListCache$6(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$6.prototype.clear = listCacheClear$3;
ListCache$6.prototype["delete"] = listCacheDelete$3;
ListCache$6.prototype.get = listCacheGet$3;
ListCache$6.prototype.has = listCacheHas$3;
ListCache$6.prototype.set = listCacheSet$3;
var Map$1$1 = getNative$5(root$1$1, "Map");
var Map$2$1 = Map$1$1;
function mapCacheClear$3() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$3(),
    "map": new (Map$2$1 || ListCache$6)(),
    "string": new Hash$3()
  };
}
function isKeyable$3(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData$6(map2, key) {
  var data = map2.__data__;
  return isKeyable$3(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete$3(key) {
  var result2 = getMapData$6(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
function mapCacheGet$3(key) {
  return getMapData$6(this, key).get(key);
}
function mapCacheHas$3(key) {
  return getMapData$6(this, key).has(key);
}
function mapCacheSet$3(key, value2) {
  var data = getMapData$6(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear$3;
MapCache$3.prototype["delete"] = mapCacheDelete$3;
MapCache$3.prototype.get = mapCacheGet$3;
MapCache$3.prototype.has = mapCacheHas$3;
MapCache$3.prototype.set = mapCacheSet$3;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result2 = func.apply(this, args2);
    memoized.cache = cache2.set(key, result2) || cache2;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache$3)();
  return memoized;
}
memoize.Cache = MapCache$3;
function toString$4(value2) {
  return value2 == null ? "" : baseToString(value2);
}
var nativeMax$3 = Math.max, nativeMin$1 = Math.min;
function baseInRange(number2, start, end) {
  return number2 >= nativeMin$1(start, end) && number2 < nativeMax$3(start, end);
}
function inRange(number2, start, end) {
  start = toFinite(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite(end);
  }
  number2 = toNumber$1(number2);
  return baseInRange(number2, start, end);
}
var boolTag$2 = "[object Boolean]";
function isBoolean$1(value2) {
  return value2 === true || value2 === false || isObjectLike$9(value2) && baseGetTag$6(value2) == boolTag$2;
}
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString$4(prefix) + id;
}
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function isHTMLElement(...args2) {
  return args2.every((arg) => arg instanceof HTMLElement);
}
function getDisplayedNodes(rootNode, selector) {
  if (!isHTMLElement(rootNode)) {
    return;
  }
  const nodes = Array.from(rootNode.querySelectorAll(selector));
  return nodes.filter((node) => node.offsetParent !== null);
}
function getNonce() {
  const node = document.querySelector('meta[property="csp-nonce"]');
  if (node) {
    return node.getAttribute("content");
  } else {
    return null;
  }
}
let _canUseFocusVisible;
function canUseFocusVisible() {
  if (isBoolean$1(_canUseFocusVisible)) {
    return _canUseFocusVisible;
  }
  if (!canUseDOM()) {
    _canUseFocusVisible = false;
    return _canUseFocusVisible;
  }
  const styleElement = document.createElement("style");
  const styleNonce = getNonce();
  if (styleNonce !== null) {
    styleElement.setAttribute("nonce", styleNonce);
  }
  document.head.appendChild(styleElement);
  try {
    styleElement.sheet.insertRule("foo:focus-visible {color:inherit}", 0);
    _canUseFocusVisible = true;
  } catch (e) {
    _canUseFocusVisible = false;
  } finally {
    document.head.removeChild(styleElement);
  }
  return _canUseFocusVisible;
}
var KeyCodes;
(function(KeyCodes2) {
  KeyCodes2[KeyCodes2["alt"] = 18] = "alt";
  KeyCodes2[KeyCodes2["arrowDown"] = 40] = "arrowDown";
  KeyCodes2[KeyCodes2["arrowLeft"] = 37] = "arrowLeft";
  KeyCodes2[KeyCodes2["arrowRight"] = 39] = "arrowRight";
  KeyCodes2[KeyCodes2["arrowUp"] = 38] = "arrowUp";
  KeyCodes2[KeyCodes2["back"] = 8] = "back";
  KeyCodes2[KeyCodes2["backSlash"] = 220] = "backSlash";
  KeyCodes2[KeyCodes2["break"] = 19] = "break";
  KeyCodes2[KeyCodes2["capsLock"] = 20] = "capsLock";
  KeyCodes2[KeyCodes2["closeBracket"] = 221] = "closeBracket";
  KeyCodes2[KeyCodes2["colon"] = 186] = "colon";
  KeyCodes2[KeyCodes2["colon2"] = 59] = "colon2";
  KeyCodes2[KeyCodes2["comma"] = 188] = "comma";
  KeyCodes2[KeyCodes2["ctrl"] = 17] = "ctrl";
  KeyCodes2[KeyCodes2["delete"] = 46] = "delete";
  KeyCodes2[KeyCodes2["end"] = 35] = "end";
  KeyCodes2[KeyCodes2["enter"] = 13] = "enter";
  KeyCodes2[KeyCodes2["equals"] = 187] = "equals";
  KeyCodes2[KeyCodes2["equals2"] = 61] = "equals2";
  KeyCodes2[KeyCodes2["equals3"] = 107] = "equals3";
  KeyCodes2[KeyCodes2["escape"] = 27] = "escape";
  KeyCodes2[KeyCodes2["forwardSlash"] = 191] = "forwardSlash";
  KeyCodes2[KeyCodes2["function1"] = 112] = "function1";
  KeyCodes2[KeyCodes2["function10"] = 121] = "function10";
  KeyCodes2[KeyCodes2["function11"] = 122] = "function11";
  KeyCodes2[KeyCodes2["function12"] = 123] = "function12";
  KeyCodes2[KeyCodes2["function2"] = 113] = "function2";
  KeyCodes2[KeyCodes2["function3"] = 114] = "function3";
  KeyCodes2[KeyCodes2["function4"] = 115] = "function4";
  KeyCodes2[KeyCodes2["function5"] = 116] = "function5";
  KeyCodes2[KeyCodes2["function6"] = 117] = "function6";
  KeyCodes2[KeyCodes2["function7"] = 118] = "function7";
  KeyCodes2[KeyCodes2["function8"] = 119] = "function8";
  KeyCodes2[KeyCodes2["function9"] = 120] = "function9";
  KeyCodes2[KeyCodes2["home"] = 36] = "home";
  KeyCodes2[KeyCodes2["insert"] = 45] = "insert";
  KeyCodes2[KeyCodes2["menu"] = 93] = "menu";
  KeyCodes2[KeyCodes2["minus"] = 189] = "minus";
  KeyCodes2[KeyCodes2["minus2"] = 109] = "minus2";
  KeyCodes2[KeyCodes2["numLock"] = 144] = "numLock";
  KeyCodes2[KeyCodes2["numPad0"] = 96] = "numPad0";
  KeyCodes2[KeyCodes2["numPad1"] = 97] = "numPad1";
  KeyCodes2[KeyCodes2["numPad2"] = 98] = "numPad2";
  KeyCodes2[KeyCodes2["numPad3"] = 99] = "numPad3";
  KeyCodes2[KeyCodes2["numPad4"] = 100] = "numPad4";
  KeyCodes2[KeyCodes2["numPad5"] = 101] = "numPad5";
  KeyCodes2[KeyCodes2["numPad6"] = 102] = "numPad6";
  KeyCodes2[KeyCodes2["numPad7"] = 103] = "numPad7";
  KeyCodes2[KeyCodes2["numPad8"] = 104] = "numPad8";
  KeyCodes2[KeyCodes2["numPad9"] = 105] = "numPad9";
  KeyCodes2[KeyCodes2["numPadDivide"] = 111] = "numPadDivide";
  KeyCodes2[KeyCodes2["numPadDot"] = 110] = "numPadDot";
  KeyCodes2[KeyCodes2["numPadMinus"] = 109] = "numPadMinus";
  KeyCodes2[KeyCodes2["numPadMultiply"] = 106] = "numPadMultiply";
  KeyCodes2[KeyCodes2["numPadPlus"] = 107] = "numPadPlus";
  KeyCodes2[KeyCodes2["openBracket"] = 219] = "openBracket";
  KeyCodes2[KeyCodes2["pageDown"] = 34] = "pageDown";
  KeyCodes2[KeyCodes2["pageUp"] = 33] = "pageUp";
  KeyCodes2[KeyCodes2["period"] = 190] = "period";
  KeyCodes2[KeyCodes2["print"] = 44] = "print";
  KeyCodes2[KeyCodes2["quote"] = 222] = "quote";
  KeyCodes2[KeyCodes2["scrollLock"] = 145] = "scrollLock";
  KeyCodes2[KeyCodes2["shift"] = 16] = "shift";
  KeyCodes2[KeyCodes2["space"] = 32] = "space";
  KeyCodes2[KeyCodes2["tab"] = 9] = "tab";
  KeyCodes2[KeyCodes2["tilde"] = 192] = "tilde";
  KeyCodes2[KeyCodes2["windowsLeft"] = 91] = "windowsLeft";
  KeyCodes2[KeyCodes2["windowsOpera"] = 219] = "windowsOpera";
  KeyCodes2[KeyCodes2["windowsRight"] = 92] = "windowsRight";
})(KeyCodes || (KeyCodes = {}));
const keyCodeArrowDown = 40;
const keyCodeArrowLeft = 37;
const keyCodeArrowRight = 39;
const keyCodeArrowUp = 38;
const keyCodeEnd = 35;
const keyCodeEnter = 13;
const keyCodeHome = 36;
const keyCodeSpace = 32;
const keyArrowDown = "ArrowDown";
const keyArrowLeft = "ArrowLeft";
const keyArrowRight = "ArrowRight";
const keyArrowUp = "ArrowUp";
const keyEnter = "Enter";
const ArrowKeys = {
  ArrowDown: keyArrowDown,
  ArrowLeft: keyArrowLeft,
  ArrowRight: keyArrowRight,
  ArrowUp: keyArrowUp
};
var Direction;
(function(Direction2) {
  Direction2["ltr"] = "ltr";
  Direction2["rtl"] = "rtl";
})(Direction || (Direction = {}));
function wrapInBounds(min, max, value2) {
  if (value2 < min) {
    return max;
  } else if (value2 > max) {
    return min;
  }
  return value2;
}
var SystemColors;
(function(SystemColors2) {
  SystemColors2["Canvas"] = "Canvas";
  SystemColors2["CanvasText"] = "CanvasText";
  SystemColors2["LinkText"] = "LinkText";
  SystemColors2["VisitedText"] = "VisitedText";
  SystemColors2["ActiveText"] = "ActiveText";
  SystemColors2["ButtonFace"] = "ButtonFace";
  SystemColors2["ButtonText"] = "ButtonText";
  SystemColors2["Field"] = "Field";
  SystemColors2["FieldText"] = "FieldText";
  SystemColors2["Highlight"] = "Highlight";
  SystemColors2["HighlightText"] = "HighlightText";
  SystemColors2["GrayText"] = "GrayText";
})(SystemColors || (SystemColors = {}));
var AccordionExpandMode;
(function(AccordionExpandMode2) {
  AccordionExpandMode2["single"] = "single";
  AccordionExpandMode2["multi"] = "multi";
})(AccordionExpandMode || (AccordionExpandMode = {}));
class Accordion extends FASTElement {
  constructor() {
    super(...arguments);
    this.expandmode = AccordionExpandMode.multi;
    this.activeItemIndex = 0;
    this.change = () => {
      this.$emit("change");
    };
    this.setItems = () => {
      this.accordionIds = this.getItemIds();
      this.accordionItems.forEach((item, index2) => {
        if (item instanceof AccordionItem) {
          item.addEventListener("change", this.activeItemChange);
          if (this.isSingleExpandMode()) {
            this.activeItemIndex !== index2 ? item.expanded = false : item.expanded = true;
          }
        }
        const itemId = this.accordionIds[index2];
        item.setAttribute("id", typeof itemId !== "string" ? `accordion-${index2 + 1}` : itemId);
        this.activeid = this.accordionIds[this.activeItemIndex];
        item.addEventListener("keydown", this.handleItemKeyDown);
        item.addEventListener("focus", this.handleItemFocus);
      });
    };
    this.removeItemListeners = (oldValue) => {
      oldValue.forEach((item, index2) => {
        item.removeEventListener("change", this.activeItemChange);
        item.removeEventListener("keydown", this.handleItemKeyDown);
        item.removeEventListener("focus", this.handleItemFocus);
      });
    };
    this.activeItemChange = (event2) => {
      const selectedItem = event2.target;
      if (this.isSingleExpandMode()) {
        this.resetItems();
        event2.target.expanded = true;
      }
      this.activeid = event2.target.getAttribute("id");
      this.activeItemIndex = Array.from(this.accordionItems).indexOf(selectedItem);
      this.change();
    };
    this.handleItemKeyDown = (event2) => {
      if (event2.target !== event2.currentTarget) {
        return;
      }
      const keyCode = event2.keyCode;
      this.accordionIds = this.getItemIds();
      switch (keyCode) {
        case keyCodeArrowUp:
          event2.preventDefault();
          this.adjust(-1);
          break;
        case keyCodeArrowDown:
          event2.preventDefault();
          this.adjust(1);
          break;
        case keyCodeHome:
          this.activeItemIndex = 0;
          this.focusItem();
          break;
        case keyCodeEnd:
          this.activeItemIndex = this.accordionItems.length - 1;
          this.focusItem();
          break;
      }
    };
    this.handleItemFocus = (event2) => {
      if (event2.target === event2.currentTarget) {
        const focusedItem = event2.target;
        const focusedIndex = this.activeItemIndex = Array.from(this.accordionItems).indexOf(focusedItem);
        if (this.activeItemIndex !== focusedIndex && focusedIndex !== -1) {
          this.activeItemIndex = focusedIndex;
          this.activeid = this.accordionIds[this.activeItemIndex];
        }
      }
    };
  }
  accordionItemsChanged(oldValue, newValue) {
    if (this.$fastController.isConnected) {
      this.removeItemListeners(oldValue);
      this.accordionIds = this.getItemIds();
      this.setItems();
    }
  }
  resetItems() {
    this.accordionItems.forEach((item, index2) => {
      item.expanded = false;
    });
  }
  getItemIds() {
    return this.accordionItems.map((accordionItem) => {
      return accordionItem.getAttribute("id");
    });
  }
  isSingleExpandMode() {
    return this.expandmode === AccordionExpandMode.single;
  }
  adjust(adjustment) {
    this.activeItemIndex = wrapInBounds(0, this.accordionItems.length - 1, this.activeItemIndex + adjustment);
    this.focusItem();
  }
  focusItem() {
    const element2 = this.accordionItems[this.activeItemIndex];
    if (element2 instanceof AccordionItem) {
      element2.expandbutton.focus();
    }
  }
}
__decorate$1([
  attr$1({ attribute: "expand-mode" })
], Accordion.prototype, "expandmode", void 0);
__decorate$1([
  observable
], Accordion.prototype, "accordionItems", void 0);
const AnchorTemplate = html$1$1`
    <a
        class="control"
        part="control"
        download="${(x2) => x2.download}"
        href="${(x2) => x2.href}"
        hreflang="${(x2) => x2.hreflang}"
        ping="${(x2) => x2.ping}"
        referrerpolicy="${(x2) => x2.referrerpolicy}"
        rel="${(x2) => x2.rel}"
        target="${(x2) => x2.target}"
        type="${(x2) => x2.type}"
        aria-atomic="${(x2) => x2.ariaAtomic}"
        aria-busy="${(x2) => x2.ariaBusy}"
        aria-controls="${(x2) => x2.ariaControls}"
        aria-current="${(x2) => x2.ariaCurrent}"
        aria-describedBy="${(x2) => x2.ariaDescribedby}"
        aria-details="${(x2) => x2.ariaDetails}"
        aria-disabled="${(x2) => x2.ariaDisabled}"
        aria-errormessage="${(x2) => x2.ariaErrormessage}"
        aria-expanded="${(x2) => x2.ariaExpanded}"
        aria-flowto="${(x2) => x2.ariaFlowto}"
        aria-haspopup="${(x2) => x2.ariaHaspopup}"
        aria-hidden="${(x2) => x2.ariaHidden}"
        aria-invalid="${(x2) => x2.ariaInvalid}"
        aria-keyshortcuts="${(x2) => x2.ariaKeyshortcuts}"
        aria-label="${(x2) => x2.ariaLabel}"
        aria-labelledby="${(x2) => x2.ariaLabelledby}"
        aria-live="${(x2) => x2.ariaLive}"
        aria-owns="${(x2) => x2.ariaOwns}"
        aria-relevant="${(x2) => x2.ariaRelevant}"
        aria-roledescription="${(x2) => x2.ariaRoledescription}"
        ${ref("control")}
    >
        ${startTemplate}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endTemplate}
    </a>
`;
class ARIAGlobalStatesAndProperties {
}
__decorate$1([
  attr$1({ attribute: "aria-atomic", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaAtomic", void 0);
__decorate$1([
  attr$1({ attribute: "aria-busy", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaBusy", void 0);
__decorate$1([
  attr$1({ attribute: "aria-controls", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaControls", void 0);
__decorate$1([
  attr$1({ attribute: "aria-current", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaCurrent", void 0);
__decorate$1([
  attr$1({ attribute: "aria-describedby", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDescribedby", void 0);
__decorate$1([
  attr$1({ attribute: "aria-details", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDetails", void 0);
__decorate$1([
  attr$1({ attribute: "aria-disabled", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaDisabled", void 0);
__decorate$1([
  attr$1({ attribute: "aria-errormessage", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaErrormessage", void 0);
__decorate$1([
  attr$1({ attribute: "aria-flowto", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaFlowto", void 0);
__decorate$1([
  attr$1({ attribute: "aria-haspopup", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaHaspopup", void 0);
__decorate$1([
  attr$1({ attribute: "aria-hidden", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaHidden", void 0);
__decorate$1([
  attr$1({ attribute: "aria-invalid", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaInvalid", void 0);
__decorate$1([
  attr$1({ attribute: "aria-keyshortcuts", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaKeyshortcuts", void 0);
__decorate$1([
  attr$1({ attribute: "aria-label", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLabel", void 0);
__decorate$1([
  attr$1({ attribute: "aria-labelledby", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLabelledby", void 0);
__decorate$1([
  attr$1({ attribute: "aria-live", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaLive", void 0);
__decorate$1([
  attr$1({ attribute: "aria-owns", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaOwns", void 0);
__decorate$1([
  attr$1({ attribute: "aria-relevant", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaRelevant", void 0);
__decorate$1([
  attr$1({ attribute: "aria-roledescription", mode: "fromView" })
], ARIAGlobalStatesAndProperties.prototype, "ariaRoledescription", void 0);
class Anchor extends FASTElement {
}
__decorate$1([
  attr$1
], Anchor.prototype, "download", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "href", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "hreflang", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "ping", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "referrerpolicy", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "rel", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "target", void 0);
__decorate$1([
  attr$1
], Anchor.prototype, "type", void 0);
__decorate$1([
  observable
], Anchor.prototype, "defaultSlottedContent", void 0);
class DelegatesARIALink {
}
__decorate$1([
  attr$1({ attribute: "aria-expanded", mode: "fromView" })
], DelegatesARIALink.prototype, "ariaExpanded", void 0);
applyMixins(DelegatesARIALink, ARIAGlobalStatesAndProperties);
applyMixins(Anchor, StartEnd, DelegatesARIALink);
function composedParent(element2) {
  const parentNode = element2.parentElement;
  if (parentNode) {
    return parentNode;
  } else {
    const rootNode = element2.getRootNode();
    if (rootNode.host instanceof HTMLElement) {
      return rootNode.host;
    }
  }
  return null;
}
class MatchMediaBehavior {
  constructor(query2) {
    this.listenerCache = /* @__PURE__ */ new WeakMap();
    this.query = query2;
  }
  bind(source) {
    const { query: query2 } = this;
    const listener = this.constructListener(source);
    listener.bind(query2)();
    query2.addListener(listener);
    this.listenerCache.set(source, listener);
  }
  unbind(source) {
    const listener = this.listenerCache.get(source);
    if (listener) {
      this.query.removeListener(listener);
      this.listenerCache.delete(source);
    }
  }
}
class MatchMediaStyleSheetBehavior extends MatchMediaBehavior {
  constructor(query2, styles2) {
    super(query2);
    this.styles = styles2;
  }
  static with(query2) {
    return (styles2) => {
      return new MatchMediaStyleSheetBehavior(query2, styles2);
    };
  }
  constructListener(source) {
    let attached = false;
    const styles2 = this.styles;
    return function listener() {
      const { matches: matches2 } = this;
      if (matches2 && !attached) {
        source.$fastController.addStyles(styles2);
        attached = matches2;
      } else if (!matches2 && attached) {
        source.$fastController.removeStyles(styles2);
        attached = matches2;
      }
    };
  }
  unbind(source) {
    super.unbind(source);
    source.$fastController.removeStyles(this.styles);
  }
}
const forcedColorsStylesheetBehavior = MatchMediaStyleSheetBehavior.with(window.matchMedia("(forced-colors)"));
MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: dark)"));
MatchMediaStyleSheetBehavior.with(window.matchMedia("(prefers-color-scheme: light)"));
class PropertyStyleSheetBehavior {
  constructor(propertyName, value2, styles2) {
    this.propertyName = propertyName;
    this.value = value2;
    this.styles = styles2;
  }
  bind(elementInstance) {
    Observable.getNotifier(elementInstance).subscribe(this, this.propertyName);
    this.handleChange(elementInstance, this.propertyName);
  }
  unbind(source) {
    Observable.getNotifier(source).unsubscribe(this, this.propertyName);
    source.$fastController.removeStyles(this.styles);
  }
  handleChange(source, key) {
    if (source[key] === this.value) {
      source.$fastController.addStyles(this.styles);
    } else {
      source.$fastController.removeStyles(this.styles);
    }
  }
}
const disabledCursor = "not-allowed";
const hidden = `:host([hidden]){display:none}`;
function display(displayValue) {
  return `${hidden}:host{display:${displayValue}}`;
}
const focusVisible = canUseFocusVisible() ? "focus-visible" : "focus";
const hostSelector = ":host{}";
class CustomPropertyManagerBase {
  constructor() {
    this.queue = /* @__PURE__ */ new Set();
    this.customPropertyTarget = null;
    this._owner = null;
    this.ticking = false;
    this.cssCustomPropertyDefinitions = /* @__PURE__ */ new Map();
  }
  get owner() {
    return this._owner;
  }
  register(def) {
    const cached = this.cssCustomPropertyDefinitions.get(def.name);
    if (cached) {
      cached.count += 1;
    } else {
      this.cssCustomPropertyDefinitions.set(def.name, Object.assign(Object.assign({}, def), { count: 1 }));
      this.set(def);
    }
  }
  unregister(name) {
    const cached = this.cssCustomPropertyDefinitions.get(name);
    if (cached) {
      cached.count -= 1;
      if (cached.count === 0) {
        this.cssCustomPropertyDefinitions.delete(name);
        this.remove(name);
      }
    }
  }
  set(definition) {
    if (this.owner) {
      this.customPropertyTarget ? this.customPropertyTarget.setProperty(`--${definition.name}`, this.owner.evaluate(definition)) : this.queue.add(this.set.bind(this, definition));
    }
  }
  remove(name) {
    this.customPropertyTarget ? this.customPropertyTarget.removeProperty(`--${name}`) : this.queue.add(this.remove.bind(this, name));
  }
  setAll() {
    if (this.ticking) {
      return;
    }
    this.ticking = true;
    DOM.queueUpdate(() => {
      this.ticking = false;
      this.cssCustomPropertyDefinitions.forEach((def) => {
        this.set(def);
      });
    });
  }
}
class ConstructableStylesCustomPropertyManager extends CustomPropertyManagerBase {
  constructor(sheet) {
    super();
    this.subscribers = /* @__PURE__ */ new Set();
    this.sheet = sheet;
    this.styles = ElementStyles.create([sheet]);
    this.customPropertyTarget = sheet.cssRules[sheet.insertRule(hostSelector)].style;
  }
  subscribe(client) {
    this.subscribers.add(client);
    if (this.subscribers.size === 1) {
      this._owner = client;
    }
    client.cssCustomPropertyDefinitions.forEach((def) => {
      this.register(def);
    });
    client.$fastController.addStyles(this.styles);
  }
  unsubscribe(client) {
    this.subscribers.delete(client);
    client.cssCustomPropertyDefinitions.forEach((def) => this.unregister(def.name));
    if (this.owner === client) {
      this._owner = this.subscribers.size ? this.subscribers.values().next().value : null;
    }
    if (!this.sheet.ownerNode && this.styles) {
      client.$fastController.removeStyles(this.styles);
    }
  }
  isSubscribed(client) {
    return this.subscribers.has(client);
  }
}
class StyleElementCustomPropertyManager extends CustomPropertyManagerBase {
  constructor(style, client) {
    super();
    this._sheet = null;
    this.handleConnection = {
      handleChange: () => {
        var _a2;
        this._sheet = this.styles.sheet;
        const key = this.sheet.insertRule(hostSelector);
        this.customPropertyTarget = this.sheet.rules[key].style;
        Observable.getNotifier((_a2 = this._owner) === null || _a2 === void 0 ? void 0 : _a2.$fastController).unsubscribe(this.handleConnection, "isConnected");
      }
    };
    const controller = client.$fastController;
    controller.addStyles(style);
    this.styles = style;
    this._owner = client;
    client.isConnected ? this.handleConnection.handleChange() : Observable.getNotifier(controller).subscribe(this.handleConnection, "isConnected");
    client.cssCustomPropertyDefinitions.forEach((def) => {
      this.register(def);
    });
  }
  get sheet() {
    return this._sheet;
  }
  customPropertyTargetChanged(prev, next2) {
    if (!prev && this.queue.size) {
      this.queue.forEach((fn2) => fn2());
      this.queue.clear();
    }
  }
}
__decorate$1([
  observable
], StyleElementCustomPropertyManager.prototype, "customPropertyTarget", void 0);
function isDesignSystemConsumer(element2) {
  const provider = element2.provider;
  return provider !== null && provider !== void 0 && DesignSystemProvider.isDesignSystemProvider(provider);
}
const designSystemConsumerBehavior = {
  bind(source) {
    source.provider = DesignSystemProvider.findProvider(source);
  },
  unbind(source) {
  }
};
class DesignSystemProvider extends FASTElement {
  constructor() {
    super();
    this.isDesignSystemProvider = true;
    this.designSystem = {};
    this.useDefaults = false;
    this.provider = null;
    this.cssCustomPropertyDefinitions = /* @__PURE__ */ new Map();
    this.attributeChangeHandler = {
      handleChange: (source, key) => {
        const value2 = this[key];
        const manager = this.customPropertyManager;
        if (this.isValidDesignSystemValue(value2)) {
          this.designSystem[key] = value2;
          const property2 = this.designSystemProperties[key];
          if (property2 && property2.cssCustomProperty && manager) {
            manager.set({
              name: property2.cssCustomProperty,
              value: value2
            });
          }
        } else {
          this.syncDesignSystemWithProvider();
          const property2 = this.designSystemProperties[key].cssCustomProperty;
          if (manager) {
            if (typeof property2 === "string") {
              manager.remove(property2);
            }
            manager.setAll();
          }
        }
      }
    };
    this.localDesignSystemChangeHandler = {
      handleChange: () => {
        const manager = this.customPropertyManager;
        if (manager && manager.owner === this) {
          manager.setAll();
        }
      }
    };
    this.providerDesignSystemChangeHandler = {
      handleChange: (source, key) => {
        if (source[key] !== this.designSystem[key] && !this.isValidDesignSystemValue(this[key])) {
          this.designSystem[key] = source[key];
        }
      }
    };
    if (!DOM.supportsAdoptedStyleSheets) {
      this.customPropertyManager = new StyleElementCustomPropertyManager(document.createElement("style"), this);
    } else {
      this.customPropertyManager = new ConstructableStylesCustomPropertyManager(new CSSStyleSheet());
    }
    if (this.designSystemProperties === void 0) {
      this.designSystemProperties = {};
    }
    this.$fastController.addBehaviors([designSystemConsumerBehavior]);
  }
  static get tagNames() {
    return DesignSystemProvider._tagNames;
  }
  static isDesignSystemProvider(el2) {
    return el2.isDesignSystemProvider || DesignSystemProvider.tagNames.indexOf(el2.tagName) !== -1;
  }
  static findProvider(el2) {
    if (isDesignSystemConsumer(el2)) {
      return el2.provider;
    }
    let parent = composedParent(el2);
    while (parent !== null) {
      if (DesignSystemProvider.isDesignSystemProvider(parent)) {
        el2.provider = parent;
        return parent;
      } else if (isDesignSystemConsumer(parent)) {
        el2.provider = parent.provider;
        return parent.provider;
      } else {
        parent = composedParent(parent);
      }
    }
    return null;
  }
  static registerTagName(tagName) {
    const tagNameUpper = tagName.toUpperCase();
    if (DesignSystemProvider.tagNames.indexOf(tagNameUpper) === -1) {
      DesignSystemProvider._tagNames.push(tagNameUpper);
    }
  }
  useDefaultsChanged() {
    if (this.useDefaults) {
      const props = this.designSystemProperties;
      Object.keys(props).forEach((key) => {
        if (this[key] === void 0) {
          this[key] = props[key].default;
        }
      });
    }
  }
  providerChanged(prev, next2) {
    if (prev instanceof HTMLElement) {
      const notifier = Observable.getNotifier(prev.designSystem);
      Observable.getAccessors(prev.designSystem).forEach((x2) => {
        notifier.unsubscribe(this.providerDesignSystemChangeHandler, x2.name);
      });
    }
    if (next2 instanceof HTMLElement && DesignSystemProvider.isDesignSystemProvider(next2)) {
      const notifier = Observable.getNotifier(next2.designSystem);
      const localAccessors = Observable.getAccessors(this.designSystem).reduce((prev2, next22) => {
        return Object.assign(Object.assign({}, prev2), { [next22.name]: next22 });
      }, {});
      const localNotifier = Observable.getNotifier(this.designSystem);
      Observable.getAccessors(next2.designSystem).forEach((x2) => {
        notifier.subscribe(this.providerDesignSystemChangeHandler, x2.name);
        if (!localAccessors[x2.name]) {
          observable(this.designSystem, x2.name);
          localNotifier.subscribe(this.localDesignSystemChangeHandler, x2.name);
        }
      });
      this.syncDesignSystemWithProvider();
    }
  }
  customPropertyManagerChanged(prev, next2) {
    if (prev && prev.unsubscribe) {
      prev.unsubscribe(this);
    }
    if (next2.subscribe) {
      next2.subscribe(this);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.customPropertyManager.subscribe && this.customPropertyManager.isSubscribed && !this.customPropertyManager.isSubscribed(this)) {
      this.customPropertyManager.subscribe(this);
    }
    const selfNotifier = Observable.getNotifier(this);
    const designSystemNotifier = Observable.getNotifier(this.designSystem);
    Object.keys(this.designSystemProperties).forEach((property2) => {
      observable(this.designSystem, property2);
      selfNotifier.subscribe(this.attributeChangeHandler, property2);
      designSystemNotifier.subscribe(this.localDesignSystemChangeHandler, property2);
      const value2 = this[property2];
      if (this.isValidDesignSystemValue(value2)) {
        this.designSystem[property2] = value2;
        const { cssCustomProperty } = this.designSystemProperties[property2];
        if (typeof cssCustomProperty === "string" && this.customPropertyManager && this.customPropertyManager.owner === this) {
          this.customPropertyManager.set({
            name: cssCustomProperty,
            value: this[property2]
          });
        }
      }
    });
    if (Array.isArray(this.disconnectedCSSCustomPropertyRegistry)) {
      for (let i2 = 0; i2 < this.disconnectedCSSCustomPropertyRegistry.length; i2++) {
        this.registerCSSCustomProperty(this.disconnectedCSSCustomPropertyRegistry[i2]);
      }
      delete this.disconnectedCSSCustomPropertyRegistry;
    }
    if (Array.isArray(this.disconnectedRegistry)) {
      for (let i2 = 0; i2 < this.disconnectedRegistry.length; i2++) {
        this.disconnectedRegistry[i2](this);
      }
      delete this.disconnectedRegistry;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.customPropertyManager.unsubscribe) {
      this.customPropertyManager.unsubscribe(this);
    }
  }
  registerCSSCustomProperty(def) {
    this.cssCustomPropertyDefinitions.set(def.name, def);
    this.customPropertyManager.register(def);
  }
  unregisterCSSCustomProperty(def) {
    this.cssCustomPropertyDefinitions.delete(def.name);
    this.customPropertyManager.unregister(def.name);
  }
  evaluate(definition) {
    return typeof definition.value === "function" ? definition.value(Object.assign({}, this.designSystem)) : definition.value;
  }
  syncDesignSystemWithProvider() {
    if (this.provider) {
      const localDSAccessors = Observable.getAccessors(this.designSystem).reduce((prev, next2) => {
        prev[next2.name] = next2;
        return prev;
      }, {});
      Observable.getAccessors(this.provider.designSystem).forEach((x2) => {
        var _a2;
        if ((!this.designSystemProperties.hasOwnProperty(x2.name) || !this.isValidDesignSystemValue(this[x2.name])) && this.isValidDesignSystemValue((_a2 = this.provider) === null || _a2 === void 0 ? void 0 : _a2.designSystem[x2.name])) {
          if (!localDSAccessors[x2.name]) {
            Observable.defineProperty(this.designSystem, x2.name);
          }
          this.designSystem[x2.name] = this.provider.designSystem[x2.name];
        }
      });
    }
  }
  isValidDesignSystemValue(value2) {
    return value2 !== void 0 && value2 !== null;
  }
}
DesignSystemProvider._tagNames = [];
__decorate$1([
  attr$1({ attribute: "use-defaults", mode: "boolean" })
], DesignSystemProvider.prototype, "useDefaults", void 0);
__decorate$1([
  observable
], DesignSystemProvider.prototype, "provider", void 0);
__decorate$1([
  observable
], DesignSystemProvider.prototype, "customPropertyManager", void 0);
function defineDesignSystemProvider(nameOrDef) {
  return (providerCtor) => {
    customElement$1(nameOrDef)(providerCtor);
    providerCtor.registerTagName(typeof nameOrDef === "string" ? nameOrDef : nameOrDef.name);
  };
}
const designSystemProvider = defineDesignSystemProvider;
function designSystemProperty(config2) {
  const decorator = (source, prop, config22) => {
    const { cssCustomProperty, attribute } = config22;
    if (!source.designSystemProperties) {
      source.designSystemProperties = {};
    }
    if (attribute === false) {
      observable(source, prop);
    } else {
      if (config22.mode === void 0) {
        config22 = Object.assign(Object.assign({}, config22), { mode: "fromView" });
      }
      attr$1(config22)(source, prop);
    }
    source.designSystemProperties[prop] = {
      cssCustomProperty: cssCustomProperty === false ? false : typeof cssCustomProperty === "string" ? cssCustomProperty : typeof attribute === "string" ? attribute : prop,
      default: config22.default
    };
  };
  return (source, prop) => {
    decorator(source, prop, config2);
  };
}
const DesignSystemProviderTemplate = html$1$1`
    <slot></slot>
`;
class DirectionalStyleSheetBehavior {
  constructor(ltr2, rtl2) {
    this.cache = /* @__PURE__ */ new WeakMap();
    this.ltr = ltr2;
    this.rtl = rtl2;
  }
  bind(source) {
    const provider = DesignSystemProvider.findProvider(source);
    if (provider !== null) {
      if (provider.$fastController && provider.$fastController.isConnected) {
        this.attach(source, provider);
      } else {
        if (!Array.isArray(provider.disconnectedRegistry)) {
          provider.disconnectedRegistry = [];
        }
        provider.disconnectedRegistry.push(this.attach.bind(this, source));
      }
    }
  }
  unbind(source) {
    const cache2 = this.cache.get(source);
    if (cache2) {
      Observable.getNotifier(cache2[0].designSystem).unsubscribe(cache2[1]);
    }
  }
  attach(source, provider) {
    const subscriber = new DirectionalStyleSheetBehaviorSubscription(this.ltr, this.rtl, source);
    Observable.getNotifier(provider.designSystem).subscribe(subscriber, "direction");
    subscriber.attach(provider.designSystem["direction"]);
    this.cache.set(source, [provider, subscriber]);
  }
}
class DirectionalStyleSheetBehaviorSubscription {
  constructor(ltr2, rtl2, source) {
    this.ltr = ltr2;
    this.rtl = rtl2;
    this.source = source;
    this.attached = null;
  }
  handleChange(source) {
    this.attach(source.direction);
  }
  attach(direction) {
    if (this.attached !== this[direction]) {
      if (this.attached !== null) {
        this.source.$fastController.removeStyles(this.attached);
      }
      this.attached = this[direction];
      if (this.attached !== null) {
        this.source.$fastController.addStyles(this.attached);
      }
    }
  }
}
const getDirection = (rootNode) => {
  const dirNode = rootNode.closest("[dir]");
  return dirNode !== null && dirNode.dir === "rtl" ? Direction.rtl : Direction.ltr;
};
function whitespaceFilter(value2, index2, array) {
  return value2.nodeType !== Node.TEXT_NODE ? true : typeof value2.nodeValue === "string" && !!value2.nodeValue.trim().length;
}
const ButtonTemplate = html$1$1`
    <button
        class="control"
        part="control"
        ?autofocus="${(x2) => x2.autofocus}"
        ?disabled="${(x2) => x2.disabled}"
        form="${(x2) => x2.formId}"
        formaction="${(x2) => x2.formaction}"
        formenctype="${(x2) => x2.formenctype}"
        formmethod="${(x2) => x2.formmethod}"
        formnovalidate="${(x2) => x2.formnovalidate}"
        formtarget="${(x2) => x2.formtarget}"
        name="${(x2) => x2.name}"
        type="${(x2) => x2.type}"
        value="${(x2) => x2.value}"
        aria-atomic="${(x2) => x2.ariaAtomic}"
        aria-busy="${(x2) => x2.ariaBusy}"
        aria-controls="${(x2) => x2.ariaControls}"
        aria-current="${(x2) => x2.ariaCurrent}"
        aria-describedBy="${(x2) => x2.ariaDescribedby}"
        aria-details="${(x2) => x2.ariaDetails}"
        aria-disabled="${(x2) => x2.ariaDisabled}"
        aria-errormessage="${(x2) => x2.ariaErrormessage}"
        aria-expanded="${(x2) => x2.ariaExpanded}"
        aria-flowto="${(x2) => x2.ariaFlowto}"
        aria-haspopup="${(x2) => x2.ariaHaspopup}"
        aria-hidden="${(x2) => x2.ariaHidden}"
        aria-invalid="${(x2) => x2.ariaInvalid}"
        aria-keyshortcuts="${(x2) => x2.ariaKeyshortcuts}"
        aria-label="${(x2) => x2.ariaLabel}"
        aria-labelledby="${(x2) => x2.ariaLabelledby}"
        aria-live="${(x2) => x2.ariaLive}"
        aria-owns="${(x2) => x2.ariaOwns}"
        aria-pressed="${(x2) => x2.ariaPressed}"
        aria-relevant="${(x2) => x2.ariaRelevant}"
        aria-roledescription="${(x2) => x2.ariaRoledescription}"
        ${ref("control")}
    >
        ${startTemplate}
        <span class="content" part="content">
            <slot ${slotted("defaultSlottedContent")}></slot>
        </span>
        ${endTemplate}
    </button>
`;
const proxySlotName = "form-associated-proxy";
const ElementInternalsKey = "ElementInternals";
const supportsElementInternals = ElementInternalsKey in window && "setFormValue" in window[ElementInternalsKey].prototype;
const InternalsMap = /* @__PURE__ */ new Map();
function FormAssociated(BaseCtor) {
  const C = class extends BaseCtor {
    constructor(...args2) {
      super(...args2);
      this.dirtyValue = false;
      this.disabled = false;
      this.proxyEventsToBlock = ["change", "click"];
      this.formDisabledCallback = (disabled) => {
        this.disabled = disabled;
      };
      this.formResetCallback = () => {
        this.value = this.initialValue;
        this.dirtyValue = false;
      };
      this.proxyInitialized = false;
      this.required = false;
      this.initialValue = this.initialValue || "";
    }
    static get formAssociated() {
      return supportsElementInternals;
    }
    get validity() {
      return this.elementInternals ? this.elementInternals.validity : this.proxy.validity;
    }
    get form() {
      return this.elementInternals ? this.elementInternals.form : this.proxy.form;
    }
    get validationMessage() {
      return this.elementInternals ? this.elementInternals.validationMessage : this.proxy.validationMessage;
    }
    get willValidate() {
      return this.elementInternals ? this.elementInternals.willValidate : this.proxy.willValidate;
    }
    get labels() {
      if (this.elementInternals) {
        return Object.freeze(Array.from(this.elementInternals.labels));
      } else if (this.proxy instanceof HTMLElement && this.proxy.ownerDocument && this.id) {
        const parentLabels = this.proxy.labels;
        const forLabels = Array.from(this.proxy.getRootNode().querySelectorAll(`[for='${this.id}']`));
        const labels = parentLabels ? forLabels.concat(Array.from(parentLabels)) : forLabels;
        return Object.freeze(labels);
      } else {
        return emptyArray;
      }
    }
    valueChanged(previous2, next2) {
      this.dirtyValue = true;
      if (this.proxy instanceof HTMLElement) {
        this.proxy.value = this.value;
      }
      this.setFormValue(this.value);
      this.validate();
    }
    initialValueChanged(previous2, next2) {
      if (!this.dirtyValue) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
    }
    disabledChanged(previous2, next2) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.disabled = this.disabled;
      }
      DOM.queueUpdate(() => this.classList.toggle("disabled", this.disabled));
    }
    nameChanged(previous2, next2) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.name = this.name;
      }
    }
    requiredChanged(prev, next2) {
      if (this.proxy instanceof HTMLElement) {
        this.proxy.required = this.required;
      }
      DOM.queueUpdate(() => this.classList.toggle("required", this.required));
      this.validate();
    }
    get elementInternals() {
      if (!supportsElementInternals) {
        return null;
      }
      let internals = InternalsMap.get(this);
      if (!internals) {
        internals = this.attachInternals();
        InternalsMap.set(this, internals);
      }
      return internals;
    }
    connectedCallback() {
      super.connectedCallback();
      this.addEventListener("keypress", this._keypressHandler);
      if (!this.value) {
        this.value = this.initialValue;
        this.dirtyValue = false;
      }
      if (!this.elementInternals) {
        this.attachProxy();
      }
      if (this.form) {
        this.form.addEventListener("reset", this.formResetCallback);
      }
    }
    disconnectedCallback() {
      this.proxyEventsToBlock.forEach((name) => this.proxy.removeEventListener(name, this.stopPropagation));
      if (this.form) {
        this.form.removeEventListener("reset", this.formResetCallback);
      }
    }
    checkValidity() {
      return this.elementInternals ? this.elementInternals.checkValidity() : this.proxy.checkValidity();
    }
    reportValidity() {
      return this.elementInternals ? this.elementInternals.reportValidity() : this.proxy.reportValidity();
    }
    setValidity(flags, message, anchor) {
      if (this.elementInternals) {
        this.elementInternals.setValidity(flags, message, anchor);
      } else if (typeof message === "string") {
        this.proxy.setCustomValidity(message);
      }
    }
    attachProxy() {
      var _a2;
      if (!this.proxyInitialized) {
        this.proxyInitialized = true;
        this.proxy.style.display = "none";
        this.proxyEventsToBlock.forEach((name) => this.proxy.addEventListener(name, this.stopPropagation));
        this.proxy.disabled = this.disabled;
        this.proxy.required = this.required;
        if (typeof this.name === "string") {
          this.proxy.name = this.name;
        }
        if (typeof this.value === "string") {
          this.proxy.value = this.value;
        }
        this.proxy.setAttribute("slot", proxySlotName);
        this.proxySlot = document.createElement("slot");
        this.proxySlot.setAttribute("name", proxySlotName);
      }
      (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.appendChild(this.proxySlot);
      this.appendChild(this.proxy);
    }
    detachProxy() {
      var _a2;
      this.removeChild(this.proxy);
      (_a2 = this.shadowRoot) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.proxySlot);
    }
    validate() {
      if (this.proxy instanceof HTMLElement) {
        this.setValidity(this.proxy.validity, this.proxy.validationMessage);
      }
    }
    setFormValue(value2, state2) {
      if (this.elementInternals) {
        this.elementInternals.setFormValue(value2, state2 || value2);
      }
    }
    _keypressHandler(e) {
      switch (e.keyCode) {
        case keyCodeEnter:
          if (this.form instanceof HTMLFormElement) {
            const defaultButton = this.form.querySelector("[type=submit]");
            defaultButton === null || defaultButton === void 0 ? void 0 : defaultButton.click();
          }
          break;
      }
    }
    stopPropagation(e) {
      e.stopPropagation();
    }
  };
  attr$1({ mode: "boolean" })(C.prototype, "disabled");
  attr$1({ mode: "fromView", attribute: "value" })(C.prototype, "initialValue");
  attr$1(C.prototype, "name");
  attr$1({ mode: "boolean" })(C.prototype, "required");
  observable(C.prototype, "value");
  return C;
}
class _Button extends FASTElement {
}
class FormAssociatedButton extends FormAssociated(_Button) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
class Button$1 extends FormAssociatedButton {
  constructor() {
    super(...arguments);
    this.handleSubmission = () => {
      if (!this.form) {
        return;
      }
      const attached = this.proxy.isConnected;
      if (!attached) {
        this.attachProxy();
      }
      typeof this.form.requestSubmit === "function" ? this.form.requestSubmit(this.proxy) : this.proxy.click();
      if (!attached) {
        this.detachProxy();
      }
    };
    this.handleFormReset = () => {
      var _a2;
      (_a2 = this.form) === null || _a2 === void 0 ? void 0 : _a2.reset();
    };
  }
  formactionChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formAction = this.formaction;
    }
  }
  formenctypeChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formEnctype = this.formenctype;
    }
  }
  formmethodChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formMethod = this.formmethod;
    }
  }
  formnovalidateChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formNoValidate = this.formnovalidate;
    }
  }
  formtargetChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.formTarget = this.formtarget;
    }
  }
  typeChanged(previous2, next2) {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.type = this.type;
    }
    next2 === "submit" && this.addEventListener("click", this.handleSubmission);
    previous2 === "submit" && this.removeEventListener("click", this.handleSubmission);
    next2 === "reset" && this.addEventListener("click", this.handleFormReset);
    previous2 === "reset" && this.removeEventListener("click", this.handleFormReset);
  }
  connectedCallback() {
    super.connectedCallback();
    this.proxy.setAttribute("type", this.type);
  }
  get root() {
    return this.control;
  }
}
__decorate$1([
  attr$1({ mode: "boolean" })
], Button$1.prototype, "autofocus", void 0);
__decorate$1([
  attr$1({ attribute: "form" })
], Button$1.prototype, "formId", void 0);
__decorate$1([
  attr$1
], Button$1.prototype, "formaction", void 0);
__decorate$1([
  attr$1
], Button$1.prototype, "formenctype", void 0);
__decorate$1([
  attr$1
], Button$1.prototype, "formmethod", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], Button$1.prototype, "formnovalidate", void 0);
__decorate$1([
  attr$1
], Button$1.prototype, "formtarget", void 0);
__decorate$1([
  attr$1
], Button$1.prototype, "type", void 0);
__decorate$1([
  observable
], Button$1.prototype, "defaultSlottedContent", void 0);
class DelegatesARIAButton {
}
__decorate$1([
  attr$1({ attribute: "aria-expanded", mode: "fromView" })
], DelegatesARIAButton.prototype, "ariaExpanded", void 0);
__decorate$1([
  attr$1({ attribute: "aria-pressed", mode: "fromView" })
], DelegatesARIAButton.prototype, "ariaPressed", void 0);
applyMixins(DelegatesARIAButton, ARIAGlobalStatesAndProperties);
applyMixins(Button$1, StartEnd, DelegatesARIAButton);
const CheckboxTemplate = html$1$1`
    <template
        role="checkbox"
        aria-checked="${(x2) => x2.checked}"
        aria-required="${(x2) => x2.required}"
        aria-disabled="${(x2) => x2.disabled}"
        aria-readonly="${(x2) => x2.readOnly}"
        tabindex="${(x2) => x2.disabled ? null : 0}"
        @keypress="${(x2, c2) => x2.keypressHandler(c2.event)}"
        @click="${(x2, c2) => x2.clickHandler(c2.event)}"
        class="${(x2) => x2.readOnly ? "readonly" : ""} ${(x2) => x2.checked ? "checked" : ""} ${(x2) => x2.indeterminate ? "indeterminate" : ""}"
    >
        <div part="control" class="control">
            <slot name="checked-indicator">
                <svg
                    aria-hidden="true"
                    part="checked-indicator"
                    class="checked-indicator"
                    viewBox="0 0 20 20"
                    xmlns="http://www.w3.org/2000/svg"
                >
                    <path
                        fill-rule="evenodd"
                        clip-rule="evenodd"
                        d="M8.143 12.6697L15.235 4.5L16.8 5.90363L8.23812 15.7667L3.80005 11.2556L5.27591 9.7555L8.143 12.6697Z"
                    />
                </svg>
            </slot>
            <slot name="indeterminate-indicator">
                <div part="indeterminate-indicator" class="indeterminate-indicator"></div>
            </slot>
        </div>
        <label
            part="label"
            class="${(x2) => x2.defaultSlottedNodes && x2.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
    </template>
`;
class _Checkbox extends FASTElement {
}
class FormAssociatedCheckbox extends FormAssociated(_Checkbox) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
class Checkbox extends FormAssociatedCheckbox {
  constructor() {
    super();
    this.initialValue = "on";
    this.indeterminate = false;
    this.dirtyChecked = false;
    this.constructed = false;
    this.formResetCallback = () => {
      this.checked = this.checkedAttribute;
      this.dirtyChecked = false;
    };
    this.keypressHandler = (e) => {
      switch (e.keyCode) {
        case keyCodeSpace:
          this.checked = !this.checked;
          break;
      }
    };
    this.clickHandler = (e) => {
      if (!this.disabled && !this.readOnly) {
        this.checked = !this.checked;
      }
    };
    this.defaultChecked = !!this.checkedAttribute;
    this.checked = this.defaultChecked;
    this.constructed = true;
  }
  readOnlyChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.readOnly = this.readOnly;
    }
  }
  checkedAttributeChanged() {
    this.defaultChecked = this.checkedAttribute;
  }
  defaultCheckedChanged() {
    if (!this.dirtyChecked) {
      this.checked = this.defaultChecked;
      this.dirtyChecked = false;
    }
  }
  checkedChanged() {
    if (!this.dirtyChecked) {
      this.dirtyChecked = true;
    }
    this.updateForm();
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.checked = this.checked;
    }
    if (this.constructed) {
      this.$emit("change");
    }
    this.validate();
  }
  connectedCallback() {
    super.connectedCallback();
    this.proxy.setAttribute("type", "checkbox");
    this.updateForm();
  }
  updateForm() {
    const value2 = this.checked ? this.value : null;
    this.setFormValue(value2, value2);
  }
}
__decorate$1([
  attr$1({ attribute: "readonly", mode: "boolean" })
], Checkbox.prototype, "readOnly", void 0);
__decorate$1([
  attr$1({ attribute: "checked", mode: "boolean" })
], Checkbox.prototype, "checkedAttribute", void 0);
__decorate$1([
  observable
], Checkbox.prototype, "defaultSlottedNodes", void 0);
__decorate$1([
  observable
], Checkbox.prototype, "defaultChecked", void 0);
__decorate$1([
  observable
], Checkbox.prototype, "checked", void 0);
__decorate$1([
  observable
], Checkbox.prototype, "indeterminate", void 0);
var SelectPosition;
(function(SelectPosition2) {
  SelectPosition2["above"] = "above";
  SelectPosition2["below"] = "below";
})(SelectPosition || (SelectPosition = {}));
var SelectRole;
(function(SelectRole2) {
  SelectRole2["combobox"] = "combobox";
})(SelectRole || (SelectRole = {}));
function isListboxOption(el2) {
  return isHTMLElement(el2) && (el2.getAttribute("role") === "option" || el2 instanceof HTMLOptionElement);
}
class ListboxOption extends FASTElement {
  constructor(text2, value2, defaultSelected, selected) {
    super();
    this.defaultSelected = false;
    this.dirtySelected = false;
    this.selected = this.defaultSelected;
    this.dirtyValue = false;
    this.initialValue = this.initialValue || "";
    if (text2) {
      this.textContent = text2;
    }
    if (value2) {
      this.initialValue = value2;
    }
    if (defaultSelected) {
      this.defaultSelected = defaultSelected;
    }
    if (selected) {
      this.selected = selected;
    }
    this.proxy = new Option(`${this.textContent}`, this.initialValue, this.defaultSelected, this.selected);
    this.proxy.disabled = this.disabled;
  }
  defaultSelectedChanged() {
    if (!this.dirtySelected) {
      this.selected = this.defaultSelected;
      if (this.proxy instanceof HTMLOptionElement) {
        this.proxy.selected = this.defaultSelected;
      }
    }
  }
  disabledChanged(prev, next2) {
    if (this.proxy instanceof HTMLOptionElement) {
      this.proxy.disabled = this.disabled;
    }
  }
  selectedAttributeChanged() {
    this.defaultSelected = this.selectedAttribute;
    if (this.proxy instanceof HTMLOptionElement) {
      this.proxy.defaultSelected = this.defaultSelected;
    }
  }
  selectedChanged() {
    if (this.$fastController.isConnected) {
      if (!this.dirtySelected) {
        this.dirtySelected = true;
      }
      if (this.proxy instanceof HTMLOptionElement) {
        this.proxy.selected = this.selected;
      }
    }
  }
  initialValueChanged(previous2, next2) {
    if (!this.dirtyValue) {
      this.value = this.initialValue;
      this.dirtyValue = false;
    }
  }
  get label() {
    return this.value ? this.value : this.textContent ? this.textContent : "";
  }
  get text() {
    return this.textContent;
  }
  set value(next2) {
    this._value = next2;
    this.dirtyValue = true;
    if (this.proxy instanceof HTMLElement) {
      this.proxy.value = next2;
    }
    Observable.notify(this, "value");
  }
  get value() {
    Observable.track(this, "value");
    return this._value ? this._value : this.text;
  }
  get form() {
    return this.proxy ? this.proxy.form : null;
  }
}
__decorate$1([
  observable
], ListboxOption.prototype, "defaultSelected", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], ListboxOption.prototype, "disabled", void 0);
__decorate$1([
  attr$1({ attribute: "selected", mode: "boolean" })
], ListboxOption.prototype, "selectedAttribute", void 0);
__decorate$1([
  observable
], ListboxOption.prototype, "selected", void 0);
__decorate$1([
  attr$1({ attribute: "value", mode: "fromView" })
], ListboxOption.prototype, "initialValue", void 0);
applyMixins(ListboxOption, StartEnd);
var ListboxRole;
(function(ListboxRole2) {
  ListboxRole2["listbox"] = "listbox";
})(ListboxRole || (ListboxRole = {}));
class Listbox extends FASTElement {
  constructor() {
    super(...arguments);
    this.selectedIndex = -1;
    this.typeaheadBuffer = "";
    this.typeaheadTimeout = -1;
    this.typeAheadExpired = true;
    this.role = ListboxRole.listbox;
    this._options = [];
    this.selectedOptions = [];
    this.shouldSkipFocus = false;
    this.handleTypeAhead = (key) => {
      if (this.typeaheadTimeout) {
        window.clearTimeout(this.typeaheadTimeout);
      }
      this.typeaheadTimeout = window.setTimeout(() => this.typeAheadExpired = true, Listbox.TYPE_AHEAD_TIMEOUT_MS);
      if (key.length > 1) {
        return;
      }
      this.typeaheadBuffer = `${this.typeAheadExpired ? "" : this.typeaheadBuffer}${key}`;
    };
  }
  selectedIndexChanged(prev, next2) {
    this.setSelectedOptions();
  }
  typeaheadBufferChanged(prev, next2) {
    if (this.$fastController.isConnected) {
      const pattern = this.typeaheadBuffer.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
      const re = new RegExp(`^${pattern}`, "gi");
      const filteredOptions = this.options.filter((o) => o.text.trim().match(re));
      if (filteredOptions.length) {
        const selectedIndex = this.options.indexOf(filteredOptions[0]);
        if (selectedIndex > -1) {
          this.selectedIndex = selectedIndex;
        }
      }
      this.typeAheadExpired = false;
    }
  }
  slottedOptionsChanged(prev, next2) {
    if (this.$fastController.isConnected) {
      this.options = next2.reduce((options2, item) => {
        if (isListboxOption(item)) {
          options2.push(item);
        }
        return options2;
      }, []);
      this.options.forEach((o) => {
        o.id = o.id || uniqueId("option-");
      });
      this.setSelectedOptions();
      this.setDefaultSelectedOption();
    }
  }
  get options() {
    Observable.track(this, "options");
    return this._options;
  }
  set options(value2) {
    this._options = value2;
    Observable.notify(this, "options");
  }
  selectedOptionsChanged(prev, next2) {
    if (this.$fastController.isConnected) {
      this.options.forEach((o) => {
        o.selected = next2.includes(o);
      });
    }
  }
  get firstSelectedOption() {
    return this.selectedOptions[0];
  }
  focusAndScrollOptionIntoView() {
    if (this.contains(document.activeElement) && this.firstSelectedOption) {
      this.firstSelectedOption.focus();
      requestAnimationFrame(() => {
        this.firstSelectedOption.scrollIntoView({ block: "nearest" });
      });
    }
  }
  focusinHandler(e) {
    if (!this.shouldSkipFocus && e.target === e.currentTarget) {
      this.setSelectedOptions();
      this.focusAndScrollOptionIntoView();
    }
    this.shouldSkipFocus = false;
  }
  mousedownHandler(e) {
    this.shouldSkipFocus = !this.contains(document.activeElement);
    return true;
  }
  setDefaultSelectedOption() {
    if (this.options && this.$fastController.isConnected) {
      const selectedIndex = this.options.findIndex((el2) => el2.getAttribute("selected") !== null);
      if (selectedIndex !== -1) {
        this.selectedIndex = selectedIndex;
        return;
      }
      this.selectedIndex = 0;
    }
  }
  setSelectedOptions() {
    if (this.$fastController.isConnected && this.options) {
      const selectedOption = this.options[this.selectedIndex] || null;
      this.selectedOptions = this.options.filter((el2) => el2.isSameNode(selectedOption));
      this.ariaActiveDescendant = this.firstSelectedOption ? this.firstSelectedOption.id : "";
      this.focusAndScrollOptionIntoView();
    }
  }
  selectFirstOption() {
    if (!this.disabled) {
      this.selectedIndex = 0;
    }
  }
  selectLastOption() {
    if (!this.disabled) {
      this.selectedIndex = this.options.length - 1;
    }
  }
  selectNextOption() {
    if (!this.disabled && this.options && this.selectedIndex < this.options.length - 1) {
      this.selectedIndex += 1;
    }
  }
  get length() {
    if (this.options) {
      return this.options.length;
    }
    return 0;
  }
  selectPreviousOption() {
    if (!this.disabled && this.selectedIndex > 0) {
      this.selectedIndex = this.selectedIndex - 1;
    }
  }
  clickHandler(e) {
    const captured = e.target.closest(`option,[role=option]`);
    if (captured && !captured.disabled) {
      this.selectedIndex = this.options.indexOf(captured);
      return true;
    }
  }
  keydownHandler(e) {
    if (this.disabled) {
      return true;
    }
    this.shouldSkipFocus = false;
    const key = e.key;
    switch (key) {
      case "Home": {
        if (!e.shiftKey) {
          e.preventDefault();
          this.selectFirstOption();
        }
        break;
      }
      case "ArrowDown": {
        if (!e.shiftKey) {
          e.preventDefault();
          this.selectNextOption();
        }
        break;
      }
      case "ArrowUp": {
        if (!e.shiftKey) {
          e.preventDefault();
          this.selectPreviousOption();
        }
        break;
      }
      case "End": {
        e.preventDefault();
        this.selectLastOption();
        break;
      }
      case "Tab": {
        this.focusAndScrollOptionIntoView();
        return true;
      }
      case "Enter":
      case "Escape": {
        return true;
      }
      case " ": {
        if (this.typeAheadExpired) {
          return true;
        }
      }
      default: {
        if (key.length === 1) {
          this.handleTypeAhead(`${key}`);
        }
        return true;
      }
    }
  }
}
Listbox.TYPE_AHEAD_TIMEOUT_MS = 1e3;
Listbox.slottedOptionFilter = (n2) => isListboxOption(n2) && !n2.disabled && !n2.hidden;
__decorate$1([
  observable
], Listbox.prototype, "selectedIndex", void 0);
__decorate$1([
  observable
], Listbox.prototype, "typeaheadBuffer", void 0);
__decorate$1([
  attr$1
], Listbox.prototype, "role", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], Listbox.prototype, "disabled", void 0);
__decorate$1([
  observable
], Listbox.prototype, "slottedOptions", void 0);
__decorate$1([
  observable
], Listbox.prototype, "selectedOptions", void 0);
class DelegatesARIAListbox {
  constructor() {
    this.ariaActiveDescendant = "";
  }
}
__decorate$1([
  observable
], DelegatesARIAListbox.prototype, "ariaActiveDescendant", void 0);
__decorate$1([
  observable
], DelegatesARIAListbox.prototype, "ariaDisabled", void 0);
__decorate$1([
  observable
], DelegatesARIAListbox.prototype, "ariaExpanded", void 0);
applyMixins(DelegatesARIAListbox, ARIAGlobalStatesAndProperties);
applyMixins(Listbox, DelegatesARIAListbox);
class CSSCustomPropertyBehavior {
  constructor(name, value2, host) {
    this.name = name;
    this.value = value2;
    this.host = host;
    this.propertyName = `--${name}`;
    this.var = `var(${this.propertyName})`;
  }
  bind(source) {
    const target = this.host(source);
    if (target !== null) {
      if (typeof target.registerCSSCustomProperty === "function") {
        target.registerCSSCustomProperty(this);
      } else {
        if (!Array.isArray(target.disconnectedCSSCustomPropertyRegistry)) {
          target.disconnectedCSSCustomPropertyRegistry = [];
        }
        target.disconnectedCSSCustomPropertyRegistry.push(this);
      }
    }
  }
  unbind(source) {
    const target = this.host(source);
    if (target !== null && typeof target.unregisterCSSCustomProperty === "function") {
      target.unregisterCSSCustomProperty(this);
    }
  }
}
function cssCustomPropertyBehaviorFactory(name, value2, host) {
  return new CSSCustomPropertyBehavior(name, value2, host);
}
const ListboxOptionTemplate = html$1$1`
    <template
        aria-selected="${(x2) => x2.selected}"
        class="${(x2) => x2.selected ? "selected" : ""} ${(x2) => x2.disabled ? "disabled" : ""}"
        role="option"
    >
        ${startTemplate}
        <span class="content" part="content">
            <slot></slot>
        </span>
        ${endTemplate}
    </template>
`;
const TextFieldTemplate = html$1$1`
    <template
        class="
            ${(x2) => x2.readOnly ? "readonly" : ""}
        "
    >
        <label
            part="label"
            for="control"
            class="${(x2) => x2.defaultSlottedNodes && x2.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot
                ${slotted({ property: "defaultSlottedNodes", filter: whitespaceFilter })}
            ></slot>
        </label>
        <div class="root" part="root">
            ${startTemplate}
            <input
                class="control"
                part="control"
                id="control"
                @input="${(x2) => x2.handleTextInput()}"
                @change="${(x2) => x2.handleChange()}"
                ?autofocus="${(x2) => x2.autofocus}"
                ?disabled="${(x2) => x2.disabled}"
                list="${(x2) => x2.list}"
                maxlength="${(x2) => x2.maxlength}"
                minlength="${(x2) => x2.minlength}"
                pattern="${(x2) => x2.pattern}"
                placeholder="${(x2) => x2.placeholder}"
                ?readonly="${(x2) => x2.readOnly}"
                ?required="${(x2) => x2.required}"
                size="${(x2) => x2.size}"
                ?spellcheck="${(x2) => x2.spellcheck}"
                :value="${(x2) => x2.value}"
                type="${(x2) => x2.type}"
                aria-atomic="${(x2) => x2.ariaAtomic}"
                aria-busy="${(x2) => x2.ariaBusy}"
                aria-controls="${(x2) => x2.ariaControls}"
                aria-current="${(x2) => x2.ariaCurrent}"
                aria-describedBy="${(x2) => x2.ariaDescribedby}"
                aria-details="${(x2) => x2.ariaDetails}"
                aria-disabled="${(x2) => x2.ariaDisabled}"
                aria-errormessage="${(x2) => x2.ariaErrormessage}"
                aria-flowto="${(x2) => x2.ariaFlowto}"
                aria-haspopup="${(x2) => x2.ariaHaspopup}"
                aria-hidden="${(x2) => x2.ariaHidden}"
                aria-invalid="${(x2) => x2.ariaInvalid}"
                aria-keyshortcuts="${(x2) => x2.ariaKeyshortcuts}"
                aria-label="${(x2) => x2.ariaLabel}"
                aria-labelledby="${(x2) => x2.ariaLabelledby}"
                aria-live="${(x2) => x2.ariaLive}"
                aria-owns="${(x2) => x2.ariaOwns}"
                aria-relevant="${(x2) => x2.ariaRelevant}"
                aria-roledescription="${(x2) => x2.ariaRoledescription}"
                ${ref("control")}
            />
            ${endTemplate}
        </div>
    </template>
`;
class _TextField extends FASTElement {
}
class FormAssociatedTextField extends FormAssociated(_TextField) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
var TextFieldType;
(function(TextFieldType2) {
  TextFieldType2["email"] = "email";
  TextFieldType2["password"] = "password";
  TextFieldType2["tel"] = "tel";
  TextFieldType2["text"] = "text";
  TextFieldType2["url"] = "url";
})(TextFieldType || (TextFieldType = {}));
class TextField extends FormAssociatedTextField {
  constructor() {
    super(...arguments);
    this.type = TextFieldType.text;
  }
  readOnlyChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.readOnly = this.readOnly;
      this.validate();
    }
  }
  autofocusChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.autofocus = this.autofocus;
      this.validate();
    }
  }
  placeholderChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.placeholder = this.placeholder;
    }
  }
  typeChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.type = this.type;
      this.validate();
    }
  }
  listChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.setAttribute("list", this.list);
      this.validate();
    }
  }
  maxlengthChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.maxLength = this.maxlength;
      this.validate();
    }
  }
  minlengthChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.minLength = this.minlength;
      this.validate();
    }
  }
  patternChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.pattern = this.pattern;
      this.validate();
    }
  }
  sizeChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.size = this.size;
    }
  }
  spellcheckChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.spellcheck = this.spellcheck;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.proxy.setAttribute("type", this.type);
    this.validate();
    if (this.autofocus) {
      DOM.queueUpdate(() => {
        this.focus();
      });
    }
  }
  handleTextInput() {
    this.value = this.control.value;
  }
  handleChange() {
    this.$emit("change");
  }
}
__decorate$1([
  attr$1({ attribute: "readonly", mode: "boolean" })
], TextField.prototype, "readOnly", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TextField.prototype, "autofocus", void 0);
__decorate$1([
  attr$1
], TextField.prototype, "placeholder", void 0);
__decorate$1([
  attr$1
], TextField.prototype, "type", void 0);
__decorate$1([
  attr$1
], TextField.prototype, "list", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter })
], TextField.prototype, "maxlength", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter })
], TextField.prototype, "minlength", void 0);
__decorate$1([
  attr$1
], TextField.prototype, "pattern", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter })
], TextField.prototype, "size", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TextField.prototype, "spellcheck", void 0);
__decorate$1([
  observable
], TextField.prototype, "defaultSlottedNodes", void 0);
class DelegatesARIATextbox {
}
applyMixins(DelegatesARIATextbox, ARIAGlobalStatesAndProperties);
applyMixins(TextField, StartEnd, DelegatesARIATextbox);
const RadioGroupTemplate = html$1$1`
    <template
        role="radiogroup"
        aria-disabled="${(x2) => x2.disabled}"
        aria-readonly="${(x2) => x2.readOnly}"
        @click="${(x2, c2) => x2.clickHandler(c2.event)}"
        @keydown="${(x2, c2) => x2.keydownHandler(c2.event)}"
        @focusout="${(x2, c2) => x2.focusOutHandler(c2.event)}"
    >
        <slot name="label"></slot>
        <div
            class="positioning-region ${(x2) => x2.orientation === Orientation.horizontal ? "horizontal" : "vertical"}"
            part="positioning-region"
        >
            <slot
                ${slotted({
  property: "slottedRadioButtons",
  filter: elements("[role=radio]")
})}
            ></slot>
        </div>
    </template>
`;
class RadioGroup extends FASTElement {
  constructor() {
    super(...arguments);
    this.orientation = Orientation.horizontal;
    this.radioChangeHandler = (e) => {
      const changedRadio = e.target;
      if (changedRadio.checked) {
        this.slottedRadioButtons.forEach((radio) => {
          if (radio !== changedRadio) {
            radio.checked = false;
            if (!this.isInsideFoundationToolbar) {
              radio.setAttribute("tabindex", "-1");
            }
          }
        });
        this.selectedRadio = changedRadio;
        this.value = changedRadio.value;
        changedRadio.setAttribute("tabindex", "0");
        this.focusedRadio = changedRadio;
      }
      e.stopPropagation();
    };
    this.moveToRadioByIndex = (group, index2) => {
      const radio = group[index2];
      if (!this.isInsideToolbar) {
        radio.setAttribute("tabindex", "0");
        if (radio.readOnly) {
          this.slottedRadioButtons.forEach((nextRadio) => {
            if (nextRadio !== radio) {
              nextRadio.setAttribute("tabindex", "-1");
            }
          });
        } else {
          radio.checked = true;
          this.selectedRadio = radio;
        }
      }
      this.focusedRadio = radio;
      radio.focus();
    };
    this.moveRightOffGroup = () => {
      var _a2;
      (_a2 = this.nextElementSibling) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    this.moveLeftOffGroup = () => {
      var _a2;
      (_a2 = this.previousElementSibling) === null || _a2 === void 0 ? void 0 : _a2.focus();
    };
    this.focusOutHandler = (e) => {
      const group = this.slottedRadioButtons;
      const radio = e.target;
      const index2 = radio !== null ? group.indexOf(radio) : 0;
      const focusedIndex = this.focusedRadio ? group.indexOf(this.focusedRadio) : -1;
      if (focusedIndex === 0 && index2 === focusedIndex || focusedIndex === group.length - 1 && focusedIndex === index2) {
        if (!this.selectedRadio) {
          this.focusedRadio = group[0];
          this.focusedRadio.setAttribute("tabindex", "0");
          group.forEach((nextRadio) => {
            if (nextRadio !== this.focusedRadio) {
              nextRadio.setAttribute("tabindex", "-1");
            }
          });
        } else {
          this.focusedRadio = this.selectedRadio;
          if (!this.isInsideFoundationToolbar) {
            this.selectedRadio.setAttribute("tabindex", "0");
            group.forEach((nextRadio) => {
              if (nextRadio !== this.selectedRadio) {
                nextRadio.setAttribute("tabindex", "-1");
              }
            });
          }
        }
      }
      return true;
    };
    this.clickHandler = (e) => {
      const radio = e.target;
      if (radio) {
        const group = this.slottedRadioButtons;
        if (radio.checked || group.indexOf(radio) === 0) {
          radio.setAttribute("tabindex", "0");
          this.selectedRadio = radio;
        } else {
          radio.setAttribute("tabindex", "-1");
          this.selectedRadio = null;
        }
        this.focusedRadio = radio;
      }
      e.preventDefault();
    };
    this.shouldMoveOffGroupToTheRight = (index2, group, keyCode) => {
      return index2 === group.length && this.isInsideToolbar && keyCode === keyCodeArrowRight;
    };
    this.shouldMoveOffGroupToTheLeft = (group, keyCode) => {
      const index2 = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
      return index2 < 0 && this.isInsideToolbar && keyCode === keyCodeArrowLeft;
    };
    this.checkFocusedRadio = () => {
      if (this.focusedRadio !== null && !this.focusedRadio.readOnly && !this.focusedRadio.checked) {
        this.focusedRadio.checked = true;
        this.focusedRadio.setAttribute("tabindex", "0");
        this.focusedRadio.focus();
        this.selectedRadio = this.focusedRadio;
      }
    };
    this.moveRight = (e) => {
      const group = this.slottedRadioButtons;
      let index2 = 0;
      index2 = this.focusedRadio ? group.indexOf(this.focusedRadio) + 1 : 1;
      if (this.shouldMoveOffGroupToTheRight(index2, group, e.keyCode)) {
        this.moveRightOffGroup();
        return;
      } else if (index2 === group.length) {
        index2 = 0;
      }
      while (index2 < group.length && group.length > 1) {
        if (!group[index2].disabled) {
          this.moveToRadioByIndex(group, index2);
          break;
        } else if (this.focusedRadio && index2 === group.indexOf(this.focusedRadio)) {
          break;
        } else if (index2 + 1 >= group.length) {
          if (this.isInsideToolbar) {
            break;
          } else {
            index2 = 0;
          }
        } else {
          index2 += 1;
        }
      }
    };
    this.moveLeft = (e) => {
      const group = this.slottedRadioButtons;
      let index2 = 0;
      index2 = this.focusedRadio ? group.indexOf(this.focusedRadio) - 1 : 0;
      index2 = index2 < 0 ? group.length - 1 : index2;
      if (this.shouldMoveOffGroupToTheLeft(group, e.keyCode)) {
        this.moveLeftOffGroup();
        return;
      }
      while (index2 >= 0 && group.length > 1) {
        if (!group[index2].disabled) {
          this.moveToRadioByIndex(group, index2);
          break;
        } else if (this.focusedRadio && index2 === group.indexOf(this.focusedRadio)) {
          break;
        } else if (index2 - 1 < 0) {
          index2 = group.length - 1;
        } else {
          index2 -= 1;
        }
      }
    };
    this.keydownHandler = (e) => {
      const key = e.key;
      if (key in ArrowKeys && this.isInsideFoundationToolbar) {
        return true;
      }
      switch (key) {
        case keyEnter: {
          this.checkFocusedRadio();
          break;
        }
        case keyArrowRight:
        case keyArrowDown: {
          if (this.direction === Direction.ltr) {
            this.moveRight(e);
          } else {
            this.moveLeft(e);
          }
          break;
        }
        case keyArrowLeft:
        case keyArrowUp: {
          if (this.direction === Direction.ltr) {
            this.moveLeft(e);
          } else {
            this.moveRight(e);
          }
          break;
        }
        default: {
          return true;
        }
      }
    };
  }
  readOnlyChanged() {
    if (this.slottedRadioButtons !== void 0) {
      this.slottedRadioButtons.forEach((radio) => {
        if (this.readOnly) {
          radio.readOnly = true;
        } else {
          radio.readOnly = false;
        }
      });
    }
  }
  disabledChanged() {
    if (this.slottedRadioButtons !== void 0) {
      this.slottedRadioButtons.forEach((radio) => {
        if (this.disabled) {
          radio.disabled = true;
        } else {
          radio.disabled = false;
        }
      });
    }
  }
  nameChanged() {
    if (this.slottedRadioButtons) {
      this.slottedRadioButtons.forEach((radio) => {
        radio.setAttribute("name", this.name);
      });
    }
  }
  valueChanged() {
    if (this.slottedRadioButtons) {
      this.slottedRadioButtons.forEach((radio) => {
        if (radio.getAttribute("value") === this.value) {
          radio.checked = true;
          this.selectedRadio = radio;
        }
      });
    }
    this.$emit("change");
  }
  slottedRadioButtonsChanged(oldValue, newValue) {
    if (this.slottedRadioButtons && this.slottedRadioButtons.length > 0) {
      this.setupRadioButtons();
    }
  }
  get parentToolbar() {
    return this.closest('[role="toolbar"]');
  }
  get isInsideToolbar() {
    var _a2;
    return (_a2 = this.parentToolbar) !== null && _a2 !== void 0 ? _a2 : false;
  }
  get isInsideFoundationToolbar() {
    var _a2;
    return !!((_a2 = this.parentToolbar) === null || _a2 === void 0 ? void 0 : _a2["$fastController"]);
  }
  connectedCallback() {
    super.connectedCallback();
    this.direction = getDirection(this);
    this.setupRadioButtons();
  }
  disconnectedCallback() {
    this.slottedRadioButtons.forEach((radio) => {
      radio.removeEventListener("change", this.radioChangeHandler);
    });
  }
  setupRadioButtons() {
    const checkedRadios = this.slottedRadioButtons.filter((radio) => {
      return radio.hasAttribute("checked");
    });
    const numberOfCheckedRadios = checkedRadios ? checkedRadios.length : 0;
    if (numberOfCheckedRadios > 1) {
      const lastCheckedRadio = checkedRadios[numberOfCheckedRadios - 1];
      lastCheckedRadio.checked = true;
    }
    let foundMatchingVal = false;
    this.slottedRadioButtons.forEach((radio) => {
      if (this.name !== void 0) {
        radio.setAttribute("name", this.name);
      }
      if (this.disabled) {
        radio.disabled = true;
      }
      if (this.readOnly) {
        radio.readOnly = true;
      }
      if (this.value && this.value === radio.getAttribute("value")) {
        this.selectedRadio = radio;
        this.focusedRadio = radio;
        radio.checked = true;
        radio.setAttribute("tabindex", "0");
        foundMatchingVal = true;
      } else {
        if (!this.isInsideFoundationToolbar) {
          radio.setAttribute("tabindex", "-1");
        }
        radio.checked = false;
      }
      radio.addEventListener("change", this.radioChangeHandler);
    });
    if (this.value === void 0 && this.slottedRadioButtons.length > 0) {
      const checkedRadios2 = this.slottedRadioButtons.filter((radio) => {
        return radio.hasAttribute("checked");
      });
      const numberOfCheckedRadios2 = checkedRadios2 !== null ? checkedRadios2.length : 0;
      if (numberOfCheckedRadios2 > 0 && !foundMatchingVal) {
        const lastCheckedRadio = checkedRadios2[numberOfCheckedRadios2 - 1];
        lastCheckedRadio.checked = true;
        this.focusedRadio = lastCheckedRadio;
        lastCheckedRadio.setAttribute("tabindex", "0");
      } else {
        this.slottedRadioButtons[0].setAttribute("tabindex", "0");
        this.focusedRadio = this.slottedRadioButtons[0];
      }
    }
  }
}
__decorate$1([
  attr$1({ attribute: "readonly", mode: "boolean" })
], RadioGroup.prototype, "readOnly", void 0);
__decorate$1([
  attr$1({ attribute: "disabled", mode: "boolean" })
], RadioGroup.prototype, "disabled", void 0);
__decorate$1([
  attr$1
], RadioGroup.prototype, "name", void 0);
__decorate$1([
  attr$1
], RadioGroup.prototype, "value", void 0);
__decorate$1([
  attr$1
], RadioGroup.prototype, "orientation", void 0);
__decorate$1([
  observable
], RadioGroup.prototype, "childItems", void 0);
__decorate$1([
  observable
], RadioGroup.prototype, "slottedRadioButtons", void 0);
const RadioTemplate = html$1$1`
    <template
        role="radio"
        class="${(x2) => x2.checked ? "checked" : ""} ${(x2) => x2.readOnly ? "readonly" : ""}"
        aria-checked="${(x2) => x2.checked}"
        aria-required="${(x2) => x2.required}"
        aria-disabled="${(x2) => x2.disabled}"
        aria-readonly="${(x2) => x2.readOnly}"
        @keypress="${(x2, c2) => x2.keypressHandler(c2.event)}"
        @click="${(x2, c2) => x2.clickHandler(c2.event)}"
    >
        <div part="control" class="control">
            <slot name="checked-indicator">
                <div part="checked-indicator" class="checked-indicator"></div>
            </slot>
        </div>
        <label
            part="label"
            class="${(x2) => x2.defaultSlottedNodes && x2.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
    </template>
`;
class _Radio extends FASTElement {
}
class FormAssociatedRadio extends FormAssociated(_Radio) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
class Radio extends FormAssociatedRadio {
  constructor() {
    var _a2;
    super();
    this.initialValue = "on";
    this.checkedAttribute = false;
    this.dirtyChecked = false;
    this.formResetCallback = () => {
      this.checked = !!this.defaultChecked;
      this.dirtyChecked = false;
    };
    this.keypressHandler = (e) => {
      switch (e.keyCode) {
        case keyCodeSpace:
          if (!this.checked && !this.readOnly) {
            this.checked = true;
          }
          return;
      }
      return true;
    };
    this.clickHandler = (e) => {
      if (!this.disabled && !this.readOnly && !this.checked) {
        this.checked = true;
      }
    };
    this.checked = (_a2 = this.defaultChecked) !== null && _a2 !== void 0 ? _a2 : false;
  }
  readOnlyChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.readOnly = this.readOnly;
    }
  }
  checkedAttributeChanged() {
    this.defaultChecked = this.checkedAttribute;
  }
  defaultCheckedChanged() {
    var _a2;
    if (this.$fastController.isConnected && !this.dirtyChecked) {
      if (!this.isInsideRadioGroup()) {
        this.checked = (_a2 = this.defaultChecked) !== null && _a2 !== void 0 ? _a2 : false;
        this.dirtyChecked = false;
      }
    }
  }
  checkedChanged() {
    if (this.$fastController.isConnected) {
      if (!this.dirtyChecked) {
        this.dirtyChecked = true;
      }
      this.updateForm();
      if (this.proxy instanceof HTMLInputElement) {
        this.proxy.checked = this.checked;
      }
      this.$emit("change");
      this.validate();
    }
  }
  connectedCallback() {
    var _a2, _b;
    super.connectedCallback();
    this.proxy.setAttribute("type", "radio");
    this.validate();
    if (((_a2 = this.parentElement) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("role")) !== "radiogroup" && this.getAttribute("tabindex") === null) {
      if (!this.disabled) {
        this.setAttribute("tabindex", "0");
      }
    }
    this.updateForm();
    if (this.checkedAttribute) {
      if (!this.dirtyChecked) {
        if (!this.isInsideRadioGroup()) {
          this.checked = (_b = this.defaultChecked) !== null && _b !== void 0 ? _b : false;
          this.dirtyChecked = false;
        }
      }
    }
  }
  isInsideRadioGroup() {
    const parent = this.closest("[role=radiogroup]");
    return parent !== null;
  }
  updateForm() {
    const value2 = this.checked ? this.value : null;
    this.setFormValue(value2, value2);
  }
}
__decorate$1([
  attr$1({ attribute: "readonly", mode: "boolean" })
], Radio.prototype, "readOnly", void 0);
__decorate$1([
  observable
], Radio.prototype, "name", void 0);
__decorate$1([
  attr$1({ attribute: "checked", mode: "boolean" })
], Radio.prototype, "checkedAttribute", void 0);
__decorate$1([
  observable
], Radio.prototype, "defaultSlottedNodes", void 0);
__decorate$1([
  observable
], Radio.prototype, "defaultChecked", void 0);
__decorate$1([
  observable
], Radio.prototype, "checked", void 0);
class _Select extends Listbox {
}
class FormAssociatedSelect extends FormAssociated(_Select) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("select");
  }
}
class Select extends FormAssociatedSelect {
  constructor() {
    super(...arguments);
    this.open = false;
    this.forcedPosition = false;
    this.role = SelectRole.combobox;
    this.position = SelectPosition.below;
    this.maxHeight = 0;
    this.displayValue = "";
    this.formResetCallback = () => {
      this.setProxyOptions();
      this.setDefaultSelectedOption();
      this.value = this.firstSelectedOption.value;
    };
  }
  openChanged() {
    this.ariaExpanded = this.open ? "true" : "false";
    if (this.open) {
      this.setPositioning();
      this.focusAndScrollOptionIntoView();
      this.indexWhenOpened = this.selectedIndex;
    }
  }
  get value() {
    Observable.track(this, "value");
    return this._value;
  }
  set value(next2) {
    const prev = `${this._value}`;
    if (this.$fastController.isConnected && this.options) {
      const selectedIndex = this.options.findIndex((el2) => el2.value === next2);
      const prevSelectedOption = this.options[this.selectedIndex];
      const nextSelectedOption = this.options[selectedIndex];
      const prevSelectedValue = prevSelectedOption ? prevSelectedOption.value : null;
      const nextSelectedValue = nextSelectedOption ? nextSelectedOption.value : null;
      if (selectedIndex === -1 || prevSelectedValue !== nextSelectedValue) {
        next2 = "";
        this.selectedIndex = selectedIndex;
      }
      if (this.firstSelectedOption) {
        next2 = this.firstSelectedOption.value;
      }
    }
    if (prev !== next2) {
      this._value = next2;
      super.valueChanged(prev, next2);
      Observable.notify(this, "value");
    }
  }
  updateValue(shouldEmit) {
    if (this.$fastController.isConnected) {
      this.value = this.firstSelectedOption ? this.firstSelectedOption.value : "";
      this.displayValue = this.firstSelectedOption ? this.firstSelectedOption.textContent || this.firstSelectedOption.value : this.value;
    }
    if (shouldEmit) {
      this.$emit("change");
    }
  }
  selectedIndexChanged(prev, next2) {
    super.selectedIndexChanged(prev, next2);
    this.updateValue();
  }
  setPositioning() {
    const currentBox = this.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const availableBottom = viewportHeight - currentBox.bottom;
    this.position = this.forcedPosition ? this.positionAttribute : currentBox.top > availableBottom ? SelectPosition.above : SelectPosition.below;
    this.positionAttribute = this.forcedPosition ? this.positionAttribute : this.position;
    this.maxHeight = this.position === SelectPosition.above ? ~~currentBox.top : ~~availableBottom;
  }
  disabledChanged(prev, next2) {
    if (super.disabledChanged) {
      super.disabledChanged(prev, next2);
    }
    this.ariaDisabled = this.disabled ? "true" : "false";
  }
  clickHandler(e) {
    if (this.disabled) {
      return;
    }
    if (this.open) {
      const captured = e.target.closest(`option,[role=option]`);
      if (captured && captured.disabled) {
        return;
      }
    }
    super.clickHandler(e);
    this.open = !this.open;
    if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
      this.updateValue(true);
    }
    return true;
  }
  focusoutHandler(e) {
    if (!this.open) {
      return true;
    }
    const focusTarget = e.relatedTarget;
    if (this.isSameNode(focusTarget)) {
      this.focus();
      return;
    }
    if (!this.options || !this.options.includes(focusTarget)) {
      this.open = false;
    }
  }
  slottedOptionsChanged(prev, next2) {
    super.slottedOptionsChanged(prev, next2);
    this.setProxyOptions();
    this.updateValue();
  }
  setProxyOptions() {
    if (this.proxy instanceof HTMLSelectElement && this.options) {
      this.proxy.options.length = 0;
      this.options.forEach((option2) => {
        const proxyOption = option2.proxy || (option2 instanceof HTMLOptionElement ? option2.cloneNode() : null);
        if (proxyOption) {
          this.proxy.appendChild(proxyOption);
        }
      });
    }
  }
  keydownHandler(e) {
    super.keydownHandler(e);
    const key = e.key || e.key.charCodeAt(0);
    switch (key) {
      case " ": {
        if (this.typeAheadExpired) {
          e.preventDefault();
          this.open = !this.open;
        }
        break;
      }
      case "Enter": {
        e.preventDefault();
        this.open = !this.open;
        break;
      }
      case "Escape": {
        if (this.open) {
          e.preventDefault();
          this.open = false;
        }
        break;
      }
      case "Tab": {
        if (!this.open) {
          return true;
        }
        e.preventDefault();
        this.open = false;
      }
    }
    if (!this.open && this.indexWhenOpened !== this.selectedIndex) {
      this.updateValue(true);
    }
    return true;
  }
  connectedCallback() {
    super.connectedCallback();
    this.forcedPosition = !!this.positionAttribute;
  }
}
__decorate$1([
  attr$1({ attribute: "open", mode: "boolean" })
], Select.prototype, "open", void 0);
__decorate$1([
  attr$1({ attribute: "position" })
], Select.prototype, "positionAttribute", void 0);
__decorate$1([
  observable
], Select.prototype, "position", void 0);
__decorate$1([
  observable
], Select.prototype, "maxHeight", void 0);
__decorate$1([
  observable
], Select.prototype, "displayValue", void 0);
class DelegatesARIASelect {
}
__decorate$1([
  observable
], DelegatesARIASelect.prototype, "ariaExpanded", void 0);
__decorate$1([
  attr$1({ attribute: "aria-pressed", mode: "fromView" })
], DelegatesARIASelect.prototype, "ariaPressed", void 0);
applyMixins(DelegatesARIASelect, ARIAGlobalStatesAndProperties);
applyMixins(Select, StartEnd, DelegatesARIASelect);
const SelectTemplate = html$1$1`
    <template
        class="${(x2) => x2.open ? "open" : ""} ${(x2) => x2.disabled ? "disabled" : ""} ${(x2) => x2.position}"
        role="${(x2) => x2.role}"
        tabindex="${(x2) => !x2.disabled ? "0" : null}"
        aria-disabled="${(x2) => x2.ariaDisabled}"
        aria-expanded="${(x2) => x2.ariaExpanded}"
        @click="${(x2, c2) => x2.clickHandler(c2.event)}"
        @focusout="${(x2, c2) => x2.focusoutHandler(c2.event)}"
        @keydown="${(x2, c2) => x2.keydownHandler(c2.event)}"
    >
        <div
            aria-activedescendant="${(x2) => x2.open ? x2.ariaActiveDescendant : null}"
            aria-controls="listbox"
            aria-expanded="${(x2) => x2.ariaExpanded}"
            aria-haspopup="listbox"
            class="control"
            part="control"
            role="button"
            ?disabled="${(x2) => x2.disabled}"
        >
            ${startTemplate}
            <slot name="button-container">
                <div class="selected-value" part="selected-value">
                    <slot name="selected-value">${(x2) => x2.displayValue}</slot>
                </div>
                <div class="indicator" part="indicator" aria-hidden="true">
                    <slot name="indicator">
                        <svg
                            class="select-indicator"
                            part="select-indicator"
                            viewBox="0 0 12 7"
                            xmlns="http://www.w3.org/2000/svg"
                        >
                            <path
                                d="M11.85.65c.2.2.2.5 0 .7L6.4 6.84a.55.55 0 01-.78 0L.14 1.35a.5.5 0 11.71-.7L6 5.8 11.15.65c.2-.2.5-.2.7 0z"
                            />
                        </svg>
                    </slot>
                </div>
            </slot>
            ${endTemplate}
        </div>
        <div
            aria-disabled="${(x2) => x2.disabled}"
            class="listbox"
            id="listbox"
            part="listbox"
            role="listbox"
            style="--max-height: ${(x2) => x2.maxHeight}px"
            ?disabled="${(x2) => x2.disabled}"
            ?hidden="${(x2) => !x2.open}"
        >
            <slot
                ${slotted({
  filter: Listbox.slottedOptionFilter,
  flatten: true,
  property: "slottedOptions"
})}
            ></slot>
        </div>
    </template>
`;
const SwitchTemplate = html$1$1`
    <template
        role="switch"
        aria-checked="${(x2) => x2.checked}"
        aria-disabled="${(x2) => x2.disabled}"
        aria-readonly="${(x2) => x2.readOnly}"
        tabindex="${(x2) => x2.disabled ? null : 0}"
        @keypress="${(x2, c2) => x2.keypressHandler(c2.event)}"
        @click="${(x2, c2) => x2.clickHandler(c2.event)}"
        class="${(x2) => x2.checked ? "checked" : ""}"
    >
        <label
            part="label"
            class="${(x2) => x2.defaultSlottedNodes && x2.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <div part="switch" class="switch">
            <span class="checked-indicator" part="checked-indicator"></span>
        </div>
        <span class="status-message" part="status-message">
            <span class="checked-message" part="checked-message">
                <slot name="checked-message"></slot>
            </span>
            <span class="unchecked-message" part="unchecked-message">
                <slot name="unchecked-message"></slot>
            </span>
        </span>
    </template>
`;
class _Switch extends FASTElement {
}
class FormAssociatedSwitch extends FormAssociated(_Switch) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("input");
  }
}
class Switch extends FormAssociatedSwitch {
  constructor() {
    super();
    this.initialValue = "on";
    this.dirtyChecked = false;
    this.formResetCallback = () => {
      this.checked = this.checkedAttribute;
      this.dirtyChecked = false;
    };
    this.keypressHandler = (e) => {
      switch (e.keyCode) {
        case keyCodeSpace:
          this.checked = !this.checked;
          break;
      }
    };
    this.clickHandler = (e) => {
      if (!this.disabled && !this.readOnly) {
        this.checked = !this.checked;
      }
    };
    this.defaultChecked = !!this.checkedAttribute;
    this.checked = this.defaultChecked;
  }
  readOnlyChanged() {
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.readOnly = this.readOnly;
    }
    this.readOnly ? this.classList.add("readonly") : this.classList.remove("readonly");
  }
  checkedAttributeChanged() {
    this.defaultChecked = this.checkedAttribute;
  }
  defaultCheckedChanged() {
    if (!this.dirtyChecked) {
      this.checked = this.defaultChecked;
      this.dirtyChecked = false;
    }
  }
  checkedChanged() {
    if (!this.dirtyChecked) {
      this.dirtyChecked = true;
    }
    this.updateForm();
    if (this.proxy instanceof HTMLInputElement) {
      this.proxy.checked = this.checked;
    }
    this.$emit("change");
    this.checked ? this.classList.add("checked") : this.classList.remove("checked");
    this.validate();
  }
  connectedCallback() {
    super.connectedCallback();
    this.proxy.setAttribute("type", "checkbox");
    this.updateForm();
  }
  updateForm() {
    const value2 = this.checked ? this.value : null;
    this.setFormValue(value2, value2);
  }
}
__decorate$1([
  attr$1({ attribute: "readonly", mode: "boolean" })
], Switch.prototype, "readOnly", void 0);
__decorate$1([
  attr$1({ attribute: "checked", mode: "boolean" })
], Switch.prototype, "checkedAttribute", void 0);
__decorate$1([
  observable
], Switch.prototype, "defaultSlottedNodes", void 0);
__decorate$1([
  observable
], Switch.prototype, "defaultChecked", void 0);
__decorate$1([
  observable
], Switch.prototype, "checked", void 0);
const TabPanelTemplate = html$1$1`
    <template slot="tabpanel" role="tabpanel">
        <slot></slot>
    </template>
`;
class TabPanel extends FASTElement {
}
const TabTemplate = html$1$1`
    <template slot="tab" role="tab" aria-disabled="${(x2) => x2.disabled}">
        <slot></slot>
    </template>
`;
class Tab extends FASTElement {
}
__decorate$1([
  attr$1({ mode: "boolean" })
], Tab.prototype, "disabled", void 0);
const TabsTemplate = html$1$1`
    <template class="${(x2) => x2.orientation}">
        ${startTemplate}
        <div class="tablist" part="tablist" role="tablist">
            <slot class="tab" name="tab" part="tab" ${slotted("tabs")}></slot>

            ${when((x2) => x2.showActiveIndicator, html$1$1`
                    <div
                        ${ref("activeIndicatorRef")}
                        class="activeIndicator"
                        part="activeIndicator"
                    ></div>
                `)}
        </div>
        ${endTemplate}
        <div class="tabpanel">
            <slot name="tabpanel" part="tabpanel" ${slotted("tabpanels")}></slot>
        </div>
    </template>
`;
var TabsOrientation;
(function(TabsOrientation2) {
  TabsOrientation2["vertical"] = "vertical";
  TabsOrientation2["horizontal"] = "horizontal";
})(TabsOrientation || (TabsOrientation = {}));
class Tabs extends FASTElement {
  constructor() {
    super(...arguments);
    this.orientation = TabsOrientation.horizontal;
    this.activeindicator = true;
    this.showActiveIndicator = true;
    this.prevActiveTabIndex = 0;
    this.activeTabIndex = 0;
    this.ticking = false;
    this.change = () => {
      this.$emit("change", this.activetab);
    };
    this.isDisabledElement = (el2) => {
      return el2.getAttribute("aria-disabled") === "true";
    };
    this.isFocusableElement = (el2) => {
      return !this.isDisabledElement(el2);
    };
    this.setTabs = () => {
      const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
      this.tabIds = this.getTabIds();
      this.tabpanelIds = this.getTabPanelIds();
      this.activeTabIndex = this.getActiveIndex();
      this.showActiveIndicator = false;
      this.tabs.forEach((tab, index2) => {
        if (tab.slot === "tab" && this.isFocusableElement(tab)) {
          if (this.activeindicator) {
            this.showActiveIndicator = true;
          }
          const tabId = this.tabIds[index2];
          const tabpanelId = this.tabpanelIds[index2];
          tab.setAttribute("id", typeof tabId !== "string" ? `tab-${index2 + 1}` : tabId);
          tab.setAttribute("aria-selected", this.activeTabIndex === index2 ? "true" : "false");
          tab.setAttribute("aria-controls", typeof tabpanelId !== "string" ? `panel-${index2 + 1}` : tabpanelId);
          tab.addEventListener("click", this.handleTabClick);
          tab.addEventListener("keydown", this.handleTabKeyDown);
          tab.setAttribute("tabindex", this.activeTabIndex === index2 ? "0" : "-1");
          if (this.activeTabIndex === index2) {
            this.activetab = tab;
          }
        }
        tab.style[gridProperty] = `${index2 + 1}`;
        !this.isHorizontal() ? tab.classList.add("vertical") : tab.classList.remove("vertical");
      });
    };
    this.setTabPanels = () => {
      this.tabIds = this.getTabIds();
      this.tabpanelIds = this.getTabPanelIds();
      this.tabpanels.forEach((tabpanel, index2) => {
        const tabId = this.tabIds[index2];
        const tabpanelId = this.tabpanelIds[index2];
        tabpanel.setAttribute("id", typeof tabpanelId !== "string" ? `panel-${index2 + 1}` : tabpanelId);
        tabpanel.setAttribute("aria-labelledby", typeof tabId !== "string" ? `tab-${index2 + 1}` : tabId);
        this.activeTabIndex !== index2 ? tabpanel.setAttribute("hidden", "") : tabpanel.removeAttribute("hidden");
      });
    };
    this.handleTabClick = (event2) => {
      const selectedTab = event2.currentTarget;
      if (selectedTab.nodeType === 1) {
        this.prevActiveTabIndex = this.activeTabIndex;
        this.activeTabIndex = this.tabs.indexOf(selectedTab);
        this.setComponent();
      }
    };
    this.handleTabKeyDown = (event2) => {
      const keyCode = event2.keyCode;
      if (this.isHorizontal()) {
        switch (keyCode) {
          case keyCodeArrowLeft:
            event2.preventDefault();
            this.adjustBackward(event2);
            break;
          case keyCodeArrowRight:
            event2.preventDefault();
            this.adjustForward(event2);
            break;
        }
      } else {
        switch (keyCode) {
          case keyCodeArrowUp:
            event2.preventDefault();
            this.adjustBackward(event2);
            break;
          case keyCodeArrowDown:
            event2.preventDefault();
            this.adjustForward(event2);
            break;
        }
      }
      switch (keyCode) {
        case keyCodeHome:
          event2.preventDefault();
          this.adjust(-this.activeTabIndex);
          break;
        case keyCodeEnd:
          event2.preventDefault();
          this.adjust(this.tabs.length - this.activeTabIndex - 1);
          break;
      }
    };
    this.adjustForward = (e) => {
      const group = this.tabs;
      let index2 = 0;
      index2 = this.activetab ? group.indexOf(this.activetab) + 1 : 1;
      if (index2 === group.length) {
        index2 = 0;
      }
      while (index2 < group.length && group.length > 1) {
        if (this.isFocusableElement(group[index2])) {
          this.moveToTabByIndex(group, index2);
          break;
        } else if (this.activetab && index2 === group.indexOf(this.activetab)) {
          break;
        } else if (index2 + 1 >= group.length) {
          index2 = 0;
        } else {
          index2 += 1;
        }
      }
    };
    this.adjustBackward = (e) => {
      const group = this.tabs;
      let index2 = 0;
      index2 = this.activetab ? group.indexOf(this.activetab) - 1 : 0;
      index2 = index2 < 0 ? group.length - 1 : index2;
      while (index2 >= 0 && group.length > 1) {
        if (this.isFocusableElement(group[index2])) {
          this.moveToTabByIndex(group, index2);
          break;
        } else if (index2 - 1 < 0) {
          index2 = group.length - 1;
        } else {
          index2 -= 1;
        }
      }
    };
    this.moveToTabByIndex = (group, index2) => {
      const tab = group[index2];
      this.activetab = tab;
      this.prevActiveTabIndex = this.activeTabIndex;
      this.activeTabIndex = index2;
      tab.focus();
      this.setComponent();
    };
  }
  activeidChanged() {
    if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
      this.setTabs();
      this.setTabPanels();
      this.handleActiveIndicatorPosition();
    }
  }
  tabsChanged() {
    if (this.$fastController.isConnected && this.tabs.length <= this.tabpanels.length) {
      this.setTabs();
      this.setTabPanels();
      this.handleActiveIndicatorPosition();
    }
  }
  tabpanelsChanged() {
    if (this.$fastController.isConnected && this.tabpanels.length <= this.tabs.length) {
      this.setTabs();
      this.setTabPanels();
      this.handleActiveIndicatorPosition();
    }
  }
  getActiveIndex() {
    const id = this.activeid;
    if (id !== void 0) {
      return this.tabIds.indexOf(this.activeid) === -1 ? 0 : this.tabIds.indexOf(this.activeid);
    } else {
      return 0;
    }
  }
  getTabIds() {
    return this.tabs.map((tab) => {
      return tab.getAttribute("id");
    });
  }
  getTabPanelIds() {
    return this.tabpanels.map((tabPanel) => {
      return tabPanel.getAttribute("id");
    });
  }
  setComponent() {
    if (this.activeTabIndex !== this.prevActiveTabIndex) {
      this.activeid = this.tabIds[this.activeTabIndex];
      this.change();
      this.setTabs();
      this.handleActiveIndicatorPosition();
      this.setTabPanels();
      this.focusTab();
      this.change();
    }
  }
  isHorizontal() {
    return this.orientation === TabsOrientation.horizontal;
  }
  handleActiveIndicatorPosition() {
    if (this.showActiveIndicator && this.activeindicator && this.activeTabIndex !== this.prevActiveTabIndex) {
      if (this.ticking) {
        this.ticking = false;
      } else {
        this.ticking = true;
        this.animateActiveIndicator();
      }
    }
  }
  animateActiveIndicator() {
    this.ticking = true;
    const gridProperty = this.isHorizontal() ? "gridColumn" : "gridRow";
    const translateProperty = this.isHorizontal() ? "translateX" : "translateY";
    const offsetProperty = this.isHorizontal() ? "offsetLeft" : "offsetTop";
    const prev = this.activeIndicatorRef[offsetProperty];
    this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
    const next2 = this.activeIndicatorRef[offsetProperty];
    this.activeIndicatorRef.style[gridProperty] = `${this.prevActiveTabIndex + 1}`;
    const dif = next2 - prev;
    this.activeIndicatorRef.style.transform = `${translateProperty}(${dif}px)`;
    this.activeIndicatorRef.classList.add("activeIndicatorTransition");
    this.activeIndicatorRef.addEventListener("transitionend", () => {
      this.ticking = false;
      this.activeIndicatorRef.style[gridProperty] = `${this.activeTabIndex + 1}`;
      this.activeIndicatorRef.style.transform = `${translateProperty}(0px)`;
      this.activeIndicatorRef.classList.remove("activeIndicatorTransition");
    });
  }
  adjust(adjustment) {
    this.prevActiveTabIndex = this.activeTabIndex;
    this.activeTabIndex = wrapInBounds(0, this.tabs.length - 1, this.activeTabIndex + adjustment);
    this.setComponent();
  }
  focusTab() {
    this.tabs[this.activeTabIndex].focus();
  }
  connectedCallback() {
    super.connectedCallback();
    this.tabIds = this.getTabIds();
    this.tabpanelIds = this.getTabPanelIds();
    this.activeTabIndex = this.getActiveIndex();
  }
}
__decorate$1([
  attr$1
], Tabs.prototype, "orientation", void 0);
__decorate$1([
  attr$1
], Tabs.prototype, "activeid", void 0);
__decorate$1([
  observable
], Tabs.prototype, "tabs", void 0);
__decorate$1([
  observable
], Tabs.prototype, "tabpanels", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], Tabs.prototype, "activeindicator", void 0);
__decorate$1([
  observable
], Tabs.prototype, "activeIndicatorRef", void 0);
__decorate$1([
  observable
], Tabs.prototype, "showActiveIndicator", void 0);
applyMixins(Tabs, StartEnd);
class _TextArea extends FASTElement {
}
class FormAssociatedTextArea extends FormAssociated(_TextArea) {
  constructor() {
    super(...arguments);
    this.proxy = document.createElement("textarea");
  }
}
var TextAreaResize;
(function(TextAreaResize2) {
  TextAreaResize2["none"] = "none";
  TextAreaResize2["both"] = "both";
  TextAreaResize2["horizontal"] = "horizontal";
  TextAreaResize2["vertical"] = "vertical";
})(TextAreaResize || (TextAreaResize = {}));
class TextArea extends FormAssociatedTextArea {
  constructor() {
    super(...arguments);
    this.resize = TextAreaResize.none;
    this.cols = 20;
    this.handleTextInput = () => {
      this.value = this.control.value;
    };
  }
  readOnlyChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.readOnly = this.readOnly;
    }
  }
  autofocusChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.autofocus = this.autofocus;
    }
  }
  listChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.setAttribute("list", this.list);
    }
  }
  maxlengthChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.maxLength = this.maxlength;
    }
  }
  minlengthChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.minLength = this.minlength;
    }
  }
  spellcheckChanged() {
    if (this.proxy instanceof HTMLTextAreaElement) {
      this.proxy.spellcheck = this.spellcheck;
    }
  }
  handleChange() {
    this.$emit("change");
  }
}
__decorate$1([
  attr$1({ mode: "boolean" })
], TextArea.prototype, "readOnly", void 0);
__decorate$1([
  attr$1
], TextArea.prototype, "resize", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TextArea.prototype, "autofocus", void 0);
__decorate$1([
  attr$1({ attribute: "form" })
], TextArea.prototype, "formId", void 0);
__decorate$1([
  attr$1
], TextArea.prototype, "list", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter })
], TextArea.prototype, "maxlength", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter })
], TextArea.prototype, "minlength", void 0);
__decorate$1([
  attr$1
], TextArea.prototype, "name", void 0);
__decorate$1([
  attr$1
], TextArea.prototype, "placeholder", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea.prototype, "cols", void 0);
__decorate$1([
  attr$1({ converter: nullableNumberConverter, mode: "fromView" })
], TextArea.prototype, "rows", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TextArea.prototype, "spellcheck", void 0);
__decorate$1([
  observable
], TextArea.prototype, "defaultSlottedNodes", void 0);
applyMixins(TextArea, DelegatesARIATextbox);
const TextAreaTemplate = html$1$1`
    <template
        class="
            ${(x2) => x2.readOnly ? "readonly" : ""}
            ${(x2) => x2.resize !== TextAreaResize.none ? `resize-${x2.resize}` : ""}"
    >
        <label
            part="label"
            for="control"
            class="${(x2) => x2.defaultSlottedNodes && x2.defaultSlottedNodes.length ? "label" : "label label__hidden"}"
        >
            <slot ${slotted("defaultSlottedNodes")}></slot>
        </label>
        <textarea
            part="control"
            class="control"
            id="control"
            ?autofocus="${(x2) => x2.autofocus}"
            cols="${(x2) => x2.cols}"
            ?disabled="${(x2) => x2.disabled}"
            form="${(x2) => x2.form}"
            list="${(x2) => x2.list}"
            maxlength="${(x2) => x2.maxlength}"
            minlength="${(x2) => x2.minlength}"
            name="${(x2) => x2.name}"
            placeholder="${(x2) => x2.placeholder}"
            ?readonly="${(x2) => x2.readOnly}"
            ?required="${(x2) => x2.required}"
            rows="${(x2) => x2.rows}"
            ?spellcheck="${(x2) => x2.spellcheck}"
            :value="${(x2) => x2.value}"
            aria-atomic="${(x2) => x2.ariaAtomic}"
            aria-busy="${(x2) => x2.ariaBusy}"
            aria-controls="${(x2) => x2.ariaControls}"
            aria-current="${(x2) => x2.ariaCurrent}"
            aria-describedBy="${(x2) => x2.ariaDescribedby}"
            aria-details="${(x2) => x2.ariaDetails}"
            aria-disabled="${(x2) => x2.ariaDisabled}"
            aria-errormessage="${(x2) => x2.ariaErrormessage}"
            aria-flowto="${(x2) => x2.ariaFlowto}"
            aria-haspopup="${(x2) => x2.ariaHaspopup}"
            aria-hidden="${(x2) => x2.ariaHidden}"
            aria-invalid="${(x2) => x2.ariaInvalid}"
            aria-keyshortcuts="${(x2) => x2.ariaKeyshortcuts}"
            aria-label="${(x2) => x2.ariaLabel}"
            aria-labelledby="${(x2) => x2.ariaLabelledby}"
            aria-live="${(x2) => x2.ariaLive}"
            aria-owns="${(x2) => x2.ariaOwns}"
            aria-relevant="${(x2) => x2.ariaRelevant}"
            aria-roledescription="${(x2) => x2.ariaRoledescription}"
            @input="${(x2, c2) => x2.handleTextInput()}"
            @change="${(x2) => x2.handleChange()}"
            ${ref("control")}
        ></textarea>
    </template>
`;
const TreeItemTemplate = html$1$1`
    <template
        role="treeitem"
        slot="${(x2) => x2.isNestedItem() ? "item" : void 0}"
        tabindex="${(x2) => x2.disabled || !x2.focusable ? void 0 : 0}"
        class="${(x2) => x2.expanded ? "expanded" : ""} ${(x2) => x2.selected ? "selected" : ""} ${(x2) => x2.nested ? "nested" : ""}
            ${(x2) => x2.disabled ? "disabled" : ""}"
        aria-expanded="${(x2) => x2.childItems && x2.childItemLength() > 0 ? x2.expanded : void 0}"
        aria-selected="${(x2) => x2.selected}"
        aria-disabled="${(x2) => x2.disabled}"
        @keydown="${(x2, c2) => x2.handleKeyDown(c2.event)}"
        @click="${(x2, c2) => x2.handleClick(c2.event)}"
        ${children$1({
  property: "childItems",
  filter: elements()
})}
    >
        <div class="positioning-region" part="positioning-region">
            <div class="content-region" part="content-region">
                ${when((x2) => x2.childItems && x2.childItemLength() > 0, html$1$1`
                        <div
                            aria-hidden="true"
                            class="expand-collapse-button"
                            part="expand-collapse-button"
                            @click="${(x2, c2) => x2.handleExpandCollapseButtonClick(c2.event)}"
                            ${ref("expandCollapseButton")}
                        >
                            <slot name="expand-collapse-glyph">
                                <svg
                                    viewBox="0 0 16 16"
                                    xmlns="http://www.w3.org/2000/svg"
                                    class="expand-collapse-glyph"
                                >
                                    <path
                                        d="M5.00001 12.3263C5.00124 12.5147 5.05566 12.699 5.15699 12.8578C5.25831 13.0167 5.40243 13.1437 5.57273 13.2242C5.74304 13.3047 5.9326 13.3354 6.11959 13.3128C6.30659 13.2902 6.4834 13.2152 6.62967 13.0965L10.8988 8.83532C11.0739 8.69473 11.2153 8.51658 11.3124 8.31402C11.4096 8.11146 11.46 7.88966 11.46 7.66499C11.46 7.44033 11.4096 7.21853 11.3124 7.01597C11.2153 6.81341 11.0739 6.63526 10.8988 6.49467L6.62967 2.22347C6.48274 2.10422 6.30501 2.02912 6.11712 2.00691C5.92923 1.9847 5.73889 2.01628 5.56823 2.09799C5.39757 2.17969 5.25358 2.30817 5.153 2.46849C5.05241 2.62882 4.99936 2.8144 5.00001 3.00369V12.3263Z"
                                    />
                                </svg>
                            </slot>
                        </div>
                    `)}
                ${startTemplate}
                <slot></slot>
                ${endTemplate}
            </div>
        </div>
        ${when((x2) => x2.childItems && x2.childItemLength() > 0 && (x2.expanded || x2.renderCollapsedChildren), html$1$1`
                <div role="group" class="items" part="items">
                    <slot name="item" ${slotted("items")}></slot>
                </div>
            `)}
    </template>
`;
function isTreeItemElement(el2) {
  return isHTMLElement(el2) && el2.getAttribute("role") === "treeitem";
}
class TreeItem extends FASTElement {
  constructor() {
    super(...arguments);
    this.expanded = false;
    this.focusable = false;
    this.enabledChildTreeItems = [];
    this.handleFocus = (e) => {
    };
    this.handleBlur = (e) => {
    };
    this.handleKeyDown = (e) => {
      if (e.target !== e.currentTarget) {
        return true;
      }
      switch (e.keyCode) {
        case keyCodeArrowLeft:
          e.preventDefault();
          this.collapseOrFocusParent();
          break;
        case keyCodeArrowRight:
          e.preventDefault();
          this.expandOrFocusFirstChild();
          break;
        case keyCodeArrowDown:
          e.preventDefault();
          this.focusNextNode(1);
          break;
        case keyCodeArrowUp:
          e.preventDefault();
          this.focusNextNode(-1);
          break;
        case keyCodeEnter:
          this.handleSelected(e);
          break;
      }
      return true;
    };
    this.handleExpandCollapseButtonClick = (e) => {
      if (!this.disabled) {
        e.preventDefault();
        this.setExpanded(!this.expanded);
      }
    };
    this.handleClick = (e) => {
      if (!e.defaultPrevented && !this.disabled) {
        this.handleSelected(e);
      }
    };
    this.isNestedItem = () => {
      return isTreeItemElement(this.parentElement);
    };
  }
  itemsChanged(oldValue, newValue) {
    if (this.$fastController.isConnected) {
      this.items.forEach((node) => {
        if (isTreeItemElement(node)) {
          node.nested = true;
        }
      });
      this.enabledChildTreeItems = this.items.filter((item) => {
        return isTreeItemElement(item) && !item.hasAttribute("disabled");
      });
    }
  }
  getParentTreeNode() {
    const parentNode = this.parentElement.closest("[role='tree']");
    return parentNode;
  }
  connectedCallback() {
    super.connectedCallback();
    const parentTreeNode = this.getParentTreeNode();
    if (parentTreeNode) {
      if (parentTreeNode.hasAttribute("render-collapsed-nodes")) {
        this.renderCollapsedChildren = parentTreeNode.getAttribute("render-collapsed-nodes") === "true";
      }
      this.notifier = Observable.getNotifier(parentTreeNode);
      this.notifier.subscribe(this, "renderCollapsedNodes");
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.notifier) {
      this.notifier.unsubscribe(this, "renderCollapsedNodes");
    }
  }
  static focusItem(el2) {
    el2.setAttribute("tabindex", "0");
    el2.focusable = true;
    el2.focus();
  }
  handleChange(source, propertyName) {
    switch (propertyName) {
      case "renderCollapsedNodes":
        this.renderCollapsedChildren = source.renderCollapsedNodes;
        break;
    }
  }
  childItemLength() {
    const treeChildren = this.childItems.filter((item) => {
      return isTreeItemElement(item);
    });
    return treeChildren ? treeChildren.length : 0;
  }
  collapseOrFocusParent() {
    if (this.expanded) {
      this.setExpanded(false);
    } else if (isHTMLElement(this.parentElement)) {
      const parentTreeItemNode = this.parentElement.closest("[role='treeitem']");
      if (isHTMLElement(parentTreeItemNode)) {
        TreeItem.focusItem(parentTreeItemNode);
      }
    }
  }
  expandOrFocusFirstChild() {
    if (typeof this.expanded !== "boolean") {
      return;
    }
    if (!this.expanded && this.childItemLength() > 0) {
      this.setExpanded(true);
    } else {
      if (this.enabledChildTreeItems.length > 0) {
        TreeItem.focusItem(this.enabledChildTreeItems[0]);
      }
    }
  }
  focusNextNode(delta) {
    const visibleNodes = this.getVisibleNodes();
    if (!visibleNodes) {
      return;
    }
    const currentIndex = visibleNodes.indexOf(this);
    if (currentIndex !== -1) {
      let nextElement = visibleNodes[currentIndex + delta];
      if (nextElement !== void 0) {
        while (nextElement.hasAttribute("disabled")) {
          const offset = delta >= 0 ? 1 : -1;
          nextElement = visibleNodes[currentIndex + delta + offset];
          if (!nextElement) {
            break;
          }
        }
      }
      if (isHTMLElement(nextElement)) {
        TreeItem.focusItem(nextElement);
      }
    }
  }
  getVisibleNodes() {
    return getDisplayedNodes(this.getTreeRoot(), "[role='treeitem']");
  }
  getTreeRoot() {
    const currentNode = this;
    if (!isHTMLElement(currentNode)) {
      return null;
    }
    return currentNode.closest("[role='tree']");
  }
  handleSelected(e) {
    this.selected = !this.selected;
    this.$emit("selected-change", e);
  }
  setExpanded(expanded2) {
    this.expanded = expanded2;
    this.$emit("expanded-change", this);
  }
}
__decorate$1([
  attr$1({ mode: "boolean" })
], TreeItem.prototype, "expanded", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TreeItem.prototype, "selected", void 0);
__decorate$1([
  attr$1({ mode: "boolean" })
], TreeItem.prototype, "disabled", void 0);
__decorate$1([
  observable
], TreeItem.prototype, "focusable", void 0);
__decorate$1([
  observable
], TreeItem.prototype, "childItems", void 0);
__decorate$1([
  observable
], TreeItem.prototype, "items", void 0);
__decorate$1([
  observable
], TreeItem.prototype, "nested", void 0);
__decorate$1([
  observable
], TreeItem.prototype, "renderCollapsedChildren", void 0);
applyMixins(TreeItem, StartEnd);
const TreeViewTemplate = html$1$1`
    <template
        role="tree"
        ${ref("treeView")}
        @keydown="${(x2, c2) => x2.handleKeyDown(c2.event)}"
        @focus="${(x2, c2) => x2.handleFocus(c2.event)}"
        @focusout="${(x2, c2) => x2.handleBlur(c2.event)}"
    >
        <slot ${slotted("slottedTreeItems")}></slot>
    </template>
`;
class TreeView extends FASTElement {
  constructor() {
    super(...arguments);
    this.focusable = true;
    this.handleBlur = (e) => {
      const { relatedTarget, target } = e;
      if (relatedTarget instanceof HTMLElement && target instanceof HTMLElement && this.contains(relatedTarget)) {
        target.removeAttribute("tabindex");
      }
    };
    this.handleFocus = (e) => {
    };
    this.handleKeyDown = (e) => {
      if (!this.treeItems) {
        return true;
      }
      switch (e.keyCode) {
        case keyCodeHome:
          if (this.treeItems && this.treeItems.length) {
            TreeItem.focusItem(this.treeItems[0]);
          }
          break;
        case keyCodeEnd:
          if (this.treeItems && this.treeItems.length) {
            TreeItem.focusItem(this.treeItems[this.treeItems.length - 1]);
          }
          break;
        default:
          return true;
      }
    };
    this.setItems = () => {
      const focusIndex = this.treeItems.findIndex(this.isFocusableElement);
      for (let item = 0; item < this.treeItems.length; item++) {
        if (item === focusIndex && !this.treeItems[item].hasAttribute("disabled")) {
          this.treeItems[item].setAttribute("tabindex", "0");
        }
        this.treeItems[item].addEventListener("selected-change", this.handleItemSelected);
      }
    };
    this.resetItems = () => {
      for (let item = 0; item < this.treeItems.length; item++) {
        this.treeItems[item].removeEventListener("selected-change", this.handleItemSelected);
      }
    };
    this.handleItemSelected = (e) => {
      const newSelection = e.target;
      if (newSelection !== this.currentSelected) {
        if (this.currentSelected) {
          this.currentSelected.removeAttribute("selected");
          this.currentSelected.selected = false;
        }
        this.currentSelected = newSelection;
      }
    };
    this.isFocusableElement = (el2) => {
      return isTreeItemElement(el2) && !this.isDisabledElement(el2);
    };
    this.isDisabledElement = (el2) => {
      return isTreeItemElement(el2) && el2.getAttribute("aria-disabled") === "true";
    };
  }
  slottedTreeItemsChanged(oldValue, newValue) {
    if (this.$fastController.isConnected) {
      this.resetItems();
      this.treeItems = this.getVisibleNodes();
      this.setItems();
      if (this.checkForNestedItems()) {
        this.slottedTreeItems.forEach((node) => {
          if (isTreeItemElement(node)) {
            node.nested = true;
          }
        });
      }
    }
  }
  checkForNestedItems() {
    return this.slottedTreeItems.some((node) => {
      return isTreeItemElement(node) && node.querySelector("[role='treeitem']");
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.treeItems = this.getVisibleNodes();
    DOM.queueUpdate(() => {
      const node = this.treeView.querySelector("[aria-selected='true']");
      if (node) {
        this.currentSelected = node;
      }
    });
  }
  getVisibleNodes() {
    const treeItems = [];
    if (this.slottedTreeItems !== void 0) {
      this.slottedTreeItems.forEach((item) => {
        if (isTreeItemElement(item)) {
          treeItems.push(item);
        }
      });
    }
    return treeItems;
  }
}
__decorate$1([
  attr$1({ attribute: "render-collapsed-nodes" })
], TreeView.prototype, "renderCollapsedNodes", void 0);
__decorate$1([
  observable
], TreeView.prototype, "focusable", void 0);
__decorate$1([
  observable
], TreeView.prototype, "currentSelected", void 0);
__decorate$1([
  observable
], TreeView.prototype, "lastFocused", void 0);
__decorate$1([
  observable
], TreeView.prototype, "nested", void 0);
__decorate$1([
  observable
], TreeView.prototype, "slottedTreeItems", void 0);
const neutralPalette$1 = [
  "#FFFFFF",
  "#FCFCFC",
  "#FAFAFA",
  "#F7F7F7",
  "#F5F5F5",
  "#F2F2F2",
  "#EFEFEF",
  "#EDEDED",
  "#EAEAEA",
  "#E8E8E8",
  "#E5E5E5",
  "#E2E2E2",
  "#E0E0E0",
  "#DDDDDD",
  "#DBDBDB",
  "#D8D8D8",
  "#D6D6D6",
  "#D3D3D3",
  "#D0D0D0",
  "#CECECE",
  "#CBCBCB",
  "#C9C9C9",
  "#C6C6C6",
  "#C3C3C3",
  "#C1C1C1",
  "#BEBEBE",
  "#BCBCBC",
  "#B9B9B9",
  "#B6B6B6",
  "#B4B4B4",
  "#B1B1B1",
  "#AFAFAF",
  "#ACACAC",
  "#A9A9A9",
  "#A7A7A7",
  "#A4A4A4",
  "#A2A2A2",
  "#9F9F9F",
  "#9D9D9D",
  "#9A9A9A",
  "#979797",
  "#959595",
  "#929292",
  "#909090",
  "#8D8D8D",
  "#8A8A8A",
  "#888888",
  "#858585",
  "#838383",
  "#808080",
  "#7D7D7D",
  "#7B7B7B",
  "#787878",
  "#767676",
  "#737373",
  "#717171",
  "#6E6E6E",
  "#6B6B6B",
  "#696969",
  "#666666",
  "#646464",
  "#616161",
  "#5F5F5F",
  "#5C5C5C",
  "#5A5A5A",
  "#575757",
  "#545454",
  "#525252",
  "#4F4F4F",
  "#4D4D4D",
  "#4A4A4A",
  "#484848",
  "#454545",
  "#424242",
  "#404040",
  "#3D3D3D",
  "#3B3B3B",
  "#383838",
  "#363636",
  "#333333",
  "#313131",
  "#2E2E2E",
  "#2B2B2B",
  "#292929",
  "#262626",
  "#242424",
  "#212121",
  "#1E1E1E",
  "#1B1B1B",
  "#181818",
  "#151515",
  "#121212",
  "#101010",
  "#000000"
];
const accentPalette$1 = [
  "#FFFFFF",
  "#FEFBFC",
  "#FEF7FA",
  "#FDF4F7",
  "#FDF0F5",
  "#FCECF2",
  "#FBE8EF",
  "#FBE5ED",
  "#FAE1EA",
  "#FADDE7",
  "#F9D9E5",
  "#F8D6E2",
  "#F8D2E0",
  "#F7CEDD",
  "#F7CADA",
  "#F6C7D8",
  "#F5C3D5",
  "#F5BFD2",
  "#F4BBD0",
  "#F3B8CD",
  "#F3B4CB",
  "#F2B0C8",
  "#F2ACC5",
  "#F1A9C3",
  "#F0A5C0",
  "#F0A1BD",
  "#EF9DBB",
  "#EF9AB8",
  "#EE96B6",
  "#ED92B3",
  "#ED8EB0",
  "#EC8BAE",
  "#EC87AB",
  "#EB83A8",
  "#EA7FA6",
  "#EA7CA3",
  "#E978A1",
  "#E9749E",
  "#E8709B",
  "#E76D99",
  "#E76996",
  "#E66593",
  "#E66191",
  "#E55E8E",
  "#E45A8C",
  "#E45689",
  "#E35286",
  "#E24F84",
  "#E24B81",
  "#E1477E",
  "#E1437C",
  "#E04079",
  "#DF3C77",
  "#DF3874",
  "#DE3471",
  "#DE316F",
  "#DD2D6C",
  "#DC2969",
  "#DC2567",
  "#DB2264",
  "#DB1E62",
  "#DA1A5F",
  "#D4195C",
  "#CD1859",
  "#C71857",
  "#C01754",
  "#BA1651",
  "#B3154E",
  "#AD154B",
  "#A71449",
  "#A01346",
  "#9A1243",
  "#931240",
  "#8D113D",
  "#86103B",
  "#800F38",
  "#7A0F35",
  "#730E32",
  "#6D0D2F",
  "#660C2D",
  "#600B2A",
  "#590B27",
  "#530A24",
  "#4D0921",
  "#46081F",
  "#40081C",
  "#3B071A",
  "#350617",
  "#300615",
  "#2B0513",
  "#260511",
  "#21040E",
  "#1C030C",
  "#000000"
];
const fastDesignSystemDefaults = {
  typeRampMinus2FontSize: "10px",
  typeRampMinus2LineHeight: "16px",
  typeRampMinus1FontSize: "12px",
  typeRampMinus1LineHeight: "16px",
  typeRampBaseFontSize: "14px",
  typeRampBaseLineHeight: "20px",
  typeRampPlus1FontSize: "16px",
  typeRampPlus1LineHeight: "24px",
  typeRampPlus2FontSize: "20px",
  typeRampPlus2LineHeight: "28px",
  typeRampPlus3FontSize: "28px",
  typeRampPlus3LineHeight: "36px",
  typeRampPlus4FontSize: "34px",
  typeRampPlus4LineHeight: "44px",
  typeRampPlus5FontSize: "46px",
  typeRampPlus5LineHeight: "56px",
  typeRampPlus6FontSize: "60px",
  typeRampPlus6LineHeight: "72px",
  accentBaseColor: "#DA1A5F",
  accentPalette: accentPalette$1,
  backgroundColor: "#181818",
  baseHeightMultiplier: 10,
  baseHorizontalSpacingMultiplier: 3,
  cornerRadius: 3,
  density: 0,
  designUnit: 4,
  direction: Direction.ltr,
  disabledOpacity: 0.3,
  focusOutlineWidth: 2,
  neutralPalette: neutralPalette$1,
  outlineWidth: 1,
  accentFillRestDelta: 0,
  accentFillHoverDelta: 4,
  accentFillActiveDelta: -5,
  accentFillFocusDelta: 0,
  accentFillSelectedDelta: 12,
  accentForegroundRestDelta: 0,
  accentForegroundHoverDelta: 6,
  accentForegroundActiveDelta: -4,
  accentForegroundFocusDelta: 0,
  neutralFillRestDelta: 7,
  neutralFillHoverDelta: 10,
  neutralFillActiveDelta: 5,
  neutralFillFocusDelta: 0,
  neutralFillSelectedDelta: 7,
  neutralFillInputRestDelta: 0,
  neutralFillInputHoverDelta: 0,
  neutralFillInputActiveDelta: 0,
  neutralFillInputFocusDelta: 0,
  neutralFillInputSelectedDelta: 0,
  neutralFillStealthRestDelta: 0,
  neutralFillStealthHoverDelta: 5,
  neutralFillStealthActiveDelta: 3,
  neutralFillStealthFocusDelta: 0,
  neutralFillStealthSelectedDelta: 7,
  neutralFillToggleHoverDelta: 8,
  neutralFillToggleActiveDelta: -5,
  neutralFillToggleFocusDelta: 0,
  baseLayerLuminance: -1,
  neutralFillCardDelta: 3,
  neutralForegroundHoverDelta: 0,
  neutralForegroundActiveDelta: 0,
  neutralForegroundFocusDelta: 0,
  neutralDividerRestDelta: 8,
  neutralOutlineRestDelta: 25,
  neutralOutlineHoverDelta: 40,
  neutralOutlineActiveDelta: 16,
  neutralOutlineFocusDelta: 25,
  neutralContrastFillRestDelta: 0,
  neutralContrastFillHoverDelta: -3,
  neutralContrastFillActiveDelta: 7,
  neutralContrastFillFocusDelta: 0
};
function evaluateDesignSystemResolver(arg, designSystem) {
  return typeof arg === "function" ? arg(designSystem) : arg;
}
function getDesignSystemValue(key) {
  return (designSystem) => {
    return designSystem && designSystem[key] !== void 0 ? designSystem[key] : fastDesignSystemDefaults[key];
  };
}
const backgroundColor = getDesignSystemValue("backgroundColor");
const accentBaseColor = getDesignSystemValue("accentBaseColor");
const neutralPalette = getDesignSystemValue("neutralPalette");
const accentPalette = getDesignSystemValue("accentPalette");
const accentFillHoverDelta = getDesignSystemValue("accentFillHoverDelta");
const accentFillActiveDelta = getDesignSystemValue("accentFillActiveDelta");
const accentFillFocusDelta = getDesignSystemValue("accentFillFocusDelta");
const accentFillSelectedDelta = getDesignSystemValue("accentFillSelectedDelta");
const accentForegroundRestDelta = getDesignSystemValue("accentForegroundRestDelta");
const accentForegroundHoverDelta = getDesignSystemValue("accentForegroundHoverDelta");
const accentForegroundActiveDelta = getDesignSystemValue("accentForegroundActiveDelta");
const accentForegroundFocusDelta = getDesignSystemValue("accentForegroundFocusDelta");
const neutralFillRestDelta = getDesignSystemValue("neutralFillRestDelta");
const neutralFillHoverDelta = getDesignSystemValue("neutralFillHoverDelta");
const neutralFillActiveDelta = getDesignSystemValue("neutralFillActiveDelta");
const neutralFillFocusDelta = getDesignSystemValue("neutralFillFocusDelta");
const neutralFillSelectedDelta = getDesignSystemValue("neutralFillSelectedDelta");
const neutralFillInputRestDelta = getDesignSystemValue("neutralFillInputRestDelta");
const neutralFillInputHoverDelta = getDesignSystemValue("neutralFillInputHoverDelta");
const neutralFillInputActiveDelta = getDesignSystemValue("neutralFillInputActiveDelta");
const neutralFillInputFocusDelta = getDesignSystemValue("neutralFillInputFocusDelta");
const neutralFillInputSelectedDelta = getDesignSystemValue("neutralFillInputSelectedDelta");
const neutralFillStealthRestDelta = getDesignSystemValue("neutralFillStealthRestDelta");
const neutralFillStealthHoverDelta = getDesignSystemValue("neutralFillStealthHoverDelta");
const neutralFillStealthActiveDelta = getDesignSystemValue("neutralFillStealthActiveDelta");
const neutralFillStealthFocusDelta = getDesignSystemValue("neutralFillStealthFocusDelta");
const neutralFillStealthSelectedDelta = getDesignSystemValue("neutralFillStealthSelectedDelta");
const neutralFillToggleHoverDelta = getDesignSystemValue("neutralFillToggleHoverDelta");
const neutralFillToggleActiveDelta = getDesignSystemValue("neutralFillToggleActiveDelta");
const neutralFillToggleFocusDelta = getDesignSystemValue("neutralFillToggleFocusDelta");
const baseLayerLuminance = getDesignSystemValue("baseLayerLuminance");
const neutralFillCardDelta = getDesignSystemValue("neutralFillCardDelta");
const neutralForegroundHoverDelta = getDesignSystemValue("neutralForegroundHoverDelta");
const neutralForegroundActiveDelta = getDesignSystemValue("neutralForegroundActiveDelta");
const neutralForegroundFocusDelta = getDesignSystemValue("neutralForegroundFocusDelta");
const neutralDividerRestDelta = getDesignSystemValue("neutralDividerRestDelta");
const neutralOutlineRestDelta = getDesignSystemValue("neutralOutlineRestDelta");
const neutralOutlineHoverDelta = getDesignSystemValue("neutralOutlineHoverDelta");
const neutralOutlineActiveDelta = getDesignSystemValue("neutralOutlineActiveDelta");
const neutralOutlineFocusDelta = getDesignSystemValue("neutralOutlineFocusDelta");
const neutralContrastFillHoverDelta = getDesignSystemValue("neutralContrastFillHoverDelta");
const neutralContrastFillActiveDelta = getDesignSystemValue("neutralContrastFillActiveDelta");
const neutralContrastFillFocusDelta = getDesignSystemValue("neutralContrastFillFocusDelta");
function clamp$2(i2, min, max) {
  if (isNaN(i2) || i2 <= min) {
    return min;
  } else if (i2 >= max) {
    return max;
  }
  return i2;
}
function normalize(i2, min, max) {
  if (isNaN(i2) || i2 <= min) {
    return 0;
  } else if (i2 >= max) {
    return 1;
  }
  return i2 / (max - min);
}
function denormalize(i2, min, max) {
  if (isNaN(i2)) {
    return min;
  }
  return min + i2 * (max - min);
}
function getHexStringForByte(i2) {
  const s = Math.round(clamp$2(i2, 0, 255)).toString(16);
  if (s.length === 1) {
    return "0" + s;
  }
  return s;
}
function roundToPrecisionSmall(i2, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(i2 * factor) / factor;
}
class ColorRGBA64 {
  constructor(red, green, blue, alpha) {
    this.r = red;
    this.g = green;
    this.b = blue;
    this.a = typeof alpha === "number" && !isNaN(alpha) ? alpha : 1;
  }
  static fromObject(data) {
    return data && !isNaN(data.r) && !isNaN(data.g) && !isNaN(data.b) ? new ColorRGBA64(data.r, data.g, data.b, data.a) : null;
  }
  equalValue(rhs) {
    return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
  }
  toStringHexRGB() {
    return "#" + [this.r, this.g, this.b].map(this.formatHexValue).join("");
  }
  toStringHexRGBA() {
    return this.toStringHexRGB() + this.formatHexValue(this.a);
  }
  toStringHexARGB() {
    return "#" + [this.a, this.r, this.g, this.b].map(this.formatHexValue).join("");
  }
  toStringWebRGB() {
    return `rgb(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))})`;
  }
  toStringWebRGBA() {
    return `rgba(${Math.round(denormalize(this.r, 0, 255))},${Math.round(denormalize(this.g, 0, 255))},${Math.round(denormalize(this.b, 0, 255))},${clamp$2(this.a, 0, 1)})`;
  }
  roundToPrecision(precision) {
    return new ColorRGBA64(roundToPrecisionSmall(this.r, precision), roundToPrecisionSmall(this.g, precision), roundToPrecisionSmall(this.b, precision), roundToPrecisionSmall(this.a, precision));
  }
  clamp() {
    return new ColorRGBA64(clamp$2(this.r, 0, 1), clamp$2(this.g, 0, 1), clamp$2(this.b, 0, 1), clamp$2(this.a, 0, 1));
  }
  toObject() {
    return { r: this.r, g: this.g, b: this.b, a: this.a };
  }
  formatHexValue(value2) {
    return getHexStringForByte(denormalize(value2, 0, 255));
  }
}
function rgbToLinearLuminance(rgb) {
  return rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722;
}
function rgbToRelativeLuminance(rgb) {
  function luminanceHelper(i2) {
    if (i2 <= 0.03928) {
      return i2 / 12.92;
    }
    return Math.pow((i2 + 0.055) / 1.055, 2.4);
  }
  return rgbToLinearLuminance(new ColorRGBA64(luminanceHelper(rgb.r), luminanceHelper(rgb.g), luminanceHelper(rgb.b), 1));
}
const calculateContrastRatio = (a, b) => (a + 0.05) / (b + 0.05);
function contrastRatio(a, b) {
  const luminanceA = rgbToRelativeLuminance(a);
  const luminanceB = rgbToRelativeLuminance(b);
  return luminanceA > luminanceB ? calculateContrastRatio(luminanceA, luminanceB) : calculateContrastRatio(luminanceB, luminanceA);
}
const webRGBRegex = /^rgb\(\s*((?:(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*,\s*){2}(?:25[0-5]|2[0-4]\d|1\d\d|\d{1,2})\s*)\)$/i;
const hexRGBRegex = /^#((?:[0-9a-f]{6}|[0-9a-f]{3}))$/i;
function isColorStringHexRGB(raw) {
  return hexRGBRegex.test(raw);
}
function isColorStringWebRGB(raw) {
  return webRGBRegex.test(raw);
}
function parseColorHexRGB(raw) {
  const result2 = hexRGBRegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  let digits = result2[1];
  if (digits.length === 3) {
    const r = digits.charAt(0);
    const g = digits.charAt(1);
    const b = digits.charAt(2);
    digits = r.concat(r, g, g, b, b);
  }
  const rawInt = parseInt(digits, 16);
  if (isNaN(rawInt)) {
    return null;
  }
  return new ColorRGBA64(normalize((rawInt & 16711680) >>> 16, 0, 255), normalize((rawInt & 65280) >>> 8, 0, 255), normalize(rawInt & 255, 0, 255), 1);
}
function parseColorWebRGB(raw) {
  const result2 = webRGBRegex.exec(raw);
  if (result2 === null) {
    return null;
  }
  const split = result2[1].split(",");
  return new ColorRGBA64(normalize(Number(split[0]), 0, 255), normalize(Number(split[1]), 0, 255), normalize(Number(split[2]), 0, 255), 1);
}
var SwatchFamilyType;
(function(SwatchFamilyType2) {
  SwatchFamilyType2["rest"] = "rest";
  SwatchFamilyType2["hover"] = "hover";
  SwatchFamilyType2["active"] = "active";
  SwatchFamilyType2["focus"] = "focus";
  SwatchFamilyType2["selected"] = "selected";
})(SwatchFamilyType || (SwatchFamilyType = {}));
function colorRecipeFactory(recipe) {
  const memoizedRecipe = memoize(recipe);
  function curryRecipe(arg) {
    if (typeof arg === "function" || typeof arg === "string") {
      return (designSystem) => {
        return memoizedRecipe(Object.assign({}, designSystem, {
          backgroundColor: typeof arg === "function" ? arg(designSystem) : arg
        }));
      };
    } else {
      return memoizedRecipe(arg);
    }
  }
  return curryRecipe;
}
function swatchFamilyToSwatchRecipeFactory(type2, callback) {
  const memoizedRecipe = memoize(callback);
  return (arg) => {
    if (typeof arg === "function" || typeof arg === "string") {
      return (designSystem) => {
        return memoizedRecipe(Object.assign({}, designSystem, {
          backgroundColor: typeof arg === "function" ? arg(designSystem) : arg
        }))[type2];
      };
    } else {
      return memoizedRecipe(arg)[type2];
    }
  };
}
const parseColorString = memoize((color2) => {
  let parsed = parseColorHexRGB(color2);
  if (parsed !== null) {
    return parsed;
  }
  parsed = parseColorWebRGB(color2);
  if (parsed !== null) {
    return parsed;
  }
  throw new Error(`${color2} cannot be converted to a ColorRGBA64. Color strings must be one of the following formats: "#RGB", "#RRGGBB", or "rgb(r, g, b)"`);
});
function isValidColor(color2) {
  return isColorStringHexRGB(color2) || isColorStringWebRGB(color2);
}
function colorMatches(a, b) {
  return parseColorString(a).equalValue(parseColorString(b));
}
const contrast = memoize((a, b) => {
  return contrastRatio(parseColorString(a), parseColorString(b));
}, (a, b) => a + b);
function luminance(color2) {
  return rgbToRelativeLuminance(parseColorString(color2));
}
function designSystemResolverMax(...args2) {
  return (designSystem) => Math.max.apply(null, args2.map((fn2) => fn2(designSystem)));
}
const clamp$1 = (value2, min, max) => Math.min(Math.max(value2, min), max);
var PaletteType;
(function(PaletteType2) {
  PaletteType2["neutral"] = "neutral";
  PaletteType2["accent"] = "accent";
})(PaletteType || (PaletteType = {}));
function findSwatchIndex(paletteResolver, swatch) {
  return (designSystem) => {
    if (!isValidColor(swatch)) {
      return -1;
    }
    const colorPalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
    const index2 = colorPalette.indexOf(swatch);
    return index2 !== -1 ? index2 : colorPalette.findIndex((paletteSwatch) => {
      return isValidColor(paletteSwatch) && colorMatches(swatch, paletteSwatch);
    });
  };
}
function findClosestSwatchIndex(paletteResolver, swatch) {
  return (designSystem) => {
    const resolvedPalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
    const resolvedSwatch = evaluateDesignSystemResolver(swatch, designSystem);
    const index2 = findSwatchIndex(resolvedPalette, resolvedSwatch)(designSystem);
    let swatchLuminance;
    if (index2 !== -1) {
      return index2;
    }
    try {
      swatchLuminance = luminance(resolvedSwatch);
    } catch (e) {
      swatchLuminance = -1;
    }
    if (swatchLuminance === -1) {
      return 0;
    }
    return resolvedPalette.map((mappedSwatch, mappedIndex) => {
      return {
        luminance: luminance(mappedSwatch),
        index: mappedIndex
      };
    }).reduce((previousValue, currentValue) => {
      return Math.abs(currentValue.luminance - swatchLuminance) < Math.abs(previousValue.luminance - swatchLuminance) ? currentValue : previousValue;
    }).index;
  };
}
function isDarkMode(designSystem) {
  return luminance(backgroundColor(designSystem)) <= (-0.1 + Math.sqrt(0.21)) / 2;
}
function getSwatch(index2, colorPalette) {
  if (typeof index2 === "function") {
    return (designSystem) => {
      return colorPalette(designSystem)[clamp$1(index2(designSystem), 0, colorPalette(designSystem).length - 1)];
    };
  } else {
    return colorPalette[clamp$1(index2, 0, colorPalette.length - 1)];
  }
}
function swatchByMode(paletteResolver) {
  return (valueA, valueB) => {
    return (designSystem) => {
      return getSwatch(isDarkMode(designSystem) ? evaluateDesignSystemResolver(valueB, designSystem) : evaluateDesignSystemResolver(valueA, designSystem), paletteResolver(designSystem));
    };
  };
}
function binarySearch(valuesToSearch, searchCondition, startIndex = 0, endIndex = valuesToSearch.length - 1) {
  if (endIndex === startIndex) {
    return valuesToSearch[startIndex];
  }
  const middleIndex = Math.floor((endIndex - startIndex) / 2) + startIndex;
  if (searchCondition(valuesToSearch[middleIndex])) {
    return binarySearch(valuesToSearch, searchCondition, startIndex, middleIndex);
  } else {
    return binarySearch(valuesToSearch, searchCondition, middleIndex + 1, endIndex);
  }
}
function swatchByContrast(referenceColor) {
  return (paletteResolver) => {
    return (indexResolver) => {
      return (directionResolver) => {
        return (contrastCondition) => {
          return (designSystem) => {
            const color2 = evaluateDesignSystemResolver(referenceColor, designSystem);
            const sourcePalette = evaluateDesignSystemResolver(paletteResolver, designSystem);
            const length = sourcePalette.length;
            const initialSearchIndex = clamp$1(indexResolver(color2, sourcePalette, designSystem), 0, length - 1);
            const direction = directionResolver(initialSearchIndex, sourcePalette, designSystem);
            function contrastSearchCondition(valueToCheckAgainst) {
              return contrastCondition(contrast(color2, valueToCheckAgainst));
            }
            const constrainedSourcePalette = [].concat(sourcePalette);
            const endSearchIndex = length - 1;
            let startSearchIndex = initialSearchIndex;
            if (direction === -1) {
              constrainedSourcePalette.reverse();
              startSearchIndex = endSearchIndex - startSearchIndex;
            }
            return binarySearch(constrainedSourcePalette, contrastSearchCondition, startSearchIndex, endSearchIndex);
          };
        };
      };
    };
  };
}
function referenceColorInitialIndexResolver(referenceColor, sourcePalette, designSystem) {
  return findClosestSwatchIndex(sourcePalette, referenceColor)(designSystem);
}
function findClosestBackgroundIndex(designSystem) {
  return findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);
}
function minContrastTargetFactory(targetContrast) {
  return (instanceContrast) => instanceContrast >= targetContrast;
}
function indexToSwatchFamily(accessibleIndex, palette, direction, restDelta, hoverDelta, activeDelta, focusDelta) {
  const accessibleIndex2 = accessibleIndex + direction * Math.abs(restDelta - hoverDelta);
  const indexOneIsRestState = direction === 1 ? restDelta < hoverDelta : direction * restDelta > direction * hoverDelta;
  const restIndex = indexOneIsRestState ? accessibleIndex : accessibleIndex2;
  const hoverIndex = indexOneIsRestState ? accessibleIndex2 : accessibleIndex;
  const activeIndex = restIndex + direction * activeDelta;
  const focusIndex = restIndex + direction * focusDelta;
  return {
    rest: getSwatch(restIndex, palette),
    hover: getSwatch(hoverIndex, palette),
    active: getSwatch(activeIndex, palette),
    focus: getSwatch(focusIndex, palette)
  };
}
function accessibleAlgorithm(palette, minContrast, restDelta, hoverDelta, activeDelta, focusDelta) {
  return (designSystem) => {
    const resolvedPalette = evaluateDesignSystemResolver(palette, designSystem);
    const direction = isDarkMode(designSystem) ? -1 : 1;
    const accessibleSwatch = swatchByContrast(backgroundColor)(resolvedPalette)(referenceColorInitialIndexResolver)(() => direction)(minContrastTargetFactory(evaluateDesignSystemResolver(minContrast, designSystem)))(designSystem);
    const accessibleIndex = findSwatchIndex(palette, accessibleSwatch)(designSystem);
    const resolvedRest = evaluateDesignSystemResolver(restDelta, designSystem);
    const resolvedHover = evaluateDesignSystemResolver(hoverDelta, designSystem);
    const resolvedActive = evaluateDesignSystemResolver(activeDelta, designSystem);
    const resolvedFocus = evaluateDesignSystemResolver(focusDelta, designSystem);
    return indexToSwatchFamily(accessibleIndex, resolvedPalette, direction, resolvedRest, resolvedHover, resolvedActive, resolvedFocus);
  };
}
const neutralForeground = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 14, 0, neutralForegroundHoverDelta, neutralForegroundActiveDelta, neutralForegroundFocusDelta));
const neutralForegroundRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralForeground);
const white = "#FFFFFF";
const black = "#000000";
const neutralFillToggle = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 4.5, 0, neutralFillToggleHoverDelta, neutralFillToggleActiveDelta, neutralFillToggleFocusDelta));
const neutralFillToggleRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralFillToggle);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralFillToggle);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralFillToggle);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralFillToggle);
const neutralForegroundToggleAlgorithm = (backgroundColor2, targetContrast) => {
  return contrast(white, backgroundColor2) >= targetContrast ? white : black;
};
function neutralForegroundToggleFactory(targetContrast) {
  function neutralForegroundToggleInternal(arg) {
    return typeof arg === "function" || typeof arg === "string" ? (designSystem) => {
      return neutralForegroundToggleAlgorithm(typeof arg === "function" ? arg(designSystem) : arg, targetContrast);
    } : neutralForegroundToggleAlgorithm(neutralFillToggleRest(arg), targetContrast);
  }
  return neutralForegroundToggleInternal;
}
const neutralForegroundToggle = neutralForegroundToggleFactory(4.5);
const neutralForegroundToggleLarge = neutralForegroundToggleFactory(3);
const accentForegroundCutAlgorithm = (backgroundColor2, targetContrast) => {
  return contrast(white, backgroundColor2) >= targetContrast ? white : black;
};
function accentForegroundCutFactory(targetContrast) {
  function accentForegroundCutInternal(arg) {
    return typeof arg === "function" || typeof arg === "string" ? (designSystem) => {
      return accentForegroundCutAlgorithm(typeof arg === "function" ? arg(designSystem) : arg, targetContrast);
    } : accentForegroundCutAlgorithm(accentBaseColor(arg), targetContrast);
  }
  return accentForegroundCutInternal;
}
const accentForegroundCut = accentForegroundCutFactory(4.5);
function neutralForegroundHintAlgorithm(targetContrast) {
  return accessibleAlgorithm(neutralPalette, targetContrast, 0, 0, 0, 0);
}
const neutralForegroundHint = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, colorRecipeFactory(neutralForegroundHintAlgorithm(4.5)));
const neutralForegroundHintLarge = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, colorRecipeFactory(neutralForegroundHintAlgorithm(3)));
function accentForegroundAlgorithm(contrastTarget) {
  return (designSystem) => {
    const palette = accentPalette(designSystem);
    const accent = accentBaseColor(designSystem);
    const accentIndex = findClosestSwatchIndex(accentPalette, accent)(designSystem);
    const stateDeltas = {
      rest: accentForegroundRestDelta(designSystem),
      hover: accentForegroundHoverDelta(designSystem),
      active: accentForegroundActiveDelta(designSystem),
      focus: accentForegroundFocusDelta(designSystem)
    };
    const direction = isDarkMode(designSystem) ? -1 : 1;
    const startIndex = accentIndex + (direction === 1 ? Math.min(stateDeltas.rest, stateDeltas.hover) : Math.max(direction * stateDeltas.rest, direction * stateDeltas.hover));
    const accessibleSwatch = swatchByContrast(backgroundColor)(accentPalette)(() => startIndex)(() => direction)((swatchContrast) => swatchContrast >= contrastTarget)(designSystem);
    const accessibleIndex1 = findSwatchIndex(accentPalette, accessibleSwatch)(designSystem);
    const accessibleIndex2 = accessibleIndex1 + direction * Math.abs(stateDeltas.rest - stateDeltas.hover);
    const indexOneIsRestState = direction === 1 ? stateDeltas.rest < stateDeltas.hover : direction * stateDeltas.rest > direction * stateDeltas.hover;
    const restIndex = indexOneIsRestState ? accessibleIndex1 : accessibleIndex2;
    const hoverIndex = indexOneIsRestState ? accessibleIndex2 : accessibleIndex1;
    const activeIndex = restIndex + direction * stateDeltas.active;
    const focusIndex = restIndex + direction * stateDeltas.focus;
    return {
      rest: getSwatch(restIndex, palette),
      hover: getSwatch(hoverIndex, palette),
      active: getSwatch(activeIndex, palette),
      focus: getSwatch(focusIndex, palette)
    };
  };
}
const accentForeground = colorRecipeFactory(accentForegroundAlgorithm(4.5));
const accentForegroundLarge = colorRecipeFactory(accentForegroundAlgorithm(3));
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentForeground);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentForegroundLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentForegroundLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentForegroundLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentForegroundLarge);
const neutralFillThreshold$1 = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta);
function neutralFillAlgorithm(deltaResolver) {
  return (designSystem) => {
    const backgroundIndex = findClosestBackgroundIndex(designSystem);
    const swapThreshold = neutralFillThreshold$1(designSystem);
    const direction = backgroundIndex >= swapThreshold ? -1 : 1;
    return getSwatch(backgroundIndex + direction * deltaResolver(designSystem), neutralPalette(designSystem));
  };
}
const neutralFillRest = colorRecipeFactory(neutralFillAlgorithm(neutralFillRestDelta));
const neutralFillHover = colorRecipeFactory(neutralFillAlgorithm(neutralFillHoverDelta));
const neutralFillActive = colorRecipeFactory(neutralFillAlgorithm(neutralFillActiveDelta));
const neutralFillFocus = colorRecipeFactory(neutralFillAlgorithm(neutralFillFocusDelta));
const neutralFillSelected = colorRecipeFactory(neutralFillAlgorithm(neutralFillSelectedDelta));
const neutralFill = colorRecipeFactory((designSystem) => {
  return {
    rest: neutralFillRest(designSystem),
    hover: neutralFillHover(designSystem),
    active: neutralFillActive(designSystem),
    focus: neutralFillFocus(designSystem),
    selected: neutralFillSelected(designSystem)
  };
});
const neutralFillStealthSwapThreshold = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta, neutralFillFocusDelta, neutralFillStealthRestDelta, neutralFillStealthHoverDelta, neutralFillStealthActiveDelta, neutralFillStealthFocusDelta);
function neutralFillStealthAlgorithm(deltaResolver) {
  return (designSystem) => {
    const backgroundIndex = findClosestBackgroundIndex(designSystem);
    const swapThreshold = neutralFillStealthSwapThreshold(designSystem);
    const direction = backgroundIndex >= swapThreshold ? -1 : 1;
    return getSwatch(backgroundIndex + direction * deltaResolver(designSystem), neutralPalette(designSystem));
  };
}
const neutralFillStealthRest = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthRestDelta));
const neutralFillStealthHover = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthHoverDelta));
const neutralFillStealthActive = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthActiveDelta));
const neutralFillStealthFocus = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthFocusDelta));
const neutralFillStealthSelected = colorRecipeFactory(neutralFillStealthAlgorithm(neutralFillStealthSelectedDelta));
const neutralFillStealth = colorRecipeFactory((designSystem) => {
  return {
    rest: neutralFillStealthRest(designSystem),
    hover: neutralFillStealthHover(designSystem),
    active: neutralFillStealthActive(designSystem),
    focus: neutralFillStealthFocus(designSystem),
    selected: neutralFillStealthSelected(designSystem)
  };
});
function neutralFillInputAlgorithm(indexResolver) {
  return (designSystem) => {
    const direction = isDarkMode(designSystem) ? -1 : 1;
    return getSwatch(findClosestBackgroundIndex(designSystem) - indexResolver(designSystem) * direction, neutralPalette(designSystem));
  };
}
const neutralFillInputRest = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputRestDelta));
const neutralFillInputHover = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputHoverDelta));
const neutralFillInputActive = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputActiveDelta));
const neutralFillInputFocus = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputFocusDelta));
const neutralFillInputSelected = colorRecipeFactory(neutralFillInputAlgorithm(neutralFillInputSelectedDelta));
const neutralFillInput = colorRecipeFactory((designSystem) => {
  return {
    rest: neutralFillInputRest(designSystem),
    hover: neutralFillInputHover(designSystem),
    active: neutralFillInputActive(designSystem),
    focus: neutralFillInputFocus(designSystem),
    selected: neutralFillInputSelected(designSystem)
  };
});
const neutralFillThreshold = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta);
function accentFillAlgorithm(contrastTarget) {
  return (designSystem) => {
    const palette = accentPalette(designSystem);
    const paletteLength = palette.length;
    const accent = accentBaseColor(designSystem);
    const textColor = accentForegroundCut(Object.assign({}, designSystem, {
      backgroundColor: accent
    }));
    const hoverDelta = accentFillHoverDelta(designSystem);
    const backgroundIndex = findClosestBackgroundIndex(designSystem);
    const swapThreshold = neutralFillThreshold(designSystem);
    const direction = backgroundIndex >= swapThreshold ? -1 : 1;
    const maxIndex = paletteLength - 1;
    const accentIndex = findClosestSwatchIndex(accentPalette, accent)(designSystem);
    let accessibleOffset = 0;
    while (accessibleOffset < direction * hoverDelta && inRange(accentIndex + accessibleOffset + direction, 0, paletteLength) && contrast(palette[accentIndex + accessibleOffset + direction], textColor) >= contrastTarget && inRange(accentIndex + accessibleOffset + direction + direction, 0, maxIndex)) {
      accessibleOffset += direction;
    }
    const hoverIndex = accentIndex + accessibleOffset;
    const restIndex = hoverIndex + direction * -1 * hoverDelta;
    const activeIndex = restIndex + direction * accentFillActiveDelta(designSystem);
    const focusIndex = restIndex + direction * accentFillFocusDelta(designSystem);
    return {
      rest: getSwatch(restIndex, palette),
      hover: getSwatch(hoverIndex, palette),
      active: getSwatch(activeIndex, palette),
      focus: getSwatch(focusIndex, palette),
      selected: getSwatch(restIndex + (isDarkMode(designSystem) ? accentFillSelectedDelta(designSystem) * -1 : accentFillSelectedDelta(designSystem)), palette)
    };
  };
}
const accentFill = colorRecipeFactory(accentFillAlgorithm(4.5));
const accentFillLarge = colorRecipeFactory(accentFillAlgorithm(3));
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, accentFillLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, accentFillLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, accentFillLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, accentFillLarge);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.selected, accentFillLarge);
const neutralContrastFill = colorRecipeFactory(accessibleAlgorithm(neutralPalette, 14, 0, neutralContrastFillHoverDelta, neutralContrastFillActiveDelta, neutralContrastFillFocusDelta));
const neutralContrastFillRest = swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralContrastFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralContrastFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralContrastFill);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralContrastFill);
const neutralCardFillAlgorithm = (designSystem) => {
  const offset = neutralFillCardDelta(designSystem);
  const index2 = findClosestSwatchIndex(neutralPalette, backgroundColor(designSystem))(designSystem);
  return getSwatch(index2 - (index2 < offset ? offset * -1 : offset), neutralPalette(designSystem));
};
function neutralFillCard(arg) {
  if (typeof arg === "function") {
    return (designSystem) => {
      return neutralCardFillAlgorithm(Object.assign({}, designSystem, { backgroundColor: arg(designSystem) }));
    };
  } else {
    return neutralCardFillAlgorithm(arg);
  }
}
const neutralOutlineAlgorithm = (designSystem) => {
  const palette = neutralPalette(designSystem);
  const backgroundIndex = findClosestBackgroundIndex(designSystem);
  const direction = isDarkMode(designSystem) ? -1 : 1;
  const restDelta = neutralOutlineRestDelta(designSystem);
  const restIndex = backgroundIndex + direction * restDelta;
  const hoverDelta = neutralOutlineHoverDelta(designSystem);
  const hoverIndex = restIndex + direction * (hoverDelta - restDelta);
  const activeDelta = neutralOutlineActiveDelta(designSystem);
  const activeIndex = restIndex + direction * (activeDelta - restDelta);
  const focusDelta = neutralOutlineFocusDelta(designSystem);
  const focusIndex = restIndex + direction * (focusDelta - restDelta);
  return {
    rest: getSwatch(restIndex, palette),
    hover: getSwatch(hoverIndex, palette),
    active: getSwatch(activeIndex, palette),
    focus: getSwatch(focusIndex, palette)
  };
};
const neutralOutline = colorRecipeFactory(neutralOutlineAlgorithm);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.rest, neutralOutline);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.hover, neutralOutline);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.active, neutralOutline);
swatchFamilyToSwatchRecipeFactory(SwatchFamilyType.focus, neutralOutline);
const neutralDividerAlgorithm = (designSystem) => {
  const palette = neutralPalette(designSystem);
  const backgroundIndex = findClosestBackgroundIndex(designSystem);
  const delta = neutralDividerRestDelta(designSystem);
  const direction = isDarkMode(designSystem) ? -1 : 1;
  const index2 = backgroundIndex + direction * delta;
  return getSwatch(index2, palette);
};
const neutralDividerRest = colorRecipeFactory(neutralDividerAlgorithm);
function performOperation(operation) {
  return (...args2) => {
    return (designSystem) => {
      const firstArg = args2[0];
      let value2 = typeof firstArg === "function" ? firstArg(designSystem) : firstArg;
      for (let i2 = 1; i2 < args2.length; i2++) {
        const currentValue = args2[i2];
        value2 = operation(value2, typeof currentValue === "function" ? currentValue(designSystem) : currentValue);
      }
      return value2;
    };
  };
}
const _add = performOperation((a, b) => a + b);
const _subtract = performOperation((a, b) => a - b);
const _multiply = performOperation((a, b) => a * b);
function add(...args2) {
  return _add.apply(this, args2);
}
function subtract(...args2) {
  return _subtract.apply(this, args2);
}
function multiply(...args2) {
  return _multiply.apply(this, args2);
}
var StandardLuminance;
(function(StandardLuminance2) {
  StandardLuminance2[StandardLuminance2["LightMode"] = 1] = "LightMode";
  StandardLuminance2[StandardLuminance2["DarkMode"] = 0.23] = "DarkMode";
})(StandardLuminance || (StandardLuminance = {}));
function luminanceOrBackgroundColor(luminanceRecipe, backgroundRecipe) {
  return (designSystem) => {
    return baseLayerLuminance(designSystem) === -1 ? backgroundRecipe(designSystem) : luminanceRecipe(designSystem);
  };
}
const baseLayerLuminanceSwatch = (designSystem) => {
  const luminance2 = baseLayerLuminance(designSystem);
  return new ColorRGBA64(luminance2, luminance2, luminance2, 1).toStringHexRGB();
};
const baseLayerLuminanceIndex = findClosestSwatchIndex(neutralPalette, baseLayerLuminanceSwatch);
const neutralLayerCardIndex = (designSystem) => clamp$2(subtract(baseLayerLuminanceIndex, neutralFillCardDelta)(designSystem), 0, neutralPalette(designSystem).length - 1);
const lightNeutralLayerL2 = designSystemResolverMax(neutralFillRestDelta, neutralFillHoverDelta, neutralFillActiveDelta);
const neutralLayerL2Index = designSystemResolverMax(add(baseLayerLuminanceIndex, neutralFillCardDelta), lightNeutralLayerL2);
const darkNeutralLayerL4 = (designSystem) => {
  const darkLum = 0.14;
  const darkColor = new ColorRGBA64(darkLum, darkLum, darkLum, 1);
  const darkRefIndex = findClosestSwatchIndex(neutralPalette, darkColor.toStringHexRGB())(designSystem);
  return darkRefIndex;
};
const neutralLayerFloating = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(subtract(neutralLayerCardIndex, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 5)))));
const neutralLayerCard = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(neutralLayerCardIndex, neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 4)))));
const neutralLayerCardContainer = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerCardIndex, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(neutralFillCardDelta, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 3)))));
const neutralLayerL1 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(baseLayerLuminanceIndex, neutralPalette), swatchByMode(neutralPalette)(0, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 3)))));
const neutralLayerL1Alt = neutralLayerCardContainer;
const neutralLayerL2 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(neutralLayerL2Index, neutralPalette), swatchByMode(neutralPalette)(lightNeutralLayerL2, subtract(darkNeutralLayerL4, multiply(neutralFillCardDelta, 2)))));
const neutralLayerL3 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerL2Index, neutralFillCardDelta), neutralPalette), swatchByMode(neutralPalette)(add(lightNeutralLayerL2, neutralFillCardDelta), subtract(darkNeutralLayerL4, neutralFillCardDelta))));
const neutralLayerL4 = colorRecipeFactory(luminanceOrBackgroundColor(getSwatch(add(neutralLayerL2Index, multiply(neutralFillCardDelta, 2)), neutralPalette), swatchByMode(neutralPalette)(add(lightNeutralLayerL2, multiply(neutralFillCardDelta, 2)), darkNeutralLayerL4)));
const targetRatio = 3.5;
function neutralFocusIndexResolver(referenceColor, palette, designSystem) {
  return findClosestSwatchIndex(neutralPalette, referenceColor)(designSystem);
}
function neutralFocusDirectionResolver(index2, palette, designSystem) {
  return isDarkMode(designSystem) ? -1 : 1;
}
function neutralFocusContrastCondition(contrastRatio2) {
  return contrastRatio2 > targetRatio;
}
const neutralFocusAlgorithm = swatchByContrast(backgroundColor)(neutralPalette)(neutralFocusIndexResolver)(neutralFocusDirectionResolver)(neutralFocusContrastCondition);
const neutralFocus = colorRecipeFactory(neutralFocusAlgorithm);
function neutralFocusInnerAccentIndexResolver(accentFillColor) {
  return (referenceColor, sourcePalette, designSystem) => {
    return sourcePalette.indexOf(accentFillColor(designSystem));
  };
}
function neutralFocusInnerAccentDirectionResolver(referenceIndex, palette, designSystem) {
  return isDarkMode(designSystem) ? 1 : -1;
}
function neutralFocusInnerAccent(accentFillColor) {
  return swatchByContrast(neutralFocus)(accentPalette)(neutralFocusInnerAccentIndexResolver(accentFillColor))(neutralFocusInnerAccentDirectionResolver)(neutralFocusContrastCondition);
}
const DesignSystemProviderStyles = css$4`
    ${display("block")};
`;
const color = new CSSCustomPropertyBehavior("neutral-foreground-rest", neutralForegroundRest, (el2) => el2);
const backgroundStyles = css$4`
    :host {
        background-color: var(--background-color);
        color: ${color.var};
    }
`.withBehaviors(color, forcedColorsStylesheetBehavior(css$4`
            :host {
                background-color: ${SystemColors.ButtonFace};
                box-shadow: 0 0 0 1px ${SystemColors.CanvasText};
                color: ${SystemColors.ButtonText};
            }
        `));
let FASTDesignSystemProvider = class FASTDesignSystemProvider2 extends DesignSystemProvider {
  constructor() {
    super(...arguments);
    this.noPaint = false;
  }
  noPaintChanged() {
    if (!this.noPaint && this.backgroundColor !== void 0) {
      this.$fastController.addStyles(backgroundStyles);
    } else {
      this.$fastController.removeStyles(backgroundStyles);
    }
  }
  backgroundColorChanged() {
    this.noPaintChanged();
  }
};
__decorate$1([
  attr$1({ attribute: "no-paint", mode: "boolean" })
], FASTDesignSystemProvider.prototype, "noPaint", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "background-color",
    default: fastDesignSystemDefaults.backgroundColor
  })
], FASTDesignSystemProvider.prototype, "backgroundColor", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-base-color",
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentBaseColor
  })
], FASTDesignSystemProvider.prototype, "accentBaseColor", void 0);
__decorate$1([
  designSystemProperty({
    attribute: false,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralPalette
  })
], FASTDesignSystemProvider.prototype, "neutralPalette", void 0);
__decorate$1([
  designSystemProperty({
    attribute: false,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentPalette
  })
], FASTDesignSystemProvider.prototype, "accentPalette", void 0);
__decorate$1([
  designSystemProperty({
    default: fastDesignSystemDefaults.density,
    converter: nullableNumberConverter
  })
], FASTDesignSystemProvider.prototype, "density", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "design-unit",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.designUnit
  })
], FASTDesignSystemProvider.prototype, "designUnit", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "direction",
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.direction
  })
], FASTDesignSystemProvider.prototype, "direction", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "base-height-multiplier",
    default: fastDesignSystemDefaults.baseHeightMultiplier,
    converter: nullableNumberConverter
  })
], FASTDesignSystemProvider.prototype, "baseHeightMultiplier", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "base-horizontal-spacing-multiplier",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.baseHorizontalSpacingMultiplier
  })
], FASTDesignSystemProvider.prototype, "baseHorizontalSpacingMultiplier", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "corner-radius",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.cornerRadius
  })
], FASTDesignSystemProvider.prototype, "cornerRadius", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "outline-width",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.outlineWidth
  })
], FASTDesignSystemProvider.prototype, "outlineWidth", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "focus-outline-width",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.focusOutlineWidth
  })
], FASTDesignSystemProvider.prototype, "focusOutlineWidth", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "disabled-opacity",
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.disabledOpacity
  })
], FASTDesignSystemProvider.prototype, "disabledOpacity", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-minus-2-font-size",
    default: fastDesignSystemDefaults.typeRampMinus2FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampMinus2FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-minus-2-line-height",
    default: fastDesignSystemDefaults.typeRampMinus2LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampMinus2LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-minus-1-font-size",
    default: fastDesignSystemDefaults.typeRampMinus1FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampMinus1FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-minus-1-line-height",
    default: fastDesignSystemDefaults.typeRampMinus1LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampMinus1LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-base-font-size",
    default: fastDesignSystemDefaults.typeRampBaseFontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampBaseFontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-base-line-height",
    default: fastDesignSystemDefaults.typeRampBaseLineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampBaseLineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-1-font-size",
    default: fastDesignSystemDefaults.typeRampPlus1FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus1FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-1-line-height",
    default: fastDesignSystemDefaults.typeRampPlus1LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus1LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-2-font-size",
    default: fastDesignSystemDefaults.typeRampPlus2FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus2FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-2-line-height",
    default: fastDesignSystemDefaults.typeRampPlus2LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus2LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-3-font-size",
    default: fastDesignSystemDefaults.typeRampPlus3FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus3FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-3-line-height",
    default: fastDesignSystemDefaults.typeRampPlus3LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus3LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-4-font-size",
    default: fastDesignSystemDefaults.typeRampPlus4FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus4FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-4-line-height",
    default: fastDesignSystemDefaults.typeRampPlus4LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus4LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-5-font-size",
    default: fastDesignSystemDefaults.typeRampPlus5FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus5FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-5-line-height",
    default: fastDesignSystemDefaults.typeRampPlus5LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus5LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-6-font-size",
    default: fastDesignSystemDefaults.typeRampPlus6FontSize
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus6FontSize", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "type-ramp-plus-6-line-height",
    default: fastDesignSystemDefaults.typeRampPlus6LineHeight
  })
], FASTDesignSystemProvider.prototype, "typeRampPlus6LineHeight", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-fill-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentFillRestDelta
  })
], FASTDesignSystemProvider.prototype, "accentFillRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-fill-hover-delta",
    cssCustomProperty: false,
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.accentFillHoverDelta
  })
], FASTDesignSystemProvider.prototype, "accentFillHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-fill-active-delta",
    cssCustomProperty: false,
    converter: nullableNumberConverter,
    default: fastDesignSystemDefaults.accentFillActiveDelta
  })
], FASTDesignSystemProvider.prototype, "accentFillActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-fill-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentFillFocusDelta
  })
], FASTDesignSystemProvider.prototype, "accentFillFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-fill-selected-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentFillSelectedDelta
  })
], FASTDesignSystemProvider.prototype, "accentFillSelectedDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-foreground-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentForegroundRestDelta
  })
], FASTDesignSystemProvider.prototype, "accentForegroundRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-foreground-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentForegroundHoverDelta
  })
], FASTDesignSystemProvider.prototype, "accentForegroundHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-foreground-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentForegroundActiveDelta
  })
], FASTDesignSystemProvider.prototype, "accentForegroundActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "accent-foreground-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.accentForegroundFocusDelta
  })
], FASTDesignSystemProvider.prototype, "accentForegroundFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-selected-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillSelectedDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillSelectedDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-input-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillInputRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillInputRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-input-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillInputHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillInputHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-input-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillInputActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillInputActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-input-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillInputFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillInputFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-input-selected-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillInputSelectedDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillInputSelectedDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-stealth-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillStealthRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillStealthRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-stealth-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillStealthHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillStealthHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-stealth-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillStealthActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillStealthActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-stealth-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillStealthFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillStealthFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-stealth-selected-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillStealthSelectedDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillStealthSelectedDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-toggle-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillToggleHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillToggleHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-toggle-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillToggleActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillToggleActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-toggle-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillToggleFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillToggleFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "base-layer-luminance",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.baseLayerLuminance
  })
], FASTDesignSystemProvider.prototype, "baseLayerLuminance", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-fill-card-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralFillCardDelta
  })
], FASTDesignSystemProvider.prototype, "neutralFillCardDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-foreground-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralForegroundHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralForegroundHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-foreground-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralForegroundActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralForegroundActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-foreground-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralForegroundFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralForegroundFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-divider-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralDividerRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralDividerRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-outline-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralOutlineRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralOutlineRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-outline-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralOutlineHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralOutlineHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-outline-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralOutlineActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralOutlineActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-outline-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralOutlineFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralOutlineFocusDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-contrast-fill-rest-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralContrastFillRestDelta
  })
], FASTDesignSystemProvider.prototype, "neutralContrastFillRestDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-contrast-fill-hover-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralContrastFillHoverDelta
  })
], FASTDesignSystemProvider.prototype, "neutralContrastFillHoverDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-contrast-fill-active-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralContrastFillActiveDelta
  })
], FASTDesignSystemProvider.prototype, "neutralContrastFillActiveDelta", void 0);
__decorate$1([
  designSystemProperty({
    attribute: "neutral-contrast-fill-focus-delta",
    converter: nullableNumberConverter,
    cssCustomProperty: false,
    default: fastDesignSystemDefaults.neutralContrastFillFocusDelta
  })
], FASTDesignSystemProvider.prototype, "neutralContrastFillFocusDelta", void 0);
FASTDesignSystemProvider = __decorate$1([
  designSystemProvider({
    name: "fast-design-system-provider",
    template: DesignSystemProviderTemplate,
    styles: DesignSystemProviderStyles
  })
], FASTDesignSystemProvider);
const neutralForegroundRestBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-rest", (x2) => neutralForeground(x2).rest, FASTDesignSystemProvider.findProvider);
const neutralForegroundHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-hover", (x2) => neutralForeground(x2).hover, FASTDesignSystemProvider.findProvider);
const neutralForegroundActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-active", (x2) => neutralForeground(x2).active, FASTDesignSystemProvider.findProvider);
const neutralForegroundFocusBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-focus", (x2) => neutralForeground(x2).focus, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-foreground-toggle", neutralForegroundToggle, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-foreground-toggle-large", neutralForegroundToggleLarge, FASTDesignSystemProvider.findProvider);
const neutralForegroundHintBehavior = cssCustomPropertyBehaviorFactory("neutral-foreground-hint", neutralForegroundHint, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-foreground-hint-large", neutralForegroundHintLarge, FASTDesignSystemProvider.findProvider);
const accentForegroundRestBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-rest", (x2) => accentForeground(x2).rest, FASTDesignSystemProvider.findProvider);
const accentForegroundHoverBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-hover", (x2) => accentForeground(x2).hover, FASTDesignSystemProvider.findProvider);
const accentForegroundActiveBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-active", (x2) => accentForeground(x2).active, FASTDesignSystemProvider.findProvider);
const accentForegroundFocusBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-focus", (x2) => accentForeground(x2).focus, FASTDesignSystemProvider.findProvider);
const accentForegroundCutRestBehavior = cssCustomPropertyBehaviorFactory("accent-foreground-cut-rest", (x2) => accentForegroundCut(x2), FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-foreground-large-rest", (x2) => accentForegroundLarge(x2).rest, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-foreground-large-hover", (x2) => accentForegroundLarge(x2).hover, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-foreground-large-active", (x2) => accentForegroundLarge(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-foreground-large-focus", (x2) => accentForegroundLarge(x2).focus, FASTDesignSystemProvider.findProvider);
const neutralFillRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-rest", (x2) => neutralFill(x2).rest, FASTDesignSystemProvider.findProvider);
const neutralFillHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-hover", (x2) => neutralFill(x2).hover, FASTDesignSystemProvider.findProvider);
const neutralFillActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-active", (x2) => neutralFill(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-focus", (x2) => neutralFill(x2).focus, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-selected", (x2) => neutralFill(x2).selected, FASTDesignSystemProvider.findProvider);
const neutralFillStealthRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-rest", (x2) => neutralFillStealth(x2).rest, FASTDesignSystemProvider.findProvider);
const neutralFillStealthHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-hover", (x2) => neutralFillStealth(x2).hover, FASTDesignSystemProvider.findProvider);
const neutralFillStealthActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-active", (x2) => neutralFillStealth(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-stealth-focus", (x2) => neutralFillStealth(x2).focus, FASTDesignSystemProvider.findProvider);
const neutralFillStealthSelectedBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-stealth-selected", (x2) => neutralFillStealth(x2).selected, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-toggle-rest", (x2) => neutralFillToggle(x2).rest, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-toggle-hover", (x2) => neutralFillToggle(x2).hover, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-toggle-active", (x2) => neutralFillToggle(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-toggle-focus", (x2) => neutralFillToggle(x2).focus, FASTDesignSystemProvider.findProvider);
const neutralFillInputRestBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-rest", (x2) => neutralFillInput(x2).rest, FASTDesignSystemProvider.findProvider);
const neutralFillInputHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-hover", (x2) => neutralFillInput(x2).hover, FASTDesignSystemProvider.findProvider);
const neutralFillInputActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-fill-input-active", (x2) => neutralFillInput(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-input-selected", (x2) => neutralFillInput(x2).selected, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-input-focus", (x2) => neutralFillInput(x2).focus, FASTDesignSystemProvider.findProvider);
const accentFillRestBehavior = cssCustomPropertyBehaviorFactory("accent-fill-rest", (x2) => accentFill(x2).rest, FASTDesignSystemProvider.findProvider);
const accentFillHoverBehavior = cssCustomPropertyBehaviorFactory("accent-fill-hover", (x2) => accentFill(x2).hover, FASTDesignSystemProvider.findProvider);
const accentFillActiveBehavior = cssCustomPropertyBehaviorFactory("accent-fill-active", (x2) => accentFill(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-focus", (x2) => accentFill(x2).focus, FASTDesignSystemProvider.findProvider);
const accentFillSelectedBehavior = cssCustomPropertyBehaviorFactory("accent-fill-selected", (x2) => accentFill(x2).selected, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-large-rest", (x2) => accentFillLarge(x2).rest, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-large-hover", (x2) => accentFillLarge(x2).hover, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-large-active", (x2) => accentFillLarge(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-large-focus", (x2) => accentFillLarge(x2).focus, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("accent-fill-large-selected", (x2) => accentFillLarge(x2).selected, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-fill-card-rest", (x2) => neutralFillCard(x2), FASTDesignSystemProvider.findProvider);
const neutralOutlineRestBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-rest", (x2) => neutralOutline(x2).rest, FASTDesignSystemProvider.findProvider);
const neutralOutlineHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-hover", (x2) => neutralOutline(x2).hover, FASTDesignSystemProvider.findProvider);
const neutralOutlineActiveBehavior = cssCustomPropertyBehaviorFactory("neutral-outline-active", (x2) => neutralOutline(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-outline-focus", (x2) => neutralOutline(x2).focus, FASTDesignSystemProvider.findProvider);
const neutralDividerRestBehavior = cssCustomPropertyBehaviorFactory("neutral-divider-rest", neutralDividerRest, FASTDesignSystemProvider.findProvider);
const neutralLayerFloatingBehavior = cssCustomPropertyBehaviorFactory("neutral-layer-floating", neutralLayerFloating, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-card", neutralLayerCard, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-card-container", neutralLayerCardContainer, FASTDesignSystemProvider.findProvider);
const neutralLayerL1Behavior = cssCustomPropertyBehaviorFactory("neutral-layer-l1", neutralLayerL1, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-l1-alt", neutralLayerL1Alt, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-l2", neutralLayerL2, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-l3", neutralLayerL3, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-layer-l4", neutralLayerL4, FASTDesignSystemProvider.findProvider);
const neutralFocusBehavior = cssCustomPropertyBehaviorFactory("neutral-focus", neutralFocus, FASTDesignSystemProvider.findProvider);
const neutralFocusInnerAccentBehavior = cssCustomPropertyBehaviorFactory("neutral-focus-inner-accent", neutralFocusInnerAccent(accentBaseColor), FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-contrast-foreground-rest", (x2) => neutralForegroundRest(neutralContrastFillRest)(x2), FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-contrast-fill-rest", (x2) => neutralContrastFill(x2).rest, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-contrast-fill-hover", (x2) => neutralContrastFill(x2).hover, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-contrast-fill-active", (x2) => neutralContrastFill(x2).active, FASTDesignSystemProvider.findProvider);
cssCustomPropertyBehaviorFactory("neutral-contrast-fill-focus", (x2) => neutralContrastFill(x2).focus, FASTDesignSystemProvider.findProvider);
const AccordionStyles = css$4`
    ${display("flex")} :host {
        box-sizing: border-box;
        flex-direction: column;
        font-family: var(--body-font);
        font-size: var(--type-ramp-minus-1-font-size);
        line-height: var(--type-ramp-minus-1-line-height);
        color: ${neutralForegroundRestBehavior.var};
        border-top: calc(var(--outline-width) * 1px) solid
            ${neutralDividerRestBehavior.var};
    }
`.withBehaviors(neutralDividerRestBehavior, neutralForegroundRestBehavior);
const heightNumber = "(var(--base-height-multiplier) + var(--density)) * var(--design-unit)";
const AccordionItemStyles = css$4`
    ${display("flex")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        flex-direction: column;
        font-size: var(--type-ramp-minus-1-font-size);
        line-height: var(--type-ramp-minus-1-line-height);
        border-bottom: calc(var(--outline-width) * 1px) solid var(--neutral-divider-rest);
    }
    
    .region {
        display: none;
        padding: calc((6 + (var(--design-unit) * 2 * var(--density))) * 1px);
    }

    .heading {
        display: grid;
        position: relative;
        grid-template-columns: auto 1fr auto calc(${heightNumber} * 1px);
        z-index: 2;
    }

    .button {
        appearance: none;
        border: none;
        background: none;
        grid-column: 2;
        grid-row: 1;
        outline: none;
        padding: 0 calc((6 + (var(--design-unit) * 2 * var(--density))) * 1px);
        text-align: left;
        height: calc(${heightNumber} * 1px);
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-family: inherit;
    }

    .button:hover {
        color: ${neutralForegroundHoverBehavior.var};
    }

    .button:active {
        color: ${neutralForegroundActiveBehavior.var};
    }

    .button::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
        cursor: pointer;
    }

    .button:${focusVisible}::before {
        outline: none;
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px)
            ${neutralFocusBehavior.var};
    }

    :host([expanded]) .region {
        display: block;
    }

    .icon {
        display: flex;
        align-items: center;
        justify-content: center;
        grid-column: 4;
        z-index: 2;
        pointer-events: none;
    }

    slot[name="expanded-icon"],
    slot[name="collapsed-icon"] {
        fill: ${accentFillRestBehavior.var};
    }

    slot[name="collapsed-icon"] {
        display: flex;
    }

    :host([expanded]) slot[name="collapsed-icon"] {
        display: none;
    }

    slot[name="expanded-icon"] {
        display: none;
    }
    
    :host([expanded]) slot[name="expanded-icon"] {
        display: flex;
    }

    .start {
        display: flex;
        align-items: center;
        padding-inline-start: calc(var(--design-unit) * 1px);
        justify-content: center;
        grid-column: 1;
        z-index: 2;
    }

    .end {
        display: flex;
        align-items: center;
        justify-content: center;
        grid-column: 3;
        z-index: 2;
    }
`.withBehaviors(accentFillRestBehavior, neutralDividerRestBehavior, neutralForegroundActiveBehavior, neutralForegroundFocusBehavior, neutralForegroundHoverBehavior, neutralForegroundRestBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css$4`
            .button:${focusVisible}::before {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.Highlight};
            }
        `));
let FASTAccordionItem = class FASTAccordionItem2 extends AccordionItem {
};
FASTAccordionItem = __decorate$1([
  customElement$1({
    name: "fast-accordion-item",
    template: AccordionItemTemplate,
    styles: AccordionItemStyles
  })
], FASTAccordionItem);
let FASTAccordion = class FASTAccordion2 extends Accordion {
};
FASTAccordion = __decorate$1([
  customElement$1({
    name: "fast-accordion",
    template: AccordionTemplate,
    styles: AccordionStyles
  })
], FASTAccordion);
const ambientShadow = "0 0 calc((var(--elevation) * 0.225px) + 2px) rgba(0, 0, 0, calc(.11 * (2 - var(--background-luminance, 1))))";
const directionalShadow = "0 calc(var(--elevation) * 0.4px) calc((var(--elevation) * 0.9px)) rgba(0, 0, 0, calc(.13 * (2 - var(--background-luminance, 1))))";
const elevation = `box-shadow: ${ambientShadow}, ${directionalShadow};`;
const BaseButtonStyles = css$4`
    ${display("inline-flex")} :host {
        font-family: var(--body-font);
        outline: none;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        height: calc(${heightNumber} * 1px);
        min-width: calc(${heightNumber} * 1px);
        background-color: ${neutralFillRestBehavior.var};
        color: ${neutralForegroundRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        fill: currentcolor;
        cursor: pointer;
    }

    .control {
        background: transparent;
        height: inherit;
        flex-grow: 1;
        box-sizing: border-box;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0 calc((10 + (var(--design-unit) * 2 * var(--density))) * 1px);
        white-space: nowrap;
        outline: none;
        text-decoration: none;
        border: calc(var(--outline-width) * 1px) solid transparent;
        color: inherit;
        border-radius: inherit;
        fill: inherit;
        cursor: inherit;
        font-family: inherit;
        font-size: inherit;
        line-height: inherit;
    }

    :host(:hover) {
        background-color: ${neutralFillHoverBehavior.var};
    }

    :host(:active) {
        background-color: ${neutralFillActiveBehavior.var};
    }

    .control:${focusVisible} {
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${neutralFocusBehavior.var};
    }

    .control::-moz-focus-inner {
        border: 0;
    }

    .start,
    .end {
        display: flex;
    }

    .control.icon-only {
        padding: 0;
        line-height: 0;
    }

    ::slotted(svg) {
        ${""} width: 16px;
        height: 16px;
        pointer-events: none;
    }

    .start {
        margin-inline-end: 11px;
    }

    .end {
        margin-inline-start: 11px;
    }
`.withBehaviors(neutralFillRestBehavior, neutralForegroundRestBehavior, neutralFillHoverBehavior, neutralFillActiveBehavior, forcedColorsStylesheetBehavior(css$4`
            :host .control {
              background-color: ${SystemColors.ButtonFace};
              border-color: ${SystemColors.ButtonText};
              color: ${SystemColors.ButtonText};
              fill: currentColor;
            }
    
            :host(:hover) .control {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              color: ${SystemColors.HighlightText};
            }

            .control:${focusVisible} {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              border-color: ${SystemColors.ButtonText};
              box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.ButtonText};
              color: ${SystemColors.HighlightText};
            }

            .control:hover,
            :host([appearance="outline"]) .control:hover {
              border-color: ${SystemColors.ButtonText};
            }

            :host([href]) .control {
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.LinkText};
            }

            :host([href]) .control:hover,
            :host([href]) .control:${focusVisible}{
              forced-color-adjust: none;
              background: ${SystemColors.ButtonFace};
              border-color: ${SystemColors.LinkText};
              box-shadow: 0 0 0 1px ${SystemColors.LinkText} inset;
              color: ${SystemColors.LinkText};
              fill: currentColor;
            }
        `));
const AccentButtonStyles = css$4`
    :host([appearance="accent"]) {
        background: ${accentFillRestBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host([appearance="accent"]:hover) {
        background: ${accentFillHoverBehavior.var};
    }

    :host([appearance="accent"]:active) .control:active {
        background: ${accentFillActiveBehavior.var};
    }

    :host([appearance="accent"]) .control:${focusVisible} {
        box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) inset ${neutralFocusInnerAccentBehavior.var};
    }
`.withBehaviors(accentFillRestBehavior, accentForegroundCutRestBehavior, accentFillHoverBehavior, accentFillActiveBehavior, neutralFocusInnerAccentBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([appearance="accent"]) .control {
                forced-color-adjust: none;
                background: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
            }

            :host([appearance="accent"]) .control:hover {
                background: ${SystemColors.HighlightText};
                border-color: ${SystemColors.Highlight};
                color: ${SystemColors.Highlight};
            }

            :host([appearance="accent"]) .control:${focusVisible} {
                border-color: ${SystemColors.ButtonText};
                box-shadow: 0 0 0 2px ${SystemColors.HighlightText} inset;
            }

            :host([appearance="accent"][href]) .control{
                background: ${SystemColors.LinkText};
                color: ${SystemColors.HighlightText};
            }

            :host([appearance="accent"][href]) .control:hover {
                background: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.LinkText};
                box-shadow: none;
                color: ${SystemColors.LinkText};
                fill: currentColor;
            }

            :host([appearance="accent"][href]) .control:${focusVisible} {
                border-color: ${SystemColors.LinkText};
                box-shadow: 0 0 0 2px ${SystemColors.HighlightText} inset;
            }
        `));
const HypertextStyles = css$4`
    :host([appearance="hypertext"]) {
        font-size: inherit;
        line-height: inherit;
        height: auto;
        min-width: 0;
        background: transparent;
    }

    :host([appearance="hypertext"]) .control {
        display: inline;
        padding: 0;
        border: none;
        box-shadow: none;
        border-radius: 0;
        line-height: 1;
    }

    :host a.control:not(:link) {
        background-color: transparent;
        cursor: default;
    }
    :host([appearance="hypertext"]) .control:link,
    :host([appearance="hypertext"]) .control:visited {
        background: transparent;
        color: ${accentForegroundRestBehavior.var};
        border-bottom: calc(var(--outline-width) * 1px) solid ${accentForegroundRestBehavior.var};
    }

    :host([appearance="hypertext"]:hover),
    :host([appearance="hypertext"]) .control:hover {
        background: transparent;
        border-bottom-color: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="hypertext"]:active),
    :host([appearance="hypertext"]) .control:active {
        background: transparent;
        border-bottom-color: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="hypertext"]) .control:${focusVisible} {
        border-bottom: calc(var(--focus-outline-width) * 1px) solid ${neutralFocusBehavior.var};
        margin-bottom: calc(calc(var(--outline-width) - var(--focus-outline-width)) * 1px);
    }
`.withBehaviors(accentForegroundRestBehavior, accentForegroundHoverBehavior, accentForegroundActiveBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([appearance="hypertext"]:hover) {
                background-color: ${SystemColors.ButtonFace};
                color: ${SystemColors.ButtonText};
            }
            :host([appearance="hypertext"][href]) .control:hover,
            :host([appearance="hypertext"][href]) .control:active,
            :host([appearance="hypertext"][href]) .control:${focusVisible} {
                color: ${SystemColors.LinkText};
                border-bottom-color: ${SystemColors.LinkText};
                box-shadow: none;
            }
        `));
const LightweightButtonStyles = css$4`
    :host([appearance="lightweight"]) {
        background: transparent;
        color: ${accentForegroundRestBehavior.var};
    }

    :host([appearance="lightweight"]) .control {
        padding: 0;
        height: initial;
        border: none;
        box-shadow: none;
        border-radius: 0;
    }

    :host([appearance="lightweight"]:hover) {
        background: transparent;
        color: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="lightweight"]:active) {
        background: transparent;
        color: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="lightweight"]) .content {
        position: relative;
    }

    :host([appearance="lightweight"]) .content::before {
        content: "";
        display: block;
        height: calc(var(--outline-width) * 1px);
        position: absolute;
        top: calc(1em + 4px);
        width: 100%;
    }

    :host([appearance="lightweight"]:hover) .content::before {
        background: ${accentForegroundHoverBehavior.var};
    }

    :host([appearance="lightweight"]:active) .content::before {
        background: ${accentForegroundActiveBehavior.var};
    }

    :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
        background: ${neutralForegroundRestBehavior.var};
        height: calc(var(--focus-outline-width) * 1px);
    }
`.withBehaviors(accentForegroundRestBehavior, accentForegroundHoverBehavior, accentForegroundActiveBehavior, accentForegroundHoverBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([appearance="lightweight"]) .control:hover,
            :host([appearance="lightweight"]) .control:${focusVisible} {
                forced-color-adjust: none;
                background: ${SystemColors.ButtonFace};
                color: ${SystemColors.Highlight};
            }
            :host([appearance="lightweight"]) .control:hover .content::before,
            :host([appearance="lightweight"]) .control:${focusVisible} .content::before {
                background: ${SystemColors.Highlight};
            }

            :host([appearance="lightweight"][href]) .control:hover,
            :host([appearance="lightweight"][href]) .control:${focusVisible} {
                background: ${SystemColors.ButtonFace};
                box-shadow: none;
                color: ${SystemColors.LinkText};
            }

            :host([appearance="lightweight"][href]) .control:hover .content::before,
            :host([appearance="lightweight"][href]) .control:${focusVisible} .content::before {
                background: ${SystemColors.LinkText};
            }
        `));
const OutlineButtonStyles = css$4`
    :host([appearance="outline"]) {
        background: transparent;
        border-color: ${accentFillRestBehavior.var};
    }

    :host([appearance="outline"]:hover) {
        border-color: ${accentFillHoverBehavior.var};
    }

    :host([appearance="outline"]:active) {
        border-color: ${accentFillActiveBehavior.var};
    }

    :host([appearance="outline"]) .control {
        border-color: inherit;
    }

    :host([appearance="outline"]) .control:${focusVisible} {
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }
`.withBehaviors(accentFillRestBehavior, accentFillHoverBehavior, accentFillActiveBehavior, neutralFocusBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([appearance="outline"]) .control {
                border-color: ${SystemColors.ButtonText};
            }
            :host([appearance="outline"]) .control:${focusVisible} {
              forced-color-adjust: none;
              background-color: ${SystemColors.Highlight};
              border-color: ${SystemColors.ButtonText};
              box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px) ${SystemColors.ButtonText};
              color: ${SystemColors.HighlightText};
              fill: currentColor;
            }
            :host([appearance="outline"][href]) .control {
                background: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.LinkText};
                fill: currentColor;
            }
            :host([appearance="outline"][href]) .control:hover,
            :host([appearance="outline"][href]) .control:${focusVisible} {
              forced-color-adjust: none;
              border-color: ${SystemColors.LinkText};
              box-shadow: 0 0 0 1px ${SystemColors.LinkText} inset;
            }
        `));
const StealthButtonStyles = css$4`
    :host([appearance="stealth"]) {
        background: ${neutralFillStealthRestBehavior.var};
    }

    :host([appearance="stealth"]:hover) {
        background: ${neutralFillStealthHoverBehavior.var};
    }

    :host([appearance="stealth"]:active) {
        background: ${neutralFillStealthActiveBehavior.var};
    }
`.withBehaviors(neutralFillStealthRestBehavior, neutralFillStealthHoverBehavior, neutralFillStealthActiveBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([appearance="stealth"]),
            :host([appearance="stealth"]) .control {
                forced-color-adjust: none;
                background: ${SystemColors.ButtonFace};
                border-color: transparent;
                color: ${SystemColors.ButtonText};
                fill: currentColor;
            }

            :host([appearance="stealth"]:hover) .control {
                background: ${SystemColors.Highlight};
                border-color: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"]:${focusVisible}) .control {
                background: ${SystemColors.Highlight};
                box-shadow: 0 0 0 1px ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"][href]) .control {
                color: ${SystemColors.LinkText};
            }

            :host([appearance="stealth"][href]:hover) .control,
            :host([appearance="stealth"][href]:${focusVisible}) .control {
                background: ${SystemColors.LinkText};
                border-color: ${SystemColors.LinkText};
                color: ${SystemColors.HighlightText};
                fill: currentColor;
            }

            :host([appearance="stealth"][href]:${focusVisible}) .control {
                forced-color-adjust: none;
                box-shadow: 0 0 0 1px ${SystemColors.LinkText};
            }
        `));
function appearanceBehavior(value2, styles2) {
  return new PropertyStyleSheetBehavior("appearance", value2, styles2);
}
const AnchorStyles = css$4`
    ${BaseButtonStyles}
`.withBehaviors(appearanceBehavior("accent", AccentButtonStyles), appearanceBehavior("hypertext", HypertextStyles), appearanceBehavior("lightweight", LightweightButtonStyles), appearanceBehavior("outline", OutlineButtonStyles), appearanceBehavior("stealth", StealthButtonStyles));
let FASTAnchor = class FASTAnchor2 extends Anchor {
  appearanceChanged(oldValue, newValue) {
    if (oldValue !== newValue) {
      this.classList.add(newValue);
      this.classList.remove(oldValue);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.appearance) {
      this.appearance = "neutral";
    }
  }
  defaultSlottedContentChanged(oldValue, newValue) {
    const slottedElements = this.defaultSlottedContent.filter((x2) => x2.nodeType === Node.ELEMENT_NODE);
    if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
      this.control.classList.add("icon-only");
    } else {
      this.control.classList.remove("icon-only");
    }
  }
};
__decorate$1([
  attr$1
], FASTAnchor.prototype, "appearance", void 0);
FASTAnchor = __decorate$1([
  customElement$1({
    name: "fast-anchor",
    template: AnchorTemplate,
    styles: AnchorStyles,
    shadowOptions: {
      delegatesFocus: true
    }
  })
], FASTAnchor);
const ButtonStyles = css$4`
    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
        opacity: var(--disabled-opacity);
        background-color: ${neutralFillRestBehavior.var};
        cursor: ${disabledCursor};
    }

    ${BaseButtonStyles}
`.withBehaviors(forcedColorsStylesheetBehavior(css$4`
            :host([disabled]),
            :host([disabled]) .control {
                forced-color-adjust: none;
                background-color: ${SystemColors.ButtonFace};
                border-color: ${SystemColors.GrayText};
                color: ${SystemColors.GrayText};
                cursor: ${disabledCursor};
                opacity: 1;
            }
        `), appearanceBehavior("accent", css$4`
            :host([appearance="accent"][disabled]),
            :host([appearance="accent"][disabled]:hover),
            :host([appearance="accent"][disabled]:active) {
                background: ${accentFillRestBehavior.var};
            }

            ${AccentButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css$4`
                    :host([appearance="accent"][disabled]) .control,
                    :host([appearance="accent"][disabled]) .control:hover {
                        background: ${SystemColors.ButtonFace};
                        border-color: ${SystemColors.GrayText};
                        color: ${SystemColors.GrayText};
                    }
                `))), appearanceBehavior("lightweight", css$4`
            :host([appearance="lightweight"][disabled]:hover),
            :host([appearance="lightweight"][disabled]:active) {
                background-color: transparent;
                color: ${accentForegroundRestBehavior.var};
            }

            :host([appearance="lightweight"][disabled]) .content::before,
            :host([appearance="lightweight"][disabled]:hover) .content::before,
            :host([appearance="lightweight"][disabled]:active) .content::before {
                background: transparent;
            }

            ${LightweightButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css$4`
                    :host([appearance="lightweight"].disabled) .control {
                        forced-color-adjust: none;
                        color: ${SystemColors.GrayText};
                    }

                    :host([appearance="lightweight"].disabled)
                        .control:hover
                        .content::before {
                        background: none;
                    }
                `))), appearanceBehavior("outline", css$4`
            :host([appearance="outline"][disabled]),
            :host([appearance="outline"][disabled]:hover),
            :host([appearance="outline"][disabled]:active) {
                background: transparent;
                border-color: ${accentFillRestBehavior.var};
            }

            ${OutlineButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css$4`
                    :host([appearance="outline"][disabled]) .control {
                        border-color: ${SystemColors.GrayText};
                    }
                `))), appearanceBehavior("stealth", css$4`
            :host([appearance="stealth"][disabled]),
            :host([appearance="stealth"][disabled]:hover),
            :host([appearance="stealth"][disabled]:active) {
                background: ${neutralFillStealthRestBehavior.var};
            }

            ${StealthButtonStyles}
        `.withBehaviors(forcedColorsStylesheetBehavior(css$4`
                    :host([appearance="stealth"][disabled]) {
                        background: ${SystemColors.ButtonFace};
                    }

                    :host([appearance="stealth"][disabled]) .control {
                        background: ${SystemColors.ButtonFace};
                        border-color: transparent;
                        color: ${SystemColors.GrayText};
                    }
                `))));
let FASTButton = class FASTButton2 extends Button$1 {
  connectedCallback() {
    super.connectedCallback();
    if (!this.appearance) {
      this.appearance = "neutral";
    }
  }
  defaultSlottedContentChanged(oldValue, newValue) {
    const slottedElements = this.defaultSlottedContent.filter((x2) => x2.nodeType === Node.ELEMENT_NODE);
    if (slottedElements.length === 1 && slottedElements[0] instanceof SVGElement) {
      this.control.classList.add("icon-only");
    } else {
      this.control.classList.remove("icon-only");
    }
  }
};
__decorate$1([
  attr$1
], FASTButton.prototype, "appearance", void 0);
FASTButton = __decorate$1([
  customElement$1({
    name: "fast-button",
    template: ButtonTemplate,
    styles: ButtonStyles,
    shadowOptions: {
      delegatesFocus: true
    }
  })
], FASTButton);
const CheckboxStyles = css$4`
    ${display("inline-flex")} :host {
        align-items: center;
        outline: none;
        margin: calc(var(--design-unit) * 1px) 0;
        ${""} user-select: none;
    }

    .control {
        position: relative;
        width: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        height: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        box-sizing: border-box;
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${neutralOutlineRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        outline: none;
        cursor: pointer;
    }

    .label {
        font-family: var(--body-font);
        color: ${neutralForegroundRestBehavior.var};
        ${""} padding-inline-start: calc(var(--design-unit) * 2px + 2px);
        margin-inline-end: calc(var(--design-unit) * 2px + 2px);
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    .checked-indicator {
        width: 100%;
        height: 100%;
        display: block;
        fill: ${accentForegroundCutRestBehavior.var};
        opacity: 0;
        pointer-events: none;
    }

    .indeterminate-indicator {
        border-radius: calc(var(--corner-radius) * 1px);
        background: ${accentForegroundCutRestBehavior.var};
        position: absolute;
        top: 50%;
        left: 50%;
        width: 50%;
        height: 50%;
        transform: translate(-50%, -50%);
        opacity: 0;
    }

    :host(:not([disabled])) .control:hover {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${neutralOutlineHoverBehavior.var};
    }

    :host(:not([disabled])) .control:active {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${neutralOutlineActiveBehavior.var};
    }

    :host(:${focusVisible}) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }

    :host([aria-checked="true"]) .control {
        background: ${accentFillRestBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:hover {
        background: ${accentFillHoverBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillHoverBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:active {
        background: ${accentFillActiveBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillActiveBehavior.var};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: transparent;
    }


    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }

    :host([aria-checked="true"]:not(.indeterminate)) .checked-indicator,
    :host(.indeterminate) .indeterminate-indicator {
        opacity: 1;
    }

    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundCutRestBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFocusBehavior, neutralFocusInnerAccentBehavior, neutralForegroundRestBehavior, neutralOutlineActiveBehavior, neutralOutlineHoverBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css$4`
            .control {
                forced-color-adjust: none;
                border-color: ${SystemColors.FieldText};
                background: ${SystemColors.Field};
            }
            .checked-indicator {
                fill: ${SystemColors.FieldText};
            }
            .indeterminate-indicator {
                background: ${SystemColors.FieldText};
            }
            :host(:not([disabled])) .control:hover, .control:active {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.Field};
            }
            :host(:${focusVisible}) .control {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([aria-checked="true"]) .control {
                background: ${SystemColors.Highlight};
                border-color: ${SystemColors.Highlight};
            }
            :host([aria-checked="true"]:not([disabled])) .control:hover, .control:active {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.HighlightText};
            }
            :host([aria-checked="true"]) .checked-indicator {
                fill: ${SystemColors.HighlightText};
            }
            :host([aria-checked="true"]:not([disabled])) .control:hover .checked-indicator {
                fill: ${SystemColors.Highlight}
            }
            :host([aria-checked="true"]) .indeterminate-indicator {
                background: ${SystemColors.HighlightText};
            }
            :host([aria-checked="true"]) .control:hover .indeterminate-indicator {
                background: ${SystemColors.Highlight}
            }
            :host([disabled]) {
                opacity: 1;
            }
            :host([disabled]) .control {
                forced-color-adjust: none;
                border-color: ${SystemColors.GrayText};
                background: ${SystemColors.Field};
            }
            :host([disabled]) .indeterminate-indicator,
            :host([aria-checked="true"][disabled]) .control:hover .indeterminate-indicator {
                forced-color-adjust: none;
                background: ${SystemColors.GrayText};
            }
            :host([disabled]) .checked-indicator,
            :host([aria-checked="true"][disabled]) .control:hover .checked-indicator {
                forced-color-adjust: none;
                fill: ${SystemColors.GrayText};
            }
        `));
let FASTCheckbox = class FASTCheckbox2 extends Checkbox {
};
FASTCheckbox = __decorate$1([
  customElement$1({
    name: "fast-checkbox",
    template: CheckboxTemplate,
    styles: CheckboxStyles
  })
], FASTCheckbox);
const SelectStyles = css$4`
    ${display("inline-flex")} :host {
        --elevation: 14;
        background: ${neutralFillInputRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
        box-sizing: border-box;
        color: ${neutralForegroundRestBehavior.var};
        font-family: var(--body-font);
        height: calc(${heightNumber} * 1px);
        position: relative;
        user-select: none;
        min-width: 250px;
        outline: none;
        vertical-align: top;
    }

    .listbox {
        ${elevation}
        background: ${neutralLayerFloatingBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${neutralOutlineRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        box-sizing: border-box;
        display: inline-flex;
        flex-direction: column;
        left: 0;
        max-height: calc(var(--max-height) - (${heightNumber} * 1px));
        padding: calc(var(--design-unit) * 1px) 0;
        overflow-y: auto;
        position: absolute;
        width: 100%;
        z-index: 1;
    }

    .listbox[hidden] {
        display: none;
    }

    .control {
        align-items: center;
        box-sizing: border-box;
        cursor: pointer;
        display: flex;
        font-size: var(--type-ramp-base-font-size);
        font-family: inherit;
        line-height: var(--type-ramp-base-line-height);
        min-height: 100%;
        padding: 0 calc(var(--design-unit) * 2.25px);
        width: 100%;
    }

    :host(:not([disabled]):hover) {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${accentFillHoverBehavior.var};
    }

    :host(:${focusVisible}) {
        border-color: ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) ${neutralFocusBehavior.var};
    }

    :host(:${focusVisible}) ::slotted([aria-selected="true"][role="option"]:not([disabled])) {
        box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) inset ${neutralFocusInnerAccentBehavior.var};
        border-color: ${neutralFocusBehavior.var};
        background: ${accentFillHoverBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host([disabled]) {
        cursor: ${disabledCursor};
        opacity: var(--disabled-opacity);
    }

    :host([disabled]) .control {
        cursor: ${disabledCursor};
        user-select: none;
    }

    :host([disabled]:hover) {
        background: ${neutralFillStealthRestBehavior.var};
        color: ${neutralForegroundRestBehavior.var};
        fill: currentcolor;
    }

    :host(:not([disabled])) .control:active {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${accentFillActiveBehavior.var};
    }

    :host([open][position="above"]) .listbox,
    :host([open][position="below"]) .control {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
    }

    :host([open][position="above"]) .control,
    :host([open][position="below"]) .listbox {
        border-top-left-radius: 0;
        border-top-right-radius: 0;
    }

    :host([open][position="above"]) .listbox {
        border-bottom: 0;
        bottom: calc(${heightNumber} * 1px);
    }

    :host([open][position="below"]) .listbox {
        border-top: 0;
        top: calc(${heightNumber} * 1px);
    }

    .selected-value {
        flex: 1 1 auto;
        font-family: inherit;
        text-align: start;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
    }

    .indicator {
        flex: 0 0 auto;
        margin-inline-start: 1em;
    }

    slot[name="listbox"] {
        display: none;
        width: 100%;
    }

    :host([open]) slot[name="listbox"] {
        display: flex;
        position: absolute;
        ${elevation}
    }

    .end {
        margin-inline-start: auto;
    }

    .start,
    .end,
    .indicator,
    .select-indicator,
    ::slotted(svg) {
        ${``}
        fill: currentcolor;
        height: 1em;
        min-height: calc(var(--design-unit) * 4px);
        min-width: calc(var(--design-unit) * 4px);
        width: 1em;
    }

    ::slotted([role="option"]),
    ::slotted(option) {
        flex: 0 0 auto;
    }

`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundCutRestBehavior, accentForegroundFocusBehavior, forcedColorsStylesheetBehavior(css$4`
            :host(:not([disabled]):hover),
            :host(:not([disabled]):active) {
                border-color: ${SystemColors.Highlight};
            }

            :host(:not([disabled]):${focusVisible}) {
                background-color: ${SystemColors.ButtonFace};
                box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) ${SystemColors.Highlight};
                color: ${SystemColors.ButtonText};
                fill: currentcolor;
                forced-color-adjust: none;
            }

            :host(:not([disabled]):${focusVisible}) .listbox {
                background: ${SystemColors.ButtonFace};
            }

            :host([disabled]) {
                border-color: ${SystemColors.GrayText};
                background-color: ${SystemColors.ButtonFace};
                color: ${SystemColors.GrayText};
                fill: currentcolor;
                opacity: 1;
                forced-color-adjust: none;
            }

            :host([disabled]:hover) {
                background: ${SystemColors.ButtonFace};
            }

            :host([disabled]) .control {
                color: ${SystemColors.GrayText};
                border-color: ${SystemColors.GrayText};
            }

            :host([disabled]) .control .select-indicator {
                fill: ${SystemColors.GrayText};
            }

            :host(:${focusVisible}) ::slotted([aria-selected="true"][role="option"]),
            :host(:${focusVisible}) ::slotted(option[aria-selected="true"]),
            :host(:${focusVisible}) ::slotted([aria-selected="true"][role="option"]:not([disabled])) {
                background: ${SystemColors.Highlight};
                border-color: ${SystemColors.ButtonText};
                box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) inset ${SystemColors.HighlightText};
                color: ${SystemColors.HighlightText};
                fill: currentcolor;
            }

            .start,
            .end,
            .indicator,
            .select-indicator,
            ::slotted(svg) {
                color: ${SystemColors.ButtonText};
                fill: currentcolor;
            }
        `), neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFocusBehavior, neutralFocusInnerAccentBehavior, neutralForegroundRestBehavior, neutralLayerFloatingBehavior, neutralOutlineRestBehavior);
const OptionStyles = css$4`
    ${display("inline-flex")} :host {
        align-items: center;
        font-family: var(--body-font);
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--focus-outline-width) * 1px) solid transparent;
        box-sizing: border-box;
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        fill: currentcolor;
        font-size: var(--type-ramp-base-font-size);
        height: calc(${heightNumber} * 1px);
        line-height: var(--type-ramp-base-line-height);
        margin: 0 calc(var(--design-unit) * 1px);
        outline: none;
        overflow: hidden;
        padding: 0 calc(var(--design-unit) * 2.25px);
        user-select: none;
        white-space: nowrap;
    }

    :host(:${focusVisible}) {
        box-shadow: 0 0 0 calc(var(--focus-outline-width) * 1px) inset ${neutralFocusInnerAccentBehavior.var};
        border-color: ${neutralFocusBehavior.var};
        background: ${accentFillHoverBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host([aria-selected="true"]) {
        background: ${accentFillHoverBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host(:active) {
        background: ${accentFillActiveBehavior.var};
        color: ${accentForegroundCutRestBehavior.var};
    }

    :host(:not([aria-selected="true"]):hover) {
        background: ${neutralFillHoverBehavior.var};
        color: ${neutralForegroundHoverBehavior.var};
    }

    :host(:not([aria-selected="true"]):active) {
        background: ${neutralFillHoverBehavior.var};
        color: ${neutralForegroundHoverBehavior.var};
    }

    :host([disabled]) {
        cursor: ${disabledCursor};
        opacity: var(--disabled-opacity);
    }

    :host([disabled]:hover) {
        background-color: inherit;
    }

    .content {
        grid-column-start: 2;
        justify-self: start;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .start,
    .end,
    ::slotted(svg) {
        display: flex;
    }

    ::slotted(svg) {
        ${""}
        height: calc(var(--design-unit) * 4px);
        width: calc(var(--design-unit) * 4px);
    }

    ::slotted([slot="end"]) {
        margin-inline-start: 1ch;
    }

    ::slotted([slot="start"]) {
        margin-inline-end: 1ch;
    }

`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillSelectedBehavior, accentForegroundCutRestBehavior, forcedColorsStylesheetBehavior(css$4`
            :host {
                border-color: transparent;
                forced-color-adjust: none;
                color: ${SystemColors.ButtonText};
                fill: currentcolor;
            }

            :host(:not([aria-selected="true"]):hover),
            :host([aria-selected="true"]) {
                background: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
            }

            :host([disabled]),
            :host([disabled]:not([aria-selected="true"]):hover) {
                background: ${SystemColors.Canvas};
                color: ${SystemColors.GrayText};
                fill: currentcolor;
                opacity: 1;
            }
        `), neutralFillHoverBehavior, neutralFillStealthHoverBehavior, neutralFillStealthRestBehavior, neutralFillStealthSelectedBehavior, neutralFocusBehavior, neutralFocusInnerAccentBehavior, neutralForegroundHoverBehavior, neutralForegroundRestBehavior, neutralLayerL1Behavior);
let FASTOption = class FASTOption2 extends ListboxOption {
};
FASTOption = __decorate$1([
  customElement$1({
    name: "fast-option",
    template: ListboxOptionTemplate,
    styles: OptionStyles
  })
], FASTOption);
const RadioStyles = css$4`
    ${display("inline-flex")} :host {
        --input-size: calc((${heightNumber} / 2) + var(--design-unit));
        align-items: center;
        outline: none;
        margin: calc(var(--design-unit) * 1px) 0;
        ${""} user-select: none;
        position: relative;
        flex-direction: row;
        transition: all 0.2s ease-in-out;
    }

    .control {
        position: relative;
        width: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        height: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        box-sizing: border-box;
        border-radius: 999px;
        border: calc(var(--outline-width) * 1px) solid ${neutralOutlineRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        outline: none;
        cursor: pointer;
    }

    .label {
        font-family: var(--body-font);
        color: ${neutralForegroundRestBehavior.var};
        ${""} padding-inline-start: calc(var(--design-unit) * 2px + 2px);
        margin-inline-end: calc(var(--design-unit) * 2px + 2px);
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    .control, .checked-indicator {
        flex-shrink: 0;
    }

    .checked-indicator {
        position: absolute;
        top: 5px;
        left: 5px;
        right: 5px;
        bottom: 5px;
        border-radius: 999px;
        display: inline-block;
        background: ${accentForegroundCutRestBehavior.var};
        fill: ${accentForegroundCutRestBehavior.var};
        opacity: 0;
        pointer-events: none;
    }

    :host(:not([disabled])) .control:hover{
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${neutralOutlineHoverBehavior.var};
    }

    :host(:not([disabled])) .control:active {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${neutralOutlineActiveBehavior.var};
    }

    :host(:${focusVisible}) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }

    :host([aria-checked="true"]) .control {
        background: ${accentFillRestBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:hover {
        background: ${accentFillHoverBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillHoverBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .control:active {
        background: ${accentFillActiveBehavior.var};
        border: calc(var(--outline-width) * 1px) solid ${accentFillActiveBehavior.var};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .control {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: transparent;
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }

    :host([aria-checked="true"]) .checked-indicator {
        opacity: 1;
    }

    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundCutRestBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineActiveBehavior, neutralOutlineHoverBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css$4`
            .control,
            :host([checked]:not([disabled])) .control {
                forced-color-adjust: none;
                border-color: ${SystemColors.FieldText};
                background: ${SystemColors.Field};
            }
            :host(:not([disabled])) .control:hover {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.Field};
            }
            :host([checked]:not([disabled])) .control:hover,
            :host([checked]:not([disabled])) .control:active {
                border-color: ${SystemColors.Highlight};
                background: ${SystemColors.Highlight};
            }
            :host([checked]) .checked-indicator {
                background: ${SystemColors.Highlight};
                fill: ${SystemColors.Highlight};
            }
            :host([checked]:not([disabled])) .control:hover .checked-indicator,
            :host([checked]:not([disabled])) .control:active .checked-indicator {
                background: ${SystemColors.HighlightText};
                fill: ${SystemColors.HighlightText};
            }
            :host(:${focusVisible}) .control {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([checked]:${focusVisible}:not([disabled])) .control {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([disabled]) {
                forced-color-adjust: none;
                opacity: 1;
            }
            :host([disabled]) .label {
                color: ${SystemColors.GrayText};
            }
            :host([disabled]) .control,
            :host([checked][disabled]) .control:hover, .control:active {
                background: ${SystemColors.Field};
                border-color: ${SystemColors.GrayText};
            }
            :host([disabled]) .checked-indicator,
            :host([checked][disabled]) .control:hover .checked-indicator {
                fill: ${SystemColors.GrayText};
                background: ${SystemColors.GrayText};
            }
        `));
let FASTRadio = class FASTRadio2 extends Radio {
};
FASTRadio = __decorate$1([
  customElement$1({
    name: "fast-radio",
    template: RadioTemplate,
    styles: RadioStyles
  })
], FASTRadio);
const RadioGroupStyles = css$4`
    ${display("flex")} :host {
        align-items: flex-start;
        margin: calc(var(--design-unit) * 1px) 0;
        flex-direction: column;
    }
    .positioning-region {
        display: flex;
        flex-wrap: wrap;
    }
    :host([orientation="vertical"]) .positioning-region {
        flex-direction: column;
    }
    :host([orientation="horizontal"]) .positioning-region {
        flex-direction: row;
    }
`;
let FASTRadioGroup = class FASTRadioGroup2 extends RadioGroup {
};
FASTRadioGroup = __decorate$1([
  customElement$1({
    name: "fast-radio-group",
    template: RadioGroupTemplate,
    styles: RadioGroupStyles
  })
], FASTRadioGroup);
let FASTSelect = class FASTSelect2 extends Select {
};
FASTSelect = __decorate$1([
  customElement$1({
    name: "fast-select",
    template: SelectTemplate,
    styles: SelectStyles
  })
], FASTSelect);
const SwitchStyles = css$4`
    :host([hidden]) {
        display: none;
    }

    ${display("inline-flex")} :host {
        align-items: center;
        outline: none;
        font-family: var(--body-font);
        margin: calc(var(--design-unit) * 1px) 0;
        ${""} user-select: none;
    }

    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .switch,
    :host([disabled]) .switch {
        cursor: ${disabledCursor};
    }

    .switch {
        position: relative;
        outline: none;
        box-sizing: border-box;
        width: calc(${heightNumber} * 1px);
        height: calc((${heightNumber} / 2 + var(--design-unit)) * 1px);
        background: ${neutralFillInputRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${neutralOutlineRestBehavior.var};
    }

    .switch:hover {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${neutralOutlineHoverBehavior.var};
        cursor: pointer;
    }

    host([disabled]) .switch:hover,
    host([readonly]) .switch:hover {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${neutralOutlineHoverBehavior.var};
        cursor: ${disabledCursor};
    }

    :host(:not([disabled])) .switch:active {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${neutralOutlineActiveBehavior.var};
    }

    :host(:${focusVisible}) .switch {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: ${neutralFocusBehavior.var};
    }

    .checked-indicator {
        position: absolute;
        top: 5px;
        bottom: 5px;
        background: ${neutralForegroundRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        transition: all 0.2s ease-in-out;
    }

    .status-message {
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
    }

    :host([disabled]) .status-message,
    :host([readonly]) .status-message {
        cursor: ${disabledCursor};
    }

    .label {
        color: ${neutralForegroundRestBehavior.var};

        ${""} margin-inline-end: calc(var(--design-unit) * 2px + 2px);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        cursor: pointer;
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    ::slotted(*) {
        ${""} margin-inline-start: calc(var(--design-unit) * 2px + 2px);
    }

    :host([aria-checked="true"]) .checked-indicator {
        background: ${accentForegroundCutRestBehavior.var};
    }

    :host([aria-checked="true"]) .switch {
        background: ${accentFillRestBehavior.var};
        border-color: ${accentFillRestBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .switch:hover {
        background: ${accentFillHoverBehavior.var};
        border-color: ${accentFillHoverBehavior.var};
    }

    :host([aria-checked="true"]:not([disabled])) .switch:active {
        background: ${accentFillActiveBehavior.var};
        border-color: ${accentFillActiveBehavior.var};
    }

    :host([aria-checked="true"]:${focusVisible}:not([disabled])) .switch {
        box-shadow: 0 0 0 2px var(--background-color), 0 0 0 4px ${neutralFocusBehavior.var};
        border-color: transparent;
    }

    .unchecked-message {
        display: block;
    }

    .checked-message {
        display: none;
    }

    :host([aria-checked="true"]) .unchecked-message {
        display: none;
    }

    :host([aria-checked="true"]) .checked-message {
        display: block;
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundCutRestBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineActiveBehavior, neutralOutlineHoverBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css$4`
            .checked-indicator,
            :host(:not([disabled])) .switch:active .checked-indicator {
                forced-color-adjust: none;
                background: ${SystemColors.FieldText};
            }
            .switch {
                forced-color-adjust: none;
                background: ${SystemColors.Field};
                border-color: ${SystemColors.FieldText};
            }
            :host(:not([disabled])) .switch:hover {
                background: ${SystemColors.HighlightText};
                border-color: ${SystemColors.Highlight};
            }
            :host([aria-checked="true"]) .switch {
                background: ${SystemColors.Highlight};
                border-color: ${SystemColors.Highlight};
            }
            :host([aria-checked="true"]:not([disabled])) .switch:hover,
            :host(:not([disabled])) .switch:active {
                background: ${SystemColors.HighlightText};
                border-color: ${SystemColors.Highlight};
            }
            :host([aria-checked="true"]) .checked-indicator {
                background: ${SystemColors.HighlightText};
            }
            :host([aria-checked="true"]:not([disabled])) .switch:hover .checked-indicator {
                background: ${SystemColors.Highlight};
            }
            :host([disabled]) {
                opacity: 1;
            }
            :host(:${focusVisible}) .switch {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([aria-checked="true"]:${focusVisible}:not([disabled])) .switch {
                box-shadow: 0 0 0 2px ${SystemColors.Field}, 0 0 0 4px ${SystemColors.FieldText};
            }
            :host([disabled]) .checked-indicator {
                background: ${SystemColors.GrayText};
            }
            :host([disabled]) .switch {
                background: ${SystemColors.Field};
                border-color: ${SystemColors.GrayText};
            }
        `), new DirectionalStyleSheetBehavior(css$4`
            .checked-indicator {
                left: 5px;
                right: calc(((${heightNumber} / 2) + 1) * 1px);
            }

            :host([aria-checked="true"]) .checked-indicator {
                left: calc(((${heightNumber} / 2) + 1) * 1px);
                right: 5px;
            }
        `, css$4`
            .checked-indicator {
                right: 5px;
                left: calc(((${heightNumber} / 2) + 1) * 1px);
            }

            :host([aria-checked="true"]) .checked-indicator {
                right: calc(((${heightNumber} / 2) + 1) * 1px);
                left: 5px;
            }
        `));
let FASTSwitch = class FASTSwitch2 extends Switch {
};
FASTSwitch = __decorate$1([
  customElement$1({
    name: "fast-switch",
    template: SwitchTemplate,
    styles: SwitchStyles
  })
], FASTSwitch);
const TabsStyles = css$4`
    ${display("grid")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        color: ${neutralForegroundRestBehavior.var};
        grid-template-columns: auto 1fr auto;
        grid-template-rows: auto 1fr;
    }

    .tablist {
        display: grid;
        grid-template-rows: auto auto;
        grid-template-columns: auto;
        position: relative;
        width: max-content;
        align-self: end;
        padding: calc(var(--design-unit) * 4px) calc(var(--design-unit) * 4px) 0;
        box-sizing: border-box;
    }

    .start,
    .end {
        align-self: center;
    }

    .activeIndicator {
        grid-row: 2;
        grid-column: 1;
        width: 100%;
        height: 5px;
        justify-self: center;
        background: ${accentFillRestBehavior.var};
        margin-top: 10px;
        border-radius: calc(var(--corner-radius) * 1px) calc(var(--corner-radius) * 1px) 0
            0;
    }

    .activeIndicatorTransition {
        transition: transform 0.2s ease-in-out;
    }

    .tabpanel {
        grid-row: 2;
        grid-column-start: 1;
        grid-column-end: 4;
        position: relative;
    }

    :host([orientation="vertical"]) {
        grid-template-rows: auto 1fr auto;
        grid-template-columns: auto 1fr;
    }

    :host([orientation="vertical"]) .tablist {
        grid-row-start: 2;
        grid-row-end: 2;
        display: grid;
        grid-template-rows: auto;
        grid-template-columns: auto 1fr;
        position: relative;
        width: max-content;
        justify-self: end;
        width: 100%;
        padding: calc((${heightNumber} - var(--design-unit)) * 1px)
            calc(var(--design-unit) * 4px)
            calc((${heightNumber} - var(--design-unit)) * 1px) 0;
    }

    :host([orientation="vertical"]) .tabpanel {
        grid-column: 2;
        grid-row-start: 1;
        grid-row-end: 4;
    }

    :host([orientation="vertical"]) .end {
        grid-row: 3;
    }

    :host([orientation="vertical"]) .activeIndicator {
        grid-column: 1;
        grid-row: 1;
        width: 5px;
        height: 100%;
        margin-inline-end: 10px;
        align-self: center;
        background: ${accentFillRestBehavior.var};
        margin-top: 0;
        border-radius: 0 calc(var(--corner-radius) * 1px) calc(var(--corner-radius) * 1px)
            0;
    }

    :host([orientation="vertical"]) .activeIndicatorTransition {
        transition: transform 0.2s linear;
    }
`.withBehaviors(accentFillRestBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css$4`
            .activeIndicator,
            :host([orientation="vertical"]) .activeIndicator {
                forced-color-adjust: none;
                background: ${SystemColors.Highlight};
            }
        `));
const TabStyles = css$4`
    ${display("inline-flex")} :host {
        box-sizing: border-box;
        font-family: var(--body-font);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        height: calc(${heightNumber} * 1px);
        padding: calc(var(--design-unit) * 5px) calc(var(--design-unit) * 4px);
        color: ${neutralForegroundHintBehavior.var};
        fill: currentcolor;
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid transparent;
        align-items: center;
        justify-content: center;
        grid-row: 1;
        cursor: pointer;
    }

    :host(:hover) {
        color: ${neutralForegroundHoverBehavior.var};
        fill: currentcolor;
    }

    :host(:active) {
        color: ${neutralForegroundActiveBehavior.var};
        fill: currentcolor;
    }

    :host([disabled]) {
        cursor: ${disabledCursor};
        opacity: var(--disabled-opacity);
    }

    :host([disabled]:hover) {
        color: ${neutralForegroundHintBehavior.var};
        background: ${neutralFillStealthRestBehavior.var};
    }

    :host([aria-selected="true"]) {
        background: ${neutralFillRestBehavior.var};
        color: ${accentForegroundRestBehavior.var};
        fill: currentcolor;
    }

    :host([aria-selected="true"]:hover) {
        background: ${neutralFillHoverBehavior.var};
        color: ${accentForegroundHoverBehavior.var};
        fill: currentcolor;
    }

    :host([aria-selected="true"]:active) {
        background: ${neutralFillActiveBehavior.var};
        color: ${accentForegroundActiveBehavior.var};
        fill: currentcolor;
    }

    :host(:${focusVisible}) {
        outline: none;
        border: calc(var(--outline-width) * 1px) solid ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 calc((var(--focus-outline-width) - var(--outline-width)) * 1px)
            ${neutralFocusBehavior.var};
    }

    :host(:focus) {
        outline: none;
    }

    :host(.vertical) {
        justify-content: end;
        grid-column: 2;
    }

    :host(.vertical[aria-selected="true"]) {
        z-index: 2;
    }

    :host(.vertical:hover) {
        color: ${neutralForegroundHoverBehavior.var};
    }

    :host(.vertical:active) {
        color: ${neutralForegroundActiveBehavior.var};
    }

    :host(.vertical:hover[aria-selected="true"]) {
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, accentForegroundActiveBehavior, accentForegroundHoverBehavior, accentForegroundRestBehavior, neutralFillActiveBehavior, neutralFillHoverBehavior, neutralFillRestBehavior, neutralFillStealthRestBehavior, neutralFocusBehavior, neutralForegroundHintBehavior, neutralForegroundActiveBehavior, neutralForegroundHoverBehavior, neutralForegroundRestBehavior, forcedColorsStylesheetBehavior(css$4`
            :host {
                forced-color-adjust: none;
                border-color: transparent;
                color: ${SystemColors.ButtonText};
                fill: currentcolor;
            }
            :host(:hover),
            :host(.vertical:hover),
            :host([aria-selected="true"]:hover) {
                background: ${SystemColors.Highlight};
                color: ${SystemColors.HighlightText};
                fill: currentcolor;
            }
            :host([aria-selected="true"]) {
                background: ${SystemColors.HighlightText};
                color: ${SystemColors.Highlight};
                fill: currentcolor;
            }
            :host(:${focusVisible}) {
                border-color: ${SystemColors.ButtonText};
                box-shadow: none;
            }
        `));
let FASTTab = class FASTTab2 extends Tab {
};
FASTTab = __decorate$1([
  customElement$1({
    name: "fast-tab",
    template: TabTemplate,
    styles: TabStyles
  })
], FASTTab);
const TabPanelStyles = css$4`
    ${display("flex")} :host {
        box-sizing: border-box;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        padding: 0 calc((6 + (var(--design-unit) * 2 * var(--density))) * 1px);
    }
`;
let FASTTabPanel = class FASTTabPanel2 extends TabPanel {
};
FASTTabPanel = __decorate$1([
  customElement$1({
    name: "fast-tab-panel",
    template: TabPanelTemplate,
    styles: TabPanelStyles
  })
], FASTTabPanel);
let FASTTabs = class FASTTabs2 extends Tabs {
};
FASTTabs = __decorate$1([
  customElement$1({
    name: "fast-tabs",
    template: TabsTemplate,
    styles: TabsStyles
  })
], FASTTabs);
const TextAreaStyles = css$4`
    ${display("inline-block")} :host {
        font-family: var(--body-font);
        outline: none;
        user-select: none;
    }

    .control {
        box-sizing: border-box;
        position: relative;
        color: ${neutralForegroundRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
        height: calc(${heightNumber} * 2px);
        font: inherit;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        padding: calc(var(--design-unit) * 2px + 1px);
        width: 100%;
        resize: none;
    }

    .control:hover:enabled {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${accentFillHoverBehavior.var};
    }

    .control:active:enabled {
        background: ${neutralFillInputActiveBehavior.var};
        border-color: ${accentFillActiveBehavior.var};
    }

    .control:hover,
    .control:${focusVisible},
    .control:disabled,
    .control:active {
        outline: none;
    }

    :host(:focus-within) .control {
        border-color: ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 1px ${neutralFocusBehavior.var} inset;
    }

    :host([appearance="filled"]) .control {
        background: ${neutralFillRestBehavior.var};
    }

    :host([appearance="filled"]:hover:not([disabled])) .control {
        background: ${neutralFillHoverBehavior.var};
    }

    :host([resize="both"]) .control {
        resize: both;
    }

    :host([resize="horizontal"]) .control {
        resize: horizontal;
    }

    :host([resize="vertical"]) .control {
        resize: vertical;
    }

    .label {
        display: block;
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        margin-bottom: 4px;
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }
    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }
    :host([disabled]) .control {
        border-color: ${neutralOutlineRestBehavior.var};
    }
 `.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, neutralFillHoverBehavior, neutralFillInputActiveBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFillRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css$4`
            :host([disabled]) {
                opacity: 1;
            }
        `));
let FASTTextArea = class FASTTextArea2 extends TextArea {
  connectedCallback() {
    super.connectedCallback();
    if (!this.appearance) {
      this.appearance = "outline";
    }
  }
};
__decorate$1([
  attr$1
], FASTTextArea.prototype, "appearance", void 0);
FASTTextArea = __decorate$1([
  customElement$1({
    name: "fast-text-area",
    template: TextAreaTemplate,
    styles: TextAreaStyles,
    shadowOptions: {
      delegatesFocus: true
    }
  })
], FASTTextArea);
const TextFieldStyles = css$4`
    ${display("inline-block")} :host {
        font-family: var(--body-font);
        outline: none;
        user-select: none;
    }

    .root {
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: row;
        color: ${neutralForegroundRestBehavior.var};
        background: ${neutralFillInputRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
        border: calc(var(--outline-width) * 1px) solid ${accentFillRestBehavior.var};
        height: calc(${heightNumber} * 1px);
    }

    .control {
        -webkit-appearance: none;
        font: inherit;
        background: transparent;
        border: 0;
        color: inherit;
        height: calc(100% - 4px);
        width: 100%;
        margin-top: auto;
        margin-bottom: auto;
        border: none;
        padding: 0 calc(var(--design-unit) * 2px + 1px);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
    }

    .control:hover,
    .control:${focusVisible},
    .control:disabled,
    .control:active {
        outline: none;
    }

    .label {
        display: block;
        color: ${neutralForegroundRestBehavior.var};
        cursor: pointer;
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        margin-bottom: 4px;
    }

    .label__hidden {
        display: none;
        visibility: hidden;
    }

    .start,
    .end {
        margin: auto;
        fill: currentcolor;
    }

    ::slotted(svg) {
        ${""} width: 16px;
        height: 16px;
    }

    .start {
        margin-inline-start: 11px;
    }

    .end {
        margin-inline-end: 11px;
    }

    :host(:hover:not([disabled])) .root {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${accentFillHoverBehavior.var};
    }

    :host(:active:not([disabled])) .root {
        background: ${neutralFillInputHoverBehavior.var};
        border-color: ${accentFillActiveBehavior.var};
    }

    :host(:focus-within:not([disabled])) .root {
        border-color: ${neutralFocusBehavior.var};
        box-shadow: 0 0 0 1px ${neutralFocusBehavior.var} inset;
    }

    :host([appearance="filled"]) .root {
        background: ${neutralFillRestBehavior.var};
    }

    :host([appearance="filled"]:hover:not([disabled])) .root {
        background: ${neutralFillHoverBehavior.var};
    }

    :host([disabled]) .label,
    :host([readonly]) .label,
    :host([readonly]) .control,
    :host([disabled]) .control {
        cursor: ${disabledCursor};
    }

    :host([disabled]) {
        opacity: var(--disabled-opacity);
    }

    :host([disabled]) .control {
        border-color: ${neutralOutlineRestBehavior.var};
    }
`.withBehaviors(accentFillActiveBehavior, accentFillHoverBehavior, accentFillRestBehavior, neutralFillHoverBehavior, neutralFillInputHoverBehavior, neutralFillInputRestBehavior, neutralFillRestBehavior, neutralFocusBehavior, neutralForegroundRestBehavior, neutralOutlineRestBehavior, forcedColorsStylesheetBehavior(css$4`
            .root,
            :host([appearance="filled"]) .root {
                forced-color-adjust: none;
                background: ${SystemColors.Field};
                border-color: ${SystemColors.FieldText};
            }
            :host(:hover:not([disabled])) .root,
            :host([appearance="filled"]:hover:not([disabled])) .root,
            :host([appearance="filled"]:hover) .root {
                background: ${SystemColors.Field};
                border-color: ${SystemColors.Highlight};
            }
            .start,
            .end {
                fill: currentcolor;
            }
            :host([disabled]) {
                opacity: 1;
            }
            :host([disabled]) .root,
            :host([appearance="filled"]:hover[disabled]) .root {
                border-color: ${SystemColors.GrayText};
                background: ${SystemColors.Field};
            }
            :host(:focus-within:enabled) .root {
                border-color: ${SystemColors.Highlight};
                box-shadow: 0 0 0 1px ${SystemColors.Highlight} inset;
            }
        `));
let FASTTextField = class FASTTextField2 extends TextField {
  connectedCallback() {
    super.connectedCallback();
    if (!this.appearance) {
      this.appearance = "outline";
    }
  }
};
__decorate$1([
  attr$1
], FASTTextField.prototype, "appearance", void 0);
FASTTextField = __decorate$1([
  customElement$1({
    name: "fast-text-field",
    template: TextFieldTemplate,
    styles: TextFieldStyles,
    shadowOptions: {
      delegatesFocus: true
    }
  })
], FASTTextField);
const TreeViewStyles = css$4`
    :host([hidden]) {
        display: none;
    }

    ${display("flex")} :host {
        flex-direction: column;
        align-items: stretch;
        min-width: fit-content;
        font-size: 0;
    }

    :host:focus-visible {
        outline: none;
    }
`;
let FASTTreeView = class FASTTreeView2 extends TreeView {
};
FASTTreeView = __decorate$1([
  customElement$1({
    name: "fast-tree-view",
    template: TreeViewTemplate,
    styles: TreeViewStyles
  })
], FASTTreeView);
const ltr = css$4`
    .expand-collapse-glyph {
        transform: rotate(0deg);
    }
    :host(.nested) .expand-collapse-button {
        left: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
    }
    :host([selected])::after {
        left: calc(var(--focus-outline-width) * 1px);
    }
    :host([expanded]) > .positioning-region .expand-collapse-glyph {
        transform: rotate(45deg);
    }
`;
const rtl = css$4`
    .expand-collapse-glyph {
        transform: rotate(180deg);
    }
    :host(.nested) .expand-collapse-button {
        right: var(--expand-collapse-button-nested-width, calc(${heightNumber} * -1px));
    }
    :host([selected])::after {
        right: calc(var(--focus-outline-width) * 1px);
    }
    :host([expanded]) > .positioning-region .expand-collapse-glyph {
        transform: rotate(135deg);
    }
`;
const expandCollapseButtonSize = "((var(--base-height-multiplier) / 2) * var(--design-unit)) + ((var(--design-unit) * var(--density)) / 2)";
const expandCollapseHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-stealth-hover-over-hover", (x2) => neutralFillStealthHover(neutralFillStealthHover)(x2), FASTDesignSystemProvider.findProvider);
const selectedExpandCollapseHoverBehavior = cssCustomPropertyBehaviorFactory("neutral-stealth-hover-over-selected", (x2) => neutralFillStealthHover(neutralFillStealthSelected)(x2), FASTDesignSystemProvider.findProvider);
const TreeItemStyles = css$4`
    ${display("block")} :host {
        contain: content;
        position: relative;
        outline: none;
        color: ${neutralForegroundRestBehavior.var};
        background: ${neutralFillStealthRestBehavior.var};
        cursor: pointer;
        font-family: var(--body-font);
        --expand-collapse-button-size: calc(${heightNumber} * 1px);
        --tree-item-nested-width: 0;
    }

    :host(:focus) > .positioning-region {
        outline: none;
    }

    :host(:focus) .content-region {
        outline: none;
    }

    :host(:${focusVisible}) .positioning-region {
        border: ${neutralFocusBehavior.var} calc(var(--outline-width) * 1px) solid;
        border-radius: calc(var(--corner-radius) * 1px);
        color: ${neutralForegroundActiveBehavior.var};
    }

    .positioning-region {
        display: flex;
        position: relative;
        box-sizing: border-box;
        border: transparent calc(var(--outline-width) * 1px) solid;
        height: calc((${heightNumber} + 1) * 1px);
    }

    .positioning-region::before {
        content: "";
        display: block;
        width: var(--tree-item-nested-width);
        flex-shrink: 0;
    }

    .positioning-region:hover {
        background: ${neutralFillStealthHoverBehavior.var};
    }

    .positioning-region:active {
        background: ${neutralFillStealthActiveBehavior.var};
    }

    .content-region {
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
        width: 100%;
        height: calc(${heightNumber} * 1px);
        margin-inline-start: calc(var(--design-unit) * 2px + 8px);
        font-size: var(--type-ramp-base-font-size);
        line-height: var(--type-ramp-base-line-height);
        font-weight: 400;
    }

    .items {
        display: none;
        ${""} font-size: calc(1em + (var(--design-unit) + 16) * 1px);
    }

    .expand-collapse-button {
        background: none;
        border: none;
        outline: none;
        ${""} width: calc((${expandCollapseButtonSize} + (var(--design-unit) * 2)) * 1px);
        height: calc((${expandCollapseButtonSize} + (var(--design-unit) * 2)) * 1px);
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        margin-left: 6px;
        margin-right: 6px;
    }

    .expand-collapse-glyph {
        ${""} width: 16px;
        height: 16px;
        transition: transform 0.1s linear;

        pointer-events: none;
        fill: currentcolor;
    }

    .start,
    .end {
        display: flex;
        fill: currentcolor;
    }

     ::slotted(svg) {
        ${""} width: 16px;
        height: 16px;
    }

    .start {
        ${""} margin-inline-end: calc(var(--design-unit) * 2px + 2px);
    }

    .end {
        ${""} margin-inline-start: calc(var(--design-unit) * 2px + 2px);
    }

    :host([expanded]) > .items {
        display: block;
    }

    :host([disabled]) .content-region {
        opacity: var(--disabled-opacity);
        cursor: ${disabledCursor};
    }

    :host(.nested) .content-region {
        position: relative;
        margin-inline-start: var(--expand-collapse-button-size);
    }

    :host(.nested) .expand-collapse-button {
        position: absolute;
    }

    :host(.nested) .expand-collapse-button:hover {
        background: ${expandCollapseHoverBehavior.var};
    }
    
    :host([selected]) .positioning-region {
        background: ${neutralFillStealthSelectedBehavior.var};
    }

    :host([selected]) .expand-collapse-button:hover {
        background: ${selectedExpandCollapseHoverBehavior.var};
    }

    :host([selected])::after {
        content: "";
        display: block;
        position: absolute;
        top: calc((${heightNumber} / 4) * 1px);
        width: 3px;
        height: calc((${heightNumber} / 2) * 1px);
        ${""} background: ${accentForegroundRestBehavior.var};
        border-radius: calc(var(--corner-radius) * 1px);
    }

    ::slotted(fast-tree-item) {
        --tree-item-nested-width: 1em;
        --expand-collapse-button-nested-width: calc(${heightNumber} * -1px);
    }
`.withBehaviors(accentForegroundRestBehavior, neutralFillStealthSelectedBehavior, neutralFillStealthActiveBehavior, expandCollapseHoverBehavior, neutralFillStealthHoverBehavior, selectedExpandCollapseHoverBehavior, neutralFillStealthRestBehavior, neutralFocusBehavior, neutralFocusInnerAccentBehavior, neutralForegroundActiveBehavior, neutralForegroundRestBehavior, new DirectionalStyleSheetBehavior(ltr, rtl), forcedColorsStylesheetBehavior(css$4`
        :host {
            forced-color-adjust: none;
            border-color: transparent;
            background: ${SystemColors.Field};
            color: ${SystemColors.FieldText};
        }
        :host .content-region .expand-collapse-glyph {
            fill: ${SystemColors.FieldText};
        }
        :host .positioning-region:hover,
        :host([selected]) .positioning-region {
            background: ${SystemColors.Highlight};
        }
        :host .positioning-region:hover .content-region,
        :host([selected]) .positioning-region .content-region {
            color: ${SystemColors.HighlightText};
        }
        :host .positioning-region:hover .content-region .expand-collapse-glyph,
        :host .positioning-region:hover .content-region .start,
        :host .positioning-region:hover .content-region .end,
        :host([selected]) .content-region .expand-collapse-glyph,
        :host([selected]) .content-region .start,
        :host([selected]) .content-region .end {
            fill: ${SystemColors.HighlightText};
        }
        :host([selected])::after {
            background: ${SystemColors.Field};
        }
        :host(:${focusVisible}) .positioning-region {
            border-color: ${SystemColors.FieldText};
            box-shadow: 0 0 0 2px inset ${SystemColors.Field};
            color: ${SystemColors.FieldText};
        }
        :host([disabled]) .content-region,
        :host([disabled]) .positioning-region:hover .content-region {
            opacity: 1;
            color: ${SystemColors.GrayText};
        }
        :host([disabled]) .content-region .expand-collapse-glyph,
        :host([disabled]) .content-region .start,
        :host([disabled]) .content-region .end,
        :host([disabled]) .positioning-region:hover .content-region .expand-collapse-glyph,
        :host([disabled]) .positioning-region:hover .content-region .start,
        :host([disabled]) .positioning-region:hover .content-region .end {
            fill: ${SystemColors.GrayText};
        }
        :host([disabled]) .positioning-region:hover {
            background: ${SystemColors.Field};
        }
        .expand-collapse-glyph,
        .start,
        .end {
            fill: ${SystemColors.FieldText};
        }
        :host(.nested) .expand-collapse-button:hover {
            background: ${SystemColors.Field};
        }
        :host(.nested) .expand-collapse-button:hover .expand-collapse-glyph {
            fill: ${SystemColors.FieldText};
        }
        `));
let FASTTreeItem = class FASTTreeItem2 extends TreeItem {
};
FASTTreeItem = __decorate$1([
  customElement$1({
    name: "fast-tree-item",
    template: TreeItemTemplate,
    styles: TreeItemStyles
  })
], FASTTreeItem);
function noop$1() {
}
const identity$4 = (x2) => x2;
function assign$1(tar, src) {
  for (const k2 in src)
    tar[k2] = src[k2];
  return tar;
}
function is_promise(value2) {
  return value2 && typeof value2 === "object" && typeof value2.then === "function";
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj2) {
  return Object.keys(obj2).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function null_to_empty(value2) {
  return value2 == null ? "" : value2;
}
function set_store_value(store, ret, value2) {
  store.set(value2);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
const is_client = typeof window !== "undefined";
let now$1 = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append$1(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles2) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles2;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root2 = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root2 && root2.host) {
    return root2;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append$1(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text$1(data) {
  return document.createTextNode(data);
}
function space() {
  return text$1(" ");
}
function empty() {
  return text$1("");
}
function listen(node, event2, handler, options2) {
  node.addEventListener(event2, handler, options2);
  return () => node.removeEventListener(event2, handler, options2);
}
function self$1(fn2) {
  return function(event2) {
    if (event2.target === this)
      fn2.call(this, event2);
  };
}
function attr(node, attribute, value2) {
  if (value2 == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value2)
    node.setAttribute(attribute, value2);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function set_custom_element_data(node, prop, value2) {
  if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value2 === "" ? true : value2;
  } else {
    attr(node, prop, value2);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value2, important) {
  if (value2 === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value2, important ? "important" : "");
  }
}
let crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = false;
    try {
      if (typeof window !== "undefined" && window.parent) {
        void window.parent.document;
      }
    } catch (error2) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_resize_listener(node, fn2) {
  const computed_style = getComputedStyle(node);
  if (computed_style.position === "static") {
    node.style.position = "relative";
  }
  const iframe = element("iframe");
  iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
  iframe.setAttribute("aria-hidden", "true");
  iframe.tabIndex = -1;
  const crossorigin2 = is_crossorigin();
  let unsubscribe;
  if (crossorigin2) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
    unsubscribe = listen(window, "message", (event2) => {
      if (event2.source === iframe.contentWindow)
        fn2();
    });
  } else {
    iframe.src = "about:blank";
    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, "resize", fn2);
    };
  }
  append$1(node, iframe);
  return () => {
    if (crossorigin2) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type2, detail, bubbles = false) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type2, bubbles, false, detail);
  return e;
}
class HtmlTag {
  constructor() {
    this.e = this.n = null;
  }
  c(html2) {
    this.h(html2);
  }
  m(html2, target, anchor = null) {
    if (!this.e) {
      this.e = element(target.nodeName);
      this.t = target;
      this.c(html2);
    }
    this.i(anchor);
  }
  h(html2) {
    this.e.innerHTML = html2;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  p(html2) {
    this.d();
    this.h(html2);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str2) {
  let hash2 = 5381;
  let i2 = str2.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str2.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay2, ease, fn2, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t = a + (b - a) * ease(p2);
    keyframes += p2 * 100 + `%{${fn2(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn2(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay2}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous2 = (node.style.animation || "").split(", ");
  const next2 = previous2.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous2.length - next2.length;
  if (deleted) {
    node.style.animation = next2.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { stylesheet } = info;
      let i2 = stylesheet.cssRules.length;
      while (i2--)
        stylesheet.deleteRule(i2);
      info.rules = {};
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function onDestroy(fn2) {
  get_current_component().$$.on_destroy.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type2, detail) => {
    const callbacks = component.$$.callbacks[type2];
    if (callbacks) {
      const event2 = custom_event(type2, detail);
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event2);
      });
    }
  };
}
function bubble(component, event2) {
  const callbacks = component.$$.callbacks[event2.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event2));
  }
}
const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function add_flush_callback(fn2) {
  flush_callbacks.push(fn2);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block2, local) {
  if (block2 && block2.i) {
    outroing.delete(block2);
    block2.i(local);
  }
}
function transition_out(block2, local, detach2, callback) {
  if (block2 && block2.o) {
    if (outroing.has(block2))
      return;
    outroing.add(block2);
    outros.c.push(() => {
      outroing.delete(block2);
      if (callback) {
        if (detach2)
          block2.d(1);
        callback();
      }
    });
    block2.o(local);
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn2, params) {
  let config2 = fn2(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay: delay2 = 0, duration = 300, easing = identity$4, tick = noop$1, css: css2 } = config2 || null_transition;
    if (css2)
      animation_name = create_rule(node, 0, 1, duration, delay2, easing, css2, uid++);
    tick(0, 1);
    const start_time = now$1() + delay2;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config2)) {
        config2 = config2();
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn2, params) {
  let config2 = fn2(node, params);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay: delay2 = 0, duration = 300, easing = identity$4, tick = noop$1, css: css2 } = config2 || null_transition;
    if (css2)
      animation_name = create_rule(node, 1, 0, duration, delay2, easing, css2);
    const start_time = now$1() + delay2;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config2)) {
    wait().then(() => {
      config2 = config2();
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config2.tick) {
        config2.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn2, params, intro) {
  let config2 = fn2(node, params);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay: delay2 = 0, duration = 300, easing = identity$4, tick = noop$1, css: css2 } = config2 || null_transition;
    const program = {
      start: now$1() + delay2,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css2) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay2, easing, css2);
      }
      if (b)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css2) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config2.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p2 = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config2)) {
        wait().then(() => {
          config2 = config2();
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update2(type2, index2, key, value2) {
    if (info.token !== token)
      return;
    info.resolved = value2;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value2;
    }
    const block2 = type2 && (info.current = type2)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block22, i2) => {
          if (i2 !== index2 && block22) {
            group_outros();
            transition_out(block22, 1, 1, () => {
              if (info.blocks[i2] === block22) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block2.c();
      transition_in(block2, 1);
      block2.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block2;
    if (info.blocks)
      info.blocks[index2] = block2;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then((value2) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value2);
      set_current_component(null);
    }, (error2) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error2);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error2;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o = levels[i2];
    const n2 = updates[i2];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name, callback) {
  const index2 = component.$$.props[name];
  if (index2 !== void 0) {
    component.$$.bound[index2] = callback;
    callback(component.$$.ctx[index2]);
  }
}
function create_component(block2) {
  block2 && block2.c();
}
function mount_component(component, target, anchor, customElement2) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement2) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init$1(component, options2, instance2, create_fragment2, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options2.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options2.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options2.props || {}, (i2, ret, ...rest) => {
    const value2 = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value2)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value2);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options2.target) {
    if (options2.hydrate) {
      const nodes = children(options2.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options2.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options2.target, options2.anchor, options2.customElement);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  $on(type2, callback) {
    const callbacks = this.$$.callbacks[type2] || (this.$$.callbacks[type2] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
function checkIframe(element2) {
  if (element2.ownerDocument !== document) {
    const iframes = Array.from(document.querySelectorAll("iframe"));
    return iframes.find((iframe) => iframe.contentDocument === element2.ownerDocument);
  }
}
function checkIgnore(element2) {
  try {
    if (element2.classList.contains("iteria-ignore"))
      return true;
    if (element2.tagName === "BODY")
      return false;
    return checkIgnore(element2.parentElement);
  } catch (error2) {
    return true;
  }
}
function isBlue(element2) {
  const rgb = window.getComputedStyle(element2, null).backgroundColor;
  if (rgb) {
    const colors2 = [];
    rgb.replace(/\d+/g, (color2) => {
      colors2.push(parseInt(color2));
      return "";
    });
    if (colors2.length >= 3) {
      if (typeof colors2[3] !== "undefined") {
        if (colors2[3] < 0.5) {
          if (element2.tagName === "BODY")
            return false;
          return isBlue(element2.parentElement);
        }
      }
      if (colors2[0] < colors2[2] && colors2[1] < colors2[2])
        return true;
    }
  }
  return false;
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity$4 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function fly(node, { delay: delay2 = 0, duration = 400, easing = cubicOut, x: x2 = 0, y: y2 = 0, opacity = 0 } = {}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform2 = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  return {
    delay: delay2,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform2} translate(${(1 - t) * x2}px, ${(1 - t) * y2}px);
			opacity: ${target_opacity - od * u}`
  };
}
function slide(node, { delay: delay2 = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay: delay2,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}
const { window: window_1$3 } = globals;
function create_if_block$g(ctx) {
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let div4_transition;
  let t3;
  let style;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      t3 = space();
      style = element("style");
      style.textContent = ".overlay {\n      position: fixed;\n      background: #44444488;\n      z-index: 9999;\n    }\n    .overlay-1 {\n      top: var(--offset-top);\n      left: var(--offset-left);\n      width: calc(var(--offset-right) - var(--offset-left));\n      height: calc(var(--local-top));\n    }\n    .overlay-2 {\n      top: calc(var(--local-top) + var(--offset-top));\n      left: calc(var(--offset-left) + var(--local-right));\n      width: calc(var(--offset-right) - var(--local-right));\n      height: calc(var(--local-bottom) - var(--local-top));\n    }\n    .overlay-3 {\n      top: calc(var(--offset-top) + var(--local-bottom));\n      left: var(--offset-left);\n      width: calc(var(--offset-right) - var(--offset-left));\n      height: calc(\n        var(--offset-bottom) - var(--offset-top) - var(--local-top) -\n          var(--local-height)\n      );\n    }\n    .overlay-4 {\n      top: calc(var(--local-top) + var(--offset-top));\n      left: var(--offset-left);\n      width: var(--local-left);\n      height: calc(var(--local-bottom) - var(--local-top));\n    }";
      attr(div0, "class", "overlay overlay-1");
      attr(div1, "class", "overlay overlay-2");
      attr(div2, "class", "overlay overlay-3");
      attr(div3, "class", "overlay overlay-4");
      attr(div4, "class", "overlays iteria-ignore");
      attr(div4, "style", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append$1(div4, div0);
      append$1(div4, t0);
      append$1(div4, div1);
      append$1(div4, t1);
      append$1(div4, div2);
      append$1(div4, t2);
      append$1(div4, div3);
      insert(target, t3, anchor);
      insert(target, style, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "pointerenter", ctx[15]),
          listen(div0, "click", ctx[16]),
          listen(div1, "pointerenter", ctx[13]),
          listen(div1, "click", ctx[14]),
          listen(div2, "pointerenter", ctx[11]),
          listen(div2, "click", ctx[12]),
          listen(div3, "pointerenter", ctx[9]),
          listen(div3, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2) {
        attr(div4, "style", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div4_transition)
          div4_transition = create_bidirectional_transition(div4, fade, {}, true);
        div4_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div4_transition)
        div4_transition = create_bidirectional_transition(div4, fade, {}, false);
      div4_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching && div4_transition)
        div4_transition.end();
      if (detaching)
        detach(t3);
      if (detaching)
        detach(style);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$C(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && create_if_block$g(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window_1$3, "resize", ctx[2]),
          listen(window_1$3, "keyup", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
const stroke = 2;
function instance$z($$self, $$props, $$invalidate) {
  let { element: element2 } = $$props;
  let { firstElement } = $$props;
  let { lastElement } = $$props;
  let overlayVars = "";
  let iframe = null;
  let removeScrollEventListeners = () => null;
  let elementBoundries = null;
  let firstElementBoundries = null;
  let lastElementBoundries = null;
  let iframeBoundries = null;
  function update2() {
    if (checkIgnore(element2))
      return;
    iframe = checkIframe(element2);
    window["iframe"] = iframe;
    updateBoundries();
    const win = iframe ? iframe.contentWindow : window;
    win.removeEventListener("scroll", updateBoundries, true);
    win.addEventListener("scroll", updateBoundries, true);
  }
  function updateBoundries() {
    $$invalidate(5, elementBoundries = element2.getBoundingClientRect());
    if (firstElement && lastElement) {
      $$invalidate(6, firstElementBoundries = firstElement.getBoundingClientRect());
      $$invalidate(7, lastElementBoundries = lastElement.getBoundingClientRect());
    }
    if (iframe) {
      $$invalidate(8, iframeBoundries = iframe.getBoundingClientRect());
    } else {
      $$invalidate(8, iframeBoundries = {
        top: 0,
        left: 0,
        x: 0,
        y: 0,
        right: window.innerWidth,
        bottom: window.innerHeight,
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
  }
  onDestroy(() => removeScrollEventListeners());
  function pointerenter_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  function pointerenter_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  function pointerenter_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function pointerenter_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function click_handler2(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("firstElement" in $$props2)
      $$invalidate(3, firstElement = $$props2.firstElement);
    if ("lastElement" in $$props2)
      $$invalidate(4, lastElement = $$props2.lastElement);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (element2)
        update2();
    }
    if ($$self.$$.dirty & 480) {
      if (elementBoundries) {
        $$invalidate(1, overlayVars = `
    --stroke: ${stroke}px;

    --local-top: ${(elementBoundries == null ? void 0 : elementBoundries.top) - stroke}px;
    --local-right: ${(elementBoundries == null ? void 0 : elementBoundries.right) + stroke}px;
    --local-bottom: ${(elementBoundries == null ? void 0 : elementBoundries.bottom) + stroke}px;
    --local-left: ${(elementBoundries == null ? void 0 : elementBoundries.left) - stroke}px;
    --local-width: ${elementBoundries == null ? void 0 : elementBoundries.width}px;
    --local-height: ${(elementBoundries == null ? void 0 : elementBoundries.height) - stroke}px;

    --offset-top: ${iframeBoundries ? iframeBoundries.top : 0}px;
    --offset-left: ${iframeBoundries ? iframeBoundries.left : 0}px;
    --offset-right: ${iframeBoundries ? iframeBoundries.right : 0}px;
    --offset-bottom: ${iframeBoundries ? iframeBoundries.bottom : 0}px;
    --offset-width: ${iframeBoundries ? iframeBoundries.width : 0}px;
    --offset-height: ${iframeBoundries ? iframeBoundries.height : 0}px;
    `);
        if (firstElementBoundries && lastElementBoundries) {
          $$invalidate(1, overlayVars = `
    --stroke: ${stroke}px;
    --local-top: ${firstElementBoundries.top - stroke}px;
    --local-right: ${lastElementBoundries.right + stroke}px;
    --local-bottom: ${lastElementBoundries.bottom + stroke}px;
    --local-left: ${firstElementBoundries.left - stroke}px;
    --local-width: ${lastElementBoundries.width}px;
    --local-height: ${lastElementBoundries.height - stroke}px;
    --offset-top: ${iframeBoundries ? iframeBoundries.top : 0}px;
    --offset-left: ${iframeBoundries ? iframeBoundries.left : 0}px;
    --offset-right: ${iframeBoundries ? iframeBoundries.right : 0}px;
    --offset-bottom: ${iframeBoundries ? iframeBoundries.bottom : 0}px;
    --offset-width: ${iframeBoundries ? iframeBoundries.width : 0}px;
    --offset-height: ${iframeBoundries ? iframeBoundries.height : 0}px;
    `);
        }
      }
    }
  };
  return [
    element2,
    overlayVars,
    update2,
    firstElement,
    lastElement,
    elementBoundries,
    firstElementBoundries,
    lastElementBoundries,
    iframeBoundries,
    pointerenter_handler_3,
    click_handler_3,
    pointerenter_handler_2,
    click_handler_2,
    pointerenter_handler_1,
    click_handler_1,
    pointerenter_handler,
    click_handler2
  ];
}
class WidgetElevation extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$z, create_fragment$C, safe_not_equal, {
      element: 0,
      firstElement: 3,
      lastElement: 4
    });
  }
}
const settings = `<svg xmlns="http://www.w3.org/2000/svg" width="18px" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.09-.16-.26-.25-.44-.25-.06 0-.12.01-.17.03l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.06-.02-.12-.03-.18-.03-.17 0-.34.09-.43.25l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.09.16.26.25.44.25.06 0 .12-.01.17-.03l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.06.02.12.03.18.03.17 0 .34-.09.43-.25l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-1.98-1.71c.04.31.05.52.05.73 0 .21-.02.43-.05.73l-.14 1.13.89.7 1.08.84-.7 1.21-1.27-.51-1.04-.42-.9.68c-.43.32-.84.56-1.25.73l-1.06.43-.16 1.13-.2 1.35h-1.4l-.19-1.35-.16-1.13-1.06-.43c-.43-.18-.83-.41-1.23-.71l-.91-.7-1.06.43-1.27.51-.7-1.21 1.08-.84.89-.7-.14-1.13c-.03-.31-.05-.54-.05-.74s.02-.43.05-.73l.14-1.13-.89-.7-1.08-.84.7-1.21 1.27.51 1.04.42.9-.68c.43-.32.84-.56 1.25-.73l1.06-.43.16-1.13.2-1.35h1.39l.19 1.35.16 1.13 1.06.43c.43.18.83.41 1.23.71l.91.7 1.06-.43 1.27-.51.7 1.21-1.07.85-.89.7.14 1.13zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>`;
const clear = `<svg xmlns="http://www.w3.org/2000/svg" width="18px" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>`;
const content_copy = `<svg xmlns="http://www.w3.org/2000/svg" width="18px" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>`;
const code = `<svg xmlns="http://www.w3.org/2000/svg" width="18px" viewBox="0 0 24 24" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/></svg>`;
const edit = `<?xml version="1.0" encoding="iso-8859-1"?><!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" fill="currentColor" width="18px" height="18px" viewBox="0 0 494.936 494.936" style="enable-background:new 0 0 494.936 494.936;"	 xml:space="preserve"><g>	<g>		<path d="M389.844,182.85c-6.743,0-12.21,5.467-12.21,12.21v222.968c0,23.562-19.174,42.735-42.736,42.735H67.157			c-23.562,0-42.736-19.174-42.736-42.735V150.285c0-23.562,19.174-42.735,42.736-42.735h267.741c6.743,0,12.21-5.467,12.21-12.21			s-5.467-12.21-12.21-12.21H67.157C30.126,83.13,0,113.255,0,150.285v267.743c0,37.029,30.126,67.155,67.157,67.155h267.741			c37.03,0,67.156-30.126,67.156-67.155V195.061C402.054,188.318,396.587,182.85,389.844,182.85z"/>		<path d="M483.876,20.791c-14.72-14.72-38.669-14.714-53.377,0L221.352,229.944c-0.28,0.28-3.434,3.559-4.251,5.396l-28.963,65.069			c-2.057,4.619-1.056,10.027,2.521,13.6c2.337,2.336,5.461,3.576,8.639,3.576c1.675,0,3.362-0.346,4.96-1.057l65.07-28.963			c1.83-0.815,5.114-3.97,5.396-4.25L483.876,74.169c7.131-7.131,11.06-16.61,11.06-26.692			C494.936,37.396,491.007,27.915,483.876,20.791z M466.61,56.897L257.457,266.05c-0.035,0.036-0.055,0.078-0.089,0.107			l-33.989,15.131L238.51,247.3c0.03-0.036,0.071-0.055,0.107-0.09L447.765,38.058c5.038-5.039,13.819-5.033,18.846,0.005			c2.518,2.51,3.905,5.855,3.905,9.414C470.516,51.036,469.127,54.38,466.61,56.897z"/>	</g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g></svg>`;
const addColumn$2 = `<img style="height:inherit;" src="https://img.icons8.com/ios/30/000000/add-column.png"/>`;
const remove = `<span class=""> <svg focusable="false" width="20" height="20" viewBox="0 0 24 24" class=" NMm5M" > <path fill="currentColor" d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13z" /><path fill="currentColor" d="M9 8h2v9H9zm4 0h2v9h-2z" /> </svg> </span>`;
const check = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="18px" height="18px" viewBox="0 0 24 24" fill="currentColor"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" /></svg>`;
const drag_move = `<svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"></path><path d="M18 11V8l4 4-4 4v-3h-5v5h3l-4 4-4-4h3v-5H6v3l-4-4 4-4v3h5V6H8l4-4 4 4h-3v5z"></path></g></svg>`;
const icons$1 = {
  settings,
  clear,
  content_copy,
  code,
  edit,
  addColumn: addColumn$2,
  remove,
  check,
  drag_move
};
function css$3(node, properties) {
  function setProperties() {
    for (const prop of Object.keys(properties)) {
      node.style.setProperty(`--${prop}`, properties[prop]);
    }
  }
  setProperties();
  return {
    update(newProperties) {
      properties = newProperties;
      setProperties();
    }
  };
}
function add_css$e(target) {
  append_styles(target, "svelte-1tsgq7s", ".tip-note-wrapper.svelte-1tsgq7s.svelte-1tsgq7s{position:absolute;display:flex;flex-direction:column;width:max-content;z-index:100000;background-color:var(--tipNotesBgColor);border-radius:0.5rem;max-width:25rem;-webkit-transition:background-color 600ms ease-in-out;-moz-transition:background-color 600ms ease-in-out;-o-transition:background-color 600ms ease-in-out;transition:background-color 600ms ease-in-out}.tip-note-head.svelte-1tsgq7s.svelte-1tsgq7s{display:flex;padding:1rem;align-items:center}.tip-header.svelte-1tsgq7s.svelte-1tsgq7s{font-weight:600;font-size:x-large;padding:1rem}.extra-notes.svelte-1tsgq7s.svelte-1tsgq7s{margin:1rem;display:flex;flex-direction:column;backdrop-filter:blur(30px)}.extra-wrapper.svelte-1tsgq7s.svelte-1tsgq7s{padding:0.5rem;background-color:white;border-radius:5px;margin-left:auto}.extra-wrapper.svelte-1tsgq7s .text.svelte-1tsgq7s{font-weight:600;font-size:x-large}.extra-notes.svelte-1tsgq7s .header.svelte-1tsgq7s{text-decoration:underline;font-weight:600;font-size:large}.extra-notes.svelte-1tsgq7s .text.svelte-1tsgq7s{font-weight:300;padding-top:0.5rem}.header-prev-input.svelte-1tsgq7s.svelte-1tsgq7s{font-weight:400;font-size:smaller;color:#666666}.header-new-input.svelte-1tsgq7s.svelte-1tsgq7s{font-weight:500;font-size:medium}.extra-notes.svelte-1tsgq7s .text.svelte-1tsgq7s{border:0.5rem;width:100%;padding:12px 20px;box-sizing:border-box;border-radius:0.3rem;border:0.5rem;width:100%;padding:12px 20px;box-sizing:border-box;border-radius:0.3rem;text-decoration:none;font-family:inherit;font-weight:300;font-size:smaller;margin:8px 0px;max-height:150px;max-width:100%;min-width:100%;min-height:60px}.extra-notes.svelte-1tsgq7s .text.disabled.svelte-1tsgq7s{background-color:#bfbfbf}.extra-notes.svelte-1tsgq7s .text.contenteditable.svelte-1tsgq7s{background-color:white}.tips.svelte-1tsgq7s.svelte-1tsgq7s{border-radius:1rem 1rem 0.5rem 0.5rem;background-color:#e9e9e9}.tip.svelte-1tsgq7s.svelte-1tsgq7s{display:flex;flex-direction:column;padding:1rem;margin:1rem;border-radius:0.5rem;-webkit-transition:background-color 300ms ease-in-out;-moz-transition:background-color 300ms ease-in-out;-o-transition:background-color 300ms ease-in-out;transition:background-color 300ms ease-in-out}.tip.svelte-1tsgq7s.svelte-1tsgq7s:not(:last-child){margin-bottom:0.5rem}.tip-icon.svelte-1tsgq7s.svelte-1tsgq7s{color:black;padding-right:0.5rem}.tip-title.svelte-1tsgq7s.svelte-1tsgq7s{display:flex;font-weight:600}.tip-text.svelte-1tsgq7s.svelte-1tsgq7s{font-weight:300;padding-top:0.5rem}.tip.svelte-1tsgq7s.svelte-1tsgq7s:hover,.hovered.svelte-1tsgq7s.svelte-1tsgq7s{background-color:var(--tipHoverBgColor);cursor:pointer}.tip.active.svelte-1tsgq7s.svelte-1tsgq7s{background-color:#e9e9e9}.tip-note-wrapper.right.svelte-1tsgq7s.svelte-1tsgq7s{bottom:0;right:0;margin-right:3rem;margin-bottom:3rem}.tip-note-wrapper.left.svelte-1tsgq7s.svelte-1tsgq7s{bottom:0;left:0;margin-left:3rem;margin-bottom:3rem}.close.svelte-1tsgq7s.svelte-1tsgq7s{cursor:pointer;margin-left:1rem;transform:translate(0, -30%)}");
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_if_block_2$7(ctx) {
  let div2;
  let span;
  return {
    c() {
      div2 = element("div");
      span = element("span");
      span.textContent = `${ctx[12].toUpperCase()}`;
      attr(span, "class", "text svelte-1tsgq7s");
      attr(div2, "class", "extra-wrapper svelte-1tsgq7s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, span);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_if_block_1$b(ctx) {
  var _a2;
  let div0;
  let span0;
  let t0_value = ((_a2 = ctx[0]) == null ? void 0 : _a2.formattedMessageElement.dataset.messageId) + "";
  let t0;
  let t1;
  let span1;
  let t3;
  let div3;
  let span2;
  let div1;
  let t5;
  let span3;
  let t7;
  let div2;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      span0 = element("span");
      t0 = text$1(t0_value);
      t1 = space();
      span1 = element("span");
      span1.textContent = "Currently selected key to translate";
      t3 = space();
      div3 = element("div");
      span2 = element("span");
      span2.textContent = "New translation:";
      div1 = element("div");
      t5 = space();
      span3 = element("span");
      span3.textContent = "Previous translation:";
      t7 = space();
      div2 = element("div");
      attr(span0, "class", "header svelte-1tsgq7s");
      attr(span1, "class", "text svelte-1tsgq7s");
      attr(div0, "class", "extra-notes svelte-1tsgq7s");
      attr(span2, "class", "header-new-input svelte-1tsgq7s");
      attr(div1, "class", "text contenteditable svelte-1tsgq7s");
      attr(div1, "contenteditable", "true");
      attr(span3, "class", "header-prev-input svelte-1tsgq7s");
      attr(div2, "class", "text disabled svelte-1tsgq7s");
      attr(div3, "class", "extra-notes svelte-1tsgq7s");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append$1(div0, span0);
      append$1(span0, t0);
      append$1(div0, t1);
      append$1(div0, span1);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      append$1(div3, span2);
      append$1(div3, div1);
      div1.innerHTML = ctx[4];
      append$1(div3, t5);
      append$1(div3, span3);
      append$1(div3, t7);
      append$1(div3, div2);
      div2.innerHTML = ctx[11];
      if (!mounted) {
        dispose = listen(div1, "input", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a3;
      if (dirty & 1 && t0_value !== (t0_value = ((_a3 = ctx2[0]) == null ? void 0 : _a3.formattedMessageElement.dataset.messageId) + ""))
        set_data(t0, t0_value);
      if (dirty & 16)
        div1.innerHTML = ctx2[4];
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$f(ctx) {
  let div2;
  let span1;
  let span0;
  let raw_value = ctx[18].icon + "";
  let t0;
  let t1_value = ctx[18].title + "";
  let t1;
  let t2;
  let span2;
  let t3_value = ctx[18].text + "";
  let t3;
  let t4;
  let div_class_value;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      span1 = element("span");
      span0 = element("span");
      t0 = space();
      t1 = text$1(t1_value);
      t2 = space();
      span2 = element("span");
      t3 = text$1(t3_value);
      t4 = space();
      attr(span0, "class", "tip-icon svelte-1tsgq7s");
      attr(span1, "class", "tip-title svelte-1tsgq7s");
      attr(span2, "class", "tip-text svelte-1tsgq7s");
      attr(div2, "class", div_class_value = "tip " + (ctx[2] === ctx[18].id ? "active" : "") + " " + (ctx[1] === ctx[18].id ? "hovered" : "") + " svelte-1tsgq7s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, span1);
      append$1(span1, span0);
      span0.innerHTML = raw_value;
      append$1(span1, t0);
      append$1(span1, t1);
      append$1(div2, t2);
      append$1(div2, span2);
      append$1(span2, t3);
      append$1(div2, t4);
      current = true;
      if (!mounted) {
        dispose = listen(div2, "click", function() {
          if (is_function(ctx[9](ctx[18].id)))
            ctx[9](ctx[18].id).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 128) && raw_value !== (raw_value = ctx[18].icon + ""))
        span0.innerHTML = raw_value;
      if ((!current || dirty & 128) && t1_value !== (t1_value = ctx[18].title + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 128) && t3_value !== (t3_value = ctx[18].text + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 134 && div_class_value !== (div_class_value = "tip " + (ctx[2] === ctx[18].id ? "active" : "") + " " + (ctx[1] === ctx[18].id ? "hovered" : "") + " svelte-1tsgq7s")) {
        attr(div2, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, {}, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div2, slide, {}, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[18].display && create_if_block$f(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[18].display) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$B(ctx) {
  var _a2;
  let div2;
  let div0;
  let span0;
  let t0_value = (ctx[2] in ctx[10] ? ctx[10][ctx[2]] : ctx[10]["default"]) + "";
  let t0;
  let t1;
  let t2;
  let span1;
  let raw_value = icons$1["clear"] + "";
  let t3;
  let t4;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let css_action;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[12] && create_if_block_2$7(ctx);
  let if_block1 = ctx[2] === "translate" && ((_a2 = ctx[0]) == null ? void 0 : _a2.formattedMessageElement) !== void 0 && create_if_block_1$b(ctx);
  let each_value = ctx[7];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text$1(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      span1 = element("span");
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span0, "class", "tip-header svelte-1tsgq7s");
      attr(span1, "class", "close svelte-1tsgq7s");
      attr(div0, "class", "tip-note-head svelte-1tsgq7s");
      attr(div1, "class", div1_class_value = null_to_empty(ctx[2] in ctx[10] ? "tips" : "") + " svelte-1tsgq7s");
      attr(div2, "class", div2_class_value = "tip-note-wrapper iteria-ignore " + ctx[3] + " svelte-1tsgq7s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, div0);
      append$1(div0, span0);
      append$1(span0, t0);
      append$1(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append$1(div0, t2);
      append$1(div0, span1);
      span1.innerHTML = raw_value;
      append$1(div2, t3);
      if (if_block1)
        if_block1.m(div2, null);
      append$1(div2, t4);
      append$1(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(span1, "click", ctx[14]),
          action_destroyer(css_action = css$3.call(null, div2, {
            tipNotesBgColor: ctx[6],
            tipHoverBgColor: ctx[5]
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a3;
      if ((!current || dirty & 4) && t0_value !== (t0_value = (ctx2[2] in ctx2[10] ? ctx2[10][ctx2[2]] : ctx2[10]["default"]) + ""))
        set_data(t0, t0_value);
      if (ctx2[12])
        if_block0.p(ctx2, dirty);
      if (ctx2[2] === "translate" && ((_a3 = ctx2[0]) == null ? void 0 : _a3.formattedMessageElement) !== void 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$b(ctx2);
          if_block1.c();
          if_block1.m(div2, t4);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 646) {
        each_value = ctx2[7];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 4 && div1_class_value !== (div1_class_value = null_to_empty(ctx2[2] in ctx2[10] ? "tips" : "") + " svelte-1tsgq7s")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & 8 && div2_class_value !== (div2_class_value = "tip-note-wrapper iteria-ignore " + ctx2[3] + " svelte-1tsgq7s")) {
        attr(div2, "class", div2_class_value);
      }
      if (css_action && is_function(css_action.update) && dirty & 96)
        css_action.update.call(null, {
          tipNotesBgColor: ctx2[6],
          tipHoverBgColor: ctx2[5]
        });
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      add_render_callback(() => {
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, fly, { x: 200, duration: 2e3 });
        div2_intro.start();
      });
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, fade, {});
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let tip_notes;
  let tipNotesBgColor;
  let tipHoverBgColor;
  const dispatch2 = createEventDispatcher();
  let { hoveredAction = void 0 } = $$props;
  let { activeAction = void 0 } = $$props;
  let { extraInspectPayload = void 0 } = $$props;
  let { filled = false } = $$props;
  let { alignX = "" } = $$props;
  const all_tip_notes = [
    {
      id: "drag_and_drop_relations",
      title: "Move Tool",
      text: "You can use this tool to swap and move the highlighted element in the grid",
      icon: icons$1["drag_move"],
      display: true,
      actions: [
        {
          id: "cancelaction",
          title: "Cancel",
          text: "You can use this tool to cancel moving elements",
          icon: icons$1["clear"],
          display: true
        },
        {
          id: "confirmaction",
          title: "Save",
          text: "You can use this tool to confirm new order of swaped elements",
          icon: icons$1["check"],
          display: true
        }
      ]
    },
    {
      id: "drag_and_drop_grid",
      title: "Move Tool",
      text: "You can use this tool to swap and move the highlighted element in the grid",
      icon: icons$1["drag_move"],
      display: true,
      actions: [
        {
          id: "cancelaction",
          title: "Cancel",
          text: "You can use this tool to cancel moving elements",
          icon: icons$1["clear"],
          display: true
        },
        {
          id: "confirmaction",
          title: "Save",
          text: "You can use this tool to confirm new order of swaped elements",
          icon: icons$1["check"],
          display: true
        }
      ]
    },
    {
      id: "clone",
      title: "Clone Tool",
      text: "You can use this tool to clone the highlighted element",
      icon: icons$1["content_copy"],
      display: true
    },
    {
      id: "delete",
      title: "Delete Tool",
      text: "You can use this tool to remove the highlighted element",
      icon: icons$1["remove"],
      display: true
    },
    {
      id: "showsource",
      title: "Show source code",
      text: "You can use this tool to show source code of the highlighted element",
      icon: icons$1["code"],
      display: true
    },
    {
      id: "translate",
      title: "Text Editing",
      text: "You can use this tool to edit text in the highlighted element",
      icon: icons$1["edit"],
      display: (extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement) !== void 0,
      actions: [
        {
          id: "cancelaction",
          title: "Cancel",
          text: "You can use this tool to cancel editing the highlighted element and revert changes",
          icon: icons$1["clear"],
          display: true
        },
        {
          id: "confirmaction",
          title: "Confirm",
          text: "You can use this tool to confirm new changes",
          icon: icons$1["check"],
          display: true
        }
      ]
    }
  ];
  const dispatchAction = (id) => (event2) => {
    if (all_tip_notes.find((note) => note.id === id)) {
      dispatch2("activeaction", id);
    }
    dispatch2(id, { event: event2 });
  };
  const tipNoteHeaders = {
    translate: "Text editing mode",
    drag_and_drop_grid: "Drag and drop editor mode",
    default: "Editing mode"
  };
  const prevFormattedMessageValue = (extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement) !== void 0 ? extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement.innerHTML : "";
  let formattedMessageInputValue = (extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement) !== void 0 ? extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement.innerHTML : "";
  const handleFormattedMessage = () => {
    $$invalidate(4, formattedMessageInputValue = extraInspectPayload.formattedMessageElement.innerHTML);
  };
  if ((extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement) !== void 0) {
    extraInspectPayload.formattedMessageElement.addEventListener("input", handleFormattedMessage, false);
    extraInspectPayload.formattedMessageElement.removeEventListener("input", handleFormattedMessage, false);
  }
  let localeLang = window.localStorage.getItem("langLocale");
  const click_handler2 = () => {
    dispatch2("modechange", { mode: "inspecting" });
  };
  const input_handler = (event2) => $$invalidate(0, extraInspectPayload.formattedMessageElement.innerHTML = event2.target.innerHTML, extraInspectPayload);
  $$self.$$set = ($$props2) => {
    if ("hoveredAction" in $$props2)
      $$invalidate(1, hoveredAction = $$props2.hoveredAction);
    if ("activeAction" in $$props2)
      $$invalidate(2, activeAction = $$props2.activeAction);
    if ("extraInspectPayload" in $$props2)
      $$invalidate(0, extraInspectPayload = $$props2.extraInspectPayload);
    if ("filled" in $$props2)
      $$invalidate(13, filled = $$props2.filled);
    if ("alignX" in $$props2)
      $$invalidate(3, alignX = $$props2.alignX);
  };
  $$self.$$.update = () => {
    var _a2;
    if ($$self.$$.dirty & 4) {
      $$invalidate(7, tip_notes = activeAction === void 0 ? [...all_tip_notes] : (_a2 = all_tip_notes.find((action) => action.id === activeAction).actions) != null ? _a2 : all_tip_notes);
    }
    if ($$self.$$.dirty & 8192) {
      $$invalidate(6, tipNotesBgColor = filled ? "rgb(255 255 255)" : "rgb(255 255 255 / 50%)");
    }
    if ($$self.$$.dirty & 8192) {
      $$invalidate(5, tipHoverBgColor = filled ? "#ebebeb" : "#a9a9a9");
    }
  };
  return [
    extraInspectPayload,
    hoveredAction,
    activeAction,
    alignX,
    formattedMessageInputValue,
    tipHoverBgColor,
    tipNotesBgColor,
    tip_notes,
    dispatch2,
    dispatchAction,
    tipNoteHeaders,
    prevFormattedMessageValue,
    localeLang,
    filled,
    click_handler2,
    input_handler
  ];
}
class TipNotes extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$y, create_fragment$B, safe_not_equal, {
      hoveredAction: 1,
      activeAction: 2,
      extraInspectPayload: 0,
      filled: 13,
      alignX: 3
    }, add_css$e);
  }
}
const { window: window_1$2 } = globals;
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i2];
  return child_ctx;
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i2];
  return child_ctx;
}
function create_if_block_7$2(ctx) {
  let div1;
  let div0;
  let span;
  let raw_value = (ctx[1] === "inspecting" ? icons$1[ctx[4]] : icons$1["clear"]) + "";
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      attr(span, "class", "material-icons");
      attr(div0, "class", "button");
      attr(div1, "class", "action");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append$1(div1, div0);
      append$1(div0, span);
      span.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[27]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 18 && raw_value !== (raw_value = (ctx2[1] === "inspecting" ? icons$1[ctx2[4]] : icons$1["clear"]) + ""))
        span.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$3(ctx) {
  let each_1_anchor;
  let each_value_2 = ctx[17];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 933892) {
        each_value_2 = ctx2[17];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$a(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[5] !== void 0)
      return create_if_block_2$6;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_6$2(ctx) {
  let div1;
  let div0;
  let span;
  let raw_value = ctx[35].icon + "";
  let span_class_value;
  let t;
  let div1_title_value;
  let mounted;
  let dispose;
  function mouseenter_handler_2(...args2) {
    return ctx[32](ctx[35], ...args2);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = space();
      attr(span, "class", span_class_value = "material-icons " + ctx[35].id);
      attr(div0, "class", "button");
      attr(div1, "class", "action");
      attr(div1, "title", div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""));
      toggle_class(div1, "disabled", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append$1(div1, div0);
      append$1(div0, span);
      span.innerHTML = raw_value;
      append$1(div1, t);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[18](ctx[35].id)),
          listen(div1, "mouseenter", mouseenter_handler_2),
          listen(div1, "mouseleave", ctx[33])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 4 && div1_title_value !== (div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""))) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty[0] & 4) {
        toggle_class(div1, "disabled", ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_2(ctx) {
  let show_if = ctx[19](ctx[35]);
  let if_block_anchor;
  let if_block = show_if && create_if_block_6$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$5(ctx) {
  let each_1_anchor;
  let each_value_1 = ctx[16];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 868356) {
        each_value_1 = ctx2[16];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$6(ctx) {
  let each_1_anchor;
  let each_value = ctx[17];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 933892) {
        each_value = ctx2[17];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_4$4(ctx) {
  let div1;
  let div0;
  let span;
  let raw_value = ctx[35].icon + "";
  let span_class_value;
  let t;
  let div1_title_value;
  let mounted;
  let dispose;
  function mouseenter_handler_1(...args2) {
    return ctx[30](ctx[35], ...args2);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = space();
      attr(span, "class", span_class_value = "material-icons " + ctx[35].id);
      attr(div0, "class", "button");
      attr(div1, "class", "action");
      attr(div1, "title", div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""));
      toggle_class(div1, "disabled", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append$1(div1, div0);
      append$1(div0, span);
      span.innerHTML = raw_value;
      append$1(div1, t);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[18](ctx[35].id)),
          listen(div1, "mouseenter", mouseenter_handler_1),
          listen(div1, "mouseleave", ctx[31])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 4 && div1_title_value !== (div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""))) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty[0] & 4) {
        toggle_class(div1, "disabled", ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_1(ctx) {
  let show_if = ctx[19](ctx[35]);
  let if_block_anchor;
  let if_block = show_if && create_if_block_4$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$5(ctx) {
  let div1;
  let div0;
  let span;
  let raw_value = ctx[35].icon + "";
  let span_class_value;
  let t;
  let div1_title_value;
  let mounted;
  let dispose;
  function mouseenter_handler(...args2) {
    return ctx[28](ctx[35], ...args2);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = space();
      attr(span, "class", span_class_value = "material-icons " + ctx[35].id);
      attr(div0, "class", "button");
      attr(div1, "class", "action");
      attr(div1, "title", div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""));
      toggle_class(div1, "disabled", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append$1(div1, div0);
      append$1(div0, span);
      span.innerHTML = raw_value;
      append$1(div1, t);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[18](ctx[35].id)),
          listen(div1, "mouseenter", mouseenter_handler),
          listen(div1, "mouseleave", ctx[29])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 4 && div1_title_value !== (div1_title_value = ctx[35].title + (ctx[2] ? " is disabled" : ""))) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty[0] & 4) {
        toggle_class(div1, "disabled", ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$4(ctx) {
  let show_if = ctx[19](ctx[35]);
  let if_block_anchor;
  let if_block = show_if && create_if_block_3$5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$e(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text$1(ctx[0]);
      attr(span, "class", "text iteria-ignore");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append$1(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$A(ctx) {
  let div3;
  let div0;
  let t0;
  let div2;
  let div1;
  let t1;
  let t2;
  let div2_resize_listener;
  let t3;
  let style;
  let div3_class_value;
  let div3_style_value;
  let mounted;
  let dispose;
  add_render_callback(ctx[26]);
  let if_block0 = ctx[5] === void 0 && (ctx[1] === "inspecting" || ctx[1] === "editing") && create_if_block_7$2(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] == "editing")
      return create_if_block_1$a;
    if (ctx2[1] === "dragable-editing")
      return create_if_block_5$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  let if_block2 = ctx[1] === "inspecting" && ctx[0] && create_if_block$e(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      style = element("style");
      style.textContent = ".tippy-wrapper {\n      position: fixed;\n      top: max(\n        0px,\n        calc(\n          var(--offset-top) + var(--position-top) - var(--tippy-height) + 2px\n        )\n      );\n      left: max(\n        calc(\n          var(--offset-left) +\n            calc(\n              calc(\n                  var(--position-right) + var(--position-left) -\n                    var(--tippy-width)\n                ) / 2\n            )\n        ),\n        calc(var(--offset-left) + var(--position-right) - var(--tippy-width))\n      );\n      z-index: 10000;\n      transform: translateX(-2px);\n      padding-top: 0;\n      padding-bottom: var(--tippy-arrow-height);\n      font-family: sans-serif;\n    }\n    .tippy-wrapper.bottom {\n      top: calc(var(--offset-top) + var(--position-bottom) - 3rem);\n    }\n    .tippy {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      background: #181818;\n      color: white;\n      padding: 0 0.2rem;\n      width: max-content;\n      height: 2rem;\n      border-radius: 4px;\n      gap: 0.2rem;\n    }\n    .tippy .actions {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      gap: 0.2rem;\n    }\n    .tippy .action {\n      width: 100%;\n      border-radius: 2px;\n      overflow: hidden;\n      display: flex;\n    }\n    .tippy .action .button {\n      width: 100%;\n      height: 100%;\n      padding: 0.2rem;\n      user-select: none;\n      cursor: pointer;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n    }\n    .tippy .action:hover {\n      background: #ffffff22;\n    }\n    .tippy .action .material-icons {\n      font-size: 1rem;\n    }\n    .tippy .action .material-icons :global(svg) {\n      width: 1.1rem;\n    }\n    .icon {\n      color: white;\n    }\n    .tippy .action.disabled {\n      opacity: 0.6;\n    }\n    .tippy .action.disabled .button {\n      pointer-events: none;\n    }\n    .tippy .tippy-wrapper .arrow {\n      position: absolute;\n      width: var(--tippy-arrow-width);\n      height: var(--tippy-arrow-height);\n      background: #333;\n      top: 2rem;\n      left: 50%;\n      transform: translateX(-50%);\n      clip-path: polygon(0 0, 100% 0, 50% 100%, 0 0);\n      cursor: pointer;\n    }\n    .tippy-wrapper.left .arrow {\n      left: 10%;\n      transform: unset;\n    }\n    .tippy-wrapper.right {\n      left: calc(\n        var(--offset-left) + var(--position-right) - var(--tippy-width) + 2px\n      );\n    }\n    .tippy-wrapper.right .arrow {\n      left: 90%;\n      transform: translateX(-100%);\n    }\n    .tippy-wrapper.bottom {\n      top: calc(\n        var(--offset-top) + var(--position-bottom) - var(--tippy-arrow-height)\n      );\n      padding-bottom: 0;\n      padding-top: var(--tippy-arrow-height);\n    }\n    .tippy-wrapper.bottom .arrow {\n      top: 0.5px;\n      clip-path: polygon(50% 0, 100% 100%, 0 100%, 50% 0);\n    }\n    .tippy-wrapper.transform {\n      top: max(0px, calc(var(--offset-top) + var(--position-top) + 2px));\n    }\n    .tippy-wrapper.left {\n      transform: translateX(2px);\n      left: calc(var(--offset-left) + var(--position-left));\n    }\n    .tippy-wrapper.center {\n      transform: translateX(-50%);\n      left: calc(\n        var(--offset-left) + var(--position-left) +\n          calc(calc(var(--position-right) - var(--position-left)) / 2)\n      );\n    }\n    .tippy .text {\n      min-width: max-content;\n      margin-right: 0.2rem;\n    }\n\n    .tippy-wrapper.transition {\n      transition: left 200ms, top 200ms;\n    }\n\n    .tippy-wrapper.fadein {\n      animation: tippy-fadein 400ms;\n    }\n\n    .tippy svg {\n      margin-top: 4px;\n    }\n\n    @keyframes tippy-fadein {\n      from {\n        opacity: 0;\n      }\n      top {\n        opacity: 1;\n      }\n    }";
      attr(div0, "class", "arrow iteria-ignore");
      attr(div1, "class", "actions");
      attr(div2, "class", "tippy iteria-ignore");
      add_render_callback(() => ctx[34].call(div2));
      attr(div3, "class", div3_class_value = "tippy-wrapper iteria-ignore fadein transition " + ctx[11]);
      attr(div3, "style", div3_style_value = "" + (ctx[3] + ctx[13]));
      toggle_class(div3, "bottom", !ctx[12] && ctx[10] <= 50);
      toggle_class(div3, "transform", ctx[12]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append$1(div3, div0);
      append$1(div3, t0);
      append$1(div3, div2);
      append$1(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append$1(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append$1(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      div2_resize_listener = add_resize_listener(div2, ctx[34].bind(div2));
      append$1(div3, t3);
      append$1(div3, style);
      if (!mounted) {
        dispose = [
          listen(window_1$2, "pointermove", ctx[15]),
          listen(window_1$2, "resize", ctx[26])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[5] === void 0 && (ctx2[1] === "inspecting" || ctx2[1] === "editing")) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$2(ctx2);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, null);
        }
      }
      if (ctx2[1] === "inspecting" && ctx2[0]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$e(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & 2048 && div3_class_value !== (div3_class_value = "tippy-wrapper iteria-ignore fadein transition " + ctx2[11])) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty[0] & 8200 && div3_style_value !== (div3_style_value = "" + (ctx2[3] + ctx2[13]))) {
        attr(div3, "style", div3_style_value);
      }
      if (dirty[0] & 7168) {
        toggle_class(div3, "bottom", !ctx2[12] && ctx2[10] <= 50);
      }
      if (dirty[0] & 6144) {
        toggle_class(div3, "transform", ctx2[12]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      if (if_block2)
        if_block2.d();
      div2_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let top;
  let bottom;
  let otherVars;
  let fatElement;
  let { text: text2 = "" } = $$props;
  let { mode = "inspecting" } = $$props;
  let { offset = new DOMRect() } = $$props;
  let { boundries = null } = $$props;
  let { disabled = false } = $$props;
  let { css: css2 = "" } = $$props;
  let { icon = "settings" } = $$props;
  let { contentWindow = window } = $$props;
  let { extraInspectPayload = void 0 } = $$props;
  let { activeAction = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  let tippyWidth = 0;
  let tippyHeight = 0;
  let windowWidth = 0;
  let windowHeight = 0;
  let mouse = [0, 0];
  let alignX = "right";
  function pointerMoved(e) {
    if (!checkIgnore(e.target)) {
      $$invalidate(24, mouse = [e.clientX, e.clientY]);
      if (tippyWidth > boundries.width) {
        $$invalidate(11, alignX = e.x < contentWindow.innerWidth - tippyWidth ? "left" : "right");
      } else if (tippyWidth < boundries.width / 3) {
        if (mouse[0] < boundries.left + boundries.width / 3) {
          $$invalidate(11, alignX = "left");
        } else if (mouse[0] < boundries.left + boundries.width * 2 / 3) {
          $$invalidate(11, alignX = "center");
        } else {
          $$invalidate(11, alignX = "right");
        }
      } else if (tippyWidth < boundries.width / 2) {
        if (mouse[0] < boundries.left + boundries.width / 2) {
          $$invalidate(11, alignX = "left");
        } else {
          $$invalidate(11, alignX = "right");
        }
      } else {
        $$invalidate(11, alignX = "right");
      }
    }
  }
  const actions = [
    {
      id: "drag_and_drop_grid",
      title: "Move item",
      icon: icons$1["drag_move"],
      defaultDisplay: true
    },
    {
      id: "clone",
      title: "Clone",
      icon: icons$1["content_copy"],
      defaultDisplay: true
    },
    {
      id: "delete",
      title: "Delete",
      icon: icons$1["remove"],
      defaultDisplay: true
    },
    {
      id: "showsource",
      title: "Show source",
      icon: icons$1["code"],
      defaultDisplay: true
    },
    {
      id: "translate",
      title: "Translate",
      icon: icons$1["edit"],
      defaultDisplay: false
    }
  ];
  const activeModeActions = [
    {
      id: "drag_and_drop_relations",
      title: "Move relations",
      icon: icons$1["drag_move"],
      defaultDisplay: true
    },
    {
      id: "cancelaction",
      title: "Cancel",
      icon: icons$1["clear"],
      defaultDisplay: true
    },
    {
      id: "confirmaction",
      title: "Confirm",
      icon: icons$1["check"],
      defaultDisplay: true
    }
  ];
  const dispatchAction = (id) => (event2) => {
    if (actions.find((action) => action.id === id)) {
      if (id === "drag_and_drop_grid" || id === "drag_and_drop_relations") {
        dispatch2("modechange", { mode: "dragable-editing" });
      }
      dispatch2("activeaction", id);
    }
    dispatch2(id, { event: event2 });
  };
  const shouldDisplayAction = (actionType) => {
    if (!actionType.defaultDisplay) {
      if (extraInspectPayload == null ? void 0 : extraInspectPayload.formattedMessageElement) {
        return true;
      }
      if (actionType.id === "drag_and_drop_grid" || actionType.id === "drag_and_drop_relations") {
        return true;
      }
      return false;
    }
    return true;
  };
  function onwindowresize() {
    $$invalidate(8, windowWidth = window_1$2.innerWidth);
    $$invalidate(9, windowHeight = window_1$2.innerHeight);
  }
  const click_handler2 = (e) => {
    dispatch2("modechange", {
      mode: mode === "inspecting" ? "editing" : "inspecting"
    });
  };
  const mouseenter_handler = (action, e) => dispatch2("hoveredAction", action.id);
  const mouseleave_handler = (e) => dispatch2("hoveredAction", void 0);
  const mouseenter_handler_1 = (action, e) => dispatch2("hoveredAction", action.id);
  const mouseleave_handler_1 = (e) => dispatch2("hoveredAction", void 0);
  const mouseenter_handler_2 = (action, e) => dispatch2("hoveredAction", action.id);
  const mouseleave_handler_2 = (e) => dispatch2("hoveredAction", void 0);
  function div2_elementresize_handler() {
    tippyWidth = this.clientWidth;
    tippyHeight = this.clientHeight;
    $$invalidate(6, tippyWidth);
    $$invalidate(7, tippyHeight);
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("mode" in $$props2)
      $$invalidate(1, mode = $$props2.mode);
    if ("offset" in $$props2)
      $$invalidate(20, offset = $$props2.offset);
    if ("boundries" in $$props2)
      $$invalidate(21, boundries = $$props2.boundries);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("css" in $$props2)
      $$invalidate(3, css2 = $$props2.css);
    if ("icon" in $$props2)
      $$invalidate(4, icon = $$props2.icon);
    if ("contentWindow" in $$props2)
      $$invalidate(22, contentWindow = $$props2.contentWindow);
    if ("extraInspectPayload" in $$props2)
      $$invalidate(23, extraInspectPayload = $$props2.extraInspectPayload);
    if ("activeAction" in $$props2)
      $$invalidate(5, activeAction = $$props2.activeAction);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 3145728) {
      $$invalidate(10, top = offset.top + boundries.top);
    }
    if ($$self.$$.dirty[0] & 3145728) {
      $$invalidate(25, bottom = offset.top + boundries.bottom);
    }
    if ($$self.$$.dirty[0] & 16778176) {
      $$invalidate(13, otherVars = `
  --tippy-width: ${tippyWidth}px;
  --tippy-height: ${tippyHeight}px;
  --tippy-arrow-width: 1rem;
  --tippy-arrow-height: 0.5rem;
  --screen-width: ${windowWidth}px;
  --screen-height: ${windowHeight}px;
  --mouse-x: ${mouse[0]}px;
  --mouse-y: ${Math.min(windowHeight - 50, Math.floor(mouse[1] / 200) * 200)}px;
  `);
    }
    if ($$self.$$.dirty[0] & 33555456) {
      $$invalidate(12, fatElement = top <= 50 && bottom >= window.innerHeight - 50);
    }
  };
  return [
    text2,
    mode,
    disabled,
    css2,
    icon,
    activeAction,
    tippyWidth,
    tippyHeight,
    windowWidth,
    windowHeight,
    top,
    alignX,
    fatElement,
    otherVars,
    dispatch2,
    pointerMoved,
    actions,
    activeModeActions,
    dispatchAction,
    shouldDisplayAction,
    offset,
    boundries,
    contentWindow,
    extraInspectPayload,
    mouse,
    bottom,
    onwindowresize,
    click_handler2,
    mouseenter_handler,
    mouseleave_handler,
    mouseenter_handler_1,
    mouseleave_handler_1,
    mouseenter_handler_2,
    mouseleave_handler_2,
    div2_elementresize_handler
  ];
}
class WidgetTippy extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$x, create_fragment$A, safe_not_equal, {
      text: 0,
      mode: 1,
      offset: 20,
      boundries: 21,
      disabled: 2,
      css: 3,
      icon: 4,
      contentWindow: 22,
      extraInspectPayload: 23,
      activeAction: 5
    }, null, [-1, -1]);
  }
}
const { window: window_1$1 } = globals;
function create_if_block_2$5(ctx) {
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let div4_style_value;
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      attr(div0, "class", "frame frame-top");
      toggle_class(div0, "dashed", ctx[17]);
      attr(div1, "class", "frame frame-right");
      toggle_class(div1, "dashed", ctx[20]);
      attr(div2, "class", "frame frame-bottom");
      toggle_class(div2, "dashed", ctx[18]);
      attr(div3, "class", "frame frame-left");
      toggle_class(div3, "dashed", ctx[19]);
      attr(div4, "class", "frame-wrapper iteria-ignore");
      attr(div4, "style", div4_style_value = "" + (ctx[8] + ctx[9] + ctx[10]));
      toggle_class(div4, "fallback-color", ctx[13]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append$1(div4, div0);
      append$1(div4, t0);
      append$1(div4, div1);
      append$1(div4, t1);
      append$1(div4, div2);
      append$1(div4, t2);
      append$1(div4, div3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 131072) {
        toggle_class(div0, "dashed", ctx2[17]);
      }
      if (dirty[0] & 1048576) {
        toggle_class(div1, "dashed", ctx2[20]);
      }
      if (dirty[0] & 262144) {
        toggle_class(div2, "dashed", ctx2[18]);
      }
      if (dirty[0] & 524288) {
        toggle_class(div3, "dashed", ctx2[19]);
      }
      if (dirty[0] & 1792 && div4_style_value !== (div4_style_value = "" + (ctx2[8] + ctx2[9] + ctx2[10]))) {
        attr(div4, "style", div4_style_value);
      }
      if (dirty[0] & 8192) {
        toggle_class(div4, "fallback-color", ctx2[13]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
    }
  };
}
function create_if_block_1$9(ctx) {
  let tipnotes;
  let current;
  tipnotes = new TipNotes({
    props: {
      hoveredAction: ctx[7],
      activeAction: ctx[5],
      extraInspectPayload: ctx[6],
      alignX: ctx[21],
      filled: ctx[4] === "dragable-editing"
    }
  });
  tipnotes.$on("clone", ctx[29]);
  tipnotes.$on("delete", ctx[30]);
  tipnotes.$on("showsource", ctx[31]);
  tipnotes.$on("translate", ctx[32]);
  tipnotes.$on("activeaction", ctx[33]);
  tipnotes.$on("confirmaction", ctx[34]);
  tipnotes.$on("cancelaction", ctx[35]);
  tipnotes.$on("modechange", ctx[36]);
  return {
    c() {
      create_component(tipnotes.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tipnotes, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tipnotes_changes = {};
      if (dirty[0] & 128)
        tipnotes_changes.hoveredAction = ctx2[7];
      if (dirty[0] & 32)
        tipnotes_changes.activeAction = ctx2[5];
      if (dirty[0] & 64)
        tipnotes_changes.extraInspectPayload = ctx2[6];
      if (dirty[0] & 2097152)
        tipnotes_changes.alignX = ctx2[21];
      if (dirty[0] & 16)
        tipnotes_changes.filled = ctx2[4] === "dragable-editing";
      tipnotes.$set(tipnotes_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tipnotes.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tipnotes.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tipnotes, detaching);
    }
  };
}
function create_if_block$d(ctx) {
  let widgettippy;
  let t0;
  let style;
  let current;
  widgettippy = new WidgetTippy({
    props: {
      icon: ctx[16],
      offset: ctx[1],
      boundries: ctx[2],
      mode: ctx[4],
      text: ctx[0],
      disabled: ctx[14],
      contentWindow: ctx[11] ? ctx[11].contentWindow : window,
      css: "" + (ctx[8] + ctx[9] + ctx[10]),
      extraInspectPayload: ctx[6],
      activeAction: ctx[5]
    }
  });
  widgettippy.$on("modechange", ctx[37]);
  widgettippy.$on("clone", ctx[38]);
  widgettippy.$on("delete", ctx[39]);
  widgettippy.$on("showsource", ctx[40]);
  widgettippy.$on("translate", ctx[41]);
  widgettippy.$on("hoveredAction", ctx[26]);
  widgettippy.$on("activeaction", ctx[42]);
  widgettippy.$on("confirmaction", ctx[43]);
  widgettippy.$on("cancelaction", ctx[44]);
  widgettippy.$on("drag_and_drop_grid", ctx[45]);
  widgettippy.$on("drag_and_drop_relations", ctx[46]);
  return {
    c() {
      create_component(widgettippy.$$.fragment);
      t0 = space();
      style = element("style");
      style.textContent = ".frame-wrapper {\n      position: absolute;\n      width: 0;\n      height: 0;\n      top: 0;\n      left: 0;\n    }\n    .frame {\n      z-index: 10000;\n      position: fixed;\n      width: 20px;\n      height: 20px;\n      background: var(--frame-color);\n      animation: frame-fadein 300ms;\n    }\n    .frame-wrapper.fallback-color .frame {\n      background: var(--frame-fallback-color);\n    }\n    .frame-top.dashed,\n    .frame-bottom.dashed {\n      background: repeating-linear-gradient(\n        to right,\n        transparent,\n        transparent 10px,\n        var(--frame-color) 10px,\n        var(--frame-color) 20px\n      );\n    }\n    .frame-left.dashed,\n    .frame-right.dashed {\n      background: repeating-linear-gradient(\n        to bottom,\n        transparent,\n        transparent 10px,\n        var(--frame-color) 10px,\n        var(--frame-color) 20px\n      );\n    }\n    .frame-wrapper.fallback-color .frame-top.dashed,\n    .frame-wrapper.fallback-color .frame-bottom.dashed {\n      background: repeating-linear-gradient(\n        to right,\n        transparent,\n        transparent 10px,\n        var(--frame-fallback-color) 10px,\n        var(--frame-fallback-color) 20px\n      );\n    }\n    .frame-wrapper.fallback-color .frame-left.dashed,\n    .frame-wrapper.fallback-color .frame-right.dashed {\n      background: repeating-linear-gradient(\n        to bottom,\n        transparent,\n        transparent 10px,\n        var(--frame-fallback-color) 10px,\n        var(--frame-fallback-color) 20px\n      );\n    }\n    .frame-top {\n      top: max(\n        0px,\n        calc(var(--offset-top) + var(--position-top) - var(--frame-half-width))\n      );\n    }\n    .frame-bottom {\n      top: calc(\n        var(--offset-top) + var(--position-bottom) - var(--frame-half-width)\n      );\n    }\n    .frame-left {\n      left: max(\n        0px,\n        calc(\n          var(--offset-left) + var(--position-left) - var(--frame-half-width)\n        )\n      );\n    }\n    .frame-right {\n      left: calc(\n        var(--offset-left) + var(--position-right) - var(--frame-half-width)\n      );\n    }\n    .frame-top,\n    .frame-bottom {\n      left: calc(\n        var(--offset-left) + var(--position-left) - var(--frame-half-width)\n      );\n      width: calc(\n        var(--position-right) - var(--position-left) + var(--frame-width)\n      );\n      height: var(--frame-width);\n    }\n    .frame-left,\n    .frame-right {\n      display: inline-block;\n      top: calc(var(--offset-top) + var(--position-top));\n      width: var(--frame-width);\n      height: calc(\n        var(--position-bottom) - var(--position-top) - var(--frame-half-width)\n      );\n    }\n    @keyframes frame-fadein {\n      from {\n        opacity: 0;\n      }\n      top {\n        opacity: 1;\n      }\n    }";
    },
    m(target, anchor) {
      mount_component(widgettippy, target, anchor);
      insert(target, t0, anchor);
      insert(target, style, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const widgettippy_changes = {};
      if (dirty[0] & 65536)
        widgettippy_changes.icon = ctx2[16];
      if (dirty[0] & 2)
        widgettippy_changes.offset = ctx2[1];
      if (dirty[0] & 4)
        widgettippy_changes.boundries = ctx2[2];
      if (dirty[0] & 16)
        widgettippy_changes.mode = ctx2[4];
      if (dirty[0] & 1)
        widgettippy_changes.text = ctx2[0];
      if (dirty[0] & 16384)
        widgettippy_changes.disabled = ctx2[14];
      if (dirty[0] & 2048)
        widgettippy_changes.contentWindow = ctx2[11] ? ctx2[11].contentWindow : window;
      if (dirty[0] & 1792)
        widgettippy_changes.css = "" + (ctx2[8] + ctx2[9] + ctx2[10]);
      if (dirty[0] & 64)
        widgettippy_changes.extraInspectPayload = ctx2[6];
      if (dirty[0] & 32)
        widgettippy_changes.activeAction = ctx2[5];
      widgettippy.$set(widgettippy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(widgettippy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(widgettippy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(widgettippy, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(style);
    }
  };
}
function create_fragment$z(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[12] && create_if_block_2$5(ctx);
  let if_block1 = ctx[4] !== "inspecting" && create_if_block_1$9(ctx);
  let if_block2 = (ctx[15] && ctx[3] || ctx[4] === "dragable-editing") && create_if_block$d(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window_1$1, "resize", ctx[24]),
          listen(window_1$1, "scroll", ctx[25], true),
          listen(window_1$1, "pointermove", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[12]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$5(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4] !== "inspecting") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[15] && ctx2[3] || ctx2[4] === "dragable-editing") {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 32792) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$d(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { color: color2 = "#4a87ee" } = $$props;
  let { fallbackColor = "orange" } = $$props;
  let { element: element2 } = $$props;
  let { mode = "inspecting" } = $$props;
  let { text: text2 = "tippy" } = $$props;
  let { offset = new DOMRect() } = $$props;
  let { boundries = null } = $$props;
  let { activeAction = void 0 } = $$props;
  let extraInspectPayload = void 0;
  let hoveredAction = void 0;
  let offsetVars = "";
  let positionVars = "";
  let otherVars = "";
  let iframe;
  let frameShown = true;
  let isBgBlue = false;
  let isDisabled = false;
  let displayTippy = false;
  let tippyIcon = "settings";
  let isDashedTop = false;
  let isDashedBottom = false;
  let isDashedLeft = false;
  let isDashedRight = false;
  let alignX = "";
  function pointerMoved(e) {
    if (mode === "inspecting") {
      const mouseX = e.clientX;
      if (mouseX < window.innerWidth / 2) {
        $$invalidate(21, alignX = "right");
      } else {
        $$invalidate(21, alignX = "left");
      }
    }
  }
  function update2() {
    if (!checkIgnore(element2)) {
      dispatch2("hover", inspectCallback);
      $$invalidate(2, boundries = boundries || new DOMRect());
      $$invalidate(2, boundries = element2.getBoundingClientRect());
      $$invalidate(8, offsetVars = `
      --offset-top: ${offset.top}px;
      --offset-left: ${offset.left}px;
      --offset-right: ${offset.right}px;
      --offset-bottom: ${offset.bottom}px;
      `);
      $$invalidate(17, isDashedTop = offset.top + boundries.top < 0);
      $$invalidate(18, isDashedBottom = offset.top + boundries.bottom > innerHeight);
      $$invalidate(19, isDashedLeft = offset.left + boundries.left < 0);
      $$invalidate(20, isDashedRight = offset.left + boundries.right > innerWidth);
      if (offset.bottom) {
        $$invalidate(9, positionVars = `
        --position-left: ${boundries.left}px;
        --position-top: ${boundries.top}px;
        --position-right: ${Math.min(offset.right, boundries.right)}px;
        --position-bottom: ${Math.min(offset.bottom, boundries.bottom)}px;
        `);
      } else {
        $$invalidate(9, positionVars = `
        --position-left: ${Math.max(boundries.left, 0)}px;
        --position-top: ${Math.max(boundries.top, 0)}px;
        --position-right: ${Math.min(boundries.right, innerWidth - 4)}px;
        --position-bottom: ${Math.min(boundries.bottom, innerHeight)}px;
        `);
      }
      $$invalidate(10, otherVars = `
      --frame-width: 4px;
      --frame-half-width: calc(var(--frame-width) / 2);
      --frame-color: ${color2};
      --frame-fallback-color: ${mode === "dragable-editing" ? "none" : fallbackColor};
      `);
    }
  }
  function inspectCallback({ display: display2, tooltipText, disabled, icon = "settings", icons: icons2, extraPayload }) {
    if (!checkIgnore(element2)) {
      $$invalidate(6, extraInspectPayload = extraPayload);
      dispatch2("set_extra_payload", extraInspectPayload);
      $$invalidate(16, tippyIcon = icon);
      $$invalidate(0, text2 = tooltipText);
      $$invalidate(14, isDisabled = !!disabled);
      $$invalidate(15, displayTippy = !!display2);
      if (!display2)
        return;
      $$invalidate(13, isBgBlue = isBlue(element2));
      $$invalidate(12, frameShown = false);
      $$invalidate(2, boundries = element2.getBoundingClientRect());
      $$invalidate(11, iframe = checkIframe(element2));
      if (iframe) {
        $$invalidate(1, offset = iframe.getBoundingClientRect());
      } else {
        $$invalidate(1, offset = new DOMRect());
      }
      iframe ? iframe.contentWindow : window;
      setTimeout(() => $$invalidate(12, frameShown = true), 0);
    }
  }
  function scrolled() {
    $$invalidate(12, frameShown = $$invalidate(15, displayTippy = false));
  }
  const handleHoveredAction = (event2) => {
    $$invalidate(7, hoveredAction = event2.detail);
  };
  function clone_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function delete_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function showsource_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function translate_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function activeaction_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function confirmaction_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function cancelaction_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function modechange_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const modechange_handler_1 = (event2) => dispatch2("modechange", { mode: event2.detail.mode, target: element2 });
  function clone_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function delete_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function showsource_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function translate_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function activeaction_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function confirmaction_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function cancelaction_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function drag_and_drop_grid_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function drag_and_drop_relations_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(27, color2 = $$props2.color);
    if ("fallbackColor" in $$props2)
      $$invalidate(28, fallbackColor = $$props2.fallbackColor);
    if ("element" in $$props2)
      $$invalidate(3, element2 = $$props2.element);
    if ("mode" in $$props2)
      $$invalidate(4, mode = $$props2.mode);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("offset" in $$props2)
      $$invalidate(1, offset = $$props2.offset);
    if ("boundries" in $$props2)
      $$invalidate(2, boundries = $$props2.boundries);
    if ("activeAction" in $$props2)
      $$invalidate(5, activeAction = $$props2.activeAction);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8) {
      if (element2)
        update2();
    }
  };
  return [
    text2,
    offset,
    boundries,
    element2,
    mode,
    activeAction,
    extraInspectPayload,
    hoveredAction,
    offsetVars,
    positionVars,
    otherVars,
    iframe,
    frameShown,
    isBgBlue,
    isDisabled,
    displayTippy,
    tippyIcon,
    isDashedTop,
    isDashedBottom,
    isDashedLeft,
    isDashedRight,
    alignX,
    dispatch2,
    pointerMoved,
    update2,
    scrolled,
    handleHoveredAction,
    color2,
    fallbackColor,
    clone_handler,
    delete_handler,
    showsource_handler,
    translate_handler,
    activeaction_handler,
    confirmaction_handler,
    cancelaction_handler,
    modechange_handler,
    modechange_handler_1,
    clone_handler_1,
    delete_handler_1,
    showsource_handler_1,
    translate_handler_1,
    activeaction_handler_1,
    confirmaction_handler_1,
    cancelaction_handler_1,
    drag_and_drop_grid_handler,
    drag_and_drop_relations_handler
  ];
}
class WidgetFrame extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$w, create_fragment$z, safe_not_equal, {
      color: 27,
      fallbackColor: 28,
      element: 3,
      mode: 4,
      text: 0,
      offset: 1,
      boundries: 2,
      activeAction: 5
    }, null, [-1, -1]);
  }
}
const template = document.createElement("div");
template.innerHTML = "<div class=wb-header><div class=wb-icon><span class=wb-min></span><span class=wb-max></span><span class=wb-full></span><span class=wb-close></span></div><div class=wb-title> </div></div><div class=wb-body></div><div class=wb-n></div><div class=wb-s></div><div class=wb-w></div><div class=wb-e></div><div class=wb-nw></div><div class=wb-ne></div><div class=wb-se></div><div class=wb-sw></div>";
function template$1() {
  return template.cloneNode(true);
}
function addListener(node, event2, fn2, opt) {
  node.addEventListener(event2, fn2, opt || opt === false ? opt : true);
}
function removeListener(node, event2, fn2, opt) {
  node.removeEventListener(event2, fn2, opt || opt === false ? opt : true);
}
function preventEvent(event2, prevent) {
  event2.stopPropagation();
  event2.cancelable && event2.preventDefault();
}
function getByClass(root2, name) {
  return root2.getElementsByClassName(name)[0];
}
function addClass(node, classname) {
  node.classList.add(classname);
}
function hasClass(node, classname) {
  return node.classList.contains(classname);
}
function removeClass(node, classname) {
  node.classList.remove(classname);
}
function setStyle(node, style, value2) {
  value2 = "" + value2;
  if (node["_s_" + style] !== value2) {
    node.style.setProperty(style, value2);
    node["_s_" + style] = value2;
  }
}
function setText(node, value2) {
  node.firstChild.nodeValue = value2;
}
const stack_min = [];
let body;
let id_counter = 0;
let dblclick_timer = 0;
let index$1;
let is_fullscreen;
let last_focus;
let prefix_request;
let prefix_exit;
let root_w, root_h;
function WinBox(params, _title) {
  if (!(this instanceof WinBox)) {
    return new WinBox(params);
  }
  index$1 || setup();
  let id, root2, customTemplate, title, mount2, html2, url, width, height, minwidth, minheight, x2, y2, max, hidden2, top, left, bottom, right, modal, onclose, onfocus, onblur, onmove, onresize, background, border, classname, splitscreen;
  if (params) {
    if (_title) {
      title = params;
      params = _title;
    }
    if (typeof params === "string") {
      title = params;
    } else {
      if (modal = params["modal"]) {
        x2 = y2 = "center";
      }
      id = params["id"];
      root2 = params["root"];
      customTemplate = params["template"];
      title = title || params["title"];
      mount2 = params["mount"];
      html2 = params["html"];
      url = params["url"];
      width = params["width"];
      height = params["height"];
      minwidth = params["minwidth"];
      minheight = params["minheight"];
      x2 = params["x"] || x2;
      y2 = params["y"] || y2;
      max = params["max"];
      hidden2 = params["hidden"];
      top = params["top"];
      left = params["left"];
      bottom = params["bottom"];
      right = params["right"];
      index$1 = params["index"] || index$1;
      onclose = params["onclose"];
      onfocus = params["onfocus"];
      onblur = params["onblur"];
      onmove = params["onmove"];
      onresize = params["onresize"];
      background = params["background"];
      border = params["border"];
      classname = params["class"];
      splitscreen = params["splitscreen"];
    }
  }
  if (customTemplate) {
    this.dom = customTemplate;
  } else {
    this.dom = template$1();
  }
  this.body = getByClass(this.dom, "wb-body");
  if (background) {
    this.setBackground(background);
  }
  if (border) {
    setStyle(this.body, "margin", border + (isNaN(border) ? "" : "px"));
  }
  this.setTitle(title || "");
  let max_width = root_w;
  let max_height = root_h;
  top = top ? parse$7(top, max_height) : 0;
  bottom = bottom ? parse$7(bottom, max_height) : 0;
  left = left ? parse$7(left, max_width) : 0;
  right = right ? parse$7(right, max_width) : 0;
  max_width -= left + right;
  max_height -= top + bottom;
  width = width ? parse$7(width, max_width) : max_width / 2 | 0;
  height = height ? parse$7(height, max_height) : max_height / 2 | 0;
  minwidth = minwidth ? parse$7(minwidth, max_width) : 0;
  minheight = minheight ? parse$7(minheight, max_height) : 0;
  x2 = x2 ? parse$7(x2, max_width, width) : left;
  y2 = y2 ? parse$7(y2, max_height, height) : top;
  index$1 = index$1 || 10;
  this.dom.id = this.id = id || "winbox-" + ++id_counter;
  this.dom.className = "winbox" + (classname ? " " + (typeof classname === "string" ? classname : classname.join(" ")) : "") + (modal ? " modal" : "");
  this.x = x2;
  this.y = y2;
  this.width = width;
  this.height = height;
  this.minwidth = minwidth;
  this.minheight = minheight;
  this.top = top;
  this.right = right;
  this.bottom = bottom;
  this.left = left;
  this.border = border;
  this.min = false;
  this.max = false;
  this.onclose = onclose;
  this.onfocus = onfocus;
  this.onblur = onblur;
  this.onmove = onmove;
  this.onresize = onresize;
  this.splitscreen = splitscreen;
  if (max) {
    this.maximize();
  } else {
    this.move().resize();
  }
  if (mount2) {
    this.mount(mount2);
  } else if (html2) {
    this.body.innerHTML = html2;
  } else if (url) {
    this.setUrl(url);
  }
  if (hidden2) {
    this.hide();
  } else {
    this.focus();
  }
  this.dom.winbox = this;
  register(this);
  (root2 || body).appendChild(this.dom);
}
WinBox["new"] = function(params) {
  return new WinBox(params);
};
function parse$7(num, base, center) {
  if (typeof num === "string") {
    if (num === "center") {
      num = (base - center) / 2 | 0;
    } else if (num === "right" || num === "bottom") {
      num = base - center;
    } else {
      const value2 = parseFloat(num);
      const unit = "" + value2 !== num && num.substring(("" + value2).length);
      if (unit === "%") {
        num = base / 100 * value2 | 0;
      } else {
        num = value2;
      }
    }
  }
  return num;
}
function setup() {
  body = document.body;
  body[prefix_request = "requestFullscreen"] || body[prefix_request = "msRequestFullscreen"] || body[prefix_request = "webkitRequestFullscreen"] || body[prefix_request = "mozRequestFullscreen"] || (prefix_request = "");
  prefix_exit = prefix_request && prefix_request.replace("request", "exit").replace("mozRequest", "mozCancel").replace("Request", "Exit");
  addListener(window, "resize", function() {
    init$2();
    update_min_stack();
  });
  init$2();
}
function register(self2) {
  addWindowListener(self2, "title");
  addWindowListener(self2, "n");
  addWindowListener(self2, "s");
  addWindowListener(self2, "w");
  addWindowListener(self2, "e");
  addWindowListener(self2, "nw");
  addWindowListener(self2, "ne");
  addWindowListener(self2, "se");
  addWindowListener(self2, "sw");
  addListener(getByClass(self2.dom, "wb-min"), "click", function(event2) {
    preventEvent(event2);
    self2.minimize();
  });
  addListener(getByClass(self2.dom, "wb-max"), "click", function(event2) {
    preventEvent(event2);
    self2.focus().maximize();
  });
  if (prefix_request) {
    addListener(getByClass(self2.dom, "wb-full"), "click", function(event2) {
      preventEvent(event2);
      self2.focus().fullscreen();
    });
  } else {
    self2.addClass("no-full");
  }
  addListener(getByClass(self2.dom, "wb-close"), "click", function(event2) {
    preventEvent(event2);
    self2.close() || (self2 = null);
  });
  addListener(self2.dom, "click", function(event2) {
    self2.focus();
  }, false);
}
function remove_min_stack(self2) {
  stack_min.splice(stack_min.indexOf(self2), 1);
  update_min_stack();
  self2.removeClass("min");
  self2.min = false;
  self2.dom.title = "";
}
function update_min_stack() {
  const len = stack_min.length;
  const tile_index = {};
  const tile_len = {};
  for (let i2 = 0, self2, key; i2 < len; i2++) {
    self2 = stack_min[i2];
    key = self2.left + ":" + self2.top;
    if (tile_len[key]) {
      tile_len[key]++;
    } else {
      tile_len[key] = 1;
    }
  }
  for (let i2 = 0, self2, key, width, header, headerHeight; i2 < len; i2++) {
    self2 = stack_min[i2];
    key = self2.left + ":" + self2.top;
    width = Math.min((root_w - self2.left - self2.right) / tile_len[key], 250);
    header = getByClass(self2.dom, "wb-title");
    headerHeight = header.clientHeight;
    tile_index[key] || (tile_index[key] = 0);
    self2.resize(width + 1 | 0, 0, true).move(self2.left + tile_index[key] * width | 0, root_h - self2.bottom - headerHeight, true);
    tile_index[key]++;
  }
}
function addWindowListener(self2, dir) {
  const node = getByClass(self2.dom, "wb-" + dir);
  let touch, x2, y2;
  addListener(node, "mousedown", mousedown);
  addListener(node, "touchstart", mousedown, { "passive": false });
  function mousedown(event2) {
    preventEvent(event2);
    if (self2.min) {
      self2.minimize();
    } else {
      if (dir === "title" && !self2.hasClass("no-max")) {
        const now2 = Date.now();
        const diff = now2 - dblclick_timer;
        dblclick_timer = now2;
        if (diff < 250) {
          self2.maximize();
          return;
        }
      }
      if (!self2.max) {
        addClass(body, "wb-drag");
        if ((touch = event2.touches) && (touch = touch[0])) {
          event2 = touch;
          addListener(window, "touchmove", handler_mousemove);
          addListener(window, "touchend", handler_mouseup);
        } else {
          addListener(window, "mousemove", handler_mousemove);
          addListener(window, "mouseup", handler_mouseup);
        }
        x2 = event2.pageX;
        y2 = event2.pageY;
        self2.focus();
      }
    }
  }
  function handler_mousemove(event2) {
    preventEvent(event2);
    if (touch) {
      event2 = event2.touches[0];
    }
    const pageX = event2.pageX;
    const pageY = event2.pageY;
    const offsetX = pageX - x2;
    const offsetY = pageY - y2;
    let resize_w, resize_h, move_x, move_y;
    if (dir === "title") {
      self2.x += offsetX;
      self2.y += offsetY;
      move_x = move_y = 1;
    } else {
      if (dir === "e" || dir === "se" || dir === "ne") {
        self2.width += offsetX;
        resize_w = 1;
      } else if (dir === "w" || dir === "sw" || dir === "nw") {
        self2.x += offsetX;
        self2.width -= offsetX;
        resize_w = 1;
        move_x = 1;
      }
      if (dir === "s" || dir === "se" || dir === "sw") {
        self2.height += offsetY;
        resize_h = 1;
      } else if (dir === "n" || dir === "ne" || dir === "nw") {
        self2.y += offsetY;
        self2.height -= offsetY;
        resize_h = 1;
        move_y = 1;
      }
    }
    if (resize_w || resize_h) {
      if (resize_w) {
        self2.width = Math.max(Math.min(self2.width, root_w - self2.x - self2.right), 150);
      }
      if (resize_h) {
        self2.height = Math.max(Math.min(self2.height, root_h - self2.y - self2.bottom), 0);
      }
      self2.resize();
    }
    if (move_x || move_y) {
      if (move_x) {
        self2.x = Math.max(Math.min(self2.x, root_w - self2.width - self2.right), self2.left);
      }
      if (move_y) {
        self2.y = Math.max(Math.min(self2.y, root_h - self2.height - self2.bottom), self2.top);
      }
      self2.move();
    }
    x2 = pageX;
    y2 = pageY;
  }
  function handler_mouseup(event2) {
    preventEvent(event2);
    removeClass(body, "wb-drag");
    if (touch) {
      removeListener(window, "touchmove", handler_mousemove);
      removeListener(window, "touchend", handler_mouseup);
    } else {
      removeListener(window, "mousemove", handler_mousemove);
      removeListener(window, "mouseup", handler_mouseup);
    }
  }
}
function init$2() {
  root_w = body.clientWidth;
  root_h = body.clientHeight;
}
WinBox.prototype.mount = function(src) {
  this.unmount();
  src._backstore || (src._backstore = src.parentNode);
  this.body.textContent = "";
  this.body.appendChild(src);
  return this;
};
WinBox.prototype.unmount = function(dest) {
  const node = this.body.firstChild;
  if (node) {
    const root2 = dest || node._backstore;
    root2 && root2.appendChild(node);
    node._backstore = dest;
  }
  return this;
};
WinBox.prototype.setTitle = function(title) {
  setText(getByClass(this.dom, "wb-title"), this.title = title);
  return this;
};
WinBox.prototype.setBackground = function(background) {
  setStyle(this.dom, "background", background);
  return this;
};
WinBox.prototype.setUrl = function(url) {
  this.body.innerHTML = '<iframe src="' + url + '"></iframe>';
  return this;
};
WinBox.prototype.focus = function() {
  if (last_focus !== this) {
    setStyle(this.dom, "z-index", index$1++);
    this.addClass("focus");
    if (last_focus) {
      last_focus.removeClass("focus");
      last_focus.onblur && last_focus.onblur();
    }
    last_focus = this;
    this.onfocus && this.onfocus();
  }
  return this;
};
WinBox.prototype.hide = function() {
  return this.addClass("hide");
};
WinBox.prototype.show = function() {
  return this.removeClass("hide");
};
WinBox.prototype.minimize = function(state2) {
  if (is_fullscreen) {
    cancel_fullscreen();
  }
  if (!state2 && this.min) {
    remove_min_stack(this);
    this.resize().move().focus();
  } else if (state2 !== false && !this.min) {
    stack_min.push(this);
    update_min_stack();
    this.dom.title = this.title;
    this.addClass("min");
    this.min = true;
  }
  if (this.max) {
    this.removeClass("max");
    this.max = false;
  }
  return this;
};
WinBox.prototype.maximize = function(state2) {
  if (typeof state2 === "undefined" || state2 !== this.max) {
    if (this.min) {
      remove_min_stack(this);
    }
    if (this.max = !this.max) {
      this.addClass("max").resize(root_w - this.left - this.right, root_h - this.top - this.bottom, true).move(this.left, this.top, true);
    } else {
      this.resize().move().removeClass("max");
    }
  }
  return this;
};
WinBox.prototype.fullscreen = function(state2) {
  if (typeof state2 === "undefined" || state2 !== is_fullscreen) {
    if (this.min) {
      this.resize().move();
      remove_min_stack(this);
    }
    if (!is_fullscreen || !cancel_fullscreen()) {
      this.body[prefix_request]();
      is_fullscreen = true;
    }
  }
  return this;
};
function has_fullscreen() {
  return document["fullscreen"] || document["fullscreenElement"] || document["webkitFullscreenElement"] || document["mozFullScreenElement"];
}
function cancel_fullscreen(self2) {
  is_fullscreen = false;
  if (has_fullscreen()) {
    document[prefix_exit]();
    return true;
  }
}
WinBox.prototype.close = function(force) {
  if (this.onclose && this.onclose(force)) {
    return true;
  }
  if (this.min) {
    remove_min_stack(this);
  }
  this.unmount();
  this.dom.parentNode.removeChild(this.dom);
  if (last_focus === this) {
    last_focus = null;
  }
};
WinBox.prototype.move = function(x2, y2, _skip_update) {
  if (!x2 && x2 !== 0) {
    x2 = this.x;
    y2 = this.y;
    if (this.splitscreen) {
      if (x2 === 0) {
        this.resize(root_w / 2, root_h);
      } else if (x2 === root_w - this.width) {
        this.resize(root_w / 2, root_h);
      }
    }
  } else if (!_skip_update) {
    this.x = x2 ? x2 = parse$7(x2, root_w - this.left - this.right, this.width) : 0;
    this.y = y2 ? y2 = parse$7(y2, root_h - this.top - this.bottom, this.height) : 0;
  }
  setStyle(this.dom, "transform", "translate(" + x2 + "px," + y2 + "px)");
  this.onmove && this.onmove(x2, y2);
  return this;
};
WinBox.prototype.resize = function(w, h, _skip_update) {
  if (!w && w !== 0) {
    w = this.width;
    h = this.height;
  } else if (!_skip_update) {
    this.width = w ? w = parse$7(w, root_w - this.left - this.right) : 0;
    this.height = h ? h = parse$7(h, root_h - this.top - this.bottom) : 0;
  }
  w = Math.max(w, this.minwidth);
  h = Math.max(h, this.minheight);
  setStyle(this.dom, "width", w + "px");
  setStyle(this.dom, "height", h + "px");
  this.onresize && this.onresize(w, h);
  return this;
};
WinBox.prototype.addClass = function(classname) {
  addClass(this.dom, classname);
  return this;
};
WinBox.prototype.removeClass = function(classname) {
  removeClass(this.dom, classname);
  return this;
};
WinBox.prototype.hasClass = function(classname) {
  return hasClass(this.dom, classname);
};
function add_css$d(target) {
  append_styles(target, "svelte-6jsaqh", ".hidden.svelte-6jsaqh{display:none;visibility:hidden}.winbox.focus{z-index:12000 !important}.winbox{background:none;border-radius:0.5rem;opacity:0.9;z-index:11000 !important}.wb-header{border-radius:0.5rem 0.5rem 0 0;background-color:rgb(0 0 0);opacity:0.95}.wb-title{font-weight:600;font-family:system-ui}.wb-body{border-radius:0 0 0.5rem 0.5rem}fast-design-system-provider{--theme-color:black;--background-color:rgb(66 66 66);--accent-fill-rest:rgb(215 215 215 / 86%);--accent-fill-active:rgb(255 255 255 / 86%);--accent-fill-hover:rgb(255 255 255 / 86%);--accent-foreground-rest:var(--theme-color);--neutral-fill-stealth-hover:var(--theme-color);--neutral-fill-rest:#d1d1d1;--neutral-fill-hover:#d1d1d1;overflow:auto}fast-button:hover{background-color:#ffffff}fast-button{border:1px solid transparent;transition:border-color 100ms ease-in-out;background-color:rgba(255, 255, 255, 0.78);color:black;animation:background-color 300ms ease-in-out}fast-button .content{font-weight:600}.checked{font-weight:500}");
}
function create_fragment$y(ctx) {
  let div2;
  let div_class_value;
  let winbox_action;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      attr(div2, "id", "winbox-target");
      attr(div2, "class", div_class_value = null_to_empty(`${ctx[3]} ${ctx[0] && "hidden"}`) + " svelte-6jsaqh");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (!mounted) {
        dispose = action_destroyer(winbox_action = ctx[4].call(null, div2, {
          html: ctx[2],
          component: ctx[1]
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 9 && div_class_value !== (div_class_value = null_to_empty(`${ctx2[3]} ${ctx2[0] && "hidden"}`) + " svelte-6jsaqh")) {
        attr(div2, "class", div_class_value);
      }
      if (winbox_action && is_function(winbox_action.update) && dirty & 6)
        winbox_action.update.call(null, {
          html: ctx2[2],
          component: ctx2[1]
        });
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function instance_1$1($$self, $$props, $$invalidate) {
  let { component = void 0 } = $$props;
  let { html: html2 = void 0 } = $$props;
  let { props = {} } = $$props;
  let { events = {} } = $$props;
  let { title = "Fields" } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { width = 400 } = $$props;
  let { height = 500 } = $$props;
  let { classes = "" } = $$props;
  let { closeless = false } = $$props;
  let { hidden: hidden2 } = $$props;
  let { windowName = void 0 } = $$props;
  let instance2;
  function newComponent(Component, target) {
    $$invalidate(14, instance2 = new Component({ target, props }));
    const eventNames = Object.keys(events);
    eventNames.forEach((eventName) => {
      instance2.$on(eventName, events[eventName]);
    });
  }
  function winbox2(target, { component: component2, html: html3 }) {
    let _x, _y;
    if (typeof width === "string") {
      _x = x2 === "left" ? 0 : x2 === "right" ? window.innerWidth - window.innerWidth * parseFloat(width) / 100 : "center";
    } else {
      _x = x2 === "left" ? 0 : x2 === "right" ? window.innerWidth - width : "center";
    }
    if (typeof height === "string") {
      _y = y2 === "top" ? 0 : y2 === "bottom" ? window.innerHeight - window.innerHeight * parseFloat(height) / 100 : "center";
    } else {
      _y = y2 === "top" ? 0 : y2 === "bottom" ? window.innerHeight - height : "center";
    }
    let box = new WinBox({
      class: "iteria-ignore",
      title,
      x: _x,
      y: _y,
      width,
      height,
      root: target,
      onclose: (e) => {
        if (closeless) {
          $$invalidate(0, hidden2 = true);
          return true;
        } else {
          const close = events["close"];
          if (typeof close === "function")
            close(e);
        }
      }
    });
    if (windowName) {
      window.windows = __spreadProps(__spreadValues({}, window.windows), {
        [windowName]: {
          maximize: () => {
            box.maximize();
          },
          show: () => {
            box.minimize(false);
          }
        }
      });
    }
    const winboxBody = target.querySelector(`div.wb-body`);
    if (winboxBody) {
      if (html3) {
        winboxBody.innerHTML = html3;
      } else if (component2) {
        newComponent(component2, winboxBody);
      }
    }
    return {
      update: ({ component: component3, html: html4 }) => {
        if (box && box.close)
          box.close();
        box = new WinBox({
          class: "iteria-ignore",
          title,
          x: box.x,
          y: box.y,
          width: box.width,
          height: box.height,
          root: target,
          background: "none",
          onclose: box.close
        });
        const winboxBody2 = target.querySelector(`div.wb-body`);
        if (winboxBody2) {
          if (html4) {
            winboxBody2.innerHTML = html4;
          } else if (component3) {
            newComponent(component3, winboxBody2);
          }
        }
      }
    };
  }
  $$self.$$set = ($$props2) => {
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("html" in $$props2)
      $$invalidate(2, html2 = $$props2.html);
    if ("props" in $$props2)
      $$invalidate(5, props = $$props2.props);
    if ("events" in $$props2)
      $$invalidate(6, events = $$props2.events);
    if ("title" in $$props2)
      $$invalidate(7, title = $$props2.title);
    if ("x" in $$props2)
      $$invalidate(8, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y2 = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(10, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(11, height = $$props2.height);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
    if ("closeless" in $$props2)
      $$invalidate(12, closeless = $$props2.closeless);
    if ("hidden" in $$props2)
      $$invalidate(0, hidden2 = $$props2.hidden);
    if ("windowName" in $$props2)
      $$invalidate(13, windowName = $$props2.windowName);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16416) {
      (instance2 == null ? void 0 : instance2.$$set) && instance2.$$set(props);
    }
  };
  return [
    hidden2,
    component,
    html2,
    classes,
    winbox2,
    props,
    events,
    title,
    x2,
    y2,
    width,
    height,
    closeless,
    windowName,
    instance2
  ];
}
class Winbox_1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance_1$1, create_fragment$y, safe_not_equal, {
      component: 1,
      html: 2,
      props: 5,
      events: 6,
      title: 7,
      x: 8,
      y: 9,
      width: 10,
      height: 11,
      classes: 3,
      closeless: 12,
      hidden: 0,
      windowName: 13
    }, add_css$d);
  }
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function commonjsRequire$1(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var dist$2 = { exports: {} };
var jsuites$1 = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory2) {
    module2.exports = factory2();
  })(commonjsGlobal$1, function() {
    var jSuites2 = function(options2) {
      var obj2 = {};
      var version2 = "4.10.5";
      var find2 = function(DOMElement, component) {
        if (DOMElement[component.type] && DOMElement[component.type] == component) {
          return true;
        }
        if (DOMElement.parentNode) {
          return find2(DOMElement.parentNode, component);
        }
        return false;
      };
      var isOpened = function(e) {
        if (jSuites2.current.length > 0) {
          for (var i2 = 0; i2 < jSuites2.current.length; i2++) {
            if (jSuites2.current[i2] && !find2(e, jSuites2.current[i2])) {
              jSuites2.current[i2].close();
            }
          }
        }
      };
      obj2.init = function() {
        var cornerSize = 15;
        var element2 = null;
        var editorAction = false;
        var state2 = {
          x: null,
          y: null
        };
        var editorMouseDown = function(e) {
          var item = jSuites2.findElement(e.target, "jpanel");
          if (item && !item.classList.contains("readonly")) {
            item.focus();
            var rect = e.target.getBoundingClientRect();
            editorAction = {
              e: item,
              x: e.clientX,
              y: e.clientY,
              w: rect.width,
              h: rect.height,
              d: item.style.cursor,
              resizing: item.style.cursor ? true : false
            };
            if (!item.style.width) {
              item.style.width = rect.width + "px";
            }
            if (!item.style.height) {
              item.style.height = rect.height + "px";
            }
            var s = window.getSelection();
            if (s.rangeCount) {
              for (var i2 = 0; i2 < s.rangeCount; i2++) {
                s.removeRange(s.getRangeAt(i2));
              }
            }
            e.preventDefault();
            e.stopPropagation();
          } else {
            editorAction = false;
          }
          if (e.changedTouches && e.changedTouches[0]) {
            var x2 = e.changedTouches[0].clientX;
            var y2 = e.changedTouches[0].clientY;
          } else {
            var x2 = e.clientX;
            var y2 = e.clientY;
          }
          var path2 = event.path || event.composedPath && event.composedPath();
          if (path2) {
            element2 = path2[0];
          } else {
            if (e.target && e.target.shadowRoot) {
              var d = e.target.shadowRoot;
            } else {
              var d = document;
            }
            element2 = d.elementFromPoint(x2, y2);
          }
          isOpened(element2);
        };
        var editorMouseUp = function(e) {
          if (editorAction && editorAction.e) {
            if (typeof editorAction.e.refresh == "function") {
              editorAction.e.refresh();
            }
            editorAction.e.style.cursor = "";
          }
          state2 = {
            x: null,
            y: null
          };
          editorAction = false;
        };
        var editorMouseMove = function(e) {
          if (editorAction) {
            var x2 = e.clientX || e.pageX;
            var y2 = e.clientY || e.pageY;
            if (!editorAction.resizing) {
              if (state2.x == null && state2.y == null) {
                state2.x = x2;
                state2.y = y2;
              }
              var dx = x2 - state2.x;
              var dy = y2 - state2.y;
              var top = editorAction.e.offsetTop + dy;
              var left = editorAction.e.offsetLeft + dx;
              editorAction.e.style.top = top + "px";
              editorAction.e.style.left = left + "px";
              editorAction.e.style.cursor = "move";
              state2.x = x2;
              state2.y = y2;
              if (typeof editorAction.e.refresh == "function") {
                editorAction.e.refresh("position", top, left);
              }
            } else {
              var width = null;
              var height = null;
              if (editorAction.d == "e-resize" || editorAction.d == "ne-resize" || editorAction.d == "se-resize") {
                width = editorAction.w + (x2 - editorAction.x);
                editorAction.e.style.width = width + "px";
                if (e.shiftKey) {
                  var newHeight = (x2 - editorAction.x) * (editorAction.h / editorAction.w);
                  height = editorAction.h + newHeight;
                  editorAction.e.style.height = height + "px";
                } else {
                  var newHeight = false;
                }
              }
              if (!newHeight) {
                if (editorAction.d == "s-resize" || editorAction.d == "se-resize" || editorAction.d == "sw-resize") {
                  height = editorAction.h + (y2 - editorAction.y);
                  editorAction.e.style.height = height + "px";
                }
              }
              if (typeof editorAction.e.refresh == "function") {
                editorAction.e.refresh("dimensions", width, height);
              }
            }
          } else {
            var item = jSuites2.findElement(e.target, "jpanel");
            if (item) {
              if (item.getAttribute("tabindex")) {
                var rect = item.getBoundingClientRect();
                if (e.clientY - rect.top < cornerSize) {
                  if (rect.width - (e.clientX - rect.left) < cornerSize) {
                    item.style.cursor = "ne-resize";
                  } else if (e.clientX - rect.left < cornerSize) {
                    item.style.cursor = "nw-resize";
                  } else {
                    item.style.cursor = "n-resize";
                  }
                } else if (rect.height - (e.clientY - rect.top) < cornerSize) {
                  if (rect.width - (e.clientX - rect.left) < cornerSize) {
                    item.style.cursor = "se-resize";
                  } else if (e.clientX - rect.left < cornerSize) {
                    item.style.cursor = "sw-resize";
                  } else {
                    item.style.cursor = "s-resize";
                  }
                } else if (rect.width - (e.clientX - rect.left) < cornerSize) {
                  item.style.cursor = "e-resize";
                } else if (e.clientX - rect.left < cornerSize) {
                  item.style.cursor = "w-resize";
                } else {
                  item.style.cursor = "";
                }
              }
            }
          }
        };
        var editorDblClick = function(e) {
          var item = jSuites2.findElement(e.target, "jpanel");
          if (item && typeof item.dblclick == "function") {
            item.dblclick(e);
          }
        };
        var editorContextmenu = function(e) {
          var item = document.activeElement;
          if (item && typeof item.contextmenu == "function") {
            item.contextmenu(e);
            e.preventDefault();
            e.stopImmediatePropagation();
          } else {
            item = jSuites2.findElement(e.target, function(o2) {
              return o2.tagName && o2.getAttribute("aria-contextmenu-id");
            });
            if (item) {
              var o = document.querySelector("#" + item);
              if (!o) {
                console.error("JSUITES: contextmenu id not found: " + item);
              } else {
                o.contextmenu.open(e);
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            }
          }
        };
        var editorKeyDown = function(e) {
          var item = document.activeElement;
          if (item) {
            if (e.key == "Delete" && typeof item.delete == "function") {
              item.delete();
              e.preventDefault();
              e.stopImmediatePropagation();
            }
          }
          if (jSuites2.current.length) {
            if (item = jSuites2.current[jSuites2.current.length - 1]) {
              if (e.key == "Escape" && typeof item.close == "function") {
                item.close();
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            }
          }
        };
        document.addEventListener("mouseup", editorMouseUp);
        document.addEventListener("mousedown", editorMouseDown);
        document.addEventListener("mousemove", editorMouseMove);
        document.addEventListener("dblclick", editorDblClick);
        document.addEventListener("keydown", editorKeyDown);
        document.addEventListener("contextmenu", editorContextmenu);
        document.dictionary = {};
        obj2.version = version2;
      };
      obj2.setExtensions = function(o) {
        if (typeof o == "object") {
          var k2 = Object.keys(o);
          for (var i2 = 0; i2 < k2.length; i2++) {
            obj2[k2[i2]] = o[k2[i2]];
          }
        }
      };
      obj2.tracking = function(component, state2) {
        if (state2 == true) {
          jSuites2.current = jSuites2.current.filter(function(v) {
            return v !== null;
          });
          setTimeout(function() {
            jSuites2.current.push(component);
          }, 0);
        } else {
          var index2 = jSuites2.current.indexOf(component);
          if (index2 >= 0) {
            jSuites2.current.splice(index2, 1);
          }
        }
      };
      obj2.path = function(str2, val) {
        str2 = str2.split(".");
        if (str2.length) {
          var o = this;
          var p2 = null;
          while (str2.length > 1) {
            p2 = str2.shift();
            if (o.hasOwnProperty(p2)) {
              o = o[p2];
            } else {
              if (val === void 0) {
                return void 0;
              } else {
                o[p2] = {};
                o = o[p2];
              }
            }
          }
          p2 = str2.shift();
          if (val !== void 0) {
            o[p2] = val;
            return true;
          } else {
            if (o) {
              return o[p2];
            }
          }
        }
        return false;
      };
      obj2.setDictionary = function(d) {
        if (!document.dictionary) {
          document.dictionary = {};
        }
        var k2 = Object.keys(d);
        for (var i2 = 0; i2 < k2.length; i2++) {
          document.dictionary[k2[i2]] = d[k2[i2]];
        }
        var t = null;
        for (var i2 = 0; i2 < jSuites2.calendar.weekdays.length; i2++) {
          t = jSuites2.translate(jSuites2.calendar.weekdays[i2]);
          if (jSuites2.calendar.weekdays[i2]) {
            jSuites2.calendar.weekdays[i2] = t;
            jSuites2.calendar.weekdaysShort[i2] = t.substr(0, 3);
          }
        }
        for (var i2 = 0; i2 < jSuites2.calendar.months.length; i2++) {
          t = jSuites2.translate(jSuites2.calendar.months[i2]);
          if (t) {
            jSuites2.calendar.months[i2] = t;
            jSuites2.calendar.monthsShort[i2] = t.substr(0, 3);
          }
        }
      };
      obj2.translate = function(t) {
        if (document.dictionary) {
          return document.dictionary[t] || t;
        } else {
          return t;
        }
      };
      obj2.current = [];
      return obj2;
    }();
    if (typeof document !== "undefined") {
      jSuites2.init();
    }
    jSuites2.ajax = function(options2, complete) {
      if (Array.isArray(options2)) {
        var multiple = {
          instance: [],
          complete
        };
        if (options2.length > 0) {
          for (var i2 = 0; i2 < options2.length; i2++) {
            options2[i2].multiple = multiple;
            multiple.instance.push(jSuites2.ajax(options2[i2]));
          }
        }
        return multiple;
      }
      if (!options2.data) {
        options2.data = {};
      }
      if (options2.type) {
        options2.method = options2.type;
      }
      if (!options2.method) {
        options2.method = "GET";
      }
      if (!options2.dataType) {
        options2.dataType = "json";
      }
      if (options2.data) {
        var parseData = function(value2, key) {
          var vars2 = [];
          var keys2 = Object.keys(value2);
          if (keys2.length) {
            for (var i3 = 0; i3 < keys2.length; i3++) {
              if (key) {
                var k3 = key + "[" + keys2[i3] + "]";
              } else {
                var k3 = keys2[i3];
              }
              if (value2[k3] instanceof FileList) {
                vars2[k3] = value2[keys2[i3]];
              } else if (typeof value2[keys2[i3]] == "object") {
                var r = parseData(value2[keys2[i3]], k3);
                var o = Object.keys(r);
                for (var j3 = 0; j3 < o.length; j3++) {
                  vars2[o[j3]] = r[o[j3]];
                }
              } else {
                vars2[k3] = value2[keys2[i3]];
              }
            }
          }
          return vars2;
        };
        var d = parseData(options2.data);
        var k2 = Object.keys(d);
        if (options2.method == "GET") {
          if (k2.length) {
            var data = [];
            for (var i2 = 0; i2 < k2.length; i2++) {
              data.push(k2[i2] + "=" + encodeURIComponent(d[k2[i2]]));
            }
            if (options2.url.indexOf("?") < 0) {
              options2.url += "?";
            }
            options2.url += data.join("&");
          }
        } else {
          var data = new FormData();
          for (var i2 = 0; i2 < k2.length; i2++) {
            if (d[k2[i2]] instanceof FileList) {
              if (d[k2[i2]].length) {
                for (var j2 = 0; j2 < d[k2[i2]].length; j2++) {
                  data.append(k2[i2], d[k2[i2]][j2], d[k2[i2]][j2].name);
                }
              }
            } else {
              data.append(k2[i2], d[k2[i2]]);
            }
          }
        }
      }
      var httpRequest = new XMLHttpRequest();
      httpRequest.open(options2.method, options2.url, true);
      httpRequest.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      if (options2.contentType) {
        httpRequest.setRequestHeader("Content-Type", options2.contentType);
      }
      if (options2.method == "POST") {
        httpRequest.setRequestHeader("Accept", "application/json");
      } else {
        if (options2.dataType == "blob") {
          httpRequest.responseType = "blob";
        } else {
          if (!options2.contentType) {
            if (options2.dataType == "json") {
              httpRequest.setRequestHeader("Content-Type", "text/json");
            } else if (options2.dataType == "html") {
              httpRequest.setRequestHeader("Content-Type", "text/html");
            }
          }
        }
      }
      if (options2.cache != true) {
        httpRequest.setRequestHeader("pragma", "no-cache");
        httpRequest.setRequestHeader("cache-control", "no-cache");
      }
      if (options2.withCredentials == true) {
        httpRequest.withCredentials = true;
      }
      if (typeof options2.beforeSend == "function") {
        options2.beforeSend(httpRequest);
      }
      if (typeof jSuites2.ajax.beforeSend == "function") {
        jSuites2.ajax.beforeSend(httpRequest);
      }
      if (document.ajax && typeof document.ajax.beforeSend == "function") {
        document.ajax.beforeSend(httpRequest);
      }
      httpRequest.onload = function() {
        if (httpRequest.status === 200) {
          if (options2.dataType == "json") {
            try {
              var result2 = JSON.parse(httpRequest.responseText);
              if (options2.success && typeof options2.success == "function") {
                options2.success(result2);
              }
            } catch (err2) {
              if (options2.error && typeof options2.error == "function") {
                options2.error(err2, result2);
              }
            }
          } else {
            if (options2.dataType == "blob") {
              var result2 = httpRequest.response;
            } else {
              var result2 = httpRequest.responseText;
            }
            if (options2.success && typeof options2.success == "function") {
              options2.success(result2);
            }
          }
        } else {
          if (options2.error && typeof options2.error == "function") {
            options2.error(httpRequest.responseText, httpRequest.status);
          }
        }
        if (jSuites2.ajax.queue && jSuites2.ajax.queue.length > 0) {
          jSuites2.ajax.send(jSuites2.ajax.queue.shift());
        }
        if (jSuites2.ajax.requests && jSuites2.ajax.requests.length) {
          var index2 = jSuites2.ajax.requests.indexOf(httpRequest);
          jSuites2.ajax.requests.splice(index2, 1);
          if (!jSuites2.ajax.requests.length) {
            if (options2.complete && typeof options2.complete == "function") {
              options2.complete(result2);
            }
          }
          if (options2.group) {
            if (jSuites2.ajax.oncomplete && typeof jSuites2.ajax.oncomplete[options2.group] == "function") {
              if (!jSuites2.ajax.pending(options2.group)) {
                jSuites2.ajax.oncomplete[options2.group]();
                jSuites2.ajax.oncomplete[options2.group] = null;
              }
            }
          }
          if (options2.multiple && options2.multiple.instance) {
            var index2 = options2.multiple.instance.indexOf(httpRequest);
            options2.multiple.instance.splice(index2, 1);
            if (!options2.multiple.instance.length) {
              if (options2.multiple.complete && typeof options2.multiple.complete == "function") {
                options2.multiple.complete(result2);
              }
            }
          }
        }
      };
      httpRequest.options = options2;
      httpRequest.data = data;
      if (options2.queue == true && jSuites2.ajax.requests.length > 0) {
        jSuites2.ajax.queue.push(httpRequest);
      } else {
        jSuites2.ajax.send(httpRequest);
      }
      return httpRequest;
    };
    jSuites2.ajax.send = function(httpRequest) {
      if (httpRequest.data) {
        if (Array.isArray(httpRequest.data)) {
          httpRequest.send(httpRequest.data.join("&"));
        } else {
          httpRequest.send(httpRequest.data);
        }
      } else {
        httpRequest.send();
      }
      jSuites2.ajax.requests.push(httpRequest);
    };
    jSuites2.ajax.exists = function(url, __callback) {
      var http = new XMLHttpRequest();
      http.open("HEAD", url, false);
      http.send();
      if (http.status) {
        __callback(http.status);
      }
    };
    jSuites2.ajax.pending = function(group) {
      var n2 = 0;
      var o = jSuites2.ajax.requests;
      if (o && o.length) {
        for (var i2 = 0; i2 < o.length; i2++) {
          if (!group || group == o[i2].options.group) {
            n2++;
          }
        }
      }
      return n2;
    };
    jSuites2.ajax.oncomplete = {};
    jSuites2.ajax.requests = [];
    jSuites2.ajax.queue = [];
    jSuites2.alert = function(message) {
      if (jSuites2.getWindowWidth() < 800 && jSuites2.dialog) {
        jSuites2.dialog.open({
          title: "Alert",
          message
        });
      } else {
        alert(message);
      }
    };
    jSuites2.animation = {};
    jSuites2.animation.slideLeft = function(element2, direction, done) {
      if (direction == true) {
        element2.classList.add("slide-left-in");
        setTimeout(function() {
          element2.classList.remove("slide-left-in");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      } else {
        element2.classList.add("slide-left-out");
        setTimeout(function() {
          element2.classList.remove("slide-left-out");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      }
    };
    jSuites2.animation.slideRight = function(element2, direction, done) {
      if (direction == true) {
        element2.classList.add("slide-right-in");
        setTimeout(function() {
          element2.classList.remove("slide-right-in");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      } else {
        element2.classList.add("slide-right-out");
        setTimeout(function() {
          element2.classList.remove("slide-right-out");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      }
    };
    jSuites2.animation.slideTop = function(element2, direction, done) {
      if (direction == true) {
        element2.classList.add("slide-top-in");
        setTimeout(function() {
          element2.classList.remove("slide-top-in");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      } else {
        element2.classList.add("slide-top-out");
        setTimeout(function() {
          element2.classList.remove("slide-top-out");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      }
    };
    jSuites2.animation.slideBottom = function(element2, direction, done) {
      if (direction == true) {
        element2.classList.add("slide-bottom-in");
        setTimeout(function() {
          element2.classList.remove("slide-bottom-in");
          if (typeof done == "function") {
            done();
          }
        }, 400);
      } else {
        element2.classList.add("slide-bottom-out");
        setTimeout(function() {
          element2.classList.remove("slide-bottom-out");
          if (typeof done == "function") {
            done();
          }
        }, 100);
      }
    };
    jSuites2.animation.fadeIn = function(element2, done) {
      element2.style.display = "";
      element2.classList.add("fade-in");
      setTimeout(function() {
        element2.classList.remove("fade-in");
        if (typeof done == "function") {
          done();
        }
      }, 2e3);
    };
    jSuites2.animation.fadeOut = function(element2, done) {
      element2.classList.add("fade-out");
      setTimeout(function() {
        element2.style.display = "none";
        element2.classList.remove("fade-out");
        if (typeof done == "function") {
          done();
        }
      }, 1e3);
    };
    jSuites2.calendar = function(el2, options2) {
      if (el2.calendar) {
        return el2.calendar.setOptions(options2, true);
      }
      var obj2 = { type: "calendar" };
      obj2.options = {};
      obj2.date = null;
      obj2.setOptions = function(options3, reset) {
        var defaults2 = {
          type: "default",
          validRange: null,
          startingDay: null,
          format: "DD/MM/YYYY",
          readonly: true,
          today: false,
          time: false,
          resetButton: true,
          placeholder: "",
          months: jSuites2.calendar.monthsShort,
          monthsFull: jSuites2.calendar.months,
          weekdays: jSuites2.calendar.weekdays,
          weekdays_short: jSuites2.calendar.weekdays,
          textDone: jSuites2.translate("Done"),
          textReset: jSuites2.translate("Reset"),
          textUpdate: jSuites2.translate("Update"),
          value: null,
          fullscreen: false,
          opened: false,
          onopen: null,
          onclose: null,
          onchange: null,
          onupdate: null,
          mode: null,
          position: null,
          dataType: null
        };
        for (var i2 = 0; i2 < defaults2.weekdays_short.length; i2++) {
          defaults2.weekdays_short[i2] = defaults2.weekdays_short[i2].substr(0, 1);
        }
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        if (obj2.options.resetButton == false) {
          calendarReset.style.display = "none";
        } else {
          calendarReset.style.display = "";
        }
        if (obj2.options.readonly) {
          el2.setAttribute("readonly", "readonly");
        } else {
          el2.removeAttribute("readonly");
        }
        if (obj2.options.placeholder) {
          el2.setAttribute("placeholder", obj2.options.placeholder);
        } else {
          el2.removeAttribute("placeholder");
        }
        if (jSuites2.isNumeric(obj2.options.value) && obj2.options.value > 0) {
          obj2.options.value = jSuites2.calendar.numToDate(obj2.options.value);
          obj2.options.dataType = "numeric";
        }
        calendarReset.innerHTML = obj2.options.textReset;
        calendarConfirm.innerHTML = obj2.options.textDone;
        calendarControlsUpdateButton.innerHTML = obj2.options.textUpdate;
        el2.setAttribute("data-mask", obj2.options.format.toLowerCase());
        if (!obj2.options.value && obj2.options.today) {
          var value2 = jSuites2.calendar.now();
        } else {
          var value2 = obj2.options.value;
        }
        if (value2) {
          obj2.options.value = null;
          obj2.setValue(value2);
        }
        return obj2;
      };
      obj2.open = function(value2) {
        if (!calendar.classList.contains("jcalendar-focus")) {
          if (!calendar.classList.contains("jcalendar-inline")) {
            jSuites2.calendar.current = obj2;
            jSuites2.tracking(obj2, true);
            obj2.getDays();
            if (obj2.options.type == "year-month-picker") {
              obj2.getMonths();
            }
            if (obj2.options.time) {
              calendarSelectHour.value = obj2.date[3];
              calendarSelectMin.value = obj2.date[4];
            }
            calendar.classList.add("jcalendar-focus");
            if (jSuites2.getWindowWidth() < 800 || obj2.options.fullscreen) {
              calendar.classList.add("jcalendar-fullsize");
              jSuites2.animation.slideBottom(calendarContent, 1);
            } else {
              calendar.classList.remove("jcalendar-fullsize");
              var rect = el2.getBoundingClientRect();
              var rectContent = calendarContent.getBoundingClientRect();
              if (obj2.options.position) {
                calendarContainer.style.position = "fixed";
                if (window.innerHeight < rect.bottom + rectContent.height) {
                  calendarContainer.style.top = rect.top - (rectContent.height + 2) + "px";
                } else {
                  calendarContainer.style.top = rect.top + rect.height + 2 + "px";
                }
                calendarContainer.style.left = rect.left + "px";
              } else {
                if (window.innerHeight < rect.bottom + rectContent.height) {
                  var d = -1 * (rect.height + rectContent.height + 2);
                  if (d + rect.top < 0) {
                    d = -1 * (rect.top + rect.height);
                  }
                  calendarContainer.style.top = d + "px";
                } else {
                  calendarContainer.style.top = 2 + "px";
                }
                if (window.innerWidth < rect.left + rectContent.width) {
                  var d = window.innerWidth - (rect.left + rectContent.width + 20);
                  calendarContainer.style.left = d + "px";
                } else {
                  calendarContainer.style.left = "0px";
                }
              }
            }
            if (typeof obj2.options.onopen == "function") {
              obj2.options.onopen(el2);
            }
          }
        }
      };
      obj2.close = function(ignoreEvents, update2) {
        if (calendar.classList.contains("jcalendar-focus")) {
          if (update2 !== false) {
            var element2 = calendar.querySelector(".jcalendar-selected");
            if (typeof update2 == "string") {
              var value2 = update2;
            } else if (!element2 || element2.classList.contains("jcalendar-disabled")) {
              var value2 = obj2.options.value;
            } else {
              var value2 = obj2.getValue();
            }
            obj2.setValue(value2);
          }
          if (!ignoreEvents && typeof obj2.options.onclose == "function") {
            obj2.options.onclose(el2);
          }
          calendar.classList.remove("jcalendar-focus");
          jSuites2.tracking(obj2, false);
          jSuites2.calendar.current = null;
        }
        return obj2.options.value;
      };
      obj2.prev = function() {
        if (obj2.options.mode == "years") {
          obj2.date[0] = obj2.date[0] - 12;
          obj2.getYears();
        } else if (obj2.options.mode == "months") {
          obj2.date[0] = parseInt(obj2.date[0]) - 1;
          obj2.getMonths();
        } else {
          if (obj2.date[1] < 2) {
            obj2.date[0] = obj2.date[0] - 1;
            obj2.date[1] = 12;
          } else {
            obj2.date[1] = obj2.date[1] - 1;
          }
          obj2.getDays();
        }
      };
      obj2.next = function() {
        if (obj2.options.mode == "years") {
          obj2.date[0] = parseInt(obj2.date[0]) + 12;
          obj2.getYears();
        } else if (obj2.options.mode == "months") {
          obj2.date[0] = parseInt(obj2.date[0]) + 1;
          obj2.getMonths();
        } else {
          if (obj2.date[1] > 11) {
            obj2.date[0] = parseInt(obj2.date[0]) + 1;
            obj2.date[1] = 1;
          } else {
            obj2.date[1] = parseInt(obj2.date[1]) + 1;
          }
          obj2.getDays();
        }
      };
      obj2.setToday = function() {
        var value2 = new Date().toISOString().substr(0, 10);
        obj2.setValue(value2);
        return value2;
      };
      obj2.setValue = function(val) {
        if (!val) {
          val = "" + val;
        }
        var newValue = val;
        var oldValue = obj2.options.value;
        if (oldValue != newValue) {
          if (!newValue) {
            obj2.date = null;
            var val = "";
          } else {
            obj2.setLabel(newValue, obj2.options);
            var date = newValue.split(" ");
            if (!date[1]) {
              date[1] = "00:00:00";
            }
            var time = date[1].split(":");
            var date = date[0].split("-");
            var y2 = parseInt(date[0]);
            var m = parseInt(date[1]);
            var d = parseInt(date[2]);
            var h = parseInt(time[0]);
            var i2 = parseInt(time[1]);
            obj2.date = [y2, m, d, h, i2, 0];
            var val = obj2.setLabel(newValue, obj2.options);
          }
          obj2.options.value = newValue;
          if (typeof obj2.options.onchange == "function") {
            obj2.options.onchange(el2, newValue, oldValue);
          }
          if (el2.value != val) {
            el2.value = val;
            if (typeof el2.oninput == "function") {
              el2.oninput({
                type: "input",
                target: el2,
                value: el2.value
              });
            }
          }
        }
        obj2.getDays();
      };
      obj2.getValue = function() {
        if (obj2.date) {
          if (obj2.options.time) {
            return jSuites2.two(obj2.date[0]) + "-" + jSuites2.two(obj2.date[1]) + "-" + jSuites2.two(obj2.date[2]) + " " + jSuites2.two(obj2.date[3]) + ":" + jSuites2.two(obj2.date[4]) + ":" + jSuites2.two(0);
          } else {
            return jSuites2.two(obj2.date[0]) + "-" + jSuites2.two(obj2.date[1]) + "-" + jSuites2.two(obj2.date[2]) + " " + jSuites2.two(0) + ":" + jSuites2.two(0) + ":" + jSuites2.two(0);
          }
        } else {
          return "";
        }
      };
      obj2.update = function(element2, v) {
        if (element2.classList.contains("jcalendar-disabled"))
          ;
        else {
          var elements2 = calendar.querySelector(".jcalendar-selected");
          if (elements2) {
            elements2.classList.remove("jcalendar-selected");
          }
          element2.classList.add("jcalendar-selected");
          if (element2.classList.contains("jcalendar-set-month")) {
            obj2.date[1] = v;
          } else {
            obj2.date[2] = element2.innerText;
          }
          if (!obj2.options.time) {
            obj2.close();
          } else {
            obj2.date[3] = calendarSelectHour.value;
            obj2.date[4] = calendarSelectMin.value;
          }
        }
        updateActions();
      };
      obj2.reset = function() {
        obj2.setValue("");
        obj2.date = null;
        obj2.close(false, false);
      };
      obj2.getDays = function() {
        obj2.options.mode = "days";
        var date = new Date();
        var year = obj2.date && jSuites2.isNumeric(obj2.date[0]) ? obj2.date[0] : parseInt(date.getFullYear());
        var month = obj2.date && jSuites2.isNumeric(obj2.date[1]) ? obj2.date[1] : parseInt(date.getMonth()) + 1;
        var day = obj2.date && jSuites2.isNumeric(obj2.date[2]) ? obj2.date[2] : parseInt(date.getDate());
        var hour = obj2.date && jSuites2.isNumeric(obj2.date[3]) ? obj2.date[3] : parseInt(date.getHours());
        var min = obj2.date && jSuites2.isNumeric(obj2.date[4]) ? obj2.date[4] : parseInt(date.getMinutes());
        obj2.date = [year, month, day, hour, min, 0];
        calendarLabelYear.innerHTML = year;
        calendarLabelMonth.innerHTML = obj2.options.months[month - 1];
        var isCurrentMonthAndYear = date.getMonth() == month - 1 && date.getFullYear() == year ? true : false;
        var currentDay = date.getDate();
        var date = new Date(year, month, 0, 0, 0);
        var numberOfDays = date.getDate();
        var date = new Date(year, month - 1, 0, 0, 0);
        var firstDay = date.getDay() + 1;
        var index2 = obj2.options.startingDay || 0;
        firstDay = firstDay - index2;
        calendarBody.innerHTML = "";
        var row = document.createElement("tr");
        row.setAttribute("align", "center");
        calendarBody.appendChild(row);
        for (var i2 = 0; i2 < 7; i2++) {
          var cell = document.createElement("td");
          cell.classList.add("jcalendar-weekday");
          cell.innerHTML = obj2.options.weekdays_short[index2];
          row.appendChild(cell);
          index2++;
          if (index2 > 6) {
            index2 = 0;
          }
        }
        var index2 = 0;
        var d = 0;
        for (var j2 = 0; j2 < 6; j2++) {
          var row = document.createElement("tr");
          row.setAttribute("align", "center");
          var emptyRow = true;
          for (var i2 = 0; i2 < 7; i2++) {
            var cell = document.createElement("td");
            cell.classList.add("jcalendar-set-day");
            if (index2 >= firstDay && index2 < firstDay + numberOfDays) {
              d++;
              cell.innerHTML = d;
              if (d == day) {
                cell.classList.add("jcalendar-selected");
              }
              if (isCurrentMonthAndYear && currentDay == d) {
                cell.style.fontWeight = "bold";
              }
              var current = jSuites2.calendar.now(new Date(year, month - 1, d), true);
              if (obj2.options.validRange) {
                if (!obj2.options.validRange[0] || current >= obj2.options.validRange[0]) {
                  var test1 = true;
                } else {
                  var test1 = false;
                }
                if (!obj2.options.validRange[1] || current <= obj2.options.validRange[1]) {
                  var test2 = true;
                } else {
                  var test2 = false;
                }
                if (!(test1 && test2)) {
                  cell.classList.add("jcalendar-disabled");
                }
              }
              emptyRow = false;
            }
            row.appendChild(cell);
            index2++;
          }
          if (emptyRow == false) {
            calendarBody.appendChild(row);
          }
        }
        if (obj2.options.time) {
          calendarControlsTime.style.display = "";
        } else {
          calendarControlsTime.style.display = "none";
        }
        updateActions();
      };
      obj2.getMonths = function() {
        obj2.options.mode = "months";
        var months = obj2.options.months;
        obj2.options.value;
        var date = new Date();
        var currentYear = parseInt(date.getFullYear());
        var currentMonth = parseInt(date.getMonth()) + 1;
        var selectedYear = obj2.date && jSuites2.isNumeric(obj2.date[0]) ? obj2.date[0] : currentYear;
        var selectedMonth = obj2.date && jSuites2.isNumeric(obj2.date[1]) ? obj2.date[1] : currentMonth;
        calendarLabelYear.innerHTML = obj2.date[0];
        calendarLabelMonth.innerHTML = months[selectedMonth - 1];
        var table = document.createElement("table");
        table.setAttribute("width", "100%");
        var row = null;
        for (var i2 = 0; i2 < 12; i2++) {
          if (!(i2 % 4)) {
            var row = document.createElement("tr");
            row.setAttribute("align", "center");
            table.appendChild(row);
          }
          var cell = document.createElement("td");
          cell.classList.add("jcalendar-set-month");
          cell.setAttribute("data-value", i2 + 1);
          cell.innerText = months[i2];
          if (obj2.options.validRange) {
            var current = selectedYear + "-" + jSuites2.two(i2 + 1);
            if (!obj2.options.validRange[0] || current >= obj2.options.validRange[0].substr(0, 7)) {
              var test1 = true;
            } else {
              var test1 = false;
            }
            if (!obj2.options.validRange[1] || current <= obj2.options.validRange[1].substr(0, 7)) {
              var test2 = true;
            } else {
              var test2 = false;
            }
            if (!(test1 && test2)) {
              cell.classList.add("jcalendar-disabled");
            }
          }
          if (i2 + 1 == selectedMonth) {
            cell.classList.add("jcalendar-selected");
          }
          if (currentYear == selectedYear && i2 + 1 == currentMonth) {
            cell.style.fontWeight = "bold";
          }
          row.appendChild(cell);
        }
        calendarBody.innerHTML = '<tr><td colspan="7"></td></tr>';
        calendarBody.children[0].children[0].appendChild(table);
        updateActions();
      };
      obj2.getYears = function() {
        obj2.options.mode = "years";
        var date = new Date();
        var currentYear = date.getFullYear();
        var selectedYear = obj2.date && jSuites2.isNumeric(obj2.date[0]) ? obj2.date[0] : parseInt(date.getFullYear());
        var y2 = [];
        for (var i2 = 0; i2 < 25; i2++) {
          y2[i2] = parseInt(obj2.date[0]) + (i2 - 12);
        }
        var table = document.createElement("table");
        table.setAttribute("width", "100%");
        for (var i2 = 0; i2 < 25; i2++) {
          if (!(i2 % 5)) {
            var row = document.createElement("tr");
            row.setAttribute("align", "center");
            table.appendChild(row);
          }
          var cell = document.createElement("td");
          cell.classList.add("jcalendar-set-year");
          cell.innerText = y2[i2];
          if (selectedYear == y2[i2]) {
            cell.classList.add("jcalendar-selected");
          }
          if (currentYear == y2[i2]) {
            cell.style.fontWeight = "bold";
          }
          row.appendChild(cell);
        }
        calendarBody.innerHTML = '<tr><td colspan="7"></td></tr>';
        calendarBody.firstChild.firstChild.appendChild(table);
        updateActions();
      };
      obj2.setLabel = function(value2, mixed) {
        return jSuites2.calendar.getDateString(value2, mixed);
      };
      obj2.fromFormatted = function(value2, format22) {
        return jSuites2.calendar.extractDateFromString(value2, format22);
      };
      var mouseUpControls = function(e) {
        var element2 = jSuites2.findElement(e.target, "jcalendar-container");
        if (element2) {
          var action = e.target.className;
          if (action == "jcalendar-prev") {
            obj2.prev();
          } else if (action == "jcalendar-next") {
            obj2.next();
          } else if (action == "jcalendar-month") {
            obj2.getMonths();
          } else if (action == "jcalendar-year") {
            obj2.getYears();
          } else if (action == "jcalendar-set-year") {
            obj2.date[0] = e.target.innerText;
            if (obj2.options.type == "year-month-picker") {
              obj2.getMonths();
            } else {
              obj2.getDays();
            }
          } else if (e.target.classList.contains("jcalendar-set-month")) {
            var month = parseInt(e.target.getAttribute("data-value"));
            if (obj2.options.type == "year-month-picker") {
              obj2.update(e.target, month);
            } else {
              obj2.date[1] = month;
              obj2.getDays();
            }
          } else if (action == "jcalendar-confirm" || action == "jcalendar-update" || action == "jcalendar-close") {
            obj2.close();
          } else if (action == "jcalendar-backdrop") {
            obj2.close(false, false);
          } else if (action == "jcalendar-reset") {
            obj2.reset();
          } else if (e.target.classList.contains("jcalendar-set-day") && e.target.innerText) {
            obj2.update(e.target);
          }
        } else {
          obj2.close();
        }
      };
      var keyUpControls = function(e) {
        if (e.target.value && e.target.value.length > 3) {
          var test = jSuites2.calendar.extractDateFromString(e.target.value, obj2.options.format);
          if (test) {
            obj2.setValue(test);
          }
        }
      };
      var updateActions = function() {
        var currentDay = calendar.querySelector(".jcalendar-selected");
        if (currentDay && currentDay.classList.contains("jcalendar-disabled")) {
          calendarControlsUpdateButton.setAttribute("disabled", "disabled");
          calendarSelectHour.setAttribute("disabled", "disabled");
          calendarSelectMin.setAttribute("disabled", "disabled");
        } else {
          calendarControlsUpdateButton.removeAttribute("disabled");
          calendarSelectHour.removeAttribute("disabled");
          calendarSelectMin.removeAttribute("disabled");
        }
        if (typeof obj2.options.onupdate == "function") {
          obj2.options.onupdate(el2, obj2.getValue());
        }
      };
      var calendar = null;
      var calendarReset = null;
      var calendarConfirm = null;
      var calendarContainer = null;
      var calendarContent = null;
      var calendarLabelYear = null;
      var calendarLabelMonth = null;
      var calendarTable = null;
      var calendarBody = null;
      var calendarControls = null;
      var calendarControlsTime = null;
      var calendarControlsUpdate = null;
      var calendarControlsUpdateButton = null;
      var calendarSelectHour = null;
      var calendarSelectMin = null;
      var init2 = function() {
        if (el2.tagName == "INPUT" && el2.value) {
          options2.value = el2.value;
        }
        calendarReset = document.createElement("div");
        calendarReset.className = "jcalendar-reset";
        calendarConfirm = document.createElement("div");
        calendarConfirm.className = "jcalendar-confirm";
        calendarControls = document.createElement("div");
        calendarControls.className = "jcalendar-controls";
        calendarControls.style.borderBottom = "1px solid #ddd";
        calendarControls.appendChild(calendarReset);
        calendarControls.appendChild(calendarConfirm);
        calendarContainer = document.createElement("div");
        calendarContainer.className = "jcalendar-container";
        calendarContent = document.createElement("div");
        calendarContent.className = "jcalendar-content";
        calendarContainer.appendChild(calendarContent);
        if (el2.tagName == "DIV") {
          calendar = el2;
          calendar.classList.add("jcalendar-inline");
        } else {
          calendarContent.appendChild(calendarControls);
          calendar = document.createElement("div");
          calendar.className = "jcalendar";
        }
        calendar.classList.add("jcalendar-container");
        calendar.appendChild(calendarContainer);
        var calendarTableContainer = document.createElement("div");
        calendarTableContainer.className = "jcalendar-table";
        calendarContent.appendChild(calendarTableContainer);
        var calendarHeaderPrev = document.createElement("td");
        calendarHeaderPrev.setAttribute("colspan", "2");
        calendarHeaderPrev.className = "jcalendar-prev";
        calendarLabelYear = document.createElement("span");
        calendarLabelYear.className = "jcalendar-year";
        calendarLabelMonth = document.createElement("span");
        calendarLabelMonth.className = "jcalendar-month";
        var calendarHeaderTitle = document.createElement("td");
        calendarHeaderTitle.className = "jcalendar-header";
        calendarHeaderTitle.setAttribute("colspan", "3");
        calendarHeaderTitle.appendChild(calendarLabelMonth);
        calendarHeaderTitle.appendChild(calendarLabelYear);
        var calendarHeaderNext = document.createElement("td");
        calendarHeaderNext.setAttribute("colspan", "2");
        calendarHeaderNext.className = "jcalendar-next";
        var calendarHeader = document.createElement("thead");
        var calendarHeaderRow = document.createElement("tr");
        calendarHeaderRow.appendChild(calendarHeaderPrev);
        calendarHeaderRow.appendChild(calendarHeaderTitle);
        calendarHeaderRow.appendChild(calendarHeaderNext);
        calendarHeader.appendChild(calendarHeaderRow);
        calendarTable = document.createElement("table");
        calendarBody = document.createElement("tbody");
        calendarTable.setAttribute("cellpadding", "0");
        calendarTable.setAttribute("cellspacing", "0");
        calendarTable.appendChild(calendarHeader);
        calendarTable.appendChild(calendarBody);
        calendarTableContainer.appendChild(calendarTable);
        calendarSelectHour = document.createElement("select");
        calendarSelectHour.className = "jcalendar-select";
        calendarSelectHour.onchange = function() {
          obj2.date[3] = this.value;
          if (typeof obj2.options.onupdate == "function") {
            obj2.options.onupdate(el2, obj2.getValue());
          }
        };
        for (var i2 = 0; i2 < 24; i2++) {
          var element2 = document.createElement("option");
          element2.value = i2;
          element2.innerHTML = jSuites2.two(i2);
          calendarSelectHour.appendChild(element2);
        }
        calendarSelectMin = document.createElement("select");
        calendarSelectMin.className = "jcalendar-select";
        calendarSelectMin.onchange = function() {
          obj2.date[4] = this.value;
          if (typeof obj2.options.onupdate == "function") {
            obj2.options.onupdate(el2, obj2.getValue());
          }
        };
        for (var i2 = 0; i2 < 60; i2++) {
          var element2 = document.createElement("option");
          element2.value = i2;
          element2.innerHTML = jSuites2.two(i2);
          calendarSelectMin.appendChild(element2);
        }
        var calendarControlsFooter = document.createElement("div");
        calendarControlsFooter.className = "jcalendar-controls";
        calendarControlsTime = document.createElement("div");
        calendarControlsTime.className = "jcalendar-time";
        calendarControlsTime.style.maxWidth = "140px";
        calendarControlsTime.appendChild(calendarSelectHour);
        calendarControlsTime.appendChild(calendarSelectMin);
        calendarControlsUpdateButton = document.createElement("button");
        calendarControlsUpdateButton.setAttribute("type", "button");
        calendarControlsUpdateButton.className = "jcalendar-update";
        calendarControlsUpdate = document.createElement("div");
        calendarControlsUpdate.style.flexGrow = "10";
        calendarControlsUpdate.appendChild(calendarControlsUpdateButton);
        calendarControlsFooter.appendChild(calendarControlsTime);
        if (el2.tagName == "INPUT") {
          calendarControlsFooter.appendChild(calendarControlsUpdate);
        }
        calendarContent.appendChild(calendarControlsFooter);
        var calendarBackdrop = document.createElement("div");
        calendarBackdrop.className = "jcalendar-backdrop";
        calendar.appendChild(calendarBackdrop);
        el2.addEventListener("keyup", keyUpControls);
        calendar.addEventListener("swipeleft", function(e) {
          jSuites2.animation.slideLeft(calendarTable, 0, function() {
            obj2.next();
            jSuites2.animation.slideRight(calendarTable, 1);
          });
          e.preventDefault();
          e.stopPropagation();
        });
        calendar.addEventListener("swiperight", function(e) {
          jSuites2.animation.slideRight(calendarTable, 0, function() {
            obj2.prev();
            jSuites2.animation.slideLeft(calendarTable, 1);
          });
          e.preventDefault();
          e.stopPropagation();
        });
        el2.onmouseup = function() {
          obj2.open();
        };
        if ("ontouchend" in document.documentElement === true) {
          calendar.addEventListener("touchend", mouseUpControls);
        } else {
          calendar.addEventListener("mouseup", mouseUpControls);
        }
        if (!jSuites2.calendar.hasEvents) {
          jSuites2.calendar.hasEvents = true;
          document.addEventListener("keydown", jSuites2.calendar.keydown);
        }
        obj2.setOptions(options2);
        if (el2.tagName == "INPUT") {
          el2.parentNode.insertBefore(calendar, el2.nextSibling);
          el2.setAttribute("autocomplete", "off");
          el2.classList.add("jcalendar-input");
          el2.value = obj2.setLabel(obj2.getValue(), obj2.options);
        } else {
          obj2.getDays();
          if (obj2.options.time) {
            calendarSelectHour.value = obj2.date[3];
            calendarSelectMin.value = obj2.date[4];
          }
        }
        if (obj2.options.opened == true) {
          obj2.open();
        }
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue();
          } else {
            obj2.setValue(val);
          }
        };
        el2.calendar = calendar.calendar = obj2;
      };
      init2();
      return obj2;
    };
    jSuites2.calendar.keydown = function(e) {
      var calendar = null;
      if (calendar = jSuites2.calendar.current) {
        if (e.which == 13) {
          calendar.close(false, true);
        } else if (e.which == 27) {
          calendar.close(false, false);
        }
      }
    };
    jSuites2.calendar.prettify = function(d, texts) {
      if (!texts) {
        var texts = {
          justNow: "Just now",
          xMinutesAgo: "{0}m ago",
          xHoursAgo: "{0}h ago",
          xDaysAgo: "{0}d ago",
          xWeeksAgo: "{0}w ago",
          xMonthsAgo: "{0} mon ago",
          xYearsAgo: "{0}y ago"
        };
      }
      var d1 = new Date();
      var d2 = new Date(d);
      var total = parseInt((d1 - d2) / 1e3 / 60);
      String.prototype.format = function(o) {
        return this.replace("{0}", o);
      };
      if (total == 0) {
        var text2 = texts.justNow;
      } else if (total < 90) {
        var text2 = texts.xMinutesAgo.format(total);
      } else if (total < 1440) {
        var text2 = texts.xHoursAgo.format(Math.round(total / 60));
      } else if (total < 20160) {
        var text2 = texts.xDaysAgo.format(Math.round(total / 1440));
      } else if (total < 43200) {
        var text2 = texts.xWeeksAgo.format(Math.round(total / 10080));
      } else if (total < 1036800) {
        var text2 = texts.xMonthsAgo.format(Math.round(total / 43200));
      } else {
        var text2 = texts.xYearsAgo.format(Math.round(total / 525600));
      }
      return text2;
    };
    jSuites2.calendar.prettifyAll = function() {
      var elements2 = document.querySelectorAll(".prettydate");
      for (var i2 = 0; i2 < elements2.length; i2++) {
        if (elements2[i2].getAttribute("data-date")) {
          elements2[i2].innerHTML = jSuites2.calendar.prettify(elements2[i2].getAttribute("data-date"));
        } else {
          if (elements2[i2].innerHTML) {
            elements2[i2].setAttribute("data-date", elements2[i2].innerHTML);
            elements2[i2].innerHTML = jSuites2.calendar.prettify(elements2[i2].innerHTML);
          }
        }
      }
    };
    jSuites2.calendar.now = function(date, dateOnly) {
      if (Array.isArray(date)) {
        var y2 = date[0];
        var m = date[1];
        var d = date[2];
        var h = date[3];
        var i2 = date[4];
        var s = date[5];
      } else {
        if (!date) {
          var date = new Date();
        }
        var y2 = date.getFullYear();
        var m = date.getMonth() + 1;
        var d = date.getDate();
        var h = date.getHours();
        var i2 = date.getMinutes();
        var s = date.getSeconds();
      }
      if (dateOnly == true) {
        return jSuites2.two(y2) + "-" + jSuites2.two(m) + "-" + jSuites2.two(d);
      } else {
        return jSuites2.two(y2) + "-" + jSuites2.two(m) + "-" + jSuites2.two(d) + " " + jSuites2.two(h) + ":" + jSuites2.two(i2) + ":" + jSuites2.two(s);
      }
    };
    jSuites2.calendar.toArray = function(value2) {
      var date = value2.split(value2.indexOf("T") !== -1 ? "T" : " ");
      var time = date[1];
      var date = date[0].split("-");
      var y2 = parseInt(date[0]);
      var m = parseInt(date[1]);
      var d = parseInt(date[2]);
      if (time) {
        var time = time.split(":");
        var h = parseInt(time[0]);
        var i2 = parseInt(time[1]);
      } else {
        var h = 0;
        var i2 = 0;
      }
      return [y2, m, d, h, i2, 0];
    };
    jSuites2.calendar.extractDateFromString = function(date, format22) {
      if (date > 0 && Number(date) == date) {
        var d = new Date(Math.round((date - 25569) * 86400 * 1e3));
        return d.getFullYear() + "-" + jSuites2.two(d.getMonth()) + "-" + jSuites2.two(d.getDate()) + " 00:00:00";
      }
      var o = jSuites2.mask(date, { mask: format22 }, true);
      if (o.date[0] && o.date[1]) {
        if (!o.date[2]) {
          o.date[2] = 1;
        }
        return o.date[0] + "-" + jSuites2.two(o.date[1]) + "-" + jSuites2.two(o.date[2]) + " " + jSuites2.two(o.date[3]) + ":" + jSuites2.two(o.date[4]) + ":" + jSuites2.two(o.date[5]);
      }
      return "";
    };
    jSuites2.calendar.dateToNum = function(a, b) {
      a = new Date(a);
      if (!b) {
        b = "1899-12-30 " + a.getHours() + ":" + a.getMinutes() + ":" + a.getSeconds();
      }
      b = new Date(b);
      var v = a.getTime() - b.getTime();
      return Math.round(v / 864e5);
    };
    jSuites2.calendar.numToDate = function(value2) {
      var d = new Date(Math.round((value2 - 25569) * 86400 * 1e3));
      return d.getFullYear() + "-" + jSuites2.two(d.getMonth() + 1) + "-" + jSuites2.two(d.getDate()) + " 00:00:00";
    };
    jSuites2.calendar.getDateString = function(value2, options2) {
      if (!options2) {
        var options2 = {};
      }
      if (options2 && typeof options2 == "object") {
        var format22 = options2.format;
      } else {
        var format22 = options2;
      }
      if (!format22) {
        format22 = "YYYY-MM-DD";
      }
      if (typeof value2 == "number" && format22.indexOf("[h]") >= 0) {
        var result2 = parseFloat(24 * Number(value2));
        if (format22.indexOf("mm") >= 0) {
          var h = ("" + result2).split(".");
          if (h[1]) {
            var d = 60 * parseFloat("0." + h[1]);
            d = parseFloat(d.toFixed(2));
          } else {
            var d = 0;
          }
          result2 = parseInt(h[0]) + ":" + jSuites2.two(d);
        }
        return result2;
      }
      if (value2 instanceof Date) {
        value2 = jSuites2.calendar.now(value2);
      } else if (value2 && jSuites2.isNumeric(value2)) {
        value2 = jSuites2.calendar.numToDate(value2);
      }
      var tokens2 = ["DAY", "WD", "DDDD", "DDD", "DD", "D", "Q", "HH24", "HH12", "HH", "H", "AM/PM", "MI", "SS", "MS", "YYYY", "YYY", "YY", "Y", "MONTH", "MON", "MMMMM", "MMMM", "MMM", "MM", "M", "."];
      var e = new RegExp(tokens2.join("|"), "gi");
      var t = format22.match(e);
      for (var i2 = 0; i2 < t.length; i2++) {
        if (t[i2].toUpperCase() == "MM") {
          if (t[i2 - 1] && t[i2 - 1].toUpperCase().indexOf("H") >= 0) {
            t[i2] = "mi";
          } else if (t[i2 - 2] && t[i2 - 2].toUpperCase().indexOf("H") >= 0) {
            t[i2] = "mi";
          } else if (t[i2 + 1] && t[i2 + 1].toUpperCase().indexOf("S") >= 0) {
            t[i2] = "mi";
          } else if (t[i2 + 2] && t[i2 + 2].toUpperCase().indexOf("S") >= 0) {
            t[i2] = "mi";
          }
        }
      }
      var o = {
        tokens: t
      };
      if (value2) {
        var d = "" + value2;
        var splitStr = d.indexOf("T") !== -1 ? "T" : " ";
        d = d.split(splitStr);
        var h = 0;
        var m = 0;
        var s = 0;
        if (d[1]) {
          h = d[1].split(":");
          m = h[1] ? h[1] : 0;
          s = h[2] ? h[2] : 0;
          h = h[0] ? h[0] : 0;
        }
        d = d[0].split("-");
        if (d[0] && d[1] && d[2] && d[0] > 0 && d[1] > 0 && d[1] < 13 && d[2] > 0 && d[2] < 32) {
          o.data = [d[0], d[1], d[2], h, m, s];
          o.value = [];
          var calendar = new Date(o.data[0], o.data[1] - 1, o.data[2], o.data[3], o.data[4], o.data[5]);
          var get3 = function(i3) {
            var t2 = this.tokens[i3];
            var s2 = t2.toUpperCase();
            var v = null;
            if (s2 === "YYYY") {
              v = this.data[0];
            } else if (s2 === "YYY") {
              v = this.data[0].substring(1, 4);
            } else if (s2 === "YY") {
              v = this.data[0].substring(2, 4);
            } else if (s2 === "Y") {
              v = this.data[0].substring(3, 4);
            } else if (t2 === "MON") {
              v = jSuites2.calendar.months[calendar.getMonth()].substr(0, 3).toUpperCase();
            } else if (t2 === "mon") {
              v = jSuites2.calendar.months[calendar.getMonth()].substr(0, 3).toLowerCase();
            } else if (t2 === "MONTH") {
              v = jSuites2.calendar.months[calendar.getMonth()].toUpperCase();
            } else if (t2 === "month") {
              v = jSuites2.calendar.months[calendar.getMonth()].toLowerCase();
            } else if (s2 === "MMMMM") {
              v = jSuites2.calendar.months[calendar.getMonth()].substr(0, 1);
            } else if (s2 === "MMMM" || t2 === "Month") {
              v = jSuites2.calendar.months[calendar.getMonth()];
            } else if (s2 === "MMM" || t2 == "Mon") {
              v = jSuites2.calendar.months[calendar.getMonth()].substr(0, 3);
            } else if (s2 === "MM") {
              v = jSuites2.two(this.data[1]);
            } else if (s2 === "M") {
              v = calendar.getMonth() + 1;
            } else if (t2 === "DAY") {
              v = jSuites2.calendar.weekdays[calendar.getDay()].toUpperCase();
            } else if (t2 === "day") {
              v = jSuites2.calendar.weekdays[calendar.getDay()].toLowerCase();
            } else if (s2 === "DDDD" || t2 == "Day") {
              v = jSuites2.calendar.weekdays[calendar.getDay()];
            } else if (s2 === "DDD") {
              v = jSuites2.calendar.weekdays[calendar.getDay()].substr(0, 3);
            } else if (s2 === "DD") {
              v = jSuites2.two(this.data[2]);
            } else if (s2 === "D") {
              v = this.data[2];
            } else if (s2 === "Q") {
              v = Math.floor((calendar.getMonth() + 3) / 3);
            } else if (s2 === "HH24" || s2 === "HH") {
              v = jSuites2.two(this.data[3]);
            } else if (s2 === "HH12") {
              if (this.data[3] > 12) {
                v = jSuites2.two(this.data[3] - 12);
              } else {
                v = jSuites2.two(this.data[3]);
              }
            } else if (s2 === "H") {
              v = this.data[3];
            } else if (s2 === "MI") {
              v = jSuites2.two(this.data[4]);
            } else if (s2 === "SS") {
              v = jSuites2.two(this.data[5]);
            } else if (s2 === "MS") {
              v = calendar.getMilliseconds();
            } else if (s2 === "AM/PM") {
              if (this.data[3] >= 12) {
                v = "PM";
              } else {
                v = "AM";
              }
            } else if (s2 === "WD") {
              v = jSuites2.calendar.weekdays[calendar.getDay()];
            }
            if (v === null) {
              this.value[i3] = this.tokens[i3];
            } else {
              this.value[i3] = v;
            }
          };
          for (var i2 = 0; i2 < o.tokens.length; i2++) {
            get3.call(o, i2);
          }
          value2 = o.value.join("");
        } else {
          value2 = "";
        }
      }
      return value2;
    };
    jSuites2.calendar.weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    jSuites2.calendar.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    jSuites2.calendar.weekdaysShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    jSuites2.calendar.monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    jSuites2.color = function(el2, options2) {
      if (el2.color) {
        return el2.color.setOptions(options2, true);
      }
      var obj2 = { type: "color" };
      obj2.options = {};
      var container = null;
      var backdrop = null;
      var content2 = null;
      var resetButton = null;
      var closeButton = null;
      var tabs = null;
      var jsuitesTabs = null;
      obj2.setOptions = function(options3, reset) {
        var defaults2 = {
          placeholder: "",
          value: null,
          onopen: null,
          onclose: null,
          onchange: null,
          closeOnChange: true,
          palette: null,
          position: null,
          doneLabel: "Done",
          resetLabel: "Reset",
          fullscreen: false,
          opened: false
        };
        if (!options3) {
          options3 = {};
        }
        if (options3 && !options3.palette) {
          options3.palette = jSuites2.palette();
        }
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        if (resetButton) {
          resetButton.innerHTML = obj2.options.resetLabel;
        }
        if (closeButton) {
          closeButton.innerHTML = obj2.options.doneLabel;
        }
        if (obj2.options.palette && jsuitesTabs) {
          jsuitesTabs.updateContent(0, table());
        }
        if (typeof obj2.options.value === "string") {
          el2.value = obj2.options.value;
          if (el2.tagName === "INPUT") {
            el2.style.color = el2.value;
            el2.style.backgroundColor = el2.value;
          }
        }
        if (obj2.options.placeholder) {
          el2.setAttribute("placeholder", obj2.options.placeholder);
        } else {
          if (el2.getAttribute("placeholder")) {
            el2.removeAttribute("placeholder");
          }
        }
        return obj2;
      };
      obj2.select = function(color2) {
        var selected = container.querySelector(".jcolor-selected");
        if (selected) {
          selected.classList.remove("jcolor-selected");
        }
        if (obj2.values[color2]) {
          obj2.values[color2].classList.add("jcolor-selected");
        }
      };
      obj2.open = function() {
        if (!container.classList.contains("jcolor-focus")) {
          jSuites2.tracking(obj2, true);
          container.classList.add("jcolor-focus");
          if (obj2.options.value) {
            obj2.select(obj2.options.value);
          }
          content2.style.marginTop = "";
          content2.style.marginLeft = "";
          var rectContent = content2.getBoundingClientRect();
          var availableWidth = jSuites2.getWindowWidth();
          var availableHeight = jSuites2.getWindowHeight();
          if (availableWidth < 800 || obj2.options.fullscreen == true) {
            content2.classList.add("jcolor-fullscreen");
            jSuites2.animation.slideBottom(content2, 1);
            backdrop.style.display = "block";
          } else {
            if (content2.classList.contains("jcolor-fullscreen")) {
              content2.classList.remove("jcolor-fullscreen");
              backdrop.style.display = "";
            }
            if (obj2.options.position) {
              content2.style.position = "fixed";
            } else {
              content2.style.position = "";
            }
            if (rectContent.left + rectContent.width > availableWidth) {
              content2.style.marginLeft = -1 * (rectContent.left + rectContent.width - (availableWidth - 20)) + "px";
            }
            if (rectContent.top + rectContent.height > availableHeight) {
              content2.style.marginTop = -1 * (rectContent.top + rectContent.height - (availableHeight - 20)) + "px";
            }
          }
          if (typeof obj2.options.onopen == "function") {
            obj2.options.onopen(el2);
          }
          jsuitesTabs.setBorder(jsuitesTabs.getActive());
          if (obj2.options.value) {
            var rgb = HexToRgb(obj2.options.value);
            rgbInputs.forEach(function(rgbInput, index2) {
              rgbInput.value = rgb[index2];
              rgbInput.dispatchEvent(new Event("input"));
            });
          }
        }
      };
      obj2.close = function(ignoreEvents) {
        if (container.classList.contains("jcolor-focus")) {
          container.classList.remove("jcolor-focus");
          backdrop.style.display = "";
          if (!ignoreEvents && typeof obj2.options.onclose == "function") {
            obj2.options.onclose(el2);
          }
          jSuites2.tracking(obj2, false);
        }
        return obj2.options.value;
      };
      obj2.setValue = function(color2) {
        if (!color2) {
          color2 = "";
        }
        if (color2 != obj2.options.value) {
          obj2.options.value = color2;
          slidersResult = color2;
          obj2.select(color2);
          if (typeof obj2.options.onchange == "function") {
            obj2.options.onchange(el2, color2);
          }
          if (el2.value != obj2.options.value) {
            el2.value = obj2.options.value;
            if (el2.tagName === "INPUT") {
              el2.style.color = el2.value;
              el2.style.backgroundColor = el2.value;
            }
            if (typeof el2.oninput == "function") {
              el2.oninput({
                type: "input",
                target: el2,
                value: el2.value
              });
            }
          }
          if (obj2.options.closeOnChange == true) {
            obj2.close();
          }
        }
      };
      obj2.getValue = function() {
        return obj2.options.value;
      };
      var decToHex = function(num) {
        var hex = num.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      };
      var rgbToHex = function(r, g, b) {
        return "#" + decToHex(r) + decToHex(g) + decToHex(b);
      };
      var hexToDec = function(hex) {
        return parseInt("0x" + hex);
      };
      var HexToRgb = function(hex) {
        return [hexToDec(hex.substr(1, 2)), hexToDec(hex.substr(3, 2)), hexToDec(hex.substr(5, 2))];
      };
      var table = function() {
        var tableContainer = document.createElement("div");
        tableContainer.className = "jcolor-grid";
        obj2.values = [];
        var t = document.createElement("table");
        t.setAttribute("cellpadding", "7");
        t.setAttribute("cellspacing", "0");
        for (var j2 = 0; j2 < obj2.options.palette.length; j2++) {
          var tr = document.createElement("tr");
          for (var i2 = 0; i2 < obj2.options.palette[j2].length; i2++) {
            var td = document.createElement("td");
            var color2 = obj2.options.palette[j2][i2];
            if (color2.length < 7 && color2.substr(0, 1) !== "#") {
              color2 = "#" + color2;
            }
            td.style.backgroundColor = color2;
            td.setAttribute("data-value", color2);
            td.innerHTML = "";
            tr.appendChild(td);
            if (obj2.options.value == color2) {
              td.classList.add("jcolor-selected");
            }
            obj2.values[color2] = td;
          }
          t.appendChild(tr);
        }
        tableContainer.appendChild(t);
        return tableContainer;
      };
      var canvas = document.createElement("canvas");
      canvas.width = 200;
      canvas.height = 160;
      var context = canvas.getContext("2d");
      var resizeCanvas = function() {
        var m = tabs.firstChild.getBoundingClientRect();
        canvas.width = m.width - 14;
        gradient();
      };
      var gradient = function() {
        var g = context.createLinearGradient(0, 0, canvas.width, 0);
        g.addColorStop(0, "rgb(255,0,0)");
        g.addColorStop(0.15, "rgb(255,0,255)");
        g.addColorStop(0.33, "rgb(0,0,255)");
        g.addColorStop(0.49, "rgb(0,255,255)");
        g.addColorStop(0.67, "rgb(0,255,0)");
        g.addColorStop(0.84, "rgb(255,255,0)");
        g.addColorStop(1, "rgb(255,0,0)");
        context.fillStyle = g;
        context.fillRect(0, 0, canvas.width, canvas.height);
        g = context.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.5, "rgba(255,255,255,0)");
        g.addColorStop(0.5, "rgba(0,0,0,0)");
        g.addColorStop(1, "rgba(0,0,0,1)");
        context.fillStyle = g;
        context.fillRect(0, 0, canvas.width, canvas.height);
      };
      var hsl = function() {
        var element2 = document.createElement("div");
        element2.className = "jcolor-hsl";
        var point = document.createElement("div");
        point.className = "jcolor-point";
        var div2 = document.createElement("div");
        div2.appendChild(canvas);
        div2.appendChild(point);
        element2.appendChild(div2);
        var update2 = function(buttons, x2, y2) {
          if (buttons === 1) {
            var rect = element2.getBoundingClientRect();
            var left = x2 - rect.left;
            var top = y2 - rect.top;
            if (left < 0) {
              left = 0;
            }
            if (top < 0) {
              top = 0;
            }
            if (left > rect.width) {
              left = rect.width;
            }
            if (top > rect.height) {
              top = rect.height;
            }
            point.style.left = left + "px";
            point.style.top = top + "px";
            var pixel = context.getImageData(left, top, 1, 1).data;
            slidersResult = rgbToHex(pixel[0], pixel[1], pixel[2]);
          }
        };
        element2.addEventListener("mousedown", function(e) {
          update2(e.buttons, e.clientX, e.clientY);
        });
        element2.addEventListener("mousemove", function(e) {
          update2(e.buttons, e.clientX, e.clientY);
        });
        element2.addEventListener("touchmove", function(e) {
          update2(1, e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        });
        return element2;
      };
      var slidersResult = "";
      var rgbInputs = [];
      var changeInputColors = function() {
        if (slidersResult !== "") {
          for (var j2 = 0; j2 < rgbInputs.length; j2++) {
            var currentColor = HexToRgb(slidersResult);
            currentColor[j2] = 0;
            var newGradient = "linear-gradient(90deg, rgb(";
            newGradient += currentColor.join(", ");
            newGradient += "), rgb(";
            currentColor[j2] = 255;
            newGradient += currentColor.join(", ");
            newGradient += "))";
            rgbInputs[j2].style.backgroundImage = newGradient;
          }
        }
      };
      var sliders = function() {
        var slidersElement = document.createElement("div");
        slidersElement.className = "jcolor-sliders";
        var slidersBody = document.createElement("div");
        var createSliderInput = function(name) {
          var inputContainer = document.createElement("div");
          inputContainer.className = "jcolor-sliders-input-container";
          var label = document.createElement("label");
          label.innerText = name;
          var subContainer = document.createElement("div");
          subContainer.className = "jcolor-sliders-input-subcontainer";
          var input = document.createElement("input");
          input.type = "range";
          input.min = 0;
          input.max = 255;
          input.value = 0;
          inputContainer.appendChild(label);
          subContainer.appendChild(input);
          var value2 = document.createElement("div");
          value2.innerText = input.value;
          input.addEventListener("input", function() {
            value2.innerText = input.value;
          });
          subContainer.appendChild(value2);
          inputContainer.appendChild(subContainer);
          slidersBody.appendChild(inputContainer);
          return input;
        };
        rgbInputs = [
          createSliderInput("Red"),
          createSliderInput("Green"),
          createSliderInput("Blue")
        ];
        slidersElement.appendChild(slidersBody);
        var slidersResultColor = document.createElement("div");
        slidersResultColor.className = "jcolor-sliders-final-color";
        var resultElement = document.createElement("div");
        resultElement.style.visibility = "hidden";
        resultElement.innerText = "a";
        slidersResultColor.appendChild(resultElement);
        var updateResult = function() {
          var resultColor = rgbToHex(parseInt(rgbInputs[0].value), parseInt(rgbInputs[1].value), parseInt(rgbInputs[2].value));
          resultElement.innerText = resultColor;
          resultElement.style.color = resultColor;
          resultElement.style.removeProperty("visibility");
          slidersResult = resultColor;
        };
        rgbInputs.forEach(function(rgbInput) {
          rgbInput.addEventListener("input", function() {
            updateResult();
            changeInputColors();
          });
        });
        slidersElement.appendChild(slidersResultColor);
        return slidersElement;
      };
      var init2 = function() {
        obj2.setOptions(options2);
        if (el2.tagName == "INPUT") {
          el2.classList.add("jcolor-input");
          el2.readOnly = true;
        }
        container = document.createElement("div");
        container.className = "jcolor";
        backdrop = document.createElement("div");
        backdrop.className = "jcolor-backdrop";
        container.appendChild(backdrop);
        content2 = document.createElement("div");
        content2.className = "jcolor-content";
        var controls = document.createElement("div");
        controls.className = "jcolor-controls";
        content2.appendChild(controls);
        resetButton = document.createElement("div");
        resetButton.className = "jcolor-reset";
        resetButton.innerHTML = obj2.options.resetLabel;
        controls.appendChild(resetButton);
        closeButton = document.createElement("div");
        closeButton.className = "jcolor-close";
        closeButton.innerHTML = obj2.options.doneLabel;
        controls.appendChild(closeButton);
        tabs = document.createElement("div");
        content2.appendChild(tabs);
        jsuitesTabs = jSuites2.tabs(tabs, {
          animation: true,
          data: [
            {
              title: "Grid",
              contentElement: table()
            },
            {
              title: "Spectrum",
              contentElement: hsl()
            },
            {
              title: "Sliders",
              contentElement: sliders()
            }
          ],
          onchange: function(element2, instance2, index2) {
            if (index2 === 1) {
              resizeCanvas();
            } else {
              var color2 = slidersResult !== "" ? slidersResult : obj2.getValue();
              if (index2 === 2 && color2) {
                var rgb = HexToRgb(color2);
                rgbInputs.forEach(function(rgbInput, index3) {
                  rgbInput.value = rgb[index3];
                  rgbInput.dispatchEvent(new Event("input"));
                });
              }
            }
          },
          palette: "modern"
        });
        container.appendChild(content2);
        if (el2.tagName == "INPUT") {
          el2.parentNode.insertBefore(container, el2.nextSibling);
        } else {
          el2.appendChild(container);
        }
        container.addEventListener("click", function(e) {
          if (e.target.tagName == "TD") {
            var value2 = e.target.getAttribute("data-value");
            if (value2) {
              obj2.setValue(value2);
            }
          } else if (e.target.classList.contains("jcolor-reset")) {
            obj2.setValue("");
            obj2.close();
          } else if (e.target.classList.contains("jcolor-close")) {
            if (jsuitesTabs.getActive() > 0) {
              obj2.setValue(slidersResult);
            }
            obj2.close();
          } else if (e.target.classList.contains("jcolor-backdrop")) {
            obj2.close();
          } else {
            obj2.open();
          }
        });
        el2.addEventListener("mouseup", function(e) {
          obj2.open();
        });
        window.addEventListener("resize", function() {
          if (container.classList.contains("jcolor-focus") && jsuitesTabs.getActive() == 1) {
            resizeCanvas();
          }
        });
        if (obj2.options.opened == true) {
          obj2.open();
        }
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue();
          } else {
            obj2.setValue(val);
          }
        };
        el2.color = obj2;
        container.color = obj2;
      };
      obj2.toHex = function(rgb) {
        var hex = function(x2) {
          return ("0" + parseInt(x2).toString(16)).slice(-2);
        };
        if (/^#[0-9A-F]{6}$/i.test(rgb)) {
          return rgb;
        } else {
          rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
          return "#" + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
        }
      };
      init2();
      return obj2;
    };
    jSuites2.contextmenu = function(el2, options2) {
      var obj2 = { type: "contextmenu" };
      obj2.options = {};
      var defaults2 = {
        items: null,
        onclick: null
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      el2.classList.add("jcontextmenu");
      obj2.open = function(e, items) {
        if (items) {
          obj2.options.items = items;
          obj2.create(items);
        }
        if (jSuites2.contextmenu.current) {
          jSuites2.contextmenu.current.close();
        }
        jSuites2.tracking(obj2, true);
        el2.classList.add("jcontextmenu-focus");
        jSuites2.contextmenu.current = obj2;
        if (obj2.options.items && obj2.options.items.length > 0 || el2.children.length) {
          if (e.target) {
            var x2 = e.clientX;
            var y2 = e.clientY;
          } else {
            var x2 = e.x;
            var y2 = e.y;
          }
          var rect = el2.getBoundingClientRect();
          if (window.innerHeight < y2 + rect.height) {
            var h = y2 - rect.height;
            if (h < 0) {
              h = 0;
            }
            el2.style.top = h + "px";
          } else {
            el2.style.top = y2 + "px";
          }
          if (window.innerWidth < x2 + rect.width) {
            if (x2 - rect.width > 0) {
              el2.style.left = x2 - rect.width + "px";
            } else {
              el2.style.left = "10px";
            }
          } else {
            el2.style.left = x2 + "px";
          }
        }
      };
      obj2.close = function() {
        if (el2.classList.contains("jcontextmenu-focus")) {
          el2.classList.remove("jcontextmenu-focus");
        }
        jSuites2.tracking(obj2, false);
      };
      obj2.create = function(items) {
        el2.innerHTML = "";
        var itemHeader = createHeader();
        el2.appendChild(itemHeader);
        for (var i2 = 0; i2 < items.length; i2++) {
          var itemContainer = createItemElement(items[i2]);
          el2.appendChild(itemContainer);
        }
      };
      function createHeader() {
        var header = document.createElement("div");
        header.classList.add("header");
        header.addEventListener("click", function(e) {
          e.preventDefault();
          e.stopPropagation();
        });
        var title = document.createElement("a");
        title.classList.add("title");
        title.innerHTML = jSuites2.translate("Menu");
        header.appendChild(title);
        var closeButton = document.createElement("a");
        closeButton.classList.add("close");
        closeButton.innerHTML = jSuites2.translate("close");
        closeButton.addEventListener("click", function(e) {
          obj2.close();
        });
        header.appendChild(closeButton);
        return header;
      }
      function createItemElement(item) {
        if (item.type && (item.type == "line" || item.type == "divisor")) {
          var itemContainer = document.createElement("hr");
        } else {
          var itemContainer = document.createElement("div");
          var itemText = document.createElement("a");
          itemText.innerHTML = item.title;
          if (item.tooltip) {
            itemContainer.setAttribute("title", item.tooltip);
          }
          if (item.icon) {
            itemContainer.setAttribute("data-icon", item.icon);
          }
          if (item.id) {
            itemContainer.id = item.id;
          }
          if (item.disabled) {
            itemContainer.className = "jcontextmenu-disabled";
          } else if (item.onclick) {
            itemContainer.method = item.onclick;
            itemContainer.addEventListener("mousedown", function(e) {
              e.preventDefault();
            });
            itemContainer.addEventListener("mouseup", function(e) {
              this.method(this, e);
            });
          }
          itemContainer.appendChild(itemText);
          if (item.submenu) {
            var itemIconSubmenu = document.createElement("span");
            itemIconSubmenu.innerHTML = "&#9658;";
            itemContainer.appendChild(itemIconSubmenu);
            itemContainer.classList.add("jcontexthassubmenu");
            var el_submenu = document.createElement("div");
            el_submenu.classList.add("jcontextmenu");
            el_submenu.setAttribute("tabindex", "900");
            var submenu = item.submenu;
            for (var i2 = 0; i2 < submenu.length; i2++) {
              var itemContainerSubMenu = createItemElement(submenu[i2]);
              el_submenu.appendChild(itemContainerSubMenu);
            }
            itemContainer.appendChild(el_submenu);
          } else if (item.shortcut) {
            var itemShortCut = document.createElement("span");
            itemShortCut.innerHTML = item.shortcut;
            itemContainer.appendChild(itemShortCut);
          }
        }
        return itemContainer;
      }
      if (typeof obj2.options.onclick == "function") {
        el2.addEventListener("click", function(e) {
          obj2.options.onclick(obj2, e);
        });
      }
      if (obj2.options.items) {
        obj2.create(obj2.options.items);
      }
      window.addEventListener("mousewheel", function() {
        obj2.close();
      });
      el2.contextmenu = obj2;
      return obj2;
    };
    jSuites2.dropdown = function(el2, options2) {
      if (el2.dropdown) {
        return el2.dropdown.setOptions(options2, true);
      }
      var obj2 = { type: "dropdown" };
      obj2.options = {};
      var success = function(data, val) {
        if (data && data.length) {
          if (obj2.options.sortResults !== false) {
            if (typeof obj2.options.sortResults == "function") {
              data.sort(obj2.options.sortResults);
            } else {
              data.sort(sortData);
            }
          }
          obj2.setData(data);
        }
        if (typeof obj2.options.onload == "function") {
          obj2.options.onload(el2, obj2, data, val);
        }
        if (val) {
          applyValue(val);
        }
        if (val === void 0 || val === null) {
          obj2.options.value = "";
        }
        el2.value = obj2.options.value;
        if (obj2.options.opened == true) {
          obj2.open();
        }
      };
      var sortData = function(itemA, itemB) {
        var testA, testB;
        if (typeof itemA == "string") {
          testA = itemA;
        } else {
          if (itemA.text) {
            testA = itemA.text;
          } else if (itemA.name) {
            testA = itemA.name;
          }
        }
        if (typeof itemB == "string") {
          testB = itemB;
        } else {
          if (itemB.text) {
            testB = itemB.text;
          } else if (itemB.name) {
            testB = itemB.name;
          }
        }
        if (typeof testA == "string" || typeof testB == "string") {
          if (typeof testA != "string") {
            testA = "" + testA;
          }
          if (typeof testB != "string") {
            testB = "" + testB;
          }
          return testA.localeCompare(testB);
        } else {
          return testA - testB;
        }
      };
      var resetValue = function() {
        obj2.value = {};
        for (var i2 = 0; i2 < obj2.items.length; i2++) {
          if (obj2.items[i2].selected == true) {
            if (obj2.items[i2].element) {
              obj2.items[i2].element.classList.remove("jdropdown-selected");
            }
            obj2.items[i2].selected = null;
          }
        }
        obj2.options.value = "";
      };
      var applyValue = function(values) {
        resetValue();
        if (values !== null) {
          if (!values) {
            if (typeof obj2.value[""] !== "undefined") {
              obj2.value[""] = "";
            }
          } else {
            if (!Array.isArray(values)) {
              values = ("" + values).split(";");
            }
            for (var i2 = 0; i2 < values.length; i2++) {
              obj2.value[values[i2]] = "";
            }
          }
        }
        for (var i2 = 0; i2 < obj2.items.length; i2++) {
          if (typeof obj2.value[Value(i2)] !== "undefined") {
            if (obj2.items[i2].element) {
              obj2.items[i2].element.classList.add("jdropdown-selected");
            }
            obj2.items[i2].selected = true;
            obj2.value[Value(i2)] = Text(i2);
          }
        }
        obj2.options.value = Object.keys(obj2.value).join(";");
        obj2.header.value = obj2.getText();
      };
      var Value = function(k2, v) {
        if (!obj2.options.format) {
          var property2 = "value";
        } else {
          var property2 = "id";
        }
        if (obj2.items[k2]) {
          if (v !== void 0) {
            return obj2.items[k2].data[property2] = v;
          } else {
            return obj2.items[k2].data[property2];
          }
        }
        return "";
      };
      var Text = function(k2, v) {
        if (!obj2.options.format) {
          var property2 = "text";
        } else {
          var property2 = "name";
        }
        if (obj2.items[k2]) {
          if (v !== void 0) {
            return obj2.items[k2].data[property2] = v;
          } else {
            return obj2.items[k2].data[property2];
          }
        }
        return "";
      };
      var getValue2 = function() {
        return Object.keys(obj2.value);
      };
      var getText2 = function() {
        var data = [];
        var k2 = Object.keys(obj2.value);
        for (var i2 = 0; i2 < k2.length; i2++) {
          data.push(obj2.value[k2[i2]]);
        }
        return data;
      };
      obj2.setOptions = function(options3, reset) {
        if (!options3) {
          options3 = {};
        }
        var defaults2 = {
          url: null,
          data: [],
          format: 0,
          multiple: false,
          autocomplete: false,
          remoteSearch: false,
          lazyLoading: false,
          type: null,
          width: null,
          maxWidth: null,
          opened: false,
          value: null,
          placeholder: "",
          newOptions: false,
          position: false,
          onchange: null,
          onload: null,
          onopen: null,
          onclose: null,
          onfocus: null,
          onblur: null,
          oninsert: null,
          onbeforeinsert: null,
          sortResults: false,
          autofocus: false
        };
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        if (obj2.options.remoteSearch == true || obj2.options.type === "searchbar") {
          obj2.options.autocomplete = true;
        }
        if (obj2.options.newOptions == true) {
          obj2.header.classList.add("jdropdown-add");
        } else {
          obj2.header.classList.remove("jdropdown-add");
        }
        if (obj2.options.autocomplete == true) {
          obj2.header.removeAttribute("readonly");
        } else {
          obj2.header.setAttribute("readonly", "readonly");
        }
        if (obj2.options.placeholder) {
          obj2.header.setAttribute("placeholder", obj2.options.placeholder);
        } else {
          obj2.header.removeAttribute("placeholder");
        }
        el2.classList.remove("jdropdown-searchbar");
        el2.classList.remove("jdropdown-picker");
        el2.classList.remove("jdropdown-list");
        if (obj2.options.type == "searchbar") {
          el2.classList.add("jdropdown-searchbar");
        } else if (obj2.options.type == "list") {
          el2.classList.add("jdropdown-list");
        } else if (obj2.options.type == "picker") {
          el2.classList.add("jdropdown-picker");
        } else {
          if (jSuites2.getWindowWidth() < 800) {
            if (obj2.options.autocomplete) {
              el2.classList.add("jdropdown-searchbar");
              obj2.options.type = "searchbar";
            } else {
              el2.classList.add("jdropdown-picker");
              obj2.options.type = "picker";
            }
          } else {
            if (obj2.options.width) {
              el2.style.width = obj2.options.width;
              el2.style.minWidth = obj2.options.width;
            } else {
              el2.style.removeProperty("width");
              el2.style.removeProperty("min-width");
            }
            el2.classList.add("jdropdown-default");
            obj2.options.type = "default";
          }
        }
        if (obj2.options.type == "searchbar") {
          containerHeader.appendChild(closeButton);
        } else {
          container.insertBefore(closeButton, container.firstChild);
        }
        if (obj2.options.url && !options3.data) {
          jSuites2.ajax({
            url: obj2.options.url,
            method: "GET",
            dataType: "json",
            success: function(data) {
              if (data) {
                success(data, obj2.options.value);
              }
            }
          });
        } else {
          success(obj2.options.data, obj2.options.value);
        }
        return obj2;
      };
      var containerHeader = null;
      var container = null;
      var content2 = null;
      var closeButton = null;
      var resetButton = null;
      var backdrop = null;
      var keyTimer = null;
      var init2 = function() {
        if (!options2) {
          options2 = {};
        }
        if (el2.tagName == "SELECT") {
          var ret = jSuites2.dropdown.extractFromDom(el2, options2);
          el2 = ret.el;
          options2 = ret.options;
        }
        if (!options2.placeholder && el2.getAttribute("placeholder")) {
          options2.placeholder = el2.getAttribute("placeholder");
        }
        obj2.value = {};
        obj2.items = [];
        obj2.groups = [];
        obj2.search = "";
        obj2.results = null;
        el2.classList.add("jdropdown");
        containerHeader = document.createElement("div");
        containerHeader.className = "jdropdown-container-header";
        obj2.header = document.createElement("input");
        obj2.header.className = "jdropdown-header";
        obj2.header.type = "text";
        obj2.header.setAttribute("autocomplete", "off");
        obj2.header.onfocus = function() {
          if (typeof obj2.options.onfocus == "function") {
            obj2.options.onfocus(el2);
          }
        };
        obj2.header.onblur = function() {
          if (typeof obj2.options.onblur == "function") {
            obj2.options.onblur(el2);
          }
        };
        obj2.header.onkeyup = function(e) {
          if (obj2.options.autocomplete == true && !keyTimer) {
            if (obj2.search != obj2.header.value.trim()) {
              keyTimer = setTimeout(function() {
                obj2.find(obj2.header.value.trim());
                keyTimer = null;
              }, 400);
            }
            if (!el2.classList.contains("jdropdown-focus")) {
              obj2.open();
            }
          } else {
            if (!obj2.options.autocomplete) {
              obj2.next(e.key);
            }
          }
        };
        if (!jSuites2.dropdown.hasEvents) {
          jSuites2.dropdown.hasEvents = true;
          document.addEventListener("keydown", jSuites2.dropdown.keydown);
        }
        container = document.createElement("div");
        container.className = "jdropdown-container";
        content2 = document.createElement("div");
        content2.className = "jdropdown-content";
        closeButton = document.createElement("div");
        closeButton.className = "jdropdown-close";
        closeButton.innerHTML = "Done";
        resetButton = document.createElement("div");
        resetButton.className = "jdropdown-reset";
        resetButton.innerHTML = "x";
        resetButton.onclick = function() {
          obj2.reset();
          obj2.close();
        };
        backdrop = document.createElement("div");
        backdrop.className = "jdropdown-backdrop";
        containerHeader.appendChild(obj2.header);
        container.appendChild(content2);
        el2.appendChild(containerHeader);
        el2.appendChild(container);
        el2.appendChild(backdrop);
        obj2.setOptions(options2);
        if ("ontouchsend" in document.documentElement === true) {
          el2.addEventListener("touchsend", jSuites2.dropdown.mouseup);
        } else {
          el2.addEventListener("mouseup", jSuites2.dropdown.mouseup);
        }
        if (obj2.options.lazyLoading == true) {
          jSuites2.lazyLoading(content2, {
            loadUp: obj2.loadUp,
            loadDown: obj2.loadDown
          });
        }
        content2.onwheel = function(e) {
          e.stopPropagation();
        };
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue(obj2.options.multiple ? true : false);
          } else {
            obj2.setValue(val);
          }
        };
        el2.dropdown = obj2;
      };
      obj2.getUrl = function() {
        return obj2.options.url;
      };
      obj2.setUrl = function(url, callback) {
        obj2.options.url = url;
        jSuites2.ajax({
          url: obj2.options.url,
          method: "GET",
          dataType: "json",
          success: function(data) {
            obj2.setData(data);
            if (typeof callback == "function") {
              callback(obj2);
            }
          }
        });
      };
      obj2.setId = function(item, v) {
        if (!obj2.options.format) {
          var property2 = "value";
        } else {
          var property2 = "id";
        }
        if (typeof item == "object") {
          item[property2] = v;
        } else {
          obj2.items[item].data[property2] = v;
        }
      };
      obj2.add = function(title, id) {
        if (!title) {
          var current = obj2.options.autocomplete == true ? obj2.header.value : "";
          var title = prompt(jSuites2.translate("Add A New Option"), current);
          if (!title) {
            return false;
          }
        }
        if (!id) {
          id = jSuites2.guid();
        }
        if (!obj2.options.format) {
          var item = {
            value: id,
            text: title
          };
        } else {
          var item = {
            id,
            name: title
          };
        }
        if (typeof obj2.options.onbeforeinsert == "function") {
          var ret = obj2.options.onbeforeinsert(obj2, item);
          if (ret === false) {
            return false;
          } else if (ret) {
            item = ret;
          }
        }
        obj2.options.data.push(item);
        var newItem = obj2.createItem(item);
        content2.appendChild(newItem.element);
        if (typeof obj2.options.oninsert == "function") {
          obj2.options.oninsert(obj2, item, newItem);
        }
        if (content2.style.display == "none") {
          content2.style.display = "";
        }
        if (obj2.results) {
          obj2.results.push(newItem);
        }
        return item;
      };
      obj2.createItem = function(data, group, groupName) {
        if (!obj2.options.format) {
          if (!data.value && data.id !== void 0) {
            data.value = data.id;
          }
          if (!data.text && data.name !== void 0) {
            data.text = data.name;
          }
        } else {
          if (!data.id && data.value !== void 0) {
            data.id = data.value;
          }
          if (!data.name && data.text !== void 0) {
            data.name = data.text;
          }
        }
        var item = {};
        item.element = document.createElement("div");
        item.element.className = "jdropdown-item";
        item.element.indexValue = obj2.items.length;
        item.data = data;
        if (group) {
          item.group = group;
        }
        if (data.id) {
          item.element.setAttribute("id", data.id);
        }
        if (data.disabled == true) {
          item.element.setAttribute("data-disabled", true);
        }
        if (data.tooltip) {
          item.element.setAttribute("title", data.tooltip);
        }
        if (data.image) {
          var image = document.createElement("img");
          image.className = "jdropdown-image";
          image.src = data.image;
          if (!data.title) {
            image.classList.add("jdropdown-image-small");
          }
          item.element.appendChild(image);
        } else if (data.icon) {
          var icon = document.createElement("span");
          icon.className = "jdropdown-icon material-icons";
          icon.innerText = data.icon;
          if (!data.title) {
            icon.classList.add("jdropdown-icon-small");
          }
          if (data.color) {
            icon.style.color = data.color;
          }
          item.element.appendChild(icon);
        } else if (data.color) {
          var color2 = document.createElement("div");
          color2.className = "jdropdown-color";
          color2.style.backgroundColor = data.color;
          item.element.appendChild(color2);
        }
        if (!obj2.options.format) {
          var text2 = data.text;
        } else {
          var text2 = data.name;
        }
        var node = document.createElement("div");
        node.className = "jdropdown-description";
        node.innerHTML = text2 || "&nbsp;";
        if (data.title) {
          var title = document.createElement("div");
          title.className = "jdropdown-title";
          title.innerText = data.title;
          node.appendChild(title);
        }
        if (!obj2.options.format) {
          var val = data.value;
        } else {
          var val = data.id;
        }
        if (obj2.value[val]) {
          item.element.classList.add("jdropdown-selected");
          item.selected = true;
        }
        obj2.items.push(item);
        item.element.appendChild(node);
        return item;
      };
      obj2.appendData = function(data) {
        if (data.length) {
          var items = [];
          var groups = [];
          for (var i2 = 0; i2 < data.length; i2++) {
            if (data[i2].group) {
              if (!groups[data[i2].group]) {
                groups[data[i2].group] = [];
              }
              groups[data[i2].group].push(i2);
            } else {
              items.push(i2);
            }
          }
          var counter = 0;
          var groupNames = Object.keys(groups);
          if (groupNames.length > 0) {
            for (var i2 = 0; i2 < groupNames.length; i2++) {
              var group = document.createElement("div");
              group.className = "jdropdown-group";
              var groupName = document.createElement("div");
              groupName.className = "jdropdown-group-name";
              groupName.innerHTML = groupNames[i2];
              var groupArrow = document.createElement("i");
              groupArrow.className = "jdropdown-group-arrow jdropdown-group-arrow-down";
              groupName.appendChild(groupArrow);
              var groupContent = document.createElement("div");
              groupContent.className = "jdropdown-group-items";
              for (var j2 = 0; j2 < groups[groupNames[i2]].length; j2++) {
                var item = obj2.createItem(data[groups[groupNames[i2]][j2]], group, groupNames[i2]);
                if (obj2.options.lazyLoading == false || counter < 200) {
                  groupContent.appendChild(item.element);
                  counter++;
                }
              }
              group.appendChild(groupName);
              group.appendChild(groupContent);
              obj2.groups.push(group);
              if (groupContent.children.length > 0) {
                content2.appendChild(group);
              }
            }
          }
          if (items.length) {
            for (var i2 = 0; i2 < items.length; i2++) {
              var item = obj2.createItem(data[items[i2]]);
              if (obj2.options.lazyLoading == false || counter < 200) {
                content2.appendChild(item.element);
                counter++;
              }
            }
          }
        }
      };
      obj2.setData = function(data) {
        if (data.length) {
          for (var i2 = 0; i2 < data.length; i2++) {
            if (typeof data[i2] != "object") {
              if (!obj2.options.format) {
                data[i2] = {
                  value: data[i2],
                  text: data[i2]
                };
              } else {
                data[i2] = {
                  id: data[i2],
                  name: data[i2]
                };
              }
            }
          }
          resetValue();
          content2.innerHTML = "";
          obj2.header.value = "";
          obj2.items = [];
          obj2.appendData(data);
          obj2.options.data = data;
        }
      };
      obj2.getData = function() {
        return obj2.options.data;
      };
      obj2.getPosition = function(val) {
        for (var i2 = 0; i2 < obj2.items.length; i2++) {
          if (Value(i2) == val) {
            return i2;
          }
        }
        return false;
      };
      obj2.getText = function(asArray2) {
        var v = getText2();
        if (asArray2) {
          return v;
        } else {
          return v.join("; ");
        }
      };
      obj2.getValue = function(asArray2) {
        var v = getValue2();
        if (asArray2) {
          return v;
        } else {
          return v.join(";");
        }
      };
      var change = function(oldValue) {
        if (el2.value != obj2.options.value) {
          el2.value = obj2.options.value;
          if (typeof el2.oninput == "function") {
            el2.oninput({
              type: "input",
              target: el2,
              value: el2.value
            });
          }
        }
        if (typeof obj2.options.onchange == "function") {
          obj2.options.onchange(el2, obj2, oldValue, obj2.options.value);
        }
      };
      obj2.setValue = function(newValue) {
        var oldValue = obj2.getValue();
        if (Array.isArray(newValue)) {
          newValue = newValue.join(";");
        }
        if (oldValue !== newValue) {
          applyValue(newValue);
          change(oldValue);
        }
      };
      obj2.resetSelected = function() {
        obj2.setValue(null);
      };
      obj2.selectIndex = function(index2, force) {
        var index2 = parseInt(index2);
        if (obj2.items && obj2.items[index2] && (force === true || obj2.items[index2].data.disabled !== true)) {
          obj2.setCursor(index2, false);
          if (!obj2.options.multiple) {
            if (obj2.items[index2].selected) {
              obj2.setValue(null);
            } else {
              obj2.setValue(Value(index2));
            }
            obj2.close();
          } else {
            var oldValue = obj2.options.value;
            if (obj2.items[index2].selected) {
              obj2.items[index2].element.classList.remove("jdropdown-selected");
              obj2.items[index2].selected = false;
              delete obj2.value[Value(index2)];
            } else {
              obj2.items[index2].element.classList.add("jdropdown-selected");
              obj2.items[index2].selected = true;
              obj2.value[Value(index2)] = Text(index2);
            }
            obj2.options.value = Object.keys(obj2.value).join(";");
            if (obj2.options.autocomplete == false) {
              obj2.header.value = getText2().join("; ");
            }
            change(oldValue);
          }
        }
      };
      obj2.selectItem = function(item) {
        obj2.selectIndex(item.indexValue);
      };
      var exists = function(k2, result2) {
        for (var j2 = 0; j2 < result2.length; j2++) {
          if (!obj2.options.format) {
            if (result2[j2].value == k2) {
              return true;
            }
          } else {
            if (result2[j2].id == k2) {
              return true;
            }
          }
        }
        return false;
      };
      obj2.find = function(str2) {
        if (obj2.search == str2.trim()) {
          return false;
        }
        obj2.search = str2;
        obj2.setCursor();
        if (obj2.groups.length) {
          for (var i2 = 0; i2 < obj2.groups.length; i2++) {
            obj2.groups[i2].lastChild.innerHTML = "";
          }
        }
        content2.innerHTML = "";
        if (obj2.options.remoteSearch == true) {
          obj2.results = null;
          var url = obj2.options.url + (obj2.options.url.indexOf("?") > 0 ? "&" : "?") + "q=" + str2;
          jSuites2.ajax({
            url,
            method: "GET",
            dataType: "json",
            success: function(result2) {
              obj2.items = [];
              var current = Object.keys(obj2.value);
              if (current.length) {
                for (var i3 = 0; i3 < current.length; i3++) {
                  if (!exists(current[i3], result2)) {
                    if (!obj2.options.format) {
                      result2.unshift({ value: current[i3], text: obj2.value[current[i3]] });
                    } else {
                      result2.unshift({ id: current[i3], name: obj2.value[current[i3]] });
                    }
                  }
                }
              }
              obj2.appendData(result2);
              if (!result2.length) {
                content2.style.display = "none";
              } else {
                content2.style.display = "";
              }
            }
          });
        } else {
          str2 = new RegExp(str2, "gi");
          var results2 = [];
          for (var i2 = 0; i2 < obj2.items.length; i2++) {
            var label = Text(i2);
            var title = obj2.items[i2].data.title || "";
            var groupName = obj2.items[i2].data.group || "";
            var synonym = obj2.items[i2].data.synonym || "";
            if (synonym) {
              synonym = synonym.join(" ");
            }
            if (str2 == null || obj2.items[i2].selected == true || label.match(str2) || title.match(str2) || groupName.match(str2) || synonym.match(str2)) {
              results2.push(obj2.items[i2]);
            }
          }
          if (!results2.length) {
            content2.style.display = "none";
            obj2.results = null;
          } else {
            content2.style.display = "";
            obj2.results = results2;
            var number2 = results2.length || 0;
            if (obj2.options.lazyLoading == true && number2 > 200) {
              number2 = 200;
            }
            for (var i2 = 0; i2 < number2; i2++) {
              if (obj2.results[i2].group) {
                if (!obj2.results[i2].group.parentNode) {
                  content2.appendChild(obj2.results[i2].group);
                }
                obj2.results[i2].group.lastChild.appendChild(obj2.results[i2].element);
              } else {
                content2.appendChild(obj2.results[i2].element);
              }
            }
          }
        }
        if (obj2.options.autofocus == true) {
          obj2.first();
        }
      };
      obj2.open = function() {
        if (!el2.classList.contains("jdropdown-focus")) {
          jSuites2.dropdown.current = obj2;
          jSuites2.tracking(obj2, true);
          el2.classList.add("jdropdown-focus");
          if (jSuites2.getWindowWidth() < 800) {
            if (obj2.options.type == null || obj2.options.type == "picker") {
              jSuites2.animation.slideBottom(container, 1);
            }
          }
          if (obj2.options.autocomplete == true) {
            obj2.header.value = obj2.search;
            obj2.header.focus();
          }
          var k2 = getValue2();
          if (k2[0]) {
            var cursor = obj2.getPosition(k2[0]);
            if (cursor !== false) {
              obj2.setCursor(cursor);
            }
          }
          if (!obj2.options.type || obj2.options.type == "default") {
            var rect = el2.getBoundingClientRect();
            var rectContainer = container.getBoundingClientRect();
            if (obj2.options.position) {
              container.style.position = "fixed";
              if (window.innerHeight < rect.bottom + rectContainer.height) {
                container.style.top = "";
                container.style.bottom = window.innerHeight - rect.top + 1 + "px";
              } else {
                container.style.top = rect.bottom + "px";
                container.style.bottom = "";
              }
              container.style.left = rect.left + "px";
            } else {
              if (window.innerHeight < rect.bottom + rectContainer.height) {
                container.style.top = "";
                container.style.bottom = rect.height + 1 + "px";
              } else {
                container.style.top = "";
                container.style.bottom = "";
              }
            }
            container.style.minWidth = rect.width + "px";
            if (obj2.options.maxWidth) {
              container.style.maxWidth = obj2.options.maxWidth;
            }
            if (!obj2.items.length && obj2.options.autocomplete == true) {
              content2.style.display = "none";
            } else {
              content2.style.display = "";
            }
          }
        }
        if (typeof obj2.options.onopen == "function") {
          obj2.options.onopen(el2);
        }
      };
      obj2.close = function(ignoreEvents) {
        if (el2.classList.contains("jdropdown-focus")) {
          obj2.header.value = obj2.getText();
          obj2.setCursor();
          if (!ignoreEvents && typeof obj2.options.onclose == "function") {
            obj2.options.onclose(el2);
          }
          if (obj2.header.blur) {
            obj2.header.blur();
          }
          el2.classList.remove("jdropdown-focus");
          jSuites2.tracking(obj2, false);
          jSuites2.dropdown.current = null;
        }
        return obj2.getValue();
      };
      obj2.setCursor = function(index2, setPosition) {
        if (obj2.currentIndex != null) {
          if (obj2.items && obj2.items[obj2.currentIndex]) {
            obj2.items[obj2.currentIndex].element.classList.remove("jdropdown-cursor");
          }
        }
        if (index2 == void 0) {
          obj2.currentIndex = null;
        } else {
          index2 = parseInt(index2);
          if (obj2.items[index2].element.parentNode) {
            obj2.items[index2].element.classList.add("jdropdown-cursor");
            obj2.currentIndex = index2;
            if (setPosition !== false && obj2.items[obj2.currentIndex].element) {
              content2.scrollTop;
              var element2 = obj2.items[obj2.currentIndex].element;
              content2.scrollTop = element2.offsetTop - element2.scrollTop + element2.clientTop - 95;
            }
          }
        }
      };
      obj2.resetCursor = obj2.setCursor;
      obj2.updateCursor = obj2.setCursor;
      obj2.reset = function() {
        obj2.setCursor();
        obj2.setValue(null);
      };
      obj2.first = function() {
        if (obj2.options.lazyLoading === true) {
          obj2.loadFirst();
        }
        var items = content2.querySelectorAll(".jdropdown-item");
        if (items.length) {
          var newIndex2 = items[0].indexValue;
          obj2.setCursor(newIndex2);
        }
      };
      obj2.last = function() {
        if (obj2.options.lazyLoading === true) {
          obj2.loadLast();
        }
        var items = content2.querySelectorAll(".jdropdown-item");
        if (items.length) {
          var newIndex2 = items[items.length - 1].indexValue;
          obj2.setCursor(newIndex2);
        }
      };
      obj2.next = function(letter) {
        var newIndex2 = null;
        if (letter) {
          if (letter.length == 1) {
            var current = obj2.currentIndex || -1;
            letter = letter.toLowerCase();
            var e = null;
            var l2 = null;
            var items = content2.querySelectorAll(".jdropdown-item");
            if (items.length) {
              for (var i2 = 0; i2 < items.length; i2++) {
                if (items[i2].indexValue > current) {
                  if (e = obj2.items[items[i2].indexValue]) {
                    if (l2 = e.element.innerText[0]) {
                      l2 = l2.toLowerCase();
                      if (letter == l2) {
                        newIndex2 = items[i2].indexValue;
                        break;
                      }
                    }
                  }
                }
              }
              obj2.setCursor(newIndex2);
            }
          }
        } else {
          if (obj2.currentIndex == void 0 || obj2.currentIndex == null) {
            obj2.first();
          } else {
            var element2 = obj2.items[obj2.currentIndex].element;
            var next2 = element2.nextElementSibling;
            if (next2) {
              if (next2.classList.contains("jdropdown-group")) {
                next2 = next2.lastChild.firstChild;
              }
              newIndex2 = next2.indexValue;
            } else {
              if (element2.parentNode.classList.contains("jdropdown-group-items")) {
                if (next2 = element2.parentNode.parentNode.nextElementSibling) {
                  if (next2.classList.contains("jdropdown-group")) {
                    next2 = next2.lastChild.firstChild;
                  } else if (next2.classList.contains("jdropdown-item")) {
                    newIndex2 = next2.indexValue;
                  } else {
                    next2 = null;
                  }
                }
                if (next2) {
                  newIndex2 = next2.indexValue;
                }
              }
            }
            if (newIndex2 !== null) {
              obj2.setCursor(newIndex2);
            }
          }
        }
      };
      obj2.prev = function() {
        var newIndex2 = null;
        if (obj2.currentIndex === null) {
          obj2.first();
        } else {
          var element2 = obj2.items[obj2.currentIndex].element;
          var prev = element2.previousElementSibling;
          if (prev) {
            if (prev.classList.contains("jdropdown-group")) {
              prev = prev.lastChild.lastChild;
            }
            newIndex2 = prev.indexValue;
          } else {
            if (element2.parentNode.classList.contains("jdropdown-group-items")) {
              if (prev = element2.parentNode.parentNode.previousElementSibling) {
                if (prev.classList.contains("jdropdown-group")) {
                  prev = prev.lastChild.lastChild;
                } else if (prev.classList.contains("jdropdown-item")) {
                  newIndex2 = prev.indexValue;
                } else {
                  prev = null;
                }
              }
              if (prev) {
                newIndex2 = prev.indexValue;
              }
            }
          }
        }
        if (newIndex2 !== null) {
          obj2.setCursor(newIndex2);
        }
      };
      obj2.loadFirst = function() {
        if (obj2.results) {
          var results2 = obj2.results;
        } else {
          var results2 = obj2.items;
        }
        var number2 = results2.length || 0;
        if (obj2.options.lazyLoading == true && number2 > 200) {
          number2 = 200;
        }
        content2.innerHTML = "";
        for (var i2 = 0; i2 < number2; i2++) {
          if (results2[i2].group) {
            if (!results2[i2].group.parentNode) {
              content2.appendChild(results2[i2].group);
            }
            results2[i2].group.lastChild.appendChild(results2[i2].element);
          } else {
            content2.appendChild(results2[i2].element);
          }
        }
        content2.scrollTop = 0;
      };
      obj2.loadLast = function() {
        if (obj2.results) {
          var results2 = obj2.results;
        } else {
          var results2 = obj2.items;
        }
        var number2 = results2.length;
        if (number2 > 200) {
          number2 = number2 - 200;
          content2.innerHTML = "";
          for (var i2 = number2; i2 < results2.length; i2++) {
            if (results2[i2].group) {
              if (!results2[i2].group.parentNode) {
                content2.appendChild(results2[i2].group);
              }
              results2[i2].group.lastChild.appendChild(results2[i2].element);
            } else {
              content2.appendChild(results2[i2].element);
            }
          }
          content2.scrollTop = content2.scrollHeight;
        }
      };
      obj2.loadUp = function() {
        var test = false;
        if (obj2.results) {
          var results2 = obj2.results;
        } else {
          var results2 = obj2.items;
        }
        var items = content2.querySelectorAll(".jdropdown-item");
        var fistItem = items[0].indexValue;
        fistItem = obj2.items[fistItem];
        var index2 = results2.indexOf(fistItem) - 1;
        if (index2 > 0) {
          var number2 = 0;
          while (index2 > 0 && results2[index2] && number2 < 200) {
            if (results2[index2].group) {
              if (!results2[index2].group.parentNode) {
                content2.insertBefore(results2[index2].group, content2.firstChild);
              }
              results2[index2].group.lastChild.insertBefore(results2[index2].element, results2[index2].group.lastChild.firstChild);
            } else {
              content2.insertBefore(results2[index2].element, content2.firstChild);
            }
            index2--;
            number2++;
          }
          test = true;
        }
        return test;
      };
      obj2.loadDown = function() {
        var test = false;
        if (obj2.results) {
          var results2 = obj2.results;
        } else {
          var results2 = obj2.items;
        }
        var items = content2.querySelectorAll(".jdropdown-item");
        var lastItem = items[items.length - 1].indexValue;
        lastItem = obj2.items[lastItem];
        var index2 = results2.indexOf(lastItem) + 1;
        if (index2 < results2.length) {
          var number2 = 0;
          while (index2 < results2.length && results2[index2] && number2 < 200) {
            if (results2[index2].group) {
              if (!results2[index2].group.parentNode) {
                content2.appendChild(results2[index2].group);
              }
              results2[index2].group.lastChild.appendChild(results2[index2].element);
            } else {
              content2.appendChild(results2[index2].element);
            }
            index2++;
            number2++;
          }
          test = true;
        }
        return test;
      };
      init2();
      return obj2;
    };
    jSuites2.dropdown.keydown = function(e) {
      var dropdown = null;
      if (dropdown = jSuites2.dropdown.current) {
        if (e.which == 13 || e.which == 9) {
          if (dropdown.header.value && dropdown.currentIndex == null && dropdown.options.newOptions) {
            dropdown.add();
          } else {
            if (dropdown.currentIndex == null && dropdown.options.autocomplete == true && dropdown.header.value != "") {
              dropdown.find(dropdown.header.value);
            }
            dropdown.selectIndex(dropdown.currentIndex);
          }
        } else if (e.which == 38) {
          if (dropdown.currentIndex == null) {
            dropdown.first();
          } else if (dropdown.currentIndex > 0) {
            dropdown.prev();
          }
          e.preventDefault();
        } else if (e.which == 40) {
          if (dropdown.currentIndex == null) {
            dropdown.first();
          } else if (dropdown.currentIndex + 1 < dropdown.items.length) {
            dropdown.next();
          }
          e.preventDefault();
        } else if (e.which == 36) {
          dropdown.first();
          if (!e.target.classList.contains("jdropdown-header")) {
            e.preventDefault();
          }
        } else if (e.which == 35) {
          dropdown.last();
          if (!e.target.classList.contains("jdropdown-header")) {
            e.preventDefault();
          }
        } else if (e.which == 27) {
          dropdown.close();
        } else if (e.which == 33) {
          if (dropdown.currentIndex == null) {
            dropdown.first();
          } else if (dropdown.currentIndex > 0) {
            for (var i2 = 0; i2 < 7; i2++) {
              dropdown.prev();
            }
          }
          e.preventDefault();
        } else if (e.which == 34) {
          if (dropdown.currentIndex == null) {
            dropdown.first();
          } else if (dropdown.currentIndex + 1 < dropdown.items.length) {
            for (var i2 = 0; i2 < 7; i2++) {
              dropdown.next();
            }
          }
          e.preventDefault();
        }
      }
    };
    jSuites2.dropdown.mouseup = function(e) {
      var element2 = jSuites2.findElement(e.target, "jdropdown");
      if (element2) {
        var dropdown = element2.dropdown;
        if (e.target.classList.contains("jdropdown-header")) {
          if (element2.classList.contains("jdropdown-focus") && element2.classList.contains("jdropdown-default")) {
            var rect = element2.getBoundingClientRect();
            if (e.changedTouches && e.changedTouches[0]) {
              var x2 = e.changedTouches[0].clientX;
              e.changedTouches[0].clientY;
            } else {
              var x2 = e.clientX;
              e.clientY;
            }
            if (rect.width - (x2 - rect.left) < 30) {
              if (e.target.classList.contains("jdropdown-add")) {
                dropdown.add();
              } else {
                dropdown.close();
              }
            } else {
              if (dropdown.options.autocomplete == false) {
                dropdown.close();
              }
            }
          } else {
            dropdown.open();
          }
        } else if (e.target.classList.contains("jdropdown-group-name")) {
          var items = e.target.nextSibling.children;
          if (e.target.nextSibling.style.display != "none") {
            for (var i2 = 0; i2 < items.length; i2++) {
              if (items[i2].style.display != "none") {
                dropdown.selectItem(items[i2]);
              }
            }
          }
        } else if (e.target.classList.contains("jdropdown-group-arrow")) {
          if (e.target.classList.contains("jdropdown-group-arrow-down")) {
            e.target.classList.remove("jdropdown-group-arrow-down");
            e.target.classList.add("jdropdown-group-arrow-up");
            e.target.parentNode.nextSibling.style.display = "none";
          } else {
            e.target.classList.remove("jdropdown-group-arrow-up");
            e.target.classList.add("jdropdown-group-arrow-down");
            e.target.parentNode.nextSibling.style.display = "";
          }
        } else if (e.target.classList.contains("jdropdown-item")) {
          dropdown.selectItem(e.target);
        } else if (e.target.classList.contains("jdropdown-image")) {
          dropdown.selectItem(e.target.parentNode);
        } else if (e.target.classList.contains("jdropdown-description")) {
          dropdown.selectItem(e.target.parentNode);
        } else if (e.target.classList.contains("jdropdown-title")) {
          dropdown.selectItem(e.target.parentNode.parentNode);
        } else if (e.target.classList.contains("jdropdown-close") || e.target.classList.contains("jdropdown-backdrop")) {
          dropdown.close();
        }
      }
    };
    jSuites2.dropdown.extractFromDom = function(el2, options2) {
      var select = el2;
      if (!options2) {
        options2 = {};
      }
      if (el2.getAttribute("multiple") && (!options2 || options2.multiple == void 0)) {
        options2.multiple = true;
      }
      if (el2.getAttribute("placeholder") && (!options2 || options2.placeholder == void 0)) {
        options2.placeholder = el2.getAttribute("placeholder");
      }
      if (el2.getAttribute("data-autocomplete") && (!options2 || options2.autocomplete == void 0)) {
        options2.autocomplete = true;
      }
      if (!options2 || options2.width == void 0) {
        options2.width = el2.offsetWidth;
      }
      if (el2.value && (!options2 || options2.value == void 0)) {
        options2.value = el2.value;
      }
      if (!options2 || options2.data == void 0) {
        options2.data = [];
        for (var j2 = 0; j2 < el2.children.length; j2++) {
          if (el2.children[j2].tagName == "OPTGROUP") {
            for (var i2 = 0; i2 < el2.children[j2].children.length; i2++) {
              options2.data.push({
                value: el2.children[j2].children[i2].value,
                text: el2.children[j2].children[i2].innerHTML,
                group: el2.children[j2].getAttribute("label")
              });
            }
          } else {
            options2.data.push({
              value: el2.children[j2].value,
              text: el2.children[j2].innerHTML
            });
          }
        }
      }
      if (!options2 || options2.onchange == void 0) {
        options2.onchange = function(a, b, c2, d) {
          if (options2.multiple == true) {
            if (obj.items[b].classList.contains("jdropdown-selected")) {
              select.options[b].setAttribute("selected", "selected");
            } else {
              select.options[b].removeAttribute("selected");
            }
          } else {
            select.value = d;
          }
        };
      }
      var div2 = document.createElement("div");
      el2.parentNode.insertBefore(div2, el2);
      el2.style.display = "none";
      el2 = div2;
      return { el: el2, options: options2 };
    };
    jSuites2.editor = function(el2, options2) {
      var obj2 = { type: "editor" };
      obj2.options = {};
      var defaults2 = {
        value: null,
        snippet: null,
        toolbar: null,
        remoteParser: null,
        placeholder: null,
        parseURL: false,
        filterPaste: true,
        dropZone: false,
        dropAsSnippet: false,
        acceptImages: false,
        acceptFiles: false,
        maxFileSize: 5e6,
        allowImageResize: true,
        border: true,
        padding: true,
        maxHeight: null,
        height: null,
        focus: false,
        onclick: null,
        onfocus: null,
        onblur: null,
        onload: null,
        onkeyup: null,
        onkeydown: null,
        onchange: null
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      var editorTimer = null;
      var editorAction = null;
      var files = [];
      el2.innerHTML = "";
      obj2.el = el2;
      if (typeof obj2.options.onclick == "function") {
        el2.onclick = function(e) {
          obj2.options.onclick(el2, obj2, e);
        };
      }
      el2.classList.add("jeditor-container");
      if (obj2.options.padding == true) {
        el2.classList.add("jeditor-padding");
      }
      if (obj2.options.border == false) {
        el2.style.border = "0px";
      }
      var snippet2 = document.createElement("div");
      snippet2.className = "jsnippet";
      snippet2.setAttribute("contenteditable", false);
      var toolbar2 = document.createElement("div");
      toolbar2.className = "jeditor-toolbar";
      var editor = document.createElement("div");
      editor.setAttribute("contenteditable", true);
      editor.setAttribute("spellcheck", false);
      editor.className = "jeditor";
      if (obj2.options.placeholder) {
        editor.setAttribute("data-placeholder", obj2.options.placeholder);
      }
      if (obj2.options.maxHeight || obj2.options.height) {
        editor.style.overflowY = "auto";
        if (obj2.options.maxHeight) {
          editor.style.maxHeight = obj2.options.maxHeight;
        }
        if (obj2.options.height) {
          editor.style.height = obj2.options.height;
        }
      }
      if (obj2.options.value) {
        var value2 = obj2.options.value;
      } else {
        var value2 = el2.innerHTML ? el2.innerHTML : "";
      }
      if (!value2) {
        var value2 = "";
      }
      var change = function(e) {
        if (typeof obj2.options.onchange == "function") {
          obj2.options.onchange(el2, obj2, e);
        }
        obj2.options.value = obj2.getData();
        if (el2.value != obj2.options.value) {
          el2.value = obj2.options.value;
          if (typeof el2.oninput == "function") {
            el2.oninput({
              type: "input",
              target: el2,
              value: el2.value
            });
          }
        }
      };
      var extractImageFromHtml = function(html2) {
        var div2 = document.createElement("div");
        div2.innerHTML = html2;
        var img = div2.querySelectorAll("img");
        if (img.length) {
          for (var i2 = 0; i2 < img.length; i2++) {
            obj2.addImage(img[i2].src);
          }
        }
      };
      var insertNodeAtCaret = function(newNode) {
        var sel, range2;
        if (window.getSelection) {
          sel = window.getSelection();
          if (sel.rangeCount) {
            range2 = sel.getRangeAt(0);
            range2.toString();
            range2.deleteContents();
            range2.insertNode(newNode);
            range2.setStartAfter(newNode);
            range2.setEndAfter(newNode);
            sel.removeAllRanges();
            sel.addRange(range2);
          }
        }
      };
      var updateTotalImages = function() {
        var o = null;
        if (o = snippet2.children[0]) {
          if (!o.classList.contains("jslider-grid")) {
            o.classList.add("jslider-grid");
          }
          var number2 = o.children.length;
          o.setAttribute("data-number", number2 > 4 ? 4 : number2);
          if (number2 > 4) {
            o.setAttribute("data-total", number2 - 4);
          } else {
            o.removeAttribute("data-total");
          }
        }
      };
      var appendImage = function(image) {
        if (!snippet2.innerHTML) {
          appendElement({});
        }
        snippet2.children[0].appendChild(image);
        updateTotalImages();
      };
      var appendElement = function(data) {
        snippet2.innerHTML = "";
        var a = ["image", "title", "description", "host", "url"];
        for (var i2 = 0; i2 < a.length; i2++) {
          var div2 = document.createElement("div");
          div2.className = "jsnippet-" + a[i2];
          div2.setAttribute("data-k", a[i2]);
          snippet2.appendChild(div2);
          if (data[a[i2]]) {
            if (a[i2] == "image") {
              if (!Array.isArray(data.image)) {
                data.image = [data.image];
              }
              for (var j2 = 0; j2 < data.image.length; j2++) {
                var img = document.createElement("img");
                img.src = data.image[j2];
                div2.appendChild(img);
              }
            } else {
              div2.innerHTML = data[a[i2]];
            }
          }
        }
        editor.appendChild(document.createElement("br"));
        editor.appendChild(snippet2);
      };
      var verifyEditor = function() {
        clearTimeout(editorTimer);
        editorTimer = setTimeout(function() {
          var snippet22 = editor.querySelector(".jsnippet");
          if (!snippet22) {
            var html2 = editor.innerHTML.replace(/\n/g, " ");
            var container = document.createElement("div");
            container.innerHTML = html2;
            var text2 = container.innerText;
            var url = jSuites2.editor.detectUrl(text2);
            if (url) {
              if (url[0].substr(-3) == "jpg" || url[0].substr(-3) == "png" || url[0].substr(-3) == "gif") {
                obj2.addImage(url[0], true);
              } else {
                var id = jSuites2.editor.youtubeParser(url[0]);
                obj2.parseWebsite(url[0], id);
              }
            }
          }
        }, 1e3);
      };
      obj2.parseContent = function() {
        verifyEditor();
      };
      obj2.parseWebsite = function(url, youtubeId) {
        if (!obj2.options.remoteParser) {
          console.log("The remoteParser is not defined");
        } else {
          if (youtubeId) {
            var url = "https://www.youtube.com/watch?v=" + youtubeId;
          }
          var p2 = {
            title: "",
            description: "",
            image: "",
            host: url.split("/")[2],
            url
          };
          jSuites2.ajax({
            url: obj2.options.remoteParser + encodeURI(url.trim()),
            method: "GET",
            dataType: "json",
            success: function(result2) {
              if (result2.title) {
                p2.title = result2.title;
              }
              if (result2.description) {
                p2.description = result2.description;
              }
              if (result2.host) {
                p2.host = result2.host;
              }
              if (result2.url) {
                p2.url = result2.url;
              }
              appendElement(p2);
              if (result2.image) {
                obj2.addImage(result2.image, true);
              } else if (result2["og:image"]) {
                obj2.addImage(result2["og:image"], true);
              }
            }
          });
        }
      };
      obj2.setData = function(o) {
        if (typeof o == "object") {
          editor.innerHTML = o.content;
        } else {
          editor.innerHTML = o;
        }
        if (obj2.options.focus) {
          jSuites2.editor.setCursor(editor, true);
        }
        files = [];
      };
      obj2.getFiles = function() {
        var f = editor.querySelectorAll(".jfile");
        var d = [];
        for (var i2 = 0; i2 < f.length; i2++) {
          if (files[f[i2].src]) {
            d.push(files[f[i2].src]);
          }
        }
        return d;
      };
      obj2.getText = function() {
        return editor.innerText;
      };
      obj2.getData = function(json2) {
        if (!json2) {
          var data = editor.innerHTML;
        } else {
          var data = {
            content: ""
          };
          if (snippet2.innerHTML) {
            data.snippet = {};
            for (var i2 = 0; i2 < snippet2.children.length; i2++) {
              var key = snippet2.children[i2].getAttribute("data-k");
              if (key) {
                if (key == "image") {
                  if (!data.snippet.image) {
                    data.snippet.image = [];
                  }
                  for (var j2 = 0; j2 < snippet2.children[i2].children.length; j2++) {
                    data.snippet.image.push(snippet2.children[i2].children[j2].getAttribute("src"));
                  }
                } else {
                  data.snippet[key] = snippet2.children[i2].innerHTML;
                }
              }
            }
          }
          var f = Object.keys(files);
          if (f.length) {
            data.files = [];
            for (var i2 = 0; i2 < f.length; i2++) {
              data.files.push(files[f[i2]]);
            }
          }
          var text2 = editor.innerHTML;
          text2 = text2.replace(/<br>/g, "\n");
          text2 = text2.replace(/<\/div>/g, "</div>\n");
          text2 = text2.replace(/<(?:.|\n)*?>/gm, "");
          data.content = text2.trim();
        }
        return data;
      };
      obj2.reset = function() {
        editor.innerHTML = "";
        snippet2.innerHTML = "";
        files = [];
      };
      obj2.addPdf = function(data) {
        if (data.result.substr(0, 4) != "data") {
          console.error("Invalid source");
        } else {
          var canvas = document.createElement("canvas");
          canvas.width = 60;
          canvas.height = 60;
          var img = new Image();
          var ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          canvas.toBlob(function(blob2) {
            var newImage = document.createElement("img");
            newImage.src = window.URL.createObjectURL(blob2);
            newImage.title = data.name;
            newImage.className = "jfile pdf";
            files[newImage.src] = {
              file: newImage.src,
              extension: "pdf",
              content: data.result
            };
            insertNodeAtCaret(newImage);
          });
        }
      };
      obj2.addImage = function(src, asSnippet) {
        if (!src) {
          src = "";
        }
        if (src.substr(0, 4) != "data" && !obj2.options.remoteParser) {
          console.error("remoteParser not defined in your initialization");
        } else {
          if (src.substr(0, 4) == "data") {
            var extension = src.split(";");
            extension = extension[0].split("/");
            extension = extension[1];
          } else {
            var extension = src.substr(src.lastIndexOf(".") + 1);
            src = obj2.options.remoteParser + src;
          }
          var img = new Image();
          img.onload = function onload() {
            var canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(function(blob2) {
              var newImage = document.createElement("img");
              newImage.src = window.URL.createObjectURL(blob2);
              newImage.classList.add("jfile");
              newImage.setAttribute("tabindex", "900");
              files[newImage.src] = {
                file: newImage.src,
                extension,
                content: canvas.toDataURL()
              };
              if (obj2.options.dropAsSnippet || asSnippet) {
                appendImage(newImage);
                files[newImage.src].snippet = true;
              } else {
                insertNodeAtCaret(newImage);
              }
              change();
            });
          };
          img.src = src;
        }
      };
      obj2.addFile = function(files2) {
        var reader = [];
        for (var i2 = 0; i2 < files2.length; i2++) {
          if (files2[i2].size > obj2.options.maxFileSize) {
            alert("The file is too big");
          } else {
            var type2 = files2[i2].type.split("/");
            if (type2[0] == "image") {
              type2 = 1;
            } else if (type2[1] == "pdf") {
              type2 = 2;
            } else {
              type2 = 0;
            }
            if (type2) {
              reader[i2] = new FileReader();
              reader[i2].index = i2;
              reader[i2].type = type2;
              reader[i2].name = files2[i2].name;
              reader[i2].date = files2[i2].lastModified;
              reader[i2].size = files2[i2].size;
              reader[i2].addEventListener("load", function(data) {
                if (data.target.type == 2) {
                  if (obj2.options.acceptFiles == true) {
                    obj2.addPdf(data.target);
                  }
                } else {
                  obj2.addImage(data.target.result);
                }
              }, false);
              reader[i2].readAsDataURL(files2[i2]);
            } else {
              alert("The extension is not allowed");
            }
          }
        }
      };
      obj2.destroy = function() {
        editor.removeEventListener("mouseup", editorMouseUp);
        editor.removeEventListener("mousedown", editorMouseDown);
        editor.removeEventListener("mousemove", editorMouseMove);
        editor.removeEventListener("keyup", editorKeyUp);
        editor.removeEventListener("keydown", editorKeyDown);
        editor.removeEventListener("dragstart", editorDragStart);
        editor.removeEventListener("dragenter", editorDragEnter);
        editor.removeEventListener("dragover", editorDragOver);
        editor.removeEventListener("drop", editorDrop);
        editor.removeEventListener("paste", editorPaste);
        if (typeof obj2.options.onblur == "function") {
          editor.removeEventListener("blur", editorBlur);
        }
        if (typeof obj2.options.onfocus == "function") {
          editor.removeEventListener("focus", editorFocus);
        }
        el2.editor = null;
        el2.classList.remove("jeditor-container");
        toolbar2.remove();
        snippet2.remove();
        editor.remove();
      };
      var editorMouseUp = function(e) {
        if (editorAction && editorAction.e) {
          editorAction.e.classList.remove("resizing");
        }
        editorAction = false;
      };
      var editorMouseDown = function(e) {
        var close = function(snippet22) {
          var rect2 = snippet22.getBoundingClientRect();
          if (rect2.width - (e.clientX - rect2.left) < 40 && e.clientY - rect2.top < 40) {
            snippet22.innerHTML = "";
            snippet22.remove();
          }
        };
        if (e.target.tagName == "IMG") {
          if (e.target.style.cursor) {
            var rect = e.target.getBoundingClientRect();
            editorAction = {
              e: e.target,
              x: e.clientX,
              y: e.clientY,
              w: rect.width,
              h: rect.height,
              d: e.target.style.cursor
            };
            if (!e.target.width) {
              e.target.width = rect.width + "px";
            }
            if (!e.target.height) {
              e.target.height = rect.height + "px";
            }
            var s = window.getSelection();
            if (s.rangeCount) {
              for (var i2 = 0; i2 < s.rangeCount; i2++) {
                s.removeRange(s.getRangeAt(i2));
              }
            }
            e.target.classList.add("resizing");
          } else {
            editorAction = true;
          }
        } else {
          if (e.target.classList.contains("jsnippet")) {
            close(e.target);
          } else if (e.target.parentNode.classList.contains("jsnippet")) {
            close(e.target.parentNode);
          }
          editorAction = true;
        }
      };
      var editorMouseMove = function(e) {
        if (e.target.tagName == "IMG" && !e.target.parentNode.classList.contains("jsnippet-image") && obj2.options.allowImageResize == true) {
          if (e.target.getAttribute("tabindex")) {
            var rect = e.target.getBoundingClientRect();
            if (e.clientY - rect.top < 5) {
              if (rect.width - (e.clientX - rect.left) < 5) {
                e.target.style.cursor = "ne-resize";
              } else if (e.clientX - rect.left < 5) {
                e.target.style.cursor = "nw-resize";
              } else {
                e.target.style.cursor = "n-resize";
              }
            } else if (rect.height - (e.clientY - rect.top) < 5) {
              if (rect.width - (e.clientX - rect.left) < 5) {
                e.target.style.cursor = "se-resize";
              } else if (e.clientX - rect.left < 5) {
                e.target.style.cursor = "sw-resize";
              } else {
                e.target.style.cursor = "s-resize";
              }
            } else if (rect.width - (e.clientX - rect.left) < 5) {
              e.target.style.cursor = "e-resize";
            } else if (e.clientX - rect.left < 5) {
              e.target.style.cursor = "w-resize";
            } else {
              e.target.style.cursor = "";
            }
          }
        }
        if (e.which == 1 && editorAction && editorAction.d) {
          if (editorAction.d == "e-resize" || editorAction.d == "ne-resize" || editorAction.d == "se-resize") {
            editorAction.e.width = editorAction.w + (e.clientX - editorAction.x);
            if (e.shiftKey) {
              var newHeight = (e.clientX - editorAction.x) * (editorAction.h / editorAction.w);
              editorAction.e.height = editorAction.h + newHeight;
            } else {
              var newHeight = null;
            }
          }
          if (!newHeight) {
            if (editorAction.d == "s-resize" || editorAction.d == "se-resize" || editorAction.d == "sw-resize") {
              if (!e.shiftKey) {
                editorAction.e.height = editorAction.h + (e.clientY - editorAction.y);
              }
            }
          }
        }
      };
      var editorKeyUp = function(e) {
        if (!editor.innerHTML) {
          editor.innerHTML = "<div><br></div>";
        }
        if (typeof obj2.options.onkeyup == "function") {
          obj2.options.onkeyup(el2, obj2, e);
        }
      };
      var editorKeyDown = function(e) {
        if (obj2.options.parseURL == true) {
          verifyEditor();
        }
        if (typeof obj2.options.onkeydown == "function") {
          obj2.options.onkeydown(el2, obj2, e);
        }
        if (e.key == "Delete") {
          if (e.target.tagName == "IMG" && e.target.parentNode.classList.contains("jsnippet-image")) {
            e.target.remove();
            updateTotalImages();
          }
        }
      };
      var remove2 = [HTMLUnknownElement, HTMLAudioElement, HTMLEmbedElement, HTMLIFrameElement, HTMLTextAreaElement, HTMLInputElement, HTMLScriptElement];
      var validProperty = ["width", "height", "align", "border", "src", "tabindex"];
      var validStyle = ["color", "font-weight", "font-size", "background", "background-color", "margin"];
      var parse22 = function(element2) {
        if (element2.attributes && element2.attributes.length) {
          var style = null;
          var elementStyle = element2.getAttribute("style");
          if (elementStyle) {
            style = [];
            var t = elementStyle.split(";");
            for (var j2 = 0; j2 < t.length; j2++) {
              var v = t[j2].trim().split(":");
              if (validStyle.indexOf(v[0].trim()) >= 0) {
                var k2 = v.shift();
                var v = v.join(":");
                style.push(k2 + ":" + v);
              }
            }
          }
          if (element2.tagName.toUpperCase() == "IMG") {
            if (!obj2.options.acceptImages || !element2.src) {
              element2.parentNode.removeChild(element2);
            } else {
              element2.setAttribute("tabindex", "900");
              obj2.addImage(element2.src);
            }
          }
          var attr2 = [];
          var numAttributes = element2.attributes.length - 1;
          if (numAttributes > 0) {
            for (var i2 = numAttributes; i2 >= 0; i2--) {
              attr2.push(element2.attributes[i2].name);
            }
            attr2.forEach(function(v2) {
              if (validProperty.indexOf(v2) == -1) {
                element2.removeAttribute(v2);
              }
            });
          }
          element2.style = "";
          if (style && style.length) {
            element2.setAttribute("style", style.join(";"));
          }
        }
        if (element2.children.length) {
          for (var i2 = 0; i2 < element2.children.length; i2++) {
            parse22(element2.children[i2]);
          }
        }
        if (remove2.indexOf(element2.constructor) >= 0) {
          element2.remove();
        }
      };
      var filter = function(data) {
        if (data) {
          data = data.replace(new RegExp("<!--(.*?)-->", "gsi"), "");
        }
        var parser2 = new DOMParser();
        var d = parser2.parseFromString(data, "text/html");
        parse22(d);
        var span = document.createElement("span");
        span.innerHTML = d.firstChild.innerHTML;
        return span;
      };
      var editorPaste = function(e) {
        if (obj2.options.filterPaste == true) {
          if (e.clipboardData || e.originalEvent.clipboardData) {
            var html2 = (e.originalEvent || e).clipboardData.getData("text/html");
            var text2 = (e.originalEvent || e).clipboardData.getData("text/plain");
            var file = (e.originalEvent || e).clipboardData.files;
          } else if (window.clipboardData) {
            var html2 = window.clipboardData.getData("Html");
            var text2 = window.clipboardData.getData("Text");
            var file = window.clipboardData.files;
          }
          if (file.length) {
            obj2.addFile(file);
          } else {
            if (!html2) {
              html2 = text2.split("\r\n");
              if (!e.target.innerText) {
                html2.map(function(v) {
                  var d2 = document.createElement("div");
                  d2.innerText = v;
                  editor.appendChild(d2);
                });
              } else {
                html2 = html2.map(function(v) {
                  return "<div>" + v + "</div>";
                });
                document.execCommand("insertHtml", false, html2.join(""));
              }
            } else {
              var d = filter(html2);
              document.execCommand("insertHtml", false, d.innerHTML);
            }
          }
          e.preventDefault();
        }
      };
      var editorDragStart = function(e) {
        if (editorAction && editorAction.e) {
          e.preventDefault();
        }
      };
      var editorDragEnter = function(e) {
        if (editorAction || obj2.options.dropZone == false)
          ;
        else {
          el2.classList.add("jeditor-dragging");
          e.preventDefault();
        }
      };
      var editorDragOver = function(e) {
        if (editorAction || obj2.options.dropZone == false)
          ;
        else {
          if (editorTimer) {
            clearTimeout(editorTimer);
          }
          editorTimer = setTimeout(function() {
            el2.classList.remove("jeditor-dragging");
          }, 100);
          e.preventDefault();
        }
      };
      var editorDrop = function(e) {
        if (editorAction || obj2.options.dropZone == false)
          ;
        else {
          var range2 = null;
          if (document.caretRangeFromPoint) {
            range2 = document.caretRangeFromPoint(e.clientX, e.clientY);
          } else if (e.rangeParent) {
            range2 = document.createRange();
            range2.setStart(e.rangeParent, e.rangeOffset);
          }
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range2);
          sel.anchorNode.parentNode.focus();
          var html2 = (e.originalEvent || e).dataTransfer.getData("text/html");
          var text2 = (e.originalEvent || e).dataTransfer.getData("text/plain");
          var file = (e.originalEvent || e).dataTransfer.files;
          if (file.length) {
            obj2.addFile(file);
          } else if (text2) {
            extractImageFromHtml(html2);
          }
          el2.classList.remove("jeditor-dragging");
          e.preventDefault();
        }
      };
      var editorBlur = function(e) {
        if (typeof obj2.options.onblur == "function") {
          obj2.options.onblur(el2, obj2, e);
        }
        change(e);
      };
      var editorFocus = function(e) {
        if (typeof obj2.options.onfocus == "function") {
          obj2.options.onfocus(el2, obj2, e);
        }
      };
      editor.addEventListener("mouseup", editorMouseUp);
      editor.addEventListener("mousedown", editorMouseDown);
      editor.addEventListener("mousemove", editorMouseMove);
      editor.addEventListener("keyup", editorKeyUp);
      editor.addEventListener("keydown", editorKeyDown);
      editor.addEventListener("dragstart", editorDragStart);
      editor.addEventListener("dragenter", editorDragEnter);
      editor.addEventListener("dragover", editorDragOver);
      editor.addEventListener("drop", editorDrop);
      editor.addEventListener("paste", editorPaste);
      editor.addEventListener("focus", editorFocus);
      editor.addEventListener("blur", editorBlur);
      if (typeof obj2.options.onload == "function") {
        obj2.options.onload(el2, obj2, editor);
      }
      editor.innerHTML = value2;
      el2.appendChild(editor);
      if (obj2.options.snippet) {
        appendElement(obj2.options.snippet);
      }
      if (obj2.options.toolbar == null) {
        obj2.options.toolbar = jSuites2.editor.getDefaultToolbar();
      }
      if (obj2.options.toolbar) {
        el2.appendChild(toolbar2);
        jSuites2.toolbar(toolbar2, {
          container: true,
          responsive: true,
          items: obj2.options.toolbar
        });
      }
      if (obj2.options.focus) {
        jSuites2.editor.setCursor(editor, obj2.options.focus == "initial" ? true : false);
      }
      el2.change = obj2.setData;
      el2.val = function(val) {
        if (val === void 0) {
          var o = el2.getAttribute("data-html") === "true" ? false : true;
          return obj2.getData(o);
        } else {
          obj2.setData(val);
        }
      };
      el2.editor = obj2;
      return obj2;
    };
    jSuites2.editor.setCursor = function(element2, first) {
      element2.focus();
      document.execCommand("selectAll");
      var sel = window.getSelection();
      var range2 = sel.getRangeAt(0);
      if (first == true) {
        var node = range2.startContainer;
        var size = 0;
      } else {
        var node = range2.endContainer;
        var size = node.length;
      }
      range2.setStart(node, size);
      range2.setEnd(node, size);
      sel.removeAllRanges();
      sel.addRange(range2);
    };
    jSuites2.editor.getDomain = function(url) {
      return url.replace("http://", "").replace("https://", "").replace("www.", "").split(/[/?#]/)[0].split(/:/g)[0];
    };
    jSuites2.editor.detectUrl = function(text2) {
      var expression2 = /(((https?:\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]+)/ig;
      var links = text2.match(expression2);
      if (links) {
        if (links[0].substr(0, 3) == "www") {
          links[0] = "http://" + links[0];
        }
      }
      return links;
    };
    jSuites2.editor.youtubeParser = function(url) {
      var regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
      var match = url.match(regExp);
      return match && match[7].length == 11 ? match[7] : false;
    };
    jSuites2.editor.getDefaultToolbar = function() {
      return [
        {
          content: "undo",
          onclick: function() {
            document.execCommand("undo");
          }
        },
        {
          content: "redo",
          onclick: function() {
            document.execCommand("redo");
          }
        },
        {
          type: "divisor"
        },
        {
          content: "format_bold",
          onclick: function(a, b, c2) {
            document.execCommand("bold");
            if (document.queryCommandState("bold")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          content: "format_italic",
          onclick: function(a, b, c2) {
            document.execCommand("italic");
            if (document.queryCommandState("italic")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          content: "format_underline",
          onclick: function(a, b, c2) {
            document.execCommand("underline");
            if (document.queryCommandState("underline")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          type: "divisor"
        },
        {
          content: "format_list_bulleted",
          onclick: function(a, b, c2) {
            document.execCommand("insertUnorderedList");
            if (document.queryCommandState("insertUnorderedList")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          content: "format_list_numbered",
          onclick: function(a, b, c2) {
            document.execCommand("insertOrderedList");
            if (document.queryCommandState("insertOrderedList")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          content: "format_indent_increase",
          onclick: function(a, b, c2) {
            document.execCommand("indent", true, null);
            if (document.queryCommandState("indent")) {
              c2.classList.add("selected");
            } else {
              c2.classList.remove("selected");
            }
          }
        },
        {
          content: "format_indent_decrease",
          onclick: function() {
            document.execCommand("outdent");
            if (document.queryCommandState("outdent")) {
              this.classList.add("selected");
            } else {
              this.classList.remove("selected");
            }
          }
        }
      ];
    };
    jSuites2.form = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        url: null,
        message: "Are you sure? There are unsaved information in your form",
        ignore: false,
        currentHash: null,
        submitButton: null,
        validations: null,
        onbeforeload: null,
        onload: null,
        onbeforesave: null,
        onsave: null,
        onbeforeremove: null,
        onremove: null,
        onerror: function(el3, message) {
          jSuites2.alert(message);
        }
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      if (!obj2.options.validations) {
        obj2.options.validations = {};
      }
      if (!obj2.options.submitButton) {
        obj2.options.submitButton = el2.querySelector("input[type=submit]");
      }
      if (obj2.options.submitButton && obj2.options.url) {
        obj2.options.submitButton.onclick = function() {
          obj2.save();
        };
      }
      if (!obj2.options.validations.email) {
        obj2.options.validations.email = jSuites2.validations.email;
      }
      if (!obj2.options.validations.length) {
        obj2.options.validations.length = jSuites2.validations.length;
      }
      if (!obj2.options.validations.required) {
        obj2.options.validations.required = jSuites2.validations.required;
      }
      obj2.setUrl = function(url) {
        obj2.options.url = url;
      };
      obj2.load = function() {
        jSuites2.ajax({
          url: obj2.options.url,
          method: "GET",
          dataType: "json",
          queue: true,
          success: function(data) {
            if (typeof obj2.options.onbeforeload == "function") {
              var ret = obj2.options.onbeforeload(el2, data);
              if (ret) {
                data = ret;
              }
            }
            jSuites2.form.setElements(el2, data);
            if (typeof obj2.options.onload == "function") {
              obj2.options.onload(el2, data);
            }
          }
        });
      };
      obj2.save = function() {
        var test = obj2.validate();
        if (test) {
          obj2.options.onerror(el2, test);
        } else {
          var data = jSuites2.form.getElements(el2, true);
          if (typeof obj2.options.onbeforesave == "function") {
            var data = obj2.options.onbeforesave(el2, data);
            if (data === false) {
              return;
            }
          }
          jSuites2.ajax({
            url: obj2.options.url,
            method: "POST",
            dataType: "json",
            data,
            success: function(result2) {
              if (typeof obj2.options.onsave == "function") {
                obj2.options.onsave(el2, data, result2);
              }
            }
          });
        }
      };
      obj2.remove = function() {
        if (typeof obj2.options.onbeforeremove == "function") {
          var ret = obj2.options.onbeforeremove(el2, obj2);
          if (ret === false) {
            return false;
          }
        }
        jSuites2.ajax({
          url: obj2.options.url,
          method: "DELETE",
          dataType: "json",
          success: function(result2) {
            if (typeof obj2.options.onremove == "function") {
              obj2.options.onremove(el2, obj2, result2);
            }
            obj2.reset();
          }
        });
      };
      var addError = function(element2) {
        element2.classList.add("error");
        if (obj2.options.submitButton) {
          obj2.options.submitButton.setAttribute("disabled", true);
        }
        var error2 = element2.getAttribute("data-error") || "There is an error in the form";
        element2.setAttribute("title", error2);
        return error2;
      };
      var delError = function(element2) {
        var error2 = false;
        element2.classList.remove("error");
        element2.removeAttribute("title");
        var elements2 = el2.querySelectorAll("input, select, textarea, div[name]");
        for (var i2 = 0; i2 < elements2.length; i2++) {
          if (elements2[i2].getAttribute("data-validation")) {
            if (elements2[i2].classList.contains("error")) {
              error2 = true;
            }
          }
        }
        if (obj2.options.submitButton) {
          if (error2) {
            obj2.options.submitButton.setAttribute("disabled", true);
          } else {
            obj2.options.submitButton.removeAttribute("disabled");
          }
        }
      };
      obj2.validateElement = function(element2) {
        var test = false;
        var value2 = jSuites2.form.getValue(element2);
        var validation = element2.getAttribute("data-validation");
        if (typeof obj2.options.validations[validation] == "function" && !obj2.options.validations[validation](value2, element2)) {
          test = addError(element2);
        } else {
          if (element2.classList.contains("error")) {
            delError(element2);
          }
        }
        return test;
      };
      obj2.reset = function() {
        var elements2 = el2.querySelectorAll("input, select, textarea, div[name]");
        for (var i2 = 0; i2 < elements2.length; i2++) {
          if (elements2[i2].getAttribute("name")) {
            if (elements2[i2].type == "checkbox" || elements2[i2].type == "radio") {
              elements2[i2].checked = false;
            } else {
              if (typeof elements2[i2].val == "function") {
                elements2[i2].val("");
              } else {
                elements2[i2].value = "";
              }
            }
          }
        }
      };
      obj2.validate = function() {
        var test = [];
        var elements2 = el2.querySelectorAll("input, select, textarea, div[name]");
        for (var i2 = 0; i2 < elements2.length; i2++) {
          if (elements2[i2].getAttribute("data-validation")) {
            var res2 = obj2.validateElement(elements2[i2]);
            if (res2) {
              test.push(res2);
            }
          }
        }
        if (test.length > 0) {
          return test.join("<br>");
        } else {
          return false;
        }
      };
      obj2.getError = function() {
        return obj2.validation() ? true : false;
      };
      obj2.setHash = function() {
        return obj2.getHash(jSuites2.form.getElements(el2));
      };
      obj2.getHash = function(str2) {
        var hash2 = 0, i2, chr;
        if (str2.length === 0) {
          return hash2;
        } else {
          for (i2 = 0; i2 < str2.length; i2++) {
            chr = str2.charCodeAt(i2);
            hash2 = (hash2 << 5) - hash2 + chr;
            hash2 |= 0;
          }
        }
        return hash2;
      };
      obj2.isChanged = function() {
        var hash2 = obj2.setHash();
        return obj2.options.currentHash != hash2;
      };
      obj2.resetTracker = function() {
        obj2.options.currentHash = obj2.setHash();
        obj2.options.ignore = false;
      };
      obj2.setIgnore = function(ignoreFlag) {
        obj2.options.ignore = ignoreFlag ? true : false;
      };
      setTimeout(function() {
        obj2.options.currentHash = obj2.setHash();
      }, 1e3);
      el2.addEventListener("keyup", function(e) {
        if (e.target.getAttribute("data-validation")) {
          obj2.validateElement(e.target);
        }
      });
      if (!jSuites2.form.hasEvents) {
        window.addEventListener("beforeunload", function(e) {
          if (obj2.isChanged() && obj2.options.ignore == false) {
            var confirmationMessage = obj2.options.message ? obj2.options.message : "o/";
            if (confirmationMessage) {
              if (typeof e == "undefined") {
                e = window.event;
              }
              if (e) {
                e.returnValue = confirmationMessage;
              }
              return confirmationMessage;
            } else {
              return void 0;
            }
          }
        });
        jSuites2.form.hasEvents = true;
      }
      el2.form = obj2;
      return obj2;
    };
    jSuites2.form.getValue = function(element2) {
      var value2 = null;
      if (element2.type == "checkbox") {
        if (element2.checked == true) {
          value2 = element2.value || true;
        }
      } else if (element2.type == "radio") {
        if (element2.checked == true) {
          value2 = element2.value;
        }
      } else if (element2.type == "file") {
        value2 = element2.files;
      } else if (element2.tagName == "select" && element2.multiple == true) {
        value2 = [];
        var options2 = element2.querySelectorAll("options[selected]");
        for (var j2 = 0; j2 < options2.length; j2++) {
          value2.push(options2[j2].value);
        }
      } else if (typeof element2.val == "function") {
        value2 = element2.val();
      } else {
        value2 = element2.value || "";
      }
      return value2;
    };
    jSuites2.form.getElements = function(el2, asArray2) {
      var data = {};
      var name = null;
      var elements2 = el2.querySelectorAll("input, select, textarea, div[name]");
      for (var i2 = 0; i2 < elements2.length; i2++) {
        if (name = elements2[i2].getAttribute("name")) {
          data[name] = jSuites2.form.getValue(elements2[i2]) || "";
        }
      }
      return asArray2 == true ? data : JSON.stringify(data);
    };
    jSuites2.form.setElements = function(el2, data) {
      var name = null;
      var value2 = null;
      var elements2 = el2.querySelectorAll("input, select, textarea, div[name]");
      for (var i2 = 0; i2 < elements2.length; i2++) {
        var type2 = elements2[i2].getAttribute("type");
        if (name = elements2[i2].getAttribute("name")) {
          name = name.replace(new RegExp(/\[(.*?)\]/ig), ".$1");
          value2 = null;
          if (name.match(/\./)) {
            var tmp2 = jSuites2.path.call(data, name) || "";
            if (typeof tmp2 !== "undefined") {
              value2 = tmp2;
            }
          } else {
            if (typeof data[name] !== "undefined") {
              value2 = data[name];
            }
          }
          if (value2 !== null) {
            if (type2 == "checkbox" || type2 == "radio") {
              elements2[i2].checked = value2 ? true : false;
            } else if (type2 == "file")
              ;
            else {
              if (typeof elements2[i2].val == "function") {
                elements2[i2].val(value2);
              } else {
                elements2[i2].value = value2;
              }
            }
          }
        }
      }
    };
    jSuites2.tracker = jSuites2.form;
    jSuites2.focus = function(el2) {
      if (el2.innerText.length) {
        var range2 = document.createRange();
        var sel = window.getSelection();
        var node = el2.childNodes[el2.childNodes.length - 1];
        range2.setStart(node, node.length);
        range2.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range2);
        el2.scrollLeft = el2.scrollWidth;
      }
    };
    jSuites2.isNumeric = function(num) {
      return !isNaN(num) && num !== null && num !== "";
    };
    jSuites2.guid = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
        var r = Math.random() * 16 | 0, v = c2 == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    jSuites2.getNode = function() {
      var node = document.getSelection().anchorNode;
      if (node) {
        return node.nodeType == 3 ? node.parentNode : node;
      } else {
        return null;
      }
    };
    jSuites2.hash = function(str2) {
      var hash2 = 0, i2, chr;
      if (str2.length === 0) {
        return hash2;
      } else {
        for (i2 = 0; i2 < str2.length; i2++) {
          chr = str2.charCodeAt(i2);
          if (chr > 32) {
            hash2 = (hash2 << 5) - hash2 + chr;
            hash2 |= 0;
          }
        }
      }
      return hash2;
    };
    jSuites2.randomColor = function(h) {
      var lum = -0.25;
      var hex = String("#" + Math.random().toString(16).slice(2, 8).toUpperCase()).replace(/[^0-9a-f]/gi, "");
      if (hex.length < 6) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      var rgb = [], c2, i2;
      for (i2 = 0; i2 < 3; i2++) {
        c2 = parseInt(hex.substr(i2 * 2, 2), 16);
        c2 = Math.round(Math.min(Math.max(0, c2 + c2 * lum), 255)).toString(16);
        rgb.push(("00" + c2).substr(c2.length));
      }
      if (h == true) {
        return "#" + jSuites2.two(rgb[0].toString(16)) + jSuites2.two(rgb[1].toString(16)) + jSuites2.two(rgb[2].toString(16));
      }
      return rgb;
    };
    jSuites2.getWindowWidth = function() {
      var w = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], x2 = w.innerWidth || e.clientWidth || g.clientWidth;
      return x2;
    };
    jSuites2.getWindowHeight = function() {
      var w = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], y2 = w.innerHeight || e.clientHeight || g.clientHeight;
      return y2;
    };
    jSuites2.getPosition = function(e) {
      if (e.changedTouches && e.changedTouches[0]) {
        var x2 = e.changedTouches[0].pageX;
        var y2 = e.changedTouches[0].pageY;
      } else {
        var x2 = window.Event ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        var y2 = window.Event ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      }
      return [x2, y2];
    };
    jSuites2.click = function(el2) {
      if (el2.click) {
        el2.click();
      } else {
        var evt = new MouseEvent("click", {
          bubbles: true,
          cancelable: true,
          view: window
        });
        el2.dispatchEvent(evt);
      }
    };
    jSuites2.findElement = function(element2, condition2) {
      var foundElement = false;
      function path2(element3) {
        if (element3 && !foundElement) {
          if (typeof condition2 == "function") {
            foundElement = condition2(element3);
          } else if (typeof condition2 == "string") {
            if (element3.classList && element3.classList.contains(condition2)) {
              foundElement = element3;
            }
          }
        }
        if (element3.parentNode && !foundElement) {
          path2(element3.parentNode);
        }
      }
      path2(element2);
      return foundElement;
    };
    jSuites2.two = function(value2) {
      value2 = "" + value2;
      if (value2.length == 1) {
        value2 = "0" + value2;
      }
      return value2;
    };
    jSuites2.sha512 = function(str2) {
      function int64(msint_32, lsint_32) {
        this.highOrder = msint_32;
        this.lowOrder = lsint_32;
      }
      var H = [
        new int64(1779033703, 4089235720),
        new int64(3144134277, 2227873595),
        new int64(1013904242, 4271175723),
        new int64(2773480762, 1595750129),
        new int64(1359893119, 2917565137),
        new int64(2600822924, 725511199),
        new int64(528734635, 4215389547),
        new int64(1541459225, 327033209)
      ];
      var K = [
        new int64(1116352408, 3609767458),
        new int64(1899447441, 602891725),
        new int64(3049323471, 3964484399),
        new int64(3921009573, 2173295548),
        new int64(961987163, 4081628472),
        new int64(1508970993, 3053834265),
        new int64(2453635748, 2937671579),
        new int64(2870763221, 3664609560),
        new int64(3624381080, 2734883394),
        new int64(310598401, 1164996542),
        new int64(607225278, 1323610764),
        new int64(1426881987, 3590304994),
        new int64(1925078388, 4068182383),
        new int64(2162078206, 991336113),
        new int64(2614888103, 633803317),
        new int64(3248222580, 3479774868),
        new int64(3835390401, 2666613458),
        new int64(4022224774, 944711139),
        new int64(264347078, 2341262773),
        new int64(604807628, 2007800933),
        new int64(770255983, 1495990901),
        new int64(1249150122, 1856431235),
        new int64(1555081692, 3175218132),
        new int64(1996064986, 2198950837),
        new int64(2554220882, 3999719339),
        new int64(2821834349, 766784016),
        new int64(2952996808, 2566594879),
        new int64(3210313671, 3203337956),
        new int64(3336571891, 1034457026),
        new int64(3584528711, 2466948901),
        new int64(113926993, 3758326383),
        new int64(338241895, 168717936),
        new int64(666307205, 1188179964),
        new int64(773529912, 1546045734),
        new int64(1294757372, 1522805485),
        new int64(1396182291, 2643833823),
        new int64(1695183700, 2343527390),
        new int64(1986661051, 1014477480),
        new int64(2177026350, 1206759142),
        new int64(2456956037, 344077627),
        new int64(2730485921, 1290863460),
        new int64(2820302411, 3158454273),
        new int64(3259730800, 3505952657),
        new int64(3345764771, 106217008),
        new int64(3516065817, 3606008344),
        new int64(3600352804, 1432725776),
        new int64(4094571909, 1467031594),
        new int64(275423344, 851169720),
        new int64(430227734, 3100823752),
        new int64(506948616, 1363258195),
        new int64(659060556, 3750685593),
        new int64(883997877, 3785050280),
        new int64(958139571, 3318307427),
        new int64(1322822218, 3812723403),
        new int64(1537002063, 2003034995),
        new int64(1747873779, 3602036899),
        new int64(1955562222, 1575990012),
        new int64(2024104815, 1125592928),
        new int64(2227730452, 2716904306),
        new int64(2361852424, 442776044),
        new int64(2428436474, 593698344),
        new int64(2756734187, 3733110249),
        new int64(3204031479, 2999351573),
        new int64(3329325298, 3815920427),
        new int64(3391569614, 3928383900),
        new int64(3515267271, 566280711),
        new int64(3940187606, 3454069534),
        new int64(4118630271, 4000239992),
        new int64(116418474, 1914138554),
        new int64(174292421, 2731055270),
        new int64(289380356, 3203993006),
        new int64(460393269, 320620315),
        new int64(685471733, 587496836),
        new int64(852142971, 1086792851),
        new int64(1017036298, 365543100),
        new int64(1126000580, 2618297676),
        new int64(1288033470, 3409855158),
        new int64(1501505948, 4234509866),
        new int64(1607167915, 987167468),
        new int64(1816402316, 1246189591)
      ];
      var W = new Array(64);
      var a, b, c2, d, e, f, g, h, i2, j2;
      var T1, T2;
      var charsize = 8;
      function utf8_encode(str22) {
        return unescape(encodeURIComponent(str22));
      }
      function str2binb(str22) {
        var bin = [];
        var mask = (1 << charsize) - 1;
        var len = str22.length * charsize;
        for (var i3 = 0; i3 < len; i3 += charsize) {
          bin[i3 >> 5] |= (str22.charCodeAt(i3 / charsize) & mask) << 32 - charsize - i3 % 32;
        }
        return bin;
      }
      function binb2hex(binarray2) {
        var hex_tab = "0123456789abcdef";
        var str22 = "";
        var length = binarray2.length * 4;
        var srcByte;
        for (var i3 = 0; i3 < length; i3 += 1) {
          srcByte = binarray2[i3 >> 2] >> (3 - i3 % 4) * 8;
          str22 += hex_tab.charAt(srcByte >> 4 & 15) + hex_tab.charAt(srcByte & 15);
        }
        return str22;
      }
      function safe_add_2(x2, y2) {
        var lsw, msw, lowOrder, highOrder;
        lsw = (x2.lowOrder & 65535) + (y2.lowOrder & 65535);
        msw = (x2.lowOrder >>> 16) + (y2.lowOrder >>> 16) + (lsw >>> 16);
        lowOrder = (msw & 65535) << 16 | lsw & 65535;
        lsw = (x2.highOrder & 65535) + (y2.highOrder & 65535) + (msw >>> 16);
        msw = (x2.highOrder >>> 16) + (y2.highOrder >>> 16) + (lsw >>> 16);
        highOrder = (msw & 65535) << 16 | lsw & 65535;
        return new int64(highOrder, lowOrder);
      }
      function safe_add_4(a2, b2, c3, d2) {
        var lsw, msw, lowOrder, highOrder;
        lsw = (a2.lowOrder & 65535) + (b2.lowOrder & 65535) + (c3.lowOrder & 65535) + (d2.lowOrder & 65535);
        msw = (a2.lowOrder >>> 16) + (b2.lowOrder >>> 16) + (c3.lowOrder >>> 16) + (d2.lowOrder >>> 16) + (lsw >>> 16);
        lowOrder = (msw & 65535) << 16 | lsw & 65535;
        lsw = (a2.highOrder & 65535) + (b2.highOrder & 65535) + (c3.highOrder & 65535) + (d2.highOrder & 65535) + (msw >>> 16);
        msw = (a2.highOrder >>> 16) + (b2.highOrder >>> 16) + (c3.highOrder >>> 16) + (d2.highOrder >>> 16) + (lsw >>> 16);
        highOrder = (msw & 65535) << 16 | lsw & 65535;
        return new int64(highOrder, lowOrder);
      }
      function safe_add_5(a2, b2, c3, d2, e2) {
        var lsw, msw, lowOrder, highOrder;
        lsw = (a2.lowOrder & 65535) + (b2.lowOrder & 65535) + (c3.lowOrder & 65535) + (d2.lowOrder & 65535) + (e2.lowOrder & 65535);
        msw = (a2.lowOrder >>> 16) + (b2.lowOrder >>> 16) + (c3.lowOrder >>> 16) + (d2.lowOrder >>> 16) + (e2.lowOrder >>> 16) + (lsw >>> 16);
        lowOrder = (msw & 65535) << 16 | lsw & 65535;
        lsw = (a2.highOrder & 65535) + (b2.highOrder & 65535) + (c3.highOrder & 65535) + (d2.highOrder & 65535) + (e2.highOrder & 65535) + (msw >>> 16);
        msw = (a2.highOrder >>> 16) + (b2.highOrder >>> 16) + (c3.highOrder >>> 16) + (d2.highOrder >>> 16) + (e2.highOrder >>> 16) + (lsw >>> 16);
        highOrder = (msw & 65535) << 16 | lsw & 65535;
        return new int64(highOrder, lowOrder);
      }
      function maj(x2, y2, z2) {
        return new int64(x2.highOrder & y2.highOrder ^ x2.highOrder & z2.highOrder ^ y2.highOrder & z2.highOrder, x2.lowOrder & y2.lowOrder ^ x2.lowOrder & z2.lowOrder ^ y2.lowOrder & z2.lowOrder);
      }
      function ch(x2, y2, z2) {
        return new int64(x2.highOrder & y2.highOrder ^ ~x2.highOrder & z2.highOrder, x2.lowOrder & y2.lowOrder ^ ~x2.lowOrder & z2.lowOrder);
      }
      function rotr(x2, n2) {
        if (n2 <= 32) {
          return new int64(x2.highOrder >>> n2 | x2.lowOrder << 32 - n2, x2.lowOrder >>> n2 | x2.highOrder << 32 - n2);
        } else {
          return new int64(x2.lowOrder >>> n2 | x2.highOrder << 32 - n2, x2.highOrder >>> n2 | x2.lowOrder << 32 - n2);
        }
      }
      function sigma0(x2) {
        var rotr28 = rotr(x2, 28);
        var rotr34 = rotr(x2, 34);
        var rotr39 = rotr(x2, 39);
        return new int64(rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder, rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);
      }
      function sigma1(x2) {
        var rotr14 = rotr(x2, 14);
        var rotr18 = rotr(x2, 18);
        var rotr41 = rotr(x2, 41);
        return new int64(rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder, rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);
      }
      function gamma0(x2) {
        var rotr1 = rotr(x2, 1), rotr8 = rotr(x2, 8), shr7 = shr(x2, 7);
        return new int64(rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder, rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder);
      }
      function gamma1(x2) {
        var rotr19 = rotr(x2, 19);
        var rotr61 = rotr(x2, 61);
        var shr6 = shr(x2, 6);
        return new int64(rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder, rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder);
      }
      function shr(x2, n2) {
        if (n2 <= 32) {
          return new int64(x2.highOrder >>> n2, x2.lowOrder >>> n2 | x2.highOrder << 32 - n2);
        } else {
          return new int64(0, x2.highOrder << 32 - n2);
        }
      }
      var str2 = utf8_encode(str2);
      var strlen = str2.length * charsize;
      str2 = str2binb(str2);
      str2[strlen >> 5] |= 128 << 24 - strlen % 32;
      str2[(strlen + 128 >> 10 << 5) + 31] = strlen;
      for (var i2 = 0; i2 < str2.length; i2 += 32) {
        a = H[0];
        b = H[1];
        c2 = H[2];
        d = H[3];
        e = H[4];
        f = H[5];
        g = H[6];
        h = H[7];
        for (var j2 = 0; j2 < 80; j2++) {
          if (j2 < 16) {
            W[j2] = new int64(str2[j2 * 2 + i2], str2[j2 * 2 + i2 + 1]);
          } else {
            W[j2] = safe_add_4(gamma1(W[j2 - 2]), W[j2 - 7], gamma0(W[j2 - 15]), W[j2 - 16]);
          }
          T1 = safe_add_5(h, sigma1(e), ch(e, f, g), K[j2], W[j2]);
          T2 = safe_add_2(sigma0(a), maj(a, b, c2));
          h = g;
          g = f;
          f = e;
          e = safe_add_2(d, T1);
          d = c2;
          c2 = b;
          b = a;
          a = safe_add_2(T1, T2);
        }
        H[0] = safe_add_2(a, H[0]);
        H[1] = safe_add_2(b, H[1]);
        H[2] = safe_add_2(c2, H[2]);
        H[3] = safe_add_2(d, H[3]);
        H[4] = safe_add_2(e, H[4]);
        H[5] = safe_add_2(f, H[5]);
        H[6] = safe_add_2(g, H[6]);
        H[7] = safe_add_2(h, H[7]);
      }
      var binarray = [];
      for (var i2 = 0; i2 < H.length; i2++) {
        binarray.push(H[i2].highOrder);
        binarray.push(H[i2].lowOrder);
      }
      return binb2hex(binarray);
    };
    if (!jSuites2.login) {
      jSuites2.login = {};
      jSuites2.login.sha512 = jSuites2.sha512;
    }
    jSuites2.image = jSuites2.upload = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        type: "image",
        extension: "*",
        input: false,
        minWidth: false,
        maxWidth: null,
        maxHeight: null,
        maxJpegSizeBytes: null,
        onchange: null,
        multiple: false,
        remoteParser: null,
        text: {
          extensionNotAllowed: "The extension is not allowed"
        }
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      if (obj2.options.multiple == true) {
        el2.setAttribute("data-multiple", true);
      }
      el2.content = [];
      el2.classList.add("jupload");
      if (obj2.options.input == true) {
        el2.classList.add("input");
      }
      obj2.add = function(data) {
        if (obj2.options.multiple == false) {
          el2.content = [];
          el2.innerText = "";
        }
        if (obj2.options.type == "image") {
          var img = document.createElement("img");
          img.setAttribute("src", data.file);
          img.setAttribute("tabindex", -1);
          if (!el2.getAttribute("name")) {
            img.className = "jfile";
            img.content = data;
          }
          el2.appendChild(img);
        } else {
          if (data.name) {
            var name = data.name;
          } else {
            var name = data.file;
          }
          var div2 = document.createElement("div");
          div2.innerText = name || obj2.options.type;
          div2.classList.add("jupload-item");
          div2.setAttribute("tabindex", -1);
          el2.appendChild(div2);
        }
        if (data.content) {
          data.file = jSuites2.guid();
        }
        el2.content.push(data);
        if (typeof obj2.options.onchange == "function") {
          obj2.options.onchange(el2, data);
        }
      };
      obj2.addFromFile = function(file) {
        var type2 = file.type.split("/");
        if (type2[0] == obj2.options.type) {
          var readFile = new FileReader();
          readFile.addEventListener("load", function(v) {
            var data = {
              file: v.srcElement.result,
              extension: file.name.substr(file.name.lastIndexOf(".") + 1),
              name: file.name,
              size: file.size,
              lastmodified: file.lastModified,
              content: v.srcElement.result
            };
            obj2.add(data);
          });
          readFile.readAsDataURL(file);
        } else {
          alert(obj2.options.text.extensionNotAllowed);
        }
      };
      obj2.addFromUrl = function(src) {
        if (src.substr(0, 4) != "data" && !obj2.options.remoteParser) {
          console.error("remoteParser not defined in your initialization");
        } else {
          if (src.substr(0, 4) == "data") {
            var extension = src.split(";");
            extension = extension[0].split("/");
            var type2 = extension[0].replace("data:", "");
            if (type2 == obj2.options.type) {
              var data = {
                file: src,
                name: "",
                extension: extension[1],
                content: src
              };
              obj2.add(data);
            } else {
              alert(obj2.options.text.extensionNotAllowed);
            }
          } else {
            var extension = src.substr(src.lastIndexOf(".") + 1);
            src = obj2.options.remoteParser + src;
            jSuites2.ajax({
              url: src,
              type: "GET",
              dataType: "blob",
              success: function(data2) {
              }
            });
          }
        }
      };
      var mime = obj2.options.type + "/" + obj2.options.extension;
      var input = document.createElement("input");
      input.type = "file";
      input.setAttribute("accept", mime);
      input.onchange = function() {
        for (var i2 = 0; i2 < this.files.length; i2++) {
          obj2.addFromFile(this.files[i2]);
        }
      };
      if (obj2.options.multiple == true) {
        input.setAttribute("multiple", true);
      }
      var current = null;
      el2.addEventListener("click", function(e) {
        current = null;
        if (!el2.children.length || e.target === el2) {
          jSuites2.click(input);
        } else {
          if (e.target.parentNode == el2) {
            current = e.target;
          }
        }
      });
      el2.addEventListener("dblclick", function(e) {
        jSuites2.click(input);
      });
      el2.addEventListener("dragenter", function(e) {
        el2.style.border = "1px dashed #000";
      });
      el2.addEventListener("dragleave", function(e) {
        el2.style.border = "1px solid #eee";
      });
      el2.addEventListener("dragstop", function(e) {
        el2.style.border = "1px solid #eee";
      });
      el2.addEventListener("dragover", function(e) {
        e.preventDefault();
      });
      el2.addEventListener("keydown", function(e) {
        if (current && e.which == 46) {
          var index2 = Array.prototype.indexOf.call(el2.children, current);
          if (index2 >= 0) {
            el2.content.splice(index2, 1);
            current.remove();
            current = null;
          }
        }
      });
      el2.addEventListener("drop", function(e) {
        e.preventDefault();
        e.stopPropagation();
        var html2 = (e.originalEvent || e).dataTransfer.getData("text/html");
        var file = (e.originalEvent || e).dataTransfer.files;
        if (file.length) {
          for (var i2 = 0; i2 < e.dataTransfer.files.length; i2++) {
            obj2.addFromFile(e.dataTransfer.files[i2]);
          }
        } else if (html2) {
          if (obj2.options.multiple == false) {
            el2.innerText = "";
          }
          var div2 = document.createElement("div");
          div2.innerHTML = html2;
          var img = div2.querySelectorAll("img");
          if (img.length) {
            for (var i2 = 0; i2 < img.length; i2++) {
              obj2.addFromUrl(img[i2].src);
            }
          }
        }
        el2.style.border = "1px solid #eee";
        return false;
      });
      el2.val = function(val) {
        if (val === void 0) {
          return el2.content && el2.content.length ? el2.content : null;
        } else {
          el2.innerText = "";
          el2.content = [];
          if (val) {
            if (Array.isArray(val)) {
              for (var i2 = 0; i2 < val.length; i2++) {
                if (typeof val[i2] == "string") {
                  obj2.add({ file: val[i2] });
                } else {
                  obj2.add(val[i2]);
                }
              }
            } else if (typeof val == "string") {
              obj2.add({ file: val });
            }
          }
        }
      };
      el2.upload = el2.image = obj2;
      return obj2;
    };
    jSuites2.image.create = function(data) {
      var img = document.createElement("img");
      img.setAttribute("src", data.file);
      img.className = "jfile";
      img.setAttribute("tabindex", -1);
      img.content = data;
      return img;
    };
    jSuites2.lazyLoading = function(el2, options2) {
      var obj2 = {};
      if (!options2.loadUp || typeof options2.loadUp != "function") {
        options2.loadUp = function() {
          return false;
        };
      }
      if (!options2.loadDown || typeof options2.loadDown != "function") {
        options2.loadDown = function() {
          return false;
        };
      }
      if (!options2.timer) {
        options2.timer = 100;
      }
      var timeControlLoading = null;
      var scrollControls = function(e) {
        if (timeControlLoading == null) {
          var event2 = false;
          var scrollTop = el2.scrollTop;
          if (el2.scrollTop + el2.clientHeight * 2 >= el2.scrollHeight) {
            if (options2.loadDown()) {
              if (scrollTop == el2.scrollTop) {
                el2.scrollTop = el2.scrollTop - el2.clientHeight;
              }
              event2 = true;
            }
          } else if (el2.scrollTop <= el2.clientHeight) {
            if (options2.loadUp()) {
              if (scrollTop == el2.scrollTop) {
                el2.scrollTop = el2.scrollTop + el2.clientHeight;
              }
              event2 = true;
            }
          }
          timeControlLoading = setTimeout(function() {
            timeControlLoading = null;
          }, options2.timer);
          if (event2) {
            if (typeof options2.onupdate == "function") {
              options2.onupdate();
            }
          }
        }
      };
      el2.onscroll = function(e) {
        scrollControls();
      };
      el2.onwheel = function(e) {
        scrollControls();
      };
      return obj2;
    };
    jSuites2.loading = function() {
      var obj2 = {};
      var loading = null;
      obj2.show = function() {
        if (!loading) {
          loading = document.createElement("div");
          loading.className = "jloading";
        }
        document.body.appendChild(loading);
      };
      obj2.hide = function() {
        if (loading && loading.parentNode) {
          document.body.removeChild(loading);
        }
      };
      return obj2;
    }();
    jSuites2.mask = function() {
      var tokens2 = {
        currency: ["#(.{1})##0?(.{1}0+)?( ?;(.*)?)?", "#"],
        percentage: ["0{1}(.{1}0+)?%"],
        numeric: ["0{1}(.{1}0+)?"],
        datetime: ["YYYY", "YYY", "YY", "MMMMM", "MMMM", "MMM", "MM", "DDDDD", "DDDD", "DDD", "DD", "DY", "DAY", "WD", "D", "Q", "HH24", "HH12", "HH", "\\[H\\]", "H", "AM/PM", "PM", "AM", "MI", "SS", "MS", "MONTH", "MON", "Y", "M"],
        general: ["A", "0", "[0-9a-zA-Z$]+", "."]
      };
      var getDate = function() {
        if (this.mask.toLowerCase().indexOf("[h]") !== -1) {
          var m = 0;
          if (this.date[4]) {
            m = parseFloat(this.date[4] / 60);
          }
          var v = parseInt(this.date[3]) + m;
          v /= 24;
        } else if (!(this.date[0] && this.date[1] && this.date[2]) && (this.date[3] || this.date[4])) {
          v = jSuites2.two(this.date[3]) + ":" + jSuites2.two(this.date[4]) + ":" + jSuites2.two(this.date[5]);
        } else {
          if (this.date[0] && this.date[1] && !this.date[2]) {
            this.date[2] = 1;
          }
          v = jSuites2.two(this.date[0]) + "-" + jSuites2.two(this.date[1]) + "-" + jSuites2.two(this.date[2]);
          if (this.date[3] || this.date[4] || this.date[5]) {
            v += " " + jSuites2.two(this.date[3]) + ":" + jSuites2.two(this.date[4]) + ":" + jSuites2.two(this.date[5]);
          }
        }
        return v;
      };
      var isBlank2 = function(v) {
        return v === null || v === "" || v === void 0 ? true : false;
      };
      var isFormula2 = function(value2) {
        return ("" + value2).chartAt(0) == "=";
      };
      var isNumeric = function(t) {
        return t === "currency" || t === "percentage" || t === "numeric" ? true : false;
      };
      var getDecimal = function(v) {
        if (v && Number(v) == v) {
          return ".";
        } else {
          if (this.options.decimal) {
            return this.options.decimal;
          } else {
            if (this.locale) {
              var t = Intl.NumberFormat(this.locale).format(1.1);
              return this.options.decimal = t[1];
            } else {
              if (!v) {
                v = this.mask;
              }
              var e = new RegExp("0{1}(.{1})0+", "ig");
              var t = e.exec(v);
              if (t && t[1] && t[1].length == 1) {
                this.options.decimal = t[1];
                return t[1];
              } else {
                var e = new RegExp("#{1}(.{1})#+", "ig");
                var t = e.exec(v);
                if (t && t[1] && t[1].length == 1) {
                  if (t[1] === ",") {
                    this.options.decimal = ".";
                  } else {
                    this.options.decimal = ",";
                  }
                } else {
                  this.options.decimal = "1.1".toLocaleString().substring(1, 2);
                }
              }
            }
          }
        }
        if (this.options.decimal) {
          return this.options.decimal;
        } else {
          return null;
        }
      };
      var ParseValue = function(v, decimal) {
        if (v == "") {
          return "";
        }
        if (!decimal) {
          decimal = getDecimal.call(this);
        }
        v = ("" + v).split(decimal);
        v[0] = v[0].match(/[\-0-9]+/g, "");
        if (v[0]) {
          v[0] = v[0].join("");
        }
        if (v[0] || v[1]) {
          if (v[1] !== void 0) {
            v[1] = v[1].match(/[0-9]+/g, "");
            if (v[1]) {
              v[1] = v[1].join("");
            } else {
              v[1] = "";
            }
          }
        } else {
          return "";
        }
        return v;
      };
      var FormatValue = function(v) {
        if (v == "") {
          return "";
        }
        var d = getDecimal.call(this);
        var o = this.options;
        v = ParseValue.call(this, v);
        if (v == "") {
          return "";
        }
        if (v[0] === "-") {
          v[0] = "-0";
        }
        if (v[0]) {
          var t = parseFloat(v[0]);
          if (o.style == "percent") {
            t /= 100;
          }
        } else {
          var t = null;
        }
        var n2 = new Intl.NumberFormat(this.locale, o).format(t);
        n2 = n2.split(d);
        if (typeof n2[1] !== "undefined") {
          var s = n2[1].replace(/[0-9]*/g, "");
          if (s) {
            n2[2] = s;
          }
        }
        if (v[1] !== void 0) {
          n2[1] = d + v[1];
        } else {
          n2[1] = "";
        }
        return n2.join("");
      };
      var Format = function(e) {
        var v = Value.call(e);
        if (!v) {
          return;
        }
        getDecimal.call(this);
        var n2 = FormatValue.call(this, v);
        var t = n2.length - v.length;
        var index2 = Caret.call(e) + t;
        Value.call(e, n2, index2, true);
      };
      var Extract = function(v) {
        var current = ParseValue.call(this, v);
        if (current) {
          if (current[0] === "-") {
            current[0] = "-0";
          }
          return parseFloat(current.join("."));
        }
        return null;
      };
      var Caret = function(index2, adjustNumeric) {
        if (index2 === void 0) {
          if (this.tagName == "DIV") {
            var pos = 0;
            var s = window.getSelection();
            if (s) {
              if (s.rangeCount !== 0) {
                var r = s.getRangeAt(0);
                var p2 = r.cloneRange();
                p2.selectNodeContents(this);
                p2.setEnd(r.endContainer, r.endOffset);
                pos = p2.toString().length;
              }
            }
            return pos;
          } else {
            return this.selectionStart;
          }
        } else {
          var n2 = Value.call(this);
          if (adjustNumeric) {
            var p2 = null;
            for (var i2 = 0; i2 < n2.length; i2++) {
              if (n2[i2].match(/[\-0-9]/g) || n2[i2] == "." || n2[i2] == ",") {
                p2 = i2;
              }
            }
            if (p2 === null) {
              p2 = n2.indexOf(" ");
            }
            if (index2 >= p2) {
              index2 = p2 + 1;
            }
          }
          if (index2 > n2.length) {
            index2 = n2.length;
          }
          if (index2) {
            if (this.tagName == "DIV") {
              var s = window.getSelection();
              var r = document.createRange();
              r.setStart(this.childNodes[0], index2);
              s.removeAllRanges();
              s.addRange(r);
            } else {
              this.selectionStart = index2;
              this.selectionEnd = index2;
            }
          }
        }
      };
      var Value = function(v, updateCaret, adjustNumeric) {
        if (this.tagName == "DIV") {
          if (v === void 0) {
            return this.innerText;
          } else {
            if (this.innerText !== v) {
              this.innerText = v;
              if (updateCaret) {
                Caret.call(this, updateCaret, adjustNumeric);
              }
            }
          }
        } else {
          if (v === void 0) {
            return this.value;
          } else {
            if (this.value !== v) {
              this.value = v;
              if (updateCaret) {
                Caret.call(this, updateCaret, adjustNumeric);
              }
            }
          }
        }
      };
      var weekDaysFull = jSuites2.calendar.weekdays;
      var weekDays = jSuites2.calendar.weekdaysShort;
      var monthsFull = jSuites2.calendar.months;
      var months = jSuites2.calendar.monthsShort;
      var parser2 = {
        "YEAR": function(v, s) {
          var y2 = "" + new Date().getFullYear();
          if (typeof this.values[this.index] === "undefined") {
            this.values[this.index] = "";
          }
          if (parseInt(v) >= 0 && parseInt(v) <= 10) {
            if (this.values[this.index].length < s) {
              this.values[this.index] += v;
            }
          }
          if (this.values[this.index].length == s) {
            if (s == 2) {
              var y2 = y2.substr(0, 2) + this.values[this.index];
            } else if (s == 3) {
              var y2 = y2.substr(0, 1) + this.values[this.index];
            } else if (s == 4) {
              var y2 = this.values[this.index];
            }
            this.date[0] = y2;
            this.index++;
          }
        },
        "YYYY": function(v) {
          parser2.YEAR.call(this, v, 4);
        },
        "YYY": function(v) {
          parser2.YEAR.call(this, v, 3);
        },
        "YY": function(v) {
          parser2.YEAR.call(this, v, 2);
        },
        "FIND": function(v, a) {
          if (isBlank2(this.values[this.index])) {
            this.values[this.index] = "";
          }
          var pos = 0;
          var count = 0;
          var value2 = (this.values[this.index] + v).toLowerCase();
          for (var i2 = 0; i2 < a.length; i2++) {
            if (a[i2].toLowerCase().indexOf(value2) == 0) {
              pos = i2;
              count++;
            }
          }
          if (count > 1) {
            this.values[this.index] += v;
          } else if (count == 1) {
            var t = a[pos].length - this.values[this.index].length - 1;
            this.position += t;
            this.values[this.index] = a[pos];
            this.index++;
            return pos;
          }
        },
        "MMM": function(v) {
          var ret = parser2.FIND.call(this, v, months);
          if (ret !== void 0) {
            this.date[1] = ret + 1;
          }
        },
        "MMMM": function(v) {
          var ret = parser2.FIND.call(this, v, monthsFull);
          if (ret !== void 0) {
            this.date[1] = ret + 1;
          }
        },
        "MMMMM": function(v) {
          if (isBlank2(this.values[this.index])) {
            this.values[this.index] = "";
          }
          var value2 = (this.values[this.index] + v).toLowerCase();
          for (var i2 = 0; i2 < monthsFull.length; i2++) {
            if (monthsFull[i2][0].toLowerCase().indexOf(value2) == 0) {
              this.values[this.index] = monthsFull[i2][0];
              this.date[1] = i2 + 1;
              this.index++;
              break;
            }
          }
        },
        "MM": function(v) {
          if (isBlank2(this.values[this.index])) {
            if (parseInt(v) > 1 && parseInt(v) < 10) {
              this.date[1] = this.values[this.index] = "0" + v;
              this.index++;
            } else if (parseInt(v) < 2) {
              this.values[this.index] = v;
            }
          } else {
            if (this.values[this.index] == 1 && parseInt(v) < 3) {
              this.date[1] = this.values[this.index] += v;
              this.index++;
            } else if (this.values[this.index] == 0 && parseInt(v) > 0 && parseInt(v) < 10) {
              this.date[1] = this.values[this.index] += v;
              this.index++;
            }
          }
        },
        "M": function(v) {
          var test = false;
          if (parseInt(v) >= 0 && parseInt(v) < 10) {
            if (isBlank2(this.values[this.index])) {
              this.values[this.index] = v;
              if (v > 1) {
                this.date[1] = this.values[this.index];
                this.index++;
              }
            } else {
              if (this.values[this.index] == 1 && parseInt(v) < 3) {
                this.date[1] = this.values[this.index] += v;
                this.index++;
              } else if (this.values[this.index] == 0 && parseInt(v) > 0) {
                this.date[1] = this.values[this.index] += v;
                this.index++;
              } else {
                var test = true;
              }
            }
          } else {
            var test = true;
          }
          if (test == true) {
            var t = parseInt(this.values[this.index]);
            if (t > 0 && t < 12) {
              this.date[2] = this.values[this.index];
              this.index++;
              this.position--;
            }
          }
        },
        "D": function(v) {
          var test = false;
          if (parseInt(v) >= 0 && parseInt(v) < 10) {
            if (isBlank2(this.values[this.index])) {
              this.values[this.index] = v;
              if (parseInt(v) > 3) {
                this.date[2] = this.values[this.index];
                this.index++;
              }
            } else {
              if (this.values[this.index] == 3 && parseInt(v) < 2) {
                this.date[2] = this.values[this.index] += v;
                this.index++;
              } else if (this.values[this.index] == 1 || this.values[this.index] == 2) {
                this.date[2] = this.values[this.index] += v;
                this.index++;
              } else if (this.values[this.index] == 0 && parseInt(v) > 0) {
                this.date[2] = this.values[this.index] += v;
                this.index++;
              } else {
                var test = true;
              }
            }
          } else {
            var test = true;
          }
          if (test == true) {
            var t = parseInt(this.values[this.index]);
            if (t > 0 && t < 32) {
              this.date[2] = this.values[this.index];
              this.index++;
              this.position--;
            }
          }
        },
        "DD": function(v) {
          if (isBlank2(this.values[this.index])) {
            if (parseInt(v) > 3 && parseInt(v) < 10) {
              this.date[2] = this.values[this.index] = "0" + v;
              this.index++;
            } else if (parseInt(v) < 10) {
              this.values[this.index] = v;
            }
          } else {
            if (this.values[this.index] == 3 && parseInt(v) < 2) {
              this.date[2] = this.values[this.index] += v;
              this.index++;
            } else if ((this.values[this.index] == 1 || this.values[this.index] == 2) && parseInt(v) < 10) {
              this.date[2] = this.values[this.index] += v;
              this.index++;
            } else if (this.values[this.index] == 0 && parseInt(v) > 0 && parseInt(v) < 10) {
              this.date[2] = this.values[this.index] += v;
              this.index++;
            }
          }
        },
        "DDD": function(v) {
          parser2.FIND.call(this, v, weekDays);
        },
        "DDDD": function(v) {
          parser2.FIND.call(this, v, weekDaysFull);
        },
        "HH12": function(v, two) {
          if (isBlank2(this.values[this.index])) {
            if (parseInt(v) > 1 && parseInt(v) < 10) {
              if (two) {
                v = 0 + v;
              }
              this.date[3] = this.values[this.index] = v;
              this.index++;
            } else if (parseInt(v) < 10) {
              this.values[this.index] = v;
            }
          } else {
            if (this.values[this.index] == 1 && parseInt(v) < 3) {
              this.date[3] = this.values[this.index] += v;
              this.index++;
            } else if (this.values[this.index] < 1 && parseInt(v) < 10) {
              this.date[3] = this.values[this.index] += v;
              this.index++;
            }
          }
        },
        "HH24": function(v, two) {
          if (parseInt(v) >= 0 && parseInt(v) < 10) {
            if (this.values[this.index] == null || this.values[this.index] == "") {
              if (parseInt(v) > 2 && parseInt(v) < 10) {
                if (two) {
                  v = 0 + v;
                }
                this.date[3] = this.values[this.index] = v;
                this.index++;
              } else if (parseInt(v) < 10) {
                this.values[this.index] = v;
              }
            } else {
              if (this.values[this.index] == 2 && parseInt(v) < 4) {
                this.date[3] = this.values[this.index] += v;
                this.index++;
              } else if (this.values[this.index] < 2 && parseInt(v) < 10) {
                this.date[3] = this.values[this.index] += v;
                this.index++;
              }
            }
          }
        },
        "HH": function(v) {
          parser2["HH24"].call(this, v, 1);
        },
        "H": function(v) {
          parser2["HH24"].call(this, v, 0);
        },
        "\\[H\\]": function(v) {
          if (this.values[this.index] == void 0) {
            this.values[this.index] = "";
          }
          if (v.match(/[0-9]/g)) {
            this.date[3] = this.values[this.index] += v;
          } else {
            if (this.values[this.index].match(/[0-9]/g)) {
              this.date[3] = this.values[this.index];
              this.index++;
              this.position--;
            }
          }
        },
        "N60": function(v, i2) {
          if (this.values[this.index] == null || this.values[this.index] == "") {
            if (parseInt(v) > 5 && parseInt(v) < 10) {
              this.date[i2] = this.values[this.index] = "0" + v;
              this.index++;
            } else if (parseInt(v) < 10) {
              this.values[this.index] = v;
            }
          } else {
            if (parseInt(v) < 10) {
              this.date[i2] = this.values[this.index] += v;
              this.index++;
            }
          }
        },
        "MI": function(v) {
          parser2.N60.call(this, v, 4);
        },
        "SS": function(v) {
          parser2.N60.call(this, v, 5);
        },
        "AM/PM": function(v) {
          this.values[this.index] = "";
          if (v) {
            if (this.date[3] > 12) {
              this.values[this.index] = "PM";
            } else {
              this.values[this.index] = "AM";
            }
          }
          this.index++;
        },
        "WD": function(v) {
          if (typeof this.values[this.index] === "undefined") {
            this.values[this.index] = "";
          }
          if (parseInt(v) >= 0 && parseInt(v) < 7) {
            this.values[this.index] = v;
          }
          if (this.value[this.index].length == 1) {
            this.index++;
          }
        },
        "0{1}(.{1}0+)?": function(v) {
          var decimal = getDecimal.call(this);
          var neg = false;
          if (isBlank2(this.values[this.index])) {
            this.values[this.index] = "";
          } else {
            if (this.values[this.index] == "-") {
              neg = true;
            }
          }
          var current = ParseValue.call(this, this.values[this.index], decimal);
          if (current) {
            this.values[this.index] = current.join(decimal);
          }
          if (parseInt(v) >= 0 && parseInt(v) < 10) {
            if (this.values[this.index] != "0" || v == decimal) {
              this.values[this.index] += v;
            }
          } else if (decimal && v == decimal) {
            if (this.values[this.index].indexOf(decimal) == -1) {
              if (!this.values[this.index]) {
                this.values[this.index] = "0";
              }
              this.values[this.index] += v;
            }
          } else if (v == "-") {
            neg = true;
          }
          if (neg === true && this.values[this.index][0] !== "-") {
            this.values[this.index] = "-" + this.values[this.index];
          }
        },
        "0{1}(.{1}0+)?%": function(v) {
          parser2["0{1}(.{1}0+)?"].call(this, v);
          if (this.values[this.index].match(/[\-0-9]/g)) {
            if (this.values[this.index] && this.values[this.index].indexOf("%") == -1) {
              this.values[this.index] += "%";
            }
          } else {
            this.values[this.index] = "";
          }
        },
        "#(.{1})##0?(.{1}0+)?( ?;(.*)?)?": function(v) {
          parser2["0{1}(.{1}0+)?"].call(this, v);
          var decimal = getDecimal.call(this);
          var separator = this.tokens[this.index].substr(1, 1);
          var negative = this.values[this.index][0] === "-" ? true : false;
          var current = ParseValue.call(this, this.values[this.index], decimal);
          if (current !== "") {
            var n2 = current[0].match(/[0-9]/g);
            if (n2) {
              n2 = n2.join("");
              var t = [];
              var s = 0;
              for (var j2 = n2.length - 1; j2 >= 0; j2--) {
                t.push(n2[j2]);
                s++;
                if (!(s % 3)) {
                  t.push(separator);
                }
              }
              t = t.reverse();
              current[0] = t.join("");
              if (current[0].substr(0, 1) == separator) {
                current[0] = current[0].substr(1);
              }
            } else {
              current[0] = "";
            }
            this.values[this.index] = current.join(decimal);
            if (negative) {
              this.values[this.index] = "-" + this.values[this.index];
            }
          }
        },
        "0": function(v) {
          if (v.match(/[0-9]/g)) {
            this.values[this.index] = v;
            this.index++;
          }
        },
        "[0-9a-zA-Z$]+": function(v) {
          if (isBlank2(this.values[this.index])) {
            this.values[this.index] = "";
          }
          var t = this.tokens[this.index];
          var s = this.values[this.index];
          var i2 = s.length;
          if (t[i2] == v) {
            this.values[this.index] += v;
            if (this.values[this.index] == t) {
              this.index++;
            }
          } else {
            this.values[this.index] = t;
            this.index++;
            if (v.match(/[\-0-9]/g)) {
              this.position--;
            }
          }
        },
        "A": function(v) {
          if (v.match(/[a-zA-Z]/gi)) {
            this.values[this.index] = v;
            this.index++;
          }
        },
        ".": function(v) {
          parser2["[0-9a-zA-Z$]+"].call(this, v);
        }
      };
      var getTokens = function(str2) {
        if (this.type == "general") {
          var t = [].concat(tokens2.general);
        } else {
          var t = [].concat(tokens2.currency, tokens2.datetime, tokens2.percentage, tokens2.numeric, tokens2.general);
        }
        var e = new RegExp(t.join("|"), "gi");
        return str2.match(e);
      };
      var getMethod = function(str2) {
        if (!this.type) {
          var types = Object.keys(tokens2);
        } else if (this.type == "general") {
          var types = ["general"];
        } else if (this.type == "datetime") {
          var types = ["numeric", "datetime", "general"];
        } else {
          var types = ["currency", "percentage", "numeric", "general"];
        }
        for (var i2 = 0; i2 < types.length; i2++) {
          var type2 = types[i2];
          for (var j2 = 0; j2 < tokens2[type2].length; j2++) {
            var e = new RegExp(tokens2[type2][j2], "gi");
            var r = str2.match(e);
            if (r) {
              return { type: type2, method: tokens2[type2][j2] };
            }
          }
        }
      };
      var getMethods = function(t) {
        var result2 = [];
        for (var i2 = 0; i2 < t.length; i2++) {
          var m = getMethod.call(this, t[i2]);
          if (m) {
            result2.push(m.method);
          } else {
            result2.push(null);
          }
        }
        for (var i2 = 0; i2 < result2.length; i2++) {
          if (result2[i2] == "MM") {
            if (result2[i2 - 1] && result2[i2 - 1].indexOf("H") >= 0) {
              result2[i2] = "MI";
            } else if (result2[i2 - 2] && result2[i2 - 2].indexOf("H") >= 0) {
              result2[i2] = "MI";
            } else if (result2[i2 + 1] && result2[i2 + 1].indexOf("S") >= 0) {
              result2[i2] = "MI";
            } else if (result2[i2 + 2] && result2[i2 + 2].indexOf("S") >= 0) {
              result2[i2] = "MI";
            }
          }
        }
        return result2;
      };
      var getType = function(str2) {
        var m = getMethod.call(this, str2);
        if (m) {
          var type2 = m.type;
        }
        if (type2) {
          var numeric = 0;
          var t = getTokens.call(this, str2);
          for (var i2 = 0; i2 < t.length; i2++) {
            m = getMethod.call(this, t[i2]);
            if (m && isNumeric(m.type)) {
              numeric++;
            }
          }
          if (numeric > 1) {
            type2 = "general";
          }
        }
        return type2;
      };
      var parse22 = function() {
        if (typeof parser2[this.methods[this.index]] == "function") {
          parser2[this.methods[this.index]].call(this, this.value[this.position]);
          this.position++;
        } else {
          this.values[this.index] = this.tokens[this.index];
          this.index++;
        }
      };
      var isFormula2 = function(value2) {
        var v = ("" + value2)[0];
        return v == "=" ? true : false;
      };
      var toPlainString = function(num) {
        return ("" + +num).replace(/(-?)(\d*)\.?(\d*)e([+-]\d+)/, function(a, b, c2, d, e) {
          return e < 0 ? b + "0." + Array(1 - e - c2.length).join(0) + c2 + d : b + c2 + d + Array(e - d.length + 1).join(0);
        });
      };
      var obj2 = function(e, config2, returnObject) {
        var t = null;
        var o = {
          input: null,
          value: null,
          options: {},
          values: [],
          index: 0,
          position: 0,
          date: [0, 0, 0, 0, 0, 0],
          number: 0
        };
        if (typeof e == "object") {
          o.input = e.target;
          o.value = Value.call(e.target);
          o.caret = Caret.call(e.target);
          if (t = e.target.getAttribute("data-mask")) {
            o.mask = t;
          }
          if (t = e.target.getAttribute("data-type")) {
            o.type = t;
          }
          if (e.target.mask) {
            if (e.target.mask.options) {
              o.options = e.target.mask.options;
            }
            if (e.target.mask.locale) {
              o.locale = e.target.mask.locale;
            }
          } else {
            if (t = e.target.getAttribute("data-locale")) {
              o.locale = t;
              if (o.mask) {
                o.options.style = o.mask;
              }
            }
          }
          if (e.target.attributes && e.target.attributes.length) {
            for (var i2 = 0; i2 < e.target.attributes.length; i2++) {
              var k2 = e.target.attributes[i2].name;
              var v = e.target.attributes[i2].value;
              if (k2.substr(0, 4) == "data") {
                o.options[k2.substr(5)] = v;
              }
            }
          }
        } else {
          if (typeof config2 == "string") {
            o.mask = config2;
          } else {
            var k2 = Object.keys(config2);
            for (var i2 = 0; i2 < k2.length; i2++) {
              o[k2[i2]] = config2[k2[i2]];
            }
          }
          if (typeof e === "number") {
            getDecimal.call(o, o.mask);
            e = ("" + e).replace(".", o.options.decimal);
          }
          o.value = e;
          if (o.input) {
            Value.call(o.input, e);
            jSuites2.focus(o.input);
            o.caret = Caret.call(o.input);
          }
        }
        if (!isFormula2(o.value) && (o.mask || o.locale)) {
          if (o.mask) {
            o.mask = o.mask.replace("[-]", "");
            if (o.mask.indexOf("##") !== -1) {
              var d = o.mask.split(";");
              if (d[0]) {
                d[0] = d[0].replace("*", "");
                d[0] = d[0].replace(/_/g, "");
                d[0] = d[0].replace(/-/g, "");
                d[0] = d[0].replace("(", "");
                d[0] = d[0].replace(")", "");
                d[0] = d[0].replace("##0.###", "##0.000");
                d[0] = d[0].replace("##0.##", "##0.00");
                d[0] = d[0].replace("##0.#", "##0.0");
              }
              o.mask = d[0];
            }
            if (!o.type) {
              o.type = getType.call(o, o.mask);
            }
            o.tokens = getTokens.call(o, o.mask);
          }
          if (typeof e !== "object" || !e.inputType || !e.inputType.indexOf("insert") || !e.inputType.indexOf("delete")) {
            if (o.locale) {
              if (o.input) {
                Format.call(o, o.input);
              } else {
                var newValue = FormatValue.call(o, o.value);
              }
            } else {
              o.methods = getMethods.call(o, o.tokens);
              while (o.position < o.value.length && typeof o.tokens[o.index] !== "undefined") {
                parse22.call(o);
              }
              if (isNumeric(o.type)) {
                while (typeof o.tokens[o.index] !== "undefined") {
                  var t = getMethod.call(o, o.tokens[o.index]);
                  if (t && t.type == "general") {
                    o.values[o.index] = o.tokens[o.index];
                  }
                  o.index++;
                }
                var adjustNumeric = true;
              } else {
                var adjustNumeric = false;
              }
              var newValue = o.values.join("");
              if (o.input) {
                t = newValue.length - o.value.length;
                if (t > 0) {
                  var caret = o.caret + t;
                } else {
                  var caret = o.caret;
                }
                Value.call(o.input, newValue, caret, adjustNumeric);
              }
            }
          }
          if (o.input) {
            var label = null;
            if (isNumeric(o.type)) {
              o.number = Extract.call(o, Value.call(o.input));
              if (o.type == "percentage") {
                label = o.number / 100;
              } else {
                label = o.number;
              }
            } else if (o.type == "datetime") {
              label = getDate.call(o);
              if (o.date[0] && o.date[1] && o.date[2]) {
                o.input.setAttribute("data-completed", true);
              }
            }
            if (label) {
              o.input.setAttribute("data-value", label);
            }
          }
          if (newValue !== void 0) {
            if (returnObject) {
              return o;
            } else {
              return newValue;
            }
          }
        }
      };
      obj2.prepare = function(str2, o) {
        if (!o) {
          o = {};
        }
        return getTokens.call(o, str2);
      };
      obj2.apply = function(e) {
        var v = Value.call(e.target);
        if (e.key.length == 1) {
          v += e.key;
        }
        Value.call(e.target, obj2(v, e.target.getAttribute("data-mask")));
      };
      obj2.run = function(value2, mask, decimal) {
        return obj2(value2, { mask, decimal });
      };
      obj2.extract = function(v, options2, returnObject) {
        if (isBlank2(v)) {
          return v;
        }
        if (typeof options2 != "object") {
          return value2;
        } else {
          if (!options2.options) {
            options2.options = {};
          }
        }
        if (!options2.mask && options2.format) {
          options2.mask = options2.format;
        }
        getDecimal.call(options2, options2.mask);
        var type2 = null;
        if (options2.type == "percent" || options2.options.style == "percent") {
          type2 = "percentage";
        } else if (options2.mask) {
          type2 = getType.call(options2, options2.mask);
        }
        if (type2 === "datetime") {
          if (v instanceof Date) {
            var t = jSuites2.calendar.getDateString(value2, options2.mask);
          }
          var o = obj2(v, options2, true);
          var value2 = getDate.call(o);
          if (o.date[0] && o.date[1] && o.date[2] && !(o.date[3] || o.date[4] || o.date[5])) {
            var t = jSuites2.calendar.now(o.date);
            value2 = jSuites2.calendar.dateToNum(t);
          }
        } else {
          var value2 = Extract.call(options2, v);
          if (type2 == "percentage") {
            value2 /= 100;
          }
          var o = options2;
        }
        o.value = value2;
        if (returnObject) {
          return o;
        } else {
          return value2;
        }
      };
      obj2.render = function(value2, options2, fullMask) {
        if (isBlank2(value2)) {
          return value2;
        }
        if (typeof options2 != "object") {
          return value2;
        } else {
          if (!options2.options) {
            options2.options = {};
          }
        }
        if (!options2.mask && options2.format) {
          options2.mask = options2.format;
        }
        var type2 = null;
        if (options2.type == "percent" || options2.options.style == "percent") {
          type2 = "percentage";
        } else if (options2.mask) {
          type2 = getType.call(options2, options2.mask);
        } else if (value2 instanceof Date) {
          type2 = "datetime";
        }
        var fillWithBlanks = false;
        if (type2 == "datetime" || options2.type == "calendar") {
          var t = jSuites2.calendar.getDateString(value2, options2.mask);
          if (t) {
            value2 = t;
          }
          if (options2.mask && fullMask) {
            fillWithBlanks = true;
          }
        } else {
          if (type2 == "percentage") {
            value2 *= 100;
          }
          if (typeof value2 === "number") {
            var t = null;
            if (options2.mask && fullMask) {
              var e = new RegExp("0{1}(.{1})0+", "ig");
              var d = options2.mask.match(e);
              if (d && d[0]) {
                d = d[0].length - 2;
                t = value2.toFixed(d);
              } else {
                t = value2.toFixed(0);
              }
            } else if (options2.locale && fullMask) {
              var d = ("" + value2).split(".");
              if (options2.options) {
                if (typeof d[1] === "undefined") {
                  d[1] = "";
                }
                var len = d[1].length;
                if (options2.options.minimumFractionDigits > len) {
                  for (var i2 = 0; i2 < options2.options.minimumFractionDigits - len; i2++) {
                    d[1] += "0";
                  }
                }
              }
              if (!d[1].length) {
                t = d[0];
              } else {
                t = d.join(".");
              }
              var len = d[1].length;
              if (options2.options && options2.options.maximumFractionDigits < len) {
                t = parseFloat(t).toFixed(options2.options.maximumFractionDigits);
              }
            } else {
              t = toPlainString(value2);
            }
            if (t !== null) {
              value2 = t;
              getDecimal.call(options2, options2.mask);
              if (options2.options.decimal) {
                value2 = value2.replace(".", options2.options.decimal);
              }
            }
          } else {
            if (options2.mask && fullMask) {
              fillWithBlanks = true;
            }
          }
        }
        if (fillWithBlanks) {
          var s = options2.mask.length - value2.length;
          if (s > 0) {
            for (var i2 = 0; i2 < s; i2++) {
              value2 += " ";
            }
          }
        }
        value2 = obj2(value2, options2);
        return value2;
      };
      obj2.set = function(e, m) {
        if (m) {
          e.setAttribute("data-mask", m);
          var event2 = new Event("input", {
            bubbles: true,
            cancelable: true
          });
          e.dispatchEvent(event2);
        }
      };
      if (typeof document !== "undefined") {
        document.addEventListener("input", function(e) {
          if (e.target.getAttribute("data-mask") || e.target.mask) {
            obj2(e);
          }
        });
      }
      return obj2;
    }();
    jSuites2.modal = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        url: null,
        onopen: null,
        onclose: null,
        closed: false,
        width: null,
        height: null,
        title: null,
        padding: null,
        backdrop: true
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      if (!obj2.options.title && el2.getAttribute("title")) {
        obj2.options.title = el2.getAttribute("title");
      }
      var temp = document.createElement("div");
      while (el2.children[0]) {
        temp.appendChild(el2.children[0]);
      }
      obj2.content = document.createElement("div");
      obj2.content.className = "jmodal_content";
      obj2.content.innerHTML = el2.innerHTML;
      while (temp.children[0]) {
        obj2.content.appendChild(temp.children[0]);
      }
      obj2.container = document.createElement("div");
      obj2.container.className = "jmodal";
      obj2.container.appendChild(obj2.content);
      if (obj2.options.padding) {
        obj2.content.style.padding = obj2.options.padding;
      }
      if (obj2.options.width) {
        obj2.container.style.width = obj2.options.width;
      }
      if (obj2.options.height) {
        obj2.container.style.height = obj2.options.height;
      }
      if (obj2.options.title) {
        obj2.container.setAttribute("title", obj2.options.title);
      } else {
        obj2.container.classList.add("no-title");
      }
      el2.innerHTML = "";
      el2.style.display = "none";
      el2.appendChild(obj2.container);
      if (obj2.options.backdrop) {
        var backdrop = document.createElement("div");
        backdrop.className = "jmodal_backdrop";
        backdrop.onclick = function() {
          obj2.close();
        };
        el2.appendChild(backdrop);
      }
      obj2.open = function() {
        el2.style.display = "block";
        var rect = obj2.container.getBoundingClientRect();
        if (jSuites2.getWindowWidth() < rect.width) {
          obj2.container.style.top = "";
          obj2.container.style.left = "";
          obj2.container.classList.add("jmodal_fullscreen");
          jSuites2.animation.slideBottom(obj2.container, 1);
        } else {
          if (obj2.options.backdrop) {
            backdrop.style.display = "block";
          }
        }
        if (typeof obj2.options.onopen == "function") {
          obj2.options.onopen(el2, obj2);
        }
      };
      obj2.resetPosition = function() {
        obj2.container.style.top = "";
        obj2.container.style.left = "";
      };
      obj2.isOpen = function() {
        return el2.style.display != "none" ? true : false;
      };
      obj2.close = function() {
        if (obj2.isOpen()) {
          el2.style.display = "none";
          if (obj2.options.backdrop) {
            backdrop.style.display = "";
          }
          obj2.container.classList.remove("jmodal_fullscreen");
          if (typeof obj2.options.onclose == "function") {
            obj2.options.onclose(el2, obj2);
          }
        }
      };
      if (!jSuites2.modal.hasEvents) {
        var tracker = null;
        document.addEventListener("keydown", function(e) {
          if (e.which == 27) {
            var modals = document.querySelectorAll(".jmodal");
            for (var i2 = 0; i2 < modals.length; i2++) {
              modals[i2].parentNode.modal.close();
            }
          }
        });
        document.addEventListener("mouseup", function(e) {
          if (tracker) {
            tracker.element.style.cursor = "auto";
            tracker = null;
          }
        });
        document.addEventListener("mousedown", function(e) {
          var item = jSuites2.findElement(e.target, "jmodal");
          if (item) {
            var rect = item.getBoundingClientRect();
            if (e.changedTouches && e.changedTouches[0]) {
              var x2 = e.changedTouches[0].clientX;
              var y2 = e.changedTouches[0].clientY;
            } else {
              var x2 = e.clientX;
              var y2 = e.clientY;
            }
            if (rect.width - (x2 - rect.left) < 50 && y2 - rect.top < 50) {
              item.parentNode.modal.close();
            } else {
              if (e.target.getAttribute("title") && y2 - rect.top < 50) {
                if (document.selection) {
                  document.selection.empty();
                } else if (window.getSelection) {
                  window.getSelection().removeAllRanges();
                }
                tracker = {
                  left: rect.left,
                  top: rect.top,
                  x: e.clientX,
                  y: e.clientY,
                  width: rect.width,
                  height: rect.height,
                  element: item
                };
              }
            }
          }
        });
        document.addEventListener("mousemove", function(e) {
          if (tracker) {
            e = e || window.event;
            if (e.buttons) {
              var mouseButton = e.buttons;
            } else if (e.button) {
              var mouseButton = e.button;
            } else {
              var mouseButton = e.which;
            }
            if (mouseButton) {
              tracker.element.style.top = tracker.top + (e.clientY - tracker.y) + tracker.height / 2 + "px";
              tracker.element.style.left = tracker.left + (e.clientX - tracker.x) + tracker.width / 2 + "px";
              tracker.element.style.cursor = "move";
            } else {
              tracker.element.style.cursor = "auto";
            }
          }
        });
        jSuites2.modal.hasEvents = true;
      }
      if (obj2.options.url) {
        jSuites2.ajax({
          url: obj2.options.url,
          method: "GET",
          dataType: "text/html",
          success: function(data) {
            obj2.content.innerHTML = data;
            if (!obj2.options.closed) {
              obj2.open();
            }
          }
        });
      } else {
        if (!obj2.options.closed) {
          obj2.open();
        }
      }
      el2.modal = obj2;
      return obj2;
    };
    jSuites2.notification = function(options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        icon: null,
        name: "Notification",
        date: null,
        error: null,
        title: null,
        message: null,
        timeout: 4e3,
        autoHide: true,
        closeable: true
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      var notification = document.createElement("div");
      notification.className = "jnotification";
      if (obj2.options.error) {
        notification.classList.add("jnotification-error");
      }
      var notificationContainer = document.createElement("div");
      notificationContainer.className = "jnotification-container";
      notification.appendChild(notificationContainer);
      var notificationHeader = document.createElement("div");
      notificationHeader.className = "jnotification-header";
      notificationContainer.appendChild(notificationHeader);
      var notificationImage = document.createElement("div");
      notificationImage.className = "jnotification-image";
      notificationHeader.appendChild(notificationImage);
      if (obj2.options.icon) {
        var notificationIcon = document.createElement("img");
        notificationIcon.src = obj2.options.icon;
        notificationImage.appendChild(notificationIcon);
      }
      var notificationName = document.createElement("div");
      notificationName.className = "jnotification-name";
      notificationName.innerHTML = obj2.options.name;
      notificationHeader.appendChild(notificationName);
      if (obj2.options.closeable == true) {
        var notificationClose = document.createElement("div");
        notificationClose.className = "jnotification-close";
        notificationClose.onclick = function() {
          obj2.hide();
        };
        notificationHeader.appendChild(notificationClose);
      }
      var notificationDate = document.createElement("div");
      notificationDate.className = "jnotification-date";
      notificationHeader.appendChild(notificationDate);
      var notificationContent = document.createElement("div");
      notificationContent.className = "jnotification-content";
      notificationContainer.appendChild(notificationContent);
      if (obj2.options.title) {
        var notificationTitle = document.createElement("div");
        notificationTitle.className = "jnotification-title";
        notificationTitle.innerHTML = obj2.options.title;
        notificationContent.appendChild(notificationTitle);
      }
      var notificationMessage = document.createElement("div");
      notificationMessage.className = "jnotification-message";
      notificationMessage.innerHTML = obj2.options.message;
      notificationContent.appendChild(notificationMessage);
      obj2.show = function() {
        document.body.appendChild(notification);
        if (jSuites2.getWindowWidth() > 800) {
          jSuites2.animation.fadeIn(notification);
        } else {
          jSuites2.animation.slideTop(notification, 1);
        }
      };
      obj2.hide = function() {
        if (jSuites2.getWindowWidth() > 800) {
          jSuites2.animation.fadeOut(notification, function() {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
              if (notificationTimeout) {
                clearTimeout(notificationTimeout);
              }
            }
          });
        } else {
          jSuites2.animation.slideTop(notification, 0, function() {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
              if (notificationTimeout) {
                clearTimeout(notificationTimeout);
              }
            }
          });
        }
      };
      obj2.show();
      if (obj2.options.autoHide == true) {
        var notificationTimeout = setTimeout(function() {
          obj2.hide();
        }, obj2.options.timeout);
      }
      if (jSuites2.getWindowWidth() < 800) {
        notification.addEventListener("swipeup", function(e) {
          obj2.hide();
          e.preventDefault();
          e.stopPropagation();
        });
      }
      return obj2;
    };
    jSuites2.notification.isVisible = function() {
      var j2 = document.querySelector(".jnotification");
      return j2 && j2.parentNode ? true : false;
    };
    jSuites2.palette = function() {
      var palette = {
        material: [
          ["#ffebee", "#fce4ec", "#f3e5f5", "#e8eaf6", "#e3f2fd", "#e0f7fa", "#e0f2f1", "#e8f5e9", "#f1f8e9", "#f9fbe7", "#fffde7", "#fff8e1", "#fff3e0", "#fbe9e7", "#efebe9", "#fafafa", "#eceff1"],
          ["#ffcdd2", "#f8bbd0", "#e1bee7", "#c5cae9", "#bbdefb", "#b2ebf2", "#b2dfdb", "#c8e6c9", "#dcedc8", "#f0f4c3", "#fff9c4", "#ffecb3", "#ffe0b2", "#ffccbc", "#d7ccc8", "#f5f5f5", "#cfd8dc"],
          ["#ef9a9a", "#f48fb1", "#ce93d8", "#9fa8da", "#90caf9", "#80deea", "#80cbc4", "#a5d6a7", "#c5e1a5", "#e6ee9c", "#fff59d", "#ffe082", "#ffcc80", "#ffab91", "#bcaaa4", "#eeeeee", "#b0bec5"],
          ["#e57373", "#f06292", "#ba68c8", "#7986cb", "#64b5f6", "#4dd0e1", "#4db6ac", "#81c784", "#aed581", "#dce775", "#fff176", "#ffd54f", "#ffb74d", "#ff8a65", "#a1887f", "#e0e0e0", "#90a4ae"],
          ["#ef5350", "#ec407a", "#ab47bc", "#5c6bc0", "#42a5f5", "#26c6da", "#26a69a", "#66bb6a", "#9ccc65", "#d4e157", "#ffee58", "#ffca28", "#ffa726", "#ff7043", "#8d6e63", "#bdbdbd", "#78909c"],
          ["#f44336", "#e91e63", "#9c27b0", "#3f51b5", "#2196f3", "#00bcd4", "#009688", "#4caf50", "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722", "#795548", "#9e9e9e", "#607d8b"],
          ["#e53935", "#d81b60", "#8e24aa", "#3949ab", "#1e88e5", "#00acc1", "#00897b", "#43a047", "#7cb342", "#c0ca33", "#fdd835", "#ffb300", "#fb8c00", "#f4511e", "#6d4c41", "#757575", "#546e7a"],
          ["#d32f2f", "#c2185b", "#7b1fa2", "#303f9f", "#1976d2", "#0097a7", "#00796b", "#388e3c", "#689f38", "#afb42b", "#fbc02d", "#ffa000", "#f57c00", "#e64a19", "#5d4037", "#616161", "#455a64"],
          ["#c62828", "#ad1457", "#6a1b9a", "#283593", "#1565c0", "#00838f", "#00695c", "#2e7d32", "#558b2f", "#9e9d24", "#f9a825", "#ff8f00", "#ef6c00", "#d84315", "#4e342e", "#424242", "#37474f"],
          ["#b71c1c", "#880e4f", "#4a148c", "#1a237e", "#0d47a1", "#006064", "#004d40", "#1b5e20", "#33691e", "#827717", "#f57f17", "#ff6f00", "#e65100", "#bf360c", "#3e2723", "#212121", "#263238"]
        ],
        fire: [
          ["0b1a6d", "840f38", "b60718", "de030b", "ff0c0c", "fd491c", "fc7521", "faa331", "fbb535", "ffc73a"],
          ["071147", "5f0b28", "930513", "be0309", "ef0000", "fa3403", "fb670b", "f9991b", "faad1e", "ffc123"],
          ["03071e", "370617", "6a040f", "9d0208", "d00000", "dc2f02", "e85d04", "f48c06", "faa307", "ffba08"],
          ["020619", "320615", "61040d", "8c0207", "bc0000", "c82a02", "d05203", "db7f06", "e19405", "efab00"],
          ["020515", "2d0513", "58040c", "7f0206", "aa0000", "b62602", "b94903", "c57205", "ca8504", "d89b00"]
        ],
        baby: [
          ["eddcd2", "fff1e6", "fde2e4", "fad2e1", "c5dedd", "dbe7e4", "f0efeb", "d6e2e9", "bcd4e6", "99c1de"],
          ["e1c4b3", "ffd5b5", "fab6ba", "f5a8c4", "aacecd", "bfd5cf", "dbd9d0", "baceda", "9dc0db", "7eb1d5"],
          ["daa990", "ffb787", "f88e95", "f282a9", "8fc4c3", "a3c8be", "cec9b3", "9dbcce", "82acd2", "649dcb"],
          ["d69070", "ff9c5e", "f66770", "f05f8f", "74bbb9", "87bfae", "c5b993", "83aac3", "699bca", "4d89c2"],
          ["c97d5d", "f58443", "eb4d57", "e54a7b", "66a9a7", "78ae9c", "b5a67e", "7599b1", "5c88b7", "4978aa"]
        ],
        chart: [
          ["#C1D37F", "#4C5454", "#FFD275", "#66586F", "#D05D5B", "#C96480", "#95BF8F", "#6EA240", "#0F0F0E", "#EB8258", "#95A3B3", "#995D81"]
        ]
      };
      var component = function(o) {
        if (palette[o]) {
          return palette[o];
        } else {
          return palette.material;
        }
      };
      component.get = function(o) {
        if (palette[o]) {
          return palette[o];
        } else {
          return palette;
        }
      };
      component.set = function(o, v) {
        palette[o] = v;
      };
      return component;
    }();
    jSuites2.picker = function(el2, options2) {
      if (el2.picker) {
        return el2.picker.setOptions(options2, true);
      }
      var obj2 = { type: "picker" };
      obj2.options = {};
      var dropdownHeader = null;
      var dropdownContent = null;
      var createContent = function() {
        dropdownContent.innerHTML = "";
        var keys2 = Object.keys(obj2.options.data);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var dropdownItem = document.createElement("div");
          dropdownItem.classList.add("jpicker-item");
          dropdownItem.k = keys2[i2];
          dropdownItem.v = obj2.options.data[keys2[i2]];
          dropdownItem.innerHTML = obj2.getLabel(keys2[i2]);
          dropdownContent.appendChild(dropdownItem);
        }
      };
      obj2.setOptions = function(options3, reset) {
        var defaults2 = {
          value: 0,
          data: null,
          render: null,
          onchange: null,
          onselect: null,
          onopen: null,
          onclose: null,
          onload: null,
          width: null,
          header: true,
          right: false,
          content: false,
          columns: null,
          height: null
        };
        if (options3 && options3.options) {
          options3.data = options3.options;
        }
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        if (obj2.options.header === false) {
          dropdownHeader.style.display = "none";
        } else {
          dropdownHeader.style.display = "";
        }
        if (obj2.options.width) {
          dropdownHeader.style.width = parseInt(obj2.options.width) + "px";
        } else {
          dropdownHeader.style.width = "";
        }
        if (obj2.options.height) {
          dropdownContent.style.maxHeight = obj2.options.height + "px";
          dropdownContent.style.overflow = "scroll";
        } else {
          dropdownContent.style.overflow = "";
        }
        if (obj2.options.columns > 0) {
          dropdownContent.classList.add("jpicker-columns");
          dropdownContent.style.width = obj2.options.width ? obj2.options.width : 36 * obj2.options.columns + "px";
        }
        if (isNaN(obj2.options.value)) {
          obj2.options.value = "0";
        }
        createContent();
        obj2.setValue(obj2.options.value);
        return obj2;
      };
      obj2.getValue = function() {
        return obj2.options.value;
      };
      obj2.setValue = function(v) {
        obj2.setLabel(v);
        obj2.options.value = String(v);
        if (el2.value != obj2.options.value) {
          el2.value = obj2.options.value;
          if (typeof el2.oninput == "function") {
            el2.oninput({
              type: "input",
              target: el2,
              value: el2.value
            });
          }
        }
        if (dropdownContent.children[v].getAttribute("type") !== "generic") {
          obj2.close();
        }
      };
      obj2.getLabel = function(v) {
        var label = obj2.options.data[v] || null;
        if (typeof obj2.options.render == "function") {
          label = obj2.options.render(label);
        }
        return label;
      };
      obj2.setLabel = function(v) {
        if (obj2.options.content) {
          var label = '<i class="material-icons">' + obj2.options.content + "</i>";
        } else {
          var label = obj2.getLabel(v);
        }
        dropdownHeader.innerHTML = label;
      };
      obj2.open = function() {
        if (!el2.classList.contains("jpicker-focus")) {
          jSuites2.tracking(obj2, true);
          el2.classList.add("jpicker-focus");
          el2.focus();
          var top = 0;
          var left = 0;
          dropdownContent.style.marginLeft = "";
          var rectHeader = dropdownHeader.getBoundingClientRect();
          var rectContent = dropdownContent.getBoundingClientRect();
          if (window.innerHeight < rectHeader.bottom + rectContent.height) {
            top = -1 * (rectContent.height + 4);
          } else {
            top = rectHeader.height + 4;
          }
          if (obj2.options.right === true) {
            left = -1 * rectContent.width + rectHeader.width;
          }
          if (rectContent.left + left < 0) {
            left = left + rectContent.left + 10;
          }
          if (rectContent.left + rectContent.width > window.innerWidth) {
            left = -1 * (10 + rectContent.left + rectContent.width - window.innerWidth);
          }
          dropdownContent.style.marginTop = parseInt(top) + "px";
          dropdownContent.style.marginLeft = parseInt(left) + "px";
          if (typeof obj2.options.onopen == "function") {
            obj2.options.onopen(el2, obj2);
          }
        }
      };
      obj2.close = function() {
        if (el2.classList.contains("jpicker-focus")) {
          el2.classList.remove("jpicker-focus");
          jSuites2.tracking(obj2, false);
          if (typeof obj2.options.onclose == "function") {
            obj2.options.onclose(el2, obj2);
          }
        }
      };
      var init2 = function() {
        el2.classList.add("jpicker");
        el2.setAttribute("tabindex", "900");
        el2.onmousedown = function(e) {
          if (!el2.classList.contains("jpicker-focus")) {
            obj2.open();
          }
        };
        dropdownHeader = document.createElement("div");
        dropdownHeader.classList.add("jpicker-header");
        dropdownContent = document.createElement("div");
        dropdownContent.classList.add("jpicker-content");
        dropdownContent.onclick = function(e) {
          var item = jSuites2.findElement(e.target, "jpicker-item");
          if (item) {
            if (item.parentNode === dropdownContent) {
              obj2.setValue(item.k);
              if (typeof obj2.options.onchange == "function") {
                obj2.options.onchange.call(obj2, el2, obj2, item.v, item.v, item.k);
              }
            }
          }
        };
        el2.appendChild(dropdownHeader);
        el2.appendChild(dropdownContent);
        el2.value = options2.value || 0;
        obj2.setOptions(options2);
        if (typeof obj2.options.onload == "function") {
          obj2.options.onload(el2, obj2);
        }
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue();
          } else {
            obj2.setValue(val);
          }
        };
        el2.picker = obj2;
      };
      init2();
      return obj2;
    };
    jSuites2.progressbar = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        value: 0,
        onchange: null,
        width: null
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      el2.classList.add("jprogressbar");
      el2.setAttribute("tabindex", 1);
      el2.setAttribute("data-value", obj2.options.value);
      var bar = document.createElement("div");
      bar.style.width = obj2.options.value + "%";
      bar.style.color = "#fff";
      el2.appendChild(bar);
      if (obj2.options.width) {
        el2.style.width = obj2.options.width;
      }
      obj2.setValue = function(value2) {
        value2 = parseInt(value2);
        obj2.options.value = value2;
        bar.style.width = value2 + "%";
        el2.setAttribute("data-value", value2 + "%");
        if (value2 < 6) {
          el2.style.color = "#000";
        } else {
          el2.style.color = "#fff";
        }
        obj2.options.value = value2;
        if (typeof obj2.options.onchange == "function") {
          obj2.options.onchange(el2, value2);
        }
        if (el2.value != obj2.options.value) {
          el2.value = obj2.options.value;
          if (typeof el2.oninput == "function") {
            el2.oninput({
              type: "input",
              target: el2,
              value: el2.value
            });
          }
        }
      };
      obj2.getValue = function() {
        return obj2.options.value;
      };
      var action = function(e) {
        if (e.which) {
          var rect = el2.getBoundingClientRect();
          if (e.changedTouches && e.changedTouches[0]) {
            var x2 = e.changedTouches[0].clientX;
            e.changedTouches[0].clientY;
          } else {
            var x2 = e.clientX;
            e.clientY;
          }
          obj2.setValue(Math.round((x2 - rect.left) / rect.width * 100));
        }
      };
      if ("touchstart" in document.documentElement === true) {
        el2.addEventListener("touchstart", action);
        el2.addEventListener("touchend", action);
      } else {
        el2.addEventListener("mousedown", action);
        el2.addEventListener("mousemove", action);
      }
      el2.change = obj2.setValue;
      el2.val = function(val) {
        if (val === void 0) {
          return obj2.getValue();
        } else {
          obj2.setValue(val);
        }
      };
      el2.progressbar = obj2;
      return obj2;
    };
    jSuites2.rating = function(el2, options2) {
      if (el2.rating) {
        return el2.rating.setOptions(options2, true);
      }
      var obj2 = {};
      obj2.options = {};
      obj2.setOptions = function(options3, reset) {
        var defaults2 = {
          number: 5,
          value: 0,
          tooltip: ["Very bad", "Bad", "Average", "Good", "Very good"],
          onchange: null
        };
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        el2.innerHTML = "";
        for (var i2 = 0; i2 < obj2.options.number; i2++) {
          var div2 = document.createElement("div");
          div2.setAttribute("data-index", i2 + 1);
          div2.setAttribute("title", obj2.options.tooltip[i2]);
          el2.appendChild(div2);
        }
        if (obj2.options.value) {
          for (var i2 = 0; i2 < obj2.options.number; i2++) {
            if (i2 < obj2.options.value) {
              el2.children[i2].classList.add("jrating-selected");
            }
          }
        }
        return obj2;
      };
      obj2.setValue = function(index2) {
        for (var i2 = 0; i2 < obj2.options.number; i2++) {
          if (i2 < index2) {
            el2.children[i2].classList.add("jrating-selected");
          } else {
            el2.children[i2].classList.remove("jrating-over");
            el2.children[i2].classList.remove("jrating-selected");
          }
        }
        obj2.options.value = index2;
        if (typeof obj2.options.onchange == "function") {
          obj2.options.onchange(el2, index2);
        }
        if (el2.value != obj2.options.value) {
          el2.value = obj2.options.value;
          if (typeof el2.oninput == "function") {
            el2.oninput({
              type: "input",
              target: el2,
              value: el2.value
            });
          }
        }
      };
      obj2.getValue = function() {
        return obj2.options.value;
      };
      var init2 = function() {
        obj2.setOptions(options2);
        el2.classList.add("jrating");
        el2.addEventListener("click", function(e) {
          var index2 = e.target.getAttribute("data-index");
          if (index2 != void 0) {
            if (index2 == obj2.options.value) {
              obj2.setValue(0);
            } else {
              obj2.setValue(index2);
            }
          }
        });
        el2.addEventListener("mouseover", function(e) {
          var index2 = e.target.getAttribute("data-index");
          for (var i2 = 0; i2 < obj2.options.number; i2++) {
            if (i2 < index2) {
              el2.children[i2].classList.add("jrating-over");
            } else {
              el2.children[i2].classList.remove("jrating-over");
            }
          }
        });
        el2.addEventListener("mouseout", function(e) {
          for (var i2 = 0; i2 < obj2.options.number; i2++) {
            el2.children[i2].classList.remove("jrating-over");
          }
        });
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue();
          } else {
            obj2.setValue(val);
          }
        };
        el2.rating = obj2;
      };
      init2();
      return obj2;
    };
    jSuites2.search = function(el2, options2) {
      if (el2.search) {
        return el2.search;
      }
      var index2 = null;
      var select = function(e) {
        if (e.target.classList.contains("jsearch_item")) {
          var element2 = e.target;
        } else {
          var element2 = e.target.parentNode;
        }
        obj2.selectIndex(element2);
        e.preventDefault();
      };
      var createList = function(data) {
        container.innerHTML = "";
        if (!data.length) {
          el2.style.display = "";
        } else {
          el2.style.display = "block";
          var len = data.length < 11 ? data.length : 10;
          for (var i2 = 0; i2 < len; i2++) {
            if (typeof data[i2] == "string") {
              var text2 = data[i2];
              var value2 = data[i2];
            } else {
              var text2 = data[i2].text;
              if (!text2 && data[i2].name) {
                text2 = data[i2].name;
              }
              var value2 = data[i2].value;
              if (!value2 && data[i2].id) {
                value2 = data[i2].id;
              }
            }
            var div2 = document.createElement("div");
            div2.setAttribute("data-value", value2);
            div2.setAttribute("data-text", text2);
            div2.className = "jsearch_item";
            if (data[i2].id) {
              div2.setAttribute("id", data[i2].id);
            }
            if (obj2.options.forceSelect && i2 == 0) {
              div2.classList.add("selected");
            }
            var img = document.createElement("img");
            if (data[i2].image) {
              img.src = data[i2].image;
            } else {
              img.style.display = "none";
            }
            div2.appendChild(img);
            var item = document.createElement("div");
            item.innerHTML = text2;
            div2.appendChild(item);
            container.appendChild(div2);
          }
        }
      };
      var execute2 = function(str2) {
        if (str2 != obj2.terms) {
          obj2.terms = str2;
          if (obj2.options.forceSelect) {
            index2 = 0;
          } else {
            index2 = null;
          }
          if (Array.isArray(obj2.options.data)) {
            var test = function(o) {
              if (typeof o == "string") {
                if (("" + o).toLowerCase().search(str2.toLowerCase()) >= 0) {
                  return true;
                }
              } else {
                for (var key in o) {
                  var value2 = o[key];
                  if (("" + value2).toLowerCase().search(str2.toLowerCase()) >= 0) {
                    return true;
                  }
                }
              }
              return false;
            };
            var results2 = obj2.options.data.filter(function(item) {
              return test(item);
            });
            createList(results2);
          } else {
            jSuites2.ajax({
              url: obj2.options.data + str2,
              method: "GET",
              dataType: "json",
              success: function(data) {
                createList(data);
              }
            });
          }
        }
      };
      var timer = null;
      var obj2 = function(str2) {
        if (timer) {
          clearTimeout(timer);
        }
        timer = setTimeout(function() {
          execute2(str2);
        }, 500);
      };
      if (options2.forceSelect === null) {
        options2.forceSelect = true;
      }
      obj2.options = {
        data: options2.data || null,
        input: options2.input || null,
        onselect: options2.onselect || null,
        forceSelect: options2.forceSelect
      };
      obj2.selectIndex = function(item) {
        var id = item.getAttribute("id");
        var text2 = item.getAttribute("data-text");
        var value2 = item.getAttribute("data-value");
        if (typeof obj2.options.onselect == "function") {
          obj2.options.onselect(obj2, text2, value2, id);
        }
        obj2.close();
      };
      obj2.open = function() {
        el2.style.display = "block";
      };
      obj2.close = function() {
        if (timer) {
          clearTimeout(timer);
        }
        obj2.terms = "";
        container.innerHTML = "";
        el2.style.display = "";
      };
      obj2.isOpened = function() {
        return el2.style.display ? true : false;
      };
      obj2.keydown = function(e) {
        if (obj2.isOpened()) {
          if (e.key == "Enter") {
            if (index2 !== null && container.children[index2]) {
              obj2.selectIndex(container.children[index2]);
              e.preventDefault();
            } else {
              obj2.close();
            }
          } else if (e.key === "ArrowUp") {
            if (index2 !== null && container.children[0]) {
              container.children[index2].classList.remove("selected");
              if (!obj2.options.forceSelect && index2 === 0) {
                index2 = null;
              } else {
                index2 = Math.max(0, index2 - 1);
                container.children[index2].classList.add("selected");
              }
            }
            e.preventDefault();
          } else if (e.key === "ArrowDown") {
            if (index2 == null) {
              index2 = -1;
            } else {
              container.children[index2].classList.remove("selected");
            }
            if (index2 < 9 && container.children[index2 + 1]) {
              index2++;
            }
            container.children[index2].classList.add("selected");
            e.preventDefault();
          }
        }
      };
      obj2.keyup = function(e) {
        if (obj2.options.input) {
          obj2(obj2.options.input.value);
        } else {
          var node = jSuites2.getNode();
          if (node) {
            obj2(node.innerText);
          }
        }
      };
      if (obj2.options.input) {
        obj2.options.input.addEventListener("keyup", obj2.keyup);
        obj2.options.input.addEventListener("keydown", obj2.keydown);
      }
      var container = document.createElement("div");
      container.classList.add("jsearch_container");
      container.onmousedown = select;
      el2.appendChild(container);
      el2.classList.add("jsearch");
      el2.search = obj2;
      return obj2;
    };
    jSuites2.slider = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      obj2.currentImage = null;
      if (options2) {
        obj2.options = options2;
      }
      el2.setAttribute("tabindex", "900");
      obj2.options.items = [];
      if (!el2.classList.contains("jslider")) {
        el2.classList.add("jslider");
        el2.classList.add("unselectable");
        if (obj2.options.height) {
          el2.style.minHeight = obj2.options.height;
        }
        if (obj2.options.width) {
          el2.style.width = obj2.options.width;
        }
        if (obj2.options.grid) {
          el2.classList.add("jslider-grid");
          var number2 = el2.children.length;
          if (number2 > 4) {
            el2.setAttribute("data-total", number2 - 4);
          }
          el2.setAttribute("data-number", number2 > 4 ? 4 : number2);
        }
        var counter = document.createElement("div");
        counter.classList.add("jslider-counter");
        if (el2.children.length > 0) {
          for (var i2 = 0; i2 < el2.children.length; i2++) {
            obj2.options.items.push(el2.children[i2]);
            var item = document.createElement("div");
            item.onclick = function() {
              var index2 = Array.prototype.slice.call(counter.children).indexOf(this);
              obj2.show(obj2.currentImage = obj2.options.items[index2]);
            };
            counter.appendChild(item);
          }
        }
        var caption = document.createElement("div");
        caption.className = "jslider-caption";
        var controls = document.createElement("div");
        var close = document.createElement("div");
        close.className = "jslider-close";
        close.innerHTML = "";
        close.onclick = function() {
          obj2.close();
        };
        controls.appendChild(caption);
        controls.appendChild(close);
      }
      obj2.updateCounter = function(index2) {
        for (var i3 = 0; i3 < counter.children.length; i3++) {
          if (counter.children[i3].classList.contains("jslider-counter-focus")) {
            counter.children[i3].classList.remove("jslider-counter-focus");
            break;
          }
        }
        counter.children[index2].classList.add("jslider-counter-focus");
      };
      obj2.show = function(target) {
        if (!target) {
          var target = el2.children[0];
        }
        el2.classList.add("jslider-focus");
        el2.classList.remove("jslider-grid");
        el2.appendChild(controls);
        el2.appendChild(counter);
        var index2 = obj2.options.items.indexOf(target);
        obj2.updateCounter(index2);
        for (var i3 = 0; i3 < el2.children.length; i3++) {
          el2.children[i3].style.display = "";
        }
        target.style.display = "block";
        if (target.previousElementSibling) {
          el2.classList.add("jslider-left");
        } else {
          el2.classList.remove("jslider-left");
        }
        if (target.nextElementSibling && target.nextElementSibling.tagName == "IMG") {
          el2.classList.add("jslider-right");
        } else {
          el2.classList.remove("jslider-right");
        }
        obj2.currentImage = target;
        if (obj2.currentImage.offsetHeight > obj2.currentImage.offsetWidth) {
          obj2.currentImage.classList.add("jslider-vertical");
        }
        controls.children[0].innerText = obj2.currentImage.getAttribute("title");
      };
      obj2.open = function() {
        obj2.show();
        if (typeof obj2.options.onopen == "function") {
          obj2.options.onopen(el2);
        }
      };
      obj2.close = function() {
        el2.classList.remove("jslider-focus");
        el2.classList.remove("jslider-left");
        el2.classList.remove("jslider-right");
        if (obj2.options.grid) {
          el2.classList.add("jslider-grid");
        }
        for (var i3 = 0; i3 < el2.children.length; i3++) {
          el2.children[i3].style.display = "";
        }
        counter.remove();
        controls.remove();
        obj2.currentImage = null;
        if (typeof obj2.options.onclose == "function") {
          obj2.options.onclose(el2);
        }
      };
      obj2.reset = function() {
        el2.innerHTML = "";
      };
      obj2.next = function() {
        var nextImage = obj2.currentImage.nextElementSibling;
        if (nextImage && nextImage.tagName === "IMG") {
          obj2.show(obj2.currentImage.nextElementSibling);
        }
      };
      obj2.prev = function() {
        if (obj2.currentImage.previousElementSibling) {
          obj2.show(obj2.currentImage.previousElementSibling);
        }
      };
      var mouseUp = function(e) {
        if (e.target.tagName == "IMG") {
          obj2.show(e.target);
        } else if (!e.target.classList.contains("jslider-close") && !(e.target.parentNode.classList.contains("jslider-counter") || e.target.classList.contains("jslider-counter"))) {
          var offsetX = e.offsetX || e.changedTouches[0].clientX;
          if (e.target.clientWidth - offsetX < 40) {
            obj2.next();
          } else if (offsetX < 40) {
            obj2.prev();
          }
        }
      };
      if ("ontouchend" in document.documentElement === true) {
        el2.addEventListener("touchend", mouseUp);
      } else {
        el2.addEventListener("mouseup", mouseUp);
      }
      el2.addEventListener("swipeleft", function(e) {
        obj2.next();
        e.preventDefault();
        e.stopPropagation();
      });
      el2.addEventListener("swiperight", function(e) {
        obj2.prev();
        e.preventDefault();
        e.stopPropagation();
      });
      el2.addEventListener("keydown", function(e) {
        if (e.which == 27) {
          obj2.close();
        }
      });
      el2.slider = obj2;
      return obj2;
    };
    jSuites2.sorting = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        pointer: null,
        direction: null,
        ondragstart: null,
        ondragend: null,
        ondrop: null
      };
      var dragElement = null;
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      el2.classList.add("jsorting");
      el2.addEventListener("dragstart", function(e) {
        var position2 = Array.prototype.indexOf.call(e.target.parentNode.children, e.target);
        dragElement = {
          element: e.target,
          o: position2,
          d: position2
        };
        e.target.style.opacity = "0.25";
        if (typeof obj2.options.ondragstart == "function") {
          obj2.options.ondragstart(el2, e.target, e);
        }
      });
      el2.addEventListener("dragover", function(e) {
        e.preventDefault();
        if (getElement(e.target) && dragElement) {
          if (e.target.getAttribute("draggable") == "true" && dragElement.element != e.target) {
            if (!obj2.options.direction) {
              var condition2 = e.target.clientHeight / 2 > e.offsetY;
            } else {
              var condition2 = e.target.clientWidth / 2 > e.offsetX;
            }
            if (condition2) {
              e.target.parentNode.insertBefore(dragElement.element, e.target);
            } else {
              e.target.parentNode.insertBefore(dragElement.element, e.target.nextSibling);
            }
            dragElement.d = Array.prototype.indexOf.call(e.target.parentNode.children, dragElement.element);
          }
        }
      });
      el2.addEventListener("dragleave", function(e) {
        e.preventDefault();
      });
      el2.addEventListener("dragend", function(e) {
        e.preventDefault();
        if (dragElement) {
          if (typeof obj2.options.ondragend == "function") {
            obj2.options.ondragend(el2, dragElement.element, e);
          }
          if (dragElement.o < dragElement.d) {
            e.target.parentNode.insertBefore(dragElement.element, e.target.parentNode.children[dragElement.o]);
          } else {
            e.target.parentNode.insertBefore(dragElement.element, e.target.parentNode.children[dragElement.o].nextSibling);
          }
          dragElement.element.style.opacity = "";
          dragElement = null;
        }
      });
      el2.addEventListener("drop", function(e) {
        e.preventDefault();
        if (dragElement && dragElement.o != dragElement.d) {
          if (typeof obj2.options.ondrop == "function") {
            obj2.options.ondrop(el2, dragElement.o, dragElement.d, dragElement.element, e.target, e);
          }
        }
        dragElement.element.style.opacity = "";
        dragElement = null;
      });
      var getElement = function(element2) {
        var sorting = false;
        function path2(element3) {
          if (element3.className) {
            if (element3.classList.contains("jsorting")) {
              sorting = true;
            }
          }
          if (!sorting) {
            path2(element3.parentNode);
          }
        }
        path2(element2);
        return sorting;
      };
      for (var i2 = 0; i2 < el2.children.length; i2++) {
        if (!el2.children[i2].hasAttribute("draggable")) {
          el2.children[i2].setAttribute("draggable", "true");
        }
      }
      el2.val = function() {
        var id = null;
        var data = [];
        for (var i3 = 0; i3 < el2.children.length; i3++) {
          if (id = el2.children[i3].getAttribute("data-id")) {
            data.push(id);
          }
        }
        return data;
      };
      return el2;
    };
    jSuites2.tabs = function(el2, options2) {
      var obj2 = {};
      obj2.options = {};
      var defaults2 = {
        data: [],
        position: null,
        allowCreate: false,
        allowChangePosition: false,
        onclick: null,
        onload: null,
        onchange: null,
        oncreate: null,
        ondelete: null,
        onbeforecreate: null,
        onchangeposition: null,
        animation: false,
        hideHeaders: false,
        padding: null,
        palette: null,
        maxWidth: null
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      el2.classList.add("jtabs");
      var prev = null;
      var next2 = null;
      var border = null;
      var setBorder = function(index2) {
        if (obj2.options.animation) {
          var rect = obj2.headers.children[index2].getBoundingClientRect();
          if (obj2.options.palette == "modern") {
            border.style.width = rect.width - 4 + "px";
            border.style.left = obj2.headers.children[index2].offsetLeft + 2 + "px";
          } else {
            border.style.width = rect.width + "px";
            border.style.left = obj2.headers.children[index2].offsetLeft + "px";
          }
          if (obj2.options.position == "bottom") {
            border.style.top = "0px";
          } else {
            border.style.bottom = "0px";
          }
        }
      };
      var updateControls = function(x2) {
        if (typeof obj2.headers.scrollTo == "function") {
          obj2.headers.scrollTo({
            left: x2,
            behavior: "smooth"
          });
        } else {
          obj2.headers.scrollLeft = x2;
        }
        if (x2 <= 1) {
          prev.classList.add("disabled");
        } else {
          prev.classList.remove("disabled");
        }
        if (x2 >= obj2.headers.scrollWidth - obj2.headers.offsetWidth) {
          next2.classList.add("disabled");
        } else {
          next2.classList.remove("disabled");
        }
        if (obj2.headers.scrollWidth <= obj2.headers.offsetWidth) {
          prev.style.display = "none";
          next2.style.display = "none";
        } else {
          prev.style.display = "";
          next2.style.display = "";
        }
      };
      obj2.setBorder = setBorder;
      obj2.open = function(index2) {
        var previous2 = null;
        for (var i3 = 0; i3 < obj2.headers.children.length; i3++) {
          if (obj2.headers.children[i3].classList.contains("jtabs-selected")) {
            previous2 = i3;
          }
          obj2.headers.children[i3].classList.remove("jtabs-selected");
          if (obj2.content.children[i3]) {
            obj2.content.children[i3].classList.remove("jtabs-selected");
          }
        }
        obj2.headers.children[index2].classList.add("jtabs-selected");
        if (obj2.content.children[index2]) {
          obj2.content.children[index2].classList.add("jtabs-selected");
        }
        if (previous2 != index2 && typeof obj2.options.onchange == "function") {
          if (obj2.content.children[index2]) {
            obj2.options.onchange(el2, obj2, index2, obj2.headers.children[index2], obj2.content.children[index2]);
          }
        }
        if (obj2.options.hideHeaders == true && (obj2.headers.children.length < 3 && obj2.options.allowCreate == false)) {
          obj2.headers.parentNode.style.display = "none";
        } else {
          setBorder(index2);
          obj2.headers.parentNode.style.display = "";
          var x1 = obj2.headers.children[index2].offsetLeft;
          var x2 = x1 + obj2.headers.children[index2].offsetWidth;
          var r1 = obj2.headers.scrollLeft;
          var r2 = r1 + obj2.headers.offsetWidth;
          if (!(r1 <= x1 && r2 >= x2)) {
            updateControls(x1 - 1);
          }
        }
      };
      obj2.selectIndex = function(a) {
        var index2 = Array.prototype.indexOf.call(obj2.headers.children, a);
        if (index2 >= 0) {
          obj2.open(index2);
        }
        return index2;
      };
      obj2.rename = function(i3, title) {
        if (!title) {
          title = prompt("New title", obj2.headers.children[i3].innerText);
        }
        obj2.headers.children[i3].innerText = title;
        obj2.open(i3);
      };
      obj2.create = function(title, url) {
        if (typeof obj2.options.onbeforecreate == "function") {
          var ret = obj2.options.onbeforecreate(el2);
          if (ret === false) {
            return false;
          } else {
            title = ret;
          }
        }
        var div2 = obj2.appendElement(title);
        if (typeof obj2.options.oncreate == "function") {
          obj2.options.oncreate(el2, div2);
        }
        return div2;
      };
      obj2.remove = function(index2) {
        return obj2.deleteElement(index2);
      };
      obj2.nextNumber = function() {
        var num = 0;
        for (var i3 = 0; i3 < obj2.headers.children.length; i3++) {
          var tmp2 = obj2.headers.children[i3].innerText.match(/[0-9].*/);
          if (tmp2 > num) {
            num = parseInt(tmp2);
          }
        }
        if (!num) {
          num = 1;
        } else {
          num++;
        }
        return num;
      };
      obj2.deleteElement = function(index2) {
        if (!obj2.headers.children[index2]) {
          return false;
        } else {
          obj2.headers.removeChild(obj2.headers.children[index2]);
          obj2.content.removeChild(obj2.content.children[index2]);
        }
        obj2.open(0);
        if (typeof obj2.options.ondelete == "function") {
          obj2.options.ondelete(el2, index2);
        }
      };
      obj2.appendElement = function(title, cb) {
        if (!title) {
          var title = prompt("Title?", "");
        }
        if (title) {
          var div2 = document.createElement("div");
          obj2.content.appendChild(div2);
          var h = document.createElement("div");
          h.innerHTML = title;
          h.content = div2;
          obj2.headers.insertBefore(h, obj2.headers.lastChild);
          if (obj2.options.allowChangePosition) {
            h.setAttribute("draggable", "true");
          }
          obj2.selectIndex(h);
          if (typeof cb == "function") {
            cb(div2, h);
          }
          return div2;
        }
      };
      obj2.getActive = function() {
        for (var i3 = 0; i3 < obj2.headers.children.length; i3++) {
          if (obj2.headers.children[i3].classList.contains("jtabs-selected")) {
            return i3;
          }
        }
        return 0;
      };
      obj2.updateContent = function(position2, newContent) {
        if (typeof newContent !== "string") {
          var contentItem = newContent;
        } else {
          var contentItem = document.createElement("div");
          contentItem.innerHTML = newContent;
        }
        if (obj2.content.children[position2].classList.contains("jtabs-selected")) {
          newContent.classList.add("jtabs-selected");
        }
        obj2.content.replaceChild(newContent, obj2.content.children[position2]);
      };
      obj2.updatePosition = function(f, t) {
        if (f > t) {
          obj2.content.insertBefore(obj2.content.children[f], obj2.content.children[t]);
        } else {
          obj2.content.insertBefore(obj2.content.children[f], obj2.content.children[t].nextSibling);
        }
        obj2.open(t);
        if (typeof obj2.options.onchangeposition == "function") {
          obj2.options.onchangeposition(obj2.headers, f, t);
        }
      };
      obj2.move = function(f, t) {
        if (f > t) {
          obj2.headers.insertBefore(obj2.headers.children[f], obj2.headers.children[t]);
        } else {
          obj2.headers.insertBefore(obj2.headers.children[f], obj2.headers.children[t].nextSibling);
        }
        obj2.updatePosition(f, t);
      };
      obj2.setBorder = setBorder;
      obj2.init = function() {
        el2.innerHTML = "";
        obj2.headers = document.createElement("div");
        obj2.content = document.createElement("div");
        obj2.headers.classList.add("jtabs-headers");
        obj2.content.classList.add("jtabs-content");
        if (obj2.options.palette) {
          el2.classList.add("jtabs-modern");
        } else {
          el2.classList.remove("jtabs-modern");
        }
        if (obj2.options.padding) {
          obj2.content.style.padding = parseInt(obj2.options.padding) + "px";
        }
        var header = document.createElement("div");
        header.className = "jtabs-headers-container";
        header.appendChild(obj2.headers);
        if (obj2.options.maxWidth) {
          header.style.maxWidth = parseInt(obj2.options.maxWidth) + "px";
        }
        var controls = document.createElement("div");
        controls.className = "jtabs-controls";
        controls.setAttribute("draggable", "false");
        header.appendChild(controls);
        if (obj2.options.position == "bottom") {
          el2.appendChild(obj2.content);
          el2.appendChild(header);
        } else {
          el2.appendChild(header);
          el2.appendChild(obj2.content);
        }
        if (obj2.options.allowCreate == true) {
          var add2 = document.createElement("div");
          add2.className = "jtabs-add";
          add2.onclick = function() {
            obj2.create();
          };
          controls.appendChild(add2);
        }
        prev = document.createElement("div");
        prev.className = "jtabs-prev";
        prev.onclick = function() {
          updateControls(obj2.headers.scrollLeft - obj2.headers.offsetWidth);
        };
        controls.appendChild(prev);
        next2 = document.createElement("div");
        next2.className = "jtabs-next";
        next2.onclick = function() {
          updateControls(obj2.headers.scrollLeft + obj2.headers.offsetWidth);
        };
        controls.appendChild(next2);
        for (var i3 = 0; i3 < obj2.options.data.length; i3++) {
          if (obj2.options.data[i3].titleElement) {
            var headerItem = obj2.options.data[i3].titleElement;
          } else {
            var headerItem = document.createElement("div");
          }
          if (obj2.options.data[i3].icon) {
            var iconContainer = document.createElement("div");
            var icon = document.createElement("i");
            icon.classList.add("material-icons");
            icon.innerHTML = obj2.options.data[i3].icon;
            iconContainer.appendChild(icon);
            headerItem.appendChild(iconContainer);
          }
          if (obj2.options.data[i3].title) {
            var title = document.createTextNode(obj2.options.data[i3].title);
            headerItem.appendChild(title);
          }
          if (obj2.options.data[i3].width) {
            headerItem.style.width = obj2.options.data[i3].width;
          }
          if (obj2.options.data[i3].contentElement) {
            var contentItem = obj2.options.data[i3].contentElement;
          } else {
            var contentItem = document.createElement("div");
            contentItem.innerHTML = obj2.options.data[i3].content;
          }
          obj2.headers.appendChild(headerItem);
          obj2.content.appendChild(contentItem);
        }
        border = document.createElement("div");
        border.className = "jtabs-border";
        obj2.headers.appendChild(border);
        if (obj2.options.animation) {
          el2.classList.add("jtabs-animation");
        }
        obj2.headers.addEventListener("click", function(e) {
          if (e.target.parentNode.classList.contains("jtabs-headers")) {
            var target = e.target;
          } else {
            if (e.target.tagName == "I") {
              var target = e.target.parentNode.parentNode;
            } else {
              var target = e.target.parentNode;
            }
          }
          var index2 = obj2.selectIndex(target);
          if (typeof obj2.options.onclick == "function") {
            obj2.options.onclick(el2, obj2, index2, obj2.headers.children[index2], obj2.content.children[index2]);
          }
        });
        obj2.headers.addEventListener("contextmenu", function(e) {
          obj2.selectIndex(e.target);
        });
        if (obj2.headers.children.length) {
          obj2.open(0);
        }
        updateControls(0);
        if (obj2.options.allowChangePosition == true) {
          jSuites2.sorting(obj2.headers, {
            direction: 1,
            ondrop: function(a, b, c2) {
              obj2.updatePosition(b, c2);
            }
          });
        }
        if (typeof obj2.options.onload == "function") {
          obj2.options.onload(el2, obj2);
        }
      };
      if (el2.children[0] && el2.children[0].children.length) {
        for (var i2 = 0; i2 < el2.children[0].children.length; i2++) {
          var item = obj2.options.data && obj2.options.data[i2] ? obj2.options.data[i2] : {};
          if (el2.children[1] && el2.children[1].children[i2]) {
            item.titleElement = el2.children[0].children[i2];
            item.contentElement = el2.children[1].children[i2];
          } else {
            item.contentElement = el2.children[0].children[i2];
          }
          obj2.options.data[i2] = item;
        }
      }
      var loadingRemoteData = false;
      if (obj2.options.data) {
        for (var i2 = 0; i2 < obj2.options.data.length; i2++) {
          if (obj2.options.data[i2].url) {
            jSuites2.ajax({
              url: obj2.options.data[i2].url,
              type: "GET",
              dataType: "text/html",
              index: i2,
              success: function(result2) {
                obj2.options.data[this.index].content = result2;
              },
              complete: function() {
                obj2.init();
              }
            });
            loadingRemoteData = true;
          }
        }
      }
      if (!loadingRemoteData) {
        obj2.init();
      }
      el2.tabs = obj2;
      return obj2;
    };
    jSuites2.tags = function(el2, options2) {
      if (el2.tags) {
        return el2.tags.setOptions(options2, true);
      }
      var obj2 = { type: "tags" };
      obj2.options = {};
      var limit = function() {
        return obj2.options.limit && el2.children.length >= obj2.options.limit ? true : false;
      };
      var search = null;
      var searchContainer = null;
      obj2.setOptions = function(options3, reset) {
        var defaults2 = {
          value: "",
          limit: null,
          limitMessage: null,
          search: null,
          placeholder: null,
          validation: null,
          onbeforepaste: null,
          onbeforechange: null,
          onlimit: null,
          onchange: null,
          onfocus: null,
          onblur: null,
          onload: null,
          colors: null
        };
        for (var property2 in defaults2) {
          if (options3 && options3.hasOwnProperty(property2)) {
            obj2.options[property2] = options3[property2];
          } else {
            if (typeof obj2.options[property2] == "undefined" || reset === true) {
              obj2.options[property2] = defaults2[property2];
            }
          }
        }
        if (obj2.options.placeholder) {
          el2.setAttribute("data-placeholder", obj2.options.placeholder);
        } else {
          el2.removeAttribute("data-placeholder");
        }
        el2.placeholder = obj2.options.placeholder;
        obj2.setValue(obj2.options.value);
        filter();
        if (obj2.options.search) {
          if (!searchContainer) {
            searchContainer = document.createElement("div");
            el2.parentNode.insertBefore(searchContainer, el2.nextSibling);
            search = jSuites2.search(searchContainer, {
              data: obj2.options.search,
              onselect: function(a, b, c2) {
                obj2.selectIndex(b, c2);
              }
            });
          }
        } else {
          if (searchContainer) {
            search = null;
            searchContainer.remove();
            searchContainer = null;
          }
        }
        return obj2;
      };
      obj2.add = function(value2, focus) {
        if (typeof obj2.options.onbeforechange == "function") {
          var ret = obj2.options.onbeforechange(el2, obj2, obj2.options.value, value2);
          if (ret === false) {
            return false;
          } else {
            if (ret != null) {
              value2 = ret;
            }
          }
        }
        if (search) {
          search.close();
        }
        if (limit()) {
          if (typeof obj2.options.onlimit == "function") {
            obj2.options.onlimit(obj2, obj2.options.limit);
          } else if (obj2.options.limitMessage) {
            alert(obj2.options.limitMessage + " " + obj2.options.limit);
          }
        } else {
          var node = jSuites2.getNode();
          if (node && node.parentNode && node.parentNode.classList.contains("jtags") && node.nextSibling && !(node.nextSibling.innerText && node.nextSibling.innerText.trim())) {
            div2 = node.nextSibling;
          } else {
            if (el2.lastChild) {
              if (!el2.lastChild.innerText.trim()) {
                el2.removeChild(el2.lastChild);
              }
            }
            if (!value2 || typeof value2 == "string") {
              var div2 = createElement2(value2, value2, node);
            } else {
              for (var i2 = 0; i2 <= value2.length; i2++) {
                if (!limit()) {
                  if (!value2[i2] || typeof value2[i2] == "string") {
                    var t = value2[i2] || "";
                    var v = null;
                  } else {
                    var t = value2[i2].text;
                    var v = value2[i2].value;
                  }
                  var div2 = createElement2(t, v);
                }
              }
            }
            change();
          }
          if (focus) {
            setFocus(div2);
          }
        }
      };
      obj2.setLimit = function(limit2) {
        obj2.options.limit = limit2;
        el2.children.length - limit2;
        while (el2.children.length > limit2) {
          el2.removeChild(el2.lastChild);
        }
      };
      obj2.remove = function(node) {
        node.parentNode.removeChild(node);
        if (!el2.children.length) {
          obj2.add("", true);
        } else {
          change();
        }
      };
      obj2.getData = function() {
        var data = [];
        for (var i2 = 0; i2 < el2.children.length; i2++) {
          var text2 = el2.children[i2].innerText.replace("\n", "");
          var value2 = el2.children[i2].getAttribute("data-value");
          if (!value2) {
            value2 = text2;
          }
          if (text2 || value2) {
            data.push({ text: text2, value: value2 });
          }
        }
        return data;
      };
      obj2.getValue = function(index2) {
        var value2 = null;
        if (index2 != null) {
          value2 = el2.children[index2].getAttribute("data-value");
          if (!value2) {
            value2 = el2.children[index2].innerText.replace("\n", "");
          }
        } else {
          var data = [];
          for (var i2 = 0; i2 < el2.children.length; i2++) {
            value2 = el2.children[i2].innerText.replace("\n", "");
            if (value2) {
              data.push(obj2.getValue(i2));
            }
          }
          value2 = data.join(",");
        }
        return value2;
      };
      obj2.setValue = function(mixed) {
        if (!mixed) {
          obj2.reset();
        } else {
          if (el2.value != mixed) {
            if (Array.isArray(mixed)) {
              obj2.add(mixed);
            } else {
              var text2 = ("" + mixed).trim();
              var data = extractTags(text2);
              el2.innerHTML = "";
              obj2.add(data);
            }
          }
        }
      };
      obj2.reset = function() {
        el2.classList.add("jtags-empty");
        el2.innerHTML = "<div></div>";
        change();
      };
      obj2.isValid = function() {
        var test = 0;
        for (var i2 = 0; i2 < el2.children.length; i2++) {
          if (el2.children[i2].classList.contains("jtags_error")) {
            test++;
          }
        }
        return test == 0 ? true : false;
      };
      obj2.selectIndex = function(text2, value2) {
        var node = jSuites2.getNode();
        if (node) {
          node.innerText = text2;
          if (value2) {
            node.setAttribute("data-value", value2);
          }
          node.classList.remove("jtags_error");
          if (!limit()) {
            obj2.add("", true);
          }
        }
      };
      obj2.search = function(node) {
        node.innerText;
      };
      obj2.destroy = function() {
        el2.removeEventListener("mouseup", tagsMouseUp);
        el2.removeEventListener("keydown", tagsKeyDown);
        el2.removeEventListener("keyup", tagsKeyUp);
        el2.removeEventListener("paste", tagsPaste);
        el2.removeEventListener("focus", tagsFocus);
        el2.removeEventListener("blur", tagsBlur);
        el2.parentNode.removeChild(el2);
      };
      var setFocus = function(node) {
        if (el2.children.length > 1) {
          var range2 = document.createRange();
          var sel = window.getSelection();
          if (!node) {
            var node = el2.childNodes[el2.childNodes.length - 1];
          }
          range2.setStart(node, node.length);
          range2.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range2);
          el2.scrollLeft = el2.scrollWidth;
        }
      };
      var createElement2 = function(label, value2, node) {
        var div2 = document.createElement("div");
        div2.innerHTML = label ? label : "";
        if (value2) {
          div2.setAttribute("data-value", value2);
        }
        if (node && node.parentNode.classList.contains("jtags")) {
          el2.insertBefore(div2, node.nextSibling);
        } else {
          el2.appendChild(div2);
        }
        return div2;
      };
      var change = function() {
        var value2 = obj2.getValue();
        if (value2 != obj2.options.value) {
          obj2.options.value = value2;
          if (typeof obj2.options.onchange == "function") {
            obj2.options.onchange(el2, obj2, obj2.options.value);
          }
          if (el2.value != obj2.options.value) {
            el2.value = obj2.options.value;
            if (typeof el2.oninput == "function") {
              el2.oninput({
                type: "input",
                target: el2,
                value: el2.value
              });
            }
          }
        }
        filter();
      };
      var filter = function() {
        for (var i2 = 0; i2 < el2.children.length; i2++) {
          if (!obj2.getValue(i2)) {
            el2.children[i2].classList.remove("jtags_label");
          } else {
            el2.children[i2].classList.add("jtags_label");
            if (typeof obj2.options.validation == "function") {
              if (obj2.getValue(i2)) {
                if (!obj2.options.validation(el2.children[i2], el2.children[i2].innerText, el2.children[i2].getAttribute("data-value"))) {
                  el2.children[i2].classList.add("jtags_error");
                } else {
                  el2.children[i2].classList.remove("jtags_error");
                }
              } else {
                el2.children[i2].classList.remove("jtags_error");
              }
            } else {
              el2.children[i2].classList.remove("jtags_error");
            }
          }
        }
        isEmpty();
      };
      var isEmpty = function() {
        if (!el2.innerText.trim()) {
          el2.innerHTML = "<div></div>";
          el2.classList.add("jtags-empty");
        } else {
          el2.classList.remove("jtags-empty");
        }
      };
      var extractTags = function(text2) {
        var data = [];
        var word = "";
        text2 = text2.trim();
        if (text2) {
          for (var i2 = 0; i2 < text2.length; i2++) {
            if (text2[i2] == "," || text2[i2] == ";" || text2[i2] == "\n") {
              if (word) {
                data.push(word.trim());
                word = "";
              }
            } else {
              word += text2[i2];
            }
          }
          if (word) {
            data.push(word);
          }
        }
        return data;
      };
      var anchorOffset = 0;
      var tagsKeyDown = function(e) {
        anchorOffset = window.getSelection().anchorOffset;
        isEmpty();
        if (e.key === "Tab" || e.key === ";" || e.key === ",") {
          var n2 = window.getSelection().anchorOffset;
          if (n2 > 1) {
            if (limit()) {
              if (typeof obj2.options.onlimit == "function") {
                obj2.options.onlimit(obj2, obj2.options.limit);
              }
            } else {
              obj2.add("", true);
            }
          }
          e.preventDefault();
        } else if (e.key == "Enter") {
          if (!search || !search.isOpened()) {
            var n2 = window.getSelection().anchorOffset;
            if (n2 > 1) {
              if (!limit()) {
                obj2.add("", true);
              }
            }
            e.preventDefault();
          }
        } else if (e.key == "Backspace") {
          if (el2.children.length == 1 && window.getSelection().anchorOffset < 1) {
            e.preventDefault();
          }
        }
        if (search) {
          search.keydown(e);
        }
      };
      var tagsKeyUp = function(e) {
        if (e.which == 39) {
          var n2 = window.getSelection().anchorOffset;
          if (n2 > 1 && n2 == anchorOffset) {
            obj2.add("", true);
          }
        } else if (e.which == 13 || e.which == 38 || e.which == 40) {
          e.preventDefault();
        } else {
          if (search) {
            search.keyup(e);
          }
        }
        filter();
      };
      var tagsPaste = function(e) {
        if (e.clipboardData || e.originalEvent.clipboardData) {
          var text2 = (e.originalEvent || e).clipboardData.getData("text/plain");
        } else if (window.clipboardData) {
          var text2 = window.clipboardData.getData("Text");
        }
        var data = extractTags(text2);
        if (typeof obj2.options.onbeforepaste == "function") {
          var ret = obj2.options.onbeforepaste(el2, obj2, data);
          if (ret === false) {
            e.preventDefault();
            return false;
          } else {
            if (ret) {
              data = ret;
            }
          }
        }
        if (data.length > 1) {
          obj2.add(data, true);
          e.preventDefault();
        } else if (data[0]) {
          document.execCommand("insertText", false, data[0]);
          e.preventDefault();
        }
      };
      var tagsMouseUp = function(e) {
        if (e.target.parentNode && e.target.parentNode.classList.contains("jtags")) {
          if (e.target.classList.contains("jtags_label") || e.target.classList.contains("jtags_error")) {
            var rect = e.target.getBoundingClientRect();
            if (rect.width - (e.clientX - rect.left) < 16) {
              obj2.remove(e.target);
            }
          }
        }
        if (e.target == el2) {
          setFocus();
        }
      };
      var tagsFocus = function() {
        if (!el2.classList.contains("jtags-focus")) {
          if (!el2.children.length || obj2.getValue(el2.children.length - 1)) {
            if (!limit()) {
              createElement2("");
            }
          }
          if (typeof obj2.options.onfocus == "function") {
            obj2.options.onfocus(el2, obj2, obj2.getValue());
          }
          el2.classList.add("jtags-focus");
        }
      };
      var tagsBlur = function() {
        if (el2.classList.contains("jtags-focus")) {
          if (search) {
            search.close();
          }
          for (var i2 = 0; i2 < el2.children.length - 1; i2++) {
            if (!obj2.getValue(i2)) {
              el2.removeChild(el2.children[i2]);
            }
          }
          change();
          el2.classList.remove("jtags-focus");
          if (typeof obj2.options.onblur == "function") {
            obj2.options.onblur(el2, obj2, obj2.getValue());
          }
        }
      };
      var init2 = function() {
        if ("touchend" in document.documentElement === true) {
          el2.addEventListener("touchend", tagsMouseUp);
        } else {
          el2.addEventListener("mouseup", tagsMouseUp);
        }
        el2.addEventListener("keydown", tagsKeyDown);
        el2.addEventListener("keyup", tagsKeyUp);
        el2.addEventListener("paste", tagsPaste);
        el2.addEventListener("focus", tagsFocus);
        el2.addEventListener("blur", tagsBlur);
        el2.setAttribute("contenteditable", true);
        el2.classList.add("jtags");
        obj2.setOptions(options2);
        if (typeof obj2.options.onload == "function") {
          obj2.options.onload(el2, obj2);
        }
        el2.change = obj2.setValue;
        el2.val = function(val) {
          if (val === void 0) {
            return obj2.getValue();
          } else {
            obj2.setValue(val);
          }
        };
        el2.tags = obj2;
      };
      init2();
      return obj2;
    };
    jSuites2.toolbar = function(el2, options2) {
      var obj2 = { type: "toolbar" };
      obj2.options = {};
      var defaults2 = {
        app: null,
        container: false,
        badge: false,
        title: false,
        responsive: false,
        maxWidth: null,
        bottom: true,
        items: []
      };
      for (var property2 in defaults2) {
        if (options2 && options2.hasOwnProperty(property2)) {
          obj2.options[property2] = options2[property2];
        } else {
          obj2.options[property2] = defaults2[property2];
        }
      }
      if (!el2 && options2.app && options2.app.el) {
        el2 = document.createElement("div");
        options2.app.el.appendChild(el2);
      }
      var toolbarArrow = document.createElement("div");
      toolbarArrow.classList.add("jtoolbar-item");
      toolbarArrow.classList.add("jtoolbar-arrow");
      var toolbarFloating = document.createElement("div");
      toolbarFloating.classList.add("jtoolbar-floating");
      toolbarArrow.appendChild(toolbarFloating);
      obj2.selectItem = function(element2) {
        var elements2 = toolbarContent.children;
        for (var i2 = 0; i2 < elements2.length; i2++) {
          if (element2 != elements2[i2]) {
            elements2[i2].classList.remove("jtoolbar-selected");
          }
        }
        element2.classList.add("jtoolbar-selected");
      };
      obj2.hide = function() {
        jSuites2.animation.slideBottom(el2, 0, function() {
          el2.style.display = "none";
        });
      };
      obj2.show = function() {
        el2.style.display = "";
        jSuites2.animation.slideBottom(el2, 1);
      };
      obj2.get = function() {
        return el2;
      };
      obj2.setBadge = function(index2, value2) {
        toolbarContent.children[index2].children[1].firstChild.innerHTML = value2;
      };
      obj2.destroy = function() {
        toolbar.remove();
        el2.innerHTML = "";
      };
      obj2.update = function(a, b) {
        for (var i2 = 0; i2 < toolbarContent.children.length; i2++) {
          var toolbarItem = toolbarContent.children[i2];
          if (typeof toolbarItem.updateState == "function") {
            toolbarItem.updateState(el2, obj2, toolbarItem, a, b);
          }
        }
      };
      obj2.create = function(items) {
        toolbarContent.innerHTML = "";
        for (var i2 = 0; i2 < items.length; i2++) {
          var toolbarItem = document.createElement("div");
          toolbarItem.classList.add("jtoolbar-item");
          if (items[i2].width) {
            toolbarItem.style.width = parseInt(items[i2].width) + "px";
          }
          if (items[i2].k) {
            toolbarItem.k = items[i2].k;
          }
          if (items[i2].tooltip) {
            toolbarItem.setAttribute("title", items[i2].tooltip);
          }
          if (items[i2].id) {
            toolbarItem.setAttribute("id", items[i2].id);
          }
          if (items[i2].updateState) {
            toolbarItem.updateState = items[i2].updateState;
          }
          if (items[i2].active) {
            toolbarItem.classList.add("jtoolbar-active");
          }
          if (items[i2].type == "select" || items[i2].type == "dropdown") {
            jSuites2.picker(toolbarItem, items[i2]);
          } else if (items[i2].type == "divisor") {
            toolbarItem.classList.add("jtoolbar-divisor");
          } else if (items[i2].type == "label") {
            toolbarItem.classList.add("jtoolbar-label");
            toolbarItem.innerHTML = items[i2].content;
          } else {
            var toolbarIcon = document.createElement("i");
            if (typeof items[i2].class === "undefined") {
              toolbarIcon.classList.add("material-icons");
            } else {
              var c2 = items[i2].class.split(" ");
              for (var j2 = 0; j2 < c2.length; j2++) {
                toolbarIcon.classList.add(c2[j2]);
              }
            }
            toolbarIcon.innerHTML = items[i2].content ? items[i2].content : "";
            toolbarItem.appendChild(toolbarIcon);
            if (obj2.options.badge == true) {
              var toolbarBadge = document.createElement("div");
              toolbarBadge.classList.add("jbadge");
              var toolbarBadgeContent = document.createElement("div");
              toolbarBadgeContent.innerHTML = items[i2].badge ? items[i2].badge : "";
              toolbarBadge.appendChild(toolbarBadgeContent);
              toolbarItem.appendChild(toolbarBadge);
            }
            if (items[i2].title) {
              if (obj2.options.title == true) {
                var toolbarTitle = document.createElement("span");
                toolbarTitle.innerHTML = items[i2].title;
                toolbarItem.appendChild(toolbarTitle);
              } else {
                toolbarItem.setAttribute("title", items[i2].title);
              }
            }
            if (obj2.options.app && items[i2].route) {
              toolbarItem.route = items[i2].route;
              toolbarItem.onclick = function() {
                obj2.options.app.pages(this.route);
              };
              obj2.options.app.pages(items[i2].route, {
                toolbarItem,
                closed: true
              });
            }
          }
          if (items[i2].onclick) {
            toolbarItem.onclick = items[i2].onclick.bind(items[i2], el2, obj2, toolbarItem);
          }
          toolbarContent.appendChild(toolbarItem);
        }
        setTimeout(function() {
          obj2.refresh();
        }, 0);
      };
      obj2.open = function() {
        toolbarArrow.classList.add("jtoolbar-arrow-selected");
        el2.getBoundingClientRect();
        var rect = toolbarFloating.getBoundingClientRect();
        if (rect.bottom > window.innerHeight || obj2.options.bottom) {
          toolbarFloating.style.bottom = "0";
        } else {
          toolbarFloating.style.removeProperty("bottom");
        }
        toolbarFloating.style.right = "0";
        toolbarArrow.children[0].focus();
        jSuites2.tracking(obj2, true);
      };
      obj2.close = function() {
        toolbarArrow.classList.remove("jtoolbar-arrow-selected");
        jSuites2.tracking(obj2, false);
      };
      obj2.refresh = function() {
        if (obj2.options.responsive == true) {
          var rect = el2.parentNode.getBoundingClientRect();
          if (!obj2.options.maxWidth) {
            obj2.options.maxWidth = rect.width;
          }
          var available = parseInt(obj2.options.maxWidth);
          toolbarArrow.remove();
          while (toolbarFloating.firstChild) {
            toolbarContent.appendChild(toolbarFloating.firstChild);
          }
          if (available < toolbarContent.offsetWidth) {
            available -= 50;
            while (toolbarContent.lastChild && available < toolbarContent.offsetWidth) {
              toolbarFloating.insertBefore(toolbarContent.lastChild, toolbarFloating.firstChild);
            }
          }
          if (toolbarFloating.children.length > 0) {
            toolbarContent.appendChild(toolbarArrow);
          }
        }
      };
      el2.onclick = function(e) {
        var element2 = jSuites2.findElement(e.target, "jtoolbar-item");
        if (element2) {
          obj2.selectItem(element2);
        }
        if (e.target.classList.contains("jtoolbar-arrow")) {
          obj2.open();
        }
      };
      window.addEventListener("resize", function() {
        obj2.refresh();
      });
      el2.classList.add("jtoolbar");
      el2.innerHTML = "";
      if (obj2.options.container == true) {
        el2.classList.add("jtoolbar-container");
      }
      var toolbarContent = document.createElement("div");
      el2.appendChild(toolbarContent);
      if (obj2.options.app) {
        el2.classList.add("jtoolbar-mobile");
      }
      obj2.create(obj2.options.items);
      el2.toolbar = obj2;
      return obj2;
    };
    jSuites2.validations = function(value2, options2) {
      if (typeof jSuites2.validations[options2.type] === "function") {
        return jSuites2.validations[options2.type](value2, options2);
      }
      return null;
    };
    jSuites2.validations.email = function(data) {
      var pattern = new RegExp(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
      return data && pattern.test(data) ? true : false;
    };
    jSuites2.validations.required = function(data) {
      return data.trim() ? true : false;
    };
    jSuites2.validations.number = function(data) {
      return jSuites2.isNumber(data);
    };
    jSuites2.validations.login = function(data) {
      var pattern = new RegExp(/^[a-zA-Z0-9\_\-\.\s+]+$/);
      return data && pattern.test(data) ? true : false;
    };
    var valueComparisons = function(data, options2) {
      if (options2.constraint === "=") {
        return data === options2.reference;
      }
      if (options2.constraint === "<") {
        return data < options2.reference;
      }
      if (options2.constraint === "<=") {
        return data <= options2.reference;
      }
      if (options2.constraint === ">") {
        return data > options2.reference;
      }
      if (options2.constraint === ">=") {
        return data >= options2.reference;
      }
      if (options2.constraint === "between") {
        return data >= options2.reference[0] && data <= options2.reference[1];
      }
      if (options2.constraint === "not between") {
        return data < options2.reference[0] || data > options2.reference[1];
      }
      return null;
    };
    jSuites2.validations.number = function(data, options2) {
      if (!jSuites2.isNumeric(data)) {
        return false;
      }
      if (options2 === void 0 || options2.constraint === void 0) {
        return true;
      }
      return valueComparisons(data, options2);
    };
    jSuites2.validations.date = function(data, options2) {
      if (new Date(data) == "Invalid Date") {
        return false;
      }
      if (options2 === void 0 || options2.constraint === void 0) {
        return true;
      } else if (typeof options2 === "object") {
        data = new Date(data).getTime();
        if (Array.isArray(options2.reference)) {
          options2.reference = options2.reference.map(function(reference) {
            return new Date(reference).getTime();
          });
        } else {
          options2.reference = new Date(options2.reference).getTime();
        }
        return valueComparisons(data, options2);
      }
      return null;
    };
    jSuites2.validations.itemList = function(data, options2) {
      return options2.reference.some(function(reference) {
        return reference == data;
      });
    };
    jSuites2.validations.text = function(data, options2) {
      if (typeof data !== "string") {
        return false;
      }
      if (options2 === void 0 || options2.constraint === void 0) {
        return true;
      }
      if (options2.constraint === "=") {
        return data === options2.reference;
      }
      if (options2.constraint === "contains") {
        return data.includes(options2.reference);
      }
      if (options2.constraint === "not contain") {
        return !data.includes(options2.reference);
      }
      if (options2.constraint === "email") {
        return jSuites2.validations.email(data);
      }
      if (options2.constraint === "url") {
        var pattern = new RegExp(/(((https?:\/\/)|(www\.))[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]+)/ig);
        return pattern.test(data) ? true : false;
      }
      return null;
    };
    jSuites2.validations.constraints = function() {
    };
    return jSuites2;
  });
})(jsuites$1);
(function(module, exports) {
  var formula = function() {
    var error = function() {
      var exports2 = {};
      exports2.nil = new Error("#NULL!");
      exports2.div0 = new Error("#DIV/0!");
      exports2.value = new Error("#VALUE!");
      exports2.ref = new Error("#REF!");
      exports2.name = new Error("#NAME?");
      exports2.num = new Error("#NUM!");
      exports2.na = new Error("#N/A");
      exports2.error = new Error("#ERROR!");
      exports2.data = new Error("#GETTING_DATA");
      return exports2;
    }();
    var utils = function() {
      var exports2 = {};
      exports2.flattenShallow = function(array) {
        if (!array || !array.reduce) {
          return array;
        }
        return array.reduce(function(a, b) {
          var aIsArray = Array.isArray(a);
          var bIsArray = Array.isArray(b);
          if (aIsArray && bIsArray) {
            return a.concat(b);
          }
          if (aIsArray) {
            a.push(b);
            return a;
          }
          if (bIsArray) {
            return [a].concat(b);
          }
          return [a, b];
        });
      };
      exports2.isFlat = function(array) {
        if (!array) {
          return false;
        }
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (Array.isArray(array[i2])) {
            return false;
          }
        }
        return true;
      };
      exports2.flatten = function() {
        var result2 = exports2.argsToArray.apply(null, arguments);
        while (!exports2.isFlat(result2)) {
          result2 = exports2.flattenShallow(result2);
        }
        return result2;
      };
      exports2.argsToArray = function(args2) {
        var result2 = [];
        exports2.arrayEach(args2, function(value2) {
          result2.push(value2);
        });
        return result2;
      };
      exports2.numbers = function() {
        var possibleNumbers = this.flatten.apply(null, arguments);
        return possibleNumbers.filter(function(el2) {
          return typeof el2 === "number";
        });
      };
      exports2.cleanFloat = function(number2) {
        var power = 1e14;
        return Math.round(number2 * power) / power;
      };
      exports2.parseBool = function(bool2) {
        if (typeof bool2 === "boolean") {
          return bool2;
        }
        if (bool2 instanceof Error) {
          return bool2;
        }
        if (typeof bool2 === "number") {
          return bool2 !== 0;
        }
        if (typeof bool2 === "string") {
          var up = bool2.toUpperCase();
          if (up === "TRUE") {
            return true;
          }
          if (up === "FALSE") {
            return false;
          }
        }
        if (bool2 instanceof Date && !isNaN(bool2)) {
          return true;
        }
        return error.value;
      };
      exports2.parseNumber = function(string) {
        if (string === void 0 || string === "") {
          return error.value;
        }
        if (!isNaN(string)) {
          return parseFloat(string);
        }
        return error.value;
      };
      exports2.parseNumberArray = function(arr) {
        var len;
        if (!arr || (len = arr.length) === 0) {
          return error.value;
        }
        var parsed;
        while (len--) {
          parsed = exports2.parseNumber(arr[len]);
          if (parsed === error.value) {
            return parsed;
          }
          arr[len] = parsed;
        }
        return arr;
      };
      exports2.parseMatrix = function(matrix2) {
        if (!matrix2 || matrix2.length === 0) {
          return error.value;
        }
        var pnarr;
        for (var i2 = 0; i2 < matrix2.length; i2++) {
          pnarr = exports2.parseNumberArray(matrix2[i2]);
          matrix2[i2] = pnarr;
          if (pnarr instanceof Error) {
            return pnarr;
          }
        }
        return matrix2;
      };
      var d1900 = new Date(Date.UTC(1900, 0, 1));
      exports2.parseDate = function(date) {
        if (!isNaN(date)) {
          if (date instanceof Date) {
            return new Date(date);
          }
          var d = parseInt(date, 10);
          if (d < 0) {
            return error.num;
          }
          if (d <= 60) {
            return new Date(d1900.getTime() + (d - 1) * 864e5);
          }
          return new Date(d1900.getTime() + (d - 2) * 864e5);
        }
        if (typeof date === "string") {
          date = new Date(date);
          if (!isNaN(date)) {
            return date;
          }
        }
        return error.value;
      };
      exports2.parseDateArray = function(arr) {
        var len = arr.length;
        var parsed;
        while (len--) {
          parsed = this.parseDate(arr[len]);
          if (parsed === error.value) {
            return parsed;
          }
          arr[len] = parsed;
        }
        return arr;
      };
      exports2.anyIsError = function() {
        var n2 = arguments.length;
        while (n2--) {
          if (arguments[n2] instanceof Error) {
            return true;
          }
        }
        return false;
      };
      exports2.arrayValuesToNumbers = function(arr) {
        var n2 = arr.length;
        var el2;
        while (n2--) {
          el2 = arr[n2];
          if (typeof el2 === "number") {
            continue;
          }
          if (el2 === true) {
            arr[n2] = 1;
            continue;
          }
          if (el2 === false) {
            arr[n2] = 0;
            continue;
          }
          if (typeof el2 === "string") {
            var number2 = this.parseNumber(el2);
            if (number2 instanceof Error) {
              arr[n2] = 0;
            } else {
              arr[n2] = number2;
            }
          }
        }
        return arr;
      };
      exports2.rest = function(array, idx) {
        idx = idx || 1;
        if (!array || typeof array.slice !== "function") {
          return array;
        }
        return array.slice(idx);
      };
      exports2.initial = function(array, idx) {
        idx = idx || 1;
        if (!array || typeof array.slice !== "function") {
          return array;
        }
        return array.slice(0, array.length - idx);
      };
      exports2.arrayEach = function(array, iteratee) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      };
      exports2.transpose = function(matrix2) {
        if (!matrix2) {
          return error.value;
        }
        return matrix2[0].map(function(col, i2) {
          return matrix2.map(function(row) {
            return row[i2];
          });
        });
      };
      return exports2;
    }();
    var met = {};
    met.datetime = function() {
      var exports2 = {};
      var d1900 = new Date(1900, 0, 1);
      var WEEK_TYPES = [
        [],
        [1, 2, 3, 4, 5, 6, 7],
        [7, 1, 2, 3, 4, 5, 6],
        [6, 0, 1, 2, 3, 4, 5],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [7, 1, 2, 3, 4, 5, 6],
        [6, 7, 1, 2, 3, 4, 5],
        [5, 6, 7, 1, 2, 3, 4],
        [4, 5, 6, 7, 1, 2, 3],
        [3, 4, 5, 6, 7, 1, 2],
        [2, 3, 4, 5, 6, 7, 1],
        [1, 2, 3, 4, 5, 6, 7]
      ];
      exports2.DATE = function(year, month, day) {
        year = utils.parseNumber(year);
        month = utils.parseNumber(month);
        day = utils.parseNumber(day);
        if (utils.anyIsError(year, month, day)) {
          return error.value;
        }
        if (year < 0 || month < 0 || day < 0) {
          return error.num;
        }
        var date = new Date(year, month - 1, day);
        return date;
      };
      exports2.DATEVALUE = function(date_text) {
        if (typeof date_text !== "string") {
          return error.value;
        }
        var date = Date.parse(date_text);
        if (isNaN(date)) {
          return error.value;
        }
        if (date <= -22038912e5) {
          return (date - d1900) / 864e5 + 1;
        }
        return (date - d1900) / 864e5 + 2;
      };
      exports2.DAY = function(serial_number) {
        var date = utils.parseDate(serial_number);
        if (date instanceof Error) {
          return date;
        }
        return date.getDate();
      };
      exports2.DAYS = function(end_date, start_date) {
        end_date = utils.parseDate(end_date);
        start_date = utils.parseDate(start_date);
        if (end_date instanceof Error) {
          return end_date;
        }
        if (start_date instanceof Error) {
          return start_date;
        }
        return serial(end_date) - serial(start_date);
      };
      exports2.DAYS360 = function(start_date, end_date, method) {
      };
      exports2.EDATE = function(start_date, months) {
        start_date = utils.parseDate(start_date);
        if (start_date instanceof Error) {
          return start_date;
        }
        if (isNaN(months)) {
          return error.value;
        }
        months = parseInt(months, 10);
        start_date.setMonth(start_date.getMonth() + months);
        return serial(start_date);
      };
      exports2.EOMONTH = function(start_date, months) {
        start_date = utils.parseDate(start_date);
        if (start_date instanceof Error) {
          return start_date;
        }
        if (isNaN(months)) {
          return error.value;
        }
        months = parseInt(months, 10);
        return serial(new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0));
      };
      exports2.HOUR = function(serial_number) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        return serial_number.getHours();
      };
      exports2.INTERVAL = function(second) {
        if (typeof second !== "number" && typeof second !== "string") {
          return error.value;
        } else {
          second = parseInt(second, 10);
        }
        var year = Math.floor(second / 94608e4);
        second = second % 94608e4;
        var month = Math.floor(second / 2592e3);
        second = second % 2592e3;
        var day = Math.floor(second / 86400);
        second = second % 86400;
        var hour = Math.floor(second / 3600);
        second = second % 3600;
        var min = Math.floor(second / 60);
        second = second % 60;
        var sec = second;
        year = year > 0 ? year + "Y" : "";
        month = month > 0 ? month + "M" : "";
        day = day > 0 ? day + "D" : "";
        hour = hour > 0 ? hour + "H" : "";
        min = min > 0 ? min + "M" : "";
        sec = sec > 0 ? sec + "S" : "";
        return "P" + year + month + day + "T" + hour + min + sec;
      };
      exports2.ISOWEEKNUM = function(date) {
        date = utils.parseDate(date);
        if (date instanceof Error) {
          return date;
        }
        date.setHours(0, 0, 0);
        date.setDate(date.getDate() + 4 - (date.getDay() || 7));
        var yearStart = new Date(date.getFullYear(), 0, 1);
        return Math.ceil(((date - yearStart) / 864e5 + 1) / 7);
      };
      exports2.MINUTE = function(serial_number) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        return serial_number.getMinutes();
      };
      exports2.MONTH = function(serial_number) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        return serial_number.getMonth() + 1;
      };
      exports2.NETWORKDAYS = function(start_date, end_date, holidays) {
      };
      exports2.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
      };
      exports2.NOW = function() {
        return new Date();
      };
      exports2.SECOND = function(serial_number) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        return serial_number.getSeconds();
      };
      exports2.TIME = function(hour, minute, second) {
        hour = utils.parseNumber(hour);
        minute = utils.parseNumber(minute);
        second = utils.parseNumber(second);
        if (utils.anyIsError(hour, minute, second)) {
          return error.value;
        }
        if (hour < 0 || minute < 0 || second < 0) {
          return error.num;
        }
        return (3600 * hour + 60 * minute + second) / 86400;
      };
      exports2.TIMEVALUE = function(time_text) {
        time_text = utils.parseDate(time_text);
        if (time_text instanceof Error) {
          return time_text;
        }
        return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;
      };
      exports2.TODAY = function() {
        return new Date();
      };
      exports2.WEEKDAY = function(serial_number, return_type) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        if (return_type === void 0) {
          return_type = 1;
        }
        var day = serial_number.getDay();
        return WEEK_TYPES[return_type][day];
      };
      exports2.WEEKNUM = function(serial_number, return_type) {
      };
      exports2.WORKDAY = function(start_date, days, holidays) {
      };
      exports2.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
      };
      exports2.YEAR = function(serial_number) {
        serial_number = utils.parseDate(serial_number);
        if (serial_number instanceof Error) {
          return serial_number;
        }
        return serial_number.getFullYear();
      };
      exports2.YEARFRAC = function(start_date, end_date, basis) {
      };
      function serial(date) {
        var addOn = date > -22038912e5 ? 2 : 1;
        return (date - d1900) / 864e5 + addOn;
      }
      return exports2;
    }();
    met.database = function() {
      var exports = {};
      function compact(array) {
        if (!array) {
          return array;
        }
        var result2 = [];
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (!array[i2]) {
            continue;
          }
          result2.push(array[i2]);
        }
        return result2;
      }
      exports.FINDFIELD = function(database2, title) {
        var index2 = null;
        for (var i2 = 0; i2 < database2.length; i2++) {
          if (database2[i2][0] === title) {
            index2 = i2;
            break;
          }
        }
        if (index2 == null) {
          return error.value;
        }
        return index2;
      };
      function findResultIndex(database, criterias) {
        var matches = {};
        for (var i = 1; i < database[0].length; ++i) {
          matches[i] = true;
        }
        var maxCriteriaLength = criterias[0].length;
        for (i = 1; i < criterias.length; ++i) {
          if (criterias[i].length > maxCriteriaLength) {
            maxCriteriaLength = criterias[i].length;
          }
        }
        for (var k = 1; k < database.length; ++k) {
          for (var l = 1; l < database[k].length; ++l) {
            var currentCriteriaResult = false;
            var hasMatchingCriteria = false;
            for (var j = 0; j < criterias.length; ++j) {
              var criteria = criterias[j];
              if (criteria.length < maxCriteriaLength) {
                continue;
              }
              var criteriaField = criteria[0];
              if (database[k][0] !== criteriaField) {
                continue;
              }
              hasMatchingCriteria = true;
              for (var p = 1; p < criteria.length; ++p) {
                currentCriteriaResult = currentCriteriaResult || eval(database[k][l] + criteria[p]);
              }
            }
            if (hasMatchingCriteria) {
              matches[l] = matches[l] && currentCriteriaResult;
            }
          }
        }
        var result = [];
        for (var n = 0; n < database[0].length; ++n) {
          if (matches[n]) {
            result.push(n - 1);
          }
        }
        return result;
      }
      exports.DAVERAGE = function(database2, field, criteria2) {
        if (isNaN(field) && typeof field !== "string") {
          return error.value;
        }
        var resultIndexes = findResultIndex(database2, criteria2);
        var targetFields = [];
        if (typeof field === "string") {
          var index2 = exports.FINDFIELD(database2, field);
          targetFields = utils.rest(database2[index2]);
        } else {
          targetFields = utils.rest(database2[field]);
        }
        var sum = 0;
        for (var i2 = 0; i2 < resultIndexes.length; i2++) {
          sum += targetFields[resultIndexes[i2]];
        }
        return resultIndexes.length === 0 ? error.div0 : sum / resultIndexes.length;
      };
      exports.DCOUNT = function(database2, field, criteria2) {
      };
      exports.DCOUNTA = function(database2, field, criteria2) {
      };
      exports.DGET = function(database2, field, criteria2) {
        if (isNaN(field) && typeof field !== "string") {
          return error.value;
        }
        var resultIndexes = findResultIndex(database2, criteria2);
        var targetFields = [];
        if (typeof field === "string") {
          var index2 = exports.FINDFIELD(database2, field);
          targetFields = utils.rest(database2[index2]);
        } else {
          targetFields = utils.rest(database2[field]);
        }
        if (resultIndexes.length === 0) {
          return error.value;
        }
        if (resultIndexes.length > 1) {
          return error.num;
        }
        return targetFields[resultIndexes[0]];
      };
      exports.DMAX = function(database2, field, criteria2) {
        if (isNaN(field) && typeof field !== "string") {
          return error.value;
        }
        var resultIndexes = findResultIndex(database2, criteria2);
        var targetFields = [];
        if (typeof field === "string") {
          var index2 = exports.FINDFIELD(database2, field);
          targetFields = utils.rest(database2[index2]);
        } else {
          targetFields = utils.rest(database2[field]);
        }
        var maxValue = targetFields[resultIndexes[0]];
        for (var i2 = 1; i2 < resultIndexes.length; i2++) {
          if (maxValue < targetFields[resultIndexes[i2]]) {
            maxValue = targetFields[resultIndexes[i2]];
          }
        }
        return maxValue;
      };
      exports.DMIN = function(database2, field, criteria2) {
        if (isNaN(field) && typeof field !== "string") {
          return error.value;
        }
        var resultIndexes = findResultIndex(database2, criteria2);
        var targetFields = [];
        if (typeof field === "string") {
          var index2 = exports.FINDFIELD(database2, field);
          targetFields = utils.rest(database2[index2]);
        } else {
          targetFields = utils.rest(database2[field]);
        }
        var minValue = targetFields[resultIndexes[0]];
        for (var i2 = 1; i2 < resultIndexes.length; i2++) {
          if (minValue > targetFields[resultIndexes[i2]]) {
            minValue = targetFields[resultIndexes[i2]];
          }
        }
        return minValue;
      };
      exports.DPRODUCT = function(database2, field, criteria2) {
        if (isNaN(field) && typeof field !== "string") {
          return error.value;
        }
        var resultIndexes = findResultIndex(database2, criteria2);
        var targetFields = [];
        if (typeof field === "string") {
          var index2 = exports.FINDFIELD(database2, field);
          targetFields = utils.rest(database2[index2]);
        } else {
          targetFields = utils.rest(database2[field]);
        }
        var targetValues = [];
        for (var i2 = 0; i2 < resultIndexes.length; i2++) {
          targetValues[i2] = targetFields[resultIndexes[i2]];
        }
        targetValues = compact(targetValues);
        var result2 = 1;
        for (i2 = 0; i2 < targetValues.length; i2++) {
          result2 *= targetValues[i2];
        }
        return result2;
      };
      exports.DSTDEV = function(database2, field, criteria2) {
      };
      exports.DSTDEVP = function(database2, field, criteria2) {
      };
      exports.DSUM = function(database2, field, criteria2) {
      };
      exports.DVAR = function(database2, field, criteria2) {
      };
      exports.DVARP = function(database2, field, criteria2) {
      };
      exports.MATCH = function(lookupValue, lookupArray, matchType) {
        if (!lookupValue && !lookupArray) {
          return error.na;
        }
        if (arguments.length === 2) {
          matchType = 1;
        }
        if (!(lookupArray instanceof Array)) {
          return error.na;
        }
        if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
          return error.na;
        }
        var index2;
        var indexValue;
        for (var idx = 0; idx < lookupArray.length; idx++) {
          if (matchType === 1) {
            if (lookupArray[idx] === lookupValue) {
              return idx + 1;
            } else if (lookupArray[idx] < lookupValue) {
              if (!indexValue) {
                index2 = idx + 1;
                indexValue = lookupArray[idx];
              } else if (lookupArray[idx] > indexValue) {
                index2 = idx + 1;
                indexValue = lookupArray[idx];
              }
            }
          } else if (matchType === 0) {
            if (typeof lookupValue === "string") {
              lookupValue = lookupValue.replace(/\?/g, ".");
              if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
                return idx + 1;
              }
            } else {
              if (lookupArray[idx] === lookupValue) {
                return idx + 1;
              }
            }
          } else if (matchType === -1) {
            if (lookupArray[idx] === lookupValue) {
              return idx + 1;
            } else if (lookupArray[idx] > lookupValue) {
              if (!indexValue) {
                index2 = idx + 1;
                indexValue = lookupArray[idx];
              } else if (lookupArray[idx] < indexValue) {
                index2 = idx + 1;
                indexValue = lookupArray[idx];
              }
            }
          }
        }
        return index2 ? index2 : error.na;
      };
      return exports;
    }();
    met.engineering = function() {
      var exports2 = {};
      function isValidBinaryNumber(number2) {
        return /^[01]{1,10}$/.test(number2);
      }
      exports2.BESSELI = function(x2, n2) {
      };
      exports2.BESSELJ = function(x2, n2) {
      };
      exports2.BESSELK = function(x2, n2) {
      };
      exports2.BESSELY = function(x2, n2) {
      };
      exports2.BIN2DEC = function(number2) {
        if (!isValidBinaryNumber(number2)) {
          return error.num;
        }
        var result2 = parseInt(number2, 2);
        var stringified = number2.toString();
        if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
          return parseInt(stringified.substring(1), 2) - 512;
        } else {
          return result2;
        }
      };
      exports2.BIN2HEX = function(number2, places) {
        if (!isValidBinaryNumber(number2)) {
          return error.num;
        }
        var stringified = number2.toString();
        if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
          return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
        }
        var result2 = parseInt(number2, 2).toString(16);
        if (places === void 0) {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.BIN2OCT = function(number2, places) {
        if (!isValidBinaryNumber(number2)) {
          return error.num;
        }
        var stringified = number2.toString();
        if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
          return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
        }
        var result2 = parseInt(number2, 2).toString(8);
        if (places === void 0) {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.BITAND = function(number1, number2) {
        number1 = utils.parseNumber(number1);
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(number1, number2)) {
          return error.value;
        }
        if (number1 < 0 || number2 < 0) {
          return error.num;
        }
        if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
          return error.num;
        }
        if (number1 > 281474976710655 || number2 > 281474976710655) {
          return error.num;
        }
        return number1 & number2;
      };
      exports2.BITLSHIFT = function(number2, shift) {
        number2 = utils.parseNumber(number2);
        shift = utils.parseNumber(shift);
        if (utils.anyIsError(number2, shift)) {
          return error.value;
        }
        if (number2 < 0) {
          return error.num;
        }
        if (Math.floor(number2) !== number2) {
          return error.num;
        }
        if (number2 > 281474976710655) {
          return error.num;
        }
        if (Math.abs(shift) > 53) {
          return error.num;
        }
        return shift >= 0 ? number2 << shift : number2 >> -shift;
      };
      exports2.BITOR = function(number1, number2) {
        number1 = utils.parseNumber(number1);
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(number1, number2)) {
          return error.value;
        }
        if (number1 < 0 || number2 < 0) {
          return error.num;
        }
        if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
          return error.num;
        }
        if (number1 > 281474976710655 || number2 > 281474976710655) {
          return error.num;
        }
        return number1 | number2;
      };
      exports2.BITRSHIFT = function(number2, shift) {
        number2 = utils.parseNumber(number2);
        shift = utils.parseNumber(shift);
        if (utils.anyIsError(number2, shift)) {
          return error.value;
        }
        if (number2 < 0) {
          return error.num;
        }
        if (Math.floor(number2) !== number2) {
          return error.num;
        }
        if (number2 > 281474976710655) {
          return error.num;
        }
        if (Math.abs(shift) > 53) {
          return error.num;
        }
        return shift >= 0 ? number2 >> shift : number2 << -shift;
      };
      exports2.BITXOR = function(number1, number2) {
        number1 = utils.parseNumber(number1);
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(number1, number2)) {
          return error.value;
        }
        if (number1 < 0 || number2 < 0) {
          return error.num;
        }
        if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
          return error.num;
        }
        if (number1 > 281474976710655 || number2 > 281474976710655) {
          return error.num;
        }
        return number1 ^ number2;
      };
      exports2.COMPLEX = function(real, imaginary, suffix) {
        real = utils.parseNumber(real);
        imaginary = utils.parseNumber(imaginary);
        if (utils.anyIsError(real, imaginary)) {
          return real;
        }
        suffix = suffix === void 0 ? "i" : suffix;
        if (suffix !== "i" && suffix !== "j") {
          return error.value;
        }
        if (real === 0 && imaginary === 0) {
          return 0;
        } else if (real === 0) {
          return imaginary === 1 ? suffix : imaginary.toString() + suffix;
        } else if (imaginary === 0) {
          return real.toString();
        } else {
          var sign = imaginary > 0 ? "+" : "";
          return real.toString() + sign + (imaginary === 1 ? suffix : imaginary.toString() + suffix);
        }
      };
      exports2.CONVERT = function(number2, from_unit, to_unit) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var units = [
          ["a.u. of action", "?", null, "action", false, false, 105457168181818e-48],
          ["a.u. of charge", "e", null, "electric_charge", false, false, 160217653141414e-33],
          ["a.u. of energy", "Eh", null, "energy", false, false, 435974417757576e-32],
          ["a.u. of length", "a?", null, "length", false, false, 529177210818182e-25],
          ["a.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
          ["a.u. of time", "?/Eh", null, "time", false, false, 241888432650516e-31],
          ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
          ["ampere", "A", null, "electric_current", true, false, 1],
          ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
          ["\xE5ngstr\xF6m", "\xC5", ["ang"], "length", false, true, 1e-10],
          ["are", "ar", null, "area", false, true, 100],
          ["astronomical unit", "ua", null, "length", false, false, 149597870691667e-25],
          ["bar", "bar", null, "pressure", false, false, 1e5],
          ["barn", "b", null, "area", false, false, 1e-28],
          ["becquerel", "Bq", null, "radioactivity", true, false, 1],
          ["bit", "bit", ["b"], "information", false, true, 1],
          ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
          ["byte", "byte", null, "information", false, true, 8],
          ["candela", "cd", null, "luminous_intensity", true, false, 1],
          ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
          ["coulomb", "C", null, "electric_charge", true, false, 1],
          ["cubic \xE5ngstr\xF6m", "ang3", ["ang^3"], "volume", false, true, 1e-30],
          ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
          ["cubic inch", "in3", ["in^3"], "volume", false, true, 16387064e-12],
          ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 846786664623715e-61],
          ["cubic metre", "m?", null, "volume", true, true, 1],
          ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 416818182544058e-5],
          ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
          ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 758660370370369e-22],
          ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
          ["cup", "cup", null, "volume", false, true, 2365882365e-13],
          ["dalton", "Da", ["u"], "mass", false, false, 166053886282828e-41],
          ["day", "d", ["day"], "time", false, true, 86400],
          ["degree", "\xB0", null, "angle", false, false, 0.0174532925199433],
          ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
          ["dyne", "dyn", ["dy"], "force", false, true, 1e-5],
          ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
          ["ell", "ell", null, "length", false, true, 1.143],
          ["erg", "erg", ["e"], "energy", false, true, 1e-7],
          ["farad", "F", null, "electric_capacitance", true, false, 1],
          ["fluid ounce", "oz", null, "volume", false, true, 295735295625e-16],
          ["foot", "ft", null, "length", false, true, 0.3048],
          ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
          ["gal", "Gal", null, "acceleration", false, false, 0.01],
          ["gallon", "gal", null, "volume", false, true, 0.003785411784],
          ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
          ["grain", "grain", null, "mass", false, true, 647989e-10],
          ["gram", "g", null, "mass", false, true, 1e-3],
          ["gray", "Gy", null, "absorbed_dose", true, false, 1],
          ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
          ["hectare", "ha", null, "area", false, true, 1e4],
          ["henry", "H", null, "inductance", true, false, 1],
          ["hertz", "Hz", null, "frequency", true, false, 1],
          ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
          ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519538e-3],
          ["hour", "h", ["hr"], "time", false, true, 3600],
          ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 454609e-8],
          ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
          ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
          ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
          ["inch", "in", null, "length", false, true, 0.0254],
          ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
          ["IT calorie", "cal", null, "energy", false, true, 4.1868],
          ["joule", "J", null, "energy", true, true, 1],
          ["katal", "kat", null, "catalytic_activity", true, false, 1],
          ["kelvin", "K", ["kel"], "temperature", true, true, 1],
          ["kilogram", "kg", null, "mass", true, true, 1],
          ["knot", "kn", null, "speed", false, true, 0.514444444444444],
          ["light-year", "ly", null, "length", false, true, 9460730472580800],
          ["litre", "L", ["l", "lt"], "volume", false, true, 1e-3],
          ["lumen", "lm", null, "luminous_flux", true, false, 1],
          ["lux", "lx", null, "illuminance", true, false, 1],
          ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
          ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
          ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 27777777777778e-17],
          ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
          ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
          ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
          ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
          ["metre", "m", null, "length", true, true, 1],
          ["miles per hour", "mph", null, "speed", false, true, 0.44704],
          ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
          ["minute", "?", null, "angle", false, false, 290888208665722e-18],
          ["minute", "min", ["mn"], "time", false, true, 60],
          ["modern teaspoon", "tspm", null, "volume", false, true, 5e-6],
          ["mole", "mol", null, "amount_of_substance", true, false, 1],
          ["morgen", "Morgen", null, "area", false, true, 2500],
          ["n.u. of action", "?", null, "action", false, false, 105457168181818e-48],
          ["n.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
          ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
          ["n.u. of time", "?/(me?c??)", null, "time", false, false, 128808866778687e-35],
          ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
          ["newton", "N", null, "force", true, true, 1],
          ["\u0153rsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
          ["ohm", "\u03A9", null, "electric_resistance", true, false, 1],
          ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
          ["pascal", "Pa", null, "pressure", true, false, 1],
          ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
          ["pferdest\xE4rke", "PS", null, "power", false, true, 735.49875],
          ["phot", "ph", null, "illuminance", false, false, 1e-4],
          ["pica (1/6 inch)", "pica", null, "length", false, true, 35277777777778e-17],
          ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
          ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
          ["pond", "pond", null, "force", false, true, 980665e-8],
          ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
          ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
          ["quart", "qt", null, "volume", false, true, 946352946e-12],
          ["radian", "rad", null, "angle", true, false, 1],
          ["second", "?", null, "angle", false, false, 484813681109536e-20],
          ["second", "s", ["sec"], "time", true, true, 1],
          ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
          ["siemens", "S", null, "electrical_conductance", true, false, 1],
          ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
          ["slug", "sg", null, "mass", false, true, 14.59390294],
          ["square \xE5ngstr\xF6m", "ang2", ["ang^2"], "area", false, true, 1e-20],
          ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
          ["square inch", "in2", ["in^2"], "area", false, true, 64516e-8],
          ["square light-year", "ly2", ["ly^2"], "area", false, true, 895054210748189e17],
          ["square meter", "m?", null, "area", true, true, 1],
          ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988110336e-6],
          ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
          ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 1792111111111e-17],
          ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
          ["statute mile", "mi", null, "length", false, true, 1609.344],
          ["steradian", "sr", null, "solid_angle", true, false, 1],
          ["stilb", "sb", null, "luminance", false, false, 1e-4],
          ["stokes", "St", null, "kinematic_viscosity", false, false, 1e-4],
          ["stone", "stone", null, "mass", false, true, 6.35029318],
          ["tablespoon", "tbs", null, "volume", false, true, 147868e-10],
          ["teaspoon", "tsp", null, "volume", false, true, 492892e-11],
          ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
          ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
          ["ton", "ton", null, "mass", false, true, 907.18474],
          ["tonne", "t", null, "mass", false, false, 1e3],
          ["U.K. pint", "uk_pt", null, "volume", false, true, 56826125e-11],
          ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
          ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
          ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 473176473e-12],
          ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
          ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
          ["volt", "V", null, "voltage", true, false, 1],
          ["watt", "W", null, "power", true, true, 1],
          ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
          ["weber", "Wb", null, "magnetic_flux", true, false, 1],
          ["yard", "yd", null, "length", false, true, 0.9144],
          ["year", "yr", null, "time", false, true, 31557600]
        ];
        var binary_prefixes = {
          Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
          Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
          Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
          Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
          Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
          Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
          Mi: ["mebi", 20, 1048576, "Mi", "mega"],
          ki: ["kibi", 10, 1024, "ki", "kilo"]
        };
        var unit_prefixes = {
          Y: ["yotta", 1e24, "Y"],
          Z: ["zetta", 1e21, "Z"],
          E: ["exa", 1e18, "E"],
          P: ["peta", 1e15, "P"],
          T: ["tera", 1e12, "T"],
          G: ["giga", 1e9, "G"],
          M: ["mega", 1e6, "M"],
          k: ["kilo", 1e3, "k"],
          h: ["hecto", 100, "h"],
          e: ["dekao", 10, "e"],
          d: ["deci", 0.1, "d"],
          c: ["centi", 0.01, "c"],
          m: ["milli", 1e-3, "m"],
          u: ["micro", 1e-6, "u"],
          n: ["nano", 1e-9, "n"],
          p: ["pico", 1e-12, "p"],
          f: ["femto", 1e-15, "f"],
          a: ["atto", 1e-18, "a"],
          z: ["zepto", 1e-21, "z"],
          y: ["yocto", 1e-24, "y"]
        };
        var from = null;
        var to = null;
        var base_from_unit = from_unit;
        var base_to_unit = to_unit;
        var from_multiplier = 1;
        var to_multiplier = 1;
        var alt;
        for (var i2 = 0; i2 < units.length; i2++) {
          alt = units[i2][2] === null ? [] : units[i2][2];
          if (units[i2][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
            from = units[i2];
          }
          if (units[i2][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
            to = units[i2];
          }
        }
        if (from === null) {
          var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
          var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];
          if (from_unit.substring(0, 2) === "da") {
            from_unit_prefix = ["dekao", 10, "da"];
          }
          if (from_binary_prefix) {
            from_multiplier = from_binary_prefix[2];
            base_from_unit = from_unit.substring(2);
          } else if (from_unit_prefix) {
            from_multiplier = from_unit_prefix[1];
            base_from_unit = from_unit.substring(from_unit_prefix[2].length);
          }
          for (var j2 = 0; j2 < units.length; j2++) {
            alt = units[j2][2] === null ? [] : units[j2][2];
            if (units[j2][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
              from = units[j2];
            }
          }
        }
        if (to === null) {
          var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
          var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];
          if (to_unit.substring(0, 2) === "da") {
            to_unit_prefix = ["dekao", 10, "da"];
          }
          if (to_binary_prefix) {
            to_multiplier = to_binary_prefix[2];
            base_to_unit = to_unit.substring(2);
          } else if (to_unit_prefix) {
            to_multiplier = to_unit_prefix[1];
            base_to_unit = to_unit.substring(to_unit_prefix[2].length);
          }
          for (var k2 = 0; k2 < units.length; k2++) {
            alt = units[k2][2] === null ? [] : units[k2][2];
            if (units[k2][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
              to = units[k2];
            }
          }
        }
        if (from === null || to === null) {
          return error.na;
        }
        if (from[3] !== to[3]) {
          return error.na;
        }
        return number2 * from[6] * from_multiplier / (to[6] * to_multiplier);
      };
      exports2.DEC2BIN = function(number2, places) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        if (!/^-?[0-9]{1,3}$/.test(number2) || number2 < -512 || number2 > 511) {
          return error.num;
        }
        if (number2 < 0) {
          return "1" + REPT("0", 9 - (512 + number2).toString(2).length) + (512 + number2).toString(2);
        }
        var result2 = parseInt(number2, 10).toString(2);
        if (typeof places === "undefined") {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.DEC2HEX = function(number2, places) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        if (!/^-?[0-9]{1,12}$/.test(number2) || number2 < -549755813888 || number2 > 549755813887) {
          return error.num;
        }
        if (number2 < 0) {
          return (1099511627776 + number2).toString(16);
        }
        var result2 = parseInt(number2, 10).toString(16);
        if (typeof places === "undefined") {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.DEC2OCT = function(number2, places) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        if (!/^-?[0-9]{1,9}$/.test(number2) || number2 < -536870912 || number2 > 536870911) {
          return error.num;
        }
        if (number2 < 0) {
          return (1073741824 + number2).toString(8);
        }
        var result2 = parseInt(number2, 10).toString(8);
        if (typeof places === "undefined") {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.DELTA = function(number1, number2) {
        number2 = number2 === void 0 ? 0 : number2;
        number1 = utils.parseNumber(number1);
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(number1, number2)) {
          return error.value;
        }
        return number1 === number2 ? 1 : 0;
      };
      exports2.ERF = function(lower_bound, upper_bound) {
      };
      exports2.ERF.PRECISE = function() {
      };
      exports2.ERFC = function(x2) {
      };
      exports2.ERFC.PRECISE = function() {
      };
      exports2.GESTEP = function(number2, step) {
        step = step || 0;
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(step, number2)) {
          return number2;
        }
        return number2 >= step ? 1 : 0;
      };
      exports2.HEX2BIN = function(number2, places) {
        if (!/^[0-9A-Fa-f]{1,10}$/.test(number2)) {
          return error.num;
        }
        var negative = number2.length === 10 && number2.substring(0, 1).toLowerCase() === "f" ? true : false;
        var decimal = negative ? parseInt(number2, 16) - 1099511627776 : parseInt(number2, 16);
        if (decimal < -512 || decimal > 511) {
          return error.num;
        }
        if (negative) {
          return "1" + REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
        }
        var result2 = decimal.toString(2);
        if (places === void 0) {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.HEX2DEC = function(number2) {
        if (!/^[0-9A-Fa-f]{1,10}$/.test(number2)) {
          return error.num;
        }
        var decimal = parseInt(number2, 16);
        return decimal >= 549755813888 ? decimal - 1099511627776 : decimal;
      };
      exports2.HEX2OCT = function(number2, places) {
        if (!/^[0-9A-Fa-f]{1,10}$/.test(number2)) {
          return error.num;
        }
        var decimal = parseInt(number2, 16);
        if (decimal > 536870911 && decimal < 1098974756864) {
          return error.num;
        }
        if (decimal >= 1098974756864) {
          return (decimal - 1098437885952).toString(8);
        }
        var result2 = decimal.toString(8);
        if (places === void 0) {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.IMABS = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        return Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
      };
      exports2.IMAGINARY = function(inumber) {
        if (inumber === void 0 || inumber === true || inumber === false) {
          return error.value;
        }
        if (inumber === 0 || inumber === "0") {
          return 0;
        }
        if (["i", "j"].indexOf(inumber) >= 0) {
          return 1;
        }
        inumber = inumber.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
        var plus = inumber.indexOf("+");
        var minus = inumber.indexOf("-");
        if (plus === 0) {
          plus = inumber.indexOf("+", 1);
        }
        if (minus === 0) {
          minus = inumber.indexOf("-", 1);
        }
        var last = inumber.substring(inumber.length - 1, inumber.length);
        var unit = last === "i" || last === "j";
        if (plus >= 0 || minus >= 0) {
          if (!unit) {
            return error.num;
          }
          if (plus >= 0) {
            return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error.num : Number(inumber.substring(plus + 1, inumber.length - 1));
          } else {
            return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error.num : -Number(inumber.substring(minus + 1, inumber.length - 1));
          }
        } else {
          if (unit) {
            return isNaN(inumber.substring(0, inumber.length - 1)) ? error.num : inumber.substring(0, inumber.length - 1);
          } else {
            return isNaN(inumber) ? error.num : 0;
          }
        }
      };
      exports2.IMARGUMENT = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        if (x2 === 0 && y2 === 0) {
          return error.div0;
        }
        if (x2 === 0 && y2 > 0) {
          return Math.PI / 2;
        }
        if (x2 === 0 && y2 < 0) {
          return -Math.PI / 2;
        }
        if (y2 === 0 && x2 > 0) {
          return 0;
        }
        if (y2 === 0 && x2 < 0) {
          return -Math.PI;
        }
        if (x2 > 0) {
          return Math.atan(y2 / x2);
        } else if (x2 < 0 && y2 >= 0) {
          return Math.atan(y2 / x2) + Math.PI;
        } else {
          return Math.atan(y2 / x2) - Math.PI;
        }
      };
      exports2.IMCONJUGATE = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return y2 !== 0 ? exports2.COMPLEX(x2, -y2, unit) : inumber;
      };
      exports2.IMCOS = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.cos(x2) * (Math.exp(y2) + Math.exp(-y2)) / 2, -Math.sin(x2) * (Math.exp(y2) - Math.exp(-y2)) / 2, unit);
      };
      exports2.IMCOSH = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.cos(y2) * (Math.exp(x2) + Math.exp(-x2)) / 2, Math.sin(y2) * (Math.exp(x2) - Math.exp(-x2)) / 2, unit);
      };
      exports2.IMCOT = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        return exports2.IMDIV(exports2.IMCOS(inumber), exports2.IMSIN(inumber));
      };
      exports2.IMDIV = function(inumber1, inumber2) {
        var a = exports2.IMREAL(inumber1);
        var b = exports2.IMAGINARY(inumber1);
        var c2 = exports2.IMREAL(inumber2);
        var d = exports2.IMAGINARY(inumber2);
        if (utils.anyIsError(a, b, c2, d)) {
          return error.value;
        }
        var unit1 = inumber1.substring(inumber1.length - 1);
        var unit2 = inumber2.substring(inumber2.length - 1);
        var unit = "i";
        if (unit1 === "j") {
          unit = "j";
        } else if (unit2 === "j") {
          unit = "j";
        }
        if (c2 === 0 && d === 0) {
          return error.num;
        }
        var den = c2 * c2 + d * d;
        return exports2.COMPLEX((a * c2 + b * d) / den, (b * c2 - a * d) / den, unit);
      };
      exports2.IMEXP = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        var e = Math.exp(x2);
        return exports2.COMPLEX(e * Math.cos(y2), e * Math.sin(y2), unit);
      };
      exports2.IMLN = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)), Math.atan(y2 / x2), unit);
      };
      exports2.IMLOG10 = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)) / Math.log(10), Math.atan(y2 / x2) / Math.log(10), unit);
      };
      exports2.IMLOG2 = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)) / Math.log(2), Math.atan(y2 / x2) / Math.log(2), unit);
      };
      exports2.IMPOWER = function(inumber, number2) {
        number2 = utils.parseNumber(number2);
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(number2, x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        var p2 = Math.pow(exports2.IMABS(inumber), number2);
        var t = exports2.IMARGUMENT(inumber);
        return exports2.COMPLEX(p2 * Math.cos(number2 * t), p2 * Math.sin(number2 * t), unit);
      };
      exports2.IMPRODUCT = function() {
        var result2 = arguments[0];
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var a = exports2.IMREAL(result2);
          var b = exports2.IMAGINARY(result2);
          var c2 = exports2.IMREAL(arguments[i2]);
          var d = exports2.IMAGINARY(arguments[i2]);
          if (utils.anyIsError(a, b, c2, d)) {
            return error.value;
          }
          result2 = exports2.COMPLEX(a * c2 - b * d, a * d + b * c2);
        }
        return result2;
      };
      exports2.IMREAL = function(inumber) {
        if (inumber === void 0 || inumber === true || inumber === false) {
          return error.value;
        }
        if (inumber === 0 || inumber === "0") {
          return 0;
        }
        if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(inumber) >= 0) {
          return 0;
        }
        var plus = inumber.indexOf("+");
        var minus = inumber.indexOf("-");
        if (plus === 0) {
          plus = inumber.indexOf("+", 1);
        }
        if (minus === 0) {
          minus = inumber.indexOf("-", 1);
        }
        var last = inumber.substring(inumber.length - 1, inumber.length);
        var unit = last === "i" || last === "j";
        if (plus >= 0 || minus >= 0) {
          if (!unit) {
            return error.num;
          }
          if (plus >= 0) {
            return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error.num : Number(inumber.substring(0, plus));
          } else {
            return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error.num : Number(inumber.substring(0, minus));
          }
        } else {
          if (unit) {
            return isNaN(inumber.substring(0, inumber.length - 1)) ? error.num : 0;
          } else {
            return isNaN(inumber) ? error.num : inumber;
          }
        }
      };
      exports2.IMSEC = function(inumber) {
        if (inumber === true || inumber === false) {
          return error.value;
        }
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        return exports2.IMDIV("1", exports2.IMCOS(inumber));
      };
      exports2.IMSECH = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        return exports2.IMDIV("1", exports2.IMCOSH(inumber));
      };
      exports2.IMSIN = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.sin(x2) * (Math.exp(y2) + Math.exp(-y2)) / 2, Math.cos(x2) * (Math.exp(y2) - Math.exp(-y2)) / 2, unit);
      };
      exports2.IMSINH = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        return exports2.COMPLEX(Math.cos(y2) * (Math.exp(x2) - Math.exp(-x2)) / 2, Math.sin(y2) * (Math.exp(x2) + Math.exp(-x2)) / 2, unit);
      };
      exports2.IMSQRT = function(inumber) {
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        var unit = inumber.substring(inumber.length - 1);
        unit = unit === "i" || unit === "j" ? unit : "i";
        var s = Math.sqrt(exports2.IMABS(inumber));
        var t = exports2.IMARGUMENT(inumber);
        return exports2.COMPLEX(s * Math.cos(t / 2), s * Math.sin(t / 2), unit);
      };
      exports2.IMCSC = function(inumber) {
        if (inumber === true || inumber === false) {
          return error.value;
        }
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.num;
        }
        return exports2.IMDIV("1", exports2.IMSIN(inumber));
      };
      exports2.IMCSCH = function(inumber) {
        if (inumber === true || inumber === false) {
          return error.value;
        }
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.num;
        }
        return exports2.IMDIV("1", exports2.IMSINH(inumber));
      };
      exports2.IMSUB = function(inumber1, inumber2) {
        var a = this.IMREAL(inumber1);
        var b = this.IMAGINARY(inumber1);
        var c2 = this.IMREAL(inumber2);
        var d = this.IMAGINARY(inumber2);
        if (utils.anyIsError(a, b, c2, d)) {
          return error.value;
        }
        var unit1 = inumber1.substring(inumber1.length - 1);
        var unit2 = inumber2.substring(inumber2.length - 1);
        var unit = "i";
        if (unit1 === "j") {
          unit = "j";
        } else if (unit2 === "j") {
          unit = "j";
        }
        return this.COMPLEX(a - c2, b - d, unit);
      };
      exports2.IMSUM = function() {
        var args2 = utils.flatten(arguments);
        var result2 = args2[0];
        for (var i2 = 1; i2 < args2.length; i2++) {
          var a = this.IMREAL(result2);
          var b = this.IMAGINARY(result2);
          var c2 = this.IMREAL(args2[i2]);
          var d = this.IMAGINARY(args2[i2]);
          if (utils.anyIsError(a, b, c2, d)) {
            return error.value;
          }
          result2 = this.COMPLEX(a + c2, b + d);
        }
        return result2;
      };
      exports2.IMTAN = function(inumber) {
        if (inumber === true || inumber === false) {
          return error.value;
        }
        var x2 = exports2.IMREAL(inumber);
        var y2 = exports2.IMAGINARY(inumber);
        if (utils.anyIsError(x2, y2)) {
          return error.value;
        }
        return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
      };
      exports2.OCT2BIN = function(number2, places) {
        if (!/^[0-7]{1,10}$/.test(number2)) {
          return error.num;
        }
        var negative = number2.length === 10 && number2.substring(0, 1) === "7" ? true : false;
        var decimal = negative ? parseInt(number2, 8) - 1073741824 : parseInt(number2, 8);
        if (decimal < -512 || decimal > 511) {
          return error.num;
        }
        if (negative) {
          return "1" + REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
        }
        var result2 = decimal.toString(2);
        if (typeof places === "undefined") {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      exports2.OCT2DEC = function(number2) {
        if (!/^[0-7]{1,10}$/.test(number2)) {
          return error.num;
        }
        var decimal = parseInt(number2, 8);
        return decimal >= 536870912 ? decimal - 1073741824 : decimal;
      };
      exports2.OCT2HEX = function(number2, places) {
        if (!/^[0-7]{1,10}$/.test(number2)) {
          return error.num;
        }
        var decimal = parseInt(number2, 8);
        if (decimal >= 536870912) {
          return "ff" + (decimal + 3221225472).toString(16);
        }
        var result2 = decimal.toString(16);
        if (places === void 0) {
          return result2;
        } else {
          if (isNaN(places)) {
            return error.value;
          }
          if (places < 0) {
            return error.num;
          }
          places = Math.floor(places);
          return places >= result2.length ? REPT("0", places - result2.length) + result2 : error.num;
        }
      };
      return exports2;
    }();
    met.financial = function() {
      var exports2 = {};
      function validDate2(d) {
        return d && d.getTime && !isNaN(d.getTime());
      }
      function ensureDate(d) {
        return d instanceof Date ? d : new Date(d);
      }
      exports2.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
        issue = ensureDate(issue);
        first = ensureDate(first);
        settlement = ensureDate(settlement);
        if (!validDate2(issue) || !validDate2(first) || !validDate2(settlement)) {
          return "#VALUE!";
        }
        if (rate <= 0 || par <= 0) {
          return "#NUM!";
        }
        if ([1, 2, 4].indexOf(frequency) === -1) {
          return "#NUM!";
        }
        if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
          return "#NUM!";
        }
        if (settlement <= issue) {
          return "#NUM!";
        }
        par = par || 0;
        basis = basis || 0;
        return par * rate * YEARFRAC(issue, settlement, basis);
      };
      exports2.ACCRINTM = null;
      exports2.AMORDEGRC = null;
      exports2.AMORLINC = null;
      exports2.COUPDAYBS = null;
      exports2.COUPDAYS = null;
      exports2.COUPDAYSNC = null;
      exports2.COUPNCD = null;
      exports2.COUPNUM = null;
      exports2.COUPPCD = null;
      exports2.CUMIPMT = function(rate, periods, value2, start, end, type2) {
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        value2 = utils.parseNumber(value2);
        if (utils.anyIsError(rate, periods, value2)) {
          return error.value;
        }
        if (rate <= 0 || periods <= 0 || value2 <= 0) {
          return error.num;
        }
        if (start < 1 || end < 1 || start > end) {
          return error.num;
        }
        if (type2 !== 0 && type2 !== 1) {
          return error.num;
        }
        var payment = exports2.PMT(rate, periods, value2, 0, type2);
        var interest = 0;
        if (start === 1) {
          if (type2 === 0) {
            interest = -value2;
            start++;
          }
        }
        for (var i2 = start; i2 <= end; i2++) {
          if (type2 === 1) {
            interest += exports2.FV(rate, i2 - 2, payment, value2, 1) - payment;
          } else {
            interest += exports2.FV(rate, i2 - 1, payment, value2, 0);
          }
        }
        interest *= rate;
        return interest;
      };
      exports2.CUMPRINC = function(rate, periods, value2, start, end, type2) {
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        value2 = utils.parseNumber(value2);
        if (utils.anyIsError(rate, periods, value2)) {
          return error.value;
        }
        if (rate <= 0 || periods <= 0 || value2 <= 0) {
          return error.num;
        }
        if (start < 1 || end < 1 || start > end) {
          return error.num;
        }
        if (type2 !== 0 && type2 !== 1) {
          return error.num;
        }
        var payment = exports2.PMT(rate, periods, value2, 0, type2);
        var principal = 0;
        if (start === 1) {
          if (type2 === 0) {
            principal = payment + value2 * rate;
          } else {
            principal = payment;
          }
          start++;
        }
        for (var i2 = start; i2 <= end; i2++) {
          if (type2 > 0) {
            principal += payment - (exports2.FV(rate, i2 - 2, payment, value2, 1) - payment) * rate;
          } else {
            principal += payment - exports2.FV(rate, i2 - 1, payment, value2, 0) * rate;
          }
        }
        return principal;
      };
      exports2.DB = function(cost, salvage, life, period, month) {
        month = month === void 0 ? 12 : month;
        cost = utils.parseNumber(cost);
        salvage = utils.parseNumber(salvage);
        life = utils.parseNumber(life);
        period = utils.parseNumber(period);
        month = utils.parseNumber(month);
        if (utils.anyIsError(cost, salvage, life, period, month)) {
          return error.value;
        }
        if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
          return error.num;
        }
        if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
          return error.num;
        }
        if (period > life) {
          return error.num;
        }
        if (salvage >= cost) {
          return 0;
        }
        var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);
        var initial = cost * rate * month / 12;
        var total = initial;
        var current = 0;
        var ceiling = period === life ? life - 1 : period;
        for (var i2 = 2; i2 <= ceiling; i2++) {
          current = (cost - total) * rate;
          total += current;
        }
        if (period === 1) {
          return initial;
        } else if (period === life) {
          return (cost - total) * rate;
        } else {
          return current;
        }
      };
      exports2.DDB = function(cost, salvage, life, period, factor) {
        factor = factor === void 0 ? 2 : factor;
        cost = utils.parseNumber(cost);
        salvage = utils.parseNumber(salvage);
        life = utils.parseNumber(life);
        period = utils.parseNumber(period);
        factor = utils.parseNumber(factor);
        if (utils.anyIsError(cost, salvage, life, period, factor)) {
          return error.value;
        }
        if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
          return error.num;
        }
        if (period > life) {
          return error.num;
        }
        if (salvage >= cost) {
          return 0;
        }
        var total = 0;
        var current = 0;
        for (var i2 = 1; i2 <= period; i2++) {
          current = Math.min((cost - total) * (factor / life), cost - salvage - total);
          total += current;
        }
        return current;
      };
      exports2.DISC = null;
      exports2.DOLLARDE = function(dollar, fraction) {
        dollar = utils.parseNumber(dollar);
        fraction = utils.parseNumber(fraction);
        if (utils.anyIsError(dollar, fraction)) {
          return error.value;
        }
        if (fraction < 0) {
          return error.num;
        }
        if (fraction >= 0 && fraction < 1) {
          return error.div0;
        }
        fraction = parseInt(fraction, 10);
        var result2 = parseInt(dollar, 10);
        result2 += dollar % 1 * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;
        var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
        result2 = Math.round(result2 * power) / power;
        return result2;
      };
      exports2.DOLLARFR = function(dollar, fraction) {
        dollar = utils.parseNumber(dollar);
        fraction = utils.parseNumber(fraction);
        if (utils.anyIsError(dollar, fraction)) {
          return error.value;
        }
        if (fraction < 0) {
          return error.num;
        }
        if (fraction >= 0 && fraction < 1) {
          return error.div0;
        }
        fraction = parseInt(fraction, 10);
        var result2 = parseInt(dollar, 10);
        result2 += dollar % 1 * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;
        return result2;
      };
      exports2.DURATION = null;
      exports2.EFFECT = function(rate, periods) {
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        if (utils.anyIsError(rate, periods)) {
          return error.value;
        }
        if (rate <= 0 || periods < 1) {
          return error.num;
        }
        periods = parseInt(periods, 10);
        return Math.pow(1 + rate / periods, periods) - 1;
      };
      exports2.FV = function(rate, periods, payment, value2, type2) {
        value2 = value2 || 0;
        type2 = type2 || 0;
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        payment = utils.parseNumber(payment);
        value2 = utils.parseNumber(value2);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, periods, payment, value2, type2)) {
          return error.value;
        }
        var result2;
        if (rate === 0) {
          result2 = value2 + payment * periods;
        } else {
          var term = Math.pow(1 + rate, periods);
          if (type2 === 1) {
            result2 = value2 * term + payment * (1 + rate) * (term - 1) / rate;
          } else {
            result2 = value2 * term + payment * (term - 1) / rate;
          }
        }
        return -result2;
      };
      exports2.FVSCHEDULE = function(principal, schedule) {
        principal = utils.parseNumber(principal);
        schedule = utils.parseNumberArray(utils.flatten(schedule));
        if (utils.anyIsError(principal, schedule)) {
          return error.value;
        }
        var n2 = schedule.length;
        var future = principal;
        for (var i2 = 0; i2 < n2; i2++) {
          future *= 1 + schedule[i2];
        }
        return future;
      };
      exports2.INTRATE = null;
      exports2.IPMT = function(rate, period, periods, present, future, type2) {
        future = future || 0;
        type2 = type2 || 0;
        rate = utils.parseNumber(rate);
        period = utils.parseNumber(period);
        periods = utils.parseNumber(periods);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, period, periods, present, future, type2)) {
          return error.value;
        }
        var payment = exports2.PMT(rate, periods, present, future, type2);
        var interest;
        if (period === 1) {
          if (type2 === 1) {
            interest = 0;
          } else {
            interest = -present;
          }
        } else {
          if (type2 === 1) {
            interest = exports2.FV(rate, period - 2, payment, present, 1) - payment;
          } else {
            interest = exports2.FV(rate, period - 1, payment, present, 0);
          }
        }
        return interest * rate;
      };
      exports2.IRR = function(values, guess) {
        guess = guess || 0;
        values = utils.parseNumberArray(utils.flatten(values));
        guess = utils.parseNumber(guess);
        if (utils.anyIsError(values, guess)) {
          return error.value;
        }
        var irrResult = function(values2, dates2, rate) {
          var r = rate + 1;
          var result2 = values2[0];
          for (var i3 = 1; i3 < values2.length; i3++) {
            result2 += values2[i3] / Math.pow(r, (dates2[i3] - dates2[0]) / 365);
          }
          return result2;
        };
        var irrResultDeriv = function(values2, dates2, rate) {
          var r = rate + 1;
          var result2 = 0;
          for (var i3 = 1; i3 < values2.length; i3++) {
            var frac = (dates2[i3] - dates2[0]) / 365;
            result2 -= frac * values2[i3] / Math.pow(r, frac + 1);
          }
          return result2;
        };
        var dates = [];
        var positive = false;
        var negative = false;
        for (var i2 = 0; i2 < values.length; i2++) {
          dates[i2] = i2 === 0 ? 0 : dates[i2 - 1] + 365;
          if (values[i2] > 0) {
            positive = true;
          }
          if (values[i2] < 0) {
            negative = true;
          }
        }
        if (!positive || !negative) {
          return error.num;
        }
        guess = guess === void 0 ? 0.1 : guess;
        var resultRate = guess;
        var epsMax = 1e-10;
        var newRate, epsRate, resultValue;
        var contLoop = true;
        do {
          resultValue = irrResult(values, dates, resultRate);
          newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
          epsRate = Math.abs(newRate - resultRate);
          resultRate = newRate;
          contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
        } while (contLoop);
        return resultRate;
      };
      exports2.ISPMT = function(rate, period, periods, value2) {
        rate = utils.parseNumber(rate);
        period = utils.parseNumber(period);
        periods = utils.parseNumber(periods);
        value2 = utils.parseNumber(value2);
        if (utils.anyIsError(rate, period, periods, value2)) {
          return error.value;
        }
        return value2 * rate * (period / periods - 1);
      };
      exports2.MDURATION = null;
      exports2.MIRR = function(values, finance_rate, reinvest_rate) {
        values = utils.parseNumberArray(utils.flatten(values));
        finance_rate = utils.parseNumber(finance_rate);
        reinvest_rate = utils.parseNumber(reinvest_rate);
        if (utils.anyIsError(values, finance_rate, reinvest_rate)) {
          return error.value;
        }
        var n2 = values.length;
        var payments = [];
        var incomes = [];
        for (var i2 = 0; i2 < n2; i2++) {
          if (values[i2] < 0) {
            payments.push(values[i2]);
          } else {
            incomes.push(values[i2]);
          }
        }
        var num = -exports2.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n2 - 1);
        var den = exports2.NPV(finance_rate, payments) * (1 + finance_rate);
        return Math.pow(num / den, 1 / (n2 - 1)) - 1;
      };
      exports2.NOMINAL = function(rate, periods) {
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        if (utils.anyIsError(rate, periods)) {
          return error.value;
        }
        if (rate <= 0 || periods < 1) {
          return error.num;
        }
        periods = parseInt(periods, 10);
        return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
      };
      exports2.NPER = function(rate, payment, present, future, type2) {
        type2 = type2 === void 0 ? 0 : type2;
        future = future === void 0 ? 0 : future;
        rate = utils.parseNumber(rate);
        payment = utils.parseNumber(payment);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, payment, present, future, type2)) {
          return error.value;
        }
        var num = payment * (1 + rate * type2) - future * rate;
        var den = present * rate + payment * (1 + rate * type2);
        return Math.log(num / den) / Math.log(1 + rate);
      };
      exports2.NPV = function() {
        var args2 = utils.parseNumberArray(utils.flatten(arguments));
        if (args2 instanceof Error) {
          return args2;
        }
        var rate = args2[0];
        var value2 = 0;
        for (var j2 = 1; j2 < args2.length; j2++) {
          value2 += args2[j2] / Math.pow(1 + rate, j2);
        }
        return value2;
      };
      exports2.ODDFPRICE = null;
      exports2.ODDFYIELD = null;
      exports2.ODDLPRICE = null;
      exports2.ODDLYIELD = null;
      exports2.PDURATION = function(rate, present, future) {
        rate = utils.parseNumber(rate);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        if (utils.anyIsError(rate, present, future)) {
          return error.value;
        }
        if (rate <= 0) {
          return error.num;
        }
        return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
      };
      exports2.PMT = function(rate, periods, present, future, type2) {
        future = future || 0;
        type2 = type2 || 0;
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, periods, present, future, type2)) {
          return error.value;
        }
        var result2;
        if (rate === 0) {
          result2 = (present + future) / periods;
        } else {
          var term = Math.pow(1 + rate, periods);
          if (type2 === 1) {
            result2 = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
          } else {
            result2 = future * rate / (term - 1) + present * rate / (1 - 1 / term);
          }
        }
        return -result2;
      };
      exports2.PPMT = function(rate, period, periods, present, future, type2) {
        future = future || 0;
        type2 = type2 || 0;
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, periods, present, future, type2)) {
          return error.value;
        }
        return exports2.PMT(rate, periods, present, future, type2) - exports2.IPMT(rate, period, periods, present, future, type2);
      };
      exports2.PRICE = null;
      exports2.PRICEDISC = null;
      exports2.PRICEMAT = null;
      exports2.PV = function(rate, periods, payment, future, type2) {
        future = future || 0;
        type2 = type2 || 0;
        rate = utils.parseNumber(rate);
        periods = utils.parseNumber(periods);
        payment = utils.parseNumber(payment);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        if (utils.anyIsError(rate, periods, payment, future, type2)) {
          return error.value;
        }
        if (rate === 0) {
          return -payment * periods - future;
        } else {
          return ((1 - Math.pow(1 + rate, periods)) / rate * payment * (1 + rate * type2) - future) / Math.pow(1 + rate, periods);
        }
      };
      exports2.RATE = function(periods, payment, present, future, type2, guess) {
        guess = guess === void 0 ? 0.01 : guess;
        future = future === void 0 ? 0 : future;
        type2 = type2 === void 0 ? 0 : type2;
        periods = utils.parseNumber(periods);
        payment = utils.parseNumber(payment);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        type2 = utils.parseNumber(type2);
        guess = utils.parseNumber(guess);
        if (utils.anyIsError(periods, payment, present, future, type2, guess)) {
          return error.value;
        }
        var epsMax = 1e-6;
        var iterMax = 100;
        var iter = 0;
        var close = false;
        var rate = guess;
        while (iter < iterMax && !close) {
          var t1 = Math.pow(rate + 1, periods);
          var t2 = Math.pow(rate + 1, periods - 1);
          var f1 = future + t1 * present + payment * (t1 - 1) * (rate * type2 + 1) / rate;
          var f2 = periods * t2 * present - payment * (t1 - 1) * (rate * type2 + 1) / Math.pow(rate, 2);
          var f3 = periods * payment * t2 * (rate * type2 + 1) / rate + payment * (t1 - 1) * type2 / rate;
          var newRate = rate - f1 / (f2 + f3);
          if (Math.abs(newRate - rate) < epsMax)
            close = true;
          iter++;
          rate = newRate;
        }
        if (!close)
          return Number.NaN + rate;
        return rate;
      };
      exports2.RECEIVED = null;
      exports2.RRI = function(periods, present, future) {
        periods = utils.parseNumber(periods);
        present = utils.parseNumber(present);
        future = utils.parseNumber(future);
        if (utils.anyIsError(periods, present, future)) {
          return error.value;
        }
        if (periods === 0 || present === 0) {
          return error.num;
        }
        return Math.pow(future / present, 1 / periods) - 1;
      };
      exports2.SLN = function(cost, salvage, life) {
        cost = utils.parseNumber(cost);
        salvage = utils.parseNumber(salvage);
        life = utils.parseNumber(life);
        if (utils.anyIsError(cost, salvage, life)) {
          return error.value;
        }
        if (life === 0) {
          return error.num;
        }
        return (cost - salvage) / life;
      };
      exports2.SYD = function(cost, salvage, life, period) {
        cost = utils.parseNumber(cost);
        salvage = utils.parseNumber(salvage);
        life = utils.parseNumber(life);
        period = utils.parseNumber(period);
        if (utils.anyIsError(cost, salvage, life, period)) {
          return error.value;
        }
        if (life === 0) {
          return error.num;
        }
        if (period < 1 || period > life) {
          return error.num;
        }
        period = parseInt(period, 10);
        return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));
      };
      exports2.TBILLEQ = function(settlement, maturity, discount) {
        settlement = utils.parseDate(settlement);
        maturity = utils.parseDate(maturity);
        discount = utils.parseNumber(discount);
        if (utils.anyIsError(settlement, maturity, discount)) {
          return error.value;
        }
        if (discount <= 0) {
          return error.num;
        }
        if (settlement > maturity) {
          return error.num;
        }
        if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
          return error.num;
        }
        return 365 * discount / (360 - discount * DAYS360(settlement, maturity, false));
      };
      exports2.TBILLPRICE = function(settlement, maturity, discount) {
        settlement = utils.parseDate(settlement);
        maturity = utils.parseDate(maturity);
        discount = utils.parseNumber(discount);
        if (utils.anyIsError(settlement, maturity, discount)) {
          return error.value;
        }
        if (discount <= 0) {
          return error.num;
        }
        if (settlement > maturity) {
          return error.num;
        }
        if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
          return error.num;
        }
        return 100 * (1 - discount * DAYS360(settlement, maturity, false) / 360);
      };
      exports2.TBILLYIELD = function(settlement, maturity, price) {
        settlement = utils.parseDate(settlement);
        maturity = utils.parseDate(maturity);
        price = utils.parseNumber(price);
        if (utils.anyIsError(settlement, maturity, price)) {
          return error.value;
        }
        if (price <= 0) {
          return error.num;
        }
        if (settlement > maturity) {
          return error.num;
        }
        if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
          return error.num;
        }
        return (100 - price) * 360 / (price * DAYS360(settlement, maturity, false));
      };
      exports2.VDB = null;
      exports2.XIRR = function(values, dates, guess) {
        values = utils.parseNumberArray(utils.flatten(values));
        dates = utils.parseDateArray(utils.flatten(dates));
        guess = utils.parseNumber(guess);
        if (utils.anyIsError(values, dates, guess)) {
          return error.value;
        }
        var irrResult = function(values2, dates2, rate) {
          var r = rate + 1;
          var result2 = values2[0];
          for (var i3 = 1; i3 < values2.length; i3++) {
            result2 += values2[i3] / Math.pow(r, DAYS(dates2[i3], dates2[0]) / 365);
          }
          return result2;
        };
        var irrResultDeriv = function(values2, dates2, rate) {
          var r = rate + 1;
          var result2 = 0;
          for (var i3 = 1; i3 < values2.length; i3++) {
            var frac = DAYS(dates2[i3], dates2[0]) / 365;
            result2 -= frac * values2[i3] / Math.pow(r, frac + 1);
          }
          return result2;
        };
        var positive = false;
        var negative = false;
        for (var i2 = 0; i2 < values.length; i2++) {
          if (values[i2] > 0) {
            positive = true;
          }
          if (values[i2] < 0) {
            negative = true;
          }
        }
        if (!positive || !negative) {
          return error.num;
        }
        guess = guess || 0.1;
        var resultRate = guess;
        var epsMax = 1e-10;
        var newRate, epsRate, resultValue;
        var contLoop = true;
        do {
          resultValue = irrResult(values, dates, resultRate);
          newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
          epsRate = Math.abs(newRate - resultRate);
          resultRate = newRate;
          contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
        } while (contLoop);
        return resultRate;
      };
      exports2.XNPV = function(rate, values, dates) {
        rate = utils.parseNumber(rate);
        values = utils.parseNumberArray(utils.flatten(values));
        dates = utils.parseDateArray(utils.flatten(dates));
        if (utils.anyIsError(rate, values, dates)) {
          return error.value;
        }
        var result2 = 0;
        for (var i2 = 0; i2 < values.length; i2++) {
          result2 += values[i2] / Math.pow(1 + rate, DAYS(dates[i2], dates[0]) / 365);
        }
        return result2;
      };
      exports2.YIELD = null;
      exports2.YIELDDISC = null;
      exports2.YIELDMAT = null;
      return exports2;
    }();
    met.information = function() {
      var exports2 = {};
      exports2.CELL = null;
      exports2.ERROR = {};
      exports2.ERROR.TYPE = function(error_val) {
        switch (error_val) {
          case error.nil:
            return 1;
          case error.div0:
            return 2;
          case error.value:
            return 3;
          case error.ref:
            return 4;
          case error.name:
            return 5;
          case error.num:
            return 6;
          case error.na:
            return 7;
          case error.data:
            return 8;
        }
        return error.na;
      };
      exports2.INFO = null;
      exports2.ISBLANK = function(value2) {
        return value2 === null;
      };
      exports2.ISBINARY = function(number2) {
        return /^[01]{1,10}$/.test(number2);
      };
      exports2.ISERR = function(value2) {
        return [error.value, error.ref, error.div0, error.num, error.name, error.nil].indexOf(value2) >= 0 || typeof value2 === "number" && (isNaN(value2) || !isFinite(value2));
      };
      exports2.ISERROR = function(value2) {
        return exports2.ISERR(value2) || value2 === error.na;
      };
      exports2.ISEVEN = function(number2) {
        return Math.floor(Math.abs(number2)) & 1 ? false : true;
      };
      exports2.ISFORMULA = null;
      exports2.ISLOGICAL = function(value2) {
        return value2 === true || value2 === false;
      };
      exports2.ISNA = function(value2) {
        return value2 === error.na;
      };
      exports2.ISNONTEXT = function(value2) {
        return typeof value2 !== "string";
      };
      exports2.ISNUMBER = function(value2) {
        return typeof value2 === "number" && !isNaN(value2) && isFinite(value2);
      };
      exports2.ISODD = function(number2) {
        return Math.floor(Math.abs(number2)) & 1 ? true : false;
      };
      exports2.ISREF = null;
      exports2.ISTEXT = function(value2) {
        return typeof value2 === "string";
      };
      exports2.N = function(value2) {
        if (this.ISNUMBER(value2)) {
          return value2;
        }
        if (value2 instanceof Date) {
          return value2.getTime();
        }
        if (value2 === true) {
          return 1;
        }
        if (value2 === false) {
          return 0;
        }
        if (this.ISERROR(value2)) {
          return value2;
        }
        return 0;
      };
      exports2.NA = function() {
        return error.na;
      };
      exports2.SHEET = null;
      exports2.SHEETS = null;
      exports2.TYPE = function(value2) {
        if (this.ISNUMBER(value2)) {
          return 1;
        }
        if (this.ISTEXT(value2)) {
          return 2;
        }
        if (this.ISLOGICAL(value2)) {
          return 4;
        }
        if (this.ISERROR(value2)) {
          return 16;
        }
        if (Array.isArray(value2)) {
          return 64;
        }
      };
      return exports2;
    }();
    met.logical = function() {
      var exports2 = {};
      exports2.AND = function() {
        var args2 = utils.flatten(arguments);
        var result2 = true;
        for (var i2 = 0; i2 < args2.length; i2++) {
          if (!args2[i2]) {
            result2 = false;
          }
        }
        return result2;
      };
      exports2.CHOOSE = function() {
        if (arguments.length < 2) {
          return error.na;
        }
        var index2 = arguments[0];
        if (index2 < 1 || index2 > 254) {
          return error.value;
        }
        if (arguments.length < index2 + 1) {
          return error.value;
        }
        return arguments[index2];
      };
      exports2.FALSE = function() {
        return false;
      };
      exports2.IF = function(test, then_value, otherwise_value) {
        return test ? then_value : otherwise_value;
      };
      exports2.IFERROR = function(value2, valueIfError) {
        if (ISERROR(value2)) {
          return valueIfError;
        }
        return value2;
      };
      exports2.IFNA = function(value2, value_if_na) {
        return value2 === error.na ? value_if_na : value2;
      };
      exports2.NOT = function(logical) {
        return !logical;
      };
      exports2.OR = function() {
        var args2 = utils.flatten(arguments);
        var result2 = false;
        for (var i2 = 0; i2 < args2.length; i2++) {
          if (args2[i2]) {
            result2 = true;
          }
        }
        return result2;
      };
      exports2.TRUE = function() {
        return true;
      };
      exports2.XOR = function() {
        var args2 = utils.flatten(arguments);
        var result2 = 0;
        for (var i2 = 0; i2 < args2.length; i2++) {
          if (args2[i2]) {
            result2++;
          }
        }
        return Math.floor(Math.abs(result2)) & 1 ? true : false;
      };
      exports2.SWITCH = function() {
        var result2;
        if (arguments.length > 0) {
          var targetValue = arguments[0];
          var argc = arguments.length - 1;
          var switchCount = Math.floor(argc / 2);
          var switchSatisfied = false;
          var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];
          if (switchCount) {
            for (var index2 = 0; index2 < switchCount; index2++) {
              if (targetValue === arguments[index2 * 2 + 1]) {
                result2 = arguments[index2 * 2 + 2];
                switchSatisfied = true;
                break;
              }
            }
          }
          if (!switchSatisfied && defaultClause) {
            result2 = defaultClause;
          }
        }
        return result2;
      };
      return exports2;
    }();
    met.math = function() {
      var exports = {};
      exports.ABS = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.abs(utils.parseNumber(number2));
      };
      exports.ACOS = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.acos(number2);
      };
      exports.ACOSH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.log(number2 + Math.sqrt(number2 * number2 - 1));
      };
      exports.ACOT = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.atan(1 / number2);
      };
      exports.ACOTH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 0.5 * Math.log((number2 + 1) / (number2 - 1));
      };
      exports.AGGREGATE = null;
      exports.ARABIC = function(text2) {
        if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text2)) {
          return error.value;
        }
        var r = 0;
        text2.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i2) {
          r += {
            M: 1e3,
            CM: 900,
            D: 500,
            CD: 400,
            C: 100,
            XC: 90,
            L: 50,
            XL: 40,
            X: 10,
            IX: 9,
            V: 5,
            IV: 4,
            I: 1
          }[i2];
        });
        return r;
      };
      exports.ASIN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.asin(number2);
      };
      exports.ASINH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.log(number2 + Math.sqrt(number2 * number2 + 1));
      };
      exports.ATAN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.atan(number2);
      };
      exports.ATAN2 = function(number_x, number_y) {
        number_x = utils.parseNumber(number_x);
        number_y = utils.parseNumber(number_y);
        if (utils.anyIsError(number_x, number_y)) {
          return error.value;
        }
        return Math.atan2(number_x, number_y);
      };
      exports.ATANH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.log((1 + number2) / (1 - number2)) / 2;
      };
      exports.BASE = function(number2, radix, min_length) {
        min_length = min_length || 0;
        number2 = utils.parseNumber(number2);
        radix = utils.parseNumber(radix);
        min_length = utils.parseNumber(min_length);
        if (utils.anyIsError(number2, radix, min_length)) {
          return error.value;
        }
        min_length = min_length === void 0 ? 0 : min_length;
        var result2 = number2.toString(radix);
        return new Array(Math.max(min_length + 1 - result2.length, 0)).join("0") + result2;
      };
      exports.CEILING = function(number2, significance, mode) {
        significance = significance === void 0 ? 1 : significance;
        mode = mode === void 0 ? 0 : mode;
        number2 = utils.parseNumber(number2);
        significance = utils.parseNumber(significance);
        mode = utils.parseNumber(mode);
        if (utils.anyIsError(number2, significance, mode)) {
          return error.value;
        }
        if (significance === 0) {
          return 0;
        }
        significance = Math.abs(significance);
        if (number2 >= 0) {
          return Math.ceil(number2 / significance) * significance;
        } else {
          if (mode === 0) {
            return -1 * Math.floor(Math.abs(number2) / significance) * significance;
          } else {
            return -1 * Math.ceil(Math.abs(number2) / significance) * significance;
          }
        }
      };
      exports.CEILING.MATH = exports.CEILING;
      exports.CEILING.PRECISE = exports.CEILING;
      exports.COMBIN = function(number2, number_chosen) {
        number2 = utils.parseNumber(number2);
        number_chosen = utils.parseNumber(number_chosen);
        if (utils.anyIsError(number2, number_chosen)) {
          return error.value;
        }
        return exports.FACT(number2) / (exports.FACT(number_chosen) * exports.FACT(number2 - number_chosen));
      };
      exports.COMBINA = function(number2, number_chosen) {
        number2 = utils.parseNumber(number2);
        number_chosen = utils.parseNumber(number_chosen);
        if (utils.anyIsError(number2, number_chosen)) {
          return error.value;
        }
        return number2 === 0 && number_chosen === 0 ? 1 : exports.COMBIN(number2 + number_chosen - 1, number2 - 1);
      };
      exports.COS = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.cos(number2);
      };
      exports.COSH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return (Math.exp(number2) + Math.exp(-number2)) / 2;
      };
      exports.COT = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 1 / Math.tan(number2);
      };
      exports.COTH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var e2 = Math.exp(2 * number2);
        return (e2 + 1) / (e2 - 1);
      };
      exports.CSC = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 1 / Math.sin(number2);
      };
      exports.CSCH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 2 / (Math.exp(number2) - Math.exp(-number2));
      };
      exports.DECIMAL = function(number2, radix) {
        if (arguments.length < 1) {
          return error.value;
        }
        return parseInt(number2, radix);
      };
      exports.DEGREES = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return number2 * 180 / Math.PI;
      };
      exports.EVEN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return exports.CEILING(number2, -2, -1);
      };
      exports.EXP = Math.exp;
      var MEMOIZED_FACT = [];
      exports.FACT = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var n2 = Math.floor(number2);
        if (n2 === 0 || n2 === 1) {
          return 1;
        } else if (MEMOIZED_FACT[n2] > 0) {
          return MEMOIZED_FACT[n2];
        } else {
          MEMOIZED_FACT[n2] = exports.FACT(n2 - 1) * n2;
          return MEMOIZED_FACT[n2];
        }
      };
      exports.FACTDOUBLE = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var n2 = Math.floor(number2);
        if (n2 <= 0) {
          return 1;
        } else {
          return n2 * exports.FACTDOUBLE(n2 - 2);
        }
      };
      exports.FLOOR = function(number2, significance, mode) {
        significance = significance === void 0 ? 1 : significance;
        mode = mode === void 0 ? 0 : mode;
        number2 = utils.parseNumber(number2);
        significance = utils.parseNumber(significance);
        mode = utils.parseNumber(mode);
        if (utils.anyIsError(number2, significance, mode)) {
          return error.value;
        }
        if (significance === 0) {
          return 0;
        }
        significance = Math.abs(significance);
        if (number2 >= 0) {
          return Math.floor(number2 / significance) * significance;
        } else {
          if (mode === 0) {
            return -1 * Math.ceil(Math.abs(number2) / significance) * significance;
          } else {
            return -1 * Math.floor(Math.abs(number2) / significance) * significance;
          }
        }
      };
      exports.FLOOR.MATH = exports.FLOOR;
      exports.GCD = null;
      exports.INT = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.floor(number2);
      };
      exports.LCM = function() {
        var o = utils.parseNumberArray(utils.flatten(arguments));
        if (o instanceof Error) {
          return o;
        }
        for (var i2, j2, n2, d, r = 1; (n2 = o.pop()) !== void 0; ) {
          while (n2 > 1) {
            if (n2 % 2) {
              for (i2 = 3, j2 = Math.floor(Math.sqrt(n2)); i2 <= j2 && n2 % i2; i2 += 2) {
              }
              d = i2 <= j2 ? i2 : n2;
            } else {
              d = 2;
            }
            for (n2 /= d, r *= d, i2 = o.length; i2; o[--i2] % d === 0 && (o[i2] /= d) === 1 && o.splice(i2, 1)) {
            }
          }
        }
        return r;
      };
      exports.LN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.log(number2);
      };
      exports.LOG = function(number2, base) {
        number2 = utils.parseNumber(number2);
        base = base === void 0 ? 10 : utils.parseNumber(base);
        if (utils.anyIsError(number2, base)) {
          return error.value;
        }
        return Math.log(number2) / Math.log(base);
      };
      exports.LOG10 = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.log(number2) / Math.log(10);
      };
      exports.MDETERM = null;
      exports.MINVERSE = null;
      exports.MMULT = null;
      exports.MOD = function(dividend, divisor) {
        dividend = utils.parseNumber(dividend);
        divisor = utils.parseNumber(divisor);
        if (utils.anyIsError(dividend, divisor)) {
          return error.value;
        }
        if (divisor === 0) {
          return error.div0;
        }
        var modulus = Math.abs(dividend % divisor);
        return divisor > 0 ? modulus : -modulus;
      };
      exports.MROUND = function(number2, multiple) {
        number2 = utils.parseNumber(number2);
        multiple = utils.parseNumber(multiple);
        if (utils.anyIsError(number2, multiple)) {
          return error.value;
        }
        if (number2 * multiple < 0) {
          return error.num;
        }
        return Math.round(number2 / multiple) * multiple;
      };
      exports.MULTINOMIAL = function() {
        var args2 = utils.parseNumberArray(utils.flatten(arguments));
        if (args2 instanceof Error) {
          return args2;
        }
        var sum = 0;
        var divisor = 1;
        for (var i2 = 0; i2 < args2.length; i2++) {
          sum += args2[i2];
          divisor *= exports.FACT(args2[i2]);
        }
        return exports.FACT(sum) / divisor;
      };
      exports.MUNIT = null;
      exports.ODD = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var temp = Math.ceil(Math.abs(number2));
        temp = temp & 1 ? temp : temp + 1;
        return number2 > 0 ? temp : -temp;
      };
      exports.PI = function() {
        return Math.PI;
      };
      exports.POWER = function(number2, power) {
        number2 = utils.parseNumber(number2);
        power = utils.parseNumber(power);
        if (utils.anyIsError(number2, power)) {
          return error.value;
        }
        var result2 = Math.pow(number2, power);
        if (isNaN(result2)) {
          return error.num;
        }
        return result2;
      };
      exports.PRODUCT = function() {
        var args2 = utils.parseNumberArray(utils.flatten(arguments));
        if (args2 instanceof Error) {
          return args2;
        }
        var result2 = 1;
        for (var i2 = 0; i2 < args2.length; i2++) {
          result2 *= args2[i2];
        }
        return result2;
      };
      exports.QUOTIENT = function(numerator, denominator) {
        numerator = utils.parseNumber(numerator);
        denominator = utils.parseNumber(denominator);
        if (utils.anyIsError(numerator, denominator)) {
          return error.value;
        }
        return parseInt(numerator / denominator, 10);
      };
      exports.RADIANS = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return number2 * Math.PI / 180;
      };
      exports.RAND = function() {
        return Math.random();
      };
      exports.RANDBETWEEN = function(bottom, top) {
        bottom = utils.parseNumber(bottom);
        top = utils.parseNumber(top);
        if (utils.anyIsError(bottom, top)) {
          return error.value;
        }
        return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
      };
      exports.ROMAN = null;
      exports.ROUND = function(number2, digits) {
        number2 = utils.parseNumber(number2);
        digits = utils.parseNumber(digits);
        if (utils.anyIsError(number2, digits)) {
          return error.value;
        }
        return Math.round(number2 * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports.ROUNDDOWN = function(number2, digits) {
        number2 = utils.parseNumber(number2);
        digits = utils.parseNumber(digits);
        if (utils.anyIsError(number2, digits)) {
          return error.value;
        }
        var sign = number2 > 0 ? 1 : -1;
        return sign * Math.floor(Math.abs(number2) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports.ROUNDUP = function(number2, digits) {
        number2 = utils.parseNumber(number2);
        digits = utils.parseNumber(digits);
        if (utils.anyIsError(number2, digits)) {
          return error.value;
        }
        var sign = number2 > 0 ? 1 : -1;
        return sign * Math.ceil(Math.abs(number2) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports.SEC = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 1 / Math.cos(number2);
      };
      exports.SECH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return 2 / (Math.exp(number2) + Math.exp(-number2));
      };
      exports.SERIESSUM = function(x2, n2, m, coefficients) {
        x2 = utils.parseNumber(x2);
        n2 = utils.parseNumber(n2);
        m = utils.parseNumber(m);
        coefficients = utils.parseNumberArray(coefficients);
        if (utils.anyIsError(x2, n2, m, coefficients)) {
          return error.value;
        }
        var result2 = coefficients[0] * Math.pow(x2, n2);
        for (var i2 = 1; i2 < coefficients.length; i2++) {
          result2 += coefficients[i2] * Math.pow(x2, n2 + i2 * m);
        }
        return result2;
      };
      exports.SIGN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        if (number2 < 0) {
          return -1;
        } else if (number2 === 0) {
          return 0;
        } else {
          return 1;
        }
      };
      exports.SIN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.sin(number2);
      };
      exports.SINH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return (Math.exp(number2) - Math.exp(-number2)) / 2;
      };
      exports.SQRT = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        if (number2 < 0) {
          return error.num;
        }
        return Math.sqrt(number2);
      };
      exports.SQRTPI = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.sqrt(number2 * Math.PI);
      };
      exports.SUBTOTAL = null;
      exports.ADD = function(num1, num2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        num1 = utils.parseNumber(num1);
        num2 = utils.parseNumber(num2);
        if (utils.anyIsError(num1, num2)) {
          return error.value;
        }
        return num1 + num2;
      };
      exports.MINUS = function(num1, num2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        num1 = utils.parseNumber(num1);
        num2 = utils.parseNumber(num2);
        if (utils.anyIsError(num1, num2)) {
          return error.value;
        }
        return num1 - num2;
      };
      exports.DIVIDE = function(dividend, divisor) {
        if (arguments.length !== 2) {
          return error.na;
        }
        dividend = utils.parseNumber(dividend);
        divisor = utils.parseNumber(divisor);
        if (utils.anyIsError(dividend, divisor)) {
          return error.value;
        }
        if (divisor === 0) {
          return error.div0;
        }
        return dividend / divisor;
      };
      exports.MULTIPLY = function(factor1, factor2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        factor1 = utils.parseNumber(factor1);
        factor2 = utils.parseNumber(factor2);
        if (utils.anyIsError(factor1, factor2)) {
          return error.value;
        }
        return factor1 * factor2;
      };
      exports.GTE = function(num1, num2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        num1 = utils.parseNumber(num1);
        num2 = utils.parseNumber(num2);
        if (utils.anyIsError(num1, num2)) {
          return error.error;
        }
        return num1 >= num2;
      };
      exports.LT = function(num1, num2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        num1 = utils.parseNumber(num1);
        num2 = utils.parseNumber(num2);
        if (utils.anyIsError(num1, num2)) {
          return error.error;
        }
        return num1 < num2;
      };
      exports.LTE = function(num1, num2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        num1 = utils.parseNumber(num1);
        num2 = utils.parseNumber(num2);
        if (utils.anyIsError(num1, num2)) {
          return error.error;
        }
        return num1 <= num2;
      };
      exports.EQ = function(value1, value2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        return value1 === value2;
      };
      exports.NE = function(value1, value2) {
        if (arguments.length !== 2) {
          return error.na;
        }
        return value1 !== value2;
      };
      exports.POW = function(base, exponent) {
        if (arguments.length !== 2) {
          return error.na;
        }
        base = utils.parseNumber(base);
        exponent = utils.parseNumber(exponent);
        if (utils.anyIsError(base, exponent)) {
          return error.error;
        }
        return exports.POWER(base, exponent);
      };
      exports.SUM = function() {
        var result2 = 0;
        var argsKeys = Object.keys(arguments);
        for (var i2 = 0; i2 < argsKeys.length; ++i2) {
          var elt = arguments[argsKeys[i2]];
          if (typeof elt === "number") {
            result2 += elt;
          } else if (typeof elt === "string") {
            var parsed = parseFloat(elt);
            !isNaN(parsed) && (result2 += parsed);
          } else if (Array.isArray(elt)) {
            result2 += exports.SUM.apply(null, elt);
          }
        }
        return result2;
      };
      exports.SUMIF = function() {
        var args = utils.argsToArray(arguments);
        var criteria = args.pop();
        var range = utils.parseNumberArray(utils.flatten(args));
        if (range instanceof Error) {
          return range;
        }
        var result = 0;
        for (var i = 0; i < range.length; i++) {
          result += eval(range[i] + criteria) ? range[i] : 0;
        }
        return result;
      };
      exports.SUMIFS = function() {
        var args = utils.argsToArray(arguments);
        var range = utils.parseNumberArray(utils.flatten(args.shift()));
        if (range instanceof Error) {
          return range;
        }
        var criteria = args;
        var n_range_elements = range.length;
        var n_criterias = criteria.length;
        var result = 0;
        for (var i = 0; i < n_range_elements; i++) {
          var el = range[i];
          var condition = "";
          for (var c = 0; c < n_criterias; c += 2) {
            if (isNaN(criteria[c][i])) {
              condition += '"' + criteria[c][i] + '"' + criteria[c + 1];
            } else {
              condition += criteria[c][i] + criteria[c + 1];
            }
            if (c !== n_criterias - 1) {
              condition += " && ";
            }
          }
          condition = condition.slice(0, -4);
          if (eval(condition)) {
            result += el;
          }
        }
        return result;
      };
      exports.SUMPRODUCT = null;
      exports.SUMSQ = function() {
        var numbers2 = utils.parseNumberArray(utils.flatten(arguments));
        if (numbers2 instanceof Error) {
          return numbers2;
        }
        var result2 = 0;
        var length = numbers2.length;
        for (var i2 = 0; i2 < length; i2++) {
          result2 += ISNUMBER(numbers2[i2]) ? numbers2[i2] * numbers2[i2] : 0;
        }
        return result2;
      };
      exports.SUMX2MY2 = function(array_x, array_y) {
        array_x = utils.parseNumberArray(utils.flatten(array_x));
        array_y = utils.parseNumberArray(utils.flatten(array_y));
        if (utils.anyIsError(array_x, array_y)) {
          return error.value;
        }
        var result2 = 0;
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result2 += array_x[i2] * array_x[i2] - array_y[i2] * array_y[i2];
        }
        return result2;
      };
      exports.SUMX2PY2 = function(array_x, array_y) {
        array_x = utils.parseNumberArray(utils.flatten(array_x));
        array_y = utils.parseNumberArray(utils.flatten(array_y));
        if (utils.anyIsError(array_x, array_y)) {
          return error.value;
        }
        var result2 = 0;
        array_x = utils.parseNumberArray(utils.flatten(array_x));
        array_y = utils.parseNumberArray(utils.flatten(array_y));
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result2 += array_x[i2] * array_x[i2] + array_y[i2] * array_y[i2];
        }
        return result2;
      };
      exports.SUMXMY2 = function(array_x, array_y) {
        array_x = utils.parseNumberArray(utils.flatten(array_x));
        array_y = utils.parseNumberArray(utils.flatten(array_y));
        if (utils.anyIsError(array_x, array_y)) {
          return error.value;
        }
        var result2 = 0;
        array_x = utils.flatten(array_x);
        array_y = utils.flatten(array_y);
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result2 += Math.pow(array_x[i2] - array_y[i2], 2);
        }
        return result2;
      };
      exports.TAN = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return Math.tan(number2);
      };
      exports.TANH = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        var e2 = Math.exp(2 * number2);
        return (e2 - 1) / (e2 + 1);
      };
      exports.TRUNC = function(number2, digits) {
        digits = digits === void 0 ? 0 : digits;
        number2 = utils.parseNumber(number2);
        digits = utils.parseNumber(digits);
        if (utils.anyIsError(number2, digits)) {
          return error.value;
        }
        var sign = number2 > 0 ? 1 : -1;
        return sign * Math.floor(Math.abs(number2) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      return exports;
    }();
    met.misc = function() {
      var exports2 = {};
      exports2.UNIQUE = function() {
        var result2 = [];
        for (var i2 = 0; i2 < arguments.length; ++i2) {
          var hasElement = false;
          var element2 = arguments[i2];
          for (var j2 = 0; j2 < result2.length; ++j2) {
            hasElement = result2[j2] === element2;
            if (hasElement) {
              break;
            }
          }
          if (!hasElement) {
            result2.push(element2);
          }
        }
        return result2;
      };
      exports2.FLATTEN = utils.flatten;
      exports2.ARGS2ARRAY = function() {
        return Array.prototype.slice.call(arguments, 0);
      };
      exports2.REFERENCE = function(context, reference) {
        try {
          var path2 = reference.split(".");
          var result2 = context;
          for (var i2 = 0; i2 < path2.length; ++i2) {
            var step = path2[i2];
            if (step[step.length - 1] === "]") {
              var opening = step.indexOf("[");
              var index2 = step.substring(opening + 1, step.length - 1);
              result2 = result2[step.substring(0, opening)][index2];
            } else {
              result2 = result2[step];
            }
          }
          return result2;
        } catch (error2) {
        }
      };
      exports2.JOIN = function(array, separator) {
        return array.join(separator);
      };
      exports2.NUMBERS = function() {
        var possibleNumbers = utils.flatten(arguments);
        return possibleNumbers.filter(function(el2) {
          return typeof el2 === "number";
        });
      };
      exports2.NUMERAL = null;
      return exports2;
    }();
    met.text = function() {
      var exports2 = {};
      exports2.ASC = null;
      exports2.BAHTTEXT = null;
      exports2.CHAR = function(number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return String.fromCharCode(number2);
      };
      exports2.CLEAN = function(text2) {
        text2 = text2 || "";
        var re = /[\0-\x1F]/g;
        return text2.replace(re, "");
      };
      exports2.CODE = function(text2) {
        text2 = text2 || "";
        return text2.charCodeAt(0);
      };
      exports2.CONCATENATE = function() {
        var args2 = utils.flatten(arguments);
        var trueFound = 0;
        while ((trueFound = args2.indexOf(true)) > -1) {
          args2[trueFound] = "TRUE";
        }
        var falseFound = 0;
        while ((falseFound = args2.indexOf(false)) > -1) {
          args2[falseFound] = "FALSE";
        }
        return args2.join("");
      };
      exports2.DBCS = null;
      exports2.DOLLAR = null;
      exports2.EXACT = function(text1, text2) {
        return text1 === text2;
      };
      exports2.FIND = function(find_text, within_text, position2) {
        position2 = position2 === void 0 ? 0 : position2;
        return within_text ? within_text.indexOf(find_text, position2 - 1) + 1 : null;
      };
      exports2.FIXED = null;
      exports2.HTML2TEXT = function(value2) {
        var result2 = "";
        if (value2) {
          if (value2 instanceof Array) {
            value2.forEach(function(line) {
              if (result2 !== "") {
                result2 += "\n";
              }
              result2 += line.replace(/<(?:.|\n)*?>/gm, "");
            });
          } else {
            result2 = value2.replace(/<(?:.|\n)*?>/gm, "");
          }
        }
        return result2;
      };
      exports2.LEFT = function(text2, number2) {
        number2 = number2 === void 0 ? 1 : number2;
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error || typeof text2 !== "string") {
          return error.value;
        }
        return text2 ? text2.substring(0, number2) : null;
      };
      exports2.LEN = function(text2) {
        if (arguments.length === 0) {
          return error.error;
        }
        if (typeof text2 === "string") {
          return text2 ? text2.length : 0;
        }
        if (text2.length) {
          return text2.length;
        }
        return error.value;
      };
      exports2.LOWER = function(text2) {
        if (typeof text2 !== "string") {
          return error.value;
        }
        return text2 ? text2.toLowerCase() : text2;
      };
      exports2.MID = function(text2, start, number2) {
        start = utils.parseNumber(start);
        number2 = utils.parseNumber(number2);
        if (utils.anyIsError(start, number2) || typeof text2 !== "string") {
          return number2;
        }
        var begin = start - 1;
        var end = begin + number2;
        return text2.substring(begin, end);
      };
      exports2.NUMBERVALUE = null;
      exports2.PRONETIC = null;
      exports2.PROPER = function(text2) {
        if (text2 === void 0 || text2.length === 0) {
          return error.value;
        }
        if (text2 === true) {
          text2 = "TRUE";
        }
        if (text2 === false) {
          text2 = "FALSE";
        }
        if (isNaN(text2) && typeof text2 === "number") {
          return error.value;
        }
        if (typeof text2 === "number") {
          text2 = "" + text2;
        }
        return text2.replace(/\w\S*/g, function(txt) {
          return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
      };
      exports2.REGEXEXTRACT = function(text2, regular_expression) {
        var match = text2.match(new RegExp(regular_expression));
        return match ? match[match.length > 1 ? match.length - 1 : 0] : null;
      };
      exports2.REGEXMATCH = function(text2, regular_expression, full) {
        var match = text2.match(new RegExp(regular_expression));
        return full ? match : !!match;
      };
      exports2.REGEXREPLACE = function(text2, regular_expression, replacement) {
        return text2.replace(new RegExp(regular_expression), replacement);
      };
      exports2.REPLACE = function(text2, position2, length, new_text) {
        position2 = utils.parseNumber(position2);
        length = utils.parseNumber(length);
        if (utils.anyIsError(position2, length) || typeof text2 !== "string" || typeof new_text !== "string") {
          return error.value;
        }
        return text2.substr(0, position2 - 1) + new_text + text2.substr(position2 - 1 + length);
      };
      exports2.REPT = function(text2, number2) {
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return new Array(number2 + 1).join(text2);
      };
      exports2.RIGHT = function(text2, number2) {
        number2 = number2 === void 0 ? 1 : number2;
        number2 = utils.parseNumber(number2);
        if (number2 instanceof Error) {
          return number2;
        }
        return text2 ? text2.substring(text2.length - number2) : null;
      };
      exports2.SEARCH = function(find_text, within_text, position2) {
        var foundAt;
        if (typeof find_text !== "string" || typeof within_text !== "string") {
          return error.value;
        }
        position2 = position2 === void 0 ? 0 : position2;
        foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position2 - 1) + 1;
        return foundAt === 0 ? error.value : foundAt;
      };
      exports2.SPLIT = function(text2, separator) {
        return text2.split(separator);
      };
      exports2.SUBSTITUTE = function(text2, old_text, new_text, occurrence) {
        if (!text2 || !old_text || !new_text) {
          return text2;
        } else if (occurrence === void 0) {
          return text2.replace(new RegExp(old_text, "g"), new_text);
        } else {
          var index2 = 0;
          var i2 = 0;
          while (text2.indexOf(old_text, index2) > 0) {
            index2 = text2.indexOf(old_text, index2 + 1);
            i2++;
            if (i2 === occurrence) {
              return text2.substring(0, index2) + new_text + text2.substring(index2 + old_text.length);
            }
          }
        }
      };
      exports2.T = function(value2) {
        return typeof value2 === "string" ? value2 : "";
      };
      exports2.TEXT = null;
      exports2.TRIM = function(text2) {
        if (typeof text2 !== "string") {
          return error.value;
        }
        return text2.replace(/ +/g, " ").trim();
      };
      exports2.UNICHAR = exports2.CHAR;
      exports2.UNICODE = exports2.CODE;
      exports2.UPPER = function(text2) {
        if (typeof text2 !== "string") {
          return error.value;
        }
        return text2.toUpperCase();
      };
      exports2.VALUE = null;
      return exports2;
    }();
    met.stats = function() {
      var exports = {};
      var SQRT2PI = 2.5066282746310002;
      exports.AVEDEV = null;
      exports.AVERAGE = function() {
        var range2 = utils.numbers(utils.flatten(arguments));
        var n2 = range2.length;
        var sum = 0;
        var count = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          sum += range2[i2];
          count += 1;
        }
        return sum / count;
      };
      exports.AVERAGEA = function() {
        var range2 = utils.flatten(arguments);
        var n2 = range2.length;
        var sum = 0;
        var count = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range2[i2];
          if (typeof el2 === "number") {
            sum += el2;
          }
          if (el2 === true) {
            sum++;
          }
          if (el2 !== null) {
            count++;
          }
        }
        return sum / count;
      };
      exports.AVERAGEIF = function(range, criteria, average_range) {
        average_range = average_range || range;
        range = utils.flatten(range);
        average_range = utils.parseNumberArray(utils.flatten(average_range));
        if (average_range instanceof Error) {
          return average_range;
        }
        var average_count = 0;
        var result = 0;
        for (var i = 0; i < range.length; i++) {
          if (eval(range[i] + criteria)) {
            result += average_range[i];
            average_count++;
          }
        }
        return result / average_count;
      };
      exports.AVERAGEIFS = null;
      exports.COUNT = function() {
        return utils.numbers(utils.flatten(arguments)).length;
      };
      exports.COUNTA = function() {
        var range2 = utils.flatten(arguments);
        return range2.length - exports.COUNTBLANK(range2);
      };
      exports.COUNTIN = function(range2, value2) {
        var result2 = 0;
        for (var i2 = 0; i2 < range2.length; i2++) {
          if (range2[i2] === value2) {
            result2++;
          }
        }
        return result2;
      };
      exports.COUNTBLANK = function() {
        var range2 = utils.flatten(arguments);
        var blanks = 0;
        var element2;
        for (var i2 = 0; i2 < range2.length; i2++) {
          element2 = range2[i2];
          if (element2 === null || element2 === "") {
            blanks++;
          }
        }
        return blanks;
      };
      exports.COUNTIF = function() {
        var args = utils.argsToArray(arguments);
        var criteria = args.pop();
        var range = utils.flatten(args);
        if (!/[<>=!]/.test(criteria)) {
          criteria = '=="' + criteria + '"';
        }
        var matches = 0;
        for (var i = 0; i < range.length; i++) {
          if (typeof range[i] !== "string") {
            if (eval(range[i] + criteria)) {
              matches++;
            }
          } else {
            if (eval('"' + range[i] + '"' + criteria)) {
              matches++;
            }
          }
        }
        return matches;
      };
      exports.COUNTIFS = function() {
        var args = utils.argsToArray(arguments);
        var results = new Array(utils.flatten(args[0]).length);
        for (var i = 0; i < results.length; i++) {
          results[i] = true;
        }
        for (i = 0; i < args.length; i += 2) {
          var range = utils.flatten(args[i]);
          var criteria = args[i + 1];
          if (!/[<>=!]/.test(criteria)) {
            criteria = '=="' + criteria + '"';
          }
          for (var j = 0; j < range.length; j++) {
            if (typeof range[j] !== "string") {
              results[j] = results[j] && eval(range[j] + criteria);
            } else {
              results[j] = results[j] && eval('"' + range[j] + '"' + criteria);
            }
          }
        }
        var result = 0;
        for (i = 0; i < results.length; i++) {
          if (results[i]) {
            result++;
          }
        }
        return result;
      };
      exports.COUNTUNIQUE = function() {
        return UNIQUE.apply(null, utils.flatten(arguments)).length;
      };
      exports.FISHER = function(x2) {
        x2 = utils.parseNumber(x2);
        if (x2 instanceof Error) {
          return x2;
        }
        return Math.log((1 + x2) / (1 - x2)) / 2;
      };
      exports.FISHERINV = function(y2) {
        y2 = utils.parseNumber(y2);
        if (y2 instanceof Error) {
          return y2;
        }
        var e2y = Math.exp(2 * y2);
        return (e2y - 1) / (e2y + 1);
      };
      exports.FREQUENCY = function(data, bins) {
        data = utils.parseNumberArray(utils.flatten(data));
        bins = utils.parseNumberArray(utils.flatten(bins));
        if (utils.anyIsError(data, bins)) {
          return error.value;
        }
        var n2 = data.length;
        var b = bins.length;
        var r = [];
        for (var i2 = 0; i2 <= b; i2++) {
          r[i2] = 0;
          for (var j2 = 0; j2 < n2; j2++) {
            if (i2 === 0) {
              if (data[j2] <= bins[0]) {
                r[0] += 1;
              }
            } else if (i2 < b) {
              if (data[j2] > bins[i2 - 1] && data[j2] <= bins[i2]) {
                r[i2] += 1;
              }
            } else if (i2 === b) {
              if (data[j2] > bins[b - 1]) {
                r[b] += 1;
              }
            }
          }
        }
        return r;
      };
      exports.LARGE = function(range2, k2) {
        range2 = utils.parseNumberArray(utils.flatten(range2));
        k2 = utils.parseNumber(k2);
        if (utils.anyIsError(range2, k2)) {
          return range2;
        }
        return range2.sort(function(a, b) {
          return b - a;
        })[k2 - 1];
      };
      exports.MAX = function() {
        var range2 = utils.numbers(utils.flatten(arguments));
        return range2.length === 0 ? 0 : Math.max.apply(Math, range2);
      };
      exports.MAXA = function() {
        var range2 = utils.arrayValuesToNumbers(utils.flatten(arguments));
        return range2.length === 0 ? 0 : Math.max.apply(Math, range2);
      };
      exports.MIN = function() {
        var range2 = utils.numbers(utils.flatten(arguments));
        return range2.length === 0 ? 0 : Math.min.apply(Math, range2);
      };
      exports.MINA = function() {
        var range2 = utils.arrayValuesToNumbers(utils.flatten(arguments));
        return range2.length === 0 ? 0 : Math.min.apply(Math, range2);
      };
      exports.MODE = {};
      exports.MODE.MULT = function() {
        var range2 = utils.parseNumberArray(utils.flatten(arguments));
        if (range2 instanceof Error) {
          return range2;
        }
        var n2 = range2.length;
        var count = {};
        var maxItems = [];
        var max = 0;
        var currentItem;
        for (var i2 = 0; i2 < n2; i2++) {
          currentItem = range2[i2];
          count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
          if (count[currentItem] > max) {
            max = count[currentItem];
            maxItems = [];
          }
          if (count[currentItem] === max) {
            maxItems[maxItems.length] = currentItem;
          }
        }
        return maxItems;
      };
      exports.MODE.SNGL = function() {
        var range2 = utils.parseNumberArray(utils.flatten(arguments));
        if (range2 instanceof Error) {
          return range2;
        }
        return exports.MODE.MULT(range2).sort(function(a, b) {
          return a - b;
        })[0];
      };
      exports.PERCENTILE = {};
      exports.PERCENTILE.EXC = function(array, k2) {
        array = utils.parseNumberArray(utils.flatten(array));
        k2 = utils.parseNumber(k2);
        if (utils.anyIsError(array, k2)) {
          return error.value;
        }
        array = array.sort(function(a, b) {
          {
            return a - b;
          }
        });
        var n2 = array.length;
        if (k2 < 1 / (n2 + 1) || k2 > 1 - 1 / (n2 + 1)) {
          return error.num;
        }
        var l2 = k2 * (n2 + 1) - 1;
        var fl = Math.floor(l2);
        return utils.cleanFloat(l2 === fl ? array[l2] : array[fl] + (l2 - fl) * (array[fl + 1] - array[fl]));
      };
      exports.PERCENTILE.INC = function(array, k2) {
        array = utils.parseNumberArray(utils.flatten(array));
        k2 = utils.parseNumber(k2);
        if (utils.anyIsError(array, k2)) {
          return error.value;
        }
        array = array.sort(function(a, b) {
          return a - b;
        });
        var n2 = array.length;
        var l2 = k2 * (n2 - 1);
        var fl = Math.floor(l2);
        return utils.cleanFloat(l2 === fl ? array[l2] : array[fl] + (l2 - fl) * (array[fl + 1] - array[fl]));
      };
      exports.PERCENTRANK = {};
      exports.PERCENTRANK.EXC = function(array, x2, significance) {
        significance = significance === void 0 ? 3 : significance;
        array = utils.parseNumberArray(utils.flatten(array));
        x2 = utils.parseNumber(x2);
        significance = utils.parseNumber(significance);
        if (utils.anyIsError(array, x2, significance)) {
          return error.value;
        }
        array = array.sort(function(a, b) {
          return a - b;
        });
        var uniques = UNIQUE.apply(null, array);
        var n2 = array.length;
        var m = uniques.length;
        var power = Math.pow(10, significance);
        var result2 = 0;
        var match = false;
        var i2 = 0;
        while (!match && i2 < m) {
          if (x2 === uniques[i2]) {
            result2 = (array.indexOf(uniques[i2]) + 1) / (n2 + 1);
            match = true;
          } else if (x2 >= uniques[i2] && (x2 < uniques[i2 + 1] || i2 === m - 1)) {
            result2 = (array.indexOf(uniques[i2]) + 1 + (x2 - uniques[i2]) / (uniques[i2 + 1] - uniques[i2])) / (n2 + 1);
            match = true;
          }
          i2++;
        }
        return Math.floor(result2 * power) / power;
      };
      exports.PERCENTRANK.INC = function(array, x2, significance) {
        significance = significance === void 0 ? 3 : significance;
        array = utils.parseNumberArray(utils.flatten(array));
        x2 = utils.parseNumber(x2);
        significance = utils.parseNumber(significance);
        if (utils.anyIsError(array, x2, significance)) {
          return error.value;
        }
        array = array.sort(function(a, b) {
          return a - b;
        });
        var uniques = UNIQUE.apply(null, array);
        var n2 = array.length;
        var m = uniques.length;
        var power = Math.pow(10, significance);
        var result2 = 0;
        var match = false;
        var i2 = 0;
        while (!match && i2 < m) {
          if (x2 === uniques[i2]) {
            result2 = array.indexOf(uniques[i2]) / (n2 - 1);
            match = true;
          } else if (x2 >= uniques[i2] && (x2 < uniques[i2 + 1] || i2 === m - 1)) {
            result2 = (array.indexOf(uniques[i2]) + (x2 - uniques[i2]) / (uniques[i2 + 1] - uniques[i2])) / (n2 - 1);
            match = true;
          }
          i2++;
        }
        return Math.floor(result2 * power) / power;
      };
      exports.PERMUT = function(number2, number_chosen) {
        number2 = utils.parseNumber(number2);
        number_chosen = utils.parseNumber(number_chosen);
        if (utils.anyIsError(number2, number_chosen)) {
          return error.value;
        }
        return FACT(number2) / FACT(number2 - number_chosen);
      };
      exports.PERMUTATIONA = function(number2, number_chosen) {
        number2 = utils.parseNumber(number2);
        number_chosen = utils.parseNumber(number_chosen);
        if (utils.anyIsError(number2, number_chosen)) {
          return error.value;
        }
        return Math.pow(number2, number_chosen);
      };
      exports.PHI = function(x2) {
        x2 = utils.parseNumber(x2);
        if (x2 instanceof Error) {
          return error.value;
        }
        return Math.exp(-0.5 * x2 * x2) / SQRT2PI;
      };
      exports.PROB = function(range2, probability, lower, upper) {
        if (lower === void 0) {
          return 0;
        }
        upper = upper === void 0 ? lower : upper;
        range2 = utils.parseNumberArray(utils.flatten(range2));
        probability = utils.parseNumberArray(utils.flatten(probability));
        lower = utils.parseNumber(lower);
        upper = utils.parseNumber(upper);
        if (utils.anyIsError(range2, probability, lower, upper)) {
          return error.value;
        }
        if (lower === upper) {
          return range2.indexOf(lower) >= 0 ? probability[range2.indexOf(lower)] : 0;
        }
        var sorted = range2.sort(function(a, b) {
          return a - b;
        });
        var n2 = sorted.length;
        var result2 = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          if (sorted[i2] >= lower && sorted[i2] <= upper) {
            result2 += probability[range2.indexOf(sorted[i2])];
          }
        }
        return result2;
      };
      exports.QUARTILE = {};
      exports.QUARTILE.EXC = function(range2, quart) {
        range2 = utils.parseNumberArray(utils.flatten(range2));
        quart = utils.parseNumber(quart);
        if (utils.anyIsError(range2, quart)) {
          return error.value;
        }
        switch (quart) {
          case 1:
            return exports.PERCENTILE.EXC(range2, 0.25);
          case 2:
            return exports.PERCENTILE.EXC(range2, 0.5);
          case 3:
            return exports.PERCENTILE.EXC(range2, 0.75);
          default:
            return error.num;
        }
      };
      exports.QUARTILE.INC = function(range2, quart) {
        range2 = utils.parseNumberArray(utils.flatten(range2));
        quart = utils.parseNumber(quart);
        if (utils.anyIsError(range2, quart)) {
          return error.value;
        }
        switch (quart) {
          case 1:
            return exports.PERCENTILE.INC(range2, 0.25);
          case 2:
            return exports.PERCENTILE.INC(range2, 0.5);
          case 3:
            return exports.PERCENTILE.INC(range2, 0.75);
          default:
            return error.num;
        }
      };
      exports.RANK = {};
      exports.RANK.AVG = function(number2, range2, order) {
        number2 = utils.parseNumber(number2);
        range2 = utils.parseNumberArray(utils.flatten(range2));
        if (utils.anyIsError(number2, range2)) {
          return error.value;
        }
        range2 = utils.flatten(range2);
        order = order || false;
        var sort2 = order ? function(a, b) {
          return a - b;
        } : function(a, b) {
          return b - a;
        };
        range2 = range2.sort(sort2);
        var length = range2.length;
        var count = 0;
        for (var i2 = 0; i2 < length; i2++) {
          if (range2[i2] === number2) {
            count++;
          }
        }
        return count > 1 ? (2 * range2.indexOf(number2) + count + 1) / 2 : range2.indexOf(number2) + 1;
      };
      exports.RANK.EQ = function(number2, range2, order) {
        number2 = utils.parseNumber(number2);
        range2 = utils.parseNumberArray(utils.flatten(range2));
        if (utils.anyIsError(number2, range2)) {
          return error.value;
        }
        order = order || false;
        var sort2 = order ? function(a, b) {
          return a - b;
        } : function(a, b) {
          return b - a;
        };
        range2 = range2.sort(sort2);
        return range2.indexOf(number2) + 1;
      };
      exports.RSQ = function(data_x, data_y) {
        data_x = utils.parseNumberArray(utils.flatten(data_x));
        data_y = utils.parseNumberArray(utils.flatten(data_y));
        if (utils.anyIsError(data_x, data_y)) {
          return error.value;
        }
        return Math.pow(exports.PEARSON(data_x, data_y), 2);
      };
      exports.SMALL = function(range2, k2) {
        range2 = utils.parseNumberArray(utils.flatten(range2));
        k2 = utils.parseNumber(k2);
        if (utils.anyIsError(range2, k2)) {
          return range2;
        }
        return range2.sort(function(a, b) {
          return a - b;
        })[k2 - 1];
      };
      exports.STANDARDIZE = function(x2, mean, sd) {
        x2 = utils.parseNumber(x2);
        mean = utils.parseNumber(mean);
        sd = utils.parseNumber(sd);
        if (utils.anyIsError(x2, mean, sd)) {
          return error.value;
        }
        return (x2 - mean) / sd;
      };
      exports.STDEV = {};
      exports.STDEV.P = function() {
        var v = exports.VAR.P.apply(this, arguments);
        return Math.sqrt(v);
      };
      exports.STDEV.S = function() {
        var v = exports.VAR.S.apply(this, arguments);
        return Math.sqrt(v);
      };
      exports.STDEVA = function() {
        var v = exports.VARA.apply(this, arguments);
        return Math.sqrt(v);
      };
      exports.STDEVPA = function() {
        var v = exports.VARPA.apply(this, arguments);
        return Math.sqrt(v);
      };
      exports.VAR = {};
      exports.VAR.P = function() {
        var range2 = utils.numbers(utils.flatten(arguments));
        var n2 = range2.length;
        var sigma = 0;
        var mean = exports.AVERAGE(range2);
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range2[i2] - mean, 2);
        }
        return sigma / n2;
      };
      exports.VAR.S = function() {
        var range2 = utils.numbers(utils.flatten(arguments));
        var n2 = range2.length;
        var sigma = 0;
        var mean = exports.AVERAGE(range2);
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range2[i2] - mean, 2);
        }
        return sigma / (n2 - 1);
      };
      exports.VARA = function() {
        var range2 = utils.flatten(arguments);
        var n2 = range2.length;
        var sigma = 0;
        var count = 0;
        var mean = exports.AVERAGEA(range2);
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range2[i2];
          if (typeof el2 === "number") {
            sigma += Math.pow(el2 - mean, 2);
          } else if (el2 === true) {
            sigma += Math.pow(1 - mean, 2);
          } else {
            sigma += Math.pow(0 - mean, 2);
          }
          if (el2 !== null) {
            count++;
          }
        }
        return sigma / (count - 1);
      };
      exports.VARPA = function() {
        var range2 = utils.flatten(arguments);
        var n2 = range2.length;
        var sigma = 0;
        var count = 0;
        var mean = exports.AVERAGEA(range2);
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range2[i2];
          if (typeof el2 === "number") {
            sigma += Math.pow(el2 - mean, 2);
          } else if (el2 === true) {
            sigma += Math.pow(1 - mean, 2);
          } else {
            sigma += Math.pow(0 - mean, 2);
          }
          if (el2 !== null) {
            count++;
          }
        }
        return sigma / count;
      };
      exports.WEIBULL = {};
      exports.WEIBULL.DIST = function(x2, alpha, beta, cumulative) {
        x2 = utils.parseNumber(x2);
        alpha = utils.parseNumber(alpha);
        beta = utils.parseNumber(beta);
        if (utils.anyIsError(x2, alpha, beta)) {
          return error.value;
        }
        return cumulative ? 1 - Math.exp(-Math.pow(x2 / beta, alpha)) : Math.pow(x2, alpha - 1) * Math.exp(-Math.pow(x2 / beta, alpha)) * alpha / Math.pow(beta, alpha);
      };
      exports.Z = {};
      exports.Z.TEST = function(range2, x2, sd) {
        range2 = utils.parseNumberArray(utils.flatten(range2));
        x2 = utils.parseNumber(x2);
        if (utils.anyIsError(range2, x2)) {
          return error.value;
        }
        sd = sd || exports.STDEV.S(range2);
        var n2 = range2.length;
        return 1 - exports.NORM.S.DIST((exports.AVERAGE(range2) - x2) / (sd / Math.sqrt(n2)), true);
      };
      return exports;
    }();
    met.utils = function() {
      var exports2 = {};
      exports2.PROGRESS = function(p2, c2) {
        var color2 = c2 ? c2 : "red";
        var value2 = p2 ? p2 : "0";
        return '<div style="width:' + value2 + "%;height:4px;background-color:" + color2 + ';margin-top:1px;"></div>';
      };
      exports2.RATING = function(v) {
        var html2 = '<div class="jrating">';
        for (var i2 = 0; i2 < 5; i2++) {
          if (i2 < v) {
            html2 += '<div class="jrating-selected"></div>';
          } else {
            html2 += "<div></div>";
          }
        }
        html2 += "</div>";
        return html2;
      };
      return exports2;
    }();
    for (var i = 0; i < Object.keys(met).length; i++) {
      var methods = met[Object.keys(met)[i]];
      var keys = Object.keys(methods);
      for (var j = 0; j < keys.length; j++) {
        if (!methods[keys[j]]) {
          window[keys[j]] = function() {
            return keys[j] + "Not implemented";
          };
        } else if (typeof methods[keys[j]] == "function" || typeof methods[keys[j]] == "object") {
          window[keys[j]] = methods[keys[j]];
          window[keys[j]].toString = function() {
            return "#ERROR";
          };
          if (typeof methods[keys[j]] == "object") {
            var tmp = Object.keys(methods[keys[j]]);
            for (var z = 0; z < tmp.length; z++) {
              window[keys[j]][tmp[z]].toString = function() {
                return "#ERROR";
              };
            }
          }
        } else {
          window[keys[j]] = function() {
            return keys[j] + "Not implemented";
          };
        }
      }
    }
    var x = null;
    var y = null;
    var instance = null;
    window["TABLE"] = function() {
      return instance;
    };
    window["COLUMN"] = window["COL"] = function() {
      return parseInt(x) + 1;
    };
    window["ROW"] = function() {
      return parseInt(y) + 1;
    };
    window["CELL"] = function() {
      return F.getColumnNameFromCoords(x, y);
    };
    window["VALUE"] = function(col, row, processed) {
      return instance.getValueFromCoords(parseInt(col) - 1, parseInt(row) - 1, processed);
    };
    window["THISROWCELL"] = function(col) {
      return instance.getValueFromCoords(parseInt(col) - 1, parseInt(y));
    };
    var secureFormula = function(oldValue, runtime) {
      var newValue = "";
      var inside = 0;
      var special = ["=", "!", ">", "<"];
      for (var i2 = 0; i2 < oldValue.length; i2++) {
        if (oldValue[i2] == '"') {
          if (inside == 0) {
            inside = 1;
          } else {
            inside = 0;
          }
        }
        if (inside == 1) {
          newValue += oldValue[i2];
        } else {
          newValue += oldValue[i2].toUpperCase();
          if (runtime == true) {
            if (i2 > 0 && oldValue[i2] == "=" && special.indexOf(oldValue[i2 - 1]) == -1 && special.indexOf(oldValue[i2 + 1]) == -1) {
              newValue += "=";
            }
          }
        }
      }
      newValue = newValue.replace(/\^/g, "**");
      newValue = newValue.replace(/\<\>/g, "!=");
      newValue = newValue.replace(/\&/g, "+");
      newValue = newValue.replace(/\$/g, "");
      return newValue;
    };
    var tokensUpdate = function(tokens2, e) {
      for (var index2 = 0; index2 < tokens2.length; index2++) {
        var f = F.getTokensFromRange(tokens2[index2]);
        e = e.replace(tokens2[index2], "[" + f.join(",") + "]");
      }
      return e;
    };
    var F = function(expression2, variables, i2, j2, obj2) {
      instance = obj2;
      x = i2;
      y = j2;
      var s = "";
      var keys2 = Object.keys(variables);
      if (keys2.length) {
        for (var i2 = 0; i2 < keys2.length; i2++) {
          if (keys2[i2].indexOf(".") == -1 && keys2[i2].indexOf("!") == -1) {
            s += "var " + keys2[i2] + " = " + variables[keys2[i2]] + ";\n";
          } else {
            s += keys2[i2] + " = " + variables[keys2[i2]] + ";\n";
          }
        }
      }
      expression2 = expression2.replace(/\$/g, "");
      expression2 = expression2.replace(/\!/g, ".");
      expression2 = secureFormula(expression2, true);
      var tokens2 = expression2.match(/([A-Z]+[0-9]*\.)?(\$?[A-Z]+\$?[0-9]+):(\$?[A-Z]+\$?[0-9]+)?/g);
      if (tokens2 && tokens2.length) {
        expression2 = tokensUpdate(tokens2, expression2);
      }
      return new Function(s + "; return " + expression2)();
    };
    var getColumnName = function(i2) {
      var letter = "";
      if (i2 > 701) {
        letter += String.fromCharCode(64 + parseInt(i2 / 676));
        letter += String.fromCharCode(64 + parseInt(i2 % 676 / 26));
      } else if (i2 > 25) {
        letter += String.fromCharCode(64 + parseInt(i2 / 26));
      }
      letter += String.fromCharCode(65 + i2 % 26);
      return letter;
    };
    F.getColumnNameFromCoords = function(x2, y2) {
      return getColumnName(parseInt(x2)) + (parseInt(y2) + 1);
    };
    F.getCoordsFromColumnName = function(columnName) {
      var t = /^[a-zA-Z]+/.exec(columnName);
      if (t) {
        var code2 = 0;
        for (var i2 = 0; i2 < t[0].length; i2++) {
          code2 += parseInt(t[0].charCodeAt(i2) - 64) * Math.pow(26, t[0].length - 1 - i2);
        }
        code2--;
        if (code2 < 0) {
          code2 = 0;
        }
        var number2 = parseInt(/[0-9]+$/.exec(columnName)) || null;
        if (number2 > 0) {
          number2--;
        }
        return [code2, number2];
      }
    };
    F.getRangeFromTokens = function(tokens2) {
      tokens2 = tokens2.filter(function(v) {
        return v != "#REF!";
      });
      var d = "";
      var t = "";
      for (var i2 = 0; i2 < tokens2.length; i2++) {
        if (tokens2[i2].indexOf(".") >= 0) {
          d = ".";
        } else if (tokens2[i2].indexOf("!") >= 0) {
          d = "!";
        }
        if (d) {
          t = tokens2[i2].split(d);
          tokens2[i2] = t[1];
          t = t[0] + d;
        }
      }
      tokens2.sort(function(a, b) {
        var t1 = Helpers.getCoordsFromColumnName(a);
        var t2 = Helpers.getCoordsFromColumnName(b);
        if (t1[1] > t2[1]) {
          return 1;
        } else if (t1[1] < t2[1]) {
          return -1;
        } else {
          if (t1[0] > t2[0]) {
            return 1;
          } else if (t1[0] < t2[0]) {
            return -1;
          } else {
            return 0;
          }
        }
      });
      if (!tokens2.length) {
        return "#REF!";
      } else {
        return t + (tokens2[0] + ":" + tokens2[tokens2.length - 1]);
      }
    };
    F.getTokensFromRange = function(range2) {
      if (range2.indexOf(".") > 0) {
        var t = range2.split(".");
        range2 = t[1];
        t = t[0] + ".";
      } else if (range2.indexOf("!") > 0) {
        var t = range2.split("!");
        range2 = t[1];
        t = t[0] + "!";
      } else {
        var t = "";
      }
      var range2 = range2.split(":");
      var e1 = F.getCoordsFromColumnName(range2[0]);
      var e2 = F.getCoordsFromColumnName(range2[1]);
      if (e1[0] <= e2[0]) {
        var x1 = e1[0];
        var x2 = e2[0];
      } else {
        var x1 = e2[0];
        var x2 = e1[0];
      }
      if (e1[1] === null && e2[1] == null) {
        var y1 = null;
        var y2 = null;
        var k2 = Object.keys(vars);
        for (var i2 = 0; i2 < k2.length; i2++) {
          var tmp2 = F.getCoordsFromColumnName(k2[i2]);
          if (tmp2[0] === e1[0]) {
            if (y1 === null || tmp2[1] < y1) {
              y1 = tmp2[1];
            }
          }
          if (tmp2[0] === e2[0]) {
            if (y2 === null || tmp2[1] > y2) {
              y2 = tmp2[1];
            }
          }
        }
      } else {
        if (e1[1] <= e2[1]) {
          var y1 = e1[1];
          var y2 = e2[1];
        } else {
          var y1 = e2[1];
          var y2 = e1[1];
        }
      }
      var f = [];
      for (var j2 = y1; j2 <= y2; j2++) {
        var line = [];
        for (var i2 = x1; i2 <= x2; i2++) {
          line.push(t + F.getColumnNameFromCoords(i2, j2));
        }
        f.push(line);
      }
      return f;
    };
    F.setFormula = function(o) {
      var k2 = Object.keys(o);
      for (var i2 = 0; i2 < k2.length; i2++) {
        if (typeof o[k2[i2]] == "function") {
          window[k2[i2]] = o[k2[i2]];
        }
      }
    };
    return F;
  }();
  if (!jSuites && typeof commonjsRequire$1 === "function") {
    var jSuites = jsuites$1.exports;
  }
  (function(global2, factory2) {
    module.exports = factory2();
  })(commonjsGlobal$1, function() {
    var Version = function() {
      var info = {
        title: "Jspreadsheet",
        version: "4.10.1",
        type: "CE",
        host: "https://bossanova.uk/jspreadsheet",
        license: "MIT",
        print: function() {
          return [this.title + " " + this.type + " " + this.version, this.host, this.license].join("\r\n");
        }
      };
      return function() {
        return info;
      };
    }();
    var isFormula = function(value2) {
      var v = ("" + value2)[0];
      return v == "=" || v == "#" ? true : false;
    };
    var getMask = function(o) {
      if (o.format || o.mask || o.locale) {
        var opt = {};
        if (o.mask) {
          opt.mask = o.mask;
        } else if (o.format) {
          opt.mask = o.format;
        } else {
          opt.locale = o.locale;
          opt.options = o.options;
        }
        if (o.decimal) {
          if (!opt.options) {
            opt.options = {};
          }
          opt.options = { decimal: o.decimal };
        }
        return opt;
      }
      return null;
    };
    var jexcel = function(el, options) {
      var obj = {};
      obj.options = {};
      if (!(el instanceof Element || el instanceof HTMLDocument)) {
        console.error("Jspreadsheet: el is not a valid DOM element");
        return false;
      } else if (el.tagName == "TABLE") {
        if (options = jexcel.createFromTable(el, options)) {
          var div = document.createElement("div");
          el.parentNode.insertBefore(div, el);
          el.remove();
          el = div;
        } else {
          console.error("Jspreadsheet: el is not a valid DOM element");
          return false;
        }
      }
      var defaults = {
        url: null,
        method: "GET",
        requestVariables: null,
        data: null,
        sorting: null,
        copyCompatibility: false,
        root: null,
        rows: [],
        columns: [],
        colHeaders: [],
        colWidths: [],
        colAlignments: [],
        nestedHeaders: null,
        defaultColWidth: 50,
        defaultColAlign: "center",
        defaultRowHeight: null,
        minSpareRows: 0,
        minSpareCols: 0,
        minDimensions: [0, 0],
        allowExport: true,
        includeHeadersOnDownload: false,
        includeHeadersOnCopy: false,
        columnSorting: true,
        columnDrag: false,
        columnResize: true,
        rowResize: false,
        rowDrag: true,
        editable: true,
        allowInsertRow: true,
        allowManualInsertRow: true,
        allowInsertColumn: true,
        allowManualInsertColumn: true,
        allowDeleteRow: true,
        allowDeletingAllRows: false,
        allowDeleteColumn: true,
        allowRenameColumn: true,
        allowComments: false,
        wordWrap: false,
        imageOptions: null,
        csv: null,
        csvFileName: "jspreadsheet",
        csvHeaders: true,
        csvDelimiter: ",",
        parseTableFirstRowAsHeader: false,
        parseTableAutoCellType: false,
        selectionCopy: true,
        mergeCells: {},
        toolbar: null,
        search: false,
        pagination: false,
        paginationOptions: null,
        fullscreen: false,
        lazyLoading: false,
        loadingSpin: false,
        tableOverflow: false,
        tableHeight: "300px",
        tableWidth: null,
        textOverflow: false,
        meta: null,
        style: null,
        classes: null,
        parseFormulas: true,
        autoIncrement: true,
        autoCasting: true,
        secureFormulas: true,
        stripHTML: true,
        stripHTMLOnCopy: false,
        filters: false,
        footers: null,
        onundo: null,
        onredo: null,
        onload: null,
        onchange: null,
        oncomments: null,
        onbeforechange: null,
        onafterchanges: null,
        onbeforeinsertrow: null,
        oninsertrow: null,
        onbeforeinsertcolumn: null,
        oninsertcolumn: null,
        onbeforedeleterow: null,
        ondeleterow: null,
        onbeforedeletecolumn: null,
        ondeletecolumn: null,
        onmoverow: null,
        onmovecolumn: null,
        onresizerow: null,
        onresizecolumn: null,
        onsort: null,
        onselection: null,
        oncopy: null,
        onpaste: null,
        onbeforepaste: null,
        onmerge: null,
        onfocus: null,
        onblur: null,
        onchangeheader: null,
        oncreateeditor: null,
        oneditionstart: null,
        oneditionend: null,
        onchangestyle: null,
        onchangemeta: null,
        onchangepage: null,
        onbeforesave: null,
        onsave: null,
        onevent: null,
        persistance: false,
        updateTable: null,
        detachForUpdates: false,
        freezeColumns: null,
        text: {
          noRecordsFound: "No records found",
          showingPage: "Showing page {0} of {1} entries",
          show: "Show ",
          search: "Search",
          entries: " entries",
          columnName: "Column name",
          insertANewColumnBefore: "Insert a new column before",
          insertANewColumnAfter: "Insert a new column after",
          deleteSelectedColumns: "Delete selected columns",
          renameThisColumn: "Rename this column",
          orderAscending: "Order ascending",
          orderDescending: "Order descending",
          insertANewRowBefore: "Insert a new row before",
          insertANewRowAfter: "Insert a new row after",
          deleteSelectedRows: "Delete selected rows",
          editComments: "Edit comments",
          addComments: "Add comments",
          comments: "Comments",
          clearComments: "Clear comments",
          copy: "Copy...",
          paste: "Paste...",
          saveAs: "Save as...",
          about: "About",
          areYouSureToDeleteTheSelectedRows: "Are you sure to delete the selected rows?",
          areYouSureToDeleteTheSelectedColumns: "Are you sure to delete the selected columns?",
          thisActionWillDestroyAnyExistingMergedCellsAreYouSure: "This action will destroy any existing merged cells. Are you sure?",
          thisActionWillClearYourSearchResultsAreYouSure: "This action will clear your search results. Are you sure?",
          thereIsAConflictWithAnotherMergedCell: "There is a conflict with another merged cell",
          invalidMergeProperties: "Invalid merged properties",
          cellAlreadyMerged: "Cell already merged",
          noCellsSelected: "No cells selected"
        },
        about: true
      };
      for (var property in defaults) {
        if (options && options.hasOwnProperty(property)) {
          if (property === "text") {
            obj.options[property] = defaults[property];
            for (var textKey in options[property]) {
              if (options[property].hasOwnProperty(textKey)) {
                obj.options[property][textKey] = options[property][textKey];
              }
            }
          } else {
            obj.options[property] = options[property];
          }
        } else {
          obj.options[property] = defaults[property];
        }
      }
      obj.el = el;
      obj.corner = null;
      obj.contextMenu = null;
      obj.textarea = null;
      obj.ads = null;
      obj.content = null;
      obj.table = null;
      obj.thead = null;
      obj.tbody = null;
      obj.rows = [];
      obj.results = null;
      obj.searchInput = null;
      obj.toolbar = null;
      obj.pagination = null;
      obj.pageNumber = null;
      obj.headerContainer = null;
      obj.colgroupContainer = null;
      obj.headers = [];
      obj.records = [];
      obj.history = [];
      obj.formula = [];
      obj.colgroup = [];
      obj.selection = [];
      obj.highlighted = [];
      obj.selectedCell = null;
      obj.selectedContainer = null;
      obj.style = [];
      obj.data = null;
      obj.filter = null;
      obj.filters = [];
      obj.cursor = null;
      obj.historyIndex = -1;
      obj.ignoreEvents = false;
      obj.ignoreHistory = false;
      obj.edition = null;
      obj.hashString = null;
      obj.resizing = null;
      obj.dragging = null;
      if (obj.options.lazyLoading == true && (obj.options.tableOverflow == false && obj.options.fullscreen == false)) {
        console.error("Jspreadsheet: The lazyloading only works when tableOverflow = yes or fullscreen = yes");
        obj.options.lazyLoading = false;
      }
      obj.fullscreen = function(activate) {
        if (activate == null) {
          activate = !obj.options.fullscreen;
        }
        if (obj.options.fullscreen != activate) {
          obj.options.fullscreen = activate;
          if (activate == true) {
            el.classList.add("fullscreen");
          } else {
            el.classList.remove("fullscreen");
          }
        }
      };
      obj.dispatch = function(event2) {
        if (!obj.ignoreEvents) {
          if (typeof obj.options.onevent == "function") {
            var ret = obj.options.onevent.apply(this, arguments);
          }
          if (typeof obj.options[event2] == "function") {
            var ret = obj.options[event2].apply(this, Array.prototype.slice.call(arguments, 1));
          }
        }
        if (event2 == "onafterchanges" && obj.options.persistance) {
          var url = obj.options.persistance == true ? obj.options.url : obj.options.persistance;
          var data = obj.prepareJson(arguments[2]);
          obj.save(url, data);
        }
        return ret;
      };
      obj.prepareTable = function() {
        var size = obj.options.columns.length;
        if (obj.options.data && typeof obj.options.data[0] !== "undefined") {
          var keys2 = Object.keys(obj.options.data[0]);
          if (keys2.length > size) {
            size = keys2.length;
          }
        }
        if (obj.options.minDimensions[0] > size) {
          size = obj.options.minDimensions[0];
        }
        var multiple = [];
        for (var i2 = 0; i2 < size; i2++) {
          if (!obj.options.colHeaders[i2]) {
            obj.options.colHeaders[i2] = "";
          }
          if (!obj.options.colWidths[i2]) {
            obj.options.colWidths[i2] = obj.options.defaultColWidth;
          }
          if (!obj.options.colAlignments[i2]) {
            obj.options.colAlignments[i2] = obj.options.defaultColAlign;
          }
          if (!obj.options.columns[i2]) {
            obj.options.columns[i2] = { type: "text" };
          } else if (!obj.options.columns[i2].type) {
            obj.options.columns[i2].type = "text";
          }
          if (!obj.options.columns[i2].name) {
            obj.options.columns[i2].name = keys2 && keys2[i2] ? keys2[i2] : i2;
          }
          if (!obj.options.columns[i2].source) {
            obj.options.columns[i2].source = [];
          }
          if (!obj.options.columns[i2].options) {
            obj.options.columns[i2].options = [];
          }
          if (!obj.options.columns[i2].editor) {
            obj.options.columns[i2].editor = null;
          }
          if (!obj.options.columns[i2].allowEmpty) {
            obj.options.columns[i2].allowEmpty = false;
          }
          if (!obj.options.columns[i2].title) {
            obj.options.columns[i2].title = obj.options.colHeaders[i2] ? obj.options.colHeaders[i2] : "";
          }
          if (!obj.options.columns[i2].width) {
            obj.options.columns[i2].width = obj.options.colWidths[i2] ? obj.options.colWidths[i2] : obj.options.defaultColWidth;
          }
          if (!obj.options.columns[i2].align) {
            obj.options.columns[i2].align = obj.options.colAlignments[i2] ? obj.options.colAlignments[i2] : "center";
          }
          if (obj.options.columns[i2].type == "autocomplete" || obj.options.columns[i2].type == "dropdown") {
            if (obj.options.columns[i2].url) {
              multiple.push({
                url: obj.options.columns[i2].url,
                index: i2,
                method: "GET",
                dataType: "json",
                success: function(data) {
                  for (var i3 = 0; i3 < data.length; i3++) {
                    obj.options.columns[this.index].source.push(data[i3]);
                  }
                }
              });
            }
          } else if (obj.options.columns[i2].type == "calendar") {
            if (!obj.options.columns[i2].options.format) {
              obj.options.columns[i2].options.format = "DD/MM/YYYY";
            }
          }
        }
        if (!multiple.length) {
          obj.createTable();
        } else {
          jSuites.ajax(multiple, function() {
            obj.createTable();
          });
        }
      };
      obj.createTable = function() {
        obj.table = document.createElement("table");
        obj.thead = document.createElement("thead");
        obj.tbody = document.createElement("tbody");
        obj.headers = [];
        obj.colgroup = [];
        obj.content = document.createElement("div");
        obj.content.classList.add("jexcel_content");
        obj.content.onscroll = function(e) {
          obj.scrollControls(e);
        };
        obj.content.onwheel = function(e) {
          obj.wheelControls(e);
        };
        obj.toolbar = document.createElement("div");
        obj.toolbar.classList.add("jexcel_toolbar");
        var searchContainer = document.createElement("div");
        var searchText = document.createTextNode(obj.options.text.search + ": ");
        obj.searchInput = document.createElement("input");
        obj.searchInput.classList.add("jexcel_search");
        searchContainer.appendChild(searchText);
        searchContainer.appendChild(obj.searchInput);
        obj.searchInput.onfocus = function() {
          obj.resetSelection();
        };
        var paginationUpdateContainer = document.createElement("div");
        if (obj.options.pagination > 0 && obj.options.paginationOptions && obj.options.paginationOptions.length > 0) {
          obj.paginationDropdown = document.createElement("select");
          obj.paginationDropdown.classList.add("jexcel_pagination_dropdown");
          obj.paginationDropdown.onchange = function() {
            obj.options.pagination = parseInt(this.value);
            obj.page(0);
          };
          for (var i2 = 0; i2 < obj.options.paginationOptions.length; i2++) {
            var temp = document.createElement("option");
            temp.value = obj.options.paginationOptions[i2];
            temp.innerHTML = obj.options.paginationOptions[i2];
            obj.paginationDropdown.appendChild(temp);
          }
          obj.paginationDropdown.value = obj.options.pagination;
          paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.show));
          paginationUpdateContainer.appendChild(obj.paginationDropdown);
          paginationUpdateContainer.appendChild(document.createTextNode(obj.options.text.entries));
        }
        var filter = document.createElement("div");
        filter.classList.add("jexcel_filter");
        filter.appendChild(paginationUpdateContainer);
        filter.appendChild(searchContainer);
        obj.colgroupContainer = document.createElement("colgroup");
        var tempCol = document.createElement("col");
        tempCol.setAttribute("width", "50");
        obj.colgroupContainer.appendChild(tempCol);
        if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
          if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
            for (var j2 = 0; j2 < obj.options.nestedHeaders.length; j2++) {
              obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders[j2]));
            }
          } else {
            obj.thead.appendChild(obj.createNestedHeader(obj.options.nestedHeaders));
          }
        }
        obj.headerContainer = document.createElement("tr");
        var tempCol = document.createElement("td");
        tempCol.classList.add("jexcel_selectall");
        obj.headerContainer.appendChild(tempCol);
        for (var i2 = 0; i2 < obj.options.columns.length; i2++) {
          obj.createCellHeader(i2);
          obj.headerContainer.appendChild(obj.headers[i2]);
          obj.colgroupContainer.appendChild(obj.colgroup[i2]);
        }
        obj.thead.appendChild(obj.headerContainer);
        if (obj.options.filters == true) {
          obj.filter = document.createElement("tr");
          var td = document.createElement("td");
          obj.filter.appendChild(td);
          for (var i2 = 0; i2 < obj.options.columns.length; i2++) {
            var td = document.createElement("td");
            td.innerHTML = "&nbsp;";
            td.setAttribute("data-x", i2);
            td.className = "jexcel_column_filter";
            if (obj.options.columns[i2].type == "hidden") {
              td.style.display = "none";
            }
            obj.filter.appendChild(td);
          }
          obj.thead.appendChild(obj.filter);
        }
        obj.table = document.createElement("table");
        obj.table.classList.add("jexcel");
        obj.table.setAttribute("cellpadding", "0");
        obj.table.setAttribute("cellspacing", "0");
        obj.table.setAttribute("unselectable", "yes");
        obj.table.appendChild(obj.colgroupContainer);
        obj.table.appendChild(obj.thead);
        obj.table.appendChild(obj.tbody);
        if (!obj.options.textOverflow) {
          obj.table.classList.add("jexcel_overflow");
        }
        obj.corner = document.createElement("div");
        obj.corner.className = "jexcel_corner";
        obj.corner.setAttribute("unselectable", "on");
        obj.corner.setAttribute("onselectstart", "return false");
        if (obj.options.selectionCopy == false) {
          obj.corner.style.display = "none";
        }
        obj.textarea = document.createElement("textarea");
        obj.textarea.className = "jexcel_textarea";
        obj.textarea.id = "jexcel_textarea";
        obj.textarea.tabIndex = "-1";
        obj.contextMenu = document.createElement("div");
        obj.contextMenu.className = "jexcel_contextmenu";
        jSuites.contextmenu(obj.contextMenu, {
          onclick: function() {
            obj.contextMenu.contextmenu.close(false);
          }
        });
        var ads = document.createElement("a");
        ads.setAttribute("href", "https://bossanova.uk/jspreadsheet/");
        obj.ads = document.createElement("div");
        obj.ads.className = "jexcel_about";
        try {
          if (typeof sessionStorage !== "undefined" && !sessionStorage.getItem("jexcel")) {
            sessionStorage.setItem("jexcel", true);
            var img = document.createElement("img");
            img.src = "//bossanova.uk/jspreadsheet/logo.png";
            ads.appendChild(img);
          }
        } catch (exception2) {
        }
        var span = document.createElement("span");
        span.innerHTML = "Jspreadsheet CE";
        ads.appendChild(span);
        obj.ads.appendChild(ads);
        var container = document.createElement("div");
        container.classList.add("jexcel_table");
        obj.pagination = document.createElement("div");
        obj.pagination.classList.add("jexcel_pagination");
        var paginationInfo = document.createElement("div");
        var paginationPages = document.createElement("div");
        obj.pagination.appendChild(paginationInfo);
        obj.pagination.appendChild(paginationPages);
        if (!obj.options.pagination) {
          obj.pagination.style.display = "none";
        }
        if (obj.options.search == true) {
          el.appendChild(filter);
        }
        obj.content.appendChild(obj.table);
        obj.content.appendChild(obj.corner);
        obj.content.appendChild(obj.textarea);
        el.appendChild(obj.toolbar);
        el.appendChild(obj.content);
        el.appendChild(obj.pagination);
        el.appendChild(obj.contextMenu);
        el.appendChild(obj.ads);
        el.classList.add("jexcel_container");
        if (obj.options.toolbar && obj.options.toolbar.length) {
          obj.createToolbar();
        }
        if (obj.options.fullscreen == true) {
          el.classList.add("fullscreen");
        } else {
          if (obj.options.tableOverflow == true) {
            if (obj.options.tableHeight) {
              obj.content.style["overflow-y"] = "auto";
              obj.content.style["box-shadow"] = "rgb(221 221 221) 2px 2px 5px 0.1px";
              obj.content.style.maxHeight = obj.options.tableHeight;
            }
            if (obj.options.tableWidth) {
              obj.content.style["overflow-x"] = "auto";
              obj.content.style.width = obj.options.tableWidth;
            }
          }
        }
        if (obj.options.tableOverflow != true && obj.options.toolbar) {
          el.classList.add("with-toolbar");
        }
        if (obj.options.columnDrag == true) {
          obj.thead.classList.add("draggable");
        }
        if (obj.options.columnResize == true) {
          obj.thead.classList.add("resizable");
        }
        if (obj.options.rowDrag == true) {
          obj.tbody.classList.add("draggable");
        }
        if (obj.options.rowResize == true) {
          obj.tbody.classList.add("resizable");
        }
        obj.setData();
        if (obj.options.style) {
          obj.setStyle(obj.options.style, null, null, 1, 1);
        }
        if (obj.options.classes) {
          var k2 = Object.keys(obj.options.classes);
          for (var i2 = 0; i2 < k2.length; i2++) {
            var cell = jexcel.getIdFromColumnName(k2[i2], true);
            obj.records[cell[1]][cell[0]].classList.add(obj.options.classes[k2[i2]]);
          }
        }
      };
      obj.refresh = function() {
        if (obj.options.url) {
          if (obj.options.loadingSpin == true) {
            jSuites.loading.show();
          }
          jSuites.ajax({
            url: obj.options.url,
            method: obj.options.method,
            data: obj.options.requestVariables,
            dataType: "json",
            success: function(result2) {
              obj.options.data = result2.data ? result2.data : result2;
              obj.setData();
              if (obj.options.loadingSpin == true) {
                jSuites.loading.hide();
              }
            }
          });
        } else {
          obj.setData();
        }
      };
      obj.setData = function(data) {
        if (data) {
          if (typeof data == "string") {
            data = JSON.parse(data);
          }
          obj.options.data = data;
        }
        if (!obj.options.data) {
          obj.options.data = [];
        }
        if (obj.options.data && obj.options.data[0]) {
          if (!Array.isArray(obj.options.data[0])) {
            var data = [];
            for (var j2 = 0; j2 < obj.options.data.length; j2++) {
              var row = [];
              for (var i2 = 0; i2 < obj.options.columns.length; i2++) {
                row[i2] = obj.options.data[j2][obj.options.columns[i2].name];
              }
              data.push(row);
            }
            obj.options.data = data;
          }
        }
        var j2 = 0;
        var i2 = 0;
        var size_i = obj.options.columns.length;
        var size_j = obj.options.data.length;
        var min_i = obj.options.minDimensions[0];
        var min_j = obj.options.minDimensions[1];
        var max_i = min_i > size_i ? min_i : size_i;
        var max_j = min_j > size_j ? min_j : size_j;
        for (j2 = 0; j2 < max_j; j2++) {
          for (i2 = 0; i2 < max_i; i2++) {
            if (obj.options.data[j2] == void 0) {
              obj.options.data[j2] = [];
            }
            if (obj.options.data[j2][i2] == void 0) {
              obj.options.data[j2][i2] = "";
            }
          }
        }
        obj.rows = [];
        obj.results = null;
        obj.records = [];
        obj.history = [];
        obj.historyIndex = -1;
        obj.tbody.innerHTML = "";
        if (obj.options.lazyLoading == true) {
          var startNumber = 0;
          var finalNumber = obj.options.data.length < 100 ? obj.options.data.length : 100;
          if (obj.options.pagination) {
            obj.options.pagination = false;
            console.error("Jspreadsheet: Pagination will be disable due the lazyLoading");
          }
        } else if (obj.options.pagination) {
          if (!obj.pageNumber) {
            obj.pageNumber = 0;
          }
          obj.options.pagination;
          startNumber = obj.options.pagination * obj.pageNumber;
          finalNumber = obj.options.pagination * obj.pageNumber + obj.options.pagination;
          if (obj.options.data.length < finalNumber) {
            finalNumber = obj.options.data.length;
          }
        } else {
          var startNumber = 0;
          var finalNumber = obj.options.data.length;
        }
        for (j2 = 0; j2 < obj.options.data.length; j2++) {
          var tr = obj.createRow(j2, obj.options.data[j2]);
          if (j2 >= startNumber && j2 < finalNumber) {
            obj.tbody.appendChild(tr);
          }
        }
        if (obj.options.lazyLoading == true)
          ;
        else if (obj.options.pagination) {
          obj.updatePagination();
        }
        if (obj.options.mergeCells) {
          var keys2 = Object.keys(obj.options.mergeCells);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var num = obj.options.mergeCells[keys2[i2]];
            obj.setMerge(keys2[i2], num[0], num[1], 1);
          }
        }
        obj.updateTable();
        obj.dispatch("onload", el, obj);
      };
      obj.getData = function(highlighted, dataOnly) {
        var dataset = [];
        var px = 0;
        var py = 0;
        var dataType = dataOnly == true || obj.options.copyCompatibility == false ? true : false;
        var x2 = obj.options.columns.length;
        var y2 = obj.options.data.length;
        for (var j2 = 0; j2 < y2; j2++) {
          px = 0;
          for (var i2 = 0; i2 < x2; i2++) {
            if (!highlighted || obj.records[j2][i2].classList.contains("highlight")) {
              if (!dataset[py]) {
                dataset[py] = [];
              }
              if (!dataType) {
                dataset[py][px] = obj.records[j2][i2].innerHTML;
              } else {
                dataset[py][px] = obj.options.data[j2][i2];
              }
              px++;
            }
          }
          if (px > 0) {
            py++;
          }
        }
        return dataset;
      };
      obj.getJsonRow = function(rowNumber) {
        var rowData = obj.options.data[rowNumber];
        var x2 = obj.options.columns.length;
        var row = {};
        for (var i2 = 0; i2 < x2; i2++) {
          if (!obj.options.columns[i2].name) {
            obj.options.columns[i2].name = i2;
          }
          row[obj.options.columns[i2].name] = rowData[i2];
        }
        return row;
      };
      obj.getJson = function(highlighted) {
        var data = [];
        var x2 = obj.options.columns.length;
        var y2 = obj.options.data.length;
        for (var j2 = 0; j2 < y2; j2++) {
          var row = null;
          for (var i2 = 0; i2 < x2; i2++) {
            if (!highlighted || obj.records[j2][i2].classList.contains("highlight")) {
              if (row == null) {
                row = {};
              }
              if (!obj.options.columns[i2].name) {
                obj.options.columns[i2].name = i2;
              }
              row[obj.options.columns[i2].name] = obj.options.data[j2][i2];
            }
          }
          if (row != null) {
            data.push(row);
          }
        }
        return data;
      };
      obj.prepareJson = function(data) {
        var rows = [];
        for (var i2 = 0; i2 < data.length; i2++) {
          var x2 = data[i2].x;
          var y2 = data[i2].y;
          var k2 = obj.options.columns[x2].name ? obj.options.columns[x2].name : x2;
          if (!rows[y2]) {
            rows[y2] = {
              row: y2,
              data: {}
            };
          }
          rows[y2].data[k2] = data[i2].newValue;
        }
        return rows.filter(function(el2) {
          return el2 != null;
        });
      };
      obj.save = function(url, data) {
        var ret = obj.dispatch("onbeforesave", el, obj, data);
        if (ret) {
          var data = ret;
        } else {
          if (ret === false) {
            return false;
          }
        }
        jSuites.ajax({
          url,
          method: "POST",
          dataType: "json",
          data: { data: JSON.stringify(data) },
          success: function(result2) {
            obj.dispatch("onsave", el, obj, data);
          }
        });
      };
      obj.getRowData = function(rowNumber) {
        return obj.options.data[rowNumber];
      };
      obj.setRowData = function(rowNumber, data) {
        for (var i2 = 0; i2 < obj.headers.length; i2++) {
          var columnName = jexcel.getColumnNameFromId([i2, rowNumber]);
          if (data[i2] != null) {
            obj.setValue(columnName, data[i2]);
          }
        }
      };
      obj.getColumnData = function(columnNumber) {
        var dataset = [];
        for (var j2 = 0; j2 < obj.options.data.length; j2++) {
          dataset.push(obj.options.data[j2][columnNumber]);
        }
        return dataset;
      };
      obj.setColumnData = function(colNumber, data) {
        for (var j2 = 0; j2 < obj.rows.length; j2++) {
          var columnName = jexcel.getColumnNameFromId([colNumber, j2]);
          if (data[j2] != null) {
            obj.setValue(columnName, data[j2]);
          }
        }
      };
      obj.createRow = function(j2, data) {
        if (!obj.records[j2]) {
          obj.records[j2] = [];
        }
        if (!data) {
          var data = obj.options.data[j2];
        }
        obj.rows[j2] = document.createElement("tr");
        obj.rows[j2].setAttribute("data-y", j2);
        var index2 = null;
        if (obj.options.defaultRowHeight) {
          obj.rows[j2].style.height = obj.options.defaultRowHeight + "px";
        }
        if (obj.options.rows[j2]) {
          if (obj.options.rows[j2].height) {
            obj.rows[j2].style.height = obj.options.rows[j2].height;
          }
          if (obj.options.rows[j2].title) {
            index2 = obj.options.rows[j2].title;
          }
        }
        if (!index2) {
          index2 = parseInt(j2 + 1);
        }
        var td = document.createElement("td");
        td.innerHTML = index2;
        td.setAttribute("data-y", j2);
        td.className = "jexcel_row";
        obj.rows[j2].appendChild(td);
        for (var i2 = 0; i2 < obj.options.columns.length; i2++) {
          obj.records[j2][i2] = obj.createCell(i2, j2, data[i2]);
          obj.rows[j2].appendChild(obj.records[j2][i2]);
        }
        return obj.rows[j2];
      };
      obj.parseValue = function(i2, j2, value2, cell) {
        if (("" + value2).substr(0, 1) == "=" && obj.options.parseFormulas == true) {
          value2 = obj.executeFormula(value2, i2, j2);
        }
        var options2 = obj.options.columns[i2];
        if (options2 && !isFormula(value2)) {
          var opt = null;
          if (opt = getMask(options2)) {
            if (value2 && value2 == Number(value2)) {
              value2 = Number(value2);
            }
            var masked = jSuites.mask.render(value2, opt, true);
            if (cell) {
              if (opt.mask) {
                var t = opt.mask.split(";");
                if (t[1]) {
                  var t1 = t[1].match(new RegExp("\\[Red\\]", "gi"));
                  if (t1) {
                    if (value2 < 0) {
                      cell.classList.add("red");
                    } else {
                      cell.classList.remove("red");
                    }
                  }
                  var t2 = t[1].match(new RegExp("\\(", "gi"));
                  if (t2) {
                    if (value2 < 0) {
                      masked = "(" + masked + ")";
                    }
                  }
                }
              }
            }
            if (masked) {
              value2 = masked;
            }
          }
        }
        return value2;
      };
      var validDate = function(date) {
        date = "" + date;
        if (date.substr(4, 1) == "-" && date.substr(7, 1) == "-") {
          return true;
        } else {
          date = date.split("-");
          if (date[0].length == 4 && date[0] == Number(date[0]) && date[1].length == 2 && date[1] == Number(date[1])) {
            return true;
          }
        }
        return false;
      };
      obj.createCell = function(i2, j2, value2) {
        var td = document.createElement("td");
        td.setAttribute("data-x", i2);
        td.setAttribute("data-y", j2);
        if (("" + value2).substr(0, 1) == "=" && obj.options.secureFormulas == true) {
          var val = secureFormula(value2);
          if (val != value2) {
            value2 = val;
          }
        }
        if (obj.options.columns[i2].editor) {
          if (obj.options.stripHTML === false || obj.options.columns[i2].stripHTML === false) {
            td.innerHTML = value2;
          } else {
            td.innerText = value2;
          }
          if (typeof obj.options.columns[i2].editor.createCell == "function") {
            td = obj.options.columns[i2].editor.createCell(td);
          }
        } else {
          if (obj.options.columns[i2].type == "hidden") {
            td.style.display = "none";
            td.innerText = value2;
          } else if (obj.options.columns[i2].type == "checkbox" || obj.options.columns[i2].type == "radio") {
            var element2 = document.createElement("input");
            element2.type = obj.options.columns[i2].type;
            element2.name = "c" + i2;
            element2.checked = value2 == 1 || value2 == true || value2 == "true" ? true : false;
            element2.onclick = function() {
              obj.setValue(td, this.checked);
            };
            if (obj.options.columns[i2].readOnly == true || obj.options.editable == false) {
              element2.setAttribute("disabled", "disabled");
            }
            td.appendChild(element2);
            obj.options.data[j2][i2] = element2.checked;
          } else if (obj.options.columns[i2].type == "calendar") {
            var formatted = null;
            if (!validDate(value2)) {
              var tmp2 = jSuites.calendar.extractDateFromString(value2, obj.options.columns[i2].options.format);
              if (tmp2) {
                formatted = tmp2;
              }
            }
            td.innerText = jSuites.calendar.getDateString(formatted ? formatted : value2, obj.options.columns[i2].options.format);
          } else if (obj.options.columns[i2].type == "dropdown" || obj.options.columns[i2].type == "autocomplete") {
            td.classList.add("jexcel_dropdown");
            td.innerText = obj.getDropDownValue(i2, value2);
          } else if (obj.options.columns[i2].type == "color") {
            if (obj.options.columns[i2].render == "square") {
              var color2 = document.createElement("div");
              color2.className = "color";
              color2.style.backgroundColor = value2;
              td.appendChild(color2);
            } else {
              td.style.color = value2;
              td.innerText = value2;
            }
          } else if (obj.options.columns[i2].type == "image") {
            if (value2 && value2.substr(0, 10) == "data:image") {
              var img = document.createElement("img");
              img.src = value2;
              td.appendChild(img);
            }
          } else {
            if (obj.options.columns[i2].type == "html") {
              td.innerHTML = stripScript(obj.parseValue(i2, j2, value2, td));
            } else {
              if (obj.options.stripHTML === false || obj.options.columns[i2].stripHTML === false) {
                td.innerHTML = stripScript(obj.parseValue(i2, j2, value2, td));
              } else {
                td.innerText = obj.parseValue(i2, j2, value2, td);
              }
            }
          }
        }
        if (obj.options.columns[i2].readOnly == true) {
          td.className = "readonly";
        }
        var colAlign = obj.options.columns[i2].align ? obj.options.columns[i2].align : "center";
        td.style.textAlign = colAlign;
        if (obj.options.columns[i2].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[i2].wordWrap == true || td.innerHTML.length > 200)) {
          td.style.whiteSpace = "pre-wrap";
        }
        if (i2 > 0) {
          if (this.options.textOverflow == true) {
            if (value2 || td.innerHTML) {
              obj.records[j2][i2 - 1].style.overflow = "hidden";
            } else {
              if (i2 == obj.options.columns.length - 1) {
                td.style.overflow = "hidden";
              }
            }
          }
        }
        return td;
      };
      obj.createCellHeader = function(colNumber) {
        var colWidth = obj.options.columns[colNumber].width ? obj.options.columns[colNumber].width : obj.options.defaultColWidth;
        var colAlign = obj.options.columns[colNumber].align ? obj.options.columns[colNumber].align : obj.options.defaultColAlign;
        obj.headers[colNumber] = document.createElement("td");
        if (obj.options.stripHTML) {
          obj.headers[colNumber].innerText = obj.options.columns[colNumber].title ? obj.options.columns[colNumber].title : jexcel.getColumnName(colNumber);
        } else {
          obj.headers[colNumber].innerHTML = obj.options.columns[colNumber].title ? obj.options.columns[colNumber].title : jexcel.getColumnName(colNumber);
        }
        obj.headers[colNumber].setAttribute("data-x", colNumber);
        obj.headers[colNumber].style.textAlign = colAlign;
        if (obj.options.columns[colNumber].title) {
          obj.headers[colNumber].setAttribute("title", obj.options.columns[colNumber].title);
        }
        if (obj.options.columns[colNumber].id) {
          obj.headers[colNumber].setAttribute("id", obj.options.columns[colNumber].id);
        }
        obj.colgroup[colNumber] = document.createElement("col");
        obj.colgroup[colNumber].setAttribute("width", colWidth);
        if (obj.options.columns[colNumber].type == "hidden") {
          obj.headers[colNumber].style.display = "none";
          obj.colgroup[colNumber].style.display = "none";
        }
      };
      obj.updateNestedHeader = function(x2, y2, title) {
        if (obj.options.nestedHeaders[y2][x2].title) {
          obj.options.nestedHeaders[y2][x2].title = title;
          obj.options.nestedHeaders[y2].element.children[x2 + 1].innerText = title;
        }
      };
      obj.createNestedHeader = function(nestedInformation) {
        var tr = document.createElement("tr");
        tr.classList.add("jexcel_nested");
        var td = document.createElement("td");
        tr.appendChild(td);
        nestedInformation.element = tr;
        var headerIndex = 0;
        for (var i2 = 0; i2 < nestedInformation.length; i2++) {
          if (!nestedInformation[i2].colspan) {
            nestedInformation[i2].colspan = 1;
          }
          if (!nestedInformation[i2].align) {
            nestedInformation[i2].align = "center";
          }
          if (!nestedInformation[i2].title) {
            nestedInformation[i2].title = "";
          }
          var numberOfColumns = nestedInformation[i2].colspan;
          var column = [];
          for (var x2 = 0; x2 < numberOfColumns; x2++) {
            if (obj.options.columns[headerIndex] && obj.options.columns[headerIndex].type == "hidden") {
              numberOfColumns++;
            }
            column.push(headerIndex);
            headerIndex++;
          }
          var td = document.createElement("td");
          td.setAttribute("data-column", column.join(","));
          td.setAttribute("colspan", nestedInformation[i2].colspan);
          td.setAttribute("align", nestedInformation[i2].align);
          td.innerText = nestedInformation[i2].title;
          tr.appendChild(td);
        }
        return tr;
      };
      obj.createToolbar = function(toolbar2) {
        if (toolbar2) {
          obj.options.toolbar = toolbar2;
        } else {
          var toolbar2 = obj.options.toolbar;
        }
        for (var i2 = 0; i2 < toolbar2.length; i2++) {
          if (toolbar2[i2].type == "i") {
            var toolbarItem = document.createElement("i");
            toolbarItem.classList.add("jexcel_toolbar_item");
            toolbarItem.classList.add("material-icons");
            toolbarItem.setAttribute("data-k", toolbar2[i2].k);
            toolbarItem.setAttribute("data-v", toolbar2[i2].v);
            toolbarItem.setAttribute("id", toolbar2[i2].id);
            if (toolbar2[i2].tooltip) {
              toolbarItem.setAttribute("title", toolbar2[i2].tooltip);
            }
            if (toolbar2[i2].onclick && typeof toolbar2[i2].onclick) {
              toolbarItem.onclick = function(a) {
                var b = a;
                return function() {
                  toolbar2[b].onclick(el, obj, this);
                };
              }(i2);
            } else {
              toolbarItem.onclick = function() {
                var k2 = this.getAttribute("data-k");
                var v = this.getAttribute("data-v");
                obj.setStyle(obj.highlighted, k2, v);
              };
            }
            toolbarItem.innerText = toolbar2[i2].content;
            obj.toolbar.appendChild(toolbarItem);
          } else if (toolbar2[i2].type == "select") {
            var toolbarItem = document.createElement("select");
            toolbarItem.classList.add("jexcel_toolbar_item");
            toolbarItem.setAttribute("data-k", toolbar2[i2].k);
            if (toolbar2[i2].tooltip) {
              toolbarItem.setAttribute("title", toolbar2[i2].tooltip);
            }
            if (toolbar2[i2].onchange && typeof toolbar2[i2].onchange) {
              toolbarItem.onchange = toolbar2[i2].onchange;
            } else {
              toolbarItem.onchange = function() {
                var k2 = this.getAttribute("data-k");
                obj.setStyle(obj.highlighted, k2, this.value);
              };
            }
            for (var j2 = 0; j2 < toolbar2[i2].v.length; j2++) {
              var toolbarDropdownOption = document.createElement("option");
              toolbarDropdownOption.value = toolbar2[i2].v[j2];
              toolbarDropdownOption.innerText = toolbar2[i2].v[j2];
              toolbarItem.appendChild(toolbarDropdownOption);
            }
            obj.toolbar.appendChild(toolbarItem);
          } else if (toolbar2[i2].type == "color") {
            var toolbarItem = document.createElement("i");
            toolbarItem.classList.add("jexcel_toolbar_item");
            toolbarItem.classList.add("material-icons");
            toolbarItem.setAttribute("data-k", toolbar2[i2].k);
            toolbarItem.setAttribute("data-v", "");
            if (toolbar2[i2].tooltip) {
              toolbarItem.setAttribute("title", toolbar2[i2].tooltip);
            }
            obj.toolbar.appendChild(toolbarItem);
            toolbarItem.innerText = toolbar2[i2].content;
            jSuites.color(toolbarItem, {
              onchange: function(o, v) {
                var k2 = o.getAttribute("data-k");
                obj.setStyle(obj.highlighted, k2, v);
              }
            });
          }
        }
      };
      obj.setMerge = function(cellName, colspan, rowspan, ignoreHistoryAndEvents) {
        var test = false;
        if (!cellName) {
          if (!obj.highlighted.length) {
            alert(obj.options.text.noCellsSelected);
            return null;
          } else {
            var x1 = parseInt(obj.highlighted[0].getAttribute("data-x"));
            var y1 = parseInt(obj.highlighted[0].getAttribute("data-y"));
            var x2 = parseInt(obj.highlighted[obj.highlighted.length - 1].getAttribute("data-x"));
            var y2 = parseInt(obj.highlighted[obj.highlighted.length - 1].getAttribute("data-y"));
            var cellName = jexcel.getColumnNameFromId([x1, y1]);
            var colspan = x2 - x1 + 1;
            var rowspan = y2 - y1 + 1;
          }
        }
        var cell = jexcel.getIdFromColumnName(cellName, true);
        if (obj.options.mergeCells[cellName]) {
          if (obj.records[cell[1]][cell[0]].getAttribute("data-merged")) {
            test = obj.options.text.cellAlreadyMerged;
          }
        } else if ((!colspan || colspan < 2) && (!rowspan || rowspan < 2)) {
          test = obj.options.text.invalidMergeProperties;
        } else {
          for (var j2 = cell[1]; j2 < cell[1] + rowspan; j2++) {
            for (var i2 = cell[0]; i2 < cell[0] + colspan; i2++) {
              jexcel.getColumnNameFromId([i2, j2]);
              if (obj.records[j2][i2].getAttribute("data-merged")) {
                test = obj.options.text.thereIsAConflictWithAnotherMergedCell;
              }
            }
          }
        }
        if (test) {
          alert(test);
        } else {
          if (colspan > 1) {
            obj.records[cell[1]][cell[0]].setAttribute("colspan", colspan);
          } else {
            colspan = 1;
          }
          if (rowspan > 1) {
            obj.records[cell[1]][cell[0]].setAttribute("rowspan", rowspan);
          } else {
            rowspan = 1;
          }
          obj.options.mergeCells[cellName] = [colspan, rowspan, []];
          obj.records[cell[1]][cell[0]].setAttribute("data-merged", "true");
          obj.records[cell[1]][cell[0]].style.overflow = "hidden";
          var data = [];
          for (var y3 = cell[1]; y3 < cell[1] + rowspan; y3++) {
            for (var x3 = cell[0]; x3 < cell[0] + colspan; x3++) {
              if (!(cell[0] == x3 && cell[1] == y3)) {
                data.push(obj.options.data[y3][x3]);
                obj.updateCell(x3, y3, "", true);
                obj.options.mergeCells[cellName][2].push(obj.records[y3][x3]);
                obj.records[y3][x3].style.display = "none";
                obj.records[y3][x3] = obj.records[cell[1]][cell[0]];
              }
            }
          }
          obj.updateSelection(obj.records[cell[1]][cell[0]]);
          if (!ignoreHistoryAndEvents) {
            obj.setHistory({
              action: "setMerge",
              column: cellName,
              colspan,
              rowspan,
              data
            });
            obj.dispatch("onmerge", el, cellName, colspan, rowspan);
          }
        }
      };
      obj.getMerge = function(cellName) {
        var data = {};
        if (cellName) {
          if (obj.options.mergeCells[cellName]) {
            data = [obj.options.mergeCells[cellName][0], obj.options.mergeCells[cellName][1]];
          } else {
            data = null;
          }
        } else {
          if (obj.options.mergeCells) {
            obj.options.mergeCells;
            var keys2 = Object.keys(obj.options.mergeCells);
            for (var i2 = 0; i2 < keys2.length; i2++) {
              data[keys2[i2]] = [obj.options.mergeCells[keys2[i2]][0], obj.options.mergeCells[keys2[i2]][1]];
            }
          }
        }
        return data;
      };
      obj.removeMerge = function(cellName, data, keepOptions) {
        if (obj.options.mergeCells[cellName]) {
          var cell = jexcel.getIdFromColumnName(cellName, true);
          obj.records[cell[1]][cell[0]].removeAttribute("colspan");
          obj.records[cell[1]][cell[0]].removeAttribute("rowspan");
          obj.records[cell[1]][cell[0]].removeAttribute("data-merged");
          var info = obj.options.mergeCells[cellName];
          var index2 = 0;
          for (var j2 = 0; j2 < info[1]; j2++) {
            for (var i2 = 0; i2 < info[0]; i2++) {
              if (j2 > 0 || i2 > 0) {
                obj.records[cell[1] + j2][cell[0] + i2] = info[2][index2];
                obj.records[cell[1] + j2][cell[0] + i2].style.display = "";
                if (data && data[index2]) {
                  obj.updateCell(cell[0] + i2, cell[1] + j2, data[index2]);
                }
                index2++;
              }
            }
          }
          obj.updateSelection(obj.records[cell[1]][cell[0]], obj.records[cell[1] + j2 - 1][cell[0] + i2 - 1]);
          if (!keepOptions) {
            delete obj.options.mergeCells[cellName];
          }
        }
      };
      obj.destroyMerged = function(keepOptions) {
        if (obj.options.mergeCells) {
          obj.options.mergeCells;
          var keys2 = Object.keys(obj.options.mergeCells);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            obj.removeMerge(keys2[i2], null, keepOptions);
          }
        }
      };
      obj.isColMerged = function(x2, insertBefore) {
        var cols = [];
        if (obj.options.mergeCells) {
          var keys2 = Object.keys(obj.options.mergeCells);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var info = jexcel.getIdFromColumnName(keys2[i2], true);
            var colspan = obj.options.mergeCells[keys2[i2]][0];
            var x1 = info[0];
            var x22 = info[0] + (colspan > 1 ? colspan - 1 : 0);
            if (insertBefore == null) {
              if (x1 <= x2 && x22 >= x2) {
                cols.push(keys2[i2]);
              }
            } else {
              if (insertBefore) {
                if (x1 < x2 && x22 >= x2) {
                  cols.push(keys2[i2]);
                }
              } else {
                if (x1 <= x2 && x22 > x2) {
                  cols.push(keys2[i2]);
                }
              }
            }
          }
        }
        return cols;
      };
      obj.isRowMerged = function(y2, insertBefore) {
        var rows = [];
        if (obj.options.mergeCells) {
          var keys2 = Object.keys(obj.options.mergeCells);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var info = jexcel.getIdFromColumnName(keys2[i2], true);
            var rowspan = obj.options.mergeCells[keys2[i2]][1];
            var y1 = info[1];
            var y22 = info[1] + (rowspan > 1 ? rowspan - 1 : 0);
            if (insertBefore == null) {
              if (y1 <= y2 && y22 >= y2) {
                rows.push(keys2[i2]);
              }
            } else {
              if (insertBefore) {
                if (y1 < y2 && y22 >= y2) {
                  rows.push(keys2[i2]);
                }
              } else {
                if (y1 <= y2 && y22 > y2) {
                  rows.push(keys2[i2]);
                }
              }
            }
          }
        }
        return rows;
      };
      obj.openFilter = function(columnId) {
        if (!obj.options.filters) {
          console.log("Jspreadsheet: filters not enabled.");
        } else {
          columnId = parseInt(columnId);
          obj.resetSelection();
          var optionsFiltered = [];
          if (obj.options.columns[columnId].type == "checkbox") {
            optionsFiltered.push({ id: "true", name: "True" });
            optionsFiltered.push({ id: "false", name: "False" });
          } else {
            var options2 = [];
            var hasBlanks = false;
            for (var j2 = 0; j2 < obj.options.data.length; j2++) {
              var k2 = obj.options.data[j2][columnId];
              var v = obj.records[j2][columnId].innerHTML;
              if (k2 && v) {
                options2[k2] = v;
              } else {
                var hasBlanks = true;
              }
            }
            var keys2 = Object.keys(options2);
            var optionsFiltered = [];
            for (var j2 = 0; j2 < keys2.length; j2++) {
              optionsFiltered.push({ id: keys2[j2], name: options2[keys2[j2]] });
            }
            if (hasBlanks) {
              optionsFiltered.push({ value: "", id: "", name: "(Blanks)" });
            }
          }
          var div2 = document.createElement("div");
          obj.filter.children[columnId + 1].innerHTML = "";
          obj.filter.children[columnId + 1].appendChild(div2);
          obj.filter.children[columnId + 1].style.paddingLeft = "0px";
          obj.filter.children[columnId + 1].style.paddingRight = "0px";
          obj.filter.children[columnId + 1].style.overflow = "initial";
          var opt = {
            data: optionsFiltered,
            multiple: true,
            autocomplete: true,
            opened: true,
            value: obj.filters[columnId] !== void 0 ? obj.filters[columnId] : null,
            width: "100%",
            position: obj.options.tableOverflow == true || obj.options.fullscreen == true ? true : false,
            onclose: function(o) {
              obj.resetFilters();
              obj.filters[columnId] = o.dropdown.getValue(true);
              obj.filter.children[columnId + 1].innerHTML = o.dropdown.getText();
              obj.filter.children[columnId + 1].style.paddingLeft = "";
              obj.filter.children[columnId + 1].style.paddingRight = "";
              obj.filter.children[columnId + 1].style.overflow = "";
              obj.closeFilter(columnId);
              obj.refreshSelection();
            }
          };
          jSuites.dropdown(div2, opt);
        }
      };
      obj.resetFilters = function() {
        if (obj.options.filters) {
          for (var i2 = 0; i2 < obj.filter.children.length; i2++) {
            obj.filter.children[i2].innerHTML = "&nbsp;";
            obj.filters[i2] = null;
          }
        }
        obj.results = null;
        obj.updateResult();
      };
      obj.closeFilter = function(columnId) {
        if (!columnId) {
          for (var i2 = 0; i2 < obj.filter.children.length; i2++) {
            if (obj.filters[i2]) {
              columnId = i2;
            }
          }
        }
        var search = function(query3, x2, y2) {
          for (var i3 = 0; i3 < query3.length; i3++) {
            var value2 = "" + obj.options.data[y2][x2];
            var label = "" + obj.records[y2][x2].innerHTML;
            if (query3[i3] == value2 || query3[i3] == label) {
              return true;
            }
          }
          return false;
        };
        var query2 = obj.filters[columnId];
        obj.results = [];
        for (var j2 = 0; j2 < obj.options.data.length; j2++) {
          if (search(query2, columnId, j2)) {
            obj.results.push(j2);
          }
        }
        if (!obj.results.length) {
          obj.results = null;
        }
        obj.updateResult();
      };
      obj.openEditor = function(cell, empty2, e) {
        var y2 = cell.getAttribute("data-y");
        var x2 = cell.getAttribute("data-x");
        obj.dispatch("oneditionstart", el, cell, x2, y2);
        if (x2 > 0) {
          obj.records[y2][x2 - 1].style.overflow = "hidden";
        }
        var createEditor = function(type2) {
          var info = cell.getBoundingClientRect();
          var editor2 = document.createElement(type2);
          editor2.style.width = info.width + "px";
          editor2.style.height = info.height - 2 + "px";
          editor2.style.minHeight = info.height - 2 + "px";
          cell.classList.add("editor");
          cell.innerHTML = "";
          cell.appendChild(editor2);
          obj.dispatch("oncreateeditor", el, cell, x2, y2, editor2);
          return editor2;
        };
        if (cell.classList.contains("readonly") == true)
          ;
        else {
          obj.edition = [obj.records[y2][x2], obj.records[y2][x2].innerHTML, x2, y2];
          if (obj.options.columns[x2].editor) {
            obj.options.columns[x2].editor.openEditor(cell, el, empty2, e);
          } else {
            if (obj.options.columns[x2].type == "hidden")
              ;
            else if (obj.options.columns[x2].type == "checkbox" || obj.options.columns[x2].type == "radio") {
              var value2 = cell.children[0].checked ? false : true;
              obj.setValue(cell, value2);
              obj.edition = null;
            } else if (obj.options.columns[x2].type == "dropdown" || obj.options.columns[x2].type == "autocomplete") {
              var value2 = obj.options.data[y2][x2];
              if (obj.options.columns[x2].multiple && !Array.isArray(value2)) {
                value2 = value2.split(";");
              }
              if (typeof obj.options.columns[x2].filter == "function") {
                var source = obj.options.columns[x2].filter(el, cell, x2, y2, obj.options.columns[x2].source);
              } else {
                var source = obj.options.columns[x2].source;
              }
              var data = [];
              for (var j2 = 0; j2 < source.length; j2++) {
                data.push(source[j2]);
              }
              var editor = createEditor("div");
              var options2 = {
                data,
                multiple: obj.options.columns[x2].multiple ? true : false,
                autocomplete: obj.options.columns[x2].autocomplete || obj.options.columns[x2].type == "autocomplete" ? true : false,
                opened: true,
                value: value2,
                width: "100%",
                height: editor.style.minHeight,
                position: obj.options.tableOverflow == true || obj.options.fullscreen == true ? true : false,
                onclose: function() {
                  obj.closeEditor(cell, true);
                }
              };
              if (obj.options.columns[x2].options && obj.options.columns[x2].options.type) {
                options2.type = obj.options.columns[x2].options.type;
              }
              jSuites.dropdown(editor, options2);
            } else if (obj.options.columns[x2].type == "calendar" || obj.options.columns[x2].type == "color") {
              var value2 = obj.options.data[y2][x2];
              var editor = createEditor("input");
              editor.value = value2;
              if (obj.options.tableOverflow == true || obj.options.fullscreen == true) {
                obj.options.columns[x2].options.position = true;
              }
              obj.options.columns[x2].options.value = obj.options.data[y2][x2];
              obj.options.columns[x2].options.opened = true;
              obj.options.columns[x2].options.onclose = function(el2, value3) {
                obj.closeEditor(cell, true);
              };
              if (obj.options.columns[x2].type == "color") {
                jSuites.color(editor, obj.options.columns[x2].options);
              } else {
                jSuites.calendar(editor, obj.options.columns[x2].options);
              }
              editor.focus();
            } else if (obj.options.columns[x2].type == "html") {
              var value2 = obj.options.data[y2][x2];
              var editor = createEditor("div");
              editor.style.position = "relative";
              var div2 = document.createElement("div");
              div2.classList.add("jexcel_richtext");
              editor.appendChild(div2);
              jSuites.editor(div2, {
                focus: true,
                value: value2
              });
              var rect = cell.getBoundingClientRect();
              var rectContent = div2.getBoundingClientRect();
              if (window.innerHeight < rect.bottom + rectContent.height) {
                div2.style.top = rect.top - (rectContent.height + 2) + "px";
              } else {
                div2.style.top = rect.top + "px";
              }
            } else if (obj.options.columns[x2].type == "image") {
              var img = cell.children[0];
              var editor = createEditor("div");
              editor.style.position = "relative";
              var div2 = document.createElement("div");
              div2.classList.add("jclose");
              if (img && img.src) {
                div2.appendChild(img);
              }
              editor.appendChild(div2);
              jSuites.image(div2, obj.options.imageOptions);
              var rect = cell.getBoundingClientRect();
              var rectContent = div2.getBoundingClientRect();
              if (window.innerHeight < rect.bottom + rectContent.height) {
                div2.style.top = rect.top - (rectContent.height + 2) + "px";
              } else {
                div2.style.top = rect.top + "px";
              }
            } else {
              var value2 = empty2 == true ? "" : obj.options.data[y2][x2];
              if (obj.options.columns[x2].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[x2].wordWrap == true)) {
                var editor = createEditor("textarea");
              } else {
                var editor = createEditor("input");
              }
              editor.focus();
              editor.value = value2;
              var options2 = obj.options.columns[x2];
              var opt = null;
              if (!isFormula(value2)) {
                if (opt = getMask(options2)) {
                  if (!options2.disabledMaskOnEdition) {
                    if (options2.mask) {
                      var m = options2.mask.split(";");
                      editor.setAttribute("data-mask", m[0]);
                    } else if (options2.locale) {
                      editor.setAttribute("data-locale", options2.locale);
                    }
                  }
                  opt.input = editor;
                  editor.mask = opt;
                  jSuites.mask.render(value2, opt, false);
                }
              }
              editor.onblur = function() {
                obj.closeEditor(cell, true);
              };
              editor.scrollLeft = editor.scrollWidth;
            }
          }
        }
      };
      obj.closeEditor = function(cell, save22) {
        var x2 = parseInt(cell.getAttribute("data-x"));
        var y2 = parseInt(cell.getAttribute("data-y"));
        if (save22 == true) {
          if (obj.options.columns[x2].editor) {
            var value2 = obj.options.columns[x2].editor.closeEditor(cell, save22);
          } else {
            if (obj.options.columns[x2].type == "checkbox" || obj.options.columns[x2].type == "radio" || obj.options.columns[x2].type == "hidden")
              ;
            else if (obj.options.columns[x2].type == "dropdown" || obj.options.columns[x2].type == "autocomplete") {
              var value2 = cell.children[0].dropdown.close(true);
            } else if (obj.options.columns[x2].type == "calendar") {
              var value2 = cell.children[0].calendar.close(true);
            } else if (obj.options.columns[x2].type == "color") {
              var value2 = cell.children[0].color.close(true);
            } else if (obj.options.columns[x2].type == "html") {
              var value2 = cell.children[0].children[0].editor.getData();
            } else if (obj.options.columns[x2].type == "image") {
              var img = cell.children[0].children[0].children[0];
              var value2 = img && img.tagName == "IMG" ? img.src : "";
            } else if (obj.options.columns[x2].type == "numeric") {
              var value2 = cell.children[0].value;
              if (("" + value2).substr(0, 1) != "=") {
                if (value2 == "") {
                  value2 = obj.options.columns[x2].allowEmpty ? "" : 0;
                }
              }
              cell.children[0].onblur = null;
            } else {
              var value2 = cell.children[0].value;
              cell.children[0].onblur = null;
              var options2 = obj.options.columns[x2];
              var opt = null;
              if (opt = getMask(options2)) {
                if (value2 !== "" && !isFormula(value2) && typeof value2 !== "number") {
                  var t = jSuites.mask.extract(value2, opt, true);
                  if (t && t.value !== "") {
                    value2 = t.value;
                  }
                }
              }
            }
          }
          if (obj.options.data[y2][x2] == value2) {
            cell.innerHTML = obj.edition[1];
          } else {
            obj.setValue(cell, value2);
          }
        } else {
          if (obj.options.columns[x2].editor) {
            obj.options.columns[x2].editor.closeEditor(cell, save22);
          } else {
            if (obj.options.columns[x2].type == "dropdown" || obj.options.columns[x2].type == "autocomplete") {
              cell.children[0].dropdown.close(true);
            } else if (obj.options.columns[x2].type == "calendar") {
              cell.children[0].calendar.close(true);
            } else if (obj.options.columns[x2].type == "color") {
              cell.children[0].color.close(true);
            } else {
              cell.children[0].onblur = null;
            }
          }
          cell.innerHTML = obj.edition && obj.edition[1] ? obj.edition[1] : "";
        }
        obj.dispatch("oneditionend", el, cell, x2, y2, value2, save22);
        cell.classList.remove("editor");
        obj.edition = null;
      };
      obj.getCell = function(cell) {
        cell = jexcel.getIdFromColumnName(cell, true);
        var x2 = cell[0];
        var y2 = cell[1];
        return obj.records[y2][x2];
      };
      obj.getColumnOptions = function(x2, y2) {
        var options2 = obj.options.columns[x2];
        if (!options2) {
          options2 = { type: "text" };
        }
        return options2;
      };
      obj.getCellFromCoords = function(x2, y2) {
        return obj.records[y2][x2];
      };
      obj.getLabel = function(cell) {
        cell = jexcel.getIdFromColumnName(cell, true);
        var x2 = cell[0];
        var y2 = cell[1];
        return obj.records[y2][x2].innerHTML;
      };
      obj.getLabelFromCoords = function(x2, y2) {
        return obj.records[y2][x2].innerHTML;
      };
      obj.getValue = function(cell, processedValue) {
        if (typeof cell == "object") {
          var x2 = cell.getAttribute("data-x");
          var y2 = cell.getAttribute("data-y");
        } else {
          cell = jexcel.getIdFromColumnName(cell, true);
          var x2 = cell[0];
          var y2 = cell[1];
        }
        var value2 = null;
        if (x2 != null && y2 != null) {
          if (obj.records[y2] && obj.records[y2][x2] && (processedValue || obj.options.copyCompatibility == true)) {
            value2 = obj.records[y2][x2].innerHTML;
          } else {
            if (obj.options.data[y2] && obj.options.data[y2][x2] != "undefined") {
              value2 = obj.options.data[y2][x2];
            }
          }
        }
        return value2;
      };
      obj.getValueFromCoords = function(x2, y2, processedValue) {
        var value2 = null;
        if (x2 != null && y2 != null) {
          if (obj.records[y2] && obj.records[y2][x2] && processedValue || obj.options.copyCompatibility == true) {
            value2 = obj.records[y2][x2].innerHTML;
          } else {
            if (obj.options.data[y2] && obj.options.data[y2][x2] != "undefined") {
              value2 = obj.options.data[y2][x2];
            }
          }
        }
        return value2;
      };
      obj.setValue = function(cell, value2, force) {
        var records = [];
        if (typeof cell == "string") {
          var columnId = jexcel.getIdFromColumnName(cell, true);
          var x2 = columnId[0];
          var y2 = columnId[1];
          records.push(obj.updateCell(x2, y2, value2, force));
          obj.updateFormulaChain(x2, y2, records);
        } else {
          var x2 = null;
          var y2 = null;
          if (cell && cell.getAttribute) {
            var x2 = cell.getAttribute("data-x");
            var y2 = cell.getAttribute("data-y");
          }
          if (x2 != null && y2 != null) {
            records.push(obj.updateCell(x2, y2, value2, force));
            obj.updateFormulaChain(x2, y2, records);
          } else {
            var keys2 = Object.keys(cell);
            if (keys2.length > 0) {
              for (var i2 = 0; i2 < keys2.length; i2++) {
                if (typeof cell[i2] == "string") {
                  var columnId = jexcel.getIdFromColumnName(cell[i2], true);
                  var x2 = columnId[0];
                  var y2 = columnId[1];
                } else {
                  if (cell[i2].x != null && cell[i2].y != null) {
                    var x2 = cell[i2].x;
                    var y2 = cell[i2].y;
                    if (cell[i2].newValue != null) {
                      value2 = cell[i2].newValue;
                    } else if (cell[i2].value != null) {
                      value2 = cell[i2].value;
                    }
                  } else {
                    var x2 = cell[i2].getAttribute("data-x");
                    var y2 = cell[i2].getAttribute("data-y");
                  }
                }
                if (x2 != null && y2 != null) {
                  records.push(obj.updateCell(x2, y2, value2, force));
                  obj.updateFormulaChain(x2, y2, records);
                }
              }
            }
          }
        }
        obj.setHistory({
          action: "setValue",
          records,
          selection: obj.selectedCell
        });
        obj.updateTable();
        obj.onafterchanges(el, records);
      };
      obj.setValueFromCoords = function(x2, y2, value2, force) {
        var records = [];
        records.push(obj.updateCell(x2, y2, value2, force));
        obj.updateFormulaChain(x2, y2, records);
        obj.setHistory({
          action: "setValue",
          records,
          selection: obj.selectedCell
        });
        obj.updateTable();
        obj.onafterchanges(el, records);
      };
      obj.setCheckRadioValue = function() {
        var records = [];
        var keys2 = Object.keys(obj.highlighted);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var x2 = obj.highlighted[i2].getAttribute("data-x");
          var y2 = obj.highlighted[i2].getAttribute("data-y");
          if (obj.options.columns[x2].type == "checkbox" || obj.options.columns[x2].type == "radio") {
            records.push(obj.updateCell(x2, y2, !obj.options.data[y2][x2]));
          }
        }
        if (records.length) {
          obj.setHistory({
            action: "setValue",
            records,
            selection: obj.selectedCell
          });
          obj.onafterchanges(el, records);
        }
      };
      var stripScript = function(a) {
        var b = new Option();
        b.innerHTML = a;
        var c2 = null;
        for (a = b.getElementsByTagName("script"); c2 = a[0]; )
          c2.parentNode.removeChild(c2);
        return b.innerHTML;
      };
      obj.updateCell = function(x2, y2, value2, force) {
        if (obj.records[y2][x2].classList.contains("readonly") == true && !force) {
          var record = {
            x: x2,
            y: y2,
            col: x2,
            row: y2
          };
        } else {
          if (("" + value2).substr(0, 1) == "=" && obj.options.secureFormulas == true) {
            var val = secureFormula(value2);
            if (val != value2) {
              value2 = val;
            }
          }
          var val = obj.dispatch("onbeforechange", el, obj.records[y2][x2], x2, y2, value2);
          if (val != void 0) {
            value2 = val;
          }
          if (obj.options.columns[x2].editor && typeof obj.options.columns[x2].editor.updateCell == "function") {
            value2 = obj.options.columns[x2].editor.updateCell(obj.records[y2][x2], value2, force);
          }
          var record = {
            x: x2,
            y: y2,
            col: x2,
            row: y2,
            newValue: value2,
            oldValue: obj.options.data[y2][x2]
          };
          if (obj.options.columns[x2].editor) {
            obj.options.data[y2][x2] = value2;
          } else {
            if (obj.options.columns[x2].type == "checkbox" || obj.options.columns[x2].type == "radio") {
              if (obj.options.columns[x2].type == "radio") {
                for (var j2 = 0; j2 < obj.options.data.length; j2++) {
                  obj.options.data[j2][x2] = false;
                }
              }
              obj.records[y2][x2].children[0].checked = value2 == 1 || value2 == true || value2 == "true" || value2 == "TRUE" ? true : false;
              obj.options.data[y2][x2] = obj.records[y2][x2].children[0].checked;
            } else if (obj.options.columns[x2].type == "dropdown" || obj.options.columns[x2].type == "autocomplete") {
              obj.options.data[y2][x2] = value2;
              obj.records[y2][x2].innerText = obj.getDropDownValue(x2, value2);
            } else if (obj.options.columns[x2].type == "calendar") {
              var formatted = null;
              if (!validDate(value2)) {
                var tmp2 = jSuites.calendar.extractDateFromString(value2, obj.options.columns[x2].options.format);
                if (tmp2) {
                  formatted = tmp2;
                }
              }
              obj.options.data[y2][x2] = value2;
              obj.records[y2][x2].innerText = jSuites.calendar.getDateString(formatted ? formatted : value2, obj.options.columns[x2].options.format);
            } else if (obj.options.columns[x2].type == "color") {
              obj.options.data[y2][x2] = value2;
              if (obj.options.columns[x2].render == "square") {
                var color2 = document.createElement("div");
                color2.className = "color";
                color2.style.backgroundColor = value2;
                obj.records[y2][x2].innerText = "";
                obj.records[y2][x2].appendChild(color2);
              } else {
                obj.records[y2][x2].style.color = value2;
                obj.records[y2][x2].innerText = value2;
              }
            } else if (obj.options.columns[x2].type == "image") {
              value2 = "" + value2;
              obj.options.data[y2][x2] = value2;
              obj.records[y2][x2].innerHTML = "";
              if (value2 && value2.substr(0, 10) == "data:image") {
                var img = document.createElement("img");
                img.src = value2;
                obj.records[y2][x2].appendChild(img);
              }
            } else {
              obj.options.data[y2][x2] = value2;
              if (obj.options.columns[x2].type == "html") {
                obj.records[y2][x2].innerHTML = stripScript(obj.parseValue(x2, y2, value2));
              } else {
                if (obj.options.stripHTML === false || obj.options.columns[x2].stripHTML === false) {
                  obj.records[y2][x2].innerHTML = stripScript(obj.parseValue(x2, y2, value2, obj.records[y2][x2]));
                } else {
                  obj.records[y2][x2].innerText = obj.parseValue(x2, y2, value2, obj.records[y2][x2]);
                }
              }
              if (obj.options.columns[x2].wordWrap != false && (obj.options.wordWrap == true || obj.options.columns[x2].wordWrap == true || obj.records[y2][x2].innerHTML.length > 200)) {
                obj.records[y2][x2].style.whiteSpace = "pre-wrap";
              } else {
                obj.records[y2][x2].style.whiteSpace = "";
              }
            }
          }
          if (x2 > 0) {
            if (value2) {
              obj.records[y2][x2 - 1].style.overflow = "hidden";
            } else {
              obj.records[y2][x2 - 1].style.overflow = "";
            }
          }
          obj.dispatch("onchange", el, obj.records[y2] && obj.records[y2][x2] ? obj.records[y2][x2] : null, x2, y2, value2, record.oldValue);
        }
        return record;
      };
      obj.copyData = function(o, d) {
        var data = obj.getData(true, true);
        var h = obj.selectedContainer;
        var x1 = parseInt(o.getAttribute("data-x"));
        var y1 = parseInt(o.getAttribute("data-y"));
        var x2 = parseInt(d.getAttribute("data-x"));
        var y2 = parseInt(d.getAttribute("data-y"));
        var records = [];
        var breakControl = false;
        if (h[0] == x1) {
          if (y1 < h[1]) {
            var rowNumber = y1 - h[1];
          } else {
            var rowNumber = 1;
          }
          var colNumber = 0;
        } else {
          if (x1 < h[0]) {
            var colNumber = x1 - h[0];
          } else {
            var colNumber = 1;
          }
          var rowNumber = 0;
        }
        var posx = 0;
        var posy = 0;
        for (var j2 = y1; j2 <= y2; j2++) {
          if (obj.rows[j2] && obj.rows[j2].style.display == "none") {
            continue;
          }
          if (data[posy] == void 0) {
            posy = 0;
          }
          posx = 0;
          if (h[0] != x1) {
            if (x1 < h[0]) {
              var colNumber = x1 - h[0];
            } else {
              var colNumber = 1;
            }
          }
          for (var i2 = x1; i2 <= x2; i2++) {
            if (obj.records[j2][i2] && !obj.records[j2][i2].classList.contains("readonly") && obj.records[j2][i2].style.display != "none" && breakControl == false) {
              if (!obj.selection.length) {
                if (obj.options.data[j2][i2] != "") {
                  breakControl = true;
                  continue;
                }
              }
              if (data[posy] == void 0) {
                posx = 0;
              } else if (data[posy][posx] == void 0) {
                posx = 0;
              }
              var value2 = data[posy][posx];
              if (value2 && !data[1] && obj.options.autoIncrement == true) {
                if (obj.options.columns[i2].type == "text" || obj.options.columns[i2].type == "number") {
                  if (("" + value2).substr(0, 1) == "=") {
                    var tokens2 = value2.match(/([A-Z]+[0-9]+)/g);
                    if (tokens2) {
                      var affectedTokens = [];
                      for (var index2 = 0; index2 < tokens2.length; index2++) {
                        var position2 = jexcel.getIdFromColumnName(tokens2[index2], 1);
                        position2[0] += colNumber;
                        position2[1] += rowNumber;
                        if (position2[1] < 0) {
                          position2[1] = 0;
                        }
                        var token = jexcel.getColumnNameFromId([position2[0], position2[1]]);
                        if (token != tokens2[index2]) {
                          affectedTokens[tokens2[index2]] = token;
                        }
                      }
                      if (affectedTokens) {
                        value2 = obj.updateFormula(value2, affectedTokens);
                      }
                    }
                  } else {
                    if (value2 == Number(value2)) {
                      value2 = Number(value2) + rowNumber;
                    }
                  }
                } else if (obj.options.columns[i2].type == "calendar") {
                  var date = new Date(value2);
                  date.setDate(date.getDate() + rowNumber);
                  value2 = date.getFullYear() + "-" + jexcel.doubleDigitFormat(parseInt(date.getMonth() + 1)) + "-" + jexcel.doubleDigitFormat(date.getDate()) + " 00:00:00";
                }
              }
              records.push(obj.updateCell(i2, j2, value2));
              obj.updateFormulaChain(i2, j2, records);
            }
            posx++;
            if (h[0] != x1) {
              colNumber++;
            }
          }
          posy++;
          rowNumber++;
        }
        obj.setHistory({
          action: "setValue",
          records,
          selection: obj.selectedCell
        });
        obj.updateTable();
        obj.onafterchanges(el, records);
      };
      obj.refreshSelection = function() {
        if (obj.selectedCell) {
          obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        }
      };
      obj.conditionalSelectionUpdate = function(type2, o, d) {
        if (type2 == 1) {
          if (obj.selectedCell && (o >= obj.selectedCell[1] && o <= obj.selectedCell[3] || d >= obj.selectedCell[1] && d <= obj.selectedCell[3])) {
            obj.resetSelection();
            return;
          }
        } else {
          if (obj.selectedCell && (o >= obj.selectedCell[0] && o <= obj.selectedCell[2] || d >= obj.selectedCell[0] && d <= obj.selectedCell[2])) {
            obj.resetSelection();
            return;
          }
        }
      };
      obj.resetSelection = function(blur) {
        if (!obj.highlighted.length) {
          var previousStatus = 0;
        } else {
          var previousStatus = 1;
          for (var i2 = 0; i2 < obj.highlighted.length; i2++) {
            obj.highlighted[i2].classList.remove("highlight");
            obj.highlighted[i2].classList.remove("highlight-left");
            obj.highlighted[i2].classList.remove("highlight-right");
            obj.highlighted[i2].classList.remove("highlight-top");
            obj.highlighted[i2].classList.remove("highlight-bottom");
            obj.highlighted[i2].classList.remove("highlight-selected");
            var px = parseInt(obj.highlighted[i2].getAttribute("data-x"));
            var py = parseInt(obj.highlighted[i2].getAttribute("data-y"));
            if (obj.highlighted[i2].getAttribute("data-merged")) {
              var colspan = parseInt(obj.highlighted[i2].getAttribute("colspan"));
              var rowspan = parseInt(obj.highlighted[i2].getAttribute("rowspan"));
              var ux = colspan > 0 ? px + (colspan - 1) : px;
              var uy = rowspan > 0 ? py + (rowspan - 1) : py;
            } else {
              var ux = px;
              var uy = py;
            }
            for (var j2 = px; j2 <= ux; j2++) {
              if (obj.headers[j2]) {
                obj.headers[j2].classList.remove("selected");
              }
            }
            for (var j2 = py; j2 <= uy; j2++) {
              if (obj.rows[j2]) {
                obj.rows[j2].classList.remove("selected");
              }
            }
          }
        }
        obj.highlighted = [];
        obj.selectedCell = null;
        obj.corner.style.top = "-2000px";
        obj.corner.style.left = "-2000px";
        if (blur == true && previousStatus == 1) {
          obj.dispatch("onblur", el);
        }
        return previousStatus;
      };
      obj.updateSelection = function(el1, el2, origin) {
        var x1 = el1.getAttribute("data-x");
        var y1 = el1.getAttribute("data-y");
        if (el2) {
          var x2 = el2.getAttribute("data-x");
          var y2 = el2.getAttribute("data-y");
        } else {
          var x2 = x1;
          var y2 = y1;
        }
        obj.updateSelectionFromCoords(x1, y1, x2, y2, origin);
      };
      obj.updateSelectionFromCoords = function(x1, y1, x2, y2, origin) {
        var previousState = obj.resetSelection();
        if (y1 == null) {
          y1 = 0;
          y2 = obj.rows.length - 1;
        }
        if (x2 == null) {
          x2 = x1;
        }
        if (y2 == null) {
          y2 = y1;
        }
        if (x1 >= obj.headers.length) {
          x1 = obj.headers.length - 1;
        }
        if (y1 >= obj.rows.length) {
          y1 = obj.rows.length - 1;
        }
        if (x2 >= obj.headers.length) {
          x2 = obj.headers.length - 1;
        }
        if (y2 >= obj.rows.length) {
          y2 = obj.rows.length - 1;
        }
        obj.selectedCell = [x1, y1, x2, y2];
        if (x1 != null) {
          if (obj.records[y1][x1]) {
            obj.records[y1][x1].classList.add("highlight-selected");
          }
          if (parseInt(x1) < parseInt(x2)) {
            var px = parseInt(x1);
            var ux = parseInt(x2);
          } else {
            var px = parseInt(x2);
            var ux = parseInt(x1);
          }
          if (parseInt(y1) < parseInt(y2)) {
            var py = parseInt(y1);
            var uy = parseInt(y2);
          } else {
            var py = parseInt(y2);
            var uy = parseInt(y1);
          }
          for (var i2 = px; i2 <= ux; i2++) {
            for (var j2 = py; j2 <= uy; j2++) {
              if (obj.records[j2][i2] && obj.records[j2][i2].getAttribute("data-merged")) {
                var x3 = parseInt(obj.records[j2][i2].getAttribute("data-x"));
                var y3 = parseInt(obj.records[j2][i2].getAttribute("data-y"));
                var colspan = parseInt(obj.records[j2][i2].getAttribute("colspan"));
                var rowspan = parseInt(obj.records[j2][i2].getAttribute("rowspan"));
                if (colspan > 1) {
                  if (x3 < px) {
                    px = x3;
                  }
                  if (x3 + colspan > ux) {
                    ux = x3 + colspan - 1;
                  }
                }
                if (rowspan) {
                  if (y3 < py) {
                    py = y3;
                  }
                  if (y3 + rowspan > uy) {
                    uy = y3 + rowspan - 1;
                  }
                }
              }
            }
          }
          var borderLeft = null;
          var borderRight = null;
          var borderTop = null;
          var borderBottom = null;
          for (var j2 = py; j2 <= uy; j2++) {
            if (obj.rows[j2].style.display != "none") {
              if (borderTop == null) {
                borderTop = j2;
              }
              borderBottom = j2;
            }
          }
          for (var i2 = px; i2 <= ux; i2++) {
            for (var j2 = py; j2 <= uy; j2++) {
              if (obj.rows[j2].style.display != "none" && obj.records[j2][i2].style.display != "none") {
                obj.records[j2][i2].classList.add("highlight");
                obj.highlighted.push(obj.records[j2][i2]);
              }
            }
            if (obj.options.columns[i2].type != "hidden") {
              if (borderLeft == null) {
                borderLeft = i2;
              }
              borderRight = i2;
            }
          }
          if (!borderLeft) {
            borderLeft = 0;
          }
          if (!borderRight) {
            borderRight = 0;
          }
          for (var i2 = borderLeft; i2 <= borderRight; i2++) {
            if (obj.options.columns[i2].type != "hidden") {
              if (obj.records[borderTop] && obj.records[borderTop][i2]) {
                obj.records[borderTop][i2].classList.add("highlight-top");
              }
              if (obj.records[borderBottom] && obj.records[borderBottom][i2]) {
                obj.records[borderBottom][i2].classList.add("highlight-bottom");
              }
              obj.headers[i2].classList.add("selected");
            }
          }
          for (var j2 = borderTop; j2 <= borderBottom; j2++) {
            if (obj.rows[j2] && obj.rows[j2].style.display != "none") {
              obj.records[j2][borderLeft].classList.add("highlight-left");
              obj.records[j2][borderRight].classList.add("highlight-right");
              obj.rows[j2].classList.add("selected");
            }
          }
          obj.selectedContainer = [borderLeft, borderTop, borderRight, borderBottom];
        }
        if (previousState == 0) {
          obj.dispatch("onfocus", el);
          obj.removeCopyingSelection();
        }
        obj.dispatch("onselection", el, borderLeft, borderTop, borderRight, borderBottom, origin);
        obj.updateCornerPosition();
      };
      obj.removeCopySelection = function() {
        for (var i2 = 0; i2 < obj.selection.length; i2++) {
          obj.selection[i2].classList.remove("selection");
          obj.selection[i2].classList.remove("selection-left");
          obj.selection[i2].classList.remove("selection-right");
          obj.selection[i2].classList.remove("selection-top");
          obj.selection[i2].classList.remove("selection-bottom");
        }
        obj.selection = [];
      };
      obj.updateCopySelection = function(x3, y3) {
        obj.removeCopySelection();
        var x1 = obj.selectedContainer[0];
        var y1 = obj.selectedContainer[1];
        var x2 = obj.selectedContainer[2];
        var y2 = obj.selectedContainer[3];
        if (x3 != null && y3 != null) {
          if (x3 - x2 > 0) {
            var px = parseInt(x2) + 1;
            var ux = parseInt(x3);
          } else {
            var px = parseInt(x3);
            var ux = parseInt(x1) - 1;
          }
          if (y3 - y2 > 0) {
            var py = parseInt(y2) + 1;
            var uy = parseInt(y3);
          } else {
            var py = parseInt(y3);
            var uy = parseInt(y1) - 1;
          }
          if (ux - px <= uy - py) {
            var px = parseInt(x1);
            var ux = parseInt(x2);
          } else {
            var py = parseInt(y1);
            var uy = parseInt(y2);
          }
          for (var j2 = py; j2 <= uy; j2++) {
            for (var i2 = px; i2 <= ux; i2++) {
              if (obj.records[j2][i2] && obj.rows[j2].style.display != "none" && obj.records[j2][i2].style.display != "none") {
                obj.records[j2][i2].classList.add("selection");
                obj.records[py][i2].classList.add("selection-top");
                obj.records[uy][i2].classList.add("selection-bottom");
                obj.records[j2][px].classList.add("selection-left");
                obj.records[j2][ux].classList.add("selection-right");
                obj.selection.push(obj.records[j2][i2]);
              }
            }
          }
        }
      };
      obj.updateCornerPosition = function() {
        if (!obj.highlighted.length) {
          obj.corner.style.top = "-2000px";
          obj.corner.style.left = "-2000px";
        } else {
          var last = obj.highlighted[obj.highlighted.length - 1];
          var lastX = last.getAttribute("data-x");
          var contentRect = obj.content.getBoundingClientRect();
          var x1 = contentRect.left;
          var y1 = contentRect.top;
          var lastRect = last.getBoundingClientRect();
          var x2 = lastRect.left;
          var y2 = lastRect.top;
          var w2 = lastRect.width;
          var h2 = lastRect.height;
          var x3 = x2 - x1 + obj.content.scrollLeft + w2 - 4;
          var y3 = y2 - y1 + obj.content.scrollTop + h2 - 4;
          obj.corner.style.top = y3 + "px";
          obj.corner.style.left = x3 + "px";
          if (obj.options.freezeColumns) {
            var width = obj.getFreezeWidth();
            if (lastX > obj.options.freezeColumns - 1 && x2 - x1 + w2 < width) {
              obj.corner.style.display = "none";
            } else {
              if (obj.options.selectionCopy == true) {
                obj.corner.style.display = "";
              }
            }
          } else {
            if (obj.options.selectionCopy == true) {
              obj.corner.style.display = "";
            }
          }
        }
      };
      obj.updateScroll = function(direction) {
        var contentRect = obj.content.getBoundingClientRect();
        var x1 = contentRect.left;
        var y1 = contentRect.top;
        var w1 = contentRect.width;
        var h1 = contentRect.height;
        var reference = obj.records[obj.selectedCell[3]][obj.selectedCell[2]];
        var referenceRect = reference.getBoundingClientRect();
        var x2 = referenceRect.left;
        var y2 = referenceRect.top;
        var w2 = referenceRect.width;
        var h2 = referenceRect.height;
        if (direction == 0 || direction == 1) {
          var x3 = x2 - x1 + obj.content.scrollLeft;
          var y3 = y2 - y1 + obj.content.scrollTop - 2;
        } else {
          var x3 = x2 - x1 + obj.content.scrollLeft + w2;
          var y3 = y2 - y1 + obj.content.scrollTop + h2;
        }
        if (y3 > obj.content.scrollTop + 30 && y3 < obj.content.scrollTop + h1)
          ;
        else {
          if (y3 < obj.content.scrollTop + 30) {
            obj.content.scrollTop = y3 - h2;
          } else {
            obj.content.scrollTop = y3 - (h1 - 2);
          }
        }
        var freezed = obj.getFreezeWidth();
        if (x3 > obj.content.scrollLeft + freezed && x3 < obj.content.scrollLeft + w1)
          ;
        else {
          if (x3 < obj.content.scrollLeft + 30) {
            obj.content.scrollLeft = x3;
            if (obj.content.scrollLeft < 50) {
              obj.content.scrollLeft = 0;
            }
          } else if (x3 < obj.content.scrollLeft + freezed) {
            obj.content.scrollLeft = x3 - freezed - 1;
          } else {
            obj.content.scrollLeft = x3 - (w1 - 20);
          }
        }
      };
      obj.getWidth = function(column) {
        if (!column) {
          var data = [];
          for (var i2 = 0; i2 < obj.headers.length; i2++) {
            data.push(obj.options.columns[i2].width);
          }
        } else {
          if (typeof column == "object") {
            column = $(column).getAttribute("data-x");
          }
          data = obj.colgroup[column].getAttribute("width");
        }
        return data;
      };
      obj.setWidth = function(column, width, oldWidth) {
        if (width) {
          if (Array.isArray(column)) {
            if (!oldWidth) {
              var oldWidth = [];
            }
            for (var i2 = 0; i2 < column.length; i2++) {
              if (!oldWidth[i2]) {
                oldWidth[i2] = obj.colgroup[column[i2]].getAttribute("width");
              }
              var w = Array.isArray(width) && width[i2] ? width[i2] : width;
              obj.colgroup[column[i2]].setAttribute("width", w);
              obj.options.columns[column[i2]].width = w;
            }
          } else {
            if (!oldWidth) {
              oldWidth = obj.colgroup[column].getAttribute("width");
            }
            obj.colgroup[column].setAttribute("width", width);
            obj.options.columns[column].width = width;
          }
          obj.setHistory({
            action: "setWidth",
            column,
            oldValue: oldWidth,
            newValue: width
          });
          obj.dispatch("onresizecolumn", el, column, width, oldWidth);
          obj.updateCornerPosition();
        }
      };
      obj.setHeight = function(row, height, oldHeight) {
        if (height > 0) {
          if (typeof row == "object") {
            row = row.getAttribute("data-y");
          }
          if (!oldHeight) {
            oldHeight = obj.rows[row].getAttribute("height");
            if (!oldHeight) {
              var rect = obj.rows[row].getBoundingClientRect();
              oldHeight = rect.height;
            }
          }
          height = parseInt(height);
          obj.rows[row].style.height = height + "px";
          if (!obj.options.rows[row]) {
            obj.options.rows[row] = {};
          }
          obj.options.rows[row].height = height;
          obj.setHistory({
            action: "setHeight",
            row,
            oldValue: oldHeight,
            newValue: height
          });
          obj.dispatch("onresizerow", el, row, height, oldHeight);
          obj.updateCornerPosition();
        }
      };
      obj.getHeight = function(row) {
        if (!row) {
          var data = [];
          for (var j2 = 0; j2 < obj.rows.length; j2++) {
            var h = obj.rows[j2].style.height;
            if (h) {
              data[j2] = h;
            }
          }
        } else {
          if (typeof row == "object") {
            row = $(row).getAttribute("data-y");
          }
          var data = obj.rows[row].style.height;
        }
        return data;
      };
      obj.setFooter = function(data) {
        if (data) {
          obj.options.footers = data;
        }
        if (obj.options.footers) {
          if (!obj.tfoot) {
            obj.tfoot = document.createElement("tfoot");
            obj.table.appendChild(obj.tfoot);
          }
          for (var j2 = 0; j2 < obj.options.footers.length; j2++) {
            if (obj.tfoot.children[j2]) {
              var tr = obj.tfoot.children[j2];
            } else {
              var tr = document.createElement("tr");
              var td = document.createElement("td");
              tr.appendChild(td);
              obj.tfoot.appendChild(tr);
            }
            for (var i2 = 0; i2 < obj.headers.length; i2++) {
              if (!obj.options.footers[j2][i2]) {
                obj.options.footers[j2][i2] = "";
              }
              if (obj.tfoot.children[j2].children[i2 + 1]) {
                var td = obj.tfoot.children[j2].children[i2 + 1];
              } else {
                var td = document.createElement("td");
                tr.appendChild(td);
                var colAlign = obj.options.columns[i2].align ? obj.options.columns[i2].align : "center";
                td.style.textAlign = colAlign;
              }
              td.innerText = obj.parseValue(+obj.records.length + i2, j2, obj.options.footers[j2][i2]);
            }
          }
        }
      };
      obj.getHeader = function(column) {
        return obj.headers[column].innerText;
      };
      obj.setHeader = function(column, newValue) {
        if (obj.headers[column]) {
          var oldValue = obj.headers[column].innerText;
          if (!newValue) {
            newValue = prompt(obj.options.text.columnName, oldValue);
          }
          if (newValue) {
            obj.headers[column].innerText = newValue;
            obj.headers[column].setAttribute("title", newValue);
            obj.options.columns[column].title = newValue;
          }
          obj.setHistory({
            action: "setHeader",
            column,
            oldValue,
            newValue
          });
          obj.dispatch("onchangeheader", el, column, oldValue, newValue);
        }
      };
      obj.getHeaders = function(asArray2) {
        var title = [];
        for (var i2 = 0; i2 < obj.headers.length; i2++) {
          title.push(obj.getHeader(i2));
        }
        return asArray2 ? title : title.join(obj.options.csvDelimiter);
      };
      obj.getMeta = function(cell, key) {
        if (!cell) {
          return obj.options.meta;
        } else {
          if (key) {
            return obj.options.meta[cell] && obj.options.meta[cell][key] ? obj.options.meta[cell][key] : null;
          } else {
            return obj.options.meta[cell] ? obj.options.meta[cell] : null;
          }
        }
      };
      obj.setMeta = function(o, k2, v) {
        if (!obj.options.meta) {
          obj.options.meta = {};
        }
        if (k2 && v) {
          if (!obj.options.meta[o]) {
            obj.options.meta[o] = {};
          }
          obj.options.meta[o][k2] = v;
        } else {
          var keys2 = Object.keys(o);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            if (!obj.options.meta[keys2[i2]]) {
              obj.options.meta[keys2[i2]] = {};
            }
            var prop = Object.keys(o[keys2[i2]]);
            for (var j2 = 0; j2 < prop.length; j2++) {
              obj.options.meta[keys2[i2]][prop[j2]] = o[keys2[i2]][prop[j2]];
            }
          }
        }
        obj.dispatch("onchangemeta", el, o, k2, v);
      };
      obj.updateMeta = function(affectedCells) {
        if (obj.options.meta) {
          var newMeta = {};
          var keys2 = Object.keys(obj.options.meta);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            if (affectedCells[keys2[i2]]) {
              newMeta[affectedCells[keys2[i2]]] = obj.options.meta[keys2[i2]];
            } else {
              newMeta[keys2[i2]] = obj.options.meta[keys2[i2]];
            }
          }
          obj.options.meta = newMeta;
        }
      };
      obj.getStyle = function(cell, key) {
        if (!cell) {
          var data = {};
          var x2 = obj.options.data[0].length;
          var y2 = obj.options.data.length;
          for (var j2 = 0; j2 < y2; j2++) {
            for (var i2 = 0; i2 < x2; i2++) {
              var v = key ? obj.records[j2][i2].style[key] : obj.records[j2][i2].getAttribute("style");
              if (v) {
                var k2 = jexcel.getColumnNameFromId([i2, j2]);
                data[k2] = v;
              }
            }
          }
          return data;
        } else {
          cell = jexcel.getIdFromColumnName(cell, true);
          return key ? obj.records[cell[1]][cell[0]].style[key] : obj.records[cell[1]][cell[0]].getAttribute("style");
        }
      }, obj.resetStyle = function(o, ignoreHistoryAndEvents) {
        var keys2 = Object.keys(o);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var cell = jexcel.getIdFromColumnName(keys2[i2], true);
          if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]]) {
            obj.records[cell[1]][cell[0]].setAttribute("style", "");
          }
        }
        obj.setStyle(o, null, null, null, ignoreHistoryAndEvents);
      };
      obj.setStyle = function(o, k2, v, force, ignoreHistoryAndEvents) {
        var newValue = {};
        var oldValue = {};
        var applyStyle = function(cellId, key, value2) {
          var cell = jexcel.getIdFromColumnName(cellId, true);
          if (obj.records[cell[1]] && obj.records[cell[1]][cell[0]] && (obj.records[cell[1]][cell[0]].classList.contains("readonly") == false || force)) {
            var currentValue = obj.records[cell[1]][cell[0]].style[key];
            if (currentValue == value2 && !force) {
              value2 = "";
              obj.records[cell[1]][cell[0]].style[key] = "";
            } else {
              obj.records[cell[1]][cell[0]].style[key] = value2;
            }
            if (!oldValue[cellId]) {
              oldValue[cellId] = [];
            }
            if (!newValue[cellId]) {
              newValue[cellId] = [];
            }
            oldValue[cellId].push([key + ":" + currentValue]);
            newValue[cellId].push([key + ":" + value2]);
          }
        };
        if (k2 && v) {
          if (typeof o == "string") {
            applyStyle(o, k2, v);
          } else {
            var oneApplication = [];
            for (var i2 = 0; i2 < o.length; i2++) {
              var x2 = o[i2].getAttribute("data-x");
              var y2 = o[i2].getAttribute("data-y");
              var cellName = jexcel.getColumnNameFromId([x2, y2]);
              if (!oneApplication[cellName]) {
                applyStyle(cellName, k2, v);
                oneApplication[cellName] = true;
              }
            }
          }
        } else {
          var keys2 = Object.keys(o);
          for (var i2 = 0; i2 < keys2.length; i2++) {
            var style = o[keys2[i2]];
            if (typeof style == "string") {
              style = style.split(";");
            }
            for (var j2 = 0; j2 < style.length; j2++) {
              if (typeof style[j2] == "string") {
                style[j2] = style[j2].split(":");
              }
              if (style[j2][0].trim()) {
                applyStyle(keys2[i2], style[j2][0].trim(), style[j2][1]);
              }
            }
          }
        }
        var keys2 = Object.keys(oldValue);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          oldValue[keys2[i2]] = oldValue[keys2[i2]].join(";");
        }
        var keys2 = Object.keys(newValue);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          newValue[keys2[i2]] = newValue[keys2[i2]].join(";");
        }
        if (!ignoreHistoryAndEvents) {
          obj.setHistory({
            action: "setStyle",
            oldValue,
            newValue
          });
        }
        obj.dispatch("onchangestyle", el, o, k2, v);
      };
      obj.getComments = function(cell, withAuthor) {
        if (cell) {
          if (typeof cell == "string") {
            var cell = jexcel.getIdFromColumnName(cell, true);
          }
          if (withAuthor) {
            return [obj.records[cell[1]][cell[0]].getAttribute("title"), obj.records[cell[1]][cell[0]].getAttribute("author")];
          } else {
            return obj.records[cell[1]][cell[0]].getAttribute("title") || "";
          }
        } else {
          var data = {};
          for (var j2 = 0; j2 < obj.options.data.length; j2++) {
            for (var i2 = 0; i2 < obj.options.columns.length; i2++) {
              var comments = obj.records[j2][i2].getAttribute("title");
              if (comments) {
                var cell = jexcel.getColumnNameFromId([i2, j2]);
                data[cell] = comments;
              }
            }
          }
          return data;
        }
      };
      obj.setComments = function(cellId, comments, author) {
        if (typeof cellId == "string") {
          var cell = jexcel.getIdFromColumnName(cellId, true);
        } else {
          var cell = cellId;
        }
        var title = obj.records[cell[1]][cell[0]].getAttribute("title");
        var author = obj.records[cell[1]][cell[0]].getAttribute("data-author");
        var oldValue = [title, author];
        obj.records[cell[1]][cell[0]].setAttribute("title", comments ? comments : "");
        obj.records[cell[1]][cell[0]].setAttribute("data-author", author ? author : "");
        if (comments) {
          obj.records[cell[1]][cell[0]].classList.add("jexcel_comments");
        } else {
          obj.records[cell[1]][cell[0]].classList.remove("jexcel_comments");
        }
        obj.setHistory({
          action: "setComments",
          column: cellId,
          newValue: [comments, author],
          oldValue
        });
        obj.dispatch("oncomments", el, comments, title, cell, cell[0], cell[1]);
      };
      obj.getConfig = function() {
        var options2 = obj.options;
        options2.style = obj.getStyle();
        options2.mergeCells = obj.getMerge();
        options2.comments = obj.getComments();
        return options2;
      };
      obj.orderBy = function(column, order) {
        if (column >= 0) {
          if (Object.keys(obj.options.mergeCells).length > 0) {
            if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
              return false;
            } else {
              obj.destroyMerged();
            }
          }
          if (order == null) {
            order = obj.headers[column].classList.contains("arrow-down") ? 1 : 0;
          } else {
            order = order ? 1 : 0;
          }
          var temp = [];
          if (obj.options.columns[column].type == "number" || obj.options.columns[column].type == "percentage" || obj.options.columns[column].type == "autonumber" || obj.options.columns[column].type == "color") {
            for (var j2 = 0; j2 < obj.options.data.length; j2++) {
              temp[j2] = [j2, Number(obj.options.data[j2][column])];
            }
          } else if (obj.options.columns[column].type == "calendar" || obj.options.columns[column].type == "checkbox" || obj.options.columns[column].type == "radio") {
            for (var j2 = 0; j2 < obj.options.data.length; j2++) {
              temp[j2] = [j2, obj.options.data[j2][column]];
            }
          } else {
            for (var j2 = 0; j2 < obj.options.data.length; j2++) {
              temp[j2] = [j2, obj.records[j2][column].innerText.toLowerCase()];
            }
          }
          if (typeof obj.options.sorting !== "function") {
            obj.options.sorting = function(direction) {
              return function(a, b) {
                var valueA = a[1];
                var valueB = b[1];
                if (!direction) {
                  return valueA === "" && valueB !== "" ? 1 : valueA !== "" && valueB === "" ? -1 : valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
                } else {
                  return valueA === "" && valueB !== "" ? 1 : valueA !== "" && valueB === "" ? -1 : valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
                }
              };
            };
          }
          temp = temp.sort(obj.options.sorting(order));
          var newValue = [];
          for (var j2 = 0; j2 < temp.length; j2++) {
            newValue[j2] = temp[j2][0];
          }
          obj.setHistory({
            action: "orderBy",
            rows: newValue,
            column,
            order
          });
          obj.updateOrderArrow(column, order);
          obj.updateOrder(newValue);
          obj.dispatch("onsort", el, column, order);
          return true;
        }
      };
      obj.updateOrderArrow = function(column, order) {
        for (var i2 = 0; i2 < obj.headers.length; i2++) {
          obj.headers[i2].classList.remove("arrow-up");
          obj.headers[i2].classList.remove("arrow-down");
        }
        if (order) {
          obj.headers[column].classList.add("arrow-up");
        } else {
          obj.headers[column].classList.add("arrow-down");
        }
      };
      obj.updateOrder = function(rows) {
        var data = [];
        for (var j2 = 0; j2 < rows.length; j2++) {
          data[j2] = obj.options.data[rows[j2]];
        }
        obj.options.data = data;
        var data = [];
        for (var j2 = 0; j2 < rows.length; j2++) {
          data[j2] = obj.records[rows[j2]];
        }
        obj.records = data;
        var data = [];
        for (var j2 = 0; j2 < rows.length; j2++) {
          data[j2] = obj.rows[rows[j2]];
        }
        obj.rows = data;
        obj.updateTableReferences();
        if (obj.results && obj.results.length) {
          if (obj.searchInput.value) {
            obj.search(obj.searchInput.value);
          } else {
            obj.closeFilter();
          }
        } else {
          obj.results = null;
          obj.pageNumber = 0;
          if (obj.options.pagination > 0) {
            obj.page(0);
          } else if (obj.options.lazyLoading == true) {
            obj.loadPage(0);
          } else {
            for (var j2 = 0; j2 < obj.rows.length; j2++) {
              obj.tbody.appendChild(obj.rows[j2]);
            }
          }
        }
      };
      obj.moveRow = function(o, d, ignoreDom) {
        if (Object.keys(obj.options.mergeCells).length > 0) {
          if (o > d) {
            var insertBefore = 1;
          } else {
            var insertBefore = 0;
          }
          if (obj.isRowMerged(o).length || obj.isRowMerged(d, insertBefore).length) {
            if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
              return false;
            } else {
              obj.destroyMerged();
            }
          }
        }
        if (obj.options.search == true) {
          if (obj.results && obj.results.length != obj.rows.length) {
            if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
              obj.resetSearch();
            } else {
              return false;
            }
          }
          obj.results = null;
        }
        if (!ignoreDom) {
          if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[d]) >= 0) {
            if (o > d) {
              obj.tbody.insertBefore(obj.rows[o], obj.rows[d]);
            } else {
              obj.tbody.insertBefore(obj.rows[o], obj.rows[d].nextSibling);
            }
          } else {
            obj.tbody.removeChild(obj.rows[o]);
          }
        }
        obj.rows.splice(d, 0, obj.rows.splice(o, 1)[0]);
        obj.records.splice(d, 0, obj.records.splice(o, 1)[0]);
        obj.options.data.splice(d, 0, obj.options.data.splice(o, 1)[0]);
        if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
          obj.page(obj.pageNumber);
        }
        obj.setHistory({
          action: "moveRow",
          oldValue: o,
          newValue: d
        });
        obj.updateTableReferences();
        obj.dispatch("onmoverow", el, o, d);
      };
      obj.insertRow = function(mixed, rowNumber, insertBefore) {
        if (obj.options.allowInsertRow == true) {
          var data = [];
          if (mixed > 0) {
            var numOfRows = mixed;
          } else {
            var numOfRows = 1;
            if (mixed) {
              data = mixed;
            }
          }
          var insertBefore = insertBefore ? true : false;
          var lastRow = obj.options.data.length - 1;
          if (rowNumber == void 0 || rowNumber >= parseInt(lastRow) || rowNumber < 0) {
            rowNumber = lastRow;
          }
          if (obj.dispatch("onbeforeinsertrow", el, rowNumber, numOfRows, insertBefore) === false) {
            return false;
          }
          if (Object.keys(obj.options.mergeCells).length > 0) {
            if (obj.isRowMerged(rowNumber, insertBefore).length) {
              if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                return false;
              } else {
                obj.destroyMerged();
              }
            }
          }
          if (obj.options.search == true) {
            if (obj.results && obj.results.length != obj.rows.length) {
              if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                obj.resetSearch();
              } else {
                return false;
              }
            }
            obj.results = null;
          }
          var rowIndex = !insertBefore ? rowNumber + 1 : rowNumber;
          var currentRecords = obj.records.splice(rowIndex);
          var currentData = obj.options.data.splice(rowIndex);
          var currentRows = obj.rows.splice(rowIndex);
          var rowRecords = [];
          var rowData = [];
          var rowNode = [];
          for (var row = rowIndex; row < numOfRows + rowIndex; row++) {
            obj.options.data[row] = [];
            for (var col = 0; col < obj.options.columns.length; col++) {
              obj.options.data[row][col] = data[col] ? data[col] : "";
            }
            var tr = obj.createRow(row, obj.options.data[row]);
            if (currentRows[0]) {
              if (Array.prototype.indexOf.call(obj.tbody.children, currentRows[0]) >= 0) {
                obj.tbody.insertBefore(tr, currentRows[0]);
              }
            } else {
              if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[rowNumber]) >= 0) {
                obj.tbody.appendChild(tr);
              }
            }
            rowRecords.push(obj.records[row]);
            rowData.push(obj.options.data[row]);
            rowNode.push(tr);
          }
          Array.prototype.push.apply(obj.records, currentRecords);
          Array.prototype.push.apply(obj.options.data, currentData);
          Array.prototype.push.apply(obj.rows, currentRows);
          if (obj.options.pagination > 0) {
            obj.page(obj.pageNumber);
          }
          obj.setHistory({
            action: "insertRow",
            rowNumber,
            numOfRows,
            insertBefore,
            rowRecords,
            rowData,
            rowNode
          });
          obj.updateTableReferences();
          obj.dispatch("oninsertrow", el, rowNumber, numOfRows, rowRecords, insertBefore);
        }
      };
      obj.deleteRow = function(rowNumber, numOfRows) {
        if (obj.options.allowDeleteRow == true) {
          if (obj.options.allowDeletingAllRows == true || obj.options.data.length > 1) {
            if (rowNumber == void 0) {
              var number2 = obj.getSelectedRows();
              if (!number2[0]) {
                rowNumber = obj.options.data.length - 1;
                numOfRows = 1;
              } else {
                rowNumber = parseInt(number2[0].getAttribute("data-y"));
                numOfRows = number2.length;
              }
            }
            var lastRow = obj.options.data.length - 1;
            if (rowNumber == void 0 || rowNumber > lastRow || rowNumber < 0) {
              rowNumber = lastRow;
            }
            if (!numOfRows) {
              numOfRows = 1;
            }
            if (rowNumber + numOfRows >= obj.options.data.length) {
              numOfRows = obj.options.data.length - rowNumber;
            }
            if (obj.dispatch("onbeforedeleterow", el, rowNumber, numOfRows) === false) {
              return false;
            }
            if (parseInt(rowNumber) > -1) {
              var mergeExists = false;
              if (Object.keys(obj.options.mergeCells).length > 0) {
                for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                  if (obj.isRowMerged(row, false).length) {
                    mergeExists = true;
                  }
                }
              }
              if (mergeExists) {
                if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                  return false;
                } else {
                  obj.destroyMerged();
                }
              }
              if (obj.options.search == true) {
                if (obj.results && obj.results.length != obj.rows.length) {
                  if (confirm(obj.options.text.thisActionWillClearYourSearchResultsAreYouSure)) {
                    obj.resetSearch();
                  } else {
                    return false;
                  }
                }
                obj.results = null;
              }
              if (obj.options.allowDeletingAllRows == false && lastRow + 1 === numOfRows) {
                numOfRows--;
                console.error("Jspreadsheet: It is not possible to delete the last row");
              }
              for (var row = rowNumber; row < rowNumber + numOfRows; row++) {
                if (Array.prototype.indexOf.call(obj.tbody.children, obj.rows[row]) >= 0) {
                  obj.rows[row].className = "";
                  obj.rows[row].parentNode.removeChild(obj.rows[row]);
                }
              }
              var rowRecords = obj.records.splice(rowNumber, numOfRows);
              var rowData = obj.options.data.splice(rowNumber, numOfRows);
              var rowNode = obj.rows.splice(rowNumber, numOfRows);
              if (obj.options.pagination > 0 && obj.tbody.children.length != obj.options.pagination) {
                obj.page(obj.pageNumber);
              }
              obj.conditionalSelectionUpdate(1, rowNumber, rowNumber + numOfRows - 1);
              obj.setHistory({
                action: "deleteRow",
                rowNumber,
                numOfRows,
                insertBefore: 1,
                rowRecords,
                rowData,
                rowNode
              });
              obj.updateTableReferences();
              obj.dispatch("ondeleterow", el, rowNumber, numOfRows, rowRecords);
            }
          } else {
            console.error("Jspreadsheet: It is not possible to delete the last row");
          }
        }
      };
      obj.moveColumn = function(o, d) {
        if (Object.keys(obj.options.mergeCells).length > 0) {
          if (o > d) {
            var insertBefore = 1;
          } else {
            var insertBefore = 0;
          }
          if (obj.isColMerged(o).length || obj.isColMerged(d, insertBefore).length) {
            if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
              return false;
            } else {
              obj.destroyMerged();
            }
          }
        }
        var o = parseInt(o);
        var d = parseInt(d);
        if (o > d) {
          obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d]);
          obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d]);
          for (var j2 = 0; j2 < obj.rows.length; j2++) {
            obj.rows[j2].insertBefore(obj.records[j2][o], obj.records[j2][d]);
          }
        } else {
          obj.headerContainer.insertBefore(obj.headers[o], obj.headers[d].nextSibling);
          obj.colgroupContainer.insertBefore(obj.colgroup[o], obj.colgroup[d].nextSibling);
          for (var j2 = 0; j2 < obj.rows.length; j2++) {
            obj.rows[j2].insertBefore(obj.records[j2][o], obj.records[j2][d].nextSibling);
          }
        }
        obj.options.columns.splice(d, 0, obj.options.columns.splice(o, 1)[0]);
        obj.headers.splice(d, 0, obj.headers.splice(o, 1)[0]);
        obj.colgroup.splice(d, 0, obj.colgroup.splice(o, 1)[0]);
        for (var j2 = 0; j2 < obj.rows.length; j2++) {
          obj.options.data[j2].splice(d, 0, obj.options.data[j2].splice(o, 1)[0]);
          obj.records[j2].splice(d, 0, obj.records[j2].splice(o, 1)[0]);
        }
        if (obj.options.footers) {
          for (var j2 = 0; j2 < obj.options.footers.length; j2++) {
            obj.options.footers[j2].splice(d, 0, obj.options.footers[j2].splice(o, 1)[0]);
          }
        }
        obj.setHistory({
          action: "moveColumn",
          oldValue: o,
          newValue: d
        });
        obj.updateTableReferences();
        obj.dispatch("onmovecolumn", el, o, d);
      };
      obj.insertColumn = function(mixed, columnNumber, insertBefore, properties) {
        if (obj.options.allowInsertColumn == true) {
          var data = [];
          if (mixed > 0) {
            var numOfColumns = mixed;
          } else {
            var numOfColumns = 1;
            if (mixed) {
              data = mixed;
            }
          }
          var insertBefore = insertBefore ? true : false;
          var lastColumn = obj.options.columns.length - 1;
          if (columnNumber == void 0 || columnNumber >= parseInt(lastColumn) || columnNumber < 0) {
            columnNumber = lastColumn;
          }
          if (obj.dispatch("onbeforeinsertcolumn", el, columnNumber, numOfColumns, insertBefore) === false) {
            return false;
          }
          if (Object.keys(obj.options.mergeCells).length > 0) {
            if (obj.isColMerged(columnNumber, insertBefore).length) {
              if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                return false;
              } else {
                obj.destroyMerged();
              }
            }
          }
          if (!properties) {
            properties = [];
          }
          for (var i2 = 0; i2 < numOfColumns; i2++) {
            if (!properties[i2]) {
              properties[i2] = { type: "text", source: [], options: [], width: obj.options.defaultColWidth, align: obj.options.defaultColAlign };
            }
          }
          var columnIndex = !insertBefore ? columnNumber + 1 : columnNumber;
          obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, properties);
          var currentHeaders = obj.headers.splice(columnIndex);
          var currentColgroup = obj.colgroup.splice(columnIndex);
          var historyHeaders = [];
          var historyColgroup = [];
          var historyRecords = [];
          var historyData = [];
          var historyFooters = [];
          for (var col = columnIndex; col < numOfColumns + columnIndex; col++) {
            obj.createCellHeader(col);
            obj.headerContainer.insertBefore(obj.headers[col], obj.headerContainer.children[col + 1]);
            obj.colgroupContainer.insertBefore(obj.colgroup[col], obj.colgroupContainer.children[col + 1]);
            historyHeaders.push(obj.headers[col]);
            historyColgroup.push(obj.colgroup[col]);
          }
          if (obj.options.footers) {
            for (var j2 = 0; j2 < obj.options.footers.length; j2++) {
              historyFooters[j2] = [];
              for (var i2 = 0; i2 < numOfColumns; i2++) {
                historyFooters[j2].push("");
              }
              obj.options.footers[j2].splice(columnIndex, 0, historyFooters[j2]);
            }
          }
          for (var row = 0; row < obj.options.data.length; row++) {
            var currentData = obj.options.data[row].splice(columnIndex);
            var currentRecord = obj.records[row].splice(columnIndex);
            historyData[row] = [];
            historyRecords[row] = [];
            for (var col = columnIndex; col < numOfColumns + columnIndex; col++) {
              var value2 = data[row] ? data[row] : "";
              obj.options.data[row][col] = value2;
              var td = obj.createCell(col, row, obj.options.data[row][col]);
              obj.records[row][col] = td;
              if (obj.rows[row]) {
                obj.rows[row].insertBefore(td, obj.rows[row].children[col + 1]);
              }
              historyData[row].push(value2);
              historyRecords[row].push(td);
            }
            Array.prototype.push.apply(obj.options.data[row], currentData);
            Array.prototype.push.apply(obj.records[row], currentRecord);
          }
          Array.prototype.push.apply(obj.headers, currentHeaders);
          Array.prototype.push.apply(obj.colgroup, currentColgroup);
          if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
            if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
              for (var j2 = 0; j2 < obj.options.nestedHeaders.length; j2++) {
                var colspan = parseInt(obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan) + numOfColumns;
                obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan = colspan;
                obj.thead.children[j2].children[obj.thead.children[j2].children.length - 1].setAttribute("colspan", colspan);
                var o = obj.thead.children[j2].children[obj.thead.children[j2].children.length - 1].getAttribute("data-column");
                o = o.split(",");
                for (var col = columnIndex; col < numOfColumns + columnIndex; col++) {
                  o.push(col);
                }
                obj.thead.children[j2].children[obj.thead.children[j2].children.length - 1].setAttribute("data-column", o);
              }
            } else {
              var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + numOfColumns;
              obj.options.nestedHeaders[0].colspan = colspan;
              obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute("colspan", colspan);
            }
          }
          obj.setHistory({
            action: "insertColumn",
            columnNumber,
            numOfColumns,
            insertBefore,
            columns: properties,
            headers: historyHeaders,
            colgroup: historyColgroup,
            records: historyRecords,
            footers: historyFooters,
            data: historyData
          });
          obj.updateTableReferences();
          obj.dispatch("oninsertcolumn", el, columnNumber, numOfColumns, historyRecords, insertBefore);
        }
      };
      obj.deleteColumn = function(columnNumber, numOfColumns) {
        if (obj.options.allowDeleteColumn == true) {
          if (obj.headers.length > 1) {
            if (columnNumber == void 0) {
              var number2 = obj.getSelectedColumns(true);
              if (!number2.length) {
                columnNumber = obj.headers.length - 1;
                numOfColumns = 1;
              } else {
                columnNumber = parseInt(number2[0]);
                numOfColumns = parseInt(number2.length);
              }
            }
            var lastColumn = obj.options.data[0].length - 1;
            if (columnNumber == void 0 || columnNumber > lastColumn || columnNumber < 0) {
              columnNumber = lastColumn;
            }
            if (!numOfColumns) {
              numOfColumns = 1;
            }
            if (numOfColumns > obj.options.data[0].length - columnNumber) {
              numOfColumns = obj.options.data[0].length - columnNumber;
            }
            if (obj.dispatch("onbeforedeletecolumn", el, columnNumber, numOfColumns) === false) {
              return false;
            }
            if (parseInt(columnNumber) > -1) {
              var mergeExists = false;
              if (Object.keys(obj.options.mergeCells).length > 0) {
                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                  if (obj.isColMerged(col, false).length) {
                    mergeExists = true;
                  }
                }
              }
              if (mergeExists) {
                if (!confirm(obj.options.text.thisActionWillDestroyAnyExistingMergedCellsAreYouSure)) {
                  return false;
                } else {
                  obj.destroyMerged();
                }
              }
              var columns = obj.options.columns.splice(columnNumber, numOfColumns);
              for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                obj.colgroup[col].className = "";
                obj.headers[col].className = "";
                obj.colgroup[col].parentNode.removeChild(obj.colgroup[col]);
                obj.headers[col].parentNode.removeChild(obj.headers[col]);
              }
              var historyHeaders = obj.headers.splice(columnNumber, numOfColumns);
              var historyColgroup = obj.colgroup.splice(columnNumber, numOfColumns);
              var historyRecords = [];
              var historyData = [];
              var historyFooters = [];
              for (var row = 0; row < obj.options.data.length; row++) {
                for (var col = columnNumber; col < columnNumber + numOfColumns; col++) {
                  obj.records[row][col].className = "";
                  obj.records[row][col].parentNode.removeChild(obj.records[row][col]);
                }
              }
              for (var row = 0; row < obj.options.data.length; row++) {
                historyData[row] = obj.options.data[row].splice(columnNumber, numOfColumns);
                historyRecords[row] = obj.records[row].splice(columnNumber, numOfColumns);
              }
              if (obj.options.footers) {
                for (var row = 0; row < obj.options.footers.length; row++) {
                  historyFooters[row] = obj.options.footers[row].splice(columnNumber, numOfColumns);
                }
              }
              obj.conditionalSelectionUpdate(0, columnNumber, columnNumber + numOfColumns - 1);
              if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
                if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
                  for (var j2 = 0; j2 < obj.options.nestedHeaders.length; j2++) {
                    var colspan = parseInt(obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan) - numOfColumns;
                    obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan = colspan;
                    obj.thead.children[j2].children[obj.thead.children[j2].children.length - 1].setAttribute("colspan", colspan);
                  }
                } else {
                  var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - numOfColumns;
                  obj.options.nestedHeaders[0].colspan = colspan;
                  obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute("colspan", colspan);
                }
              }
              obj.setHistory({
                action: "deleteColumn",
                columnNumber,
                numOfColumns,
                insertBefore: 1,
                columns,
                headers: historyHeaders,
                colgroup: historyColgroup,
                records: historyRecords,
                footers: historyFooters,
                data: historyData
              });
              obj.updateTableReferences();
              obj.dispatch("ondeletecolumn", el, columnNumber, numOfColumns, historyRecords);
            }
          } else {
            console.error("Jspreadsheet: It is not possible to delete the last column");
          }
        }
      };
      obj.getSelectedRows = function(asIds) {
        var rows = [];
        for (var j2 = 0; j2 < obj.rows.length; j2++) {
          if (obj.rows[j2].classList.contains("selected")) {
            if (asIds) {
              rows.push(j2);
            } else {
              rows.push(obj.rows[j2]);
            }
          }
        }
        return rows;
      }, obj.getSelectedColumns = function() {
        var cols = [];
        for (var i2 = 0; i2 < obj.headers.length; i2++) {
          if (obj.headers[i2].classList.contains("selected")) {
            cols.push(i2);
          }
        }
        return cols;
      };
      obj.getHighlighted = function() {
        return obj.highlighted;
      };
      obj.updateTableReferences = function() {
        for (var i2 = 0; i2 < obj.headers.length; i2++) {
          var x2 = obj.headers[i2].getAttribute("data-x");
          if (x2 != i2) {
            obj.headers[i2].setAttribute("data-x", i2);
            if (!obj.headers[i2].getAttribute("title")) {
              obj.headers[i2].innerHTML = jexcel.getColumnName(i2);
            }
          }
        }
        for (var j2 = 0; j2 < obj.rows.length; j2++) {
          if (obj.rows[j2]) {
            var y2 = obj.rows[j2].getAttribute("data-y");
            if (y2 != j2) {
              obj.rows[j2].setAttribute("data-y", j2);
              obj.rows[j2].children[0].setAttribute("data-y", j2);
              obj.rows[j2].children[0].innerHTML = j2 + 1;
            }
          }
        }
        var affectedTokens = [];
        var mergeCellUpdates = [];
        var updatePosition = function(x3, y3, i3, j3) {
          if (x3 != i3) {
            obj.records[j3][i3].setAttribute("data-x", i3);
          }
          if (y3 != j3) {
            obj.records[j3][i3].setAttribute("data-y", j3);
          }
          if (x3 != i3 || y3 != j3) {
            var columnIdFrom2 = jexcel.getColumnNameFromId([x3, y3]);
            var columnIdTo2 = jexcel.getColumnNameFromId([i3, j3]);
            affectedTokens[columnIdFrom2] = columnIdTo2;
          }
        };
        for (var j2 = 0; j2 < obj.records.length; j2++) {
          for (var i2 = 0; i2 < obj.records[0].length; i2++) {
            if (obj.records[j2][i2]) {
              var x2 = obj.records[j2][i2].getAttribute("data-x");
              var y2 = obj.records[j2][i2].getAttribute("data-y");
              if (obj.records[j2][i2].getAttribute("data-merged")) {
                var columnIdFrom = jexcel.getColumnNameFromId([x2, y2]);
                var columnIdTo = jexcel.getColumnNameFromId([i2, j2]);
                if (mergeCellUpdates[columnIdFrom] == null) {
                  if (columnIdFrom == columnIdTo) {
                    mergeCellUpdates[columnIdFrom] = false;
                  } else {
                    var totalX = parseInt(i2 - x2);
                    var totalY = parseInt(j2 - y2);
                    mergeCellUpdates[columnIdFrom] = [columnIdTo, totalX, totalY];
                  }
                }
              } else {
                updatePosition(x2, y2, i2, j2);
              }
            }
          }
        }
        var keys2 = Object.keys(mergeCellUpdates);
        if (keys2.length) {
          for (var i2 = 0; i2 < keys2.length; i2++) {
            if (mergeCellUpdates[keys2[i2]]) {
              var info = jexcel.getIdFromColumnName(keys2[i2], true);
              var x2 = info[0];
              var y2 = info[1];
              updatePosition(x2, y2, x2 + mergeCellUpdates[keys2[i2]][1], y2 + mergeCellUpdates[keys2[i2]][2]);
              var columnIdFrom = keys2[i2];
              var columnIdTo = mergeCellUpdates[keys2[i2]][0];
              for (var j2 = 0; j2 < obj.options.mergeCells[columnIdFrom][2].length; j2++) {
                var x2 = parseInt(obj.options.mergeCells[columnIdFrom][2][j2].getAttribute("data-x"));
                var y2 = parseInt(obj.options.mergeCells[columnIdFrom][2][j2].getAttribute("data-y"));
                obj.options.mergeCells[columnIdFrom][2][j2].setAttribute("data-x", x2 + mergeCellUpdates[keys2[i2]][1]);
                obj.options.mergeCells[columnIdFrom][2][j2].setAttribute("data-y", y2 + mergeCellUpdates[keys2[i2]][2]);
              }
              obj.options.mergeCells[columnIdTo] = obj.options.mergeCells[columnIdFrom];
              delete obj.options.mergeCells[columnIdFrom];
            }
          }
        }
        obj.updateFormulas(affectedTokens);
        obj.updateMeta(affectedTokens);
        obj.refreshSelection();
        obj.updateTable();
      };
      obj.updateTable = function() {
        if (obj.options.minSpareRows > 0) {
          var numBlankRows = 0;
          for (var j2 = obj.rows.length - 1; j2 >= 0; j2--) {
            var test = false;
            for (var i2 = 0; i2 < obj.headers.length; i2++) {
              if (obj.options.data[j2][i2]) {
                test = true;
              }
            }
            if (test) {
              break;
            } else {
              numBlankRows++;
            }
          }
          if (obj.options.minSpareRows - numBlankRows > 0) {
            obj.insertRow(obj.options.minSpareRows - numBlankRows);
          }
        }
        if (obj.options.minSpareCols > 0) {
          var numBlankCols = 0;
          for (var i2 = obj.headers.length - 1; i2 >= 0; i2--) {
            var test = false;
            for (var j2 = 0; j2 < obj.rows.length; j2++) {
              if (obj.options.data[j2][i2]) {
                test = true;
              }
            }
            if (test) {
              break;
            } else {
              numBlankCols++;
            }
          }
          if (obj.options.minSpareCols - numBlankCols > 0) {
            obj.insertColumn(obj.options.minSpareCols - numBlankCols);
          }
        }
        if (typeof obj.options.updateTable == "function") {
          if (obj.options.detachForUpdates) {
            el.removeChild(obj.content);
          }
          for (var j2 = 0; j2 < obj.rows.length; j2++) {
            for (var i2 = 0; i2 < obj.headers.length; i2++) {
              obj.options.updateTable(el, obj.records[j2][i2], i2, j2, obj.options.data[j2][i2], obj.records[j2][i2].innerText, jexcel.getColumnNameFromId([i2, j2]));
            }
          }
          if (obj.options.detachForUpdates) {
            el.insertBefore(obj.content, obj.pagination);
          }
        }
        if (obj.options.footers) {
          obj.setFooter();
        }
        setTimeout(function() {
          obj.updateCornerPosition();
        }, 0);
      };
      obj.isReadOnly = function(cell) {
        if (cell = obj.getCell(cell)) {
          return cell.classList.contains("readonly") ? true : false;
        }
      };
      obj.setReadOnly = function(cell, state2) {
        if (cell = obj.getCell(cell)) {
          if (state2) {
            cell.classList.add("readonly");
          } else {
            cell.classList.remove("readonly");
          }
        }
      };
      obj.showRow = function(rowNumber) {
        obj.rows[rowNumber].style.display = "";
      };
      obj.hideRow = function(rowNumber) {
        obj.rows[rowNumber].style.display = "none";
      };
      obj.showColumn = function(colNumber) {
        obj.headers[colNumber].style.display = "";
        obj.colgroup[colNumber].style.display = "";
        if (obj.filter && obj.filter.children.length > colNumber + 1) {
          obj.filter.children[colNumber + 1].style.display = "";
        }
        for (var j2 = 0; j2 < obj.options.data.length; j2++) {
          obj.records[j2][colNumber].style.display = "";
        }
        obj.resetSelection();
      };
      obj.hideColumn = function(colNumber) {
        obj.headers[colNumber].style.display = "none";
        obj.colgroup[colNumber].style.display = "none";
        if (obj.filter && obj.filter.children.length > colNumber + 1) {
          obj.filter.children[colNumber + 1].style.display = "none";
        }
        for (var j2 = 0; j2 < obj.options.data.length; j2++) {
          obj.records[j2][colNumber].style.display = "none";
        }
        obj.resetSelection();
      };
      obj.showIndex = function() {
        obj.table.classList.remove("jexcel_hidden_index");
      };
      obj.hideIndex = function() {
        obj.table.classList.add("jexcel_hidden_index");
      };
      var chainLoopProtection = [];
      obj.updateFormulaChain = function(x2, y2, records) {
        var cellId = jexcel.getColumnNameFromId([x2, y2]);
        if (obj.formula[cellId] && obj.formula[cellId].length > 0) {
          if (chainLoopProtection[cellId]) {
            obj.records[y2][x2].innerHTML = "#ERROR";
            obj.formula[cellId] = "";
          } else {
            chainLoopProtection[cellId] = true;
            for (var i2 = 0; i2 < obj.formula[cellId].length; i2++) {
              var cell = jexcel.getIdFromColumnName(obj.formula[cellId][i2], true);
              var value2 = "" + obj.options.data[cell[1]][cell[0]];
              if (value2.substr(0, 1) == "=") {
                records.push(obj.updateCell(cell[0], cell[1], value2, true));
              } else {
                Object.keys(obj.formula)[i2] = null;
              }
              obj.updateFormulaChain(cell[0], cell[1], records);
            }
          }
        }
        chainLoopProtection = [];
      };
      obj.updateFormulas = function(referencesToUpdate) {
        for (var j2 = 0; j2 < obj.options.data.length; j2++) {
          for (var i2 = 0; i2 < obj.options.data[0].length; i2++) {
            var value2 = "" + obj.options.data[j2][i2];
            if (value2.substr(0, 1) == "=") {
              var newFormula = obj.updateFormula(value2, referencesToUpdate);
              if (newFormula != value2) {
                obj.options.data[j2][i2] = newFormula;
              }
            }
          }
        }
        var formula2 = [];
        var keys2 = Object.keys(obj.formula);
        for (var j2 = 0; j2 < keys2.length; j2++) {
          var key = keys2[j2];
          var value2 = obj.formula[key];
          if (referencesToUpdate[key]) {
            key = referencesToUpdate[key];
          }
          formula2[key] = [];
          for (var i2 = 0; i2 < value2.length; i2++) {
            var letter = value2[i2];
            if (referencesToUpdate[letter]) {
              letter = referencesToUpdate[letter];
            }
            formula2[key].push(letter);
          }
        }
        obj.formula = formula2;
      };
      obj.updateFormula = function(formula2, referencesToUpdate) {
        var testLetter = /[A-Z]/;
        var testNumber = /[0-9]/;
        var newFormula = "";
        var letter = null;
        var number2 = null;
        var token = "";
        for (var index2 = 0; index2 < formula2.length; index2++) {
          if (testLetter.exec(formula2[index2])) {
            letter = 1;
            number2 = 0;
            token += formula2[index2];
          } else if (testNumber.exec(formula2[index2])) {
            number2 = letter ? 1 : 0;
            token += formula2[index2];
          } else {
            if (letter && number2) {
              token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
            }
            newFormula += token;
            newFormula += formula2[index2];
            letter = 0;
            number2 = 0;
            token = "";
          }
        }
        if (token) {
          if (letter && number2) {
            token = referencesToUpdate[token] ? referencesToUpdate[token] : token;
          }
          newFormula += token;
        }
        return newFormula;
      };
      var secureFormula = function(oldValue) {
        var newValue = "";
        var inside = 0;
        for (var i2 = 0; i2 < oldValue.length; i2++) {
          if (oldValue[i2] == '"') {
            if (inside == 0) {
              inside = 1;
            } else {
              inside = 0;
            }
          }
          if (inside == 1) {
            newValue += oldValue[i2];
          } else {
            newValue += oldValue[i2].toUpperCase();
          }
        }
        return newValue;
      };
      obj.executeFormula = function(expression, x, y) {
        var formulaResults = [];
        var formulaLoopProtection = [];
        var execute = function(expression, x, y) {
          var parentId = jexcel.getColumnNameFromId([x, y]);
          if (formulaLoopProtection[parentId]) {
            console.error("Reference loop detected");
            return "#ERROR";
          }
          formulaLoopProtection[parentId] = true;
          var tokensUpdate = function(tokens2) {
            for (var index2 = 0; index2 < tokens2.length; index2++) {
              var f = [];
              var token = tokens2[index2].split(":");
              var e1 = jexcel.getIdFromColumnName(token[0], true);
              var e2 = jexcel.getIdFromColumnName(token[1], true);
              if (e1[0] <= e2[0]) {
                var x1 = e1[0];
                var x2 = e2[0];
              } else {
                var x1 = e2[0];
                var x2 = e1[0];
              }
              if (e1[1] <= e2[1]) {
                var y1 = e1[1];
                var y2 = e2[1];
              } else {
                var y1 = e2[1];
                var y2 = e1[1];
              }
              for (var j2 = y1; j2 <= y2; j2++) {
                for (var i2 = x1; i2 <= x2; i2++) {
                  f.push(jexcel.getColumnNameFromId([i2, j2]));
                }
              }
              expression = expression.replace(tokens2[index2], f.join(","));
            }
          };
          expression = expression.replace(/\$?([A-Z]+)\$?([0-9]+)/g, "$1$2");
          var tokens = expression.match(/([A-Z]+[0-9]+)\:([A-Z]+[0-9]+)/g);
          if (tokens && tokens.length) {
            tokensUpdate(tokens);
          }
          var tokens = expression.match(/([A-Z]+[0-9]+)/g);
          if (tokens && tokens.indexOf(parentId) > -1) {
            console.error("Self Reference detected");
            return "#ERROR";
          } else {
            var formulaExpressions = {};
            if (tokens) {
              for (var i = 0; i < tokens.length; i++) {
                if (!obj.formula[tokens[i]]) {
                  obj.formula[tokens[i]] = [];
                }
                if (obj.formula[tokens[i]].indexOf(parentId) < 0) {
                  obj.formula[tokens[i]].push(parentId);
                }
                if (eval("typeof(" + tokens[i] + ') == "undefined"')) {
                  var position = jexcel.getIdFromColumnName(tokens[i], 1);
                  if (typeof obj.options.data[position[1]] != "undefined" && typeof obj.options.data[position[1]][position[0]] != "undefined") {
                    var value = obj.options.data[position[1]][position[0]];
                  } else {
                    var value = "";
                  }
                  if (("" + value).substr(0, 1) == "=") {
                    if (formulaResults[tokens[i]]) {
                      value = formulaResults[tokens[i]];
                    } else {
                      value = execute(value, position[0], position[1]);
                      formulaResults[tokens[i]] = value;
                    }
                  }
                  if (("" + value).trim() == "") {
                    formulaExpressions[tokens[i]] = null;
                  } else {
                    if (value == Number(value) && obj.options.autoCasting == true) {
                      formulaExpressions[tokens[i]] = Number(value);
                    } else {
                      var number = obj.parseNumber(value, position[0]);
                      if (obj.options.autoCasting == true && number) {
                        formulaExpressions[tokens[i]] = number;
                      } else {
                        formulaExpressions[tokens[i]] = '"' + value + '"';
                      }
                    }
                  }
                }
              }
            }
            try {
              var res = jexcel.formula(expression.substr(1), formulaExpressions, x, y, obj);
            } catch (e) {
              var res = "#ERROR";
              console.log(e);
            }
            return res;
          }
        };
        return execute(expression, x, y);
      };
      obj.parseNumber = function(value2, columnNumber) {
        var decimal = columnNumber && obj.options.columns[columnNumber].decimal ? obj.options.columns[columnNumber].decimal : ".";
        var number2 = "" + value2;
        number2 = number2.split(decimal);
        number2[0] = number2[0].match(/[+-]?[0-9]/g);
        if (number2[0]) {
          number2[0] = number2[0].join("");
        }
        if (number2[1]) {
          number2[1] = number2[1].match(/[0-9]*/g).join("");
        }
        if (number2[0] && Number(number2[0]) >= 0) {
          if (!number2[1]) {
            var value2 = Number(number2[0] + ".00");
          } else {
            var value2 = Number(number2[0] + "." + number2[1]);
          }
        } else {
          var value2 = null;
        }
        return value2;
      };
      obj.row = function(cell) {
      };
      obj.col = function(cell) {
      };
      obj.up = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (obj.selectedCell[3] > 0) {
            obj.up.visible(1, ctrlKey ? 0 : 1);
          }
        } else {
          if (obj.selectedCell[1] > 0) {
            obj.up.visible(0, ctrlKey ? 0 : 1);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        if (obj.options.lazyLoading == true) {
          if (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0) {
            obj.loadPage(0);
            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
          } else {
            if (obj.loadValidation()) {
              obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
            } else {
              var item = parseInt(obj.tbody.firstChild.getAttribute("data-y"));
              if (obj.selectedCell[1] - item < 30) {
                obj.loadUp();
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
              }
            }
          }
        } else if (obj.options.pagination > 0) {
          var pageNumber = obj.whichPage(obj.selectedCell[3]);
          if (pageNumber != obj.pageNumber) {
            obj.page(pageNumber);
          }
        }
        obj.updateScroll(1);
      };
      obj.up.visible = function(group, direction) {
        if (group == 0) {
          var x2 = parseInt(obj.selectedCell[0]);
          var y2 = parseInt(obj.selectedCell[1]);
        } else {
          var x2 = parseInt(obj.selectedCell[2]);
          var y2 = parseInt(obj.selectedCell[3]);
        }
        if (direction == 0) {
          for (var j2 = 0; j2 < y2; j2++) {
            if (obj.records[j2][x2].style.display != "none" && obj.rows[j2].style.display != "none") {
              y2 = j2;
              break;
            }
          }
        } else {
          y2 = obj.up.get(x2, y2);
        }
        if (group == 0) {
          obj.selectedCell[0] = x2;
          obj.selectedCell[1] = y2;
        } else {
          obj.selectedCell[2] = x2;
          obj.selectedCell[3] = y2;
        }
      };
      obj.up.get = function(x2, y2) {
        var x2 = parseInt(x2);
        var y2 = parseInt(y2);
        for (var j2 = y2 - 1; j2 >= 0; j2--) {
          if (obj.records[j2][x2].style.display != "none" && obj.rows[j2].style.display != "none") {
            if (obj.records[j2][x2].getAttribute("data-merged")) {
              if (obj.records[j2][x2] == obj.records[y2][x2]) {
                continue;
              }
            }
            y2 = j2;
            break;
          }
        }
        return y2;
      };
      obj.down = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (obj.selectedCell[3] < obj.records.length - 1) {
            obj.down.visible(1, ctrlKey ? 0 : 1);
          }
        } else {
          if (obj.selectedCell[1] < obj.records.length - 1) {
            obj.down.visible(0, ctrlKey ? 0 : 1);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        if (obj.options.lazyLoading == true) {
          if (obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1) {
            obj.loadPage(-1);
            obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
          } else {
            if (obj.loadValidation()) {
              obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
            } else {
              var item = parseInt(obj.tbody.lastChild.getAttribute("data-y"));
              if (item - obj.selectedCell[3] < 30) {
                obj.loadDown();
                obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
              }
            }
          }
        } else if (obj.options.pagination > 0) {
          var pageNumber = obj.whichPage(obj.selectedCell[3]);
          if (pageNumber != obj.pageNumber) {
            obj.page(pageNumber);
          }
        }
        obj.updateScroll(3);
      };
      obj.down.visible = function(group, direction) {
        if (group == 0) {
          var x2 = parseInt(obj.selectedCell[0]);
          var y2 = parseInt(obj.selectedCell[1]);
        } else {
          var x2 = parseInt(obj.selectedCell[2]);
          var y2 = parseInt(obj.selectedCell[3]);
        }
        if (direction == 0) {
          for (var j2 = obj.rows.length - 1; j2 > y2; j2--) {
            if (obj.records[j2][x2].style.display != "none" && obj.rows[j2].style.display != "none") {
              y2 = j2;
              break;
            }
          }
        } else {
          y2 = obj.down.get(x2, y2);
        }
        if (group == 0) {
          obj.selectedCell[0] = x2;
          obj.selectedCell[1] = y2;
        } else {
          obj.selectedCell[2] = x2;
          obj.selectedCell[3] = y2;
        }
      };
      obj.down.get = function(x2, y2) {
        var x2 = parseInt(x2);
        var y2 = parseInt(y2);
        for (var j2 = y2 + 1; j2 < obj.rows.length; j2++) {
          if (obj.records[j2][x2].style.display != "none" && obj.rows[j2].style.display != "none") {
            if (obj.records[j2][x2].getAttribute("data-merged")) {
              if (obj.records[j2][x2] == obj.records[y2][x2]) {
                continue;
              }
            }
            y2 = j2;
            break;
          }
        }
        return y2;
      };
      obj.right = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (obj.selectedCell[2] < obj.headers.length - 1) {
            obj.right.visible(1, ctrlKey ? 0 : 1);
          }
        } else {
          if (obj.selectedCell[0] < obj.headers.length - 1) {
            obj.right.visible(0, ctrlKey ? 0 : 1);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        obj.updateScroll(2);
      };
      obj.right.visible = function(group, direction) {
        if (group == 0) {
          var x2 = parseInt(obj.selectedCell[0]);
          var y2 = parseInt(obj.selectedCell[1]);
        } else {
          var x2 = parseInt(obj.selectedCell[2]);
          var y2 = parseInt(obj.selectedCell[3]);
        }
        if (direction == 0) {
          for (var i2 = obj.headers.length - 1; i2 > x2; i2--) {
            if (obj.records[y2][i2].style.display != "none") {
              x2 = i2;
              break;
            }
          }
        } else {
          x2 = obj.right.get(x2, y2);
        }
        if (group == 0) {
          obj.selectedCell[0] = x2;
          obj.selectedCell[1] = y2;
        } else {
          obj.selectedCell[2] = x2;
          obj.selectedCell[3] = y2;
        }
      };
      obj.right.get = function(x2, y2) {
        var x2 = parseInt(x2);
        var y2 = parseInt(y2);
        for (var i2 = x2 + 1; i2 < obj.headers.length; i2++) {
          if (obj.records[y2][i2].style.display != "none") {
            if (obj.records[y2][i2].getAttribute("data-merged")) {
              if (obj.records[y2][i2] == obj.records[y2][x2]) {
                continue;
              }
            }
            x2 = i2;
            break;
          }
        }
        return x2;
      };
      obj.left = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (obj.selectedCell[2] > 0) {
            obj.left.visible(1, ctrlKey ? 0 : 1);
          }
        } else {
          if (obj.selectedCell[0] > 0) {
            obj.left.visible(0, ctrlKey ? 0 : 1);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        obj.updateScroll(0);
      };
      obj.left.visible = function(group, direction) {
        if (group == 0) {
          var x2 = parseInt(obj.selectedCell[0]);
          var y2 = parseInt(obj.selectedCell[1]);
        } else {
          var x2 = parseInt(obj.selectedCell[2]);
          var y2 = parseInt(obj.selectedCell[3]);
        }
        if (direction == 0) {
          for (var i2 = 0; i2 < x2; i2++) {
            if (obj.records[y2][i2].style.display != "none") {
              x2 = i2;
              break;
            }
          }
        } else {
          x2 = obj.left.get(x2, y2);
        }
        if (group == 0) {
          obj.selectedCell[0] = x2;
          obj.selectedCell[1] = y2;
        } else {
          obj.selectedCell[2] = x2;
          obj.selectedCell[3] = y2;
        }
      };
      obj.left.get = function(x2, y2) {
        var x2 = parseInt(x2);
        var y2 = parseInt(y2);
        for (var i2 = x2 - 1; i2 >= 0; i2--) {
          if (obj.records[y2][i2].style.display != "none") {
            if (obj.records[y2][i2].getAttribute("data-merged")) {
              if (obj.records[y2][i2] == obj.records[y2][x2]) {
                continue;
              }
            }
            x2 = i2;
            break;
          }
        }
        return x2;
      };
      obj.first = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (ctrlKey) {
            obj.selectedCell[3] = 0;
          } else {
            obj.left.visible(1, 0);
          }
        } else {
          if (ctrlKey) {
            obj.selectedCell[1] = 0;
          } else {
            obj.left.visible(0, 0);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        if (obj.options.lazyLoading == true && (obj.selectedCell[1] == 0 || obj.selectedCell[3] == 0)) {
          obj.loadPage(0);
        } else if (obj.options.pagination > 0) {
          var pageNumber = obj.whichPage(obj.selectedCell[3]);
          if (pageNumber != obj.pageNumber) {
            obj.page(pageNumber);
          }
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        obj.updateScroll(1);
      };
      obj.last = function(shiftKey, ctrlKey) {
        if (shiftKey) {
          if (ctrlKey) {
            obj.selectedCell[3] = obj.records.length - 1;
          } else {
            obj.right.visible(1, 0);
          }
        } else {
          if (ctrlKey) {
            obj.selectedCell[1] = obj.records.length - 1;
          } else {
            obj.right.visible(0, 0);
          }
          obj.selectedCell[2] = obj.selectedCell[0];
          obj.selectedCell[3] = obj.selectedCell[1];
        }
        if (obj.options.lazyLoading == true && (obj.selectedCell[1] == obj.records.length - 1 || obj.selectedCell[3] == obj.records.length - 1)) {
          obj.loadPage(-1);
        } else if (obj.options.pagination > 0) {
          var pageNumber = obj.whichPage(obj.selectedCell[3]);
          if (pageNumber != obj.pageNumber) {
            obj.page(pageNumber);
          }
        }
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
        obj.updateScroll(3);
      };
      obj.selectAll = function() {
        if (!obj.selectedCell) {
          obj.selectedCell = [];
        }
        obj.selectedCell[0] = 0;
        obj.selectedCell[1] = 0;
        obj.selectedCell[2] = obj.headers.length - 1;
        obj.selectedCell[3] = obj.records.length - 1;
        obj.updateSelectionFromCoords(obj.selectedCell[0], obj.selectedCell[1], obj.selectedCell[2], obj.selectedCell[3]);
      };
      obj.loadPage = function(pageNumber) {
        if (obj.options.search == true && obj.results) {
          var results2 = obj.results;
        } else {
          var results2 = obj.rows;
        }
        var quantityPerPage = 100;
        if (pageNumber == null || pageNumber == -1) {
          pageNumber = Math.ceil(results2.length / quantityPerPage) - 1;
        }
        var startRow = pageNumber * quantityPerPage;
        var finalRow = pageNumber * quantityPerPage + quantityPerPage;
        if (finalRow > results2.length) {
          finalRow = results2.length;
        }
        startRow = finalRow - 100;
        if (startRow < 0) {
          startRow = 0;
        }
        for (var j2 = startRow; j2 < finalRow; j2++) {
          if (obj.options.search == true && obj.results) {
            obj.tbody.appendChild(obj.rows[results2[j2]]);
          } else {
            obj.tbody.appendChild(obj.rows[j2]);
          }
          if (obj.tbody.children.length > quantityPerPage) {
            obj.tbody.removeChild(obj.tbody.firstChild);
          }
        }
      };
      obj.loadUp = function() {
        if (obj.options.search == true && obj.results) {
          var results2 = obj.results;
        } else {
          var results2 = obj.rows;
        }
        var test = 0;
        if (results2.length > 100) {
          var item = parseInt(obj.tbody.firstChild.getAttribute("data-y"));
          if (obj.options.search == true && obj.results) {
            item = results2.indexOf(item);
          }
          if (item > 0) {
            for (var j2 = 0; j2 < 30; j2++) {
              item = item - 1;
              if (item > -1) {
                if (obj.options.search == true && obj.results) {
                  obj.tbody.insertBefore(obj.rows[results2[item]], obj.tbody.firstChild);
                } else {
                  obj.tbody.insertBefore(obj.rows[item], obj.tbody.firstChild);
                }
                if (obj.tbody.children.length > 100) {
                  obj.tbody.removeChild(obj.tbody.lastChild);
                  test = 1;
                }
              }
            }
          }
        }
        return test;
      };
      obj.loadDown = function() {
        if (obj.options.search == true && obj.results) {
          var results2 = obj.results;
        } else {
          var results2 = obj.rows;
        }
        var test = 0;
        if (results2.length > 100) {
          var item = parseInt(obj.tbody.lastChild.getAttribute("data-y"));
          if (obj.options.search == true && obj.results) {
            item = results2.indexOf(item);
          }
          if (item < obj.rows.length - 1) {
            for (var j2 = 0; j2 <= 30; j2++) {
              if (item < results2.length) {
                if (obj.options.search == true && obj.results) {
                  obj.tbody.appendChild(obj.rows[results2[item]]);
                } else {
                  obj.tbody.appendChild(obj.rows[item]);
                }
                if (obj.tbody.children.length > 100) {
                  obj.tbody.removeChild(obj.tbody.firstChild);
                  test = 1;
                }
              }
              item = item + 1;
            }
          }
        }
        return test;
      };
      obj.loadValidation = function() {
        if (obj.selectedCell) {
          var currentPage = parseInt(obj.tbody.firstChild.getAttribute("data-y")) / 100;
          var selectedPage = parseInt(obj.selectedCell[3] / 100);
          var totalPages = parseInt(obj.rows.length / 100);
          if (currentPage != selectedPage && selectedPage <= totalPages) {
            if (!Array.prototype.indexOf.call(obj.tbody.children, obj.rows[obj.selectedCell[3]])) {
              obj.loadPage(selectedPage);
              return true;
            }
          }
        }
        return false;
      };
      obj.resetSearch = function() {
        obj.searchInput.value = "";
        obj.search("");
        obj.results = null;
      };
      obj.search = function(query2) {
        if (query2) {
          var query2 = query2.toLowerCase();
        }
        if (obj.options.filters) {
          obj.resetFilters();
        }
        obj.resetSelection();
        obj.pageNumber = 0;
        obj.results = [];
        if (query2) {
          var search = function(item, query3, index2) {
            for (var i2 = 0; i2 < item.length; i2++) {
              if (("" + item[i2]).toLowerCase().search(query3) >= 0 || ("" + obj.records[index2][i2].innerHTML).toLowerCase().search(query3) >= 0) {
                return true;
              }
            }
            return false;
          };
          var addToResult = function(k2) {
            if (obj.results.indexOf(k2) == -1) {
              obj.results.push(k2);
            }
          };
          obj.options.data.filter(function(v, k2) {
            if (search(v, query2, k2)) {
              var rows = obj.isRowMerged(k2);
              if (rows.length) {
                for (var i2 = 0; i2 < rows.length; i2++) {
                  var row = jexcel.getIdFromColumnName(rows[i2], true);
                  for (var j2 = 0; j2 < obj.options.mergeCells[rows[i2]][1]; j2++) {
                    addToResult(row[1] + j2);
                  }
                }
              } else {
                addToResult(k2);
              }
              return true;
            } else {
              return false;
            }
          });
        } else {
          obj.results = null;
        }
        return obj.updateResult();
      };
      obj.updateResult = function() {
        var total = 0;
        var index2 = 0;
        if (obj.options.lazyLoading == true) {
          total = 100;
        } else if (obj.options.pagination > 0) {
          total = obj.options.pagination;
        } else {
          if (obj.results) {
            total = obj.results.length;
          } else {
            total = obj.rows.length;
          }
        }
        while (obj.tbody.firstChild) {
          obj.tbody.removeChild(obj.tbody.firstChild);
        }
        for (var j2 = 0; j2 < obj.rows.length; j2++) {
          if (!obj.results || obj.results.indexOf(j2) > -1) {
            if (index2 < total) {
              obj.tbody.appendChild(obj.rows[j2]);
              index2++;
            }
            obj.rows[j2].style.display = "";
          } else {
            obj.rows[j2].style.display = "none";
          }
        }
        if (obj.options.pagination > 0) {
          obj.updatePagination();
        }
        obj.updateCornerPosition();
        return total;
      };
      obj.whichPage = function(cell) {
        if (obj.options.search == true && obj.results) {
          cell = obj.results.indexOf(cell);
        }
        return Math.ceil((parseInt(cell) + 1) / parseInt(obj.options.pagination)) - 1;
      };
      obj.page = function(pageNumber) {
        var oldPage = obj.pageNumber;
        if (obj.options.search == true && obj.results) {
          var results2 = obj.results;
        } else {
          var results2 = obj.rows;
        }
        var quantityPerPage = parseInt(obj.options.pagination);
        if (pageNumber == null || pageNumber == -1) {
          pageNumber = Math.ceil(results2.length / quantityPerPage) - 1;
        }
        obj.pageNumber = pageNumber;
        var startRow = pageNumber * quantityPerPage;
        var finalRow = pageNumber * quantityPerPage + quantityPerPage;
        if (finalRow > results2.length) {
          finalRow = results2.length;
        }
        if (startRow < 0) {
          startRow = 0;
        }
        while (obj.tbody.firstChild) {
          obj.tbody.removeChild(obj.tbody.firstChild);
        }
        for (var j2 = startRow; j2 < finalRow; j2++) {
          if (obj.options.search == true && obj.results) {
            obj.tbody.appendChild(obj.rows[results2[j2]]);
          } else {
            obj.tbody.appendChild(obj.rows[j2]);
          }
        }
        if (obj.options.pagination > 0) {
          obj.updatePagination();
        }
        obj.updateCornerPosition();
        obj.dispatch("onchangepage", el, pageNumber, oldPage);
      };
      obj.updatePagination = function() {
        obj.pagination.children[0].innerHTML = "";
        obj.pagination.children[1].innerHTML = "";
        if (obj.options.pagination) {
          if (obj.options.search == true && obj.results) {
            var results2 = obj.results.length;
          } else {
            var results2 = obj.rows.length;
          }
          if (!results2) {
            obj.pagination.children[0].innerHTML = obj.options.text.noRecordsFound;
          } else {
            var quantyOfPages = Math.ceil(results2 / obj.options.pagination);
            if (obj.pageNumber < 6) {
              var startNumber = 1;
              var finalNumber = quantyOfPages < 10 ? quantyOfPages : 10;
            } else if (quantyOfPages - obj.pageNumber < 5) {
              var startNumber = quantyOfPages - 9;
              var finalNumber = quantyOfPages;
              if (startNumber < 1) {
                startNumber = 1;
              }
            } else {
              var startNumber = obj.pageNumber - 4;
              var finalNumber = obj.pageNumber + 5;
            }
            if (startNumber > 1) {
              var paginationItem = document.createElement("div");
              paginationItem.className = "jexcel_page";
              paginationItem.innerHTML = "<";
              paginationItem.title = 1;
              obj.pagination.children[1].appendChild(paginationItem);
            }
            for (var i2 = startNumber; i2 <= finalNumber; i2++) {
              var paginationItem = document.createElement("div");
              paginationItem.className = "jexcel_page";
              paginationItem.innerHTML = i2;
              obj.pagination.children[1].appendChild(paginationItem);
              if (obj.pageNumber == i2 - 1) {
                paginationItem.classList.add("jexcel_page_selected");
              }
            }
            if (finalNumber < quantyOfPages) {
              var paginationItem = document.createElement("div");
              paginationItem.className = "jexcel_page";
              paginationItem.innerHTML = ">";
              paginationItem.title = quantyOfPages;
              obj.pagination.children[1].appendChild(paginationItem);
            }
            var format22 = function(format3) {
              var args2 = Array.prototype.slice.call(arguments, 1);
              return format3.replace(/{(\d+)}/g, function(match, number2) {
                return typeof args2[number2] != "undefined" ? args2[number2] : match;
              });
            };
            obj.pagination.children[0].innerHTML = format22(obj.options.text.showingPage, obj.pageNumber + 1, quantyOfPages);
          }
        }
      };
      obj.download = function(includeHeaders) {
        if (obj.options.allowExport == false) {
          console.error("Export not allowed");
        } else {
          var data = "";
          data += obj.copy(false, obj.options.csvDelimiter, true, includeHeaders, true);
          var blob2 = new Blob(["\uFEFF" + data], { type: "text/csv;charset=utf-8;" });
          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob2, obj.options.csvFileName + ".csv");
          } else {
            var pom = document.createElement("a");
            var url = URL.createObjectURL(blob2);
            pom.href = url;
            pom.setAttribute("download", obj.options.csvFileName + ".csv");
            document.body.appendChild(pom);
            pom.click();
            pom.parentNode.removeChild(pom);
          }
        }
      };
      obj.setHistory = function(changes) {
        if (obj.ignoreHistory != true) {
          var index2 = ++obj.historyIndex;
          obj.history = obj.history = obj.history.slice(0, index2 + 1);
          obj.history[index2] = changes;
        }
      };
      obj.copy = function(highlighted, delimiter, returnData, includeHeaders, download) {
        if (!delimiter) {
          delimiter = "	";
        }
        var div2 = new RegExp(delimiter, "ig");
        var header = [];
        var col = [];
        var colLabel = [];
        var row = [];
        var rowLabel = [];
        var x2 = obj.options.data[0].length;
        var y2 = obj.options.data.length;
        var tmp2 = "";
        var copyHeader = false;
        var headers = "";
        var nestedHeaders = "";
        var numOfCols = 0;
        var numOfRows = 0;
        var copyX = 0;
        var copyY = 0;
        var isPartialCopy = true;
        for (var j2 = 0; j2 < y2; j2++) {
          for (var i2 = 0; i2 < x2; i2++) {
            if (!highlighted || obj.records[j2][i2].classList.contains("highlight")) {
              if (copyX <= i2) {
                copyX = i2;
              }
              if (copyY <= j2) {
                copyY = j2;
              }
            }
          }
        }
        if (x2 === copyX + 1 && y2 === copyY + 1) {
          isPartialCopy = false;
        }
        if (download && obj.options.includeHeadersOnDownload == true || !download && obj.options.includeHeadersOnCopy == true && !isPartialCopy || includeHeaders) {
          if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
            if (!(obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0])) {
              tmp2 = [obj.options.nestedHeaders];
            } else {
              tmp2 = obj.options.nestedHeaders;
            }
            for (var j2 = 0; j2 < tmp2.length; j2++) {
              var nested = [];
              for (var i2 = 0; i2 < tmp2[j2].length; i2++) {
                var colspan = parseInt(tmp2[j2][i2].colspan);
                nested.push(tmp2[j2][i2].title);
                for (var c2 = 0; c2 < colspan - 1; c2++) {
                  nested.push("");
                }
              }
              nestedHeaders += nested.join(delimiter) + "\r\n";
            }
          }
          copyHeader = true;
        }
        obj.style = [];
        for (var j2 = 0; j2 < y2; j2++) {
          col = [];
          colLabel = [];
          for (var i2 = 0; i2 < x2; i2++) {
            if (!highlighted || obj.records[j2][i2].classList.contains("highlight")) {
              if (copyHeader == true) {
                header.push(obj.headers[i2].innerText);
              }
              var value2 = obj.options.data[j2][i2];
              if (value2.match && (value2.match(div2) || value2.match(/,/g) || value2.match(/\n/) || value2.match(/\"/))) {
                value2 = value2.replace(new RegExp('"', "g"), '""');
                value2 = '"' + value2 + '"';
              }
              col.push(value2);
              if (obj.options.columns[i2].type == "checkbox" || obj.options.columns[i2].type == "radio") {
                var label = value2;
              } else {
                if (obj.options.stripHTMLOnCopy == true) {
                  var label = obj.records[j2][i2].innerText;
                } else {
                  var label = obj.records[j2][i2].innerHTML;
                }
                if (label.match && (label.match(div2) || label.match(/,/g) || label.match(/\n/) || label.match(/\"/))) {
                  label = label.replace(new RegExp('"', "g"), '""');
                  label = '"' + label + '"';
                }
              }
              colLabel.push(label);
              tmp2 = obj.records[j2][i2].getAttribute("style");
              tmp2 = tmp2.replace("display: none;", "");
              obj.style.push(tmp2 ? tmp2 : "");
            }
          }
          if (col.length) {
            if (copyHeader) {
              numOfCols = col.length;
              row.push(header.join(delimiter));
            }
            row.push(col.join(delimiter));
          }
          if (colLabel.length) {
            numOfRows++;
            if (copyHeader) {
              rowLabel.push(header.join(delimiter));
              copyHeader = false;
            }
            rowLabel.push(colLabel.join(delimiter));
          }
        }
        if (x2 == numOfCols && y2 == numOfRows) {
          headers = nestedHeaders;
        }
        var str2 = headers + row.join("\r\n");
        var strLabel = headers + rowLabel.join("\r\n");
        if (!returnData) {
          if (obj.options.copyCompatibility == true) {
            obj.textarea.value = strLabel;
          } else {
            obj.textarea.value = str2;
          }
          obj.textarea.select();
          document.execCommand("copy");
        }
        if (obj.options.copyCompatibility == true) {
          obj.data = strLabel;
        } else {
          obj.data = str2;
        }
        obj.hashString = obj.hash(obj.data);
        if (!returnData) {
          obj.removeCopyingSelection();
          if (obj.highlighted) {
            for (var i2 = 0; i2 < obj.highlighted.length; i2++) {
              obj.highlighted[i2].classList.add("copying");
              if (obj.highlighted[i2].classList.contains("highlight-left")) {
                obj.highlighted[i2].classList.add("copying-left");
              }
              if (obj.highlighted[i2].classList.contains("highlight-right")) {
                obj.highlighted[i2].classList.add("copying-right");
              }
              if (obj.highlighted[i2].classList.contains("highlight-top")) {
                obj.highlighted[i2].classList.add("copying-top");
              }
              if (obj.highlighted[i2].classList.contains("highlight-bottom")) {
                obj.highlighted[i2].classList.add("copying-bottom");
              }
            }
          }
          obj.dispatch("oncopy", el, obj.options.copyCompatibility == true ? rowLabel : row, obj.hashString);
        }
        return obj.data;
      };
      obj.paste = function(x2, y2, data) {
        var ret = obj.dispatch("onbeforepaste", el, data, x2, y2);
        if (ret === false) {
          return false;
        } else if (ret) {
          var data = ret;
        }
        var hash2 = obj.hash(data);
        var style = hash2 == obj.hashString ? obj.style : null;
        if (obj.options.copyCompatibility == true && hash2 == obj.hashString) {
          var data = obj.data;
        }
        var data = obj.parseCSV(data, "	");
        if (x2 != null && y2 != null && data) {
          var i2 = 0;
          var j2 = 0;
          var records = [];
          var newStyle = {};
          var oldStyle = {};
          var styleIndex = 0;
          var colIndex = parseInt(x2);
          var rowIndex = parseInt(y2);
          var row = null;
          while (row = data[j2]) {
            i2 = 0;
            colIndex = parseInt(x2);
            while (row[i2] != null) {
              var record = obj.updateCell(colIndex, rowIndex, row[i2]);
              records.push(record);
              obj.updateFormulaChain(colIndex, rowIndex, records);
              if (style && style[styleIndex]) {
                var columnName = jexcel.getColumnNameFromId([colIndex, rowIndex]);
                newStyle[columnName] = style[styleIndex];
                oldStyle[columnName] = obj.getStyle(columnName);
                obj.records[rowIndex][colIndex].setAttribute("style", style[styleIndex]);
                styleIndex++;
              }
              i2++;
              if (row[i2] != null) {
                if (colIndex >= obj.headers.length - 1) {
                  if (obj.options.allowInsertColumn == true) {
                    obj.insertColumn();
                  } else {
                    break;
                  }
                }
                colIndex = obj.right.get(colIndex, rowIndex);
              }
            }
            j2++;
            if (data[j2]) {
              if (rowIndex >= obj.rows.length - 1) {
                if (obj.options.allowInsertRow == true) {
                  obj.insertRow();
                } else {
                  break;
                }
              }
              rowIndex = obj.down.get(x2, rowIndex);
            }
          }
          obj.updateSelectionFromCoords(x2, y2, colIndex, rowIndex);
          obj.setHistory({
            action: "setValue",
            records,
            selection: obj.selectedCell,
            newStyle,
            oldStyle
          });
          obj.updateTable();
          obj.dispatch("onpaste", el, data);
          obj.onafterchanges(el, records);
        }
        obj.removeCopyingSelection();
      };
      obj.removeCopyingSelection = function() {
        var copying = document.querySelectorAll(".jexcel .copying");
        for (var i2 = 0; i2 < copying.length; i2++) {
          copying[i2].classList.remove("copying");
          copying[i2].classList.remove("copying-left");
          copying[i2].classList.remove("copying-right");
          copying[i2].classList.remove("copying-top");
          copying[i2].classList.remove("copying-bottom");
        }
      };
      obj.historyProcessRow = function(type2, historyRecord) {
        var rowIndex = !historyRecord.insertBefore ? historyRecord.rowNumber + 1 : +historyRecord.rowNumber;
        if (obj.options.search == true) {
          if (obj.results && obj.results.length != obj.rows.length) {
            obj.resetSearch();
          }
        }
        if (type2 == 1) {
          var numOfRows = historyRecord.numOfRows;
          for (var j2 = rowIndex; j2 < numOfRows + rowIndex; j2++) {
            obj.rows[j2].parentNode.removeChild(obj.rows[j2]);
          }
          obj.records.splice(rowIndex, numOfRows);
          obj.options.data.splice(rowIndex, numOfRows);
          obj.rows.splice(rowIndex, numOfRows);
          obj.conditionalSelectionUpdate(1, rowIndex, numOfRows + rowIndex - 1);
        } else {
          obj.records = jexcel.injectArray(obj.records, rowIndex, historyRecord.rowRecords);
          obj.options.data = jexcel.injectArray(obj.options.data, rowIndex, historyRecord.rowData);
          obj.rows = jexcel.injectArray(obj.rows, rowIndex, historyRecord.rowNode);
          var index2 = 0;
          for (var j2 = rowIndex; j2 < historyRecord.numOfRows + rowIndex; j2++) {
            obj.tbody.insertBefore(historyRecord.rowNode[index2], obj.tbody.children[j2]);
            index2++;
          }
        }
        if (obj.options.pagination > 0) {
          obj.page(obj.pageNumber);
        }
        obj.updateTableReferences();
      };
      obj.historyProcessColumn = function(type2, historyRecord) {
        var columnIndex = !historyRecord.insertBefore ? historyRecord.columnNumber + 1 : historyRecord.columnNumber;
        if (type2 == 1) {
          var numOfColumns = historyRecord.numOfColumns;
          obj.options.columns.splice(columnIndex, numOfColumns);
          for (var i2 = columnIndex; i2 < numOfColumns + columnIndex; i2++) {
            obj.headers[i2].parentNode.removeChild(obj.headers[i2]);
            obj.colgroup[i2].parentNode.removeChild(obj.colgroup[i2]);
          }
          obj.headers.splice(columnIndex, numOfColumns);
          obj.colgroup.splice(columnIndex, numOfColumns);
          for (var j2 = 0; j2 < historyRecord.data.length; j2++) {
            for (var i2 = columnIndex; i2 < numOfColumns + columnIndex; i2++) {
              obj.records[j2][i2].parentNode.removeChild(obj.records[j2][i2]);
            }
            obj.records[j2].splice(columnIndex, numOfColumns);
            obj.options.data[j2].splice(columnIndex, numOfColumns);
          }
          if (obj.options.footers) {
            for (var j2 = 0; j2 < obj.options.footers.length; j2++) {
              obj.options.footers[j2].splice(columnIndex, numOfColumns);
            }
          }
        } else {
          obj.options.columns = jexcel.injectArray(obj.options.columns, columnIndex, historyRecord.columns);
          obj.headers = jexcel.injectArray(obj.headers, columnIndex, historyRecord.headers);
          obj.colgroup = jexcel.injectArray(obj.colgroup, columnIndex, historyRecord.colgroup);
          var index2 = 0;
          for (var i2 = columnIndex; i2 < historyRecord.numOfColumns + columnIndex; i2++) {
            obj.headerContainer.insertBefore(historyRecord.headers[index2], obj.headerContainer.children[i2 + 1]);
            obj.colgroupContainer.insertBefore(historyRecord.colgroup[index2], obj.colgroupContainer.children[i2 + 1]);
            index2++;
          }
          for (var j2 = 0; j2 < historyRecord.data.length; j2++) {
            obj.options.data[j2] = jexcel.injectArray(obj.options.data[j2], columnIndex, historyRecord.data[j2]);
            obj.records[j2] = jexcel.injectArray(obj.records[j2], columnIndex, historyRecord.records[j2]);
            var index2 = 0;
            for (var i2 = columnIndex; i2 < historyRecord.numOfColumns + columnIndex; i2++) {
              obj.rows[j2].insertBefore(historyRecord.records[j2][index2], obj.rows[j2].children[i2 + 1]);
              index2++;
            }
          }
          if (obj.options.footers) {
            for (var j2 = 0; j2 < obj.options.footers.length; j2++) {
              obj.options.footers[j2] = jexcel.injectArray(obj.options.footers[j2], columnIndex, historyRecord.footers[j2]);
            }
          }
        }
        if (obj.options.nestedHeaders && obj.options.nestedHeaders.length > 0) {
          if (obj.options.nestedHeaders[0] && obj.options.nestedHeaders[0][0]) {
            for (var j2 = 0; j2 < obj.options.nestedHeaders.length; j2++) {
              if (type2 == 1) {
                var colspan = parseInt(obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan) - historyRecord.numOfColumns;
              } else {
                var colspan = parseInt(obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan) + historyRecord.numOfColumns;
              }
              obj.options.nestedHeaders[j2][obj.options.nestedHeaders[j2].length - 1].colspan = colspan;
              obj.thead.children[j2].children[obj.thead.children[j2].children.length - 1].setAttribute("colspan", colspan);
            }
          } else {
            if (type2 == 1) {
              var colspan = parseInt(obj.options.nestedHeaders[0].colspan) - historyRecord.numOfColumns;
            } else {
              var colspan = parseInt(obj.options.nestedHeaders[0].colspan) + historyRecord.numOfColumns;
            }
            obj.options.nestedHeaders[0].colspan = colspan;
            obj.thead.children[0].children[obj.thead.children[0].children.length - 1].setAttribute("colspan", colspan);
          }
        }
        obj.updateTableReferences();
      };
      obj.undo = function() {
        var ignoreEvents = obj.ignoreEvents ? true : false;
        var ignoreHistory = obj.ignoreHistory ? true : false;
        obj.ignoreEvents = true;
        obj.ignoreHistory = true;
        var records = [];
        if (obj.historyIndex >= 0) {
          var historyRecord = obj.history[obj.historyIndex--];
          if (historyRecord.action == "insertRow") {
            obj.historyProcessRow(1, historyRecord);
          } else if (historyRecord.action == "deleteRow") {
            obj.historyProcessRow(0, historyRecord);
          } else if (historyRecord.action == "insertColumn") {
            obj.historyProcessColumn(1, historyRecord);
          } else if (historyRecord.action == "deleteColumn") {
            obj.historyProcessColumn(0, historyRecord);
          } else if (historyRecord.action == "moveRow") {
            obj.moveRow(historyRecord.newValue, historyRecord.oldValue);
          } else if (historyRecord.action == "moveColumn") {
            obj.moveColumn(historyRecord.newValue, historyRecord.oldValue);
          } else if (historyRecord.action == "setMerge") {
            obj.removeMerge(historyRecord.column, historyRecord.data);
          } else if (historyRecord.action == "setStyle") {
            obj.setStyle(historyRecord.oldValue, null, null, 1);
          } else if (historyRecord.action == "setWidth") {
            obj.setWidth(historyRecord.column, historyRecord.oldValue);
          } else if (historyRecord.action == "setHeight") {
            obj.setHeight(historyRecord.row, historyRecord.oldValue);
          } else if (historyRecord.action == "setHeader") {
            obj.setHeader(historyRecord.column, historyRecord.oldValue);
          } else if (historyRecord.action == "setComments") {
            obj.setComments(historyRecord.column, historyRecord.oldValue[0], historyRecord.oldValue[1]);
          } else if (historyRecord.action == "orderBy") {
            var rows = [];
            for (var j2 = 0; j2 < historyRecord.rows.length; j2++) {
              rows[historyRecord.rows[j2]] = j2;
            }
            obj.updateOrderArrow(historyRecord.column, historyRecord.order ? 0 : 1);
            obj.updateOrder(rows);
          } else if (historyRecord.action == "setValue") {
            for (var i2 = 0; i2 < historyRecord.records.length; i2++) {
              records.push({
                x: historyRecord.records[i2].x,
                y: historyRecord.records[i2].y,
                newValue: historyRecord.records[i2].oldValue
              });
              if (historyRecord.oldStyle) {
                obj.resetStyle(historyRecord.oldStyle);
              }
            }
            obj.setValue(records);
            if (historyRecord.selection) {
              obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
            }
          }
        }
        obj.ignoreEvents = ignoreEvents;
        obj.ignoreHistory = ignoreHistory;
        obj.dispatch("onundo", el, historyRecord);
      };
      obj.redo = function() {
        var ignoreEvents = obj.ignoreEvents ? true : false;
        var ignoreHistory = obj.ignoreHistory ? true : false;
        obj.ignoreEvents = true;
        obj.ignoreHistory = true;
        if (obj.historyIndex < obj.history.length - 1) {
          var historyRecord = obj.history[++obj.historyIndex];
          if (historyRecord.action == "insertRow") {
            obj.historyProcessRow(0, historyRecord);
          } else if (historyRecord.action == "deleteRow") {
            obj.historyProcessRow(1, historyRecord);
          } else if (historyRecord.action == "insertColumn") {
            obj.historyProcessColumn(0, historyRecord);
          } else if (historyRecord.action == "deleteColumn") {
            obj.historyProcessColumn(1, historyRecord);
          } else if (historyRecord.action == "moveRow") {
            obj.moveRow(historyRecord.oldValue, historyRecord.newValue);
          } else if (historyRecord.action == "moveColumn") {
            obj.moveColumn(historyRecord.oldValue, historyRecord.newValue);
          } else if (historyRecord.action == "setMerge") {
            obj.setMerge(historyRecord.column, historyRecord.colspan, historyRecord.rowspan, 1);
          } else if (historyRecord.action == "setStyle") {
            obj.setStyle(historyRecord.newValue, null, null, 1);
          } else if (historyRecord.action == "setWidth") {
            obj.setWidth(historyRecord.column, historyRecord.newValue);
          } else if (historyRecord.action == "setHeight") {
            obj.setHeight(historyRecord.row, historyRecord.newValue);
          } else if (historyRecord.action == "setHeader") {
            obj.setHeader(historyRecord.column, historyRecord.newValue);
          } else if (historyRecord.action == "setComments") {
            obj.setComments(historyRecord.column, historyRecord.newValue[0], historyRecord.newValue[1]);
          } else if (historyRecord.action == "orderBy") {
            obj.updateOrderArrow(historyRecord.column, historyRecord.order);
            obj.updateOrder(historyRecord.rows);
          } else if (historyRecord.action == "setValue") {
            obj.setValue(historyRecord.records);
            for (var i2 = 0; i2 < historyRecord.records.length; i2++) {
              if (historyRecord.oldStyle) {
                obj.resetStyle(historyRecord.newStyle);
              }
            }
            if (historyRecord.selection) {
              obj.updateSelectionFromCoords(historyRecord.selection[0], historyRecord.selection[1], historyRecord.selection[2], historyRecord.selection[3]);
            }
          }
        }
        obj.ignoreEvents = ignoreEvents;
        obj.ignoreHistory = ignoreHistory;
        obj.dispatch("onredo", el, historyRecord);
      };
      obj.getDropDownValue = function(column, key) {
        var value2 = [];
        if (obj.options.columns[column] && obj.options.columns[column].source) {
          var combo = [];
          var source = obj.options.columns[column].source;
          for (var i2 = 0; i2 < source.length; i2++) {
            if (typeof source[i2] == "object") {
              combo[source[i2].id] = source[i2].name;
            } else {
              combo[source[i2]] = source[i2];
            }
          }
          var keys2 = Array.isArray(key) ? key : ("" + key).split(";");
          for (var i2 = 0; i2 < keys2.length; i2++) {
            if (typeof keys2[i2] === "object") {
              value2.push(combo[keys2[i2].id]);
            } else {
              if (combo[keys2[i2]]) {
                value2.push(combo[keys2[i2]]);
              }
            }
          }
        } else {
          console.error("Invalid column");
        }
        return value2.length > 0 ? value2.join("; ") : "";
      };
      obj.parseCSV = function(str2, delimiter) {
        str2 = str2.replace(/\r?\n$|\r$|\n$/g, "");
        if (str2.charCodeAt(str2.length - 1) == 9) {
          str2 += "\0";
        }
        delimiter = delimiter || ",";
        var arr = [];
        var quote = false;
        for (var row = 0, col = 0, c2 = 0; c2 < str2.length; c2++) {
          var cc = str2[c2], nc = str2[c2 + 1];
          arr[row] = arr[row] || [];
          arr[row][col] = arr[row][col] || "";
          if (cc == '"' && quote && nc == '"') {
            arr[row][col] += cc;
            ++c2;
            continue;
          }
          if (cc == '"') {
            quote = !quote;
            continue;
          }
          if (cc == delimiter && !quote) {
            ++col;
            continue;
          }
          if (cc == "\r" && nc == "\n" && !quote) {
            ++row;
            col = 0;
            ++c2;
            continue;
          }
          if (cc == "\n" && !quote) {
            ++row;
            col = 0;
            continue;
          }
          if (cc == "\r" && !quote) {
            ++row;
            col = 0;
            continue;
          }
          arr[row][col] += cc;
        }
        return arr;
      };
      obj.hash = function(str2) {
        var hash2 = 0, i2, chr;
        if (str2.length === 0) {
          return hash2;
        } else {
          for (i2 = 0; i2 < str2.length; i2++) {
            chr = str2.charCodeAt(i2);
            hash2 = (hash2 << 5) - hash2 + chr;
            hash2 |= 0;
          }
        }
        return hash2;
      };
      obj.onafterchanges = function(el2, records) {
        obj.dispatch("onafterchanges", el2, records);
      };
      obj.destroy = function() {
        jexcel.destroy(el);
      };
      obj.init = function() {
        jexcel.current = obj;
        if (typeof jexcel.build == "function") {
          if (obj.options.root) {
            jexcel.build(obj.options.root);
          } else {
            jexcel.build(document);
            jexcel.build = null;
          }
        }
        el.setAttribute("tabindex", 1);
        el.addEventListener("focus", function(e) {
          if (jexcel.current && !obj.selectedCell) {
            obj.updateSelectionFromCoords(0, 0, 0, 0);
            obj.left();
          }
        });
        if (obj.options.csv) {
          if (obj.options.loadingSpin == true) {
            jSuites.loading.show();
          }
          jSuites.ajax({
            url: obj.options.csv,
            method: obj.options.method,
            data: obj.options.requestVariables,
            dataType: "text",
            success: function(result2) {
              var newData = obj.parseCSV(result2, obj.options.csvDelimiter);
              if (obj.options.csvHeaders == true && newData.length > 0) {
                var headers = newData.shift();
                for (var i2 = 0; i2 < headers.length; i2++) {
                  if (!obj.options.columns[i2]) {
                    obj.options.columns[i2] = { type: "text", align: obj.options.defaultColAlign, width: obj.options.defaultColWidth };
                  }
                  if (typeof obj.options.columns[i2].title === "undefined") {
                    obj.options.columns[i2].title = headers[i2];
                  }
                }
              }
              obj.options.data = newData;
              obj.prepareTable();
              if (obj.options.loadingSpin == true) {
                jSuites.loading.hide();
              }
            }
          });
        } else if (obj.options.url) {
          if (obj.options.loadingSpin == true) {
            jSuites.loading.show();
          }
          jSuites.ajax({
            url: obj.options.url,
            method: obj.options.method,
            data: obj.options.requestVariables,
            dataType: "json",
            success: function(result2) {
              obj.options.data = result2.data ? result2.data : result2;
              obj.prepareTable();
              if (obj.options.loadingSpin == true) {
                jSuites.loading.hide();
              }
            }
          });
        } else {
          obj.prepareTable();
        }
      };
      if (options && options.contextMenu != null) {
        obj.options.contextMenu = options.contextMenu;
      } else {
        obj.options.contextMenu = function(el2, x2, y2, e) {
          var items = [];
          if (y2 == null) {
            if (obj.options.allowInsertColumn == true) {
              items.push({
                title: obj.options.text.insertANewColumnBefore,
                onclick: function() {
                  obj.insertColumn(1, parseInt(x2), 1);
                }
              });
            }
            if (obj.options.allowInsertColumn == true) {
              items.push({
                title: obj.options.text.insertANewColumnAfter,
                onclick: function() {
                  obj.insertColumn(1, parseInt(x2), 0);
                }
              });
            }
            if (obj.options.allowDeleteColumn == true) {
              items.push({
                title: obj.options.text.deleteSelectedColumns,
                onclick: function() {
                  obj.deleteColumn(obj.getSelectedColumns().length ? void 0 : parseInt(x2));
                }
              });
            }
            if (obj.options.allowRenameColumn == true) {
              items.push({
                title: obj.options.text.renameThisColumn,
                onclick: function() {
                  obj.setHeader(x2);
                }
              });
            }
            if (obj.options.columnSorting == true) {
              items.push({ type: "line" });
              items.push({
                title: obj.options.text.orderAscending,
                onclick: function() {
                  obj.orderBy(x2, 0);
                }
              });
              items.push({
                title: obj.options.text.orderDescending,
                onclick: function() {
                  obj.orderBy(x2, 1);
                }
              });
            }
          } else {
            if (obj.options.allowInsertRow == true) {
              items.push({
                title: obj.options.text.insertANewRowBefore,
                onclick: function() {
                  obj.insertRow(1, parseInt(y2), 1);
                }
              });
              items.push({
                title: obj.options.text.insertANewRowAfter,
                onclick: function() {
                  obj.insertRow(1, parseInt(y2));
                }
              });
            }
            if (obj.options.allowDeleteRow == true) {
              items.push({
                title: obj.options.text.deleteSelectedRows,
                onclick: function() {
                  obj.deleteRow(obj.getSelectedRows().length ? void 0 : parseInt(y2));
                }
              });
            }
            if (x2) {
              if (obj.options.allowComments == true) {
                items.push({ type: "line" });
                var title = obj.records[y2][x2].getAttribute("title") || "";
                items.push({
                  title: title ? obj.options.text.editComments : obj.options.text.addComments,
                  onclick: function() {
                    var comment = prompt(obj.options.text.comments, title);
                    if (comment) {
                      obj.setComments([x2, y2], comment);
                    }
                  }
                });
                if (title) {
                  items.push({
                    title: obj.options.text.clearComments,
                    onclick: function() {
                      obj.setComments([x2, y2], "");
                    }
                  });
                }
              }
            }
          }
          items.push({ type: "line" });
          items.push({
            title: obj.options.text.copy,
            shortcut: "Ctrl + C",
            onclick: function() {
              obj.copy(true);
            }
          });
          if (navigator && navigator.clipboard) {
            items.push({
              title: obj.options.text.paste,
              shortcut: "Ctrl + V",
              onclick: function() {
                if (obj.selectedCell) {
                  navigator.clipboard.readText().then(function(text2) {
                    if (text2) {
                      jexcel.current.paste(obj.selectedCell[0], obj.selectedCell[1], text2);
                    }
                  });
                }
              }
            });
          }
          if (obj.options.allowExport) {
            items.push({
              title: obj.options.text.saveAs,
              shortcut: "Ctrl + S",
              onclick: function() {
                obj.download();
              }
            });
          }
          if (obj.options.about) {
            items.push({
              title: obj.options.text.about,
              onclick: function() {
                if (obj.options.about === true) {
                  alert(Version().print());
                } else {
                  alert(obj.options.about);
                }
              }
            });
          }
          return items;
        };
      }
      obj.scrollControls = function(e) {
        obj.wheelControls();
        if (obj.options.freezeColumns > 0 && obj.content.scrollLeft != scrollLeft) {
          obj.updateFreezePosition();
        }
        if (obj.options.lazyLoading == true || obj.options.tableOverflow == true) {
          if (obj.edition && e.target.className.substr(0, 9) != "jdropdown") {
            obj.closeEditor(obj.edition[0], true);
          }
        }
      };
      obj.wheelControls = function(e) {
        if (obj.options.lazyLoading == true) {
          if (jexcel.timeControlLoading == null) {
            jexcel.timeControlLoading = setTimeout(function() {
              if (obj.content.scrollTop + obj.content.clientHeight >= obj.content.scrollHeight - 10) {
                if (obj.loadDown()) {
                  if (obj.content.scrollTop + obj.content.clientHeight > obj.content.scrollHeight - 10) {
                    obj.content.scrollTop = obj.content.scrollTop - obj.content.clientHeight;
                  }
                  obj.updateCornerPosition();
                }
              } else if (obj.content.scrollTop <= obj.content.clientHeight) {
                if (obj.loadUp()) {
                  if (obj.content.scrollTop < 10) {
                    obj.content.scrollTop = obj.content.scrollTop + obj.content.clientHeight;
                  }
                  obj.updateCornerPosition();
                }
              }
              jexcel.timeControlLoading = null;
            }, 100);
          }
        }
      };
      obj.getFreezeWidth = function() {
        var width = 0;
        if (obj.options.freezeColumns > 0) {
          for (var i2 = 0; i2 < obj.options.freezeColumns; i2++) {
            width += parseInt(obj.options.columns[i2].width);
          }
        }
        return width;
      };
      var scrollLeft = 0;
      obj.updateFreezePosition = function() {
        scrollLeft = obj.content.scrollLeft;
        var width = 0;
        if (scrollLeft > 50) {
          for (var i2 = 0; i2 < obj.options.freezeColumns; i2++) {
            if (i2 > 0) {
              if (obj.options.columns[i2 - 1].type !== "hidden") {
                width += parseInt(obj.options.columns[i2 - 1].width);
              }
            }
            obj.headers[i2].classList.add("jexcel_freezed");
            obj.headers[i2].style.left = width + "px";
            for (var j2 = 0; j2 < obj.rows.length; j2++) {
              if (obj.rows[j2] && obj.records[j2][i2]) {
                var shifted = scrollLeft + (i2 > 0 ? obj.records[j2][i2 - 1].style.width : 0) - 51 + "px";
                obj.records[j2][i2].classList.add("jexcel_freezed");
                obj.records[j2][i2].style.left = shifted;
              }
            }
          }
        } else {
          for (var i2 = 0; i2 < obj.options.freezeColumns; i2++) {
            obj.headers[i2].classList.remove("jexcel_freezed");
            obj.headers[i2].style.left = "";
            for (var j2 = 0; j2 < obj.rows.length; j2++) {
              if (obj.records[j2][i2]) {
                obj.records[j2][i2].classList.remove("jexcel_freezed");
                obj.records[j2][i2].style.left = "";
              }
            }
          }
        }
        obj.updateCornerPosition();
      };
      el.addEventListener("DOMMouseScroll", obj.wheelControls);
      el.addEventListener("mousewheel", obj.wheelControls);
      el.jexcel = obj;
      el.jspreadsheet = obj;
      obj.init();
      return obj;
    };
    jexcel.setDictionary = function(o) {
      jSuites.setDictionary(o);
    };
    jexcel.setExtensions = function(o) {
      var k2 = Object.keys(o);
      for (var i2 = 0; i2 < k2.length; i2++) {
        if (typeof o[k2[i2]] === "function") {
          jexcel[k2[i2]] = o[k2[i2]];
          if (jexcel.license && typeof o[k2[i2]].license == "function") {
            o[k2[i2]].license(jexcel.license);
          }
        }
      }
    };
    if (typeof formula !== "undefined") {
      jexcel.formula = formula;
    }
    jexcel.version = Version;
    jexcel.current = null;
    jexcel.timeControl = null;
    jexcel.timeControlLoading = null;
    jexcel.destroy = function(element2, destroyEventHandlers) {
      if (element2.jexcel) {
        var root2 = element2.jexcel.options.root ? element2.jexcel.options.root : document;
        element2.removeEventListener("DOMMouseScroll", element2.jexcel.scrollControls);
        element2.removeEventListener("mousewheel", element2.jexcel.scrollControls);
        element2.jexcel = null;
        element2.innerHTML = "";
        if (destroyEventHandlers) {
          root2.removeEventListener("mouseup", jexcel.mouseUpControls);
          root2.removeEventListener("mousedown", jexcel.mouseDownControls);
          root2.removeEventListener("mousemove", jexcel.mouseMoveControls);
          root2.removeEventListener("mouseover", jexcel.mouseOverControls);
          root2.removeEventListener("dblclick", jexcel.doubleClickControls);
          root2.removeEventListener("paste", jexcel.pasteControls);
          root2.removeEventListener("contextmenu", jexcel.contextMenuControls);
          root2.removeEventListener("touchstart", jexcel.touchStartControls);
          root2.removeEventListener("touchend", jexcel.touchEndControls);
          root2.removeEventListener("touchcancel", jexcel.touchEndControls);
          document.removeEventListener("keydown", jexcel.keyDownControls);
          jexcel = null;
        }
      }
    };
    jexcel.build = function(root2) {
      root2.addEventListener("mouseup", jexcel.mouseUpControls);
      root2.addEventListener("mousedown", jexcel.mouseDownControls);
      root2.addEventListener("mousemove", jexcel.mouseMoveControls);
      root2.addEventListener("mouseover", jexcel.mouseOverControls);
      root2.addEventListener("dblclick", jexcel.doubleClickControls);
      root2.addEventListener("paste", jexcel.pasteControls);
      root2.addEventListener("contextmenu", jexcel.contextMenuControls);
      root2.addEventListener("touchstart", jexcel.touchStartControls);
      root2.addEventListener("touchend", jexcel.touchEndControls);
      root2.addEventListener("touchcancel", jexcel.touchEndControls);
      root2.addEventListener("touchmove", jexcel.touchEndControls);
      document.addEventListener("keydown", jexcel.keyDownControls);
    };
    jexcel.keyDownControls = function(e) {
      if (jexcel.current) {
        if (jexcel.current.edition) {
          if (e.which == 27) {
            if (jexcel.current.edition) {
              jexcel.current.closeEditor(jexcel.current.edition[0], false);
            }
            e.preventDefault();
          } else if (e.which == 13) {
            if (jexcel.current.options.columns[jexcel.current.edition[2]].type == "calendar") {
              jexcel.current.closeEditor(jexcel.current.edition[0], true);
            } else if (jexcel.current.options.columns[jexcel.current.edition[2]].type == "dropdown" || jexcel.current.options.columns[jexcel.current.edition[2]].type == "autocomplete")
              ;
            else {
              if ((jexcel.current.options.wordWrap == true || jexcel.current.options.columns[jexcel.current.edition[2]].wordWrap == true || jexcel.current.options.data[jexcel.current.edition[3]][jexcel.current.edition[2]].length > 200) && e.altKey) {
                var editorTextarea = jexcel.current.edition[0].children[0];
                var editorValue = jexcel.current.edition[0].children[0].value;
                var editorIndexOf = editorTextarea.selectionStart;
                editorValue = editorValue.slice(0, editorIndexOf) + "\n" + editorValue.slice(editorIndexOf);
                editorTextarea.value = editorValue;
                editorTextarea.focus();
                editorTextarea.selectionStart = editorIndexOf + 1;
                editorTextarea.selectionEnd = editorIndexOf + 1;
              } else {
                jexcel.current.edition[0].children[0].blur();
              }
            }
          } else if (e.which == 9) {
            if (jexcel.current.options.columns[jexcel.current.edition[2]].type == "calendar") {
              jexcel.current.closeEditor(jexcel.current.edition[0], true);
            } else {
              jexcel.current.edition[0].children[0].blur();
            }
          }
        }
        if (!jexcel.current.edition && jexcel.current.selectedCell) {
          if (e.which == 37) {
            jexcel.current.left(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 39) {
            jexcel.current.right(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 38) {
            jexcel.current.up(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 40) {
            jexcel.current.down(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 36) {
            jexcel.current.first(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 35) {
            jexcel.current.last(e.shiftKey, e.ctrlKey);
            e.preventDefault();
          } else if (e.which == 32) {
            if (jexcel.current.options.editable == true) {
              jexcel.current.setCheckRadioValue();
            }
            e.preventDefault();
          } else if (e.which == 46) {
            if (jexcel.current.options.editable == true) {
              if (jexcel.current.selectedRow) {
                if (jexcel.current.options.allowDeleteRow == true) {
                  if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedRows)) {
                    jexcel.current.deleteRow();
                  }
                }
              } else if (jexcel.current.selectedHeader) {
                if (jexcel.current.options.allowDeleteColumn == true) {
                  if (confirm(jexcel.current.options.text.areYouSureToDeleteTheSelectedColumns)) {
                    jexcel.current.deleteColumn();
                  }
                }
              } else {
                jexcel.current.setValue(jexcel.current.highlighted, "");
              }
            }
          } else if (e.which == 13) {
            if (e.shiftKey) {
              jexcel.current.up();
            } else {
              if (jexcel.current.options.allowInsertRow == true) {
                if (jexcel.current.options.allowManualInsertRow == true) {
                  if (jexcel.current.selectedCell[1] == jexcel.current.options.data.length - 1) {
                    jexcel.current.insertRow();
                  }
                }
              }
              jexcel.current.down();
            }
            e.preventDefault();
          } else if (e.which == 9) {
            if (e.shiftKey) {
              jexcel.current.left();
            } else {
              if (jexcel.current.options.allowInsertColumn == true) {
                if (jexcel.current.options.allowManualInsertColumn == true) {
                  if (jexcel.current.selectedCell[0] == jexcel.current.options.data[0].length - 1) {
                    jexcel.current.insertColumn();
                  }
                }
              }
              jexcel.current.right();
            }
            e.preventDefault();
          } else {
            if ((e.ctrlKey || e.metaKey) && !e.shiftKey) {
              if (e.which == 65) {
                jexcel.current.selectAll();
                e.preventDefault();
              } else if (e.which == 83) {
                jexcel.current.download();
                e.preventDefault();
              } else if (e.which == 89) {
                jexcel.current.redo();
                e.preventDefault();
              } else if (e.which == 90) {
                jexcel.current.undo();
                e.preventDefault();
              } else if (e.which == 67) {
                jexcel.current.copy(true);
                e.preventDefault();
              } else if (e.which == 88) {
                if (jexcel.current.options.editable == true) {
                  jexcel.cutControls();
                } else {
                  jexcel.copyControls();
                }
                e.preventDefault();
              } else if (e.which == 86) {
                jexcel.pasteControls();
              }
            } else {
              if (jexcel.current.selectedCell) {
                if (jexcel.current.options.editable == true) {
                  var rowId = jexcel.current.selectedCell[1];
                  var columnId = jexcel.current.selectedCell[0];
                  if (jexcel.current.options.columns[columnId].type != "readonly") {
                    if (e.keyCode == 32) {
                      if (jexcel.current.options.columns[columnId].type == "checkbox" || jexcel.current.options.columns[columnId].type == "radio") {
                        e.preventDefault();
                      } else {
                        jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                      }
                    } else if (e.keyCode == 113) {
                      jexcel.current.openEditor(jexcel.current.records[rowId][columnId], false);
                    } else if (e.keyCode == 8 || e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 111 || e.keyCode >= 187 && e.keyCode <= 190 || (String.fromCharCode(e.keyCode) == e.key || String.fromCharCode(e.keyCode).toLowerCase() == e.key.toLowerCase()) && jexcel.validLetter(String.fromCharCode(e.keyCode))) {
                      jexcel.current.openEditor(jexcel.current.records[rowId][columnId], true);
                      if (jexcel.current.options.columns[columnId].type == "calendar") {
                        e.preventDefault();
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (e.target.classList.contains("jexcel_search")) {
            if (jexcel.timeControl) {
              clearTimeout(jexcel.timeControl);
            }
            jexcel.timeControl = setTimeout(function() {
              jexcel.current.search(e.target.value);
            }, 200);
          }
        }
      }
    };
    jexcel.isMouseAction = false;
    jexcel.mouseDownControls = function(e) {
      e = e || window.event;
      if (e.buttons) {
        var mouseButton = e.buttons;
      } else if (e.button) {
        var mouseButton = e.button;
      } else {
        var mouseButton = e.which;
      }
      var jexcelTable = jexcel.getElement(e.target);
      if (jexcelTable[0]) {
        if (jexcel.current != jexcelTable[0].jexcel) {
          if (jexcel.current) {
            if (jexcel.current.edition) {
              jexcel.current.closeEditor(jexcel.current.edition[0], true);
            }
            jexcel.current.resetSelection();
          }
          jexcel.current = jexcelTable[0].jexcel;
        }
      } else {
        if (jexcel.current) {
          if (jexcel.current.edition) {
            jexcel.current.closeEditor(jexcel.current.edition[0], true);
          }
          jexcel.current.resetSelection(true);
          jexcel.current = null;
        }
      }
      if (jexcel.current && mouseButton == 1) {
        if (e.target.classList.contains("jexcel_selectall")) {
          if (jexcel.current) {
            jexcel.current.selectAll();
          }
        } else if (e.target.classList.contains("jexcel_corner")) {
          if (jexcel.current.options.editable == true) {
            jexcel.current.selectedCorner = true;
          }
        } else {
          if (jexcelTable[1] == 1) {
            var columnId = e.target.getAttribute("data-x");
            if (columnId) {
              var info = e.target.getBoundingClientRect();
              if (jexcel.current.options.columnResize == true && info.width - e.offsetX < 6) {
                jexcel.current.resizing = {
                  mousePosition: e.pageX,
                  column: columnId,
                  width: info.width
                };
                jexcel.current.headers[columnId].classList.add("resizing");
                for (var j2 = 0; j2 < jexcel.current.records.length; j2++) {
                  if (jexcel.current.records[j2][columnId]) {
                    jexcel.current.records[j2][columnId].classList.add("resizing");
                  }
                }
              } else if (jexcel.current.options.columnDrag == true && info.height - e.offsetY < 6) {
                if (jexcel.current.isColMerged(columnId).length) {
                  console.error("Jspreadsheet: This column is part of a merged cell.");
                } else {
                  jexcel.current.resetSelection();
                  jexcel.current.dragging = {
                    element: e.target,
                    column: columnId,
                    destination: columnId
                  };
                  jexcel.current.headers[columnId].classList.add("dragging");
                  for (var j2 = 0; j2 < jexcel.current.records.length; j2++) {
                    if (jexcel.current.records[j2][columnId]) {
                      jexcel.current.records[j2][columnId].classList.add("dragging");
                    }
                  }
                }
              } else {
                if (jexcel.current.selectedHeader && (e.shiftKey || e.ctrlKey)) {
                  var o = jexcel.current.selectedHeader;
                  var d = columnId;
                } else {
                  if (jexcel.current.selectedHeader == columnId && jexcel.current.options.allowRenameColumn == true) {
                    jexcel.timeControl = setTimeout(function() {
                      jexcel.current.setHeader(columnId);
                    }, 800);
                  }
                  jexcel.current.selectedHeader = columnId;
                  var o = columnId;
                  var d = columnId;
                }
                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
              }
            } else {
              if (e.target.parentNode.classList.contains("jexcel_nested")) {
                if (e.target.getAttribute("data-column")) {
                  var column = e.target.getAttribute("data-column").split(",");
                  var c1 = parseInt(column[0]);
                  var c2 = parseInt(column[column.length - 1]);
                } else {
                  var c1 = 0;
                  var c2 = jexcel.current.options.columns.length - 1;
                }
                jexcel.current.updateSelectionFromCoords(c1, 0, c2, jexcel.current.options.data.length - 1);
              }
            }
          } else {
            jexcel.current.selectedHeader = false;
          }
          if (jexcelTable[1] == 2) {
            var rowId = e.target.getAttribute("data-y");
            if (e.target.classList.contains("jexcel_row")) {
              var info = e.target.getBoundingClientRect();
              if (jexcel.current.options.rowResize == true && info.height - e.offsetY < 6) {
                jexcel.current.resizing = {
                  element: e.target.parentNode,
                  mousePosition: e.pageY,
                  row: rowId,
                  height: info.height
                };
                e.target.parentNode.classList.add("resizing");
              } else if (jexcel.current.options.rowDrag == true && info.width - e.offsetX < 6) {
                if (jexcel.current.isRowMerged(rowId).length) {
                  console.error("Jspreadsheet: This row is part of a merged cell");
                } else if (jexcel.current.options.search == true && jexcel.current.results) {
                  console.error("Jspreadsheet: Please clear your search before perform this action");
                } else {
                  jexcel.current.resetSelection();
                  jexcel.current.dragging = {
                    element: e.target.parentNode,
                    row: rowId,
                    destination: rowId
                  };
                  e.target.parentNode.classList.add("dragging");
                }
              } else {
                if (jexcel.current.selectedRow && (e.shiftKey || e.ctrlKey)) {
                  var o = jexcel.current.selectedRow;
                  var d = rowId;
                } else {
                  jexcel.current.selectedRow = rowId;
                  var o = rowId;
                  var d = rowId;
                }
                jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
              }
            } else {
              if (e.target.classList.contains("jclose") && e.target.clientWidth - e.offsetX < 50 && e.offsetY < 50) {
                jexcel.current.closeEditor(jexcel.current.edition[0], true);
              } else {
                var getCellCoords = function(element2) {
                  var x2 = element2.getAttribute("data-x");
                  var y2 = element2.getAttribute("data-y");
                  if (x2 && y2) {
                    return [x2, y2];
                  } else {
                    if (element2.parentNode) {
                      return getCellCoords(element2.parentNode);
                    }
                  }
                };
                var position2 = getCellCoords(e.target);
                if (position2) {
                  var columnId = position2[0];
                  var rowId = position2[1];
                  if (jexcel.current.edition) {
                    if (jexcel.current.edition[2] != columnId || jexcel.current.edition[3] != rowId) {
                      jexcel.current.closeEditor(jexcel.current.edition[0], true);
                    }
                  }
                  if (!jexcel.current.edition) {
                    if (e.shiftKey) {
                      jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                    } else {
                      jexcel.current.updateSelectionFromCoords(columnId, rowId);
                    }
                  }
                  jexcel.current.selectedHeader = null;
                  jexcel.current.selectedRow = null;
                }
              }
            }
          } else {
            jexcel.current.selectedRow = false;
          }
          if (e.target.classList.contains("jexcel_page")) {
            if (e.target.innerText == "<") {
              jexcel.current.page(0);
            } else if (e.target.innerText == ">") {
              jexcel.current.page(e.target.getAttribute("title") - 1);
            } else {
              jexcel.current.page(e.target.innerText - 1);
            }
          }
        }
        if (jexcel.current.edition) {
          jexcel.isMouseAction = false;
        } else {
          jexcel.isMouseAction = true;
        }
      } else {
        jexcel.isMouseAction = false;
      }
    };
    jexcel.mouseUpControls = function(e) {
      if (jexcel.current) {
        if (jexcel.current.resizing) {
          if (jexcel.current.resizing.column) {
            var newWidth = jexcel.current.colgroup[jexcel.current.resizing.column].getAttribute("width");
            var columns = jexcel.current.getSelectedColumns();
            if (columns.length > 1) {
              var currentWidth = [];
              for (var i2 = 0; i2 < columns.length; i2++) {
                currentWidth.push(parseInt(jexcel.current.colgroup[columns[i2]].getAttribute("width")));
              }
              var index2 = columns.indexOf(parseInt(jexcel.current.resizing.column));
              currentWidth[index2] = jexcel.current.resizing.width;
              jexcel.current.setWidth(columns, newWidth, currentWidth);
            } else {
              jexcel.current.setWidth(jexcel.current.resizing.column, newWidth, jexcel.current.resizing.width);
            }
            jexcel.current.headers[jexcel.current.resizing.column].classList.remove("resizing");
            for (var j2 = 0; j2 < jexcel.current.records.length; j2++) {
              if (jexcel.current.records[j2][jexcel.current.resizing.column]) {
                jexcel.current.records[j2][jexcel.current.resizing.column].classList.remove("resizing");
              }
            }
          } else {
            jexcel.current.rows[jexcel.current.resizing.row].children[0].classList.remove("resizing");
            var newHeight = jexcel.current.rows[jexcel.current.resizing.row].getAttribute("height");
            jexcel.current.setHeight(jexcel.current.resizing.row, newHeight, jexcel.current.resizing.height);
            jexcel.current.resizing.element.classList.remove("resizing");
          }
          jexcel.current.resizing = null;
        } else if (jexcel.current.dragging) {
          if (jexcel.current.dragging) {
            if (jexcel.current.dragging.column) {
              var columnId = e.target.getAttribute("data-x");
              jexcel.current.headers[jexcel.current.dragging.column].classList.remove("dragging");
              for (var j2 = 0; j2 < jexcel.current.rows.length; j2++) {
                if (jexcel.current.records[j2][jexcel.current.dragging.column]) {
                  jexcel.current.records[j2][jexcel.current.dragging.column].classList.remove("dragging");
                }
              }
              for (var i2 = 0; i2 < jexcel.current.headers.length; i2++) {
                jexcel.current.headers[i2].classList.remove("dragging-left");
                jexcel.current.headers[i2].classList.remove("dragging-right");
              }
              if (columnId) {
                if (jexcel.current.dragging.column != jexcel.current.dragging.destination) {
                  jexcel.current.moveColumn(jexcel.current.dragging.column, jexcel.current.dragging.destination);
                }
              }
            } else {
              if (jexcel.current.dragging.element.nextSibling) {
                var position2 = parseInt(jexcel.current.dragging.element.nextSibling.getAttribute("data-y"));
                if (jexcel.current.dragging.row < position2) {
                  position2 -= 1;
                }
              } else {
                var position2 = parseInt(jexcel.current.dragging.element.previousSibling.getAttribute("data-y"));
              }
              if (jexcel.current.dragging.row != jexcel.current.dragging.destination) {
                jexcel.current.moveRow(jexcel.current.dragging.row, position2, true);
              }
              jexcel.current.dragging.element.classList.remove("dragging");
            }
            jexcel.current.dragging = null;
          }
        } else {
          if (jexcel.current.selectedCorner) {
            jexcel.current.selectedCorner = false;
            if (jexcel.current.selection.length > 0) {
              jexcel.current.copyData(jexcel.current.selection[0], jexcel.current.selection[jexcel.current.selection.length - 1]);
              jexcel.current.removeCopySelection();
            }
          }
        }
      }
      if (jexcel.timeControl) {
        clearTimeout(jexcel.timeControl);
        jexcel.timeControl = null;
      }
      jexcel.isMouseAction = false;
    };
    jexcel.mouseMoveControls = function(e) {
      e = e || window.event;
      if (e.buttons) {
        var mouseButton = e.buttons;
      } else if (e.button) {
        var mouseButton = e.button;
      } else {
        var mouseButton = e.which;
      }
      if (!mouseButton) {
        jexcel.isMouseAction = false;
      }
      if (jexcel.current) {
        if (jexcel.isMouseAction == true) {
          if (jexcel.current.resizing) {
            if (jexcel.current.resizing.column) {
              var width = e.pageX - jexcel.current.resizing.mousePosition;
              if (jexcel.current.resizing.width + width > 0) {
                var tempWidth = jexcel.current.resizing.width + width;
                jexcel.current.colgroup[jexcel.current.resizing.column].setAttribute("width", tempWidth);
                jexcel.current.updateCornerPosition();
              }
            } else {
              var height = e.pageY - jexcel.current.resizing.mousePosition;
              if (jexcel.current.resizing.height + height > 0) {
                var tempHeight = jexcel.current.resizing.height + height;
                jexcel.current.rows[jexcel.current.resizing.row].setAttribute("height", tempHeight);
                jexcel.current.updateCornerPosition();
              }
            }
          } else if (jexcel.current.dragging) {
            if (jexcel.current.dragging.column) {
              var columnId = e.target.getAttribute("data-x");
              if (columnId) {
                if (jexcel.current.isColMerged(columnId).length) {
                  console.error("Jspreadsheet: This column is part of a merged cell.");
                } else {
                  for (var i2 = 0; i2 < jexcel.current.headers.length; i2++) {
                    jexcel.current.headers[i2].classList.remove("dragging-left");
                    jexcel.current.headers[i2].classList.remove("dragging-right");
                  }
                  if (jexcel.current.dragging.column == columnId) {
                    jexcel.current.dragging.destination = parseInt(columnId);
                  } else {
                    if (e.target.clientWidth / 2 > e.offsetX) {
                      if (jexcel.current.dragging.column < columnId) {
                        jexcel.current.dragging.destination = parseInt(columnId) - 1;
                      } else {
                        jexcel.current.dragging.destination = parseInt(columnId);
                      }
                      jexcel.current.headers[columnId].classList.add("dragging-left");
                    } else {
                      if (jexcel.current.dragging.column < columnId) {
                        jexcel.current.dragging.destination = parseInt(columnId);
                      } else {
                        jexcel.current.dragging.destination = parseInt(columnId) + 1;
                      }
                      jexcel.current.headers[columnId].classList.add("dragging-right");
                    }
                  }
                }
              }
            } else {
              var rowId = e.target.getAttribute("data-y");
              if (rowId) {
                if (jexcel.current.isRowMerged(rowId).length) {
                  console.error("Jspreadsheet: This row is part of a merged cell.");
                } else {
                  var target = e.target.clientHeight / 2 > e.offsetY ? e.target.parentNode.nextSibling : e.target.parentNode;
                  if (jexcel.current.dragging.element != target) {
                    e.target.parentNode.parentNode.insertBefore(jexcel.current.dragging.element, target);
                    jexcel.current.dragging.destination = Array.prototype.indexOf.call(jexcel.current.dragging.element.parentNode.children, jexcel.current.dragging.element);
                  }
                }
              }
            }
          }
        } else {
          var x2 = e.target.getAttribute("data-x");
          var y2 = e.target.getAttribute("data-y");
          var rect = e.target.getBoundingClientRect();
          if (jexcel.current.cursor) {
            jexcel.current.cursor.style.cursor = "";
            jexcel.current.cursor = null;
          }
          if (e.target.parentNode.parentNode && e.target.parentNode.parentNode.className) {
            if (e.target.parentNode.parentNode.classList.contains("resizable")) {
              if (e.target && x2 && !y2 && rect.width - (e.clientX - rect.left) < 6) {
                jexcel.current.cursor = e.target;
                jexcel.current.cursor.style.cursor = "col-resize";
              } else if (e.target && !x2 && y2 && rect.height - (e.clientY - rect.top) < 6) {
                jexcel.current.cursor = e.target;
                jexcel.current.cursor.style.cursor = "row-resize";
              }
            }
            if (e.target.parentNode.parentNode.classList.contains("draggable")) {
              if (e.target && !x2 && y2 && rect.width - (e.clientX - rect.left) < 6) {
                jexcel.current.cursor = e.target;
                jexcel.current.cursor.style.cursor = "move";
              } else if (e.target && x2 && !y2 && rect.height - (e.clientY - rect.top) < 6) {
                jexcel.current.cursor = e.target;
                jexcel.current.cursor.style.cursor = "move";
              }
            }
          }
        }
      }
    };
    jexcel.mouseOverControls = function(e) {
      e = e || window.event;
      if (e.buttons) {
        var mouseButton = e.buttons;
      } else if (e.button) {
        var mouseButton = e.button;
      } else {
        var mouseButton = e.which;
      }
      if (!mouseButton) {
        jexcel.isMouseAction = false;
      }
      if (jexcel.current && jexcel.isMouseAction == true) {
        var jexcelTable = jexcel.getElement(e.target);
        if (jexcelTable[0]) {
          if (jexcel.current != jexcelTable[0].jexcel) {
            if (jexcel.current) {
              return false;
            }
          }
          var columnId = e.target.getAttribute("data-x");
          var rowId = e.target.getAttribute("data-y");
          if (jexcel.current.resizing || jexcel.current.dragging)
            ;
          else {
            if (jexcelTable[1] == 1) {
              if (jexcel.current.selectedHeader) {
                var columnId = e.target.getAttribute("data-x");
                var o = jexcel.current.selectedHeader;
                var d = columnId;
                jexcel.current.updateSelectionFromCoords(o, 0, d, jexcel.current.options.data.length - 1);
              }
            }
            if (jexcelTable[1] == 2) {
              if (e.target.classList.contains("jexcel_row")) {
                if (jexcel.current.selectedRow) {
                  var o = jexcel.current.selectedRow;
                  var d = rowId;
                  jexcel.current.updateSelectionFromCoords(0, o, jexcel.current.options.data[0].length - 1, d);
                }
              } else {
                if (!jexcel.current.edition) {
                  if (columnId && rowId) {
                    if (jexcel.current.selectedCorner) {
                      jexcel.current.updateCopySelection(columnId, rowId);
                    } else {
                      if (jexcel.current.selectedCell) {
                        jexcel.current.updateSelectionFromCoords(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], columnId, rowId);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (jexcel.timeControl) {
        clearTimeout(jexcel.timeControl);
        jexcel.timeControl = null;
      }
    };
    jexcel.doubleClickControls = function(e) {
      if (jexcel.current) {
        if (e.target.classList.contains("jexcel_corner")) {
          if (jexcel.current.highlighted.length > 0) {
            var x1 = jexcel.current.highlighted[0].getAttribute("data-x");
            var y1 = parseInt(jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute("data-y")) + 1;
            var x2 = jexcel.current.highlighted[jexcel.current.highlighted.length - 1].getAttribute("data-x");
            var y2 = jexcel.current.records.length - 1;
            jexcel.current.copyData(jexcel.current.records[y1][x1], jexcel.current.records[y2][x2]);
          }
        } else if (e.target.classList.contains("jexcel_column_filter")) {
          var columnId = e.target.getAttribute("data-x");
          jexcel.current.openFilter(columnId);
        } else {
          var jexcelTable = jexcel.getElement(e.target);
          if (jexcelTable[1] == 1 && jexcel.current.options.columnSorting == true) {
            var columnId = e.target.getAttribute("data-x");
            if (columnId) {
              jexcel.current.orderBy(columnId);
            }
          }
          if (jexcelTable[1] == 2 && jexcel.current.options.editable == true) {
            if (!jexcel.current.edition) {
              var getCellCoords = function(element2) {
                if (element2.parentNode) {
                  var x3 = element2.getAttribute("data-x");
                  var y3 = element2.getAttribute("data-y");
                  if (x3 && y3) {
                    return element2;
                  } else {
                    return getCellCoords(element2.parentNode);
                  }
                }
              };
              var cell = getCellCoords(e.target);
              if (cell && cell.classList.contains("highlight")) {
                jexcel.current.openEditor(cell);
              }
            }
          }
        }
      }
    };
    jexcel.copyControls = function(e) {
      if (jexcel.current && jexcel.copyControls.enabled) {
        if (!jexcel.current.edition) {
          jexcel.current.copy(true);
        }
      }
    };
    jexcel.cutControls = function(e) {
      if (jexcel.current) {
        if (!jexcel.current.edition) {
          jexcel.current.copy(true);
          if (jexcel.current.options.editable == true) {
            jexcel.current.setValue(jexcel.current.highlighted, "");
          }
        }
      }
    };
    jexcel.pasteControls = function(e) {
      if (jexcel.current && jexcel.current.selectedCell) {
        if (!jexcel.current.edition) {
          if (jexcel.current.options.editable == true) {
            if (e && e.clipboardData) {
              jexcel.current.paste(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], e.clipboardData.getData("text"));
              e.preventDefault();
            } else if (window.clipboardData) {
              jexcel.current.paste(jexcel.current.selectedCell[0], jexcel.current.selectedCell[1], window.clipboardData.getData("text"));
            }
          }
        }
      }
    };
    jexcel.contextMenuControls = function(e) {
      e = e || window.event;
      if ("buttons" in e) {
        e.buttons;
      } else {
        e.which || e.button;
      }
      if (jexcel.current) {
        if (jexcel.current.edition) {
          e.preventDefault();
        } else if (jexcel.current.options.contextMenu) {
          jexcel.current.contextMenu.contextmenu.close();
          if (jexcel.current) {
            var x2 = e.target.getAttribute("data-x");
            var y2 = e.target.getAttribute("data-y");
            if (x2 || y2) {
              if (x2 < parseInt(jexcel.current.selectedCell[0]) || x2 > parseInt(jexcel.current.selectedCell[2]) || y2 < parseInt(jexcel.current.selectedCell[1]) || y2 > parseInt(jexcel.current.selectedCell[3])) {
                jexcel.current.updateSelectionFromCoords(x2, y2, x2, y2);
              }
              var items = jexcel.current.options.contextMenu(jexcel.current, x2, y2, e);
              jexcel.current.contextMenu.contextmenu.open(e, items);
              e.preventDefault();
            }
          }
        }
      }
    };
    jexcel.touchStartControls = function(e) {
      var jexcelTable = jexcel.getElement(e.target);
      if (jexcelTable[0]) {
        if (jexcel.current != jexcelTable[0].jexcel) {
          if (jexcel.current) {
            jexcel.current.resetSelection();
          }
          jexcel.current = jexcelTable[0].jexcel;
        }
      } else {
        if (jexcel.current) {
          jexcel.current.resetSelection();
          jexcel.current = null;
        }
      }
      if (jexcel.current) {
        if (!jexcel.current.edition) {
          var columnId = e.target.getAttribute("data-x");
          var rowId = e.target.getAttribute("data-y");
          if (columnId && rowId) {
            jexcel.current.updateSelectionFromCoords(columnId, rowId);
            jexcel.timeControl = setTimeout(function() {
              if (jexcel.current.options.columns[columnId].type == "color") {
                jexcel.tmpElement = null;
              } else {
                jexcel.tmpElement = e.target;
              }
              jexcel.current.openEditor(e.target, false, e);
            }, 500);
          }
        }
      }
    };
    jexcel.touchEndControls = function(e) {
      if (jexcel.timeControl) {
        clearTimeout(jexcel.timeControl);
        jexcel.timeControl = null;
        if (jexcel.tmpElement && jexcel.tmpElement.children[0].tagName == "INPUT") {
          jexcel.tmpElement.children[0].focus();
        }
        jexcel.tmpElement = null;
      }
    };
    jexcel.tabs = function(tabs, result2) {
      var instances = [];
      if (!tabs.classList.contains("jexcel_tabs")) {
        tabs.innerHTML = "";
        tabs.classList.add("jexcel_tabs");
        tabs.jexcel = [];
        var div2 = document.createElement("div");
        var headers = tabs.appendChild(div2);
        var div2 = document.createElement("div");
        var content2 = tabs.appendChild(div2);
      } else {
        var headers = tabs.children[0];
        var content2 = tabs.children[1];
      }
      var spreadsheet = [];
      var link = [];
      for (var i2 = 0; i2 < result2.length; i2++) {
        spreadsheet[i2] = document.createElement("div");
        spreadsheet[i2].classList.add("jexcel_tab");
        var worksheet = jexcel(spreadsheet[i2], result2[i2]);
        content2.appendChild(spreadsheet[i2]);
        instances[i2] = tabs.jexcel.push(worksheet);
        link[i2] = document.createElement("div");
        link[i2].classList.add("jexcel_tab_link");
        link[i2].setAttribute("data-spreadsheet", tabs.jexcel.length - 1);
        link[i2].innerHTML = result2[i2].sheetName;
        link[i2].onclick = function() {
          for (var j3 = 0; j3 < headers.children.length; j3++) {
            headers.children[j3].classList.remove("selected");
            content2.children[j3].style.display = "none";
          }
          var i3 = this.getAttribute("data-spreadsheet");
          content2.children[i3].style.display = "block";
          headers.children[i3].classList.add("selected");
        };
        headers.appendChild(link[i2]);
      }
      for (var j2 = 0; j2 < headers.children.length; j2++) {
        headers.children[j2].classList.remove("selected");
        content2.children[j2].style.display = "none";
      }
      headers.children[headers.children.length - 1].classList.add("selected");
      content2.children[headers.children.length - 1].style.display = "block";
      return instances;
    };
    jexcel.createTabs = jexcel.tabs;
    jexcel.fromSpreadsheet = function(file, __callback) {
      var convert = function(workbook) {
        var spreadsheets = [];
        workbook.SheetNames.forEach(function(sheetName) {
          var spreadsheet = {};
          spreadsheet.rows = [];
          spreadsheet.columns = [];
          spreadsheet.data = [];
          spreadsheet.style = {};
          spreadsheet.sheetName = sheetName;
          var temp = workbook.Sheets[sheetName]["!cols"];
          if (temp && temp.length) {
            for (var i2 = 0; i2 < temp.length; i2++) {
              spreadsheet.columns[i2] = {};
              if (temp[i2] && temp[i2].wpx) {
                spreadsheet.columns[i2].width = temp[i2].wpx + "px";
              }
            }
          }
          var temp = workbook.Sheets[sheetName]["!rows"];
          if (temp && temp.length) {
            for (var i2 = 0; i2 < temp.length; i2++) {
              if (temp[i2] && temp[i2].hpx) {
                spreadsheet.rows[i2] = {};
                spreadsheet.rows[i2].height = temp[i2].hpx + "px";
              }
            }
          }
          var temp = workbook.Sheets[sheetName]["!merges"];
          if (temp && temp.length > 0) {
            spreadsheet.mergeCells = [];
            for (var i2 = 0; i2 < temp.length; i2++) {
              var x1 = temp[i2].s.c;
              var y1 = temp[i2].s.r;
              var x2 = temp[i2].e.c;
              var y2 = temp[i2].e.r;
              var key = jexcel.getColumnNameFromId([x1, y1]);
              spreadsheet.mergeCells[key] = [x2 - x1 + 1, y2 - y1 + 1];
            }
          }
          var max_x = 0;
          var max_y = 0;
          var temp = Object.keys(workbook.Sheets[sheetName]);
          for (var i2 = 0; i2 < temp.length; i2++) {
            if (temp[i2].substr(0, 1) != "!") {
              var cell = workbook.Sheets[sheetName][temp[i2]];
              var info = jexcel.getIdFromColumnName(temp[i2], true);
              if (!spreadsheet.data[info[1]]) {
                spreadsheet.data[info[1]] = [];
              }
              spreadsheet.data[info[1]][info[0]] = cell.f ? "=" + cell.f : cell.w;
              if (max_x < info[0]) {
                max_x = info[0];
              }
              if (max_y < info[1]) {
                max_y = info[1];
              }
              if (cell.style && Object.keys(cell.style).length > 0) {
                spreadsheet.style[temp[i2]] = cell.style;
              }
              if (cell.s && cell.s.fgColor) {
                if (spreadsheet.style[temp[i2]]) {
                  spreadsheet.style[temp[i2]] += ";";
                }
                spreadsheet.style[temp[i2]] += "background-color:#" + cell.s.fgColor.rgb;
              }
            }
          }
          var numColumns = spreadsheet.columns;
          for (var j2 = 0; j2 <= max_y; j2++) {
            for (var i2 = 0; i2 <= max_x; i2++) {
              if (!spreadsheet.data[j2]) {
                spreadsheet.data[j2] = [];
              }
              if (!spreadsheet.data[j2][i2]) {
                if (numColumns < i2) {
                  spreadsheet.data[j2][i2] = "";
                }
              }
            }
          }
          spreadsheets.push(spreadsheet);
        });
        return spreadsheets;
      };
      var oReq;
      oReq = new XMLHttpRequest();
      oReq.open("GET", file, true);
      if (typeof Uint8Array !== "undefined") {
        oReq.responseType = "arraybuffer";
        oReq.onload = function(e) {
          var arraybuffer = oReq.response;
          var data = new Uint8Array(arraybuffer);
          var wb = XLSX.read(data, { type: "array", cellFormula: true, cellStyles: true });
          __callback(convert(wb));
        };
      } else {
        oReq.setRequestHeader("Accept-Charset", "x-user-defined");
        oReq.onreadystatechange = function() {
          if (oReq.readyState == 4 && oReq.status == 200) {
            var ff = convertResponseBodyToText(oReq.responseBody);
            var wb = XLSX.read(ff, { type: "binary", cellFormula: true, cellStyles: true });
            __callback(convert(wb));
          }
        };
      }
      oReq.send();
    };
    jexcel.validLetter = function(text2) {
      var regex = /([\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC-\u0400-\u04FF']+)/g;
      return text2.match(regex) ? 1 : 0;
    };
    jexcel.injectArray = function(o, idx, arr) {
      return o.slice(0, idx).concat(arr).concat(o.slice(idx));
    };
    jexcel.getColumnName = function(i2) {
      var letter = "";
      if (i2 > 701) {
        letter += String.fromCharCode(64 + parseInt(i2 / 676));
        letter += String.fromCharCode(64 + parseInt(i2 % 676 / 26));
      } else if (i2 > 25) {
        letter += String.fromCharCode(64 + parseInt(i2 / 26));
      }
      letter += String.fromCharCode(65 + i2 % 26);
      return letter;
    };
    jexcel.getIdFromColumnName = function(id, arr) {
      var t = /^[a-zA-Z]+/.exec(id);
      if (t) {
        var code2 = 0;
        for (var i2 = 0; i2 < t[0].length; i2++) {
          code2 += parseInt(t[0].charCodeAt(i2) - 64) * Math.pow(26, t[0].length - 1 - i2);
        }
        code2--;
        if (code2 < 0) {
          code2 = 0;
        }
        var number2 = parseInt(/[0-9]+$/.exec(id));
        if (number2 > 0) {
          number2--;
        }
        if (arr == true) {
          id = [code2, number2];
        } else {
          id = code2 + "-" + number2;
        }
      }
      return id;
    };
    jexcel.getColumnNameFromId = function(cellId) {
      if (!Array.isArray(cellId)) {
        cellId = cellId.split("-");
      }
      return jexcel.getColumnName(parseInt(cellId[0])) + (parseInt(cellId[1]) + 1);
    };
    jexcel.getElement = function(element2) {
      var jexcelSection = 0;
      var jexcelElement = 0;
      function path2(element3) {
        if (element3.className) {
          if (element3.classList.contains("jexcel_container")) {
            jexcelElement = element3;
          }
        }
        if (element3.tagName == "THEAD") {
          jexcelSection = 1;
        } else if (element3.tagName == "TBODY") {
          jexcelSection = 2;
        }
        if (element3.parentNode) {
          if (!jexcelElement) {
            path2(element3.parentNode);
          }
        }
      }
      path2(element2);
      return [jexcelElement, jexcelSection];
    };
    jexcel.doubleDigitFormat = function(v) {
      v = "" + v;
      if (v.length == 1) {
        v = "0" + v;
      }
      return v;
    };
    jexcel.createFromTable = function(el2, options2) {
      if (el2.tagName != "TABLE") {
        console.log("Element is not a table");
      } else {
        if (!options2) {
          options2 = {};
        }
        options2.columns = [];
        options2.data = [];
        var colgroup = el2.querySelectorAll("colgroup > col");
        if (colgroup.length) {
          for (var i2 = 0; i2 < colgroup.length; i2++) {
            var width = colgroup[i2].style.width;
            if (!width) {
              var width = colgroup[i2].getAttribute("width");
            }
            if (width) {
              if (!options2.columns[i2]) {
                options2.columns[i2] = {};
              }
              options2.columns[i2].width = width;
            }
          }
        }
        var parseHeader = function(header) {
          var info = header.getBoundingClientRect();
          var width2 = info.width > 50 ? info.width : 50;
          if (!options2.columns[i2]) {
            options2.columns[i2] = {};
          }
          if (header.getAttribute("data-celltype")) {
            options2.columns[i2].type = header.getAttribute("data-celltype");
          } else {
            options2.columns[i2].type = "text";
          }
          options2.columns[i2].width = width2 + "px";
          options2.columns[i2].title = header.innerHTML;
          options2.columns[i2].align = header.style.textAlign || "center";
          if (info = header.getAttribute("name")) {
            options2.columns[i2].name = info;
          }
          if (info = header.getAttribute("id")) {
            options2.columns[i2].id = info;
          }
        };
        var nested = [];
        var headers = el2.querySelectorAll(":scope > thead > tr");
        if (headers.length) {
          for (var j2 = 0; j2 < headers.length - 1; j2++) {
            var cells = [];
            for (var i2 = 0; i2 < headers[j2].children.length; i2++) {
              var row = {
                title: headers[j2].children[i2].innerText,
                colspan: headers[j2].children[i2].getAttribute("colspan") || 1
              };
              cells.push(row);
            }
            nested.push(cells);
          }
          headers = headers[headers.length - 1].children;
          for (var i2 = 0; i2 < headers.length; i2++) {
            parseHeader(headers[i2]);
          }
        }
        var rowNumber = 0;
        var mergeCells = {};
        var rows = {};
        var style = {};
        var classes = {};
        var content2 = el2.querySelectorAll(":scope > tr, :scope > tbody > tr");
        for (var j2 = 0; j2 < content2.length; j2++) {
          options2.data[rowNumber] = [];
          if (options2.parseTableFirstRowAsHeader == true && !headers.length && j2 == 0) {
            for (var i2 = 0; i2 < content2[j2].children.length; i2++) {
              parseHeader(content2[j2].children[i2]);
            }
          } else {
            for (var i2 = 0; i2 < content2[j2].children.length; i2++) {
              var value2 = content2[j2].children[i2].getAttribute("data-formula");
              if (value2) {
                if (value2.substr(0, 1) != "=") {
                  value2 = "=" + value2;
                }
              } else {
                var value2 = content2[j2].children[i2].innerHTML;
              }
              options2.data[rowNumber].push(value2);
              var cellName = jexcel.getColumnNameFromId([i2, j2]);
              var tmp2 = content2[j2].children[i2].getAttribute("class");
              if (tmp2) {
                classes[cellName] = tmp2;
              }
              var mergedColspan = parseInt(content2[j2].children[i2].getAttribute("colspan")) || 0;
              var mergedRowspan = parseInt(content2[j2].children[i2].getAttribute("rowspan")) || 0;
              if (mergedColspan || mergedRowspan) {
                mergeCells[cellName] = [mergedColspan || 1, mergedRowspan || 1];
              }
              if (s = content2[j2].children[i2].style && content2[j2].children[i2].style.display == "none") {
                content2[j2].children[i2].style.display = "";
              }
              var s = content2[j2].children[i2].getAttribute("style");
              if (s) {
                style[cellName] = s;
              }
              if (content2[j2].children[i2].classList.contains("styleBold")) {
                if (style[cellName]) {
                  style[cellName] += "; font-weight:bold;";
                } else {
                  style[cellName] = "font-weight:bold;";
                }
              }
            }
            if (content2[j2].style && content2[j2].style.height) {
              rows[j2] = { height: content2[j2].style.height };
            }
            rowNumber++;
          }
        }
        if (Object.keys(nested).length > 0) {
          options2.nestedHeaders = nested;
        }
        if (Object.keys(style).length > 0) {
          options2.style = style;
        }
        if (Object.keys(mergeCells).length > 0) {
          options2.mergeCells = mergeCells;
        }
        if (Object.keys(rows).length > 0) {
          options2.rows = rows;
        }
        if (Object.keys(classes).length > 0) {
          options2.classes = classes;
        }
        var content2 = el2.querySelectorAll("tfoot tr");
        if (content2.length) {
          var footers = [];
          for (var j2 = 0; j2 < content2.length; j2++) {
            var footer = [];
            for (var i2 = 0; i2 < content2[j2].children.length; i2++) {
              footer.push(content2[j2].children[i2].innerText);
            }
            footers.push(footer);
          }
          if (Object.keys(footers).length > 0) {
            options2.footers = footers;
          }
        }
        if (options2.parseTableAutoCellType == true) {
          var pattern = [];
          for (var i2 = 0; i2 < options2.columns.length; i2++) {
            var test = true;
            var testCalendar = true;
            pattern[i2] = [];
            for (var j2 = 0; j2 < options2.data.length; j2++) {
              var value2 = options2.data[j2][i2];
              if (!pattern[i2][value2]) {
                pattern[i2][value2] = 0;
              }
              pattern[i2][value2]++;
              if (value2.length > 25) {
                test = false;
              }
              if (value2.length == 10) {
                if (!(value2.substr(4, 1) == "-" && value2.substr(7, 1) == "-")) {
                  testCalendar = false;
                }
              } else {
                testCalendar = false;
              }
            }
            var keys2 = Object.keys(pattern[i2]).length;
            if (testCalendar) {
              options2.columns[i2].type = "calendar";
            } else if (test == true && keys2 > 1 && keys2 <= parseInt(options2.data.length * 0.1)) {
              options2.columns[i2].type = "dropdown";
              options2.columns[i2].source = Object.keys(pattern[i2]);
            }
          }
        }
        return options2;
      }
    };
    jexcel.helpers = function() {
      var component = {};
      component.getCaretIndex = function(e) {
        if (this.config.root) {
          var d = this.config.root;
        } else {
          var d = window;
        }
        var pos = 0;
        var s = d.getSelection();
        if (s) {
          if (s.rangeCount !== 0) {
            var r = s.getRangeAt(0);
            var p2 = r.cloneRange();
            p2.selectNodeContents(e);
            p2.setEnd(r.endContainer, r.endOffset);
            pos = p2.toString().length;
          }
        }
        return pos;
      };
      component.invert = function(o) {
        var d = [];
        var k2 = Object.keys(o);
        for (var i2 = 0; i2 < k2.length; i2++) {
          d[o[k2[i2]]] = k2[i2];
        }
        return d;
      };
      component.getColumnName = function(i2) {
        var letter = "";
        if (i2 > 701) {
          letter += String.fromCharCode(64 + parseInt(i2 / 676));
          letter += String.fromCharCode(64 + parseInt(i2 % 676 / 26));
        } else if (i2 > 25) {
          letter += String.fromCharCode(64 + parseInt(i2 / 26));
        }
        letter += String.fromCharCode(65 + i2 % 26);
        return letter;
      };
      component.getColumnNameFromCoords = function(x2, y2) {
        return component.getColumnName(parseInt(x2)) + (parseInt(y2) + 1);
      };
      component.getCoordsFromColumnName = function(columnName) {
        var t = /^[a-zA-Z]+/.exec(columnName);
        if (t) {
          var code2 = 0;
          for (var i2 = 0; i2 < t[0].length; i2++) {
            code2 += parseInt(t[0].charCodeAt(i2) - 64) * Math.pow(26, t[0].length - 1 - i2);
          }
          code2--;
          if (code2 < 0) {
            code2 = 0;
          }
          var number2 = parseInt(/[0-9]+$/.exec(columnName)) || null;
          if (number2 > 0) {
            number2--;
          }
          return [code2, number2];
        }
      };
      component.createFromTable = function() {
      };
      component.injectArray = function(o, idx, arr) {
        return o.slice(0, idx).concat(arr).concat(o.slice(idx));
      };
      component.parseCSV = function(str2, delimiter) {
        delimiter = delimiter || ",";
        var col = 0;
        var row = 0;
        var data = [[]];
        var limit = 0;
        var flag = null;
        var inside = false;
        var closed = false;
        for (var i2 = 0; i2 < str2.length; i2++) {
          if (!data[row]) {
            data[row] = [];
          }
          if (!data[row][col]) {
            data[row][col] = "";
          }
          if (str2[i2] == "\r") {
            continue;
          }
          if ((str2[i2] == "\n" || str2[i2] == delimiter) && (inside == false || closed == true || !flag)) {
            flag = null;
            inside = false;
            closed = false;
            if (data[row][col][0] == '"') {
              var val = data[row][col].trim();
              if (val[val.length - 1] == '"') {
                data[row][col] = val.substr(1, val.length - 2);
              }
            }
            if (str2[i2] == "\n") {
              col = 0;
              row++;
            } else {
              col++;
              if (col > limit) {
                limit = col;
              }
            }
          } else {
            if (str2[i2] == '"') {
              inside = !inside;
            }
            if (flag === null) {
              flag = inside;
              if (flag == true) {
                continue;
              }
            } else if (flag === true && !closed) {
              if (str2[i2] == '"') {
                if (str2[i2 + 1] == '"') {
                  inside = true;
                  data[row][col] += str2[i2];
                  i2++;
                } else {
                  closed = true;
                }
                continue;
              }
            }
            data[row][col] += str2[i2];
          }
        }
        for (var j2 = 0; j2 < data.length; j2++) {
          for (var i2 = 0; i2 <= limit; i2++) {
            if (data[j2][i2] === void 0) {
              data[j2][i2] = "";
            }
          }
        }
        return data;
      };
      return component;
    }();
    if (typeof jQuery != "undefined") {
      (function($2) {
        $2.fn.jspreadsheet = $2.fn.jexcel = function(mixed) {
          var spreadsheetContainer = $2(this).get(0);
          if (!spreadsheetContainer.jexcel) {
            return jexcel($2(this).get(0), arguments[0]);
          } else {
            if (Array.isArray(spreadsheetContainer.jexcel)) {
              return spreadsheetContainer.jexcel[mixed][arguments[1]].apply(this, Array.prototype.slice.call(arguments, 2));
            } else {
              return spreadsheetContainer.jexcel[mixed].apply(this, Array.prototype.slice.call(arguments, 1));
            }
          }
        };
      })(jQuery);
    }
    return jexcel;
  });
})(dist$2);
var jspreadsheet$1 = dist$2.exports;
function mapTranslationsToSpreadsheet(translations) {
  let _columns = [
    { name: "messageID", title: "message ID", type: "text", width: 150 }
  ];
  let _data = [];
  const entries = Object.entries(translations).sort(([a], [b]) => {
    if (a === "messageID")
      return -3;
    if (a === "choose")
      return -2;
    if (a === "en")
      return -1;
    return a < b ? -1 : 1;
  });
  for (const [lang, data] of entries) {
    _columns = [
      ..._columns,
      {
        name: lang,
        title: lang,
        type: lang === "choose" ? "html" : "text",
        width: 150
      }
    ];
    for (const [messageID, value2] of Object.entries(data)) {
      const entry = _data.find((i2) => i2.messageID === messageID);
      if (entry) {
        entry[lang] = value2;
      } else {
        _data = [..._data, { messageID, [lang]: value2 }];
      }
    }
  }
  return {
    columns: _columns,
    data: _data
  };
}
function mapSpreadsheetToTranslations(instance2) {
  const _headers = instance2.getHeaders();
  const headers = _headers.split(",");
  let output = {};
  for (const header of headers.slice(1)) {
    output[header] = {};
  }
  for (const row of instance2.getData()) {
    const messageID = row[0];
    if (messageID) {
      for (const [index2, cellValue] of Object.entries(row.slice(1))) {
        const langCol = headers[parseInt(index2) + 1];
        if (langCol) {
          const langData = output[langCol];
          if (langData) {
            langData[messageID] = cellValue;
          }
        }
      }
    }
  }
  return output;
}
function add_css$c(target) {
  append_styles(target, "svelte-5ktcdu", ".translationsheet-container.svelte-5ktcdu{width:100%;height:100%}.spreadsheet-container.svelte-5ktcdu{overflow:scroll;height:100%;width:100%}.ok-button.svelte-5ktcdu{padding:0.5rem 1rem 0.5rem 1rem;float:right;margin-right:0.5rem}.button-container.svelte-5ktcdu{display:flex;justify-content:end;position:static}");
}
function create_fragment$x(ctx) {
  let div3;
  let div0;
  let fast_button0;
  let t1;
  let fast_button1;
  let t3;
  let div2;
  let div1;
  let initiate_action;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      fast_button0 = element("fast-button");
      fast_button0.textContent = "DOWNLOAD";
      t1 = space();
      fast_button1 = element("fast-button");
      fast_button1.textContent = "OK";
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      set_custom_element_data(fast_button0, "class", "download-button");
      set_custom_element_data(fast_button1, "class", "ok-button svelte-5ktcdu");
      attr(div0, "class", "button-container svelte-5ktcdu");
      attr(div1, "class", "spreadsheet");
      attr(div2, "class", "spreadsheet-container svelte-5ktcdu");
      attr(div3, "class", "translationsheet-container svelte-5ktcdu");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append$1(div3, div0);
      append$1(div0, fast_button0);
      append$1(div0, t1);
      append$1(div0, fast_button1);
      append$1(div3, t3);
      append$1(div3, div2);
      append$1(div2, div1);
      if (!mounted) {
        dispose = [
          listen(fast_button0, "click", ctx[8]),
          listen(fast_button1, "click", ctx[9]),
          action_destroyer(initiate_action = ctx[4].call(null, div1, ctx[0])),
          listen(div1, "keyup", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (initiate_action && is_function(initiate_action.update) && dirty & 1)
        initiate_action.update.call(null, ctx2[0]);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance_1($$self, $$props, $$invalidate) {
  let { chooseRow = false } = $$props;
  let { translations } = $$props;
  let changedTranslations = /* @__PURE__ */ new Set();
  const dispatch2 = createEventDispatcher();
  let data = [];
  let columns = [];
  let instance2;
  const eventHanlders = {
    onchange: handleCellChange,
    ondeleterow: handleChange,
    ondeletecolumn: handleChange,
    onpaste: handleChange,
    oninsertrow: handleChange,
    oninsertcolumn: handleChange,
    onfocus: handleChange,
    onblur: handleChange,
    oneditionstart: handleChange,
    oneditionend: handleChange
  };
  function initiate(target, columns2) {
    $$invalidate(1, instance2 = jspreadsheet$1(target, __spreadProps(__spreadValues({
      data,
      columns: [...columns2]
    }, eventHanlders), {
      csvFileName: "translations",
      includeHeadersOnDownload: true
    })));
    return {
      update(columns3) {
        instance2 && instance2.destroy();
        $$invalidate(1, instance2 = jspreadsheet$1(target, __spreadProps(__spreadValues({
          data,
          columns: [...columns3]
        }, eventHanlders), {
          csvFileName: "translations",
          includeHeadersOnDownload: true
        })));
      }
    };
  }
  function handleCellChange(_instance, cell, x2, y2, value2) {
    const MESSAGE_ID_INDEX = 1;
    const output = mapSpreadsheetToTranslations(instance2);
    if (chooseRow) {
      delete output["choose"];
    }
    Object.keys(output).length >= 1 && changedTranslations.add(Object.keys(output)[x2 - MESSAGE_ID_INDEX]);
    dispatch2("change", output);
  }
  function handleChange() {
    const output = mapSpreadsheetToTranslations(instance2);
    if (chooseRow) {
      delete output["choose"];
    }
    dispatch2("change", output);
  }
  const click_handler2 = () => instance2 && instance2.download();
  const click_handler_1 = () => dispatch2("ok", changedTranslations);
  $$self.$$set = ($$props2) => {
    if ("chooseRow" in $$props2)
      $$invalidate(6, chooseRow = $$props2.chooseRow);
    if ("translations" in $$props2)
      $$invalidate(7, translations = $$props2.translations);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      {
        const _translations = JSON.parse(JSON.stringify(translations));
        if (chooseRow) {
          const cols = Object.keys(Object.values(translations)[0]);
          _translations["choose"] = Object.fromEntries(cols.map((col) => [col, "<button>choose</button>"]));
        }
        const { data: _data, columns: _columns } = mapTranslationsToSpreadsheet(_translations);
        data = _data;
        $$invalidate(0, columns = _columns);
      }
    }
  };
  return [
    columns,
    instance2,
    changedTranslations,
    dispatch2,
    initiate,
    handleChange,
    chooseRow,
    translations,
    click_handler2,
    click_handler_1
  ];
}
class TranslationSheet extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance_1, create_fragment$x, safe_not_equal, { chooseRow: 6, translations: 7 }, add_css$c);
  }
}
function create_fragment$w(ctx) {
  let svg2;
  let g2;
  let g1;
  let g0;
  let path0;
  let path1;
  let path2;
  let path3;
  let g3;
  let g4;
  let g5;
  let g6;
  let g7;
  let g8;
  let g9;
  let g10;
  let g11;
  let g12;
  let g13;
  let g14;
  let g15;
  let g16;
  let g17;
  return {
    c() {
      svg2 = svg_element("svg");
      g2 = svg_element("g");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      g3 = svg_element("g");
      g4 = svg_element("g");
      g5 = svg_element("g");
      g6 = svg_element("g");
      g7 = svg_element("g");
      g8 = svg_element("g");
      g9 = svg_element("g");
      g10 = svg_element("g");
      g11 = svg_element("g");
      g12 = svg_element("g");
      g13 = svg_element("g");
      g14 = svg_element("g");
      g15 = svg_element("g");
      g16 = svg_element("g");
      g17 = svg_element("g");
      attr(path0, "d", "M45.432,35.049c-0.008,0-0.017,0-0.025,0c-2.809,0-5.451,1.095-7.446,3.085c-2.017,2.012-3.128,4.691-3.128,7.543\n				v159.365c0,5.844,4.773,10.61,10.641,10.625c24.738,0.059,66.184,5.215,94.776,35.136V84.023c0-1.981-0.506-3.842-1.461-5.382\n				C115.322,40.849,70.226,35.107,45.432,35.049z");
      attr(path1, "d", "M262.167,205.042V45.676c0-2.852-1.111-5.531-3.128-7.543c-1.995-1.99-4.639-3.085-7.445-3.085c-0.009,0-0.018,0-0.026,0\n				c-24.793,0.059-69.889,5.801-93.357,43.593c-0.955,1.54-1.46,3.401-1.46,5.382v166.779\n				c28.592-29.921,70.038-35.077,94.776-35.136C257.394,215.651,262.167,210.885,262.167,205.042z");
      attr(path2, "d", "M286.373,71.801h-7.706v133.241c0,14.921-12.157,27.088-27.101,27.125c-20.983,0.05-55.581,4.153-80.084,27.344\n				c42.378-10.376,87.052-3.631,112.512,2.171c3.179,0.724,6.464-0.024,9.011-2.054c2.538-2.025,3.994-5.052,3.994-8.301V82.427\n				C297,76.568,292.232,71.801,286.373,71.801z");
      attr(path3, "d", "M18.332,205.042V71.801h-7.706C4.768,71.801,0,76.568,0,82.427v168.897c0,3.25,1.456,6.276,3.994,8.301\n				c2.545,2.029,5.827,2.78,9.011,2.054c25.46-5.803,70.135-12.547,112.511-2.171c-24.502-23.19-59.1-27.292-80.083-27.342\n				C30.49,232.13,18.332,219.963,18.332,205.042z");
      attr(svg2, "version", "1.1");
      attr(svg2, "id", "Layer_1");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg2, "x", "0px");
      attr(svg2, "y", "0px");
      attr(svg2, "viewBox", "0 0 296.999 296.999");
      set_style(svg2, "enable-background", "new 0 0 296.999 296.999");
      set_style(svg2, "width", "1rem");
      set_style(svg2, "margin", "0 1rem");
      attr(svg2, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg2, anchor);
      append$1(svg2, g2);
      append$1(g2, g1);
      append$1(g1, g0);
      append$1(g0, path0);
      append$1(g0, path1);
      append$1(g0, path2);
      append$1(g0, path3);
      append$1(svg2, g3);
      append$1(svg2, g4);
      append$1(svg2, g5);
      append$1(svg2, g6);
      append$1(svg2, g7);
      append$1(svg2, g8);
      append$1(svg2, g9);
      append$1(svg2, g10);
      append$1(svg2, g11);
      append$1(svg2, g12);
      append$1(svg2, g13);
      append$1(svg2, g14);
      append$1(svg2, g15);
      append$1(svg2, g16);
      append$1(svg2, g17);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg2);
    }
  };
}
class OpenBookIcon extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, null, create_fragment$w, safe_not_equal, {});
  }
}
function messageIdToExpression(messageId) {
  return `$_(${messageId})`;
}
function expressionToMessageId(expression2) {
  return expression2.replace(/^\$_\(/, "").replace(/\)$/, "");
}
function create_else_block$4(ctx) {
  let fast_text_area;
  let fast_text_area_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      fast_text_area = element("fast-text-area");
      set_custom_element_data(fast_text_area, "appearance", "outline");
      set_custom_element_data(fast_text_area, "cols", "1000");
      set_custom_element_data(fast_text_area, "resize", "vertical");
      set_custom_element_data(fast_text_area, "value", fast_text_area_value_value = ctx[0].value || ctx[0].default || "");
    },
    m(target, anchor) {
      insert(target, fast_text_area, anchor);
      if (!mounted) {
        dispose = [
          listen(fast_text_area, "keypress", ctx[9]),
          listen(fast_text_area, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && fast_text_area_value_value !== (fast_text_area_value_value = ctx2[0].value || ctx2[0].default || "")) {
        set_custom_element_data(fast_text_area, "value", fast_text_area_value_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(fast_text_area);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$c(ctx) {
  let if_block_anchor;
  let if_block = ctx[2][ctx[3]] && create_if_block_1$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[2][ctx2[3]]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div2;
  let monacoEdit_action;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "monaco-container");
      set_style(div2, "height", "100%");
      set_style(div2, "min-height", "100px");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (!mounted) {
        dispose = action_destroyer(monacoEdit_action = ctx[7].call(null, div2, {
          value: ctx[0].messageId ? ctx[5].messageIdToExpression(ctx[0].messageId) : (ctx[0].value || ctx[0].default || "").toString(),
          language: "",
          onchange: ctx[8]
        }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (monacoEdit_action && is_function(monacoEdit_action.update) && dirty & 35)
        monacoEdit_action.update.call(null, {
          value: ctx2[0].messageId ? ctx2[5].messageIdToExpression(ctx2[0].messageId) : (ctx2[0].value || ctx2[0].default || "").toString(),
          language: "",
          onchange: ctx2[8]
        });
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$c;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { fields: fields22 } = $$props;
  let { field } = $$props;
  let { expanded: expanded2 } = $$props;
  let { index: index2 } = $$props;
  let { monaco = void 0 } = $$props;
  let { messageExpressions = {
    messageIdToExpression,
    expressionToMessageId
  } } = $$props;
  const dispatch2 = createEventDispatcher();
  function monacoEdit(target, props) {
    let editor = monaco.editor.create(target, {
      value: props.value,
      language: props.language,
      theme: "vs-dark",
      automaticLayout: true
    });
    editor.onDidChangeModelContent((e) => {
      props.onchange(editor.getValue());
    });
    return {
      update(props2) {
        if (editor.getValue() !== props2.value) {
          const pos = editor.getPosition();
          editor.setValue(props2.value);
          editor.setPosition(pos);
          props2.onchange(props2.value);
        }
        monaco.editor.setModelLanguage(editor.getModel(), props2.language);
      },
      destroy: () => {
        editor.dispose();
      }
    };
  }
  const monacoEdit_function = (value2) => {
    $$invalidate(0, field.value = value2, field);
    dispatch2("change", fields22);
  };
  const keypress_handler = (event2) => {
    if (event2.target) {
      $$invalidate(0, field.value = event2.target.value, field);
      dispatch2("keypress", fields22);
    }
  };
  const change_handler = (event2) => {
    if (event2.target) {
      $$invalidate(0, field.value = event2.target.value, field);
      dispatch2("change", fields22);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(1, fields22 = $$props2.fields);
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("expanded" in $$props2)
      $$invalidate(2, expanded2 = $$props2.expanded);
    if ("index" in $$props2)
      $$invalidate(3, index2 = $$props2.index);
    if ("monaco" in $$props2)
      $$invalidate(4, monaco = $$props2.monaco);
    if ("messageExpressions" in $$props2)
      $$invalidate(5, messageExpressions = $$props2.messageExpressions);
  };
  return [
    field,
    fields22,
    expanded2,
    index2,
    monaco,
    messageExpressions,
    dispatch2,
    monacoEdit,
    monacoEdit_function,
    keypress_handler,
    change_handler
  ];
}
class WidgetFieldExpression extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$v, create_fragment$v, safe_not_equal, {
      fields: 1,
      field: 0,
      expanded: 2,
      index: 3,
      monaco: 4,
      messageExpressions: 5
    });
  }
}
function create_fragment$u(ctx) {
  let div2;
  let span;
  let t1;
  let button;
  let t2_value = (ctx[1].messageId || "Select Message ID") + "";
  let t2;
  let t3;
  let style;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      span = element("span");
      span.textContent = "Message ID";
      t1 = space();
      button = element("button");
      t2 = text$1(t2_value);
      t3 = space();
      style = element("style");
      style.textContent = ".widget-field-translation {\n      padding: 2rem;\n      display: flex;\n      justify-content: center;\n      gap: 0.5rem;\n    }\n\n    .widget-field-translation button {\n      background: #f0f0f0;\n      border: none;\n      outline: none;\n      cursor: pointer;\n    }";
      attr(div2, "class", "widget-field-translation");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, span);
      append$1(div2, t1);
      append$1(div2, button);
      append$1(button, t2);
      append$1(div2, t3);
      append$1(div2, style);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1].messageId || "Select Message ID") + ""))
        set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let { field } = $$props;
  let { choosingMessageId } = $$props;
  const click_handler2 = () => $$invalidate(0, choosingMessageId = field);
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(1, field = $$props2.field);
    if ("choosingMessageId" in $$props2)
      $$invalidate(0, choosingMessageId = $$props2.choosingMessageId);
  };
  return [choosingMessageId, field, click_handler2];
}
class WidgetFieldTranslation extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$u, create_fragment$u, safe_not_equal, { field: 1, choosingMessageId: 0 });
  }
}
function create_if_block$b(ctx) {
  let if_block_anchor;
  let current;
  let if_block = typeof ctx[0].messageId === "string" && create_if_block_1$7(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (typeof ctx2[0].messageId === "string") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$7(ctx) {
  let fast_tabs;
  let fast_tab0;
  let t2;
  let fast_tab1;
  let openbookicon;
  let t3;
  let defaultTab_action;
  let t4;
  let fast_tab_panel0;
  let t5;
  let fast_tab_panel1;
  let widgetfieldtranslation;
  let updating_choosingMessageId;
  let updating_field;
  let current;
  let mounted;
  let dispose;
  openbookicon = new OpenBookIcon({});
  function widgetfieldtranslation_choosingMessageId_binding(value2) {
    ctx[11](value2);
  }
  function widgetfieldtranslation_field_binding(value2) {
    ctx[12](value2);
  }
  let widgetfieldtranslation_props = {};
  if (ctx[2] !== void 0) {
    widgetfieldtranslation_props.choosingMessageId = ctx[2];
  }
  if (ctx[0] !== void 0) {
    widgetfieldtranslation_props.field = ctx[0];
  }
  widgetfieldtranslation = new WidgetFieldTranslation({ props: widgetfieldtranslation_props });
  binding_callbacks.push(() => bind(widgetfieldtranslation, "choosingMessageId", widgetfieldtranslation_choosingMessageId_binding));
  binding_callbacks.push(() => bind(widgetfieldtranslation, "field", widgetfieldtranslation_field_binding));
  return {
    c() {
      fast_tabs = element("fast-tabs");
      fast_tab0 = element("fast-tab");
      fast_tab0.innerHTML = `<span class="icon">f(x)</span>
          Expression`;
      t2 = space();
      fast_tab1 = element("fast-tab");
      create_component(openbookicon.$$.fragment);
      t3 = text$1("\n          Translated Message");
      t4 = space();
      fast_tab_panel0 = element("fast-tab-panel");
      t5 = space();
      fast_tab_panel1 = element("fast-tab-panel");
      create_component(widgetfieldtranslation.$$.fragment);
      set_custom_element_data(fast_tab0, "slot", "tab");
      set_custom_element_data(fast_tab1, "slot", "tab");
      set_custom_element_data(fast_tab_panel0, "slot", "tabpanel");
      set_custom_element_data(fast_tab_panel1, "slot", "tabpanel");
    },
    m(target, anchor) {
      insert(target, fast_tabs, anchor);
      append$1(fast_tabs, fast_tab0);
      append$1(fast_tabs, t2);
      append$1(fast_tabs, fast_tab1);
      mount_component(openbookicon, fast_tab1, null);
      append$1(fast_tab1, t3);
      append$1(fast_tabs, t4);
      append$1(fast_tabs, fast_tab_panel0);
      append$1(fast_tabs, t5);
      append$1(fast_tabs, fast_tab_panel1);
      mount_component(widgetfieldtranslation, fast_tab_panel1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(fast_tab0, "click", ctx[9]),
          action_destroyer(defaultTab_action = defaultTab.call(null, fast_tab1, { field: ctx[0] })),
          listen(fast_tab1, "click", ctx[10]),
          listen(fast_tabs, "click", tabClicked),
          listen(fast_tabs, "pointerdown", tabClicked)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (defaultTab_action && is_function(defaultTab_action.update) && dirty & 1)
        defaultTab_action.update.call(null, { field: ctx2[0] });
      const widgetfieldtranslation_changes = {};
      if (!updating_choosingMessageId && dirty & 4) {
        updating_choosingMessageId = true;
        widgetfieldtranslation_changes.choosingMessageId = ctx2[2];
        add_flush_callback(() => updating_choosingMessageId = false);
      }
      if (!updating_field && dirty & 1) {
        updating_field = true;
        widgetfieldtranslation_changes.field = ctx2[0];
        add_flush_callback(() => updating_field = false);
      }
      widgetfieldtranslation.$set(widgetfieldtranslation_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(openbookicon.$$.fragment, local);
      transition_in(widgetfieldtranslation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(openbookicon.$$.fragment, local);
      transition_out(widgetfieldtranslation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_tabs);
      destroy_component(openbookicon);
      destroy_component(widgetfieldtranslation);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$t(ctx) {
  let fast_accordion_item;
  let t0;
  let div0;
  let widgetfieldexpression;
  let updating_monaco;
  let updating_field;
  let updating_fields;
  let t1;
  let div1;
  let t2_value = ctx[0].name + "";
  let t2;
  let t3;
  let t4_value = ctx[0].required ? "(required)" : "";
  let t4;
  let t5;
  let style;
  let fast_accordion_item_resize_listener;
  let current;
  let if_block = ctx[4][ctx[5]] && create_if_block$b(ctx);
  function widgetfieldexpression_monaco_binding(value2) {
    ctx[13](value2);
  }
  function widgetfieldexpression_field_binding(value2) {
    ctx[14](value2);
  }
  function widgetfieldexpression_fields_binding(value2) {
    ctx[15](value2);
  }
  let widgetfieldexpression_props = {
    messageExpressions: ctx[6],
    expanded: ctx[4],
    index: ctx[5]
  };
  if (ctx[3] !== void 0) {
    widgetfieldexpression_props.monaco = ctx[3];
  }
  if (ctx[0] !== void 0) {
    widgetfieldexpression_props.field = ctx[0];
  }
  if (ctx[1] !== void 0) {
    widgetfieldexpression_props.fields = ctx[1];
  }
  widgetfieldexpression = new WidgetFieldExpression({ props: widgetfieldexpression_props });
  binding_callbacks.push(() => bind(widgetfieldexpression, "monaco", widgetfieldexpression_monaco_binding));
  binding_callbacks.push(() => bind(widgetfieldexpression, "field", widgetfieldexpression_field_binding));
  binding_callbacks.push(() => bind(widgetfieldexpression, "fields", widgetfieldexpression_fields_binding));
  widgetfieldexpression.$on("change", ctx[16]);
  let fast_accordion_item_levels = [{ class: "widget-field" }, { slot: "item" }];
  let fast_accordion_item_data = {};
  for (let i2 = 0; i2 < fast_accordion_item_levels.length; i2 += 1) {
    fast_accordion_item_data = assign$1(fast_accordion_item_data, fast_accordion_item_levels[i2]);
  }
  return {
    c() {
      fast_accordion_item = element("fast-accordion-item");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      create_component(widgetfieldexpression.$$.fragment);
      t1 = space();
      div1 = element("div");
      t2 = text$1(t2_value);
      t3 = space();
      t4 = text$1(t4_value);
      t5 = space();
      style = element("style");
      style.textContent = ".widget-field .icon:not(.material-icons) {\n      font-family: monospace;\n      font-size: 0.8rem;\n    }\n    .widget-field .icon {\n      margin-right: 0.5rem;\n      font-size: 0.95rem;\n    }\n    .widget-field .expression-wrapper {\n      width: calc(100% - 0.5rem) !important;\n      min-height: 40px;\n    }\n    .widget-field .expression-wrapper.hidden {\n      position: absolute;\n      z-index: -200;\n      opacity: 0;\n      pointer-events: none;\n    }";
      attr(div0, "class", "expression-wrapper");
      set_style(div0, "max-width", ctx[8] - 8 + "px");
      toggle_class(div0, "hidden", !ctx[7]);
      attr(div1, "slot", "heading");
      set_attributes(fast_accordion_item, fast_accordion_item_data);
      add_render_callback(() => ctx[17].call(fast_accordion_item));
    },
    m(target, anchor) {
      insert(target, fast_accordion_item, anchor);
      if (if_block)
        if_block.m(fast_accordion_item, null);
      append$1(fast_accordion_item, t0);
      append$1(fast_accordion_item, div0);
      mount_component(widgetfieldexpression, div0, null);
      append$1(fast_accordion_item, t1);
      append$1(fast_accordion_item, div1);
      append$1(div1, t2);
      append$1(div1, t3);
      append$1(div1, t4);
      append$1(fast_accordion_item, t5);
      append$1(fast_accordion_item, style);
      fast_accordion_item_resize_listener = add_resize_listener(fast_accordion_item, ctx[17].bind(fast_accordion_item));
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[4][ctx2[5]]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 48) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fast_accordion_item, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const widgetfieldexpression_changes = {};
      if (dirty & 64)
        widgetfieldexpression_changes.messageExpressions = ctx2[6];
      if (dirty & 16)
        widgetfieldexpression_changes.expanded = ctx2[4];
      if (dirty & 32)
        widgetfieldexpression_changes.index = ctx2[5];
      if (!updating_monaco && dirty & 8) {
        updating_monaco = true;
        widgetfieldexpression_changes.monaco = ctx2[3];
        add_flush_callback(() => updating_monaco = false);
      }
      if (!updating_field && dirty & 1) {
        updating_field = true;
        widgetfieldexpression_changes.field = ctx2[0];
        add_flush_callback(() => updating_field = false);
      }
      if (!updating_fields && dirty & 2) {
        updating_fields = true;
        widgetfieldexpression_changes.fields = ctx2[1];
        add_flush_callback(() => updating_fields = false);
      }
      widgetfieldexpression.$set(widgetfieldexpression_changes);
      if (!current || dirty & 256) {
        set_style(div0, "max-width", ctx2[8] - 8 + "px");
      }
      if (dirty & 128) {
        toggle_class(div0, "hidden", !ctx2[7]);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].name + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0].required ? "(required)" : ""))
        set_data(t4, t4_value);
      set_attributes(fast_accordion_item, fast_accordion_item_data = get_spread_update(fast_accordion_item_levels, [{ class: "widget-field" }, { slot: "item" }]));
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(widgetfieldexpression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(widgetfieldexpression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_accordion_item);
      if (if_block)
        if_block.d();
      destroy_component(widgetfieldexpression);
      fast_accordion_item_resize_listener();
    }
  };
}
function getAccordionItem(node) {
  while (node && node.tagName !== "FAST-ACCORDION-ITEM" && node.tagName !== "BODY") {
    node = node.parentElement;
  }
  if (node.tagName === "FAST-ACCORDION-ITEM") {
    return node;
  }
}
function tabClicked(e) {
  let elm = getAccordionItem(e.target);
  if (elm) {
    elm["expanded"] = true;
    setTimeout(() => elm["expanded"] = true);
  }
}
function defaultTab(target, { field }) {
  const { messageId } = field;
  if (typeof messageId === "string" && messageId) {
    const accord = getAccordionItem(target);
    setTimeout(() => accord && accord["expanded"] && target.click(), 800);
  }
}
function instance$t($$self, $$props, $$invalidate) {
  let { field } = $$props;
  let { fields: fields22 } = $$props;
  let { expanded: expanded2 } = $$props;
  let { index: index2 } = $$props;
  let { choosingMessageId } = $$props;
  let { monaco = void 0 } = $$props;
  let { messageExpressions = {
    messageIdToExpression,
    expressionToMessageId
  } } = $$props;
  let editing = true;
  let clientWidth = 0;
  createEventDispatcher();
  const click_handler2 = () => $$invalidate(7, editing = true);
  const click_handler_1 = () => $$invalidate(7, editing = false);
  function widgetfieldtranslation_choosingMessageId_binding(value2) {
    choosingMessageId = value2;
    $$invalidate(2, choosingMessageId);
  }
  function widgetfieldtranslation_field_binding(value2) {
    field = value2;
    $$invalidate(0, field);
  }
  function widgetfieldexpression_monaco_binding(value2) {
    monaco = value2;
    $$invalidate(3, monaco);
  }
  function widgetfieldexpression_field_binding(value2) {
    field = value2;
    $$invalidate(0, field);
  }
  function widgetfieldexpression_fields_binding(value2) {
    fields22 = value2;
    $$invalidate(1, fields22);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function fast_accordion_item_elementresize_handler() {
    clientWidth = this.clientWidth;
    $$invalidate(8, clientWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
    if ("fields" in $$props2)
      $$invalidate(1, fields22 = $$props2.fields);
    if ("expanded" in $$props2)
      $$invalidate(4, expanded2 = $$props2.expanded);
    if ("index" in $$props2)
      $$invalidate(5, index2 = $$props2.index);
    if ("choosingMessageId" in $$props2)
      $$invalidate(2, choosingMessageId = $$props2.choosingMessageId);
    if ("monaco" in $$props2)
      $$invalidate(3, monaco = $$props2.monaco);
    if ("messageExpressions" in $$props2)
      $$invalidate(6, messageExpressions = $$props2.messageExpressions);
  };
  return [
    field,
    fields22,
    choosingMessageId,
    monaco,
    expanded2,
    index2,
    messageExpressions,
    editing,
    clientWidth,
    click_handler2,
    click_handler_1,
    widgetfieldtranslation_choosingMessageId_binding,
    widgetfieldtranslation_field_binding,
    widgetfieldexpression_monaco_binding,
    widgetfieldexpression_field_binding,
    widgetfieldexpression_fields_binding,
    change_handler,
    fast_accordion_item_elementresize_handler
  ];
}
class WidgetField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$t, create_fragment$t, safe_not_equal, {
      field: 0,
      fields: 1,
      expanded: 4,
      index: 5,
      choosingMessageId: 2,
      monaco: 3,
      messageExpressions: 6
    });
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  child_ctx[18] = i2;
  return child_ctx;
}
function create_each_block$3(ctx) {
  let widgetfield;
  let updating_choosingMessageId;
  let current;
  function widgetfield_choosingMessageId_binding(value2) {
    ctx[11](value2);
  }
  let widgetfield_props = {
    messageExpressions: ctx[3],
    field: ctx[16],
    fields: ctx[0],
    index: ctx[18],
    monaco: ctx[2],
    expanded: ctx[4]
  };
  if (ctx[7] !== void 0) {
    widgetfield_props.choosingMessageId = ctx[7];
  }
  widgetfield = new WidgetField({ props: widgetfield_props });
  binding_callbacks.push(() => bind(widgetfield, "choosingMessageId", widgetfield_choosingMessageId_binding));
  widgetfield.$on("change", ctx[12]);
  return {
    c() {
      create_component(widgetfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(widgetfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const widgetfield_changes = {};
      if (dirty & 8)
        widgetfield_changes.messageExpressions = ctx2[3];
      if (dirty & 1)
        widgetfield_changes.field = ctx2[16];
      if (dirty & 1)
        widgetfield_changes.fields = ctx2[0];
      if (dirty & 4)
        widgetfield_changes.monaco = ctx2[2];
      if (dirty & 16)
        widgetfield_changes.expanded = ctx2[4];
      if (!updating_choosingMessageId && dirty & 128) {
        updating_choosingMessageId = true;
        widgetfield_changes.choosingMessageId = ctx2[7];
        add_flush_callback(() => updating_choosingMessageId = false);
      }
      widgetfield.$set(widgetfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(widgetfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(widgetfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(widgetfield, detaching);
    }
  };
}
function create_if_block$a(ctx) {
  let div2;
  let translationsheet;
  let current;
  let mounted;
  let dispose;
  translationsheet = new TranslationSheet({
    props: {
      translations: ctx[1],
      chooseRow: true
    }
  });
  translationsheet.$on("change", ctx[14]);
  return {
    c() {
      div2 = element("div");
      create_component(translationsheet.$$.fragment);
      attr(div2, "class", "popup");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(translationsheet, div2, null);
      ctx[15](div2);
      current = true;
      if (!mounted) {
        dispose = listen(div2, "click", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const translationsheet_changes = {};
      if (dirty & 2)
        translationsheet_changes.translations = ctx2[1];
      translationsheet.$set(translationsheet_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(translationsheet.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(translationsheet.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(translationsheet);
      ctx[15](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$s(ctx) {
  let div2;
  let fast_design_system_provider;
  let fast_accordion;
  let t0;
  let t1;
  let style;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = ctx[7] && create_if_block$a(ctx);
  return {
    c() {
      div2 = element("div");
      fast_design_system_provider = element("fast-design-system-provider");
      fast_accordion = element("fast-accordion");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      style = element("style");
      style.textContent = ".widget-fields.fields {\n      --theme-bg: #222;\n      --theme-color: #f0f0f0;\n      background: var(--theme-bg);\n      color: var(--theme-color);\n      height: 100%;\n    }\n\n    .widget-fields .popup {\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      padding: 0;\n      z-index: 10000;\n      width: 500px;\n      min-width: max-content;\n      padding: 0.3rem;\n      padding-bottom: 0;\n      background: #f5f5f5;\n      color: black;\n      box-shadow: 0 0 0.5rem #777;\n    }";
      set_custom_element_data(fast_accordion, "expand-mode", "single");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      attr(div2, "class", "widget-fields fields");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, fast_design_system_provider);
      append$1(fast_design_system_provider, fast_accordion);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(fast_accordion, null);
      }
      ctx[13](fast_design_system_provider);
      append$1(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append$1(div2, t1);
      append$1(div2, style);
      current = true;
      if (!mounted) {
        dispose = listen(fast_design_system_provider, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 157) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(fast_accordion, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      ctx[13](null);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { monaco = void 0 } = $$props;
  let { fields: fields22 = [] } = $$props;
  let { translations = {} } = $$props;
  let { messageExpressions = {
    messageIdToExpression,
    expressionToMessageId
  } } = $$props;
  let expanded2 = [true];
  let wrapper;
  let popupElement;
  function checkExpand(event2) {
    const accordItems = Array.from(wrapper.querySelectorAll("fast-accordion-item"));
    setTimeout(async () => {
      $$invalidate(4, expanded2 = accordItems.map((elm) => elm["expanded"]));
    });
  }
  let choosingMessageId;
  function popupClicked(event2) {
    let element2 = event2.target;
    if (element2.tagName === "BUTTON") {
      element2 = element2.parentElement;
    }
    if (element2.querySelector("button")) {
      const dataY = element2.getAttribute("data-y");
      if (dataY) {
        if (choosingMessageId) {
          const messageIdCell = popupElement.querySelector(`td[data-x="0"][data-y="${dataY}"]`);
          $$invalidate(7, choosingMessageId["messageId"] = messageIdCell.innerText, choosingMessageId);
          dispatch2("change", fields22);
          $$invalidate(0, fields22);
        }
        $$invalidate(7, choosingMessageId = void 0);
      }
    }
  }
  function widgetfield_choosingMessageId_binding(value2) {
    choosingMessageId = value2;
    $$invalidate(7, choosingMessageId);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function fast_design_system_provider_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(5, wrapper);
    });
  }
  const change_handler_1 = (event2) => {
    if (JSON.stringify(translations) !== JSON.stringify(event2.detail)) {
      $$invalidate(1, translations = event2.detail);
      dispatch2("change", fields22);
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popupElement = $$value;
      $$invalidate(6, popupElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("monaco" in $$props2)
      $$invalidate(2, monaco = $$props2.monaco);
    if ("fields" in $$props2)
      $$invalidate(0, fields22 = $$props2.fields);
    if ("translations" in $$props2)
      $$invalidate(1, translations = $$props2.translations);
    if ("messageExpressions" in $$props2)
      $$invalidate(3, messageExpressions = $$props2.messageExpressions);
  };
  return [
    fields22,
    translations,
    monaco,
    messageExpressions,
    expanded2,
    wrapper,
    popupElement,
    choosingMessageId,
    dispatch2,
    checkExpand,
    popupClicked,
    widgetfield_choosingMessageId_binding,
    change_handler,
    fast_design_system_provider_binding,
    change_handler_1,
    div_binding
  ];
}
class WidgetFields extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$s, create_fragment$s, safe_not_equal, {
      monaco: 2,
      fields: 0,
      translations: 1,
      messageExpressions: 3
    });
  }
}
const fields = [
  {
    name: "appearance",
    title: "Appearance",
    description: "The text area's visual treatment",
    default: "outline",
    required: true,
    type: "string",
    values: [{ name: "outline" }, { name: "filled" }]
  },
  {
    name: "resize",
    title: "Resize",
    description: "The resize mode of the element",
    required: false,
    type: "string",
    values: [
      { name: "none" },
      { name: "both" },
      { name: "horizontal" },
      { name: "vertical" }
    ],
    default: "none"
  },
  {
    name: "autofocus",
    title: "Autofocus",
    description: "Determines if the element should receive document focus on page load",
    required: false,
    type: "boolean",
    default: false
  },
  {
    name: "cols",
    title: "Columns",
    description: "Sizes the element vertically by a number of character columns",
    required: false,
    type: "number",
    default: 20
  },
  {
    name: "form",
    description: "The form attribute",
    required: false,
    type: "string"
  },
  {
    name: "list",
    title: "List ID",
    description: "Allows associating a datalist to the component",
    required: false,
    type: "string",
    default: ""
  },
  {
    name: "maxlength",
    title: "Maximum length",
    description: "The maximum number of characters a user can enter",
    required: false,
    type: "number"
  },
  {
    name: "minlength",
    title: "Minimum length",
    description: "The minimum number of characters a user can enter",
    required: false,
    type: "number"
  },
  {
    name: "placeholder",
    title: "Placeholder",
    description: "Sets the placeholder value of the element, generally used to provide a hint to the user",
    required: false,
    type: "string"
  },
  {
    name: "rows",
    title: "Rows",
    description: "Sizes the element vertically by a number of character rows",
    required: false,
    type: "number"
  },
  {
    name: "spellcheck",
    title: "Spellcheck",
    description: "Controls whether or not to enable spell checking for the input field, or if the default spell checking configuration should be used",
    required: false,
    type: "boolean"
  },
  {
    name: "value",
    title: "Value",
    description: "The HTML value attribute of the text area",
    required: false,
    type: "string"
  },
  {
    name: "name",
    title: "Name",
    description: "This element's value will be surfaced during form submission under the provided name",
    type: "string",
    default: "",
    required: false
  },
  {
    name: "required",
    title: "Required",
    description: "Require the field to be completed prior to form submission",
    type: "boolean",
    default: false,
    required: false
  },
  {
    name: "disabled",
    title: "Disabled",
    description: "Sets the disabled state of the text area",
    type: "boolean",
    default: false,
    required: false
  },
  {
    name: "readonly",
    title: "Readonly",
    description: "When true, the control will be immutable by user interaction",
    type: "boolean",
    default: false,
    required: false
  }
];
function create_fragment$r(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: WidgetFields,
      props: {
        fields: ctx[0],
        messageExpressions: ctx[4]
      },
      events: {
        change: ctx[5],
        keypress: ctx[6],
        close: ctx[7]
      },
      x: ctx[1],
      y: ctx[2],
      title: ctx[3]
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 17)
        winbox_changes.props = {
          fields: ctx2[0],
          messageExpressions: ctx2[4]
        };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      if (dirty & 8)
        winbox_changes.title = ctx2[3];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { fields: fields$1 = fields } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { title = "Fields" } = $$props;
  let { messageExpressions = {
    messageIdToExpression,
    expressionToMessageId
  } } = $$props;
  const dispatch2 = createEventDispatcher();
  function change(e) {
    dispatch2("change", e);
  }
  function keypress(e) {
    dispatch2("keypress", e);
  }
  function close() {
    dispatch2("close", []);
  }
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(0, fields$1 = $$props2.fields);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("messageExpressions" in $$props2)
      $$invalidate(4, messageExpressions = $$props2.messageExpressions);
  };
  return [fields$1, x2, y2, title, messageExpressions, change, keypress, close];
}
class WidgetFieldsDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$r, create_fragment$r, safe_not_equal, {
      fields: 0,
      x: 1,
      y: 2,
      title: 3,
      messageExpressions: 4
    });
  }
}
const subscriber_queue = [];
function writable(value2, start = noop$1) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn2) {
    set2(fn2(value2));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2) || noop$1;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
function add_css$b(target) {
  append_styles(target, "svelte-qrzwy5", "fast-tree-item.svelte-qrzwy5.svelte-qrzwy5{--neutral-fill-stealth-selected:var(--selected-color, var(--theme-color));--neutral-fill-stealth-hover:var(--hover-color, var(--theme-color))}fast-tree-item.svelte-qrzwy5>span.svelte-qrzwy5{pointer-events:none}");
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_if_block_1$6(ctx) {
  let t0;
  let style;
  let current;
  let each_value = ctx[1].fields || [];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      style = element("style");
      style.textContent = ".fast-tree-item {\n      --neutral-fill-stealth-selected: var(\n        --selected-color,\n        var(--theme-color)\n      );\n      --neutral-fill-stealth-hover: var(--hover-color, var(--theme-color));\n    }\n    fast-tree-item > span {\n      pointer-events: none;\n    }";
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(target, anchor);
      }
      insert(target, t0, anchor);
      insert(target, style, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 239) {
        each_value = ctx2[1].fields || [];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(style);
    }
  };
}
function create_if_block$9(ctx) {
  let fast_design_system_provider;
  let pickfield;
  let current;
  pickfield = new PickField({
    props: {
      mode: ctx[2],
      context: [],
      type: ctx[4],
      onlyEntities: ctx[3]
    }
  });
  pickfield.$on("change", ctx[11]);
  pickfield.$on("dblclick", ctx[12]);
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      create_component(pickfield.$$.fragment);
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "width", "100%");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      mount_component(pickfield, fast_design_system_provider, null);
      current = true;
    },
    p(ctx2, dirty) {
      const pickfield_changes = {};
      if (dirty & 4)
        pickfield_changes.mode = ctx2[2];
      if (dirty & 16)
        pickfield_changes.type = ctx2[4];
      if (dirty & 8)
        pickfield_changes.onlyEntities = ctx2[3];
      pickfield.$set(pickfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pickfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      destroy_component(pickfield);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block(ctx) {
  let fast_tree_item;
  let promise2;
  let fast_tree_item_id_value;
  let fast_tree_item_expanded_value;
  let fast_tree_item_selected_value;
  let current;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block,
    value: 23,
    blocks: [, , ,]
  };
  handle_promise(promise2 = ctx[19].type.kind === "SCALAR" ? typesCollection.get(ctx[19].name) : typesCollection.get(ctx[19].type.name), info);
  function click_handler_1(...args2) {
    return ctx[16](ctx[22], ...args2);
  }
  return {
    c() {
      fast_tree_item = element("fast-tree-item");
      info.block.c();
      set_custom_element_data(fast_tree_item, "class", "fast-tree-item svelte-qrzwy5");
      set_custom_element_data(fast_tree_item, "id", fast_tree_item_id_value = ctx[22]);
      set_custom_element_data(fast_tree_item, "expanded", fast_tree_item_expanded_value = !!ctx[5][ctx[22]]);
      set_custom_element_data(fast_tree_item, "selected", fast_tree_item_selected_value = ctx[6].indexOf(ctx[22]) > -1);
    },
    m(target, anchor) {
      insert(target, fast_tree_item, anchor);
      info.block.m(fast_tree_item, info.anchor = null);
      info.mount = () => fast_tree_item;
      info.anchor = null;
      current = true;
      if (!mounted) {
        dispose = listen(fast_tree_item, "click", self$1(click_handler_1));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 2 && promise2 !== (promise2 = ctx[19].type.kind === "SCALAR" ? typesCollection.get(ctx[19].name) : typesCollection.get(ctx[19].type.name)) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (!current || dirty & 3 && fast_tree_item_id_value !== (fast_tree_item_id_value = ctx[22])) {
        set_custom_element_data(fast_tree_item, "id", fast_tree_item_id_value);
      }
      if (!current || dirty & 35 && fast_tree_item_expanded_value !== (fast_tree_item_expanded_value = !!ctx[5][ctx[22]])) {
        set_custom_element_data(fast_tree_item, "expanded", fast_tree_item_expanded_value);
      }
      if (!current || dirty & 67 && fast_tree_item_selected_value !== (fast_tree_item_selected_value = ctx[6].indexOf(ctx[22]) > -1)) {
        set_custom_element_data(fast_tree_item, "selected", fast_tree_item_selected_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block2 = info.blocks[i2];
        transition_out(block2);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_tree_item);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block_1(ctx) {
  let t0_value = fieldsCollection.set(ctx[22], ctx[19]) ? "" : "";
  let t0;
  let t1;
  let t2;
  let span;
  let t3_value = ctx[19].name + "";
  let t3;
  let span_style_value;
  let t4;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[0].length === 0 && create_if_block_5$2();
  function click_handler2(...args2) {
    return ctx[13](ctx[22], ...args2);
  }
  let if_block1 = (!ctx[3] || !ctx[0]) && create_if_block_2$4(ctx);
  return {
    c() {
      t0 = text$1(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      span = element("span");
      t3 = text$1(t3_value);
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(span, "style", span_style_value = (ctx[0].length === 0 ? "font-weight:bold;" : "font-style: italic;") + ";user-select:none;");
      attr(span, "class", "svelte-qrzwy5");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, span, anchor);
      append$1(span, t3);
      insert(target, t4, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", self$1(click_handler2));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 3) && t0_value !== (t0_value = fieldsCollection.set(ctx[22], ctx[19]) ? "" : ""))
        set_data(t0, t0_value);
      if (ctx[0].length === 0) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$2();
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx[19].name + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 1 && span_style_value !== (span_style_value = (ctx[0].length === 0 ? "font-weight:bold;" : "font-style: italic;") + ";user-select:none;")) {
        attr(span, "style", span_style_value);
      }
      if (!ctx[3] || !ctx[0]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & 9) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$4(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(span);
      if (detaching)
        detach(t4);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$2(ctx) {
  let svg2;
  let g1;
  let rect;
  let g0;
  let path0;
  let path1;
  return {
    c() {
      svg2 = svg_element("svg");
      g1 = svg_element("g");
      rect = svg_element("rect");
      g0 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(rect, "fill", "none");
      attr(rect, "height", "24");
      attr(rect, "width", "24");
      attr(path0, "d", "M19,5v14H5V5H19 M19,3H5C3.9,3,3,3.9,3,5v14c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V5C21,3.9,20.1,3,19,3L19,3z");
      attr(path1, "d", "M14,17H7v-2h7V17z M17,13H7v-2h10V13z M17,9H7V7h10V9z");
      attr(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg2, "enable-background", "new 0 0 24 24");
      attr(svg2, "width", "24px");
      attr(svg2, "height", "24px");
      attr(svg2, "viewBox", "0 0 24 24");
      attr(svg2, "fill", "currentColor");
      set_style(svg2, "margin-right", "0.4rem");
    },
    m(target, anchor) {
      insert(target, svg2, anchor);
      append$1(svg2, g1);
      append$1(g1, rect);
      append$1(g1, g0);
      append$1(g0, path0);
      append$1(g1, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg2);
    }
  };
}
function create_if_block_2$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$4, create_if_block_4$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[5][ctx2[22]])
      return 0;
    if (ctx2[23] && ctx2[23].fields && ctx2[23].fields.length)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_4$3(ctx) {
  let fast_tree_item;
  return {
    c() {
      fast_tree_item = element("fast-tree-item");
      set_custom_element_data(fast_tree_item, "class", "fast-tree-item svelte-qrzwy5");
    },
    m(target, anchor) {
      insert(target, fast_tree_item, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(fast_tree_item);
    }
  };
}
function create_if_block_3$4(ctx) {
  let pickfield;
  let current;
  pickfield = new PickField({
    props: {
      mode: ctx[2],
      context: [...ctx[0], ctx[19].name],
      type: ctx[23],
      onlyEntities: ctx[3]
    }
  });
  pickfield.$on("change", ctx[14]);
  pickfield.$on("dblclick", ctx[15]);
  return {
    c() {
      create_component(pickfield.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pickfield_changes = {};
      if (dirty & 4)
        pickfield_changes.mode = ctx2[2];
      if (dirty & 3)
        pickfield_changes.context = [...ctx2[0], ctx2[19].name];
      if (dirty & 2)
        pickfield_changes.type = ctx2[23];
      if (dirty & 8)
        pickfield_changes.onlyEntities = ctx2[3];
      pickfield.$set(pickfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pickfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickfield, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_pending_block(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_each_block$2(ctx) {
  let await_block_anchor;
  let promise2;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block_1,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(promise2 = getId(ctx[0], ctx[19]), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 3 && promise2 !== (promise2 = getId(ctx[0], ctx[19])) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block2 = info.blocks[i2];
        transition_out(block2);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$9, create_if_block_1$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[0] === "undefined")
      return 0;
    if (ctx2[1])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const typesCollection = /* @__PURE__ */ new Map();
const fieldsCollection = /* @__PURE__ */ new Map();
const rootType = writable(null);
const expanded = writable({});
const selectedFields = writable([]);
function setTypes$1(es) {
  for (const e of es) {
    e.fields = (e.fields || []).map((f) => {
      let type2 = f.type;
      while (type2 == null ? void 0 : type2.ofType) {
        type2 = type2.ofType;
      }
      const fieldTypeName = type2.name;
      const fieldKindName = type2 == null ? void 0 : type2.kind;
      return __spreadProps(__spreadValues({}, f), {
        type: { name: fieldTypeName, kind: fieldKindName }
      });
    });
    typesCollection.set(e.name, e);
  }
}
function getId(context, field) {
  return [...context, field.name].join(".");
}
function instance$q($$self, $$props, $$invalidate) {
  let $expanded, $$unsubscribe_expanded = noop$1;
  let $rootType, $$unsubscribe_rootType = noop$1;
  let $selectedFields, $$unsubscribe_selectedFields = noop$1;
  component_subscribe($$self, expanded, ($$value) => $$invalidate(5, $expanded = $$value));
  component_subscribe($$self, rootType, ($$value) => $$invalidate(4, $rootType = $$value));
  component_subscribe($$self, selectedFields, ($$value) => $$invalidate(6, $selectedFields = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_expanded());
  $$self.$$.on_destroy.push(() => $$unsubscribe_rootType());
  $$self.$$.on_destroy.push(() => $$unsubscribe_selectedFields());
  const dispatch2 = createEventDispatcher();
  let { intro = void 0 } = $$props;
  let { rootName = "query_root" } = $$props;
  let { context = void 0 } = $$props;
  let { type: type2 = void 0 } = $$props;
  let { mode = "one" } = $$props;
  let { onlyEntities = false } = $$props;
  let { reset } = $$props;
  function update2() {
    setTypes$1(intro.types);
    rootType.set(typesCollection.get(rootName));
  }
  async function itemClicked(event2, id) {
    let element2 = event2.target;
    while (element2.tagName !== "FAST-TREE-ITEM")
      element2 = element2.parentElement;
    if (event2.ctrlKey || event2.metaKey) {
      let expand2 = function(node) {
        const list = Array.from(node.querySelectorAll("fast-tree-item"));
        for (const element3 of list) {
          setTimeout(() => {
            set_store_value(expanded, $expanded[element3.id] = true, $expanded);
          }, 100);
        }
      };
      const start = element2;
      set_store_value(expanded, $expanded[id] = true, $expanded);
      setTimeout(() => expand2(start), 100);
      if (element2["selected"]) {
        set_store_value(selectedFields, $selectedFields = [...$selectedFields, id], $selectedFields);
      } else {
        set_store_value(selectedFields, $selectedFields = $selectedFields.filter((fid) => fid !== id), $selectedFields);
      }
      dispatch2("change", $selectedFields);
      return;
    }
    await new Promise((r) => setTimeout(r, 0));
    if (onlyEntities) {
      if (element2["selected"]) {
        set_store_value(selectedFields, $selectedFields = [id], $selectedFields);
      } else if ($selectedFields[0] === id) {
        set_store_value(selectedFields, $selectedFields = [], $selectedFields);
      }
    } else if (mode === "one") {
      if (id.split(".").length < 2) {
        element2["selected"] = false;
      } else {
        if (element2["selected"]) {
          set_store_value(selectedFields, $selectedFields = [id], $selectedFields);
        } else if ($selectedFields[0] === id) {
          set_store_value(selectedFields, $selectedFields = [], $selectedFields);
        }
      }
    } else if (mode === "many") {
      if (element2["selected"]) {
        set_store_value(selectedFields, $selectedFields = [...$selectedFields, id], $selectedFields);
      } else if ($selectedFields[0] === id) {
        set_store_value(selectedFields, $selectedFields = $selectedFields.filter((fid) => fid !== id), $selectedFields);
      }
    }
    if ($expanded[id] === void 0 || $expanded[id] === !!element2["expanded"]) {
      element2["expanded"] = !element2["expanded"];
    }
    if ($expanded[id] !== !!element2["expanded"]) {
      set_store_value(expanded, $expanded[id] = !!element2["expanded"], $expanded);
      dispatch2("expand", $expanded[id]);
    }
    dispatch2("change", element2.id);
  }
  function change_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  function dblclick_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler2 = (id, e) => itemClicked(e, id);
  function change_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  function dblclick_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  const click_handler_1 = (id, e) => itemClicked(e, id);
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(9, intro = $$props2.intro);
    if ("rootName" in $$props2)
      $$invalidate(10, rootName = $$props2.rootName);
    if ("context" in $$props2)
      $$invalidate(0, context = $$props2.context);
    if ("type" in $$props2)
      $$invalidate(1, type2 = $$props2.type);
    if ("mode" in $$props2)
      $$invalidate(2, mode = $$props2.mode);
    if ("onlyEntities" in $$props2)
      $$invalidate(3, onlyEntities = $$props2.onlyEntities);
    if ("reset" in $$props2)
      $$invalidate(8, reset = $$props2.reset);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      if (reset) {
        set_store_value(selectedFields, $selectedFields = [], $selectedFields);
        set_store_value(expanded, $expanded = {}, $expanded);
        $$invalidate(8, reset = false);
      }
    }
    if ($$self.$$.dirty & 512) {
      if (intro)
        update2();
    }
    if ($$self.$$.dirty & 16) {
      if ($rootType && $rootType.fields.length === 1) {
        for (const f of $rootType.fields) {
          set_store_value(expanded, $expanded[f.name] = true, $expanded);
        }
      }
    }
  };
  return [
    context,
    type2,
    mode,
    onlyEntities,
    $rootType,
    $expanded,
    $selectedFields,
    itemClicked,
    reset,
    intro,
    rootName,
    change_handler,
    dblclick_handler,
    click_handler2,
    change_handler_1,
    dblclick_handler_1,
    click_handler_1
  ];
}
class PickField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$q, create_fragment$q, safe_not_equal, {
      intro: 9,
      rootName: 10,
      context: 0,
      type: 1,
      mode: 2,
      onlyEntities: 3,
      reset: 8
    }, add_css$b);
  }
}
function create_fragment$p(ctx) {
  let svg2;
  let svg_levels = [
    { width: ctx[1] },
    { height: ctx[1] },
    { "stroke-width": "0" },
    { class: ctx[2] },
    ctx[0].a,
    ctx[4],
    { xmlns: "http://www.w3.org/2000/svg" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg2 = svg_element("svg");
      set_svg_attributes(svg2, svg_data);
    },
    m(target, anchor) {
      insert(target, svg2, anchor);
      svg2.innerHTML = ctx[3];
    },
    p(ctx2, [dirty]) {
      if (dirty & 8)
        svg2.innerHTML = ctx2[3];
      set_svg_attributes(svg2, svg_data = get_spread_update(svg_levels, [
        dirty & 2 && { width: ctx2[1] },
        dirty & 2 && { height: ctx2[1] },
        { "stroke-width": "0" },
        dirty & 4 && { class: ctx2[2] },
        dirty & 1 && ctx2[0].a,
        dirty & 16 && ctx2[4],
        { xmlns: "http://www.w3.org/2000/svg" }
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg2);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let { src } = $$props;
  let { size = "1em" } = $$props;
  let { color: color2 = void 0 } = $$props;
  let { title = void 0 } = $$props;
  let { className = "" } = $$props;
  let innerHtml;
  let attr2;
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
    if ("size" in $$props2)
      $$invalidate(1, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(5, color2 = $$props2.color);
    if ("title" in $$props2)
      $$invalidate(6, title = $$props2.title);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 33) {
      {
        $$invalidate(4, attr2 = {});
        if (color2) {
          if (src.a.stroke !== "none") {
            $$invalidate(4, attr2.stroke = color2, attr2);
          }
          if (src.a.fill !== "none") {
            $$invalidate(4, attr2.fill = color2, attr2);
          }
        }
      }
    }
    if ($$self.$$.dirty & 65) {
      {
        $$invalidate(3, innerHtml = (title ? `<title>${title}</title>` : "") + src.c);
      }
    }
  };
  return [src, size, className, innerHtml, attr2, color2, title];
}
class Icon$1 extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$p, create_fragment$p, safe_not_equal, {
      src: 0,
      size: 1,
      color: 5,
      title: 6,
      className: 2
    });
  }
}
var BiRefresh = {
  a: {
    viewBox: "0 0 24 24"
  },
  c: '<path d="M10 11H7.101c0-.003 0-.006.001-.009.065-.319.163-.634.291-.937.126-.297.281-.583.461-.85.178-.264.384-.513.61-.74C8.691 8.238 8.94 8.032 9.206 7.853c.266-.18.551-.334.848-.46.302-.128.617-.226.938-.291.658-.135 1.357-.135 2.018 0 .318.065.634.163.937.291.296.125.581.281.85.461.266.179.514.384.738.609l1.416-1.412c-.314-.316-.664-.604-1.036-.855-.373-.252-.773-.47-1.188-.646-.425-.18-.868-.317-1.315-.408-.923-.189-1.899-.189-2.819 0-.449.092-.892.229-1.316.409C8.858 5.727 8.458 5.944 8.086 6.196 7.716 6.445 7.368 6.733 7.05 7.05S6.445 7.716 6.197 8.085c-.252.373-.47.773-.646 1.19-.18.424-.317.867-.408 1.315C5.115 10.725 5.1 10.863 5.08 11H2l4 4L10 11zM14 13h2.899c-.001.003 0 .006-.001.008-.066.324-.164.639-.292.938-.123.293-.278.579-.459.848-.179.264-.385.514-.613.742-.225.225-.473.43-.739.61-.268.18-.553.335-.849.461-.303.128-.618.226-.938.291-.657.135-1.357.135-2.017 0-.319-.065-.634-.163-.937-.291-.297-.126-.583-.281-.85-.461-.264-.178-.513-.384-.74-.61L7.05 16.95c.317.317.666.605 1.035.854.373.252.773.47 1.19.646.424.18.867.317 1.315.408C11.051 18.952 11.525 19 12 19s.949-.048 1.408-.142c.449-.091.893-.229 1.317-.409.415-.176.815-.393 1.188-.645.372-.251.722-.54 1.035-.854.317-.317.605-.666.855-1.037.254-.377.472-.777.645-1.187.178-.42.315-.863.408-1.316.027-.135.043-.273.063-.41H22l-4-4L14 13z"></path>'
};
var RiEditorInsertColumnLeft = {
  a: {
    viewBox: "0 0 24 24"
  },
  c: '<g><path fill="none" d="M0 0H24V24H0z"></path>\n<path d="M20 3c.552 0 1 .448 1 1v16c0 .552-.448 1-1 1h-6c-.552 0-1-.448-1-1V4c0-.552.448-1 1-1h6zm-1 2h-4v14h4V5zM6 7c2.761 0 5 2.239 5 5s-2.239 5-5 5-5-2.239-5-5 2.239-5 5-5zm1 2H5v1.999L3 11v2l2-.001V15h2v-2.001L9 13v-2l-2-.001V9z"></path></g>'
};
var CgExtensionAdd = {
  a: {
    viewBox: "0 0 24 24",
    fill: "none"
  },
  c: '<path d="M16 4H18V6H20V8H18V10H16V8H14V6H16V4Z" fill="currentColor"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M12 12V6H4V20H18V12H12ZM6 8H10V12H6V8ZM10 14V18H6V14H10ZM16 14V18H12V14H16Z" fill="currentColor"></path>'
};
function add_css$a(target) {
  append_styles(target, "svelte-w6zhyn", "table.svelte-w6zhyn.svelte-w6zhyn{position:fixed;top:0;left:0;z-index:2;background-color:#181818}.gql-input.svelte-w6zhyn.svelte-w6zhyn{padding:0.5rem 0;position:fixed;bottom:0;width:100%;background-color:#000}.gql-create-button.svelte-w6zhyn.svelte-w6zhyn{background:rgba(255, 255, 255, .2);border:1px solid #FFF;color:#FFF;margin:0 0.5rem;transition:0.3s}.gql-create-button.svelte-w6zhyn.svelte-w6zhyn:hover{color:#000;background:#FFF}.gql-create-button.svelte-w6zhyn .container.svelte-w6zhyn{display:flex;align-items:center;justify-content:center}.field-container.svelte-w6zhyn.svelte-w6zhyn{margin-top:2.8rem;margin-bottom:2.6rem}.input-fields.svelte-w6zhyn.svelte-w6zhyn::-webkit-scrollbar{width:0;background:transparent}.input-fields.svelte-w6zhyn.svelte-w6zhyn{height:100%;overflow:scroll;-ms-overflow-style:none;scrollbar-width:none}");
}
function create_else_block$3(ctx) {
  let fast_switch;
  let t0;
  let t1;
  let fast_switch_checked_value;
  let mounted;
  let dispose;
  return {
    c() {
      fast_switch = element("fast-switch");
      t0 = text$1("Insert ");
      t1 = text$1(ctx[0]);
      set_style(fast_switch, "margin-left", "1.5rem");
      set_custom_element_data(fast_switch, "class", "switch");
      set_custom_element_data(fast_switch, "checked", fast_switch_checked_value = ctx[0] === "after");
    },
    m(target, anchor) {
      insert(target, fast_switch, anchor);
      append$1(fast_switch, t0);
      append$1(fast_switch, t1);
      if (!mounted) {
        dispose = listen(fast_switch, "change", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
      if (dirty & 1 && fast_switch_checked_value !== (fast_switch_checked_value = ctx2[0] === "after")) {
        set_custom_element_data(fast_switch, "checked", fast_switch_checked_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(fast_switch);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$2(ctx) {
  let fast_switch;
  let t0;
  let t1;
  let fast_switch_checked_value;
  let mounted;
  let dispose;
  return {
    c() {
      fast_switch = element("fast-switch");
      t0 = text$1("Insert ");
      t1 = text$1(ctx[1]);
      set_style(fast_switch, "margin-left", "1.5rem");
      set_custom_element_data(fast_switch, "class", "switch");
      set_custom_element_data(fast_switch, "checked", fast_switch_checked_value = ctx[1] === "last");
    },
    m(target, anchor) {
      insert(target, fast_switch, anchor);
      append$1(fast_switch, t0);
      append$1(fast_switch, t1);
      if (!mounted) {
        dispose = listen(fast_switch, "change", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t1, ctx2[1]);
      if (dirty & 2 && fast_switch_checked_value !== (fast_switch_checked_value = ctx2[1] === "last")) {
        set_custom_element_data(fast_switch, "checked", fast_switch_checked_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(fast_switch);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$3(ctx) {
  let fast_switch;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      fast_switch = element("fast-switch");
      t = text$1("Generate React");
      set_custom_element_data(fast_switch, "class", "switch");
      set_custom_element_data(fast_switch, "checked", ctx[2]);
    },
    m(target, anchor) {
      insert(target, fast_switch, anchor);
      append$1(fast_switch, t);
      if (!mounted) {
        dispose = listen(fast_switch, "change", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        set_custom_element_data(fast_switch, "checked", ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(fast_switch);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$3(ctx) {
  let fast_button;
  let t;
  let fast_button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      fast_button = element("fast-button");
      t = text$1("OK");
      set_custom_element_data(fast_button, "class", "ok-button");
      set_custom_element_data(fast_button, "disabled", fast_button_disabled_value = !ctx[11]);
    },
    m(target, anchor) {
      insert(target, fast_button, anchor);
      append$1(fast_button, t);
      if (!mounted) {
        dispose = [
          listen(fast_button, "click", ctx[14]),
          listen(fast_button, "dblclick", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2048 && fast_button_disabled_value !== (fast_button_disabled_value = !ctx2[11])) {
        set_custom_element_data(fast_button, "disabled", fast_button_disabled_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(fast_button);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$5(ctx) {
  let p2;
  let fast_button0;
  let div0;
  let icon0;
  let t0;
  let t1;
  let fast_button1;
  let div1;
  let icon1;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon$1({
    props: {
      className: "custom-icon",
      src: CgExtensionAdd,
      size: "24"
    }
  });
  icon1 = new Icon$1({
    props: {
      className: "custom-icon",
      src: BiRefresh,
      size: "24"
    }
  });
  return {
    c() {
      p2 = element("p");
      fast_button0 = element("fast-button");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t0 = text$1("\n            Create table");
      t1 = space();
      fast_button1 = element("fast-button");
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t2 = text$1("\n          Reload schema");
      attr(div0, "class", "container svelte-w6zhyn");
      set_custom_element_data(fast_button0, "class", "gql-create-button svelte-w6zhyn");
      attr(div1, "class", "container svelte-w6zhyn");
      set_custom_element_data(fast_button1, "class", "gql-create-button svelte-w6zhyn");
      attr(p2, "class", "gql-input svelte-w6zhyn");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append$1(p2, fast_button0);
      append$1(fast_button0, div0);
      mount_component(icon0, div0, null);
      append$1(div0, t0);
      append$1(p2, t1);
      append$1(p2, fast_button1);
      append$1(fast_button1, div1);
      mount_component(icon1, div1, null);
      append$1(div1, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(fast_button0, "click", ctx[16]),
          listen(fast_button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$8(ctx) {
  let p2;
  let fast_button0;
  let div0;
  let icon0;
  let t0;
  let t1;
  let fast_button1;
  let div1;
  let icon1;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon$1({
    props: {
      className: "custom-icon",
      src: RiEditorInsertColumnLeft,
      size: "24"
    }
  });
  icon1 = new Icon$1({
    props: {
      className: "custom-icon",
      src: BiRefresh,
      size: "24"
    }
  });
  return {
    c() {
      p2 = element("p");
      fast_button0 = element("fast-button");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t0 = text$1("\n            Add new column");
      t1 = space();
      fast_button1 = element("fast-button");
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t2 = text$1("\n          Reload schema");
      attr(div0, "class", "container svelte-w6zhyn");
      set_custom_element_data(fast_button0, "class", "gql-create-button svelte-w6zhyn");
      attr(div1, "class", "container svelte-w6zhyn");
      set_custom_element_data(fast_button1, "class", "gql-create-button svelte-w6zhyn");
      attr(p2, "class", "gql-input svelte-w6zhyn");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append$1(p2, fast_button0);
      append$1(fast_button0, div0);
      mount_component(icon0, div0, null);
      append$1(div0, t0);
      append$1(p2, t1);
      append$1(p2, fast_button1);
      append$1(fast_button1, div1);
      mount_component(icon1, div1, null);
      append$1(div1, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(fast_button0, "click", ctx[17]),
          listen(fast_button1, "click", ctx[24])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(p2);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$o(ctx) {
  let fast_design_system_provider;
  let table;
  let tr;
  let td0;
  let t0;
  let td1;
  let t1;
  let td2;
  let t2;
  let div2;
  let pickfield;
  let updating_reset;
  let t3;
  let t4;
  let current;
  function select_block_type(ctx2, dirty) {
    if (!ctx2[9])
      return create_if_block_4$2;
    return create_else_block$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[9] && create_if_block_3$3(ctx);
  let if_block2 = ctx[5] && create_if_block_2$3(ctx);
  function pickfield_reset_binding(value2) {
    ctx[22](value2);
  }
  let pickfield_props = {
    mode: ctx[4],
    onlyEntities: ctx[6],
    intro: ctx[3]
  };
  if (ctx[10] !== void 0) {
    pickfield_props.reset = ctx[10];
  }
  pickfield = new PickField({ props: pickfield_props });
  binding_callbacks.push(() => bind(pickfield, "reset", pickfield_reset_binding));
  pickfield.$on("change", ctx[13]);
  let if_block3 = ctx[7] && create_if_block_1$5(ctx);
  let if_block4 = ctx[8] && create_if_block$8(ctx);
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      table = element("table");
      tr = element("tr");
      td0 = element("td");
      if_block0.c();
      t0 = space();
      td1 = element("td");
      if (if_block1)
        if_block1.c();
      t1 = space();
      td2 = element("td");
      if (if_block2)
        if_block2.c();
      t2 = space();
      div2 = element("div");
      create_component(pickfield.$$.fragment);
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      set_style(td2, "text-align", "end");
      attr(table, "width", "100%");
      attr(table, "class", "svelte-w6zhyn");
      attr(div2, "class", "field-container svelte-w6zhyn");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_custom_element_data(fast_design_system_provider, "class", "input-fields svelte-w6zhyn");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, table);
      append$1(table, tr);
      append$1(tr, td0);
      if_block0.m(td0, null);
      append$1(tr, t0);
      append$1(tr, td1);
      if (if_block1)
        if_block1.m(td1, null);
      append$1(tr, t1);
      append$1(tr, td2);
      if (if_block2)
        if_block2.m(td2, null);
      append$1(fast_design_system_provider, t2);
      append$1(fast_design_system_provider, div2);
      mount_component(pickfield, div2, null);
      append$1(fast_design_system_provider, t3);
      if (if_block3)
        if_block3.m(fast_design_system_provider, null);
      append$1(fast_design_system_provider, t4);
      if (if_block4)
        if_block4.m(fast_design_system_provider, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(td0, null);
        }
      }
      if (ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$3(ctx2);
          if_block1.c();
          if_block1.m(td1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$3(ctx2);
          if_block2.c();
          if_block2.m(td2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      const pickfield_changes = {};
      if (dirty & 16)
        pickfield_changes.mode = ctx2[4];
      if (dirty & 64)
        pickfield_changes.onlyEntities = ctx2[6];
      if (dirty & 8)
        pickfield_changes.intro = ctx2[3];
      if (!updating_reset && dirty & 1024) {
        updating_reset = true;
        pickfield_changes.reset = ctx2[10];
        add_flush_callback(() => updating_reset = false);
      }
      pickfield.$set(pickfield_changes);
      if (ctx2[7]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$5(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(fast_design_system_provider, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$8(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(fast_design_system_provider, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pickfield.$$.fragment, local);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(pickfield.$$.fragment, local);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(pickfield);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let isValid2;
  let { intro } = $$props;
  let { beforeAfter = "after" } = $$props;
  let { firstLast = "last" } = $$props;
  let { mode = "one" } = $$props;
  let { okButton = false } = $$props;
  let { onlyEntities = false } = $$props;
  let { showCreateButton = false } = $$props;
  let { showColumnButton = false } = $$props;
  let { showGenerateReactSwitch = false } = $$props;
  let { generateReact = true } = $$props;
  let fields22;
  let reset = true;
  const dispatch2 = createEventDispatcher();
  function handleChange(event2) {
    $$invalidate(21, fields22 = event2.detail);
    dispatch2("change", { beforeAfter, fields: event2.detail });
  }
  function handleSelect() {
    dispatch2("select", {
      insertType: showGenerateReactSwitch ? beforeAfter : firstLast,
      fields: fields22,
      generateReact
    });
    $$invalidate(10, reset = true);
  }
  function doubleClick() {
    dispatch2("ok", fields22);
  }
  const handleCreateTable2 = () => {
    dispatch2("create");
    dispatch2("close");
  };
  const handleAddColumn2 = () => {
    dispatch2("addColumn");
    dispatch2("close");
  };
  const handleGenerateReact = (e) => {
    $$invalidate(2, generateReact = e.target.checked);
  };
  const handleFirstLast = (e) => {
    $$invalidate(1, firstLast = e.target.checked ? "last" : "first");
  };
  const handleBeforeAfter = (e) => {
    $$invalidate(0, beforeAfter = e.target.checked ? "after" : "before");
    handleChange(new CustomEvent("change", { detail: fields22 }));
  };
  function pickfield_reset_binding(value2) {
    reset = value2;
    $$invalidate(10, reset);
  }
  const click_handler2 = () => dispatch2("loadIntrospection");
  const click_handler_1 = () => dispatch2("loadIntrospection");
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(3, intro = $$props2.intro);
    if ("beforeAfter" in $$props2)
      $$invalidate(0, beforeAfter = $$props2.beforeAfter);
    if ("firstLast" in $$props2)
      $$invalidate(1, firstLast = $$props2.firstLast);
    if ("mode" in $$props2)
      $$invalidate(4, mode = $$props2.mode);
    if ("okButton" in $$props2)
      $$invalidate(5, okButton = $$props2.okButton);
    if ("onlyEntities" in $$props2)
      $$invalidate(6, onlyEntities = $$props2.onlyEntities);
    if ("showCreateButton" in $$props2)
      $$invalidate(7, showCreateButton = $$props2.showCreateButton);
    if ("showColumnButton" in $$props2)
      $$invalidate(8, showColumnButton = $$props2.showColumnButton);
    if ("showGenerateReactSwitch" in $$props2)
      $$invalidate(9, showGenerateReactSwitch = $$props2.showGenerateReactSwitch);
    if ("generateReact" in $$props2)
      $$invalidate(2, generateReact = $$props2.generateReact);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2097153) {
      $$invalidate(11, isValid2 = fields22 && beforeAfter);
    }
  };
  return [
    beforeAfter,
    firstLast,
    generateReact,
    intro,
    mode,
    okButton,
    onlyEntities,
    showCreateButton,
    showColumnButton,
    showGenerateReactSwitch,
    reset,
    isValid2,
    dispatch2,
    handleChange,
    handleSelect,
    doubleClick,
    handleCreateTable2,
    handleAddColumn2,
    handleGenerateReact,
    handleFirstLast,
    handleBeforeAfter,
    fields22,
    pickfield_reset_binding,
    click_handler2,
    click_handler_1
  ];
}
class InsertField extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$o, create_fragment$o, safe_not_equal, {
      intro: 3,
      beforeAfter: 0,
      firstLast: 1,
      mode: 4,
      okButton: 5,
      onlyEntities: 6,
      showCreateButton: 7,
      showColumnButton: 8,
      showGenerateReactSwitch: 9,
      generateReact: 2
    }, add_css$a);
  }
}
function create_fragment$n(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: InsertField,
      props: {
        intro: ctx[0],
        okButton: true,
        mode: ctx[4],
        showColumnButton: true
      },
      events: {
        change: ctx[5],
        select: ctx[6],
        close: ctx[7],
        ok: ctx[9],
        addColumn: ctx[8],
        loadIntrospection: ctx[10]
      },
      classes: "iteria-ignore",
      x: ctx[1],
      y: ctx[2],
      title: ctx[3]
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 17)
        winbox_changes.props = {
          intro: ctx2[0],
          okButton: true,
          mode: ctx2[4],
          showColumnButton: true
        };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      if (dirty & 8)
        winbox_changes.title = ctx2[3];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { intro } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { title = "Fields" } = $$props;
  let { mode = "one" } = $$props;
  const dispatch2 = createEventDispatcher();
  function change(e) {
    const data = {
      beforeAfter: e.detail.beforeAfter,
      selectedFields: e.detail.fields
    };
    dispatch2("change", data);
  }
  function select(e) {
    const data = {
      insertType: e.detail.insertType,
      selectedFields: e.detail.fields
    };
    dispatch2("select", data);
  }
  function close() {
    dispatch2("close", []);
  }
  function addColumn2() {
    dispatch2("addColumn");
  }
  function ok(event2) {
    dispatch2("ok", event2.detail);
  }
  function loadIntrospection2() {
    dispatch2("loadIntrospection");
  }
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(0, intro = $$props2.intro);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("mode" in $$props2)
      $$invalidate(4, mode = $$props2.mode);
  };
  return [
    intro,
    x2,
    y2,
    title,
    mode,
    change,
    select,
    close,
    addColumn2,
    ok,
    loadIntrospection2
  ];
}
class InsertFieldDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$n, create_fragment$n, safe_not_equal, { intro: 0, x: 1, y: 2, title: 3, mode: 4 });
  }
}
function create_fragment$m(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: InsertField,
      props: {
        intro: ctx[0],
        okButton: true,
        mode: ctx[4],
        onlyEntities: ctx[5],
        showCreateButton: true,
        showGenerateReactSwitch: true
      },
      events: {
        change: ctx[6],
        select: ctx[7],
        close: ctx[8],
        ok: ctx[9],
        create: ctx[10],
        loadIntrospection: ctx[11]
      },
      classes: "iteria-ignore",
      x: ctx[1],
      y: ctx[2],
      title: ctx[3]
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 49)
        winbox_changes.props = {
          intro: ctx2[0],
          okButton: true,
          mode: ctx2[4],
          onlyEntities: ctx2[5],
          showCreateButton: true,
          showGenerateReactSwitch: true
        };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      if (dirty & 8)
        winbox_changes.title = ctx2[3];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { intro } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { title = "Fields" } = $$props;
  let { mode = "one" } = $$props;
  let { onlyEntities = true } = $$props;
  const dispatch2 = createEventDispatcher();
  function change(e) {
    const data = {
      beforeAfter: e.detail.beforeAfter,
      selectedFields: e.detail.fields
    };
    dispatch2("change", data);
  }
  function select(e) {
    const data = {
      beforeAfter: e.detail.insertType,
      selectedFields: e.detail.fields,
      generateReact: e.detail.generateReact
    };
    dispatch2("select", data);
  }
  function close() {
    dispatch2("close", []);
  }
  function ok(event2) {
    dispatch2("ok", event2.detail);
  }
  const create2 = () => {
    dispatch2("create");
  };
  const loadIntrospection2 = () => {
    dispatch2("loadIntrospection");
  };
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(0, intro = $$props2.intro);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("mode" in $$props2)
      $$invalidate(4, mode = $$props2.mode);
    if ("onlyEntities" in $$props2)
      $$invalidate(5, onlyEntities = $$props2.onlyEntities);
  };
  return [
    intro,
    x2,
    y2,
    title,
    mode,
    onlyEntities,
    change,
    select,
    close,
    ok,
    create2,
    loadIntrospection2
  ];
}
class ChooseEntityDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$m, create_fragment$m, safe_not_equal, {
      intro: 0,
      x: 1,
      y: 2,
      title: 3,
      mode: 4,
      onlyEntities: 5
    });
  }
}
function create_fragment$l(ctx) {
  let iframe;
  let iframe_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      iframe = element("iframe");
      attr(iframe, "title", "vscode-iframe");
      if (!src_url_equal(iframe.src, iframe_src_value = "https://vscode-web.iteria.app/"))
        attr(iframe, "src", iframe_src_value);
      attr(iframe, "id", "vscode-iframe");
      attr(iframe, "height", "100%");
      attr(iframe, "class", "iteria-ignore");
      attr(iframe, "width", "100%");
      attr(iframe, "frameborder", "0");
    },
    m(target, anchor) {
      insert(target, iframe, anchor);
      if (!mounted) {
        dispose = listen(iframe, "load", ctx[0]);
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(iframe);
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self) {
  const dispatch2 = createEventDispatcher();
  const onIframeLoad = (e) => dispatch2("iframeLoaded", { iframe: e.target });
  return [onIframeLoad];
}
class VscodeIframe extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$l, create_fragment$l, safe_not_equal, {});
  }
}
function create_fragment$k(ctx) {
  let winbox2;
  let updating_hidden;
  let current;
  function winbox_hidden_binding(value2) {
    ctx[5](value2);
  }
  let winbox_props = {
    title: ctx[1],
    events: {
      iframeLoaded: ctx[4],
      close: ctx[3]
    },
    component: VscodeIframe,
    classes: "iteria-ignore",
    closeless: false,
    width: "50%",
    x: "right",
    y: "bottom",
    windowName: "vscode"
  };
  if (ctx[0] !== void 0) {
    winbox_props.hidden = ctx[0];
  }
  winbox2 = new Winbox_1({ props: winbox_props });
  binding_callbacks.push(() => bind(winbox2, "hidden", winbox_hidden_binding));
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 2)
        winbox_changes.title = ctx2[1];
      if (!updating_hidden && dirty & 1) {
        updating_hidden = true;
        winbox_changes.hidden = ctx2[0];
        add_flush_callback(() => updating_hidden = false);
      }
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { title = "Title" } = $$props;
  let { hidden: hidden2 } = $$props;
  const dispatch2 = createEventDispatcher();
  const close = () => {
    dispatch2("close", []);
  };
  const func = (e) => dispatch2("iframeLoaded", e.detail);
  function winbox_hidden_binding(value2) {
    hidden2 = value2;
    $$invalidate(0, hidden2);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("hidden" in $$props2)
      $$invalidate(0, hidden2 = $$props2.hidden);
  };
  return [hidden2, title, dispatch2, close, func, winbox_hidden_binding];
}
class VscodeWindow extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$k, create_fragment$k, safe_not_equal, { title: 1, hidden: 0 });
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d = decorators[i2])
        r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
const removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n2 = start.nextSibling;
    container.removeChild(start);
    start = n2;
  }
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
const boundAttributeSuffix = "$lit$";
class Template {
  constructor(result2, element2) {
    this.parts = [];
    this.element = element2;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element2.content, 133, null, false);
    let lastPartIndex = 0;
    let index2 = -1;
    let partIndex = 0;
    const { strings: strings2, values: { length } } = result2;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index2++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const { length: length2 } = attributes;
          let count = 0;
          for (let i2 = 0; i2 < length2; i2++) {
            if (endsWith(attributes[i2].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings2[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({ type: "attribute", index: index2, name, strings: statics });
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings3 = data.split(markerRegex);
          const lastIndex = strings3.length - 1;
          for (let i2 = 0; i2 < lastIndex; i2++) {
            let insert2;
            let s = strings3[i2];
            if (s === "") {
              insert2 = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert2 = document.createTextNode(s);
            }
            parent.insertBefore(insert2, node);
            this.parts.push({ type: "node", index: ++index2 });
          }
          if (strings3[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings3[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index2 === lastPartIndex) {
            index2++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index2;
          this.parts.push({ type: "node", index: index2 });
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index2--;
          }
          partIndex++;
        } else {
          let i2 = -1;
          while ((i2 = node.data.indexOf(marker, i2 + 1)) !== -1) {
            this.parts.push({ type: "node", index: -1 });
            partIndex++;
          }
        }
      }
    }
    for (const n2 of nodesToRemove) {
      n2.parentNode.removeChild(n2);
    }
  }
}
const endsWith = (str2, suffix) => {
  const index2 = str2.length - suffix.length;
  return index2 >= 0 && str2.slice(index2) === suffix;
};
const isTemplatePartActive = (part) => part.index !== -1;
const createMarker = () => document.createComment("");
const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const walkerNodeFilter = 133;
function removeNodesFromTemplate(template2, nodesToRemove) {
  const { element: { content: content2 }, parts: parts2 } = template2;
  const walker = document.createTreeWalker(content2, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let part = parts2[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;
  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode;
    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    }
    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node);
      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    }
    if (currentRemovingNode !== null) {
      removeCount++;
    }
    while (part !== void 0 && part.index === nodeIndex) {
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
      part = parts2[partIndex];
    }
  }
  nodesToRemoveInTemplate.forEach((n2) => n2.parentNode.removeChild(n2));
}
const countNodes = (node) => {
  let count = node.nodeType === 11 ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);
  while (walker.nextNode()) {
    count++;
  }
  return count;
};
const nextActiveIndexInTemplateParts = (parts2, startIndex = -1) => {
  for (let i2 = startIndex + 1; i2 < parts2.length; i2++) {
    const part = parts2[i2];
    if (isTemplatePartActive(part)) {
      return i2;
    }
  }
  return -1;
};
function insertNodeIntoTemplate(template2, node, refNode = null) {
  const { element: { content: content2 }, parts: parts2 } = template2;
  if (refNode === null || refNode === void 0) {
    content2.appendChild(node);
    return;
  }
  const walker = document.createTreeWalker(content2, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts2);
  let insertCount = 0;
  let walkerIndex = -1;
  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;
    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }
    while (partIndex !== -1 && parts2[partIndex].index === walkerIndex) {
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts2[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
        }
        return;
      }
      partIndex = nextActiveIndexInTemplateParts(parts2, partIndex);
    }
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directives = /* @__PURE__ */ new WeakMap();
const directive$1 = (f) => (...args2) => {
  const d = f(...args2);
  directives.set(d, true);
  return d;
};
const isDirective$1 = (o) => {
  return typeof o === "function" && directives.has(o);
};
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const noChange = {};
const nothing = {};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class TemplateInstance {
  constructor(template2, processor, options2) {
    this.__parts = [];
    this.template = template2;
    this.processor = processor;
    this.options = options2;
  }
  update(values) {
    let i2 = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i2]);
      }
      i2++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (s) => s });
const commentMarker = ` ${marker} `;
class TemplateResult {
  constructor(strings2, values, type2, processor) {
    this.strings = strings2;
    this.values = values;
    this.type = type2;
    this.processor = processor;
  }
  getHTML() {
    const l2 = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i2 = 0; i2 < l2; i2++) {
      const s = this.strings[i2];
      const commentOpen = s.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s);
      if (attributeMatch === null) {
        html2 += s + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l2];
    return html2;
  }
  getTemplateElement() {
    const template2 = document.createElement("template");
    let value2 = this.getHTML();
    if (policy !== void 0) {
      value2 = policy.createHTML(value2);
    }
    template2.innerHTML = value2;
    return template2;
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const isPrimitive = (value2) => {
  return value2 === null || !(typeof value2 === "object" || typeof value2 === "function");
};
const isIterable = (value2) => {
  return Array.isArray(value2) || !!(value2 && value2[Symbol.iterator]);
};
class AttributeCommitter {
  constructor(element2, name, strings2) {
    this.dirty = true;
    this.element = element2;
    this.name = name;
    this.strings = strings2;
    this.parts = [];
    for (let i2 = 0; i2 < strings2.length - 1; i2++) {
      this.parts[i2] = this._createPart();
    }
  }
  _createPart() {
    return new AttributePart$1(this);
  }
  _getValue() {
    const strings2 = this.strings;
    const l2 = strings2.length - 1;
    const parts2 = this.parts;
    if (l2 === 1 && strings2[0] === "" && strings2[1] === "") {
      const v = parts2[0].value;
      if (typeof v === "symbol") {
        return String(v);
      }
      if (typeof v === "string" || !isIterable(v)) {
        return v;
      }
    }
    let text2 = "";
    for (let i2 = 0; i2 < l2; i2++) {
      text2 += strings2[i2];
      const part = parts2[i2];
      if (part !== void 0) {
        const v = part.value;
        if (isPrimitive(v) || !isIterable(v)) {
          text2 += typeof v === "string" ? v : String(v);
        } else {
          for (const t of v) {
            text2 += typeof t === "string" ? t : String(t);
          }
        }
      }
    }
    text2 += strings2[l2];
    return text2;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
}
class AttributePart$1 {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value2) {
    if (value2 !== noChange && (!isPrimitive(value2) || value2 !== this.value)) {
      this.value = value2;
      if (!isDirective$1(value2)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective$1(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
}
class NodePart {
  constructor(options2) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options2;
  }
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  insertAfterNode(ref2) {
    this.startNode = ref2;
    this.endNode = ref2.nextSibling;
  }
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  insertAfterPart(ref2) {
    ref2.__insert(this.startNode = createMarker());
    this.endNode = ref2.endNode;
    ref2.endNode = this.startNode;
  }
  setValue(value2) {
    this.__pendingValue = value2;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective$1(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value2 = this.__pendingValue;
    if (value2 === noChange) {
      return;
    }
    if (isPrimitive(value2)) {
      if (value2 !== this.value) {
        this.__commitText(value2);
      }
    } else if (value2 instanceof TemplateResult) {
      this.__commitTemplateResult(value2);
    } else if (value2 instanceof Node) {
      this.__commitNode(value2);
    } else if (isIterable(value2)) {
      this.__commitIterable(value2);
    } else if (value2 === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value2);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value2) {
    if (this.value === value2) {
      return;
    }
    this.clear();
    this.__insert(value2);
    this.value = value2;
  }
  __commitText(value2) {
    const node = this.startNode.nextSibling;
    value2 = value2 == null ? "" : value2;
    const valueAsString = typeof value2 === "string" ? value2 : String(value2);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value2;
  }
  __commitTemplateResult(value2) {
    const template2 = this.options.templateFactory(value2);
    if (this.value instanceof TemplateInstance && this.value.template === template2) {
      this.value.update(value2.values);
    } else {
      const instance2 = new TemplateInstance(template2, value2.processor, this.options);
      const fragment = instance2._clone();
      instance2.update(value2.values);
      this.__commitNode(fragment);
      this.value = instance2;
    }
  }
  __commitIterable(value2) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value2) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
}
class BooleanAttributePart$1 {
  constructor(element2, name, strings2) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings2.length !== 2 || strings2[0] !== "" || strings2[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element2;
    this.name = name;
    this.strings = strings2;
  }
  setValue(value2) {
    this.__pendingValue = value2;
  }
  commit() {
    while (isDirective$1(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value2 = !!this.__pendingValue;
    if (this.value !== value2) {
      if (value2) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value2;
    }
    this.__pendingValue = noChange;
  }
}
class PropertyCommitter extends AttributeCommitter {
  constructor(element2, name, strings2) {
    super(element2, name, strings2);
    this.single = strings2.length === 2 && strings2[0] === "" && strings2[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
}
class PropertyPart extends AttributePart$1 {
}
let eventOptionsSupported = false;
(() => {
  try {
    const options2 = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options2, options2);
    window.removeEventListener("test", options2, options2);
  } catch (_e) {
  }
})();
class EventPart$1 {
  constructor(element2, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element2;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e) => this.handleEvent(e);
  }
  setValue(value2) {
    this.__pendingValue = value2;
  }
  commit() {
    while (isDirective$1(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event2) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event2);
    } else {
      this.value.handleEvent(event2);
    }
  }
}
const getOptions = (o) => o && (eventOptionsSupported ? { capture: o.capture, passive: o.passive, once: o.once } : o.capture);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function templateFactory(result2) {
  let templateCache = templateCaches.get(result2.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(result2.type, templateCache);
  }
  let template2 = templateCache.stringsArray.get(result2.strings);
  if (template2 !== void 0) {
    return template2;
  }
  const key = result2.strings.join(marker);
  template2 = templateCache.keyString.get(key);
  if (template2 === void 0) {
    template2 = new Template(result2, result2.getTemplateElement());
    templateCache.keyString.set(key, template2);
  }
  templateCache.stringsArray.set(result2.strings, template2);
  return template2;
}
const templateCaches = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const parts = /* @__PURE__ */ new WeakMap();
const render$1 = (result2, container, options2) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options2)));
    part.appendInto(container);
  }
  part.setValue(result2);
  part.commit();
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class DefaultTemplateProcessor {
  handleAttributeExpressions(element2, name, strings2, options2) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element2, name.slice(1), strings2);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart$1(element2, name.slice(1), options2.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart$1(element2, name.slice(1), strings2)];
    }
    const committer = new AttributeCommitter(element2, name, strings2);
    return committer.parts;
  }
  handleTextExpression(options2) {
    return new NodePart(options2);
  }
}
const defaultTemplateProcessor = new DefaultTemplateProcessor();
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
const html$2 = (strings2, ...values) => new TemplateResult(strings2, values, "html", defaultTemplateProcessor);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const getTemplateCacheKey = (type2, scopeName) => `${type2}--${scopeName}`;
let compatibleShadyCSSVersion = true;
if (typeof window.ShadyCSS === "undefined") {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === "undefined") {
  console.warn(`Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
const shadyTemplateFactory = (scopeName) => (result2) => {
  const cacheKey = getTemplateCacheKey(result2.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: /* @__PURE__ */ new WeakMap(),
      keyString: /* @__PURE__ */ new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }
  let template2 = templateCache.stringsArray.get(result2.strings);
  if (template2 !== void 0) {
    return template2;
  }
  const key = result2.strings.join(marker);
  template2 = templateCache.keyString.get(key);
  if (template2 === void 0) {
    const element2 = result2.getTemplateElement();
    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element2, scopeName);
    }
    template2 = new Template(result2, element2);
    templateCache.keyString.set(key, template2);
  }
  templateCache.stringsArray.set(result2.strings, template2);
  return template2;
};
const TEMPLATE_TYPES = ["html", "svg"];
const removeStylesFromLitTemplates = (scopeName) => {
  TEMPLATE_TYPES.forEach((type2) => {
    const templates = templateCaches.get(getTemplateCacheKey(type2, scopeName));
    if (templates !== void 0) {
      templates.keyString.forEach((template2) => {
        const { element: { content: content2 } } = template2;
        const styles2 = /* @__PURE__ */ new Set();
        Array.from(content2.querySelectorAll("style")).forEach((s) => {
          styles2.add(s);
        });
        removeNodesFromTemplate(template2, styles2);
      });
    }
  });
};
const shadyRenderSet = /* @__PURE__ */ new Set();
const prepareTemplateStyles = (scopeName, renderedDOM, template2) => {
  shadyRenderSet.add(scopeName);
  const templateElement = !!template2 ? template2.element : document.createElement("template");
  const styles2 = renderedDOM.querySelectorAll("style");
  const { length } = styles2;
  if (length === 0) {
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }
  const condensedStyle = document.createElement("style");
  for (let i2 = 0; i2 < length; i2++) {
    const style2 = styles2[i2];
    style2.parentNode.removeChild(style2);
    condensedStyle.textContent += style2.textContent;
  }
  removeStylesFromLitTemplates(scopeName);
  const content2 = templateElement.content;
  if (!!template2) {
    insertNodeIntoTemplate(template2, condensedStyle, content2.firstChild);
  } else {
    content2.insertBefore(condensedStyle, content2.firstChild);
  }
  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content2.querySelector("style");
  if (window.ShadyCSS.nativeShadow && style !== null) {
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template2) {
    content2.insertBefore(condensedStyle, content2.firstChild);
    const removes = /* @__PURE__ */ new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template2, removes);
  }
};
const render = (result2, container, options2) => {
  if (!options2 || typeof options2 !== "object" || !options2.scopeName) {
    throw new Error("The `scopeName` option is required.");
  }
  const scopeName = options2.scopeName;
  const hasRendered = parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11 && !!container.host;
  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);
  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render$1(result2, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options2));
  if (firstScopeRender) {
    const part = parts.get(renderContainer);
    parts.delete(renderContainer);
    const template2 = part.value instanceof TemplateInstance ? part.value.template : void 0;
    prepareTemplateStyles(scopeName, renderContainer, template2);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    parts.set(container, part);
  }
  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var _a;
window.JSCompiler_renameProperty = (prop, _obj) => prop;
const defaultConverter = {
  toAttribute(value2, type2) {
    switch (type2) {
      case Boolean:
        return value2 ? "" : null;
      case Object:
      case Array:
        return value2 == null ? value2 : JSON.stringify(value2);
    }
    return value2;
  },
  fromAttribute(value2, type2) {
    switch (type2) {
      case Boolean:
        return value2 !== null;
      case Number:
        return value2 === null ? null : Number(value2);
      case Object:
      case Array:
        return JSON.parse(value2);
    }
    return value2;
  }
};
const notEqual = (value2, old) => {
  return old !== value2 && (old === old || value2 === value2);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
const finalized = "finalized";
class UpdatingElement extends HTMLElement {
  constructor() {
    super();
    this.initialize();
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this._classProperties.forEach((v, p2) => {
      const attr2 = this._attributeNameForProperty(p2, v);
      if (attr2 !== void 0) {
        this._attributeToPropertyMap.set(attr2, p2);
        attributes.push(attr2);
      }
    });
    return attributes;
  }
  static _ensureClassProperties() {
    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
      this._classProperties = /* @__PURE__ */ new Map();
      const superProperties = Object.getPrototypeOf(this)._classProperties;
      if (superProperties !== void 0) {
        superProperties.forEach((v, k2) => this._classProperties.set(k2, v));
      }
    }
  }
  static createProperty(name, options2 = defaultPropertyDeclaration) {
    this._ensureClassProperties();
    this._classProperties.set(name, options2);
    if (options2.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }
    const key = typeof name === "symbol" ? Symbol() : `__${name}`;
    const descriptor = this.getPropertyDescriptor(name, key, options2);
    if (descriptor !== void 0) {
      Object.defineProperty(this.prototype, name, descriptor);
    }
  }
  static getPropertyDescriptor(name, key, options2) {
    return {
      get() {
        return this[key];
      },
      set(value2) {
        const oldValue = this[name];
        this[key] = value2;
        this.requestUpdateInternal(name, oldValue, options2);
      },
      configurable: true,
      enumerable: true
    };
  }
  static getPropertyOptions(name) {
    return this._classProperties && this._classProperties.get(name) || defaultPropertyDeclaration;
  }
  static finalize() {
    const superCtor = Object.getPrototypeOf(this);
    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }
    this[finalized] = true;
    this._ensureClassProperties();
    this._attributeToPropertyMap = /* @__PURE__ */ new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...typeof Object.getOwnPropertySymbols === "function" ? Object.getOwnPropertySymbols(props) : []
      ];
      for (const p2 of propKeys) {
        this.createProperty(p2, props[p2]);
      }
    }
  }
  static _attributeNameForProperty(name, options2) {
    const attribute = options2.attribute;
    return attribute === false ? void 0 : typeof attribute === "string" ? attribute : typeof name === "string" ? name.toLowerCase() : void 0;
  }
  static _valueHasChanged(value2, old, hasChanged = notEqual) {
    return hasChanged(value2, old);
  }
  static _propertyValueFromAttribute(value2, options2) {
    const type2 = options2.type;
    const converter = options2.converter || defaultConverter;
    const fromAttribute = typeof converter === "function" ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value2, type2) : value2;
  }
  static _propertyValueToAttribute(value2, options2) {
    if (options2.reflect === void 0) {
      return;
    }
    const type2 = options2.type;
    const converter = options2.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value2, type2);
  }
  initialize() {
    this._updateState = 0;
    this._updatePromise = new Promise((res2) => this._enableUpdatingResolver = res2);
    this._changedProperties = /* @__PURE__ */ new Map();
    this._saveInstanceProperties();
    this.requestUpdateInternal();
  }
  _saveInstanceProperties() {
    this.constructor._classProperties.forEach((_v, p2) => {
      if (this.hasOwnProperty(p2)) {
        const value2 = this[p2];
        delete this[p2];
        if (!this._instanceProperties) {
          this._instanceProperties = /* @__PURE__ */ new Map();
        }
        this._instanceProperties.set(p2, value2);
      }
    });
  }
  _applyInstanceProperties() {
    this._instanceProperties.forEach((v, p2) => this[p2] = v);
    this._instanceProperties = void 0;
  }
  connectedCallback() {
    this.enableUpdating();
  }
  enableUpdating() {
    if (this._enableUpdatingResolver !== void 0) {
      this._enableUpdatingResolver();
      this._enableUpdatingResolver = void 0;
    }
  }
  disconnectedCallback() {
  }
  attributeChangedCallback(name, old, value2) {
    if (old !== value2) {
      this._attributeToProperty(name, value2);
    }
  }
  _propertyToAttribute(name, value2, options2 = defaultPropertyDeclaration) {
    const ctor = this.constructor;
    const attr2 = ctor._attributeNameForProperty(name, options2);
    if (attr2 !== void 0) {
      const attrValue = ctor._propertyValueToAttribute(value2, options2);
      if (attrValue === void 0) {
        return;
      }
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;
      if (attrValue == null) {
        this.removeAttribute(attr2);
      } else {
        this.setAttribute(attr2, attrValue);
      }
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }
  _attributeToProperty(name, value2) {
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }
    const ctor = this.constructor;
    const propName = ctor._attributeToPropertyMap.get(name);
    if (propName !== void 0) {
      const options2 = ctor.getPropertyOptions(propName);
      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = ctor._propertyValueFromAttribute(value2, options2);
      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  requestUpdateInternal(name, oldValue, options2) {
    let shouldRequestUpdate = true;
    if (name !== void 0) {
      const ctor = this.constructor;
      options2 = options2 || ctor.getPropertyOptions(name);
      if (ctor._valueHasChanged(this[name], oldValue, options2.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        }
        if (options2.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === void 0) {
            this._reflectingProperties = /* @__PURE__ */ new Map();
          }
          this._reflectingProperties.set(name, options2);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._updatePromise = this._enqueueUpdate();
    }
  }
  requestUpdate(name, oldValue) {
    this.requestUpdateInternal(name, oldValue);
    return this.updateComplete;
  }
  async _enqueueUpdate() {
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    try {
      await this._updatePromise;
    } catch (e) {
    }
    const result2 = this.performUpdate();
    if (result2 != null) {
      await result2;
    }
    return !this._hasRequestedUpdate;
  }
  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }
  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  performUpdate() {
    if (!this._hasRequestedUpdate) {
      return;
    }
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }
    let shouldUpdate = false;
    const changedProperties = this._changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.update(changedProperties);
      } else {
        this._markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this._markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
  }
  _markUpdated() {
    this._changedProperties = /* @__PURE__ */ new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  get updateComplete() {
    return this._getUpdateComplete();
  }
  _getUpdateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this._reflectingProperties !== void 0 && this._reflectingProperties.size > 0) {
      this._reflectingProperties.forEach((v, k2) => this._propertyToAttribute(k2, this[k2], v));
      this._reflectingProperties = void 0;
    }
    this._markUpdated();
  }
  updated(_changedProperties) {
  }
  firstUpdated(_changedProperties) {
  }
}
_a = finalized;
UpdatingElement[_a] = true;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz);
  return clazz;
};
const standardCustomElement = (tagName, descriptor) => {
  const { kind, elements: elements2 } = descriptor;
  return {
    kind,
    elements: elements2,
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }
  };
};
const customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === "function" ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
const standardProperty = (options2, element2) => {
  if (element2.kind === "method" && element2.descriptor && !("value" in element2.descriptor)) {
    return Object.assign(Object.assign({}, element2), { finisher(clazz) {
      clazz.createProperty(element2.key, options2);
    } });
  } else {
    return {
      kind: "field",
      key: Symbol(),
      placement: "own",
      descriptor: {},
      initializer() {
        if (typeof element2.initializer === "function") {
          this[element2.key] = element2.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element2.key, options2);
      }
    };
  }
};
const legacyProperty = (options2, proto, name) => {
  proto.constructor.createProperty(name, options2);
};
function property(options2) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyProperty(options2, protoOrDescriptor, name) : standardProperty(options2, protoOrDescriptor);
}
function internalProperty(options2) {
  return property({ attribute: false, hasChanged: options2 === null || options2 === void 0 ? void 0 : options2.hasChanged });
}
const state = (options2) => internalProperty(options2);
function query(selector, cache2) {
  return (protoOrDescriptor, name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelector(selector);
      },
      enumerable: true,
      configurable: true
    };
    if (cache2) {
      const prop = name !== void 0 ? name : protoOrDescriptor.key;
      const key = typeof prop === "symbol" ? Symbol() : `__${prop}`;
      descriptor.get = function() {
        if (this[key] === void 0) {
          this[key] = this.renderRoot.querySelector(selector);
        }
        return this[key];
      };
    }
    return name !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
function queryAsync(selector) {
  return (protoOrDescriptor, name) => {
    const descriptor = {
      async get() {
        await this.updateComplete;
        return this.renderRoot.querySelector(selector);
      },
      enumerable: true,
      configurable: true
    };
    return name !== void 0 ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
const legacyQuery = (descriptor, proto, name) => {
  Object.defineProperty(proto, name, descriptor);
};
const standardQuery = (descriptor, element2) => ({
  kind: "method",
  placement: "prototype",
  key: element2.key,
  descriptor
});
const standardEventOptions = (options2, element2) => {
  return Object.assign(Object.assign({}, element2), { finisher(clazz) {
    Object.assign(clazz.prototype[element2.key], options2);
  } });
};
const legacyEventOptions = (options2, proto, name) => {
  Object.assign(proto[name], options2);
};
function eventOptions(options2) {
  return (protoOrDescriptor, name) => name !== void 0 ? legacyEventOptions(options2, protoOrDescriptor, name) : standardEventOptions(options2, protoOrDescriptor);
}
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = window.ShadowRoot && (window.ShadyCSS === void 0 || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
const constructionToken = Symbol();
class CSSResult {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    }
    this.cssText = cssText;
  }
  get styleSheet() {
    if (this._styleSheet === void 0) {
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();
        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }
    return this._styleSheet;
  }
  toString() {
    return this.cssText;
  }
}
const unsafeCSS = (value2) => {
  return new CSSResult(String(value2), constructionToken);
};
const textFromCSSResult = (value2) => {
  if (value2 instanceof CSSResult) {
    return value2.cssText;
  } else if (typeof value2 === "number") {
    return value2;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value2}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
const css$2 = (strings2, ...values) => {
  const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings2[idx + 1], strings2[0]);
  return new CSSResult(cssText, constructionToken);
};
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
(window["litElementVersions"] || (window["litElementVersions"] = [])).push("2.5.1");
const renderNotImplemented = {};
class LitElement extends UpdatingElement {
  static getStyles() {
    return this.styles;
  }
  static _getUniqueStyles() {
    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) {
      return;
    }
    const userStyles = this.getStyles();
    if (Array.isArray(userStyles)) {
      const addStyles = (styles3, set22) => styles3.reduceRight((set3, s) => Array.isArray(s) ? addStyles(s, set3) : (set3.add(s), set3), set22);
      const set2 = addStyles(userStyles, /* @__PURE__ */ new Set());
      const styles2 = [];
      set2.forEach((v) => styles2.unshift(v));
      this._styles = styles2;
    } else {
      this._styles = userStyles === void 0 ? [] : [userStyles];
    }
    this._styles = this._styles.map((s) => {
      if (s instanceof CSSStyleSheet && !supportsAdoptingStyleSheets) {
        const cssText = Array.prototype.slice.call(s.cssRules).reduce((css2, rule) => css2 + rule.cssText, "");
        return unsafeCSS(cssText);
      }
      return s;
    });
  }
  initialize() {
    super.initialize();
    this.constructor._getUniqueStyles();
    this.renderRoot = this.createRenderRoot();
    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  createRenderRoot() {
    return this.attachShadow(this.constructor.shadowRootOptions);
  }
  adoptStyles() {
    const styles2 = this.constructor._styles;
    if (styles2.length === 0) {
      return;
    }
    if (window.ShadyCSS !== void 0 && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles2.map((s) => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles2.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);
    } else {
      this._needsShimAdoptedStyleSheets = true;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.hasUpdated && window.ShadyCSS !== void 0) {
      window.ShadyCSS.styleElement(this);
    }
  }
  update(changedProperties) {
    const templateResult = this.render();
    super.update(changedProperties);
    if (templateResult !== renderNotImplemented) {
      this.constructor.render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });
    }
    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;
      this.constructor._styles.forEach((s) => {
        const style = document.createElement("style");
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  render() {
    return renderNotImplemented;
  }
}
LitElement["finalized"] = true;
LitElement.render = render;
LitElement.shadowRootOptions = { mode: "open" };
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function addHasRemoveClass(element2) {
  return {
    addClass: (className) => {
      element2.classList.add(className);
    },
    removeClass: (className) => {
      element2.classList.remove(className);
    },
    hasClass: (className) => element2.classList.contains(className)
  };
}
const fn = () => {
};
const optionsBlock = {
  get passive() {
    return false;
  }
};
document.addEventListener("x", fn, optionsBlock);
document.removeEventListener("x", fn);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class BaseElement extends LitElement {
  click() {
    if (this.mdcRoot) {
      this.mdcRoot.focus();
      this.mdcRoot.click();
      return;
    }
    super.click();
  }
  createFoundation() {
    if (this.mdcFoundation !== void 0) {
      this.mdcFoundation.destroy();
    }
    if (this.mdcFoundationClass) {
      this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter());
      this.mdcFoundation.init();
    }
  }
  firstUpdated() {
    this.createFoundation();
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const observer = (observer2) => (proto, propName) => {
  if (!proto.constructor._observers) {
    proto.constructor._observers = /* @__PURE__ */ new Map();
    const userUpdated = proto.updated;
    proto.updated = function(changedProperties) {
      userUpdated.call(this, changedProperties);
      changedProperties.forEach((v, k2) => {
        const observers = this.constructor._observers;
        const observer3 = observers.get(k2);
        if (observer3 !== void 0) {
          observer3.call(this, this[k2], v);
        }
      });
    };
  } else if (!proto.constructor.hasOwnProperty("_observers")) {
    const observers = proto.constructor._observers;
    proto.constructor._observers = /* @__PURE__ */ new Map();
    observers.forEach((v, k2) => proto.constructor._observers.set(k2, v));
  }
  proto.constructor._observers.set(propName, observer2);
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = function() {
  function MDCFoundation2(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }
    this.adapter = adapter;
  }
  Object.defineProperty(MDCFoundation2, "cssClasses", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "strings", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "numbers", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "defaultAdapter", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  MDCFoundation2.prototype.init = function() {
  };
  MDCFoundation2.prototype.destroy = function() {
  };
  return MDCFoundation2;
}();
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$2 = {
  CLOSING: "mdc-snackbar--closing",
  OPEN: "mdc-snackbar--open",
  OPENING: "mdc-snackbar--opening"
};
var strings$2 = {
  ACTION_SELECTOR: ".mdc-snackbar__action",
  ARIA_LIVE_LABEL_TEXT_ATTR: "data-mdc-snackbar-label-text",
  CLOSED_EVENT: "MDCSnackbar:closed",
  CLOSING_EVENT: "MDCSnackbar:closing",
  DISMISS_SELECTOR: ".mdc-snackbar__dismiss",
  LABEL_SELECTOR: ".mdc-snackbar__label",
  OPENED_EVENT: "MDCSnackbar:opened",
  OPENING_EVENT: "MDCSnackbar:opening",
  REASON_ACTION: "action",
  REASON_DISMISS: "dismiss",
  SURFACE_SELECTOR: ".mdc-snackbar__surface"
};
var numbers$2 = {
  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5e3,
  INDETERMINATE: -1,
  MAX_AUTO_DISMISS_TIMEOUT_MS: 1e4,
  MIN_AUTO_DISMISS_TIMEOUT_MS: 4e3,
  SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
  SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
  ARIA_LIVE_DELAY_MS: 1e3
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var OPENING = cssClasses$2.OPENING, OPEN = cssClasses$2.OPEN, CLOSING = cssClasses$2.CLOSING;
var REASON_ACTION = strings$2.REASON_ACTION, REASON_DISMISS = strings$2.REASON_DISMISS;
var MDCSnackbarFoundation = function(_super) {
  __extends(MDCSnackbarFoundation2, _super);
  function MDCSnackbarFoundation2(adapter) {
    var _this = _super.call(this, __assign$3(__assign$3({}, MDCSnackbarFoundation2.defaultAdapter), adapter)) || this;
    _this.opened = false;
    _this.animationFrame = 0;
    _this.animationTimer = 0;
    _this.autoDismissTimer = 0;
    _this.autoDismissTimeoutMs = numbers$2.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
    _this.closeOnEscape = true;
    return _this;
  }
  Object.defineProperty(MDCSnackbarFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "strings", {
    get: function() {
      return strings$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "numbers", {
    get: function() {
      return numbers$2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        announce: function() {
          return void 0;
        },
        notifyClosed: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        },
        notifyOpened: function() {
          return void 0;
        },
        notifyOpening: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSnackbarFoundation2.prototype.destroy = function() {
    this.clearAutoDismissTimer();
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    clearTimeout(this.animationTimer);
    this.animationTimer = 0;
    this.adapter.removeClass(OPENING);
    this.adapter.removeClass(OPEN);
    this.adapter.removeClass(CLOSING);
  };
  MDCSnackbarFoundation2.prototype.open = function() {
    var _this = this;
    this.clearAutoDismissTimer();
    this.opened = true;
    this.adapter.notifyOpening();
    this.adapter.removeClass(CLOSING);
    this.adapter.addClass(OPENING);
    this.adapter.announce();
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(OPEN);
      _this.animationTimer = setTimeout(function() {
        var timeoutMs = _this.getTimeoutMs();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyOpened();
        if (timeoutMs !== numbers$2.INDETERMINATE) {
          _this.autoDismissTimer = setTimeout(function() {
            _this.close(REASON_DISMISS);
          }, timeoutMs);
        }
      }, numbers$2.SNACKBAR_ANIMATION_OPEN_TIME_MS);
    });
  };
  MDCSnackbarFoundation2.prototype.close = function(reason) {
    var _this = this;
    if (reason === void 0) {
      reason = "";
    }
    if (!this.opened) {
      return;
    }
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    this.clearAutoDismissTimer();
    this.opened = false;
    this.adapter.notifyClosing(reason);
    this.adapter.addClass(cssClasses$2.CLOSING);
    this.adapter.removeClass(cssClasses$2.OPEN);
    this.adapter.removeClass(cssClasses$2.OPENING);
    clearTimeout(this.animationTimer);
    this.animationTimer = setTimeout(function() {
      _this.handleAnimationTimerEnd();
      _this.adapter.notifyClosed(reason);
    }, numbers$2.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
  };
  MDCSnackbarFoundation2.prototype.isOpen = function() {
    return this.opened;
  };
  MDCSnackbarFoundation2.prototype.getTimeoutMs = function() {
    return this.autoDismissTimeoutMs;
  };
  MDCSnackbarFoundation2.prototype.setTimeoutMs = function(timeoutMs) {
    var minValue = numbers$2.MIN_AUTO_DISMISS_TIMEOUT_MS;
    var maxValue = numbers$2.MAX_AUTO_DISMISS_TIMEOUT_MS;
    var indeterminateValue = numbers$2.INDETERMINATE;
    if (timeoutMs === numbers$2.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
      this.autoDismissTimeoutMs = timeoutMs;
    } else {
      throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "\u2013" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
    }
  };
  MDCSnackbarFoundation2.prototype.getCloseOnEscape = function() {
    return this.closeOnEscape;
  };
  MDCSnackbarFoundation2.prototype.setCloseOnEscape = function(closeOnEscape) {
    this.closeOnEscape = closeOnEscape;
  };
  MDCSnackbarFoundation2.prototype.handleKeyDown = function(evt) {
    var isEscapeKey = evt.key === "Escape" || evt.keyCode === 27;
    if (isEscapeKey && this.getCloseOnEscape()) {
      this.close(REASON_DISMISS);
    }
  };
  MDCSnackbarFoundation2.prototype.handleActionButtonClick = function(_evt) {
    this.close(REASON_ACTION);
  };
  MDCSnackbarFoundation2.prototype.handleActionIconClick = function(_evt) {
    this.close(REASON_DISMISS);
  };
  MDCSnackbarFoundation2.prototype.clearAutoDismissTimer = function() {
    clearTimeout(this.autoDismissTimer);
    this.autoDismissTimer = 0;
  };
  MDCSnackbarFoundation2.prototype.handleAnimationTimerEnd = function() {
    this.animationTimer = 0;
    this.adapter.removeClass(cssClasses$2.OPENING);
    this.adapter.removeClass(cssClasses$2.CLOSING);
  };
  MDCSnackbarFoundation2.prototype.runNextAnimationFrame = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(function() {
      _this.animationFrame = 0;
      clearTimeout(_this.animationTimer);
      _this.animationTimer = setTimeout(callback, 0);
    });
  };
  return MDCSnackbarFoundation2;
}(MDCFoundation);
var MDCSnackbarFoundation$1 = MDCSnackbarFoundation;
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class ClassList {
  constructor(element2) {
    this.classes = /* @__PURE__ */ new Set();
    this.changed = false;
    this.element = element2;
    const classList = (element2.getAttribute("class") || "").split(/\s+/);
    for (const cls of classList) {
      this.classes.add(cls);
    }
  }
  add(cls) {
    this.classes.add(cls);
    this.changed = true;
  }
  remove(cls) {
    this.classes.delete(cls);
    this.changed = true;
  }
  commit() {
    if (this.changed) {
      let classString = "";
      this.classes.forEach((cls) => classString += cls + " ");
      this.element.setAttribute("class", classString);
    }
  }
}
const previousClassesCache = /* @__PURE__ */ new WeakMap();
const classMap = directive$1((classInfo) => (part) => {
  if (!(part instanceof AttributePart$1) || part instanceof PropertyPart || part.committer.name !== "class" || part.committer.parts.length > 1) {
    throw new Error("The `classMap` directive must be used in the `class` attribute and must be the only part in the attribute.");
  }
  const { committer } = part;
  const { element: element2 } = committer;
  let previousClasses = previousClassesCache.get(part);
  if (previousClasses === void 0) {
    element2.setAttribute("class", committer.strings.join(" "));
    previousClassesCache.set(part, previousClasses = /* @__PURE__ */ new Set());
  }
  const classList = element2.classList || new ClassList(element2);
  previousClasses.forEach((name) => {
    if (!(name in classInfo)) {
      classList.remove(name);
      previousClasses.delete(name);
    }
  });
  for (const name in classInfo) {
    const value2 = classInfo[name];
    if (value2 != previousClasses.has(name)) {
      if (value2) {
        classList.add(name);
        previousClasses.add(name);
      } else {
        classList.remove(name);
        previousClasses.delete(name);
      }
    }
  }
  if (typeof classList.commit === "function") {
    classList.commit();
  }
});
/**
 * @license
 * Copyright (c) 2021 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
class ChildPart {
  constructor(legacyPart) {
    this.type = PartType.CHILD;
    this.options = legacyPart.options;
    this.legacyPart = legacyPart;
  }
  get parentNode() {
    return this.legacyPart.startNode.parentNode;
  }
  get startNode() {
    return this.legacyPart.startNode;
  }
  get endNode() {
    return this.legacyPart.endNode;
  }
}
class AttributePart {
  constructor(legacyPart) {
    this.legacyPart = legacyPart;
    this.type = legacyPart instanceof PropertyPart ? PartType.PROPERTY : PartType.ATTRIBUTE;
  }
  get options() {
    return void 0;
  }
  get name() {
    return this.legacyPart.committer.name;
  }
  get element() {
    return this.legacyPart.committer.element;
  }
  get strings() {
    return this.legacyPart.committer.strings;
  }
  get tagName() {
    return this.element.tagName;
  }
}
class BooleanAttributePart {
  constructor(legacyPart) {
    this.type = PartType.BOOLEAN_ATTRIBUTE;
    this.legacyPart = legacyPart;
  }
  get options() {
    return void 0;
  }
  get name() {
    return this.legacyPart.name;
  }
  get element() {
    return this.legacyPart.element;
  }
  get strings() {
    return this.legacyPart.strings;
  }
  get tagName() {
    return this.element.tagName;
  }
}
class EventPart {
  constructor(legacyPart) {
    this.type = PartType.EVENT;
    this.legacyPart = legacyPart;
  }
  get options() {
    return void 0;
  }
  get name() {
    return this.legacyPart.eventName;
  }
  get element() {
    return this.legacyPart.element;
  }
  get strings() {
    return void 0;
  }
  get tagName() {
    return this.element.tagName;
  }
  handleEvent(event2) {
    this.legacyPart.handleEvent(event2);
  }
}
function legacyPartToPart(part) {
  if (part instanceof NodePart) {
    return new ChildPart(part);
  } else if (part instanceof EventPart$1) {
    return new EventPart(part);
  } else if (part instanceof BooleanAttributePart$1) {
    return new BooleanAttributePart(part);
  } else if (part instanceof PropertyPart || part instanceof AttributePart$1) {
    return new AttributePart(part);
  }
  throw new Error(`Unknown part type`);
}
class Directive {
  constructor(_partInfo) {
  }
  update(_part, args2) {
    return this.render(...args2);
  }
}
function directive(directiveClass) {
  const partToInstance = /* @__PURE__ */ new WeakMap();
  const result2 = directive$1((...args2) => {
    return (part) => {
      const cached = partToInstance.get(part);
      let modernPart, instance2;
      if (cached === void 0) {
        modernPart = legacyPartToPart(part);
        instance2 = new directiveClass(modernPart);
        partToInstance.set(part, [modernPart, instance2]);
      } else {
        modernPart = cached[0];
        instance2 = cached[1];
      }
      part.setValue(instance2.update(modernPart, args2));
      part.commit();
    };
  });
  return result2;
}
/**
 * @license
 * Copyright (c) 2021 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
class AsyncDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._renderedYet = false;
    this._legacyPart = partInfo.legacyPart;
  }
  _legacyGetNode() {
    if (this._legacyPart instanceof NodePart) {
      return this._legacyPart.startNode;
    } else if (this._legacyPart instanceof EventPart$1) {
      return this._legacyPart.element;
    } else if (this._legacyPart instanceof BooleanAttributePart$1) {
      return this._legacyPart.element;
    } else if (this._legacyPart instanceof PropertyPart || this._legacyPart instanceof AttributePart$1) {
      return this._legacyPart.committer.element;
    }
    return void 0;
  }
  _shouldRender() {
    if (!this._renderedYet) {
      this._renderedYet = true;
      return true;
    }
    const node = this._legacyGetNode();
    return !!(node === null || node === void 0 ? void 0 : node.isConnected);
  }
  setValue(value2) {
    if (!this._shouldRender()) {
      return;
    }
    this._legacyPart.setValue(value2);
    this._legacyPart.commit();
  }
  disconnected() {
  }
  reconnected() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const { ARIA_LIVE_DELAY_MS } = MDCSnackbarFoundation$1.numbers;
class AccessibleSnackbarLabel extends AsyncDirective {
  constructor(partInfo) {
    super(partInfo);
    this.labelEl = null;
    this.timerId = null;
    this.previousPart = null;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error("AccessibleSnackbarLabel only supports child parts.");
    }
  }
  update(part, [labelText, isOpen]) {
    var _a2;
    if (!isOpen) {
      return;
    }
    if (this.labelEl === null) {
      const wrapperEl = document.createElement("div");
      const labelTemplate = html$2`<div class="mdc-snackbar__label" role="status" aria-live="polite">${labelText}</div>`;
      render$1(labelTemplate, wrapperEl);
      const labelEl2 = wrapperEl.firstElementChild;
      (_a2 = part.endNode) === null || _a2 === void 0 ? void 0 : _a2.parentNode.insertBefore(labelEl2, part.endNode);
      this.labelEl = labelEl2;
      return labelEl2;
    }
    const labelEl = this.labelEl;
    labelEl.setAttribute("aria-live", "off");
    labelEl.textContent = "";
    const spaceTemplate = html$2`<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>`;
    render$1(spaceTemplate, labelEl);
    labelEl.setAttribute("data-mdc-snackbar-label-text", labelText);
    if (this.timerId !== null) {
      clearTimeout(this.timerId);
    }
    this.timerId = window.setTimeout(() => {
      this.timerId = null;
      labelEl.setAttribute("aria-live", "polite");
      labelEl.removeAttribute("data-mdc-snackbar-label-text");
      labelEl.textContent = labelText;
      this.setValue(this.labelEl);
    }, ARIA_LIVE_DELAY_MS);
    return labelEl;
  }
  render(labelText, isOpen) {
    if (!isOpen) {
      return html$2``;
    }
    return html$2`
      <div class="mdc-snackbar__label" role="status" aria-live="polite">${labelText}</div>`;
  }
}
const accessibleSnackbarLabel = directive(AccessibleSnackbarLabel);
const { OPENING_EVENT, OPENED_EVENT, CLOSING_EVENT, CLOSED_EVENT } = MDCSnackbarFoundation$1.strings;
class SnackbarBase extends BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = MDCSnackbarFoundation$1;
    this.open = false;
    this.timeoutMs = 5e3;
    this.closeOnEscape = false;
    this.labelText = "";
    this.stacked = false;
    this.leading = false;
    this.reason = "";
  }
  render() {
    const classes = {
      "mdc-snackbar--stacked": this.stacked,
      "mdc-snackbar--leading": this.leading
    };
    return html$2`
      <div class="mdc-snackbar ${classMap(classes)}" @keydown="${this._handleKeydown}">
        <div class="mdc-snackbar__surface">
          ${accessibleSnackbarLabel(this.labelText, this.open)}
          <div class="mdc-snackbar__actions">
            <slot name="action" @click="${this._handleActionClick}"></slot>
            <slot name="dismiss" @click="${this._handleDismissClick}"></slot>
          </div>
        </div>
      </div>`;
  }
  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { announce: () => {
    }, notifyClosed: (reason) => {
      this.dispatchEvent(new CustomEvent(CLOSED_EVENT, { bubbles: true, cancelable: true, detail: { reason } }));
    }, notifyClosing: (reason) => {
      this.open = false;
      this.dispatchEvent(new CustomEvent(CLOSING_EVENT, { bubbles: true, cancelable: true, detail: { reason } }));
    }, notifyOpened: () => {
      this.dispatchEvent(new CustomEvent(OPENED_EVENT, { bubbles: true, cancelable: true }));
    }, notifyOpening: () => {
      this.open = true;
      this.dispatchEvent(new CustomEvent(OPENING_EVENT, { bubbles: true, cancelable: true }));
    } });
  }
  show() {
    this.open = true;
  }
  close(reason = "") {
    this.reason = reason;
    this.open = false;
  }
  firstUpdated() {
    super.firstUpdated();
    if (this.open) {
      this.mdcFoundation.open();
    }
  }
  _handleKeydown(e) {
    this.mdcFoundation.handleKeyDown(e);
  }
  _handleActionClick(e) {
    this.mdcFoundation.handleActionButtonClick(e);
  }
  _handleDismissClick(e) {
    this.mdcFoundation.handleActionIconClick(e);
  }
}
__decorate([
  query(".mdc-snackbar")
], SnackbarBase.prototype, "mdcRoot", void 0);
__decorate([
  query(".mdc-snackbar__label")
], SnackbarBase.prototype, "labelElement", void 0);
__decorate([
  property({ type: Boolean, reflect: true }),
  observer(function(value2) {
    if (this.mdcFoundation) {
      if (value2) {
        this.mdcFoundation.open();
      } else {
        this.mdcFoundation.close(this.reason);
        this.reason = "";
      }
    }
  })
], SnackbarBase.prototype, "open", void 0);
__decorate([
  observer(function(value2) {
    this.mdcFoundation.setTimeoutMs(value2);
  }),
  property({ type: Number })
], SnackbarBase.prototype, "timeoutMs", void 0);
__decorate([
  observer(function(value2) {
    this.mdcFoundation.setCloseOnEscape(value2);
  }),
  property({ type: Boolean })
], SnackbarBase.prototype, "closeOnEscape", void 0);
__decorate([
  property({ type: String })
], SnackbarBase.prototype, "labelText", void 0);
__decorate([
  property({ type: Boolean })
], SnackbarBase.prototype, "stacked", void 0);
__decorate([
  property({ type: Boolean })
], SnackbarBase.prototype, "leading", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles$4 = css$2`.mdc-snackbar{z-index:8;margin:8px;display:none;position:fixed;right:0;bottom:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;pointer-events:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-snackbar__surface{background-color:#333333}.mdc-snackbar__label{color:rgba(255, 255, 255, 0.87)}.mdc-snackbar__surface{min-width:344px}@media(max-width: 480px),(max-width: 344px){.mdc-snackbar__surface{min-width:100%}}.mdc-snackbar__surface{max-width:672px}.mdc-snackbar__surface{box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2),0px 6px 10px 0px rgba(0, 0, 0, 0.14),0px 1px 18px 0px rgba(0,0,0,.12)}.mdc-snackbar__surface{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-snackbar--opening,.mdc-snackbar--open,.mdc-snackbar--closing{display:flex}.mdc-snackbar--open .mdc-snackbar__label,.mdc-snackbar--open .mdc-snackbar__actions{visibility:visible}.mdc-snackbar--leading{justify-content:flex-start}.mdc-snackbar--stacked .mdc-snackbar__label{padding-left:16px;padding-right:8px;padding-bottom:12px}[dir=rtl] .mdc-snackbar--stacked .mdc-snackbar__label,.mdc-snackbar--stacked .mdc-snackbar__label[dir=rtl]{padding-left:8px;padding-right:16px}.mdc-snackbar--stacked .mdc-snackbar__surface{flex-direction:column;align-items:flex-start}.mdc-snackbar--stacked .mdc-snackbar__actions{align-self:flex-end;margin-bottom:8px}.mdc-snackbar__surface{padding-left:0;padding-right:8px;display:flex;align-items:center;justify-content:flex-start;box-sizing:border-box;transform:scale(0.8);opacity:0}.mdc-snackbar__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid transparent;border-radius:inherit;content:"";pointer-events:none}[dir=rtl] .mdc-snackbar__surface,.mdc-snackbar__surface[dir=rtl]{padding-left:8px;padding-right:0}.mdc-snackbar--open .mdc-snackbar__surface{transform:scale(1);opacity:1;pointer-events:auto;transition:opacity 150ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-snackbar--closing .mdc-snackbar__surface{transform:scale(1);transition:opacity 75ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-snackbar__label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-body2-font-size, 0.875rem);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight, 400);letter-spacing:0.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing, 0.0178571429em);text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform, inherit);padding-left:16px;padding-right:8px;width:100%;flex-grow:1;box-sizing:border-box;margin:0;visibility:hidden;padding-top:14px;padding-bottom:14px}[dir=rtl] .mdc-snackbar__label,.mdc-snackbar__label[dir=rtl]{padding-left:8px;padding-right:16px}.mdc-snackbar__label::before{display:inline;content:attr(data-mdc-snackbar-label-text)}.mdc-snackbar__actions{display:flex;flex-shrink:0;align-items:center;box-sizing:border-box;visibility:hidden}.mdc-snackbar__action:not(:disabled){color:#bb86fc}.mdc-snackbar__action::before,.mdc-snackbar__action::after{background-color:#bb86fc;background-color:var(--mdc-ripple-color, #bb86fc)}.mdc-snackbar__action:hover::before,.mdc-snackbar__action.mdc-ripple-surface--hover::before{opacity:0.08;opacity:var(--mdc-ripple-hover-opacity, 0.08)}.mdc-snackbar__action.mdc-ripple-upgraded--background-focused::before,.mdc-snackbar__action:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-snackbar__action:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-snackbar__action:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-snackbar__action.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-snackbar__dismiss{color:rgba(255, 255, 255, 0.87)}.mdc-snackbar__dismiss .mdc-icon-button__ripple::before,.mdc-snackbar__dismiss .mdc-icon-button__ripple::after{background-color:rgba(255, 255, 255, 0.87);background-color:var(--mdc-ripple-color, rgba(255, 255, 255, 0.87))}.mdc-snackbar__dismiss:hover .mdc-icon-button__ripple::before,.mdc-snackbar__dismiss.mdc-ripple-surface--hover .mdc-icon-button__ripple::before{opacity:0.08;opacity:var(--mdc-ripple-hover-opacity, 0.08)}.mdc-snackbar__dismiss.mdc-ripple-upgraded--background-focused .mdc-icon-button__ripple::before,.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):focus .mdc-icon-button__ripple::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded) .mdc-icon-button__ripple::after{transition:opacity 150ms linear}.mdc-snackbar__dismiss:not(.mdc-ripple-upgraded):active .mdc-icon-button__ripple::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-snackbar__dismiss.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-snackbar__dismiss.mdc-snackbar__dismiss{width:36px;height:36px;padding:6px;font-size:18px}.mdc-snackbar__action+.mdc-snackbar__dismiss{margin-left:8px;margin-right:0}[dir=rtl] .mdc-snackbar__action+.mdc-snackbar__dismiss,.mdc-snackbar__action+.mdc-snackbar__dismiss[dir=rtl]{margin-left:0;margin-right:8px}slot[name=action]::slotted(mwc-button){--mdc-theme-primary: var( --mdc-snackbar-action-color, #bb86fc )}slot[name=dismiss]::slotted(mwc-icon-button){--mdc-icon-size: 18px;--mdc-icon-button-size: 36px;color:rgba(255, 255, 255, 0.87);margin-left:8px;margin-right:0}[dir=rtl] slot[name=dismiss]::slotted(mwc-icon-button),::slotted(mwc-icon-buttonslot[name=dismiss][dir=rtl]){margin-left:0;margin-right:8px}`;
let Snackbar = class Snackbar2 extends SnackbarBase {
};
Snackbar.styles = [styles$4];
Snackbar = __decorate([
  customElement("mwc-snackbar")
], Snackbar);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles$3 = css$2`:host{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}`;
let Icon = class Icon2 extends LitElement {
  render() {
    return html$2`<slot></slot>`;
  }
};
Icon.styles = [styles$3];
Icon = __decorate([
  customElement("mwc-icon")
], Icon);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function closest$1(element2, selector) {
  if (element2.closest) {
    return element2.closest(selector);
  }
  var el2 = element2;
  while (el2) {
    if (matches$1(el2, selector)) {
      return el2;
    }
    el2 = el2.parentElement;
  }
  return null;
}
function matches$1(element2, selector) {
  var nativeMatches = element2.matches || element2.webkitMatchesSelector || element2.msMatchesSelector;
  return nativeMatches.call(element2, selector);
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings$1 = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers$1 = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x2 = pageOffset.x, y2 = pageOffset.y;
  var documentX = x2 + clientRect.left;
  var documentY = y2 + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = function(_super) {
  __extends(MDCRippleFoundation2, _super);
  function MDCRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign$3(__assign$3({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.activationAnimationHasEnded = false;
    _this.activationTimer = 0;
    _this.fgDeactivationRemovalTimer = 0;
    _this.fgScale = "0";
    _this.frame = { width: 0, height: 0 };
    _this.initialSize = 0;
    _this.layoutFrame = 0;
    _this.maxRadius = 0;
    _this.unboundedCoords = { left: 0, top: 0 };
    _this.activationState = _this.defaultActivationState();
    _this.activationTimerCallback = function() {
      _this.activationAnimationHasEnded = true;
      _this.runDeactivationUXLogicIfReady();
    };
    _this.activateHandler = function(e) {
      _this.activateImpl(e);
    };
    _this.deactivateHandler = function() {
      _this.deactivateImpl();
    };
    _this.focusHandler = function() {
      _this.handleFocus();
    };
    _this.blurHandler = function() {
      _this.handleBlur();
    };
    _this.resizeHandler = function() {
      _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "strings", {
    get: function() {
      return strings$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "numbers", {
    get: function() {
      return numbers$1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        browserSupportsCssVars: function() {
          return true;
        },
        computeBoundingRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        containsEventTarget: function() {
          return true;
        },
        deregisterDocumentInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        deregisterResizeHandler: function() {
          return void 0;
        },
        getWindowPageOffset: function() {
          return { x: 0, y: 0 };
        },
        isSurfaceActive: function() {
          return true;
        },
        isSurfaceDisabled: function() {
          return true;
        },
        isUnbounded: function() {
          return true;
        },
        registerDocumentInteractionHandler: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        registerResizeHandler: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        updateCssVariable: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCRippleFoundation2.prototype.init = function() {
    var _this = this;
    var supportsPressRipple = this.supportsPressRipple();
    this.registerRootHandlers(supportsPressRipple);
    if (supportsPressRipple) {
      var _a2 = MDCRippleFoundation2.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.addClass(ROOT_1);
        if (_this.adapter.isUnbounded()) {
          _this.adapter.addClass(UNBOUNDED_1);
          _this.layoutInternal();
        }
      });
    }
  };
  MDCRippleFoundation2.prototype.destroy = function() {
    var _this = this;
    if (this.supportsPressRipple()) {
      if (this.activationTimer) {
        clearTimeout(this.activationTimer);
        this.activationTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
      }
      if (this.fgDeactivationRemovalTimer) {
        clearTimeout(this.fgDeactivationRemovalTimer);
        this.fgDeactivationRemovalTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
      }
      var _a2 = MDCRippleFoundation2.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.removeClass(ROOT_2);
        _this.adapter.removeClass(UNBOUNDED_2);
        _this.removeCssVars();
      });
    }
    this.deregisterRootHandlers();
    this.deregisterDeactivationHandlers();
  };
  MDCRippleFoundation2.prototype.activate = function(evt) {
    this.activateImpl(evt);
  };
  MDCRippleFoundation2.prototype.deactivate = function() {
    this.deactivateImpl();
  };
  MDCRippleFoundation2.prototype.layout = function() {
    var _this = this;
    if (this.layoutFrame) {
      cancelAnimationFrame(this.layoutFrame);
    }
    this.layoutFrame = requestAnimationFrame(function() {
      _this.layoutInternal();
      _this.layoutFrame = 0;
    });
  };
  MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
    var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
    if (unbounded) {
      this.adapter.addClass(UNBOUNDED);
    } else {
      this.adapter.removeClass(UNBOUNDED);
    }
  };
  MDCRippleFoundation2.prototype.handleFocus = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.handleBlur = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.supportsPressRipple = function() {
    return this.adapter.browserSupportsCssVars();
  };
  MDCRippleFoundation2.prototype.defaultActivationState = function() {
    return {
      activationEvent: void 0,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
    var e_1, _a2;
    if (supportsPressRipple) {
      try {
        for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a2 = ACTIVATION_EVENT_TYPES_1.return))
            _a2.call(ACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (this.adapter.isUnbounded()) {
        this.adapter.registerResizeHandler(this.resizeHandler);
      }
    }
    this.adapter.registerInteractionHandler("focus", this.focusHandler);
    this.adapter.registerInteractionHandler("blur", this.blurHandler);
  };
  MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
    var e_2, _a2;
    if (evt.type === "keydown") {
      this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
    } else {
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
            _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  };
  MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
    var e_3, _a2;
    try {
      for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a2 = ACTIVATION_EVENT_TYPES_2.return))
          _a2.call(ACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
    this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
    if (this.adapter.isUnbounded()) {
      this.adapter.deregisterResizeHandler(this.resizeHandler);
    }
  };
  MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
    var e_4, _a2;
    this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
    try {
      for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
          _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  MDCRippleFoundation2.prototype.removeCssVars = function() {
    var _this = this;
    var rippleStrings = MDCRippleFoundation2.strings;
    var keys2 = Object.keys(rippleStrings);
    keys2.forEach(function(key) {
      if (key.indexOf("VAR_") === 0) {
        _this.adapter.updateCssVariable(rippleStrings[key], null);
      }
    });
  };
  MDCRippleFoundation2.prototype.activateImpl = function(evt) {
    var _this = this;
    if (this.adapter.isSurfaceDisabled()) {
      return;
    }
    var activationState = this.activationState;
    if (activationState.isActivated) {
      return;
    }
    var previousActivationEvent = this.previousActivationEvent;
    var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
    if (isSameInteraction) {
      return;
    }
    activationState.isActivated = true;
    activationState.isProgrammatic = evt === void 0;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
    var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
      return _this.adapter.containsEventTarget(target);
    });
    if (hasActivatedChild) {
      this.resetActivationState();
      return;
    }
    if (evt !== void 0) {
      activatedTargets.push(evt.target);
      this.registerDeactivationHandlers(evt);
    }
    activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
    if (activationState.wasElementMadeActive) {
      this.animateActivation();
    }
    requestAnimationFrame(function() {
      activatedTargets = [];
      if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
        activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
        if (activationState.wasElementMadeActive) {
          _this.animateActivation();
        }
      }
      if (!activationState.wasElementMadeActive) {
        _this.activationState = _this.defaultActivationState();
      }
    });
  };
  MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
    return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
  };
  MDCRippleFoundation2.prototype.animateActivation = function() {
    var _this = this;
    var _a2 = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
    var _b = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal();
    var translateStart = "";
    var translateEnd = "";
    if (!this.adapter.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    clearTimeout(this.activationTimer);
    clearTimeout(this.fgDeactivationRemovalTimer);
    this.rmBoundedActivationClasses();
    this.adapter.removeClass(FG_DEACTIVATION);
    this.adapter.computeBoundingRect();
    this.adapter.addClass(FG_ACTIVATION);
    this.activationTimer = setTimeout(function() {
      _this.activationTimerCallback();
    }, DEACTIVATION_TIMEOUT_MS);
  };
  MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
    var _a2 = this.activationState, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
    var startPoint;
    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame.width / 2,
        y: this.frame.height / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize / 2,
      y: startPoint.y - this.initialSize / 2
    };
    var endPoint = {
      x: this.frame.width / 2 - this.initialSize / 2,
      y: this.frame.height / 2 - this.initialSize / 2
    };
    return { startPoint, endPoint };
  };
  MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
    var _this = this;
    var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
    var _a2 = this.activationState, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;
    if (activationHasEnded && this.activationAnimationHasEnded) {
      this.rmBoundedActivationClasses();
      this.adapter.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer = setTimeout(function() {
        _this.adapter.removeClass(FG_DEACTIVATION);
      }, numbers$1.FG_DEACTIVATION_MS);
    }
  };
  MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
    var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
    this.adapter.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded = false;
    this.adapter.computeBoundingRect();
  };
  MDCRippleFoundation2.prototype.resetActivationState = function() {
    var _this = this;
    this.previousActivationEvent = this.activationState.activationEvent;
    this.activationState = this.defaultActivationState();
    setTimeout(function() {
      return _this.previousActivationEvent = void 0;
    }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
  };
  MDCRippleFoundation2.prototype.deactivateImpl = function() {
    var _this = this;
    var activationState = this.activationState;
    if (!activationState.isActivated) {
      return;
    }
    var state2 = __assign$3({}, activationState);
    if (activationState.isProgrammatic) {
      requestAnimationFrame(function() {
        _this.animateDeactivation(state2);
      });
      this.resetActivationState();
    } else {
      this.deregisterDeactivationHandlers();
      requestAnimationFrame(function() {
        _this.activationState.hasDeactivationUXRun = true;
        _this.animateDeactivation(state2);
        _this.resetActivationState();
      });
    }
  };
  MDCRippleFoundation2.prototype.animateDeactivation = function(_a2) {
    var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady();
    }
  };
  MDCRippleFoundation2.prototype.layoutInternal = function() {
    var _this = this;
    this.frame = this.adapter.computeBoundingRect();
    var maxDim = Math.max(this.frame.height, this.frame.width);
    var getBoundedRadius = function() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
      return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
    };
    this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
    var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
    if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
      this.initialSize = initialSize - 1;
    } else {
      this.initialSize = initialSize;
    }
    this.fgScale = "" + this.maxRadius / this.initialSize;
    this.updateLayoutCssVars();
  };
  MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
    var _a2 = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
    this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
    this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
    if (this.adapter.isUnbounded()) {
      this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      };
      this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
      this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
    }
  };
  return MDCRippleFoundation2;
}(MDCFoundation);
var MDCRippleFoundation$1 = MDCRippleFoundation;
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const previousStylePropertyCache = /* @__PURE__ */ new WeakMap();
const styleMap = directive$1((styleInfo) => (part) => {
  if (!(part instanceof AttributePart$1) || part instanceof PropertyPart || part.committer.name !== "style" || part.committer.parts.length > 1) {
    throw new Error("The `styleMap` directive must be used in the style attribute and must be the only part in the attribute.");
  }
  const { committer } = part;
  const { style } = committer.element;
  let previousStyleProperties = previousStylePropertyCache.get(part);
  if (previousStyleProperties === void 0) {
    style.cssText = committer.strings.join(" ");
    previousStylePropertyCache.set(part, previousStyleProperties = /* @__PURE__ */ new Set());
  }
  previousStyleProperties.forEach((name) => {
    if (!(name in styleInfo)) {
      previousStyleProperties.delete(name);
      if (name.indexOf("-") === -1) {
        style[name] = null;
      } else {
        style.removeProperty(name);
      }
    }
  });
  for (const name in styleInfo) {
    previousStyleProperties.add(name);
    if (name.indexOf("-") === -1) {
      style[name] = styleInfo[name];
    } else {
      style.setProperty(name, styleInfo[name]);
    }
  }
});
class RippleBase extends BaseElement {
  constructor() {
    super(...arguments);
    this.primary = false;
    this.accent = false;
    this.unbounded = false;
    this.disabled = false;
    this.activated = false;
    this.selected = false;
    this.internalUseStateLayerCustomProperties = false;
    this.hovering = false;
    this.bgFocused = false;
    this.fgActivation = false;
    this.fgDeactivation = false;
    this.fgScale = "";
    this.fgSize = "";
    this.translateStart = "";
    this.translateEnd = "";
    this.leftPos = "";
    this.topPos = "";
    this.mdcFoundationClass = MDCRippleFoundation$1;
  }
  get isActive() {
    return matches$1(this.parentElement || this, ":active");
  }
  createAdapter() {
    return {
      browserSupportsCssVars: () => true,
      isUnbounded: () => this.unbounded,
      isSurfaceActive: () => this.isActive,
      isSurfaceDisabled: () => this.disabled,
      addClass: (className) => {
        switch (className) {
          case "mdc-ripple-upgraded--background-focused":
            this.bgFocused = true;
            break;
          case "mdc-ripple-upgraded--foreground-activation":
            this.fgActivation = true;
            break;
          case "mdc-ripple-upgraded--foreground-deactivation":
            this.fgDeactivation = true;
            break;
        }
      },
      removeClass: (className) => {
        switch (className) {
          case "mdc-ripple-upgraded--background-focused":
            this.bgFocused = false;
            break;
          case "mdc-ripple-upgraded--foreground-activation":
            this.fgActivation = false;
            break;
          case "mdc-ripple-upgraded--foreground-deactivation":
            this.fgDeactivation = false;
            break;
        }
      },
      containsEventTarget: () => true,
      registerInteractionHandler: () => void 0,
      deregisterInteractionHandler: () => void 0,
      registerDocumentInteractionHandler: () => void 0,
      deregisterDocumentInteractionHandler: () => void 0,
      registerResizeHandler: () => void 0,
      deregisterResizeHandler: () => void 0,
      updateCssVariable: (varName, value2) => {
        switch (varName) {
          case "--mdc-ripple-fg-scale":
            this.fgScale = value2;
            break;
          case "--mdc-ripple-fg-size":
            this.fgSize = value2;
            break;
          case "--mdc-ripple-fg-translate-end":
            this.translateEnd = value2;
            break;
          case "--mdc-ripple-fg-translate-start":
            this.translateStart = value2;
            break;
          case "--mdc-ripple-left":
            this.leftPos = value2;
            break;
          case "--mdc-ripple-top":
            this.topPos = value2;
            break;
        }
      },
      computeBoundingRect: () => (this.parentElement || this).getBoundingClientRect(),
      getWindowPageOffset: () => ({ x: window.pageXOffset, y: window.pageYOffset })
    };
  }
  startPress(ev) {
    this.waitForFoundation(() => {
      this.mdcFoundation.activate(ev);
    });
  }
  endPress() {
    this.waitForFoundation(() => {
      this.mdcFoundation.deactivate();
    });
  }
  startFocus() {
    this.waitForFoundation(() => {
      this.mdcFoundation.handleFocus();
    });
  }
  endFocus() {
    this.waitForFoundation(() => {
      this.mdcFoundation.handleBlur();
    });
  }
  startHover() {
    this.hovering = true;
  }
  endHover() {
    this.hovering = false;
  }
  waitForFoundation(fn2) {
    if (this.mdcFoundation) {
      fn2();
    } else {
      this.updateComplete.then(fn2);
    }
  }
  update(changedProperties) {
    if (changedProperties.has("disabled")) {
      if (this.disabled) {
        this.endHover();
      }
    }
    super.update(changedProperties);
  }
  render() {
    const shouldActivateInPrimary = this.activated && (this.primary || !this.accent);
    const shouldSelectInPrimary = this.selected && (this.primary || !this.accent);
    const classes = {
      "mdc-ripple-surface--accent": this.accent,
      "mdc-ripple-surface--primary--activated": shouldActivateInPrimary,
      "mdc-ripple-surface--accent--activated": this.accent && this.activated,
      "mdc-ripple-surface--primary--selected": shouldSelectInPrimary,
      "mdc-ripple-surface--accent--selected": this.accent && this.selected,
      "mdc-ripple-surface--disabled": this.disabled,
      "mdc-ripple-surface--hover": this.hovering,
      "mdc-ripple-surface--primary": this.primary,
      "mdc-ripple-surface--selected": this.selected,
      "mdc-ripple-upgraded--background-focused": this.bgFocused,
      "mdc-ripple-upgraded--foreground-activation": this.fgActivation,
      "mdc-ripple-upgraded--foreground-deactivation": this.fgDeactivation,
      "mdc-ripple-upgraded--unbounded": this.unbounded,
      "mdc-ripple-surface--internal-use-state-layer-custom-properties": this.internalUseStateLayerCustomProperties
    };
    return html$2`
        <div class="mdc-ripple-surface mdc-ripple-upgraded ${classMap(classes)}"
          style="${styleMap({
      "--mdc-ripple-fg-scale": this.fgScale,
      "--mdc-ripple-fg-size": this.fgSize,
      "--mdc-ripple-fg-translate-end": this.translateEnd,
      "--mdc-ripple-fg-translate-start": this.translateStart,
      "--mdc-ripple-left": this.leftPos,
      "--mdc-ripple-top": this.topPos
    })}"></div>`;
  }
}
__decorate([
  query(".mdc-ripple-surface")
], RippleBase.prototype, "mdcRoot", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "primary", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "accent", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "unbounded", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "disabled", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "activated", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "selected", void 0);
__decorate([
  property({ type: Boolean })
], RippleBase.prototype, "internalUseStateLayerCustomProperties", void 0);
__decorate([
  state()
], RippleBase.prototype, "hovering", void 0);
__decorate([
  state()
], RippleBase.prototype, "bgFocused", void 0);
__decorate([
  state()
], RippleBase.prototype, "fgActivation", void 0);
__decorate([
  state()
], RippleBase.prototype, "fgDeactivation", void 0);
__decorate([
  state()
], RippleBase.prototype, "fgScale", void 0);
__decorate([
  state()
], RippleBase.prototype, "fgSize", void 0);
__decorate([
  state()
], RippleBase.prototype, "translateStart", void 0);
__decorate([
  state()
], RippleBase.prototype, "translateEnd", void 0);
__decorate([
  state()
], RippleBase.prototype, "leftPos", void 0);
__decorate([
  state()
], RippleBase.prototype, "topPos", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles$2 = css$2`.mdc-ripple-surface{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity;position:relative;outline:none;overflow:hidden}.mdc-ripple-surface::before,.mdc-ripple-surface::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-ripple-surface::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-ripple-surface::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-ripple-surface.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface::before,.mdc-ripple-surface::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-ripple-surface.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded],.mdc-ripple-upgraded--unbounded{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::after,.mdc-ripple-upgraded--unbounded::before,.mdc-ripple-upgraded--unbounded::after{top:calc(50% - 50%);left:calc(50% - 50%);width:100%;height:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::before,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{top:var(--mdc-ripple-top, calc(50% - 50%));left:var(--mdc-ripple-left, calc(50% - 50%));width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface::before,.mdc-ripple-surface::after{background-color:#000;background-color:var(--mdc-ripple-color, #000)}.mdc-ripple-surface:hover::before,.mdc-ripple-surface.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:block}:host .mdc-ripple-surface{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;will-change:unset}.mdc-ripple-surface--primary::before,.mdc-ripple-surface--primary::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary:hover::before,.mdc-ripple-surface--primary.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--primary.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before,.mdc-ripple-surface--primary--activated::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--activated:hover::before,.mdc-ripple-surface--primary--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--primary--selected::before,.mdc-ripple-surface--primary--selected::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--selected:hover::before,.mdc-ripple-surface--primary--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent::before,.mdc-ripple-surface--accent::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent:hover::before,.mdc-ripple-surface--accent.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--accent.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before,.mdc-ripple-surface--accent--activated::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--activated:hover::before,.mdc-ripple-surface--accent--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--accent--selected::before,.mdc-ripple-surface--accent--selected::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--selected:hover::before,.mdc-ripple-surface--accent--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--disabled{opacity:0}.mdc-ripple-surface--internal-use-state-layer-custom-properties::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties::after{background-color:#000;background-color:var(--mdc-ripple-hover-state-layer-color, #000)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:hover::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-state-layer-opacity, 0.04)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}`;
let Ripple = class Ripple2 extends RippleBase {
};
Ripple.styles = [styles$2];
Ripple = __decorate([
  customElement("mwc-ripple")
], Ripple);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class RippleHandlers {
  constructor(rippleFn) {
    this.startPress = (ev) => {
      rippleFn().then((r) => {
        r && r.startPress(ev);
      });
    };
    this.endPress = () => {
      rippleFn().then((r) => {
        r && r.endPress();
      });
    };
    this.startFocus = () => {
      rippleFn().then((r) => {
        r && r.startFocus();
      });
    };
    this.endFocus = () => {
      rippleFn().then((r) => {
        r && r.endFocus();
      });
    };
    this.startHover = () => {
      rippleFn().then((r) => {
        r && r.startHover();
      });
    };
    this.endHover = () => {
      rippleFn().then((r) => {
        r && r.endHover();
      });
    };
  }
}
class ButtonBase extends LitElement {
  constructor() {
    super(...arguments);
    this.raised = false;
    this.unelevated = false;
    this.outlined = false;
    this.dense = false;
    this.disabled = false;
    this.trailingIcon = false;
    this.fullwidth = false;
    this.icon = "";
    this.label = "";
    this.expandContent = false;
    this.shouldRenderRipple = false;
    this.rippleHandlers = new RippleHandlers(() => {
      this.shouldRenderRipple = true;
      return this.ripple;
    });
  }
  renderOverlay() {
    return html$2``;
  }
  renderRipple() {
    const filled = this.raised || this.unelevated;
    return this.shouldRenderRipple ? html$2`<mwc-ripple class="ripple" .primary="${!filled}" .disabled="${this.disabled}"></mwc-ripple>` : "";
  }
  focus() {
    const buttonElement = this.buttonElement;
    if (buttonElement) {
      this.rippleHandlers.startFocus();
      buttonElement.focus();
    }
  }
  blur() {
    const buttonElement = this.buttonElement;
    if (buttonElement) {
      this.rippleHandlers.endFocus();
      buttonElement.blur();
    }
  }
  getRenderClasses() {
    return classMap({
      "mdc-button--raised": this.raised,
      "mdc-button--unelevated": this.unelevated,
      "mdc-button--outlined": this.outlined,
      "mdc-button--dense": this.dense
    });
  }
  render() {
    return html$2`
      <button
          id="button"
          class="mdc-button ${this.getRenderClasses()}"
          ?disabled="${this.disabled}"
          aria-label="${this.label || this.icon}"
          @focus="${this.handleRippleFocus}"
          @blur="${this.handleRippleBlur}"
          @mousedown="${this.handleRippleActivate}"
          @mouseenter="${this.handleRippleMouseEnter}"
          @mouseleave="${this.handleRippleMouseLeave}"
          @touchstart="${this.handleRippleActivate}"
          @touchend="${this.handleRippleDeactivate}"
          @touchcancel="${this.handleRippleDeactivate}">
        ${this.renderOverlay()}
        ${this.renderRipple()}
        <span class="leading-icon">
          <slot name="icon">
            ${this.icon && !this.trailingIcon ? this.renderIcon() : ""}
          </slot>
        </span>
        <span class="mdc-button__label">${this.label}</span>
        <span class="slot-container ${classMap({
      flex: this.expandContent
    })}">
          <slot></slot>
        </span>
        <span class="trailing-icon">
          <slot name="trailingIcon">
            ${this.icon && this.trailingIcon ? this.renderIcon() : ""}
          </slot>
        </span>
      </button>`;
  }
  renderIcon() {
    return html$2`
    <mwc-icon class="mdc-button__icon">
      ${this.icon}
    </mwc-icon>`;
  }
  handleRippleActivate(evt) {
    const onUp = () => {
      window.removeEventListener("mouseup", onUp);
      this.handleRippleDeactivate();
    };
    window.addEventListener("mouseup", onUp);
    this.rippleHandlers.startPress(evt);
  }
  handleRippleDeactivate() {
    this.rippleHandlers.endPress();
  }
  handleRippleMouseEnter() {
    this.rippleHandlers.startHover();
  }
  handleRippleMouseLeave() {
    this.rippleHandlers.endHover();
  }
  handleRippleFocus() {
    this.rippleHandlers.startFocus();
  }
  handleRippleBlur() {
    this.rippleHandlers.endFocus();
  }
}
ButtonBase.shadowRootOptions = { mode: "open", delegatesFocus: true };
__decorate([
  property({ type: Boolean, reflect: true })
], ButtonBase.prototype, "raised", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ButtonBase.prototype, "unelevated", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ButtonBase.prototype, "outlined", void 0);
__decorate([
  property({ type: Boolean })
], ButtonBase.prototype, "dense", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ButtonBase.prototype, "disabled", void 0);
__decorate([
  property({ type: Boolean, attribute: "trailingicon" })
], ButtonBase.prototype, "trailingIcon", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ButtonBase.prototype, "fullwidth", void 0);
__decorate([
  property({ type: String })
], ButtonBase.prototype, "icon", void 0);
__decorate([
  property({ type: String })
], ButtonBase.prototype, "label", void 0);
__decorate([
  property({ type: Boolean })
], ButtonBase.prototype, "expandContent", void 0);
__decorate([
  query("#button")
], ButtonBase.prototype, "buttonElement", void 0);
__decorate([
  queryAsync("mwc-ripple")
], ButtonBase.prototype, "ripple", void 0);
__decorate([
  state()
], ButtonBase.prototype, "shouldRenderRipple", void 0);
__decorate([
  eventOptions({ passive: true })
], ButtonBase.prototype, "handleRippleActivate", null);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles$1 = css$2`.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:0;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff;background-color:var(--mdc-elevation-overlay-color, #fff)}.mdc-button{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-button-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-button-font-size, 0.875rem);line-height:2.25rem;line-height:var(--mdc-typography-button-line-height, 2.25rem);font-weight:500;font-weight:var(--mdc-typography-button-font-weight, 500);letter-spacing:0.0892857143em;letter-spacing:var(--mdc-typography-button-letter-spacing, 0.0892857143em);text-decoration:none;text-decoration:var(--mdc-typography-button-text-decoration, none);text-transform:uppercase;text-transform:var(--mdc-typography-button-text-transform, uppercase);position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:transparent}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;font-size:1.125rem;height:1.125rem;vertical-align:top;width:1.125rem}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--raised .mdc-button__icon,.mdc-button--unelevated .mdc-button__icon,.mdc-button--outlined .mdc-button__icon{margin-left:-4px;margin-right:8px}[dir=rtl] .mdc-button--raised .mdc-button__icon,[dir=rtl] .mdc-button--unelevated .mdc-button__icon,[dir=rtl] .mdc-button--outlined .mdc-button__icon,.mdc-button--raised .mdc-button__icon[dir=rtl],.mdc-button--unelevated .mdc-button__icon[dir=rtl],.mdc-button--outlined .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mdc-button--raised .mdc-button__label+.mdc-button__icon,.mdc-button--unelevated .mdc-button__label+.mdc-button__icon,.mdc-button--outlined .mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mdc-button--raised .mdc-button__label+.mdc-button__icon,[dir=rtl] .mdc-button--unelevated .mdc-button__label+.mdc-button__icon,[dir=rtl] .mdc-button--outlined .mdc-button__label+.mdc-button__icon,.mdc-button--raised .mdc-button__label+.mdc-button__icon[dir=rtl],.mdc-button--unelevated .mdc-button__label+.mdc-button__icon[dir=rtl],.mdc-button--outlined .mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button--raised{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2),0px 2px 2px 0px rgba(0, 0, 0, 0.14),0px 1px 5px 0px rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--raised:hover,.mdc-button--raised:focus{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12)}.mdc-button--raised:active{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}.mdc-button--raised:disabled{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2),0px 0px 0px 0px rgba(0, 0, 0, 0.14),0px 0px 0px 0px rgba(0,0,0,.12)}.mdc-button--outlined{border-style:solid}.mdc-button{height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px);padding:0 8px 0 8px}.mdc-button:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-button:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--raised,.mdc-button--unelevated{padding:0 16px 0 16px;height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{background-color:rgba(0, 0, 0, 0.12)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button--raised .mdc-button__ripple,.mdc-button--unelevated .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--outlined{height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px);padding:0 15px 0 15px;border-width:1px}.mdc-button--outlined:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-button--outlined:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button--outlined .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--outlined:not(:disabled){border-color:rgba(0, 0, 0, 0.12)}.mdc-button--outlined:disabled{border-color:rgba(0, 0, 0, 0.12)}.mdc-button--outlined.mdc-button--icon-trailing{padding:0 11px 0 15px}.mdc-button--outlined.mdc-button--icon-leading{padding:0 15px 0 11px}.mdc-button--outlined .mdc-button__ripple{top:-1px;left:-1px;border:1px solid transparent}.mdc-button--outlined .mdc-button__touch{left:-1px;width:calc(100% + 2 * 1px)}:host{display:inline-flex;outline:none;-webkit-tap-highlight-color:transparent;vertical-align:top}:host([fullwidth]){width:100%}:host([raised]),:host([unelevated]){--mdc-ripple-color:#fff;--mdc-ripple-focus-opacity:0.24;--mdc-ripple-hover-opacity:0.08;--mdc-ripple-press-opacity:0.24}.trailing-icon ::slotted(*),.trailing-icon .mdc-button__icon,.leading-icon ::slotted(*),.leading-icon .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;font-size:1.125rem;height:1.125rem;vertical-align:top;width:1.125rem}[dir=rtl] .trailing-icon ::slotted(*),[dir=rtl] .trailing-icon .mdc-button__icon,[dir=rtl] .leading-icon ::slotted(*),[dir=rtl] .leading-icon .mdc-button__icon,.trailing-icon ::slotted(*[dir=rtl]),.trailing-icon .mdc-button__icon[dir=rtl],.leading-icon ::slotted(*[dir=rtl]),.leading-icon .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.trailing-icon ::slotted(*),.trailing-icon .mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .trailing-icon ::slotted(*),[dir=rtl] .trailing-icon .mdc-button__icon,.trailing-icon ::slotted(*[dir=rtl]),.trailing-icon .mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}.slot-container{display:inline-flex;align-items:center;justify-content:center}.slot-container.flex{flex:auto}.mdc-button{flex:auto;overflow:hidden;padding-left:8px;padding-left:var(--mdc-button-horizontal-padding, 8px);padding-right:8px;padding-right:var(--mdc-button-horizontal-padding, 8px)}.mdc-button--raised{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:focus{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-focus, var(--mdc-button-raised-box-shadow-hover, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12)))}.mdc-button--raised:hover{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-hover, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:active{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-active, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mdc-button--raised:disabled{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-disabled, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised,.mdc-button--unelevated{padding-left:16px;padding-left:var(--mdc-button-horizontal-padding, 16px);padding-right:16px;padding-right:var(--mdc-button-horizontal-padding, 16px)}.mdc-button--outlined{border-width:1px;border-width:var(--mdc-button-outline-width, 1px);padding-left:calc(16px - 1px);padding-left:calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px));padding-right:calc(16px - 1px);padding-right:calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px))}.mdc-button--outlined:not(:disabled){border-color:rgba(0, 0, 0, 0.12);border-color:var(--mdc-button-outline-color, rgba(0, 0, 0, 0.12))}.mdc-button--outlined .ripple{top:calc(-1 * 1px);top:calc(-1 * var(--mdc-button-outline-width, 1px));left:calc(-1 * 1px);left:calc(-1 * var(--mdc-button-outline-width, 1px));right:initial;right:initial;border-width:1px;border-width:var(--mdc-button-outline-width, 1px);border-style:solid;border-color:transparent}[dir=rtl] .mdc-button--outlined .ripple,.mdc-button--outlined .ripple[dir=rtl]{left:initial;left:initial;right:calc(-1 * 1px);right:calc(-1 * var(--mdc-button-outline-width, 1px))}.mdc-button--dense{height:28px;margin-top:0;margin-bottom:0}.mdc-button--dense .mdc-button__touch{display:none}:host([disabled]){pointer-events:none}:host([disabled]) .mdc-button{color:rgba(0, 0, 0, 0.38);color:var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-button--raised,:host([disabled]) .mdc-button--unelevated{background-color:rgba(0, 0, 0, 0.12);background-color:var(--mdc-button-disabled-fill-color, rgba(0, 0, 0, 0.12))}:host([disabled]) .mdc-button--outlined{border-color:rgba(0, 0, 0, 0.12);border-color:var(--mdc-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}`;
let Button = class Button2 extends ButtonBase {
};
Button.styles = [styles$1];
Button = __decorate([
  customElement("mwc-button")
], Button);
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(() => {
  var _a2, _b, _c;
  const _blockingElements = Symbol();
  const _alreadyInertElements = Symbol();
  const _topElParents = Symbol();
  const _siblingsToRestore = Symbol();
  const _parentMO = Symbol();
  const _topChanged = Symbol();
  const _swapInertedSibling = Symbol();
  const _inertSiblings = Symbol();
  const _restoreInertedSiblings = Symbol();
  const _getParents = Symbol();
  const _getDistributedChildren = Symbol();
  const _isInertable = Symbol();
  const _handleMutations = Symbol();
  class BlockingElementsImpl {
    constructor() {
      this[_a2] = [];
      this[_b] = [];
      this[_c] = /* @__PURE__ */ new Set();
    }
    destructor() {
      this[_restoreInertedSiblings](this[_topElParents]);
      const nullable = this;
      nullable[_blockingElements] = null;
      nullable[_topElParents] = null;
      nullable[_alreadyInertElements] = null;
    }
    get top() {
      const elems = this[_blockingElements];
      return elems[elems.length - 1] || null;
    }
    push(element2) {
      if (!element2 || element2 === this.top) {
        return;
      }
      this.remove(element2);
      this[_topChanged](element2);
      this[_blockingElements].push(element2);
    }
    remove(element2) {
      const i2 = this[_blockingElements].indexOf(element2);
      if (i2 === -1) {
        return false;
      }
      this[_blockingElements].splice(i2, 1);
      if (i2 === this[_blockingElements].length) {
        this[_topChanged](this.top);
      }
      return true;
    }
    pop() {
      const top = this.top;
      top && this.remove(top);
      return top;
    }
    has(element2) {
      return this[_blockingElements].indexOf(element2) !== -1;
    }
    [(_a2 = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
      const toKeepInert = this[_alreadyInertElements];
      const oldParents = this[_topElParents];
      if (!newTop) {
        this[_restoreInertedSiblings](oldParents);
        toKeepInert.clear();
        this[_topElParents] = [];
        return;
      }
      const newParents = this[_getParents](newTop);
      if (newParents[newParents.length - 1].parentNode !== document.body) {
        throw Error("Non-connected element cannot be a blocking element");
      }
      this[_topElParents] = newParents;
      const toSkip = this[_getDistributedChildren](newTop);
      if (!oldParents.length) {
        this[_inertSiblings](newParents, toSkip, toKeepInert);
        return;
      }
      let i2 = oldParents.length - 1;
      let j2 = newParents.length - 1;
      while (i2 > 0 && j2 > 0 && oldParents[i2] === newParents[j2]) {
        i2--;
        j2--;
      }
      if (oldParents[i2] !== newParents[j2]) {
        this[_swapInertedSibling](oldParents[i2], newParents[j2]);
      }
      i2 > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i2));
      j2 > 0 && this[_inertSiblings](newParents.slice(0, j2), toSkip, null);
    }
    [_swapInertedSibling](oldInert, newInert) {
      const siblingsToRestore = oldInert[_siblingsToRestore];
      if (this[_isInertable](oldInert) && !oldInert.inert) {
        oldInert.inert = true;
        siblingsToRestore.add(oldInert);
      }
      if (siblingsToRestore.has(newInert)) {
        newInert.inert = false;
        siblingsToRestore.delete(newInert);
      }
      newInert[_parentMO] = oldInert[_parentMO];
      newInert[_siblingsToRestore] = siblingsToRestore;
      oldInert[_parentMO] = void 0;
      oldInert[_siblingsToRestore] = void 0;
    }
    [_restoreInertedSiblings](elements2) {
      for (const element2 of elements2) {
        const mo = element2[_parentMO];
        mo.disconnect();
        element2[_parentMO] = void 0;
        const siblings = element2[_siblingsToRestore];
        for (const sibling of siblings) {
          sibling.inert = false;
        }
        element2[_siblingsToRestore] = void 0;
      }
    }
    [_inertSiblings](elements2, toSkip, toKeepInert) {
      for (const element2 of elements2) {
        const parent = element2.parentNode;
        const children2 = parent.children;
        const inertedSiblings = /* @__PURE__ */ new Set();
        for (let j2 = 0; j2 < children2.length; j2++) {
          const sibling = children2[j2];
          if (sibling === element2 || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
            continue;
          }
          if (toKeepInert && sibling.inert) {
            toKeepInert.add(sibling);
          } else {
            sibling.inert = true;
            inertedSiblings.add(sibling);
          }
        }
        element2[_siblingsToRestore] = inertedSiblings;
        const mo = new MutationObserver(this[_handleMutations].bind(this));
        element2[_parentMO] = mo;
        let parentToObserve = parent;
        const maybeShadyRoot = parentToObserve;
        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
          parentToObserve = maybeShadyRoot.host;
        }
        mo.observe(parentToObserve, {
          childList: true
        });
      }
    }
    [_handleMutations](mutations) {
      const parents = this[_topElParents];
      const toKeepInert = this[_alreadyInertElements];
      for (const mutation of mutations) {
        const target = mutation.target.host || mutation.target;
        const idx = target === document.body ? parents.length : parents.indexOf(target);
        const inertedChild = parents[idx - 1];
        const inertedSiblings = inertedChild[_siblingsToRestore];
        for (let i2 = 0; i2 < mutation.removedNodes.length; i2++) {
          const sibling = mutation.removedNodes[i2];
          if (sibling === inertedChild) {
            console.info("Detected removal of the top Blocking Element.");
            this.pop();
            return;
          }
          if (inertedSiblings.has(sibling)) {
            sibling.inert = false;
            inertedSiblings.delete(sibling);
          }
        }
        for (let i2 = 0; i2 < mutation.addedNodes.length; i2++) {
          const sibling = mutation.addedNodes[i2];
          if (!this[_isInertable](sibling)) {
            continue;
          }
          if (toKeepInert && sibling.inert) {
            toKeepInert.add(sibling);
          } else {
            sibling.inert = true;
            inertedSiblings.add(sibling);
          }
        }
      }
    }
    [_isInertable](element2) {
      return /^(style|template|script)$/.test(element2.localName) === false;
    }
    [_getParents](element2) {
      const parents = [];
      let current = element2;
      while (current && current !== document.body) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          parents.push(current);
        }
        if (current.assignedSlot) {
          while (current = current.assignedSlot) {
            parents.push(current);
          }
          current = parents.pop();
          continue;
        }
        current = current.parentNode || current.host;
      }
      return parents;
    }
    [_getDistributedChildren](element2) {
      const shadowRoot = element2.shadowRoot;
      if (!shadowRoot) {
        return null;
      }
      const result2 = /* @__PURE__ */ new Set();
      let i2;
      let j2;
      let nodes;
      const slots = shadowRoot.querySelectorAll("slot");
      if (slots.length && slots[0].assignedNodes) {
        for (i2 = 0; i2 < slots.length; i2++) {
          nodes = slots[i2].assignedNodes({
            flatten: true
          });
          for (j2 = 0; j2 < nodes.length; j2++) {
            if (nodes[j2].nodeType === Node.ELEMENT_NODE) {
              result2.add(nodes[j2]);
            }
          }
        }
      }
      return result2;
    }
  }
  document.$blockingElements = new BlockingElementsImpl();
})();
var _createClass$5 = function() {
  function defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
(function() {
  if (typeof window === "undefined") {
    return;
  }
  var slice = Array.prototype.slice;
  var matches2 = Element.prototype.matches || Element.prototype.msMatchesSelector;
  var _focusableElementsString = ["a[href]", "area[href]", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "details", "summary", "iframe", "object", "embed", "[contenteditable]"].join(",");
  var InertRoot = function() {
    function InertRoot2(rootElement, inertManager2) {
      _classCallCheck$1(this, InertRoot2);
      this._inertManager = inertManager2;
      this._rootElement = rootElement;
      this._managedNodes = /* @__PURE__ */ new Set();
      if (this._rootElement.hasAttribute("aria-hidden")) {
        this._savedAriaHidden = this._rootElement.getAttribute("aria-hidden");
      } else {
        this._savedAriaHidden = null;
      }
      this._rootElement.setAttribute("aria-hidden", "true");
      this._makeSubtreeUnfocusable(this._rootElement);
      this._observer = new MutationObserver(this._onMutation.bind(this));
      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    }
    _createClass$5(InertRoot2, [{
      key: "destructor",
      value: function destructor() {
        this._observer.disconnect();
        if (this._rootElement) {
          if (this._savedAriaHidden !== null) {
            this._rootElement.setAttribute("aria-hidden", this._savedAriaHidden);
          } else {
            this._rootElement.removeAttribute("aria-hidden");
          }
        }
        this._managedNodes.forEach(function(inertNode) {
          this._unmanageNode(inertNode.node);
        }, this);
        this._observer = null;
        this._rootElement = null;
        this._managedNodes = null;
        this._inertManager = null;
      }
    }, {
      key: "_makeSubtreeUnfocusable",
      value: function _makeSubtreeUnfocusable(startNode) {
        var _this2 = this;
        composedTreeWalk(startNode, function(node2) {
          return _this2._visitNode(node2);
        });
        var activeElement = document.activeElement;
        if (!document.body.contains(startNode)) {
          var node = startNode;
          var root2 = void 0;
          while (node) {
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              root2 = node;
              break;
            }
            node = node.parentNode;
          }
          if (root2) {
            activeElement = root2.activeElement;
          }
        }
        if (startNode.contains(activeElement)) {
          activeElement.blur();
          if (activeElement === document.activeElement) {
            document.body.focus();
          }
        }
      }
    }, {
      key: "_visitNode",
      value: function _visitNode(node) {
        if (node.nodeType !== Node.ELEMENT_NODE) {
          return;
        }
        var element2 = node;
        if (element2 !== this._rootElement && element2.hasAttribute("inert")) {
          this._adoptInertRoot(element2);
        }
        if (matches2.call(element2, _focusableElementsString) || element2.hasAttribute("tabindex")) {
          this._manageNode(element2);
        }
      }
    }, {
      key: "_manageNode",
      value: function _manageNode(node) {
        var inertNode = this._inertManager.register(node, this);
        this._managedNodes.add(inertNode);
      }
    }, {
      key: "_unmanageNode",
      value: function _unmanageNode(node) {
        var inertNode = this._inertManager.deregister(node, this);
        if (inertNode) {
          this._managedNodes["delete"](inertNode);
        }
      }
    }, {
      key: "_unmanageSubtree",
      value: function _unmanageSubtree(startNode) {
        var _this3 = this;
        composedTreeWalk(startNode, function(node) {
          return _this3._unmanageNode(node);
        });
      }
    }, {
      key: "_adoptInertRoot",
      value: function _adoptInertRoot(node) {
        var inertSubroot = this._inertManager.getInertRoot(node);
        if (!inertSubroot) {
          this._inertManager.setInert(node, true);
          inertSubroot = this._inertManager.getInertRoot(node);
        }
        inertSubroot.managedNodes.forEach(function(savedInertNode) {
          this._manageNode(savedInertNode.node);
        }, this);
      }
    }, {
      key: "_onMutation",
      value: function _onMutation(records, self2) {
        records.forEach(function(record) {
          var target = record.target;
          if (record.type === "childList") {
            slice.call(record.addedNodes).forEach(function(node) {
              this._makeSubtreeUnfocusable(node);
            }, this);
            slice.call(record.removedNodes).forEach(function(node) {
              this._unmanageSubtree(node);
            }, this);
          } else if (record.type === "attributes") {
            if (record.attributeName === "tabindex") {
              this._manageNode(target);
            } else if (target !== this._rootElement && record.attributeName === "inert" && target.hasAttribute("inert")) {
              this._adoptInertRoot(target);
              var inertSubroot = this._inertManager.getInertRoot(target);
              this._managedNodes.forEach(function(managedNode) {
                if (target.contains(managedNode.node)) {
                  inertSubroot._manageNode(managedNode.node);
                }
              });
            }
          }
        }, this);
      }
    }, {
      key: "managedNodes",
      get: function get3() {
        return new Set(this._managedNodes);
      }
    }, {
      key: "hasSavedAriaHidden",
      get: function get3() {
        return this._savedAriaHidden !== null;
      }
    }, {
      key: "savedAriaHidden",
      set: function set2(ariaHidden) {
        this._savedAriaHidden = ariaHidden;
      },
      get: function get3() {
        return this._savedAriaHidden;
      }
    }]);
    return InertRoot2;
  }();
  var InertNode = function() {
    function InertNode2(node, inertRoot) {
      _classCallCheck$1(this, InertNode2);
      this._node = node;
      this._overrodeFocusMethod = false;
      this._inertRoots = /* @__PURE__ */ new Set([inertRoot]);
      this._savedTabIndex = null;
      this._destroyed = false;
      this.ensureUntabbable();
    }
    _createClass$5(InertNode2, [{
      key: "destructor",
      value: function destructor() {
        this._throwIfDestroyed();
        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
          var element2 = this._node;
          if (this._savedTabIndex !== null) {
            element2.setAttribute("tabindex", this._savedTabIndex);
          } else {
            element2.removeAttribute("tabindex");
          }
          if (this._overrodeFocusMethod) {
            delete element2.focus;
          }
        }
        this._node = null;
        this._inertRoots = null;
        this._destroyed = true;
      }
    }, {
      key: "_throwIfDestroyed",
      value: function _throwIfDestroyed() {
        if (this.destroyed) {
          throw new Error("Trying to access destroyed InertNode");
        }
      }
    }, {
      key: "ensureUntabbable",
      value: function ensureUntabbable() {
        if (this.node.nodeType !== Node.ELEMENT_NODE) {
          return;
        }
        var element2 = this.node;
        if (matches2.call(element2, _focusableElementsString)) {
          if (element2.tabIndex === -1 && this.hasSavedTabIndex) {
            return;
          }
          if (element2.hasAttribute("tabindex")) {
            this._savedTabIndex = element2.tabIndex;
          }
          element2.setAttribute("tabindex", "-1");
          if (element2.nodeType === Node.ELEMENT_NODE) {
            element2.focus = function() {
            };
            this._overrodeFocusMethod = true;
          }
        } else if (element2.hasAttribute("tabindex")) {
          this._savedTabIndex = element2.tabIndex;
          element2.removeAttribute("tabindex");
        }
      }
    }, {
      key: "addInertRoot",
      value: function addInertRoot(inertRoot) {
        this._throwIfDestroyed();
        this._inertRoots.add(inertRoot);
      }
    }, {
      key: "removeInertRoot",
      value: function removeInertRoot(inertRoot) {
        this._throwIfDestroyed();
        this._inertRoots["delete"](inertRoot);
        if (this._inertRoots.size === 0) {
          this.destructor();
        }
      }
    }, {
      key: "destroyed",
      get: function get3() {
        return this._destroyed;
      }
    }, {
      key: "hasSavedTabIndex",
      get: function get3() {
        return this._savedTabIndex !== null;
      }
    }, {
      key: "node",
      get: function get3() {
        this._throwIfDestroyed();
        return this._node;
      }
    }, {
      key: "savedTabIndex",
      set: function set2(tabIndex) {
        this._throwIfDestroyed();
        this._savedTabIndex = tabIndex;
      },
      get: function get3() {
        this._throwIfDestroyed();
        return this._savedTabIndex;
      }
    }]);
    return InertNode2;
  }();
  var InertManager = function() {
    function InertManager2(document2) {
      _classCallCheck$1(this, InertManager2);
      if (!document2) {
        throw new Error("Missing required argument; InertManager needs to wrap a document.");
      }
      this._document = document2;
      this._managedNodes = /* @__PURE__ */ new Map();
      this._inertRoots = /* @__PURE__ */ new Map();
      this._observer = new MutationObserver(this._watchForInert.bind(this));
      addInertStyle(document2.head || document2.body || document2.documentElement);
      if (document2.readyState === "loading") {
        document2.addEventListener("DOMContentLoaded", this._onDocumentLoaded.bind(this));
      } else {
        this._onDocumentLoaded();
      }
    }
    _createClass$5(InertManager2, [{
      key: "setInert",
      value: function setInert(root2, inert) {
        if (inert) {
          if (this._inertRoots.has(root2)) {
            return;
          }
          var inertRoot = new InertRoot(root2, this);
          root2.setAttribute("inert", "");
          this._inertRoots.set(root2, inertRoot);
          if (!this._document.body.contains(root2)) {
            var parent = root2.parentNode;
            while (parent) {
              if (parent.nodeType === 11) {
                addInertStyle(parent);
              }
              parent = parent.parentNode;
            }
          }
        } else {
          if (!this._inertRoots.has(root2)) {
            return;
          }
          var _inertRoot = this._inertRoots.get(root2);
          _inertRoot.destructor();
          this._inertRoots["delete"](root2);
          root2.removeAttribute("inert");
        }
      }
    }, {
      key: "getInertRoot",
      value: function getInertRoot(element2) {
        return this._inertRoots.get(element2);
      }
    }, {
      key: "register",
      value: function register2(node, inertRoot) {
        var inertNode = this._managedNodes.get(node);
        if (inertNode !== void 0) {
          inertNode.addInertRoot(inertRoot);
        } else {
          inertNode = new InertNode(node, inertRoot);
        }
        this._managedNodes.set(node, inertNode);
        return inertNode;
      }
    }, {
      key: "deregister",
      value: function deregister(node, inertRoot) {
        var inertNode = this._managedNodes.get(node);
        if (!inertNode) {
          return null;
        }
        inertNode.removeInertRoot(inertRoot);
        if (inertNode.destroyed) {
          this._managedNodes["delete"](node);
        }
        return inertNode;
      }
    }, {
      key: "_onDocumentLoaded",
      value: function _onDocumentLoaded() {
        var inertElements = slice.call(this._document.querySelectorAll("[inert]"));
        inertElements.forEach(function(inertElement) {
          this.setInert(inertElement, true);
        }, this);
        this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
      }
    }, {
      key: "_watchForInert",
      value: function _watchForInert(records, self2) {
        var _this = this;
        records.forEach(function(record) {
          switch (record.type) {
            case "childList":
              slice.call(record.addedNodes).forEach(function(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }
                var inertElements = slice.call(node.querySelectorAll("[inert]"));
                if (matches2.call(node, "[inert]")) {
                  inertElements.unshift(node);
                }
                inertElements.forEach(function(inertElement) {
                  this.setInert(inertElement, true);
                }, _this);
              }, _this);
              break;
            case "attributes":
              if (record.attributeName !== "inert") {
                return;
              }
              var target = record.target;
              var inert = target.hasAttribute("inert");
              _this.setInert(target, inert);
              break;
          }
        }, this);
      }
    }]);
    return InertManager2;
  }();
  function composedTreeWalk(node, callback, shadowRootAncestor) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      var element2 = node;
      if (callback) {
        callback(element2);
      }
      var shadowRoot = element2.shadowRoot;
      if (shadowRoot) {
        composedTreeWalk(shadowRoot, callback);
        return;
      }
      if (element2.localName == "content") {
        var content2 = element2;
        var distributedNodes = content2.getDistributedNodes ? content2.getDistributedNodes() : [];
        for (var i2 = 0; i2 < distributedNodes.length; i2++) {
          composedTreeWalk(distributedNodes[i2], callback);
        }
        return;
      }
      if (element2.localName == "slot") {
        var slot = element2;
        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
        for (var _i = 0; _i < _distributedNodes.length; _i++) {
          composedTreeWalk(_distributedNodes[_i], callback);
        }
        return;
      }
    }
    var child = node.firstChild;
    while (child != null) {
      composedTreeWalk(child, callback);
      child = child.nextSibling;
    }
  }
  function addInertStyle(node) {
    if (node.querySelector("style#inert-style, link#inert-style")) {
      return;
    }
    var style = document.createElement("style");
    style.setAttribute("id", "inert-style");
    style.textContent = "\n[inert] {\n  pointer-events: none;\n  cursor: default;\n}\n\n[inert], [inert] * {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n";
    node.appendChild(style);
  }
  if (!Element.prototype.hasOwnProperty("inert")) {
    var inertManager = new InertManager(document);
    Object.defineProperty(Element.prototype, "inert", {
      enumerable: true,
      get: function get3() {
        return this.hasAttribute("inert");
      },
      set: function set2(inert) {
        inertManager.setInert(this, inert);
      }
    });
  }
})();
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
var strings$3 = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
var numbers = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationFrame = function() {
  function AnimationFrame2() {
    this.rafIDs = /* @__PURE__ */ new Map();
  }
  AnimationFrame2.prototype.request = function(key, callback) {
    var _this = this;
    this.cancel(key);
    var frameID = requestAnimationFrame(function(frame) {
      _this.rafIDs.delete(key);
      callback(frame);
    });
    this.rafIDs.set(key, frameID);
  };
  AnimationFrame2.prototype.cancel = function(key) {
    var rafID = this.rafIDs.get(key);
    if (rafID) {
      cancelAnimationFrame(rafID);
      this.rafIDs.delete(key);
    }
  };
  AnimationFrame2.prototype.cancelAll = function() {
    var _this = this;
    this.rafIDs.forEach(function(_, key) {
      _this.cancel(key);
    });
  };
  AnimationFrame2.prototype.getQueue = function() {
    var queue2 = [];
    this.rafIDs.forEach(function(_, key) {
      queue2.push(key);
    });
    return queue2;
  };
  return AnimationFrame2;
}();
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_SCROLL_POS"] = "poll_scroll_position";
  AnimationKeys2["POLL_LAYOUT_CHANGE"] = "poll_layout_change";
})(AnimationKeys || (AnimationKeys = {}));
var MDCDialogFoundation = function(_super) {
  __extends(MDCDialogFoundation2, _super);
  function MDCDialogFoundation2(adapter) {
    var _this = _super.call(this, __assign$3(__assign$3({}, MDCDialogFoundation2.defaultAdapter), adapter)) || this;
    _this.dialogOpen = false;
    _this.isFullscreen = false;
    _this.animationFrame = 0;
    _this.animationTimer = 0;
    _this.escapeKeyAction = strings$3.CLOSE_ACTION;
    _this.scrimClickAction = strings$3.CLOSE_ACTION;
    _this.autoStackButtons = true;
    _this.areButtonsStacked = false;
    _this.suppressDefaultPressSelector = strings$3.SUPPRESS_DEFAULT_PRESS_SELECTOR;
    _this.animFrame = new AnimationFrame();
    _this.contentScrollHandler = function() {
      _this.handleScrollEvent();
    };
    _this.windowResizeHandler = function() {
      _this.layout();
    };
    _this.windowOrientationChangeHandler = function() {
      _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCDialogFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "strings", {
    get: function() {
      return strings$3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addBodyClass: function() {
          return void 0;
        },
        addClass: function() {
          return void 0;
        },
        areButtonsStacked: function() {
          return false;
        },
        clickDefaultButton: function() {
          return void 0;
        },
        eventTargetMatches: function() {
          return false;
        },
        getActionFromEvent: function() {
          return "";
        },
        getInitialFocusEl: function() {
          return null;
        },
        hasClass: function() {
          return false;
        },
        isContentScrollable: function() {
          return false;
        },
        notifyClosed: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        },
        notifyOpened: function() {
          return void 0;
        },
        notifyOpening: function() {
          return void 0;
        },
        releaseFocus: function() {
          return void 0;
        },
        removeBodyClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        reverseButtons: function() {
          return void 0;
        },
        trapFocus: function() {
          return void 0;
        },
        registerContentEventHandler: function() {
          return void 0;
        },
        deregisterContentEventHandler: function() {
          return void 0;
        },
        isScrollableContentAtTop: function() {
          return false;
        },
        isScrollableContentAtBottom: function() {
          return false;
        },
        registerWindowEventHandler: function() {
          return void 0;
        },
        deregisterWindowEventHandler: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCDialogFoundation2.prototype.init = function() {
    if (this.adapter.hasClass(cssClasses.STACKED)) {
      this.setAutoStackButtons(false);
    }
    this.isFullscreen = this.adapter.hasClass(cssClasses.FULLSCREEN);
  };
  MDCDialogFoundation2.prototype.destroy = function() {
    if (this.animationTimer) {
      clearTimeout(this.animationTimer);
      this.handleAnimationTimerEnd();
    }
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.animFrame.cancelAll();
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
  };
  MDCDialogFoundation2.prototype.open = function(dialogOptions) {
    var _this = this;
    this.dialogOpen = true;
    this.adapter.notifyOpening();
    this.adapter.addClass(cssClasses.OPENING);
    if (this.isFullscreen) {
      this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
    }
    if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
      this.adapter.addClass(cssClasses.SCRIM_HIDDEN);
    }
    this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.registerWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(cssClasses.OPEN);
      _this.adapter.addBodyClass(cssClasses.SCROLL_LOCK);
      _this.layout();
      _this.animationTimer = setTimeout(function() {
        _this.handleAnimationTimerEnd();
        _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
        _this.adapter.notifyOpened();
      }, numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
    });
  };
  MDCDialogFoundation2.prototype.close = function(action) {
    var _this = this;
    if (action === void 0) {
      action = "";
    }
    if (!this.dialogOpen) {
      return;
    }
    this.dialogOpen = false;
    this.adapter.notifyClosing(action);
    this.adapter.addClass(cssClasses.CLOSING);
    this.adapter.removeClass(cssClasses.OPEN);
    this.adapter.removeBodyClass(cssClasses.SCROLL_LOCK);
    if (this.isFullscreen) {
      this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
    }
    this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
    this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    clearTimeout(this.animationTimer);
    this.animationTimer = setTimeout(function() {
      _this.adapter.releaseFocus();
      _this.handleAnimationTimerEnd();
      _this.adapter.notifyClosed(action);
    }, numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
  };
  MDCDialogFoundation2.prototype.showSurfaceScrim = function() {
    var _this = this;
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWING);
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(cssClasses.SURFACE_SCRIM_SHOWN);
    });
  };
  MDCDialogFoundation2.prototype.hideSurfaceScrim = function() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWN);
    this.adapter.addClass(cssClasses.SURFACE_SCRIM_HIDING);
  };
  MDCDialogFoundation2.prototype.handleSurfaceScrimTransitionEnd = function() {
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_HIDING);
    this.adapter.removeClass(cssClasses.SURFACE_SCRIM_SHOWING);
  };
  MDCDialogFoundation2.prototype.isOpen = function() {
    return this.dialogOpen;
  };
  MDCDialogFoundation2.prototype.getEscapeKeyAction = function() {
    return this.escapeKeyAction;
  };
  MDCDialogFoundation2.prototype.setEscapeKeyAction = function(action) {
    this.escapeKeyAction = action;
  };
  MDCDialogFoundation2.prototype.getScrimClickAction = function() {
    return this.scrimClickAction;
  };
  MDCDialogFoundation2.prototype.setScrimClickAction = function(action) {
    this.scrimClickAction = action;
  };
  MDCDialogFoundation2.prototype.getAutoStackButtons = function() {
    return this.autoStackButtons;
  };
  MDCDialogFoundation2.prototype.setAutoStackButtons = function(autoStack) {
    this.autoStackButtons = autoStack;
  };
  MDCDialogFoundation2.prototype.getSuppressDefaultPressSelector = function() {
    return this.suppressDefaultPressSelector;
  };
  MDCDialogFoundation2.prototype.setSuppressDefaultPressSelector = function(selector) {
    this.suppressDefaultPressSelector = selector;
  };
  MDCDialogFoundation2.prototype.layout = function() {
    var _this = this;
    this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function() {
      _this.layoutInternal();
    });
  };
  MDCDialogFoundation2.prototype.handleClick = function(evt) {
    var isScrim = this.adapter.eventTargetMatches(evt.target, strings$3.SCRIM_SELECTOR);
    if (isScrim && this.scrimClickAction !== "") {
      this.close(this.scrimClickAction);
    } else {
      var action = this.adapter.getActionFromEvent(evt);
      if (action) {
        this.close(action);
      }
    }
  };
  MDCDialogFoundation2.prototype.handleKeydown = function(evt) {
    var isEnter = evt.key === "Enter" || evt.keyCode === 13;
    if (!isEnter) {
      return;
    }
    var action = this.adapter.getActionFromEvent(evt);
    if (action) {
      return;
    }
    var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
    var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
    if (isEnter && isDefault) {
      this.adapter.clickDefaultButton();
    }
  };
  MDCDialogFoundation2.prototype.handleDocumentKeydown = function(evt) {
    var isEscape = evt.key === "Escape" || evt.keyCode === 27;
    if (isEscape && this.escapeKeyAction !== "") {
      this.close(this.escapeKeyAction);
    }
  };
  MDCDialogFoundation2.prototype.handleScrollEvent = function() {
    var _this = this;
    this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function() {
      _this.toggleScrollDividerHeader();
      _this.toggleScrollDividerFooter();
    });
  };
  MDCDialogFoundation2.prototype.layoutInternal = function() {
    if (this.autoStackButtons) {
      this.detectStackedButtons();
    }
    this.toggleScrollableClasses();
  };
  MDCDialogFoundation2.prototype.handleAnimationTimerEnd = function() {
    this.animationTimer = 0;
    this.adapter.removeClass(cssClasses.OPENING);
    this.adapter.removeClass(cssClasses.CLOSING);
  };
  MDCDialogFoundation2.prototype.runNextAnimationFrame = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(function() {
      _this.animationFrame = 0;
      clearTimeout(_this.animationTimer);
      _this.animationTimer = setTimeout(callback, 0);
    });
  };
  MDCDialogFoundation2.prototype.detectStackedButtons = function() {
    this.adapter.removeClass(cssClasses.STACKED);
    var areButtonsStacked = this.adapter.areButtonsStacked();
    if (areButtonsStacked) {
      this.adapter.addClass(cssClasses.STACKED);
    }
    if (areButtonsStacked !== this.areButtonsStacked) {
      this.adapter.reverseButtons();
      this.areButtonsStacked = areButtonsStacked;
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollableClasses = function() {
    this.adapter.removeClass(cssClasses.SCROLLABLE);
    if (this.adapter.isContentScrollable()) {
      this.adapter.addClass(cssClasses.SCROLLABLE);
      if (this.isFullscreen) {
        this.toggleScrollDividerHeader();
        this.toggleScrollDividerFooter();
      }
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollDividerHeader = function() {
    if (!this.adapter.isScrollableContentAtTop()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_HEADER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_HEADER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_HEADER);
    }
  };
  MDCDialogFoundation2.prototype.toggleScrollDividerFooter = function() {
    if (!this.adapter.isScrollableContentAtBottom()) {
      this.adapter.addClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    } else if (this.adapter.hasClass(cssClasses.SCROLL_DIVIDER_FOOTER)) {
      this.adapter.removeClass(cssClasses.SCROLL_DIVIDER_FOOTER);
    }
  };
  return MDCDialogFoundation2;
}(MDCFoundation);
var MDCDialogFoundation$1 = MDCDialogFoundation;
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options2 = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options2);
    globalObj.document.removeEventListener("test", handler, options2);
  } catch (err2) {
    passiveSupported = false;
  }
  return passiveSupported;
}
const blockingElements = document.$blockingElements;
class DialogBase extends BaseElement {
  constructor() {
    super(...arguments);
    this.hideActions = false;
    this.stacked = false;
    this.heading = "";
    this.scrimClickAction = "close";
    this.escapeKeyAction = "close";
    this.open = false;
    this.defaultAction = "close";
    this.actionAttribute = "dialogAction";
    this.initialFocusAttribute = "dialogInitialFocus";
    this.initialSupressDefaultPressSelector = "";
    this.mdcFoundationClass = MDCDialogFoundation$1;
    this.boundHandleClick = null;
    this.boundHandleKeydown = null;
    this.boundHandleDocumentKeydown = null;
  }
  set suppressDefaultPressSelector(selector) {
    if (this.mdcFoundation) {
      this.mdcFoundation.setSuppressDefaultPressSelector(selector);
    } else {
      this.initialSupressDefaultPressSelector = selector;
    }
  }
  get suppressDefaultPressSelector() {
    return this.mdcFoundation ? this.mdcFoundation.getSuppressDefaultPressSelector() : this.initialSupressDefaultPressSelector;
  }
  get primaryButton() {
    let assignedNodes = this.primarySlot.assignedNodes();
    assignedNodes = assignedNodes.filter((node) => node instanceof HTMLElement);
    const button = assignedNodes[0];
    return button ? button : null;
  }
  emitNotification(name, action) {
    const init2 = { detail: action ? { action } : {} };
    const ev = new CustomEvent(name, init2);
    this.dispatchEvent(ev);
  }
  getInitialFocusEl() {
    const initFocusSelector = `[${this.initialFocusAttribute}]`;
    const lightDomQs = this.querySelector(initFocusSelector);
    if (lightDomQs) {
      return lightDomQs;
    }
    const primarySlot = this.primarySlot;
    const primaryNodes = primarySlot.assignedNodes({ flatten: true });
    const primaryFocusElement = this.searchNodeTreesForAttribute(primaryNodes, this.initialFocusAttribute);
    if (primaryFocusElement) {
      return primaryFocusElement;
    }
    const secondarySlot = this.secondarySlot;
    const secondaryNodes = secondarySlot.assignedNodes({ flatten: true });
    const secondaryFocusElement = this.searchNodeTreesForAttribute(secondaryNodes, this.initialFocusAttribute);
    if (secondaryFocusElement) {
      return secondaryFocusElement;
    }
    const contentSlot = this.contentSlot;
    const contentNodes = contentSlot.assignedNodes({ flatten: true });
    const initFocusElement = this.searchNodeTreesForAttribute(contentNodes, this.initialFocusAttribute);
    return initFocusElement;
  }
  searchNodeTreesForAttribute(nodes, attribute) {
    for (const node of nodes) {
      if (!(node instanceof HTMLElement)) {
        continue;
      }
      if (node.hasAttribute(attribute)) {
        return node;
      } else {
        const selection = node.querySelector(`[${attribute}]`);
        if (selection) {
          return selection;
        }
      }
    }
    return null;
  }
  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { addBodyClass: () => document.body.style.overflow = "hidden", removeBodyClass: () => document.body.style.overflow = "", areButtonsStacked: () => this.stacked, clickDefaultButton: () => {
      const primary = this.primaryButton;
      if (primary) {
        primary.click();
      }
    }, eventTargetMatches: (target, selector) => target ? matches$1(target, selector) : false, getActionFromEvent: (e) => {
      if (!e.target) {
        return "";
      }
      const element2 = closest$1(e.target, `[${this.actionAttribute}]`);
      const action = element2 && element2.getAttribute(this.actionAttribute);
      return action;
    }, getInitialFocusEl: () => {
      return this.getInitialFocusEl();
    }, isContentScrollable: () => {
      const el2 = this.contentElement;
      return el2 ? el2.scrollHeight > el2.offsetHeight : false;
    }, notifyClosed: (action) => this.emitNotification("closed", action), notifyClosing: (action) => {
      if (!this.closingDueToDisconnect) {
        this.open = false;
      }
      this.emitNotification("closing", action);
    }, notifyOpened: () => this.emitNotification("opened"), notifyOpening: () => {
      this.open = true;
      this.emitNotification("opening");
    }, reverseButtons: () => {
    }, releaseFocus: () => {
      blockingElements.remove(this);
    }, trapFocus: (el2) => {
      if (!this.isConnected) {
        return;
      }
      blockingElements.push(this);
      if (el2) {
        el2.focus();
      }
    }, registerContentEventHandler: (evtType, handler) => {
      const el2 = this.contentElement;
      el2.addEventListener(evtType, handler);
    }, deregisterContentEventHandler: (evtType, handler) => {
      const el2 = this.contentElement;
      el2.removeEventListener(evtType, handler);
    }, isScrollableContentAtTop: () => {
      const el2 = this.contentElement;
      return el2 ? el2.scrollTop === 0 : false;
    }, isScrollableContentAtBottom: () => {
      const el2 = this.contentElement;
      return el2 ? Math.ceil(el2.scrollHeight - el2.scrollTop) === el2.clientHeight : false;
    }, registerWindowEventHandler: (evtType, handler) => {
      window.addEventListener(evtType, handler, applyPassive());
    }, deregisterWindowEventHandler: (evtType, handler) => {
      window.removeEventListener(evtType, handler, applyPassive());
    } });
  }
  render() {
    const classes = {
      [cssClasses.STACKED]: this.stacked
    };
    let heading = html$2``;
    if (this.heading) {
      heading = this.renderHeading();
    }
    const actionsClasses = {
      "mdc-dialog__actions": !this.hideActions
    };
    return html$2`
    <div class="mdc-dialog ${classMap(classes)}"
        role="alertdialog"
        aria-modal="true"
        aria-labelledby="title"
        aria-describedby="content">
      <div class="mdc-dialog__container">
        <div class="mdc-dialog__surface">
          ${heading}
          <div id="content" class="mdc-dialog__content">
            <slot id="contentSlot"></slot>
          </div>
          <footer
              id="actions"
              class="${classMap(actionsClasses)}">
            <span>
              <slot name="secondaryAction"></slot>
            </span>
            <span>
             <slot name="primaryAction"></slot>
            </span>
          </footer>
        </div>
      </div>
      <div class="mdc-dialog__scrim"></div>
    </div>`;
  }
  renderHeading() {
    return html$2`
      <h2 id="title" class="mdc-dialog__title">${this.heading}</h2>`;
  }
  firstUpdated() {
    super.firstUpdated();
    this.mdcFoundation.setAutoStackButtons(true);
    if (this.initialSupressDefaultPressSelector) {
      this.suppressDefaultPressSelector = this.initialSupressDefaultPressSelector;
    } else {
      this.suppressDefaultPressSelector = [
        this.suppressDefaultPressSelector,
        "mwc-textarea",
        "mwc-menu mwc-list-item",
        "mwc-select mwc-list-item"
      ].join(", ");
    }
    this.boundHandleClick = this.mdcFoundation.handleClick.bind(this.mdcFoundation);
    this.boundHandleKeydown = this.mdcFoundation.handleKeydown.bind(this.mdcFoundation);
    this.boundHandleDocumentKeydown = this.mdcFoundation.handleDocumentKeydown.bind(this.mdcFoundation);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.open && this.mdcFoundation && !this.mdcFoundation.isOpen()) {
      this.setEventListeners();
      this.mdcFoundation.open();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.open && this.mdcFoundation) {
      this.removeEventListeners();
      this.closingDueToDisconnect = true;
      this.mdcFoundation.close(this.currentAction || this.defaultAction);
      this.closingDueToDisconnect = false;
      this.currentAction = void 0;
      blockingElements.remove(this);
    }
  }
  forceLayout() {
    this.mdcFoundation.layout();
  }
  focus() {
    const initialFocusEl = this.getInitialFocusEl();
    initialFocusEl && initialFocusEl.focus();
  }
  blur() {
    if (!this.shadowRoot) {
      return;
    }
    const activeEl = this.shadowRoot.activeElement;
    if (activeEl) {
      if (activeEl instanceof HTMLElement) {
        activeEl.blur();
      }
    } else {
      const root2 = this.getRootNode();
      const activeEl2 = root2 instanceof Document ? root2.activeElement : null;
      if (activeEl2 instanceof HTMLElement) {
        activeEl2.blur();
      }
    }
  }
  setEventListeners() {
    if (this.boundHandleClick) {
      this.mdcRoot.addEventListener("click", this.boundHandleClick);
    }
    if (this.boundHandleKeydown) {
      this.mdcRoot.addEventListener("keydown", this.boundHandleKeydown, applyPassive());
    }
    if (this.boundHandleDocumentKeydown) {
      document.addEventListener("keydown", this.boundHandleDocumentKeydown, applyPassive());
    }
  }
  removeEventListeners() {
    if (this.boundHandleClick) {
      this.mdcRoot.removeEventListener("click", this.boundHandleClick);
    }
    if (this.boundHandleKeydown) {
      this.mdcRoot.removeEventListener("keydown", this.boundHandleKeydown);
    }
    if (this.boundHandleDocumentKeydown) {
      document.removeEventListener("keydown", this.boundHandleDocumentKeydown);
    }
  }
  close() {
    this.open = false;
  }
  show() {
    this.open = true;
  }
}
__decorate([
  query(".mdc-dialog")
], DialogBase.prototype, "mdcRoot", void 0);
__decorate([
  query('slot[name="primaryAction"]')
], DialogBase.prototype, "primarySlot", void 0);
__decorate([
  query('slot[name="secondaryAction"]')
], DialogBase.prototype, "secondarySlot", void 0);
__decorate([
  query("#contentSlot")
], DialogBase.prototype, "contentSlot", void 0);
__decorate([
  query(".mdc-dialog__content")
], DialogBase.prototype, "contentElement", void 0);
__decorate([
  query(".mdc-container")
], DialogBase.prototype, "conatinerElement", void 0);
__decorate([
  property({ type: Boolean })
], DialogBase.prototype, "hideActions", void 0);
__decorate([
  property({ type: Boolean }),
  observer(function() {
    this.forceLayout();
  })
], DialogBase.prototype, "stacked", void 0);
__decorate([
  property({ type: String })
], DialogBase.prototype, "heading", void 0);
__decorate([
  property({ type: String }),
  observer(function(newAction) {
    this.mdcFoundation.setScrimClickAction(newAction);
  })
], DialogBase.prototype, "scrimClickAction", void 0);
__decorate([
  property({ type: String }),
  observer(function(newAction) {
    this.mdcFoundation.setEscapeKeyAction(newAction);
  })
], DialogBase.prototype, "escapeKeyAction", void 0);
__decorate([
  property({ type: Boolean, reflect: true }),
  observer(function(isOpen) {
    if (this.mdcFoundation && this.isConnected) {
      if (isOpen) {
        this.setEventListeners();
        this.mdcFoundation.open();
      } else {
        this.removeEventListeners();
        this.mdcFoundation.close(this.currentAction || this.defaultAction);
        this.currentAction = void 0;
      }
    }
  })
], DialogBase.prototype, "open", void 0);
__decorate([
  property()
], DialogBase.prototype, "defaultAction", void 0);
__decorate([
  property()
], DialogBase.prototype, "actionAttribute", void 0);
__decorate([
  property()
], DialogBase.prototype, "initialFocusAttribute", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles = css$2`.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:0;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff;background-color:var(--mdc-elevation-overlay-color, #fff)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:7;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__surface{background-color:#fff;background-color:var(--mdc-theme-surface, #fff)}.mdc-dialog .mdc-dialog__scrim{background-color:rgba(0,0,0,.32)}.mdc-dialog .mdc-dialog__surface-scrim{background-color:rgba(0,0,0,.32)}.mdc-dialog .mdc-dialog__title{color:rgba(0,0,0,.87)}.mdc-dialog .mdc-dialog__content{color:rgba(0,0,0,.6)}.mdc-dialog .mdc-dialog__close{color:#000;color:var(--mdc-theme-on-surface, #000)}.mdc-dialog .mdc-dialog__close .mdc-icon-button__ripple::before,.mdc-dialog .mdc-dialog__close .mdc-icon-button__ripple::after{background-color:#000;background-color:var(--mdc-ripple-color, var(--mdc-theme-on-surface, #000))}.mdc-dialog .mdc-dialog__close:hover .mdc-icon-button__ripple::before,.mdc-dialog .mdc-dialog__close.mdc-ripple-surface--hover .mdc-icon-button__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-dialog .mdc-dialog__close.mdc-ripple-upgraded--background-focused .mdc-icon-button__ripple::before,.mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded):focus .mdc-icon-button__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded) .mdc-icon-button__ripple::after{transition:opacity 150ms linear}.mdc-dialog .mdc-dialog__close:not(.mdc-ripple-upgraded):active .mdc-icon-button__ripple::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-dialog .mdc-dialog__close.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title,.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions,.mdc-dialog.mdc-dialog--scrollable.mdc-dialog-scroll-divider-footer .mdc-dialog__actions{border-color:rgba(0,0,0,.12)}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:1px solid rgba(0,0,0,.12);margin-bottom:0}.mdc-dialog.mdc-dialog-scroll-divider-header.mdc-dialog--fullscreen .mdc-dialog__header{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2),0px 2px 2px 0px rgba(0, 0, 0, 0.14),0px 1px 5px 0px rgba(0,0,0,.12)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog .mdc-dialog__surface{border-radius:4px;border-radius:var(--mdc-shape-medium, 4px)}@media(max-width: 960px)and (max-height: 1440px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;max-width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 1023px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:calc(100vw - 112px)}}@media(max-width: 720px)and (max-height: 1023px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:560px}}@media(max-width: 720px)and (max-height: 1023px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (max-height: 1023px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px)and (max-height: 1023px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100%;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(max-width: 600px)and (max-height: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px)and (min-height: 1440px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;box-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2),0px 24px 38px 3px rgba(0, 0, 0, 0.14),0px 9px 46px 8px rgba(0,0,0,.12);display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid transparent;border-radius:inherit;content:"";pointer-events:none}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;line-height:normal;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-headline6-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1.25rem;font-size:var(--mdc-typography-headline6-font-size, 1.25rem);line-height:2rem;line-height:var(--mdc-typography-headline6-line-height, 2rem);font-weight:500;font-weight:var(--mdc-typography-headline6-font-weight, 500);letter-spacing:0.0125em;letter-spacing:var(--mdc-typography-headline6-letter-spacing, 0.0125em);text-decoration:inherit;text-decoration:var(--mdc-typography-headline6-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-headline6-text-transform, inherit);position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid transparent;display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid transparent}.mdc-dialog__content{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-body1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-body1-font-size, 1rem);line-height:1.5rem;line-height:var(--mdc-typography-body1-line-height, 1.5rem);font-weight:400;font-weight:var(--mdc-typography-body1-font-weight, 400);letter-spacing:0.03125em;letter-spacing:var(--mdc-typography-body1-letter-spacing, 0.03125em);text-decoration:inherit;text-decoration:var(--mdc-typography-body1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-body1-text-transform, inherit);flex-grow:1;box-sizing:border-box;margin:0;overflow:auto;-webkit-overflow-scrolling:touch}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid transparent}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1;z-index:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}#actions:not(.mdc-dialog__actions){display:none}.mdc-dialog__surface{box-shadow:var(--mdc-dialog-box-shadow, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}@media(min-width: 560px){.mdc-dialog .mdc-dialog__surface{max-width:560px;max-width:var(--mdc-dialog-max-width, 560px)}}.mdc-dialog .mdc-dialog__scrim{background-color:rgba(0, 0, 0, 0.32);background-color:var(--mdc-dialog-scrim-color, rgba(0, 0, 0, 0.32))}.mdc-dialog .mdc-dialog__title{color:rgba(0, 0, 0, 0.87);color:var(--mdc-dialog-heading-ink-color, rgba(0, 0, 0, 0.87))}.mdc-dialog .mdc-dialog__content{color:rgba(0, 0, 0, 0.6);color:var(--mdc-dialog-content-ink-color, rgba(0, 0, 0, 0.6))}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title,.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions{border-color:rgba(0, 0, 0, 0.12);border-color:var(--mdc-dialog-scroll-divider-color, rgba(0, 0, 0, 0.12))}.mdc-dialog .mdc-dialog__surface{min-width:280px;min-width:var(--mdc-dialog-min-width, 280px)}.mdc-dialog .mdc-dialog__surface{max-height:var(--mdc-dialog-max-height, calc(100% - 32px))}#actions ::slotted(*){margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] #actions ::slotted(*),#actions ::slotted(*[dir=rtl]){margin-left:0;margin-right:8px}[dir=rtl] #actions ::slotted(*),#actions ::slotted(*[dir=rtl]){text-align:left}.mdc-dialog--stacked #actions{flex-direction:column-reverse}.mdc-dialog--stacked #actions *:not(:last-child) ::slotted(*){flex-basis:.000000001px;margin-top:12px}`;
let Dialog = class Dialog2 extends DialogBase {
};
Dialog.styles = [styles];
Dialog = __decorate([
  customElement("mwc-dialog")
], Dialog);
function create_if_block_1$4(ctx) {
  let mwc_snackbar;
  let mwc_button;
  let mwc_snackbar_leading_value;
  let mwc_snackbar_timeoutms_value;
  let mwc_snackbar_labeltext_value;
  let mounted;
  let dispose;
  return {
    c() {
      mwc_snackbar = element("mwc-snackbar");
      mwc_button = element("mwc-button");
      mwc_button.textContent = "Show";
      set_custom_element_data(mwc_button, "primary", "");
      set_custom_element_data(mwc_button, "raised", "");
      set_custom_element_data(mwc_button, "class", "mwc-snackbar");
      set_custom_element_data(mwc_button, "slot", "action");
      set_custom_element_data(mwc_snackbar, "leading", mwc_snackbar_leading_value = true);
      set_custom_element_data(mwc_snackbar, "open", ctx[0]);
      set_custom_element_data(mwc_snackbar, "timeoutms", mwc_snackbar_timeoutms_value = -1);
      set_custom_element_data(mwc_snackbar, "labeltext", mwc_snackbar_labeltext_value = `Error while ${ctx[0].type === "TRANSPILER_ERROR" ? "transpiling" : "bundling"}`);
      set_custom_element_data(mwc_snackbar, "class", "iteria-ignore");
      set_style(mwc_snackbar, "--mdc-snackbar-action-color", "#007acc");
      set_style(mwc_snackbar, "--mdc-snackbar-z-index", "10000000");
    },
    m(target, anchor) {
      insert(target, mwc_snackbar, anchor);
      append$1(mwc_snackbar, mwc_button);
      if (!mounted) {
        dispose = listen(mwc_button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        set_custom_element_data(mwc_snackbar, "open", ctx2[0]);
      }
      if (dirty & 1 && mwc_snackbar_labeltext_value !== (mwc_snackbar_labeltext_value = `Error while ${ctx2[0].type === "TRANSPILER_ERROR" ? "transpiling" : "bundling"}`)) {
        set_custom_element_data(mwc_snackbar, "labeltext", mwc_snackbar_labeltext_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(mwc_snackbar);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$7(ctx) {
  let mwc_dialog;
  let pre;
  let t0_value = ctx[0].error.message + "";
  let t0;
  let t1;
  let mwc_button;
  let mounted;
  let dispose;
  return {
    c() {
      mwc_dialog = element("mwc-dialog");
      pre = element("pre");
      t0 = text$1(t0_value);
      t1 = space();
      mwc_button = element("mwc-button");
      mwc_button.textContent = "Ok";
      set_custom_element_data(mwc_button, "raised", "");
      set_custom_element_data(mwc_button, "slot", "primaryAction");
      set_custom_element_data(mwc_button, "dialogaction", "accept");
      set_custom_element_data(mwc_dialog, "class", "mwc-dialog iteria-ignore");
      set_custom_element_data(mwc_dialog, "heading", "Error info");
      set_custom_element_data(mwc_dialog, "open", "");
      set_style(mwc_dialog, "--mdc-dialog-max-width", "auto");
      set_style(mwc_dialog, "--mdc-dialog-z-index", "10000000");
    },
    m(target, anchor) {
      insert(target, mwc_dialog, anchor);
      append$1(mwc_dialog, pre);
      append$1(pre, t0);
      append$1(mwc_dialog, t1);
      append$1(mwc_dialog, mwc_button);
      if (!mounted) {
        dispose = listen(mwc_button, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[0].error.message + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(mwc_dialog);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$j(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = ctx[0] && create_if_block_1$4(ctx);
  let if_block1 = ctx[0] && ctx[1] && create_if_block$7(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$4(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0] && ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$7(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { bundlerError } = $$props;
  let openDialog = false;
  const click_handler2 = () => $$invalidate(1, openDialog = !openDialog);
  const click_handler_1 = () => $$invalidate(1, openDialog = false);
  $$self.$$set = ($$props2) => {
    if ("bundlerError" in $$props2)
      $$invalidate(0, bundlerError = $$props2.bundlerError);
  };
  return [bundlerError, openDialog, click_handler2, click_handler_1];
}
class ErrorSnackbar extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$j, create_fragment$j, safe_not_equal, { bundlerError: 0 });
  }
}
var VscNewFile = {
  a: {
    viewBox: "0 0 16 16",
    fill: "currentColor"
  },
  c: '<path fill-rule="evenodd" clip-rule="evenodd" d="M4 7H3V4H0V3h3V0h1v3h3v1H4v3zm6.5-5.9l3.4 3.5.1.4v8.5l-.5.5h-10l-.5-.5V8h1v5h9V6H9V2H5V1h5.2l.3.1zM10 2v3h2.9L10 2z"></path>'
};
var AiOutlineEyeInvisible = {
  a: {
    viewBox: "0 0 1024 1024"
  },
  c: '<path d="M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 0 0 0-51.5zm-63.57-320.64L836 122.88a8 8 0 0 0-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 0 0 0 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 0 0 0 11.31L155.17 889a8 8 0 0 0 11.31 0l712.15-712.12a8 8 0 0 0 0-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 0 0-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 0 1 146.2-106.69L401.31 546.2A112 112 0 0 1 396 512z"></path><path d="M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 0 0 227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 0 1-112 112z"></path>'
};
var AiOutlineEye = {
  a: {
    viewBox: "0 0 1024 1024"
  },
  c: '<path d="M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 0 0 0 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z"></path>'
};
var BsLayoutThreeColumns = {
  a: {
    viewBox: "0 0 16 16",
    fill: "currentColor"
  },
  c: '<path fill-rule="evenodd" d="M0 2.5A1.5 1.5 0 0 1 1.5 1h13A1.5 1.5 0 0 1 16 2.5v11a1.5 1.5 0 0 1-1.5 1.5h-13A1.5 1.5 0 0 1 0 13.5v-11zM1.5 2a.5.5 0 0 0-.5.5v11a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-11a.5.5 0 0 0-.5-.5h-13z"></path><path fill-rule="evenodd" d="M5 15V1h1v14H5zm5 0V1h1v14h-1z"></path>'
};
var SiGoogletranslate = {
  a: {
    role: "img",
    viewBox: "0 0 24 24"
  },
  c: '<title></title><path d="M1.597 0C.719 0 0 .719 0 1.599v16.275c0 .878.719 1.597 1.597 1.597h10L13.074 24h9.33C23.28 24 24 23.293 24 22.428V6.39c0-.865-.719-1.572-1.597-1.572h-9.93L10.927 0zm11.109 5.539h9.697c.234 0 .455.091.62.255a.834.834 0 01.256.596v16.038a.824.824 0 01-.255.596.881.881 0 01-.62.255h-8.677l3.45-3.808h.004l-.74-2.302c.01-.009.58-.501 1.283-1.247a52.6 52.6 0 002.818 2.806l.772-.772c-1.272-1.154-2.205-2.07-2.89-2.805.918-1.087 1.851-2.455 2.049-3.708h2.034v.003h.002v-.94h-4.532v-1.52h-1.472v1.52h-2.204zm-5.966.46c1.012 0 1.861.374 2.513.975l-.99.952a2.194 2.194 0 00-1.523-.584c-1.306 0-2.364 1.08-2.364 2.409 0 1.33 1.058 2.409 2.364 2.409 1.508 0 2.13-1.08 2.19-1.808l-2.188-.002V9.066h3.511c.05.23.089.457.089.764 0 2.147-1.433 3.669-3.602 3.669a3.752 3.752 0 01-3.751-3.75c0-2.07 1.68-3.75 3.751-3.75zm7.863 5.447h4.766c-.308 1.084-.988 2.108-1.652 2.904-1.176-1.392-1.18-1.844-1.18-1.844h-1.222s.05.678 1.7 2.61c-.533.546-.946.875-.95.88Z"></path>'
};
var BiBrush = {
  a: {
    viewBox: "0 0 24 24"
  },
  c: '<path d="M13.707,2.293c-0.391-0.391-1.023-0.391-1.414,0l-5.84,5.84C6.438,8.132,6.424,8.124,6.409,8.124 c-0.265,0-0.52,0.105-0.707,0.293L4.288,9.831c-0.566,0.567-0.878,1.321-0.878,2.122c0,0.802,0.313,1.556,0.879,2.121l0.707,0.707 l-2.122,2.122C2.299,17.477,1.989,18.234,2,19.012c-0.011,0.887,0.377,1.729,1.063,2.308C3.582,21.759,4.251,22,4.948,22 c0.834,0,1.654-0.341,2.25-0.937l2.04-2.039l0.707,0.706c1.134,1.133,3.109,1.134,4.242,0.001l1.415-1.414 c0.188-0.188,0.293-0.441,0.293-0.707c0-0.026-0.013-0.05-0.015-0.076l5.827-5.827c0.391-0.391,0.391-1.023,0-1.414L13.707,2.293z M12.772,18.317c-0.377,0.377-1.036,0.378-1.414-0.001l-1.414-1.413c-0.391-0.391-1.023-0.391-1.414,0l-2.746,2.745 C5.561,19.872,5.256,20,4.948,20c-0.159,0-0.391-0.036-0.594-0.208C4.122,19.597,3.997,19.327,4,19.01 c-0.003-0.258,0.099-0.504,0.287-0.692l2.829-2.829c0.391-0.391,0.391-1.023,0-1.414l-1.415-1.415 c-0.188-0.188-0.292-0.438-0.292-0.706s0.104-0.519,0.293-0.708l0.707-0.707l7.071,7.072L12.772,18.317z M14.661,15.925 L8.075,9.339L13,4.414L19.586,11L14.661,15.925z"></path>'
};
var AiOutlineCluster = {
  a: {
    viewBox: "0 0 1024 1024"
  },
  c: '<path d="M888 680h-54V540H546v-92h238c8.8 0 16-7.2 16-16V168c0-8.8-7.2-16-16-16H240c-8.8 0-16 7.2-16 16v264c0 8.8 7.2 16 16 16h238v92H190v140h-54c-4.4 0-8 3.6-8 8v176c0 4.4 3.6 8 8 8h176c4.4 0 8-3.6 8-8V688c0-4.4-3.6-8-8-8h-54v-72h220v72h-54c-4.4 0-8 3.6-8 8v176c0 4.4 3.6 8 8 8h176c4.4 0 8-3.6 8-8V688c0-4.4-3.6-8-8-8h-54v-72h220v72h-54c-4.4 0-8 3.6-8 8v176c0 4.4 3.6 8 8 8h176c4.4 0 8-3.6 8-8V688c0-4.4-3.6-8-8-8zM256 805.3c0 1.5-1.2 2.7-2.7 2.7h-58.7c-1.5 0-2.7-1.2-2.7-2.7v-58.7c0-1.5 1.2-2.7 2.7-2.7h58.7c1.5 0 2.7 1.2 2.7 2.7v58.7zm288 0c0 1.5-1.2 2.7-2.7 2.7h-58.7c-1.5 0-2.7-1.2-2.7-2.7v-58.7c0-1.5 1.2-2.7 2.7-2.7h58.7c1.5 0 2.7 1.2 2.7 2.7v58.7zM288 384V216h448v168H288zm544 421.3c0 1.5-1.2 2.7-2.7 2.7h-58.7c-1.5 0-2.7-1.2-2.7-2.7v-58.7c0-1.5 1.2-2.7 2.7-2.7h58.7c1.5 0 2.7 1.2 2.7 2.7v58.7zM360 300a40 40 0 1 0 80 0 40 40 0 1 0-80 0z"></path>'
};
var SiGraphql = {
  a: {
    role: "img",
    viewBox: "0 0 24 24"
  },
  c: '<title></title><path d="M14.051 2.751l4.935 2.85c.816-.859 2.173-.893 3.032-.077.148.14.274.301.377.477.589 1.028.232 2.339-.796 2.928-.174.1-.361.175-.558.223v5.699c1.146.273 1.854 1.423 1.58 2.569-.048.204-.127.4-.232.581-.592 1.023-1.901 1.374-2.927.782-.196-.113-.375-.259-.526-.429l-4.905 2.832c.372 1.124-.238 2.335-1.361 2.706-.217.071-.442.108-.67.108-1.181.001-2.139-.955-2.14-2.136 0-.205.029-.41.088-.609l-4.936-2.847c-.816.854-2.171.887-3.026.07-.854-.816-.886-2.171-.07-3.026.283-.297.646-.506 1.044-.603l.001-5.699c-1.15-.276-1.858-1.433-1.581-2.584.047-.198.123-.389.224-.566.592-1.024 1.902-1.374 2.927-.782.177.101.339.228.48.377l4.938-2.85C9.613 1.612 10.26.423 11.39.088 11.587.029 11.794 0 12 0c1.181-.001 2.139.954 2.14 2.134.001.209-.03.418-.089.617zm-.515.877c-.019.021-.037.039-.058.058l6.461 11.19c.026-.009.056-.016.082-.023V9.146c-1.145-.283-1.842-1.442-1.558-2.588.006-.024.012-.049.019-.072l-4.946-2.858zm-3.015.059l-.06-.06-4.946 2.852c.327 1.135-.327 2.318-1.461 2.645-.026.008-.051.014-.076.021v5.708l.084.023 6.461-11.19-.002.001zm2.076.507c-.39.112-.803.112-1.192 0l-6.46 11.189c.294.283.502.645.6 1.041h12.911c.097-.398.307-.761.603-1.044L12.597 4.194zm.986 16.227l4.913-2.838c-.015-.047-.027-.094-.038-.142H5.542l-.021.083 4.939 2.852c.388-.404.934-.653 1.54-.653.627 0 1.19.269 1.583.698z"></path>'
};
var BiGitCommit = {
  a: {
    viewBox: "0 0 24 24"
  },
  c: '<path d="M12,6c-2.967,0-5.431,2.167-5.909,5H2v2h4.092c0.479,2.832,2.942,4.998,5.909,4.998s5.43-2.166,5.909-4.998H22v-2h-4.09 C17.432,8.167,14.968,6,12,6z M12,15.998c-2.205,0-3.999-1.794-3.999-3.999S9.795,8,12,8c2.206,0,4,1.794,4,3.999 S14.206,15.998,12,15.998z"></path>'
};
var AiOutlineDownload = {
  a: {
    viewBox: "0 0 1024 1024"
  },
  c: '<path d="M505.7 661a8 8 0 0 0 12.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z"></path>'
};
function add_css$9(target) {
  append_styles(target, "svelte-jt2bkg", ".fab-container.svelte-jt2bkg>li.svelte-jt2bkg{transition:transform 300ms ease-in-out}.fab-container.svelte-jt2bkg>li.svelte-jt2bkg:hover{transform:translate(10px, 0)}.save-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#B8860B}.commit-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#e53935}.column-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#43a047}.translate-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#4183c4}.tippy-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#fb8c00}.generate-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#3f51b5}.graphql-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#e10098}.viewERD-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#008080}.theme-icon.svelte-jt2bkg.svelte-jt2bkg:hover{color:#FF7F50}.fab-icon-label.svelte-jt2bkg.svelte-jt2bkg{padding-top:4px;color:#000 !important}.fab-download-icon-label.svelte-jt2bkg.svelte-jt2bkg{padding-top:5px}.fab-icon-container.svelte-jt2bkg.svelte-jt2bkg{width:48px;margin:2px;background-image:linear-gradient(\n      rgb(255, 255, 255),\n      rgb(244, 245, 247)\n    ) !important;box-shadow:rgb(67 90 111 / 14%) 0px 0px 0px 1px inset,\n      rgb(67 90 111 / 6%) 0px -1px 1px 0px inset;border-top-right-radius:8px;border-bottom-right-radius:8px;align-items:center;justify-content:center;height:52px;display:flex;cursor:pointer;transition:transform 0.3s;font-size:10px;flex-direction:column;text-align:center}.fab-container.svelte-jt2bkg.svelte-jt2bkg{z-index:10000000000;display:none;list-style-type:none;justify-content:space-evenly;align-items:center;opacity:0;transition:all 0.2s ease-in-out;flex-direction:column;left:-2px;position:absolute;bottom:5rem}.main-container.svelte-jt2bkg.svelte-jt2bkg{line-height:1.15;-webkit-text-size-adjust:100%;font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica,\n      Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;position:fixed;bottom:0px;left:0px;box-sizing:border-box;transform:translate(0px, 0px);display:flex;flex-direction:column-reverse;z-index:1000000000}.icon-container.svelte-jt2bkg.svelte-jt2bkg{line-height:1.15;-webkit-text-size-adjust:100%;font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica,\n      Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol;box-sizing:border-box;padding-bottom:32px;position:relative;transition:transform 240ms cubic-bezier(0, 0, 0.2, 1) 0s;display:flex}.icon-container.svelte-jt2bkg:hover+.fab-container.svelte-jt2bkg,.fab-container.svelte-jt2bkg.svelte-jt2bkg:hover{display:flex;opacity:1;transition:all 0.3s ease-in-out}.svg-wrapper.svelte-jt2bkg.svelte-jt2bkg{-webkit-text-size-adjust:100%;text-transform:none;-webkit-font-smoothing:antialiased;font-weight:400;user-select:none;cursor:pointer;white-space:nowrap;font-family:'SF UI Text', -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji',\n      'Segoe UI Emoji', 'Segoe UI Symbol';color:rgb(66, 90, 112);font-size:16px;line-height:20px;letter-spacing:-0.05px;box-sizing:border-box;align-items:center;-webkit-box-align:center;justify-content:center;-webkit-box-pack:center;display:flex;flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal}.main-button.svelte-jt2bkg.svelte-jt2bkg{-webkit-text-size-adjust:100%;margin:0;overflow:visible;text-transform:none;-webkit-font-smoothing:antialiased;appearance:none;box-sizing:border-box;position:relative;width:48px;font-weight:400;display:inline-flex;align-items:center;-webkit-box-align:center;justify-content:center;-webkit-box-pack:center;text-decoration:none;vertical-align:middle;border-bottom:0px;border-left:0px;border-right:0px;border-top:0px;outline:none;user-select:none;cursor:pointer;white-space:nowrap;font-family:'SF UI Text', -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji',\n      'Segoe UI Emoji', 'Segoe UI Symbol';border-bottom-left-radius:0px;border-bottom-right-radius:8px;border-top-left-radius:0px;border-top-right-radius:8px;color:rgb(66, 90, 112);height:48px;min-width:32px;font-size:16px;line-height:20px;padding-left:4px;padding-right:4px;background-color:white;background-image:linear-gradient(\n      rgb(255, 255, 255),\n      rgb(244, 245, 247)\n    ) !important;box-shadow:rgba(67, 90, 111, 0.14) 0px 0px 0px 1px inset,\n      rgba(67, 90, 111, 0.06) 0px -1px 1px 0px inset;padding-bottom:4px;padding-top:4px;transition:all 240ms ease 210ms;letter-spacing:-0.05px;transform:translateX(0px)}.svg-hamburger.svelte-jt2bkg.svelte-jt2bkg{-webkit-text-size-adjust:100%;text-transform:none;-webkit-font-smoothing:antialiased;font-weight:400;user-select:none;cursor:pointer;white-space:nowrap;font-family:'SF UI Text', -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji',\n      'Segoe UI Emoji', 'Segoe UI Symbol';color:rgb(66, 90, 112);font-size:16px;line-height:20px;letter-spacing:-0.05px;-webkit-box-direction:normal;fill:rgb(100, 111, 115);box-sizing:border-box;position:relative;left:2px;top:3px;width:16px;height:16px}.iteria-logo.svelte-jt2bkg.svelte-jt2bkg{-webkit-text-size-adjust:100%;text-transform:none;-webkit-font-smoothing:antialiased;font-weight:400;user-select:none;cursor:pointer;white-space:nowrap;font-family:'SF UI Text', -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji',\n      'Segoe UI Emoji', 'Segoe UI Symbol';color:rgb(66, 90, 112);font-size:16px;line-height:20px;letter-spacing:-0.05px;-webkit-box-direction:normal;-webkit-user-drag:none;border-style:none;box-sizing:border-box;height:20px;width:20px}");
}
function create_if_block$6(ctx) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let div2;
  let div1;
  let t1;
  let ul;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let current;
  let if_block0 = !ctx[2] && ((_a2 = ctx[4]) == null ? void 0 : _a2.save) != false && create_if_block_11$1(ctx);
  let if_block1 = ctx[3] && ((_b = ctx[4]) == null ? void 0 : _b.commit) != false && create_if_block_10$1(ctx);
  let if_block2 = ((_c = ctx[4]) == null ? void 0 : _c.addFields) != false && create_if_block_9$1(ctx);
  let if_block3 = ((_d = ctx[4]) == null ? void 0 : _d.translations) != false && create_if_block_8$1(ctx);
  let if_block4 = ((_e = ctx[4]) == null ? void 0 : _e.tippy) != false && create_if_block_6$1(ctx);
  let if_block5 = ((_f = ctx[4]) == null ? void 0 : _f.generator) != false && create_if_block_5$1(ctx);
  let if_block6 = ((_g = ctx[4]) == null ? void 0 : _g.graphQLEndpoint) != false && create_if_block_4$1(ctx);
  let if_block7 = ((_h = ctx[4]) == null ? void 0 : _h.erd) != false && create_if_block_3$2(ctx);
  let if_block8 = ((_i = ctx[4]) == null ? void 0 : _i.themeEditor) != false && create_if_block_2$2(ctx);
  let if_block9 = ((_j = ctx[4]) == null ? void 0 : _j.vsCode) != false && create_if_block_1$3(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<button class="main-button svelte-jt2bkg"><div class="svg-wrapper svelte-jt2bkg"><img src="https://iteria.app/favicon.ico" alt="Iteria logo" class="iteria-logo svelte-jt2bkg"/> 
          <svg class="svg-hamburger svelte-jt2bkg" data-icon="hamburger" viewBox="0 0 16 16"><path d="M0 1.00001C0 0.50295 0.402944 0.100006 0.9 0.100006H9.1C9.59706 0.100006 10 0.50295 10 1.00001C10 1.49706 9.59706 1.90001 9.1 1.90001H0.9C0.402944 1.90001 0 1.49706 0 1.00001Z" fill-rule="evenodd"></path><path d="M0 5.00001C0 4.50295 0.402944 4.10001 0.9 4.10001H9.1C9.59706 4.10001 10 4.50295 10 5.00001C10 5.49706 9.59706 5.90001 9.1 5.90001H0.9C0.402944 5.90001 0 5.49706 0 5.00001Z" fill-rule="evenodd"></path><path d="M0.9 8.10001C0.402944 8.10001 0 8.50295 0 9.00001C0 9.49706 0.402944 9.90001 0.9 9.90001H9.1C9.59706 9.90001 10 9.49706 10 9.00001C10 8.50295 9.59706 8.10001 9.1 8.10001H0.9Z" fill-rule="evenodd"></path></svg></div></button>`;
      t1 = space();
      ul = element("ul");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      t7 = space();
      if (if_block6)
        if_block6.c();
      t8 = space();
      if (if_block7)
        if_block7.c();
      t9 = space();
      if (if_block8)
        if_block8.c();
      t10 = space();
      if (if_block9)
        if_block9.c();
      attr(div1, "class", "icon-container svelte-jt2bkg");
      attr(ul, "class", "fab-container svelte-jt2bkg");
      attr(div2, "class", "iteria-ignore main-container svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, div1);
      append$1(div2, t1);
      append$1(div2, ul);
      if (if_block0)
        if_block0.m(ul, null);
      append$1(ul, t2);
      if (if_block1)
        if_block1.m(ul, null);
      append$1(ul, t3);
      if (if_block2)
        if_block2.m(ul, null);
      append$1(ul, t4);
      if (if_block3)
        if_block3.m(ul, null);
      append$1(ul, t5);
      if (if_block4)
        if_block4.m(ul, null);
      append$1(ul, t6);
      if (if_block5)
        if_block5.m(ul, null);
      append$1(ul, t7);
      if (if_block6)
        if_block6.m(ul, null);
      append$1(ul, t8);
      if (if_block7)
        if_block7.m(ul, null);
      append$1(ul, t9);
      if (if_block8)
        if_block8.m(ul, null);
      append$1(ul, t10);
      if (if_block9)
        if_block9.m(ul, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a3, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
      if (!ctx2[2] && ((_a3 = ctx2[4]) == null ? void 0 : _a3.save) != false) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_11$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(ul, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3] && ((_b2 = ctx2[4]) == null ? void 0 : _b2.commit) != false) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 24) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_10$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(ul, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (((_c2 = ctx2[4]) == null ? void 0 : _c2.addFields) != false) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(ul, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (((_d2 = ctx2[4]) == null ? void 0 : _d2.translations) != false) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_8$1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(ul, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (((_e2 = ctx2[4]) == null ? void 0 : _e2.tippy) != false) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_6$1(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(ul, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (((_f2 = ctx2[4]) == null ? void 0 : _f2.generator) != false) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_5$1(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(ul, t7);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (((_g2 = ctx2[4]) == null ? void 0 : _g2.graphQLEndpoint) != false) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_4$1(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(ul, t8);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (((_h2 = ctx2[4]) == null ? void 0 : _h2.erd) != false) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_3$2(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(ul, t9);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (((_i2 = ctx2[4]) == null ? void 0 : _i2.themeEditor) != false) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_2$2(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(ul, t10);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (((_j2 = ctx2[4]) == null ? void 0 : _j2.vsCode) != false) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
        } else {
          if_block9 = create_if_block_1$3(ctx2);
          if_block9.c();
          if_block9.m(ul, null);
        }
      } else if (if_block9) {
        if_block9.d(1);
        if_block9 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
    }
  };
}
function create_if_block_11$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: AiOutlineDownload,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Save Zip";
      attr(span, "class", "fab-icon-label fab-download-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container save-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[7]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: BiGitCommit,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Commit Changes";
      attr(span, "class", "fab-icon-label fab-download-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container commit-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[8]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: BsLayoutThreeColumns,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Add field";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container column-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[9]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: SiGoogletranslate,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Translate";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container translate-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[10]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$1(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let t0;
  let span;
  let t1_value = ctx[5] ? "Hide" : "Show";
  let t1;
  let br;
  let t2;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_7$1, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      li = element("li");
      if_block.c();
      t0 = space();
      span = element("span");
      t1 = text$1(t1_value);
      br = element("br");
      t2 = text$1("Tippy");
      attr(span, "class", "fab-icon-label  svelte-jt2bkg");
      attr(li, "class", "fab-icon-container tippy-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      append$1(li, t0);
      append$1(li, span);
      append$1(span, t1);
      append$1(span, br);
      append$1(span, t2);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, t0);
      }
      if ((!current || dirty & 32) && t1_value !== (t1_value = ctx2[5] ? "Hide" : "Show"))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$2(ctx) {
  let icon;
  let current;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: AiOutlineEye,
      size: "24"
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_7$1(ctx) {
  let icon;
  let current;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: AiOutlineEyeInvisible,
      size: "24"
    }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: VscNewFile,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Generate Page";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container generate-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[12]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$1(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: SiGraphql,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "GraphQL Endpoint";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container graphql-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$2(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: AiOutlineCluster,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "ERD";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container viewERD-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$2(ctx) {
  let li;
  let icon;
  let t0;
  let span;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$1({
    props: {
      color: "currentColor",
      src: BiBrush,
      size: "24"
    }
  });
  return {
    c() {
      li = element("li");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = "Theme Editor";
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container theme-icon svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(icon, li, null);
      append$1(li, t0);
      append$1(li, span);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[15]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$3(ctx) {
  let li;
  let html_tag;
  let raw_value = icons$1.code + "";
  let t0;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      html_tag = new HtmlTag();
      t0 = space();
      span = element("span");
      span.textContent = "VS Code";
      html_tag.a = t0;
      attr(span, "class", "fab-icon-label svelte-jt2bkg");
      attr(li, "class", "fab-icon-container show-vs-code svelte-jt2bkg");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      html_tag.m(raw_value, li);
      append$1(li, t0);
      append$1(li, span);
      if (!mounted) {
        dispose = listen(li, "click", ctx[16]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$i(ctx) {
  var _a2;
  let if_block_anchor;
  let current;
  let if_block = ((_a2 = ctx[4]) == null ? void 0 : _a2.floatingButton) != false && create_if_block$6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a3;
      if (((_a3 = ctx2[4]) == null ? void 0 : _a3.floatingButton) != false) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { hidden: hidden2 = false } = $$props;
  let { isDevserver = false } = $$props;
  let { isNetlify = false } = $$props;
  let { features = void 0 } = $$props;
  let { showTippy } = $$props;
  let { showVsCode } = $$props;
  const click_handler2 = () => dispatch2("saveProjectZip");
  const click_handler_1 = () => dispatch2("commitAllChanges");
  const click_handler_2 = () => dispatch2("addColumn");
  const click_handler_3 = () => dispatch2("editTranslations");
  const click_handler_4 = () => dispatch2("toggleTippy");
  const click_handler_5 = () => dispatch2("generatePage");
  const click_handler_6 = () => dispatch2("changeGraphqlEndpoint");
  const click_handler_7 = () => dispatch2("viewERD");
  const click_handler_8 = () => dispatch2("changeTheme");
  const click_handler_9 = () => {
    $$invalidate(0, hidden2 = false);
    window.windows.vscode.show();
    $$invalidate(1, showVsCode = true);
  };
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden2 = $$props2.hidden);
    if ("isDevserver" in $$props2)
      $$invalidate(2, isDevserver = $$props2.isDevserver);
    if ("isNetlify" in $$props2)
      $$invalidate(3, isNetlify = $$props2.isNetlify);
    if ("features" in $$props2)
      $$invalidate(4, features = $$props2.features);
    if ("showTippy" in $$props2)
      $$invalidate(5, showTippy = $$props2.showTippy);
    if ("showVsCode" in $$props2)
      $$invalidate(1, showVsCode = $$props2.showVsCode);
  };
  return [
    hidden2,
    showVsCode,
    isDevserver,
    isNetlify,
    features,
    showTippy,
    dispatch2,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8,
    click_handler_9
  ];
}
class FloatingButton extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$i, create_fragment$i, safe_not_equal, {
      hidden: 0,
      isDevserver: 2,
      isNetlify: 3,
      features: 4,
      showTippy: 5,
      showVsCode: 1
    }, add_css$9);
  }
}
function create_fragment$h(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: TranslationSheet,
      props: {
        okButton: true,
        translations: ctx[3].translations
      },
      events: {
        change: ctx[4],
        close: ctx[5],
        ok: ctx[6]
      },
      x: ctx[0],
      y: ctx[1],
      title: ctx[2]
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 8)
        winbox_changes.props = {
          okButton: true,
          translations: ctx2[3].translations
        };
      if (dirty & 1)
        winbox_changes.x = ctx2[0];
      if (dirty & 2)
        winbox_changes.y = ctx2[1];
      if (dirty & 4)
        winbox_changes.title = ctx2[2];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { title = "Fields" } = $$props;
  let { translations = {} } = $$props;
  const dispatch2 = createEventDispatcher();
  function change(e) {
    const data = { translations: e.detail };
    dispatch2("change", data);
  }
  function close() {
    dispatch2("close", []);
  }
  function ok(event2) {
    dispatch2("ok", event2.detail);
  }
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(0, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y2 = $$props2.y);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("translations" in $$props2)
      $$invalidate(3, translations = $$props2.translations);
  };
  return [x2, y2, title, translations, change, close, ok];
}
class TranslationSheetDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$h, create_fragment$h, safe_not_equal, { x: 0, y: 1, title: 2, translations: 3 });
  }
}
function add_css$8(target) {
  append_styles(target, "svelte-6cdfbb", ".ok-button.svelte-6cdfbb{position:fixed;top:0;right:0;z-index:2\n  }.input-fields.svelte-6cdfbb{height:100%;width:100%;-ms-overflow-style:none;scrollbar-width:none}.input-fields.svelte-6cdfbb::-webkit-scrollbar{width:0;background:transparent}.switch.svelte-6cdfbb{margin-top:0.5rem;margin-bottom:0.5rem;margin-left:1.5rem}.column-container.svelte-6cdfbb{width:100%;background-color:#181818}");
}
function create_if_block$5(ctx) {
  let fast_tabs;
  let fast_tab0;
  let t1;
  let fast_tab1;
  let t3;
  let fast_tab_panel0;
  let t5;
  let fast_tab_panel1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$2, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      fast_tabs = element("fast-tabs");
      fast_tab0 = element("fast-tab");
      fast_tab0.textContent = "Clone Element";
      t1 = space();
      fast_tab1 = element("fast-tab");
      fast_tab1.textContent = "Clone Column";
      t3 = space();
      fast_tab_panel0 = element("fast-tab-panel");
      fast_tab_panel0.textContent = "Clone Element";
      t5 = space();
      fast_tab_panel1 = element("fast-tab-panel");
      if_block.c();
      set_custom_element_data(fast_tab0, "id", "cloneElement");
      set_custom_element_data(fast_tab1, "id", "cloneColumn");
      set_custom_element_data(fast_tab_panel0, "id", "cloneElementPanel");
      set_custom_element_data(fast_tab_panel1, "id", "cloneColumnPanel");
      set_custom_element_data(fast_tabs, "activeid", "cloneElement");
      set_style(fast_tabs, "width", "100%");
      set_style(fast_tabs, "height", "100%");
    },
    m(target, anchor) {
      insert(target, fast_tabs, anchor);
      append$1(fast_tabs, fast_tab0);
      append$1(fast_tabs, t1);
      append$1(fast_tabs, fast_tab1);
      append$1(fast_tabs, t3);
      append$1(fast_tabs, fast_tab_panel0);
      append$1(fast_tabs, t5);
      append$1(fast_tabs, fast_tab_panel1);
      if_blocks[current_block_type_index].m(fast_tab_panel1, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(fast_tab_panel1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_tabs);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block$1(ctx) {
  let p2;
  return {
    c() {
      p2 = element("p");
      p2.textContent = "Loading...";
    },
    m(target, anchor) {
      insert(target, p2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function create_if_block_1$2(ctx) {
  let div2;
  let fast_switch;
  let t0;
  let t1;
  let fast_switch_checked_value;
  let t2;
  let pickfield;
  let current;
  let mounted;
  let dispose;
  pickfield = new PickField({
    props: {
      mode: ctx[4],
      onlyEntities: ctx[5],
      intro: ctx[1]
    }
  });
  pickfield.$on("change", ctx[8]);
  return {
    c() {
      div2 = element("div");
      fast_switch = element("fast-switch");
      t0 = text$1("Insert ");
      t1 = text$1(ctx[0]);
      t2 = space();
      create_component(pickfield.$$.fragment);
      set_custom_element_data(fast_switch, "class", "switch svelte-6cdfbb");
      set_custom_element_data(fast_switch, "checked", fast_switch_checked_value = ctx[0] === "after");
      attr(div2, "class", "column-container svelte-6cdfbb");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, fast_switch);
      append$1(fast_switch, t0);
      append$1(fast_switch, t1);
      append$1(div2, t2);
      mount_component(pickfield, div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(fast_switch, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1)
        set_data(t1, ctx2[0]);
      if (!current || dirty & 1 && fast_switch_checked_value !== (fast_switch_checked_value = ctx2[0] === "after")) {
        set_custom_element_data(fast_switch, "checked", fast_switch_checked_value);
      }
      const pickfield_changes = {};
      if (dirty & 16)
        pickfield_changes.mode = ctx2[4];
      if (dirty & 32)
        pickfield_changes.onlyEntities = ctx2[5];
      if (dirty & 2)
        pickfield_changes.intro = ctx2[1];
      pickfield.$set(pickfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pickfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(pickfield);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$g(ctx) {
  let fast_design_system_provider;
  let fast_button;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = (ctx[2] || ctx[3]) && create_if_block$5(ctx);
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      fast_button = element("fast-button");
      fast_button.textContent = "OK";
      t1 = space();
      if (if_block)
        if_block.c();
      set_custom_element_data(fast_button, "class", "ok-button svelte-6cdfbb");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_custom_element_data(fast_design_system_provider, "class", "input-fields svelte-6cdfbb");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, fast_button);
      append$1(fast_design_system_provider, t1);
      if (if_block)
        if_block.m(fast_design_system_provider, null);
      current = true;
      if (!mounted) {
        dispose = listen(fast_button, "click", function() {
          if (is_function(ctx[7]("ok", {
            fields: ctx[6],
            __typename: ctx[3],
            beforeAfter: ctx[0]
          })))
            ctx[7]("ok", {
              fields: ctx[6],
              __typename: ctx[3],
              beforeAfter: ctx[0]
            }).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[2] || ctx[3]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fast_design_system_provider, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { intro } = $$props;
  let { isInsideTable: isInsideTable2 } = $$props;
  let { __typename } = $$props;
  let { mode = "one" } = $$props;
  let { onlyEntities = false } = $$props;
  let fields22;
  const dispatch2 = createEventDispatcher();
  let { beforeAfter = "after" } = $$props;
  function handleChange(event2) {
    $$invalidate(6, fields22 = event2.detail);
    dispatch2("select", { fields: event2.detail });
  }
  const handleBeforeAfter = (e) => {
    $$invalidate(0, beforeAfter = e.target.checked ? "after" : "before");
    handleChange(new CustomEvent("change", { detail: fields22 }));
  };
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(1, intro = $$props2.intro);
    if ("isInsideTable" in $$props2)
      $$invalidate(2, isInsideTable2 = $$props2.isInsideTable);
    if ("__typename" in $$props2)
      $$invalidate(3, __typename = $$props2.__typename);
    if ("mode" in $$props2)
      $$invalidate(4, mode = $$props2.mode);
    if ("onlyEntities" in $$props2)
      $$invalidate(5, onlyEntities = $$props2.onlyEntities);
    if ("beforeAfter" in $$props2)
      $$invalidate(0, beforeAfter = $$props2.beforeAfter);
  };
  return [
    beforeAfter,
    intro,
    isInsideTable2,
    __typename,
    mode,
    onlyEntities,
    fields22,
    dispatch2,
    handleChange,
    handleBeforeAfter
  ];
}
class CloneComponent extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$g, create_fragment$g, safe_not_equal, {
      intro: 1,
      isInsideTable: 2,
      __typename: 3,
      mode: 4,
      onlyEntities: 5,
      beforeAfter: 0
    }, add_css$8);
  }
}
function create_fragment$f(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      classes: "iteria-ignore",
      component: CloneComponent,
      props: {
        intro: ctx[0],
        okButton: true,
        mode: ctx[6],
        isInsideTable: ctx[1],
        __typename: ctx[2]
      },
      events: {
        close: ctx[7],
        ok: ctx[8]
      },
      x: ctx[3],
      y: ctx[4],
      title: ctx[5]
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 71)
        winbox_changes.props = {
          intro: ctx2[0],
          okButton: true,
          mode: ctx2[6],
          isInsideTable: ctx2[1],
          __typename: ctx2[2]
        };
      if (dirty & 8)
        winbox_changes.x = ctx2[3];
      if (dirty & 16)
        winbox_changes.y = ctx2[4];
      if (dirty & 32)
        winbox_changes.title = ctx2[5];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { intro } = $$props;
  let { isInsideTable: isInsideTable2 } = $$props;
  let { __typename } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  let { title = "Clone" } = $$props;
  let { mode = "one" } = $$props;
  const dispatch2 = createEventDispatcher();
  function close() {
    dispatch2("close", []);
  }
  function ok(e) {
    dispatch2("ok", e.detail);
  }
  $$self.$$set = ($$props2) => {
    if ("intro" in $$props2)
      $$invalidate(0, intro = $$props2.intro);
    if ("isInsideTable" in $$props2)
      $$invalidate(1, isInsideTable2 = $$props2.isInsideTable);
    if ("__typename" in $$props2)
      $$invalidate(2, __typename = $$props2.__typename);
    if ("x" in $$props2)
      $$invalidate(3, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(4, y2 = $$props2.y);
    if ("title" in $$props2)
      $$invalidate(5, title = $$props2.title);
    if ("mode" in $$props2)
      $$invalidate(6, mode = $$props2.mode);
  };
  return [intro, isInsideTable2, __typename, x2, y2, title, mode, close, ok];
}
class CloneDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$f, create_fragment$f, safe_not_equal, {
      intro: 0,
      isInsideTable: 1,
      __typename: 2,
      x: 3,
      y: 4,
      title: 5,
      mode: 6
    });
  }
}
function add_css$7(target) {
  append_styles(target, "svelte-1206luy", ".graphql-endpoint-provider.svelte-1206luy.svelte-1206luy{height:100%;overflow:hidden;background-color:rgb(36, 36, 36)}.gql-endpoint-text.svelte-1206luy.svelte-1206luy{font-size:var(--type-ramp-base-font-size);padding:1rem}.gql-hasura-button.svelte-1206luy.svelte-1206luy{display:flex;align-items:center;justify-content:center;padding:0.5rem;background-color:#fff;border-radius:2px;color:#000;margin-top:1rem}.gql-endpoint-input.svelte-1206luy.svelte-1206luy{padding:1rem;display:flex;justify-content:space-between;align-items:flex-end}.gql-secret-input.svelte-1206luy.svelte-1206luy{padding:0rem 1rem 1rem 1rem;display:flex;justify-content:space-between;align-items:flex-end}.gql-input-field.svelte-1206luy.svelte-1206luy{width:80%}.gql-save-button.svelte-1206luy.svelte-1206luy{width:25%;margin-left:1rem;justify-content:center}.gql-create-button.svelte-1206luy.svelte-1206luy{background:rgba(255, 255, 255, .2);border:1px solid #FFF;color:#FFF;margin:0 0.5rem;transition:0.3s}.gql-create-button.svelte-1206luy.svelte-1206luy:hover{color:#000;background:#FFF}.gql-create-button.svelte-1206luy .container.svelte-1206luy{display:flex;align-items:center;justify-content:center}.custom-icon{vertical-align:middle}");
}
function create_if_block$4(ctx) {
  let a;
  let img;
  let img_src_value;
  let t0;
  let b;
  return {
    c() {
      a = element("a");
      img = element("img");
      t0 = space();
      b = element("b");
      b.textContent = "Open Hasura console";
      attr(img, "width", "25px");
      set_style(img, "margin-right", "0.5rem");
      attr(img, "alt", "hasura");
      if (!src_url_equal(img.src, img_src_value = "https://avatars.githubusercontent.com/u/13966722?s=200&v=4"))
        attr(img, "src", img_src_value);
      attr(a, "class", "gql-hasura-button svelte-1206luy");
      attr(a, "rel", "noopener noreferrer");
      attr(a, "target", "_blank");
      attr(a, "href", ctx[5]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append$1(a, img);
      append$1(a, t0);
      append$1(a, b);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$e(ctx) {
  let fast_design_system_provider;
  let p0;
  let t0;
  let br;
  let b;
  let t1;
  let t2;
  let t3;
  let p1;
  let fast_text_field0;
  let t4;
  let t5;
  let p2;
  let fast_text_field1;
  let t6;
  let t7;
  let fast_button0;
  let t8;
  let t9;
  let p3;
  let fast_button1;
  let div0;
  let icon0;
  let t10;
  let t11;
  let fast_button2;
  let div1;
  let icon1;
  let t12;
  let t13;
  let fast_button3;
  let div2;
  let icon2;
  let t14;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[5] && create_if_block$4(ctx);
  icon0 = new Icon$1({
    props: {
      className: "custom-icon",
      src: CgExtensionAdd,
      size: "24"
    }
  });
  icon1 = new Icon$1({
    props: {
      className: "custom-icon",
      src: RiEditorInsertColumnLeft,
      size: "24"
    }
  });
  icon2 = new Icon$1({
    props: {
      className: "custom-icon",
      src: BiRefresh,
      size: "24"
    }
  });
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      p0 = element("p");
      t0 = text$1("Current endpoint URL: ");
      br = element("br");
      b = element("b");
      t1 = text$1(ctx[1]);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      p1 = element("p");
      fast_text_field0 = element("fast-text-field");
      t4 = text$1("New GraphQL Endpoint");
      t5 = space();
      p2 = element("p");
      fast_text_field1 = element("fast-text-field");
      t6 = text$1("Hasura admin secret");
      t7 = space();
      fast_button0 = element("fast-button");
      t8 = text$1("Save");
      t9 = space();
      p3 = element("p");
      fast_button1 = element("fast-button");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t10 = text$1("\r\n        Create table");
      t11 = space();
      fast_button2 = element("fast-button");
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t12 = text$1("\r\n        Add new column");
      t13 = space();
      fast_button3 = element("fast-button");
      div2 = element("div");
      create_component(icon2.$$.fragment);
      t14 = text$1("\r\n        Reload schema");
      attr(p0, "class", "gql-endpoint-text svelte-1206luy");
      set_custom_element_data(fast_text_field0, "placeholder", "Endpoint URL");
      set_custom_element_data(fast_text_field0, "class", "gql-input-field svelte-1206luy");
      set_custom_element_data(fast_text_field0, "value", ctx[2]);
      set_style(fast_text_field0, "width", "100%");
      attr(p1, "class", "gql-endpoint-input svelte-1206luy");
      set_custom_element_data(fast_text_field1, "placeholder", "x-hasura-admin-secret");
      set_custom_element_data(fast_text_field1, "class", "gql-input-field svelte-1206luy");
      set_custom_element_data(fast_text_field1, "value", ctx[0]);
      set_custom_element_data(fast_button0, "class", "gql-save-button svelte-1206luy");
      set_custom_element_data(fast_button0, "disabled", ctx[3]);
      attr(p2, "class", "gql-secret-input svelte-1206luy");
      attr(div0, "class", "container svelte-1206luy");
      set_custom_element_data(fast_button1, "class", "gql-create-button svelte-1206luy");
      attr(div1, "class", "container svelte-1206luy");
      set_custom_element_data(fast_button2, "class", "gql-create-button svelte-1206luy");
      attr(div2, "class", "container svelte-1206luy");
      set_custom_element_data(fast_button3, "class", "gql-create-button svelte-1206luy");
      attr(p3, "class", "gql-endpoint-input svelte-1206luy");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_custom_element_data(fast_design_system_provider, "class", "graphql-endpoint-provider svelte-1206luy");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, p0);
      append$1(p0, t0);
      append$1(p0, br);
      append$1(p0, b);
      append$1(b, t1);
      append$1(p0, t2);
      if (if_block)
        if_block.m(p0, null);
      append$1(fast_design_system_provider, t3);
      append$1(fast_design_system_provider, p1);
      append$1(p1, fast_text_field0);
      append$1(fast_text_field0, t4);
      append$1(fast_design_system_provider, t5);
      append$1(fast_design_system_provider, p2);
      append$1(p2, fast_text_field1);
      append$1(fast_text_field1, t6);
      append$1(p2, t7);
      append$1(p2, fast_button0);
      append$1(fast_button0, t8);
      append$1(fast_design_system_provider, t9);
      append$1(fast_design_system_provider, p3);
      append$1(p3, fast_button1);
      append$1(fast_button1, div0);
      mount_component(icon0, div0, null);
      append$1(div0, t10);
      append$1(p3, t11);
      append$1(p3, fast_button2);
      append$1(fast_button2, div1);
      mount_component(icon1, div1, null);
      append$1(div1, t12);
      append$1(p3, t13);
      append$1(p3, fast_button3);
      append$1(fast_button3, div2);
      mount_component(icon2, div2, null);
      append$1(div2, t14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(fast_text_field0, "input", ctx[7]),
          listen(fast_text_field0, "focus", focus_handler),
          listen(fast_text_field1, "input", ctx[8]),
          listen(fast_button0, "click", ctx[6]),
          listen(fast_button1, "click", ctx[9]),
          listen(fast_button2, "click", ctx[10]),
          listen(fast_button3, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2)
        set_data(t1, ctx2[1]);
      if (ctx2[5])
        if_block.p(ctx2, dirty);
      if (!current || dirty & 4) {
        set_custom_element_data(fast_text_field0, "value", ctx2[2]);
      }
      if (!current || dirty & 1) {
        set_custom_element_data(fast_text_field1, "value", ctx2[0]);
      }
      if (!current || dirty & 8) {
        set_custom_element_data(fast_button0, "disabled", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      if (if_block)
        if_block.d();
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
const focus_handler = () => globalThis.select();
function instance$e($$self, $$props, $$invalidate) {
  let { currentEndpoint } = $$props;
  let { currentSecret } = $$props;
  let newEndpoint = "";
  let disabled = true;
  const dispatch2 = createEventDispatcher();
  const hasuraConsole = (currentEndpoint == null ? void 0 : currentEndpoint.includes("hasura")) ? currentEndpoint.replace(/v1\/graphql/, "console") : void 0;
  const handleSaveEndpoint = () => {
    dispatch2("save", {
      newEndpointURL: newEndpoint,
      newSecret: currentSecret
    });
    dispatch2("close");
  };
  const handleEndpointInput = (e) => {
    $$invalidate(2, newEndpoint = e.target.value);
    if (newEndpoint === "" || newEndpoint === currentEndpoint)
      $$invalidate(3, disabled = true);
    else
      $$invalidate(3, disabled = false);
  };
  const handleSecretInput = (e) => {
    $$invalidate(0, currentSecret = e.target.value);
    if (newEndpoint === "" || newEndpoint === currentEndpoint)
      $$invalidate(3, disabled = true);
    else
      $$invalidate(3, disabled = false);
  };
  const handleCreateTable2 = () => {
    dispatch2("create");
    dispatch2("close");
  };
  const handleAddColumn2 = () => {
    dispatch2("addColumn");
    dispatch2("close");
  };
  const click_handler2 = () => dispatch2("loadIntrospection");
  $$self.$$set = ($$props2) => {
    if ("currentEndpoint" in $$props2)
      $$invalidate(1, currentEndpoint = $$props2.currentEndpoint);
    if ("currentSecret" in $$props2)
      $$invalidate(0, currentSecret = $$props2.currentSecret);
  };
  return [
    currentSecret,
    currentEndpoint,
    newEndpoint,
    disabled,
    dispatch2,
    hasuraConsole,
    handleSaveEndpoint,
    handleEndpointInput,
    handleSecretInput,
    handleCreateTable2,
    handleAddColumn2,
    click_handler2
  ];
}
class GraphqlEndpoint extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$e, create_fragment$e, safe_not_equal, { currentEndpoint: 1, currentSecret: 0 }, add_css$7);
  }
}
function create_fragment$d(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: GraphqlEndpoint,
      props: {
        okButton: true,
        currentEndpoint: ctx[0],
        currentSecret: ctx[1]
      },
      events: {
        close: ctx[5],
        save: ctx[4],
        create: ctx[6],
        addColumn: ctx[7],
        loadIntrospection: ctx[8]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "400",
      width: "500",
      x: ctx[2],
      y: ctx[3],
      title: "GraphQL Endpoint"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 3)
        winbox_changes.props = {
          okButton: true,
          currentEndpoint: ctx2[0],
          currentSecret: ctx2[1]
        };
      if (dirty & 4)
        winbox_changes.x = ctx2[2];
      if (dirty & 8)
        winbox_changes.y = ctx2[3];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { currentEndpoint } = $$props;
  let { currentSecret } = $$props;
  let { endpointChanged = (ChangeGraphqlEndpointEvent, ChangeGraphqlSecretEvent) => {
  } } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const save22 = (e) => {
    endpointChanged(e.detail.newEndpointURL, e.detail.newSecret);
  };
  const close = () => {
    dispatch2("close", []);
  };
  const create2 = () => {
    dispatch2("create");
  };
  const addColumn2 = () => {
    dispatch2("addColumn");
  };
  const loadIntrospection2 = () => {
    dispatch2("loadIntrospection");
  };
  $$self.$$set = ($$props2) => {
    if ("currentEndpoint" in $$props2)
      $$invalidate(0, currentEndpoint = $$props2.currentEndpoint);
    if ("currentSecret" in $$props2)
      $$invalidate(1, currentSecret = $$props2.currentSecret);
    if ("endpointChanged" in $$props2)
      $$invalidate(9, endpointChanged = $$props2.endpointChanged);
    if ("x" in $$props2)
      $$invalidate(2, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(3, y2 = $$props2.y);
  };
  return [
    currentEndpoint,
    currentSecret,
    x2,
    y2,
    save22,
    close,
    create2,
    addColumn2,
    loadIntrospection2,
    endpointChanged
  ];
}
class GraphqlEndpointDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$d, create_fragment$d, safe_not_equal, {
      currentEndpoint: 0,
      currentSecret: 1,
      endpointChanged: 9,
      x: 2,
      y: 3
    });
  }
}
const clamp = (number2, min = 0, max = 1) => {
  return number2 > max ? max : number2 < min ? min : number2;
};
const round = (number2, digits = 0, base = Math.pow(10, digits)) => {
  return Math.round(base * number2) / base;
};
const hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
const hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substr(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: 1
    };
  }
  return {
    r: parseInt(hex.substr(0, 2), 16),
    g: parseInt(hex.substr(2, 2), 16),
    b: parseInt(hex.substr(4, 2), 16),
    a: 1
  };
};
const hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
const hsvaToHsla = ({ h, s, v, a }) => {
  const hh = (200 - s) * v / 100;
  return {
    h: round(h),
    s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round(hh / 2),
    a: round(a, 2)
  };
};
const hsvaToHslString = (hsva) => {
  const { h, s, l: l2 } = hsvaToHsla(hsva);
  return `hsl(${h}, ${s}%, ${l2}%)`;
};
const hsvaToHslaString = (hsva) => {
  const { h, s, l: l2, a } = hsvaToHsla(hsva);
  return `hsla(${h}, ${s}%, ${l2}%, ${a})`;
};
const hsvaToRgba = ({ h, s, v, a }) => {
  h = h / 360 * 6;
  s = s / 100;
  v = v / 100;
  const hh = Math.floor(h), b = v * (1 - s), c2 = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module2 = hh % 6;
  return {
    r: round([v, c2, b, b, d, v][module2] * 255),
    g: round([d, v, v, c2, b, b][module2] * 255),
    b: round([b, b, d, v, v, c2][module2] * 255),
    a: round(a, 2)
  };
};
const format = (number2) => {
  const hex = number2.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
const rgbaToHex = ({ r, g, b }) => {
  return "#" + format(r) + format(g) + format(b);
};
const rgbaToHsva = ({ r, g, b, a }) => {
  const max = Math.max(r, g, b);
  const delta = max - Math.min(r, g, b);
  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round(60 * (hh < 0 ? hh + 6 : hh)),
    s: round(max ? delta / max * 100 : 0),
    v: round(max / 255 * 100),
    a
  };
};
const equalColorObjects = (first, second) => {
  if (first === second)
    return true;
  for (const prop in first) {
    if (first[prop] !== second[prop])
      return false;
  }
  return true;
};
const equalHex = (first, second) => {
  if (first.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first), hexToRgba(second));
};
const cache = {};
const tpl = (html2) => {
  let template2 = cache[html2];
  if (!template2) {
    template2 = document.createElement("template");
    template2.innerHTML = html2;
    cache[html2] = template2;
  }
  return template2;
};
const fire = (target, type2, detail) => {
  target.dispatchEvent(new CustomEvent(type2, {
    bubbles: true,
    detail
  }));
};
let hasTouched = false;
const isTouch = (e) => "touches" in e;
const isValid = (event2) => {
  if (hasTouched && !isTouch(event2))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event2);
  return true;
};
const pointerMove = (target, event2) => {
  const pointer = isTouch(event2) ? event2.touches[0] : event2;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
const keyMove = (target, event2) => {
  const keyCode = event2.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event2.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
class Slider {
  constructor(root2, part, aria, xy) {
    const template2 = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
    root2.appendChild(template2.content.cloneNode(true));
    const el2 = root2.querySelector(`[part=${part}]`);
    el2.addEventListener("mousedown", this);
    el2.addEventListener("touchstart", this);
    el2.addEventListener("keydown", this);
    this.el = el2;
    this.xy = xy;
    this.nodes = [el2.firstChild, el2];
  }
  set dragging(state2) {
    const toggleEvent = state2 ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event2) {
    switch (event2.type) {
      case "mousedown":
      case "touchstart":
        event2.preventDefault();
        if (!isValid(event2) || !hasTouched && event2.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event2);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event2.preventDefault();
        pointerMove(this, event2);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event2);
        break;
    }
  }
  style(styles2) {
    styles2.forEach((style, i2) => {
      for (const p2 in style) {
        this.nodes[i2].style.setProperty(p2, style[p2]);
      }
    });
  }
}
class Hue extends Slider {
  constructor(root2) {
    super(root2, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({ h }) {
    this.h = h;
    this.style([
      {
        left: `${h / 360 * 100}%`,
        color: hsvaToHslString({ h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round(h)}`);
  }
  getMove(offset, key) {
    return { h: key ? clamp(this.h + offset.x * 360, 0, 360) : 360 * offset.x };
  }
}
class Saturation extends Slider {
  constructor(root2) {
    super(root2, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 })
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
  }
  getMove(offset, key) {
    return {
      s: key ? clamp(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key ? clamp(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
}
var css$1 = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{display:block;content:'';position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;
var hueCss = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;
var saturationCss = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;
const $isSame = Symbol("same");
const $color = Symbol("color");
const $hsva = Symbol("hsva");
const $change = Symbol("change");
const $update = Symbol("update");
const $parts = Symbol("parts");
const $css = Symbol("css");
const $sliders = Symbol("sliders");
class ColorPicker extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [css$1, hueCss, saturationCss];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$change](newColor);
    }
  }
  constructor() {
    super();
    const template2 = tpl(`<style>${this[$css].join("")}</style>`);
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(template2.content.cloneNode(true));
    root2.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root2));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value2 = this.color;
      delete this["color"];
      this.color = value2;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color2 = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color2)) {
      this.color = color2;
    }
  }
  handleEvent(event2) {
    const oldHsva = this[$hsva];
    const newHsva = __spreadValues(__spreadValues({}, oldHsva), event2.detail);
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$change](newColor);
    }
  }
  [$isSame](color2) {
    return this.color && this.colorModel.equal(color2, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
  [$change](value2) {
    this[$color] = value2;
    fire(this, "color-changed", { value: value2 });
  }
}
const colorModel$1 = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: hsvaToHex,
  equal: equalHex,
  fromAttr: (color2) => color2
};
class HexBase extends ColorPicker {
  get colorModel() {
    return colorModel$1;
  }
}
class HexColorPicker extends HexBase {
}
customElements.define("hex-color-picker", HexColorPicker);
class Alpha extends Slider {
  constructor(root2) {
    super(root2, "alpha", 'aria-label="Alpha" aria-valuemin="0" aria-valuemax="1"', false);
  }
  update(hsva) {
    this.hsva = hsva;
    const colorFrom = hsvaToHslaString(__spreadProps(__spreadValues({}, hsva), { a: 0 }));
    const colorTo = hsvaToHslaString(__spreadProps(__spreadValues({}, hsva), { a: 1 }));
    const value2 = hsva.a * 100;
    this.style([
      {
        left: `${value2}%`,
        color: hsvaToHslaString(hsva)
      },
      {
        "--gradient": `linear-gradient(90deg, ${colorFrom}, ${colorTo}`
      }
    ]);
    const v = round(value2);
    this.el.setAttribute("aria-valuenow", `${v}`);
    this.el.setAttribute("aria-valuetext", `${v}%`);
  }
  getMove(offset, key) {
    return { a: key ? clamp(this.hsva.a + offset.x) : offset.x };
  }
}
var alphaCss = `[part=alpha]{flex:0 0 24px}[part=alpha]::after{display:block;content:'';position:absolute;top:0;left:0;right:0;bottom:0;border-radius:inherit;background-image:var(--gradient);box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part^=alpha]{background-color:#fff;background-image:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>')}[part=alpha-pointer]{top:50%}`;
class AlphaColorPicker extends ColorPicker {
  get [$css]() {
    return [...super[$css], alphaCss];
  }
  get [$sliders]() {
    return [...super[$sliders], Alpha];
  }
}
const colorModel = {
  defaultColor: { r: 0, g: 0, b: 0, a: 1 },
  toHsva: rgbaToHsva,
  fromHsva: hsvaToRgba,
  equal: equalColorObjects,
  fromAttr: (color2) => JSON.parse(color2)
};
class RgbaBase extends AlphaColorPicker {
  get colorModel() {
    return colorModel;
  }
}
class RgbaColorPicker extends RgbaBase {
}
customElements.define("rgba-color-picker", RgbaColorPicker);
function add_css$6(target) {
  append_styles(target, "svelte-vcqdl8", "rgba-color-picker.svelte-vcqdl8{position:relative;left:50%;transform:translateX(-50%);margin-bottom:10px}.picked-color.svelte-vcqdl8{width:28px;height:28px;border-radius:8px;border:3px solid #fff}.color-input.svelte-vcqdl8{padding:0.2rem;display:flex;justify-content:space-evenly;align-items:flex-end}.color-input-field.svelte-vcqdl8{width:80%}");
}
function create_if_block$3(ctx) {
  let rgba_color_picker;
  let mounted;
  let dispose;
  return {
    c() {
      rgba_color_picker = element("rgba-color-picker");
      set_custom_element_data(rgba_color_picker, "id", ctx[1]);
      set_custom_element_data(rgba_color_picker, "color", ctx[2]);
      set_custom_element_data(rgba_color_picker, "class", "svelte-vcqdl8");
    },
    m(target, anchor) {
      insert(target, rgba_color_picker, anchor);
      if (!mounted) {
        dispose = listen(rgba_color_picker, "color-changed", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        set_custom_element_data(rgba_color_picker, "id", ctx2[1]);
      }
      if (dirty & 4) {
        set_custom_element_data(rgba_color_picker, "color", ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(rgba_color_picker);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$c(ctx) {
  let div2;
  let p2;
  let span;
  let span_class_value;
  let t0;
  let fast_text_field;
  let t1;
  let t2;
  let fast_text_field_id_value;
  let fast_text_field_placeholder_value;
  let fast_text_field_class_value;
  let t3;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block$3(ctx);
  return {
    c() {
      div2 = element("div");
      p2 = element("p");
      span = element("span");
      t0 = space();
      fast_text_field = element("fast-text-field");
      t1 = text$1(ctx[1]);
      t2 = text$1(" color");
      t3 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", span_class_value = "picked-color picked-color-" + ctx[1] + " svelte-vcqdl8");
      set_style(span, "background-color", ctx[0]);
      set_custom_element_data(fast_text_field, "id", fast_text_field_id_value = "input-" + ctx[1]);
      set_custom_element_data(fast_text_field, "placeholder", fast_text_field_placeholder_value = "Hex or rgba " + ctx[1] + " color");
      set_custom_element_data(fast_text_field, "class", fast_text_field_class_value = "color-input-field color-input-field-" + ctx[1] + " svelte-vcqdl8");
      set_custom_element_data(fast_text_field, "value", ctx[0]);
      attr(p2, "class", "color-input svelte-vcqdl8");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, p2);
      append$1(p2, span);
      append$1(p2, t0);
      append$1(p2, fast_text_field);
      append$1(fast_text_field, t1);
      append$1(fast_text_field, t2);
      append$1(div2, t3);
      if (if_block)
        if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(fast_text_field, "input", ctx[4]),
          listen(fast_text_field, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && span_class_value !== (span_class_value = "picked-color picked-color-" + ctx2[1] + " svelte-vcqdl8")) {
        attr(span, "class", span_class_value);
      }
      if (dirty & 1) {
        set_style(span, "background-color", ctx2[0]);
      }
      if (dirty & 2)
        set_data(t1, ctx2[1]);
      if (dirty & 2 && fast_text_field_id_value !== (fast_text_field_id_value = "input-" + ctx2[1])) {
        set_custom_element_data(fast_text_field, "id", fast_text_field_id_value);
      }
      if (dirty & 2 && fast_text_field_placeholder_value !== (fast_text_field_placeholder_value = "Hex or rgba " + ctx2[1] + " color")) {
        set_custom_element_data(fast_text_field, "placeholder", fast_text_field_placeholder_value);
      }
      if (dirty & 2 && fast_text_field_class_value !== (fast_text_field_class_value = "color-input-field color-input-field-" + ctx2[1] + " svelte-vcqdl8")) {
        set_custom_element_data(fast_text_field, "class", fast_text_field_class_value);
      }
      if (dirty & 1) {
        set_custom_element_data(fast_text_field, "value", ctx2[0]);
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function matchColor(_color) {
  return _color.match(/^#([0-9a-fA-F]{6,8})$|^rgba?\(\d+(?:(?:\s*,\s*\d+){2}(?:\s*,\s*(?:\d*\.\d+|\d+)%?)?)|(?:(?:\s+\d+){2}(?:\s*\/\s*(?:\d*\.\d+|\d+)%?)?)\)$/);
}
function humanReadableRGBA(rgba) {
  return "rgba(" + rgba.r + ", " + rgba.g + ", " + rgba.b + ", " + +rgba.a + ")";
}
function computerReadableRGBA(rgba) {
  const rgbaObject = rgba.substring(5, rgba.length - 1).replace(/ /g, "").split(",");
  return {
    r: parseFloat(rgbaObject[0]),
    g: parseFloat(rgbaObject[1]),
    b: parseFloat(rgbaObject[2]),
    a: parseFloat(rgbaObject[3]) === void 0 ? 1 : parseFloat(rgbaObject[3])
  };
}
function hexToRGB(hex) {
  if (!hex || [4, 7, 9].indexOf(hex.length) === -1)
    return;
  hex = hex.substr(1);
  var r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16), a = parseInt(hex.slice(6, 8), 16);
  let alpha = a ? a / 255 : 1;
  return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
}
function rgba2hex(rgba) {
  var a, rgb = rgba.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i), alpha = (rgb && rgb[4] || "").trim(), hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : rgba;
  if (alpha !== "") {
    a = alpha;
  } else {
    a = 1;
  }
  a = (a * 255 | 1 << 8).toString(16).slice(1);
  hex = "#" + hex + (a !== "ff" ? a : "");
  return hex;
}
function formatColor(_color) {
  if (!matchColor(_color))
    return;
  if (_color.startsWith("#")) {
    return computerReadableRGBA(hexToRGB(_color));
  } else if (_color.startsWith("rgba")) {
    return computerReadableRGBA(_color);
  } else {
    return _color;
  }
}
function instance$c($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { color: color2 } = $$props;
  let colorObject = formatColor(color2);
  let display2 = false;
  const handleInput = (e) => {
    if (!matchColor(e.target._value))
      return;
    $$invalidate(0, color2 = e.target._value);
    $$invalidate(2, colorObject = formatColor(color2));
  };
  function handleOnclick(event2) {
    $$invalidate(3, display2 = !display2);
    document.onclick = function(e) {
      if (e.target.id != id && e.target.id != event2.target.id) {
        $$invalidate(3, display2 = false);
      }
    };
  }
  function handleColorObjectChanged(event2) {
    $$invalidate(2, colorObject = event2.detail.value);
    const input = document.querySelector(".color-input-field-" + id);
    const pickedColor = document.querySelector(".picked-color-" + id);
    if (input.value.startsWith("#")) {
      $$invalidate(0, color2 = rgba2hex(humanReadableRGBA(colorObject)));
    } else {
      $$invalidate(0, color2 = humanReadableRGBA(colorObject));
    }
    input.value = color2;
    pickedColor.style.backgroundColor = color2;
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("color" in $$props2)
      $$invalidate(0, color2 = $$props2.color);
  };
  return [
    color2,
    id,
    colorObject,
    display2,
    handleInput,
    handleOnclick,
    handleColorObjectChanged
  ];
}
class ThemeEditorComponent extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$c, create_fragment$c, safe_not_equal, { id: 1, color: 0 }, add_css$6);
  }
}
function add_css$5(target) {
  append_styles(target, "svelte-fb3hxq", ".colors-container.svelte-fb3hxq{overflow:auto;height:-webkit-fill-available;margin-bottom:3.5rem}.save-button-container.svelte-fb3hxq{display:flex;justify-content:end;position:static}.save-button.svelte-fb3hxq{float:right;margin:0.5rem}");
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2][0];
  child_ctx[5] = list[i2][1];
  child_ctx[6] = list;
  child_ctx[7] = i2;
  return child_ctx;
}
function create_each_block$1(ctx) {
  let themeeditorcomponent;
  let updating_color;
  let current;
  function themeeditorcomponent_color_binding(value2) {
    ctx[2](value2, ctx[4]);
  }
  let themeeditorcomponent_props = { id: ctx[4] };
  if (ctx[0][ctx[4]] !== void 0) {
    themeeditorcomponent_props.color = ctx[0][ctx[4]];
  }
  themeeditorcomponent = new ThemeEditorComponent({ props: themeeditorcomponent_props });
  binding_callbacks.push(() => bind(themeeditorcomponent, "color", themeeditorcomponent_color_binding));
  return {
    c() {
      create_component(themeeditorcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeeditorcomponent, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const themeeditorcomponent_changes = {};
      if (dirty & 1)
        themeeditorcomponent_changes.id = ctx[4];
      if (!updating_color && dirty & 1) {
        updating_color = true;
        themeeditorcomponent_changes.color = ctx[0][ctx[4]];
        add_flush_callback(() => updating_color = false);
      }
      themeeditorcomponent.$set(themeeditorcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themeeditorcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeeditorcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themeeditorcomponent, detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let fast_design_system_provider;
  let div0;
  let fast_button;
  let t1;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value = Object.entries(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      div0 = element("div");
      fast_button = element("fast-button");
      fast_button.textContent = "Save to file system";
      t1 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_custom_element_data(fast_button, "class", "save-button svelte-fb3hxq");
      attr(div0, "class", "save-button-container svelte-fb3hxq");
      attr(div1, "class", "colors-container svelte-fb3hxq");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "height", "100%");
      set_style(fast_design_system_provider, "overflow", "hidden");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, div0);
      append$1(div0, fast_button);
      append$1(fast_design_system_provider, t1);
      append$1(fast_design_system_provider, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(fast_button, "click", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = Object.entries(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { theme } = $$props;
  const dispatch2 = createEventDispatcher();
  const handleSave = () => {
    dispatch2("save", { theme });
    dispatch2("close");
  };
  function themeeditorcomponent_color_binding(value2, attribute) {
    if ($$self.$$.not_equal(theme[attribute], value2)) {
      theme[attribute] = value2;
      $$invalidate(0, theme);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
  };
  return [theme, handleSave, themeeditorcomponent_color_binding];
}
class ThemeEditor extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$b, create_fragment$b, safe_not_equal, { theme: 0 }, add_css$5);
  }
}
function create_fragment$a(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: ThemeEditor,
      props: { okButton: true, theme: ctx[0] },
      events: {
        close: ctx[4],
        save: ctx[3]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "500",
      x: ctx[1],
      y: ctx[2],
      title: "Theme Editor"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 1)
        winbox_changes.props = { okButton: true, theme: ctx2[0] };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { theme } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const save22 = (e) => {
    dispatch2("save", e.detail);
  };
  const close = () => {
    dispatch2("close", []);
  };
  $$self.$$set = ($$props2) => {
    if ("theme" in $$props2)
      $$invalidate(0, theme = $$props2.theme);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
  };
  return [theme, x2, y2, save22, close];
}
class ThemeEditorDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$a, create_fragment$a, safe_not_equal, { theme: 0, x: 1, y: 2 });
  }
}
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$7(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$6(obj2) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function(obj3) {
      return typeof obj3;
    };
  } else {
    _typeof$6 = function(obj3) {
      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    };
  }
  return _typeof$6(obj2);
}
function _defineProperty$7(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version$1 = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el2, event2, fn2) {
  el2.addEventListener(event2, fn2, !IE11OrLess && captureMode);
}
function off(el2, event2, fn2) {
  el2.removeEventListener(event2, fn2, !IE11OrLess && captureMode);
}
function matches(el2, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el2) {
    try {
      if (el2.matches) {
        return el2.matches(selector);
      } else if (el2.msMatchesSelector) {
        return el2.msMatchesSelector(selector);
      } else if (el2.webkitMatchesSelector) {
        return el2.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el2) {
  return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
}
function closest$2(el2, selector, ctx, includeCTX) {
  if (el2) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches(el2, selector) : matches(el2, selector)) || includeCTX && el2 === ctx) {
        return el2;
      }
      if (el2 === ctx)
        break;
    } while (el2 = getParentOrHost(el2));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el2, name, state2) {
  if (el2 && name) {
    if (el2.classList) {
      el2.classList[state2 ? "add" : "remove"](name);
    } else {
      var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el2.className = (className + (state2 ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el2, prop, val) {
  var style = el2 && el2.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el2, "");
      } else if (el2.currentStyle) {
        val = el2.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el2, selfOnly) {
  var appliedTransforms = "";
  if (typeof el2 === "string") {
    appliedTransforms = el2;
  } else {
    do {
      var transform2 = css(el2, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el2 = el2.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find$2(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
    if (iterator) {
      for (; i2 < n2; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el2.getBoundingClientRect && el2 !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
    elRect = el2.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
    container = container || el2.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el2 !== window) {
    var elMatrix = matrix(container || el2), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el2, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el2, childNum, options2, includeDragEl) {
  var currentChild = 0, i2 = 0, children2 = el2.children;
  while (i2 < children2.length) {
    if (children2[i2].style.display !== "none" && children2[i2] !== Sortable.ghost && (includeDragEl || children2[i2] !== Sortable.dragged) && closest$2(children2[i2], options2.draggable, el2, false)) {
      if (currentChild === childNum) {
        return children2[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild$1(el2, selector) {
  var last = el2.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index$2(el2, selector) {
  var index2 = 0;
  if (!el2 || !el2.parentNode) {
    return -1;
  }
  while (el2 = el2.previousElementSibling) {
    if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable.clone && (!selector || matches(el2, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el2) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el2) {
    do {
      var elMatrix = matrix(el2), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el2.scrollLeft * scaleX;
      offsetTop += el2.scrollTop * scaleY;
    } while (el2 !== winScroller && (el2 = el2.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj2) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj2) {
      if (obj2.hasOwnProperty(key) && obj2[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el2, includeSelf) {
  if (!el2 || !el2.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el2;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend$1(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args2 = arguments, _this = this;
      if (args2.length === 1) {
        callback.call(_this, args2[0]);
      } else {
        callback.apply(_this, args2);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el2, x2, y2) {
  el2.scrollLeft += x2;
  el2.scrollTop += y2;
}
function clone$1(el2) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el2).cloneNode(true);
  } else if ($2) {
    return $2(el2).clone(true)[0];
  } else {
    return el2.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children2 = [].slice.call(this.el.children);
      children2.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state2) {
      animationStates.push(state2);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state2) {
        var time = 0, target = state2.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options2) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options2.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent2(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el2, defaults2, options2) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el2, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value2) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value2);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref2) {
  var sortable = _ref2.sortable, rootEl2 = _ref2.rootEl, name = _ref2.name, targetEl = _ref2.targetEl, cloneEl2 = _ref2.cloneEl, toEl = _ref2.toEl, fromEl = _ref2.fromEl, oldIndex2 = _ref2.oldIndex, newIndex2 = _ref2.newIndex, oldDraggableIndex2 = _ref2.oldDraggableIndex, newDraggableIndex2 = _ref2.newDraggableIndex, originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, extraEventProperties = _ref2.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options2 = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options2[onName]) {
    options2[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent = function pluginEvent3(eventName, sortable) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref2.evt, data = _objectWithoutProperties(_ref2, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el2 = document.createElement("x");
  el2.style.cssText = "pointer-events:auto";
  return el2.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el2, options2) {
  var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el2, 0, options2), child2 = getChild(el2, 1, options2), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild$1(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options2) {
  function toFn(value2, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value2 == null && (pull || sameGroup)) {
        return true;
      } else if (value2 == null || value2 === false) {
        return false;
      } else if (pull && value2 === "clone") {
        return value2;
      } else if (typeof value2 === "function") {
        return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options2.group;
  if (!originalGroup || _typeof$6(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options2.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event2 = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event2[i2] = evt[i2];
        }
      }
      event2.target = event2.rootEl = nearest;
      event2.preventDefault = void 0;
      event2.stopPropagation = void 0;
      nearest[expando]._onDragOver(event2);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el2, options2) {
  if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
  }
  this.el = el2;
  this.options = options2 = _extends({}, options2);
  el2[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el2, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el2, defaults2);
  for (var name in defaults2) {
    !(name in options2) && (options2[name] = defaults2[name]);
  }
  _prepareGroup(options2);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options2.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options2.supportPointer) {
    on(el2, "pointerdown", this._onTapStart);
  } else {
    on(el2, "mousedown", this._onTapStart);
    on(el2, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el2, "dragover", this);
    on(el2, "dragenter", this);
  }
  sortables.push(this.el);
  options2.store && options2.store.get && this.sort(options2.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el2 = this.el, options2 = this.options, preventOnFilter = options2.preventOnFilter, type2 = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options2.filter;
    _saveInputCheckedState(el2);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type2) && evt.button !== 0 || options2.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest$2(target, options2.draggable, el2, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$2(target);
    oldDraggableIndex = index$2(target, options2.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el2,
          fromEl: el2
        });
        pluginEvent("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria2) {
        criteria2 = closest$2(originalTarget, criteria2.trim(), el2, false);
        if (criteria2) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria2,
            name: "filter",
            targetEl: target,
            fromEl: el2,
            toEl: el2
          });
          pluginEvent("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options2.handle && !closest$2(originalTarget, options2.handle, el2, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el2 = _this.el, options2 = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el2) {
      var dragRect = getRect(target);
      rootEl = el2;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options2.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options2.chosenClass, true);
      };
      options2.ignore.split(",").forEach(function(criteria2) {
        find$2(dragEl, criteria2.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent("delayStart", this, {
        evt
      });
      if (options2.delay && (!options2.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options2.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options2.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err2) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options2 = this.options;
      !fallback && toggleClass(dragEl, options2.dragClass, false);
      toggleClass(dragEl, options2.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options2 = this.options, fallbackTolerance = options2.fallbackTolerance, fallbackOffset = options2.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options2 = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options2.ghostClass, false);
      toggleClass(ghostEl, options2.fallbackClass, true);
      toggleClass(ghostEl, options2.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options2 = _this.options;
    pluginEvent("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone$1(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options2.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options2.setData && options2.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el2 = this.el, target = evt.target, dragRect, targetRect, revert, options2 = this.options, group = options2.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options2.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el2, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options2.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el2 && !target.animated) {
        lastTarget = null;
      }
      if (!options2.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options2.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$2(dragEl);
      newDraggableIndex = index$2(dragEl, options2.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el2,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest$2(target, options2.draggable, el2, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options2.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild$1(el2, options2.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el2 === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el2.appendChild(dragEl);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el2, 0, options2, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el2.insertBefore(dragEl, firstChild);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el2) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options2.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options2.swapThreshold, options2.invertedSwapThreshold == null ? options2.swapThreshold : options2.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$2(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el2.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el2.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el2 = this.el, options2 = this.options;
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options2.draggable);
    pluginEvent("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options2.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el2, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options2.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el2) {
      el2.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order = [], el2, children2 = this.el.children, i2 = 0, n2 = children2.length, options2 = this.options;
    for (; i2 < n2; i2++) {
      el2 = children2[i2];
      if (closest$2(el2, options2.draggable, this.el, false)) {
        order.push(el2.getAttribute(options2.dataIdAttr) || _generateId(el2));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el2 = rootEl2.children[i2];
      if (closest$2(el2, this.options.draggable, rootEl2, false)) {
        items[id] = el2;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save2() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$12(el2, selector) {
    return closest$2(el2, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value2) {
    var options2 = this.options;
    if (value2 === void 0) {
      return options2[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value2);
      if (typeof modifiedValue !== "undefined") {
        options2[name] = modifiedValue;
      } else {
        options2[name] = value2;
      }
      if (name === "group") {
        _prepareGroup(options2);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent("destroy", this);
    var el2 = this.el;
    el2[expando] = null;
    off(el2, "mousedown", this._onTapStart);
    off(el2, "touchstart", this._onTapStart);
    off(el2, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el2, "dragover", this);
      off(el2, "dragenter", this);
    }
    Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
      el3.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el2 = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el2) {
  el2.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild$1(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$2(dragEl) < index$2(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el2) {
  var str2 = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i2 = str2.length, sum = 0;
  while (i2--) {
    sum += str2.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el2 = inputs[idx];
    el2.checked && savedInputChecked.push(el2);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find: find$2,
  is: function is(el2, selector) {
    return !!closest$2(el2, selector, el2, false);
  },
  extend: extend$1,
  throttle,
  closest: closest$2,
  toggleClass,
  clone: clone$1,
  index: index$2,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el2, options2) {
  return new Sortable(el2, options2);
};
Sortable.version = version$1;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options2, rootEl2, isFallback) {
  if (!options2.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options2.scrollSensitivity, speed = options2.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options2.scroll;
    scrollCustomFn = options2.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el2 = currentParent, rect = getRect(el2), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
    if (el2 === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el2) {
      autoScrolls[layersOut].el = el2;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options2.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref2) {
  var originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, dragEl2 = _ref2.dragEl, activeSortable = _ref2.activeSortable, dispatchSortableEvent = _ref2.dispatchSortableEvent, hideGhostForTarget = _ref2.hideGhostForTarget, unhideGhostForTarget = _ref2.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function add_css$4(target) {
  append_styles(target, "svelte-9z0wv6", ".gql-endpoint-input.svelte-9z0wv6{padding:1rem;display:flex;justify-content:space-between;align-items:flex-end}.gql-input-field.svelte-9z0wv6{width:80%}.gql-button.svelte-9z0wv6{width:35%;display:flex;justify-content:center}");
}
function create_fragment$9(ctx) {
  let fast_design_system_provider;
  let p0;
  let fast_switch;
  let t0;
  let t1;
  let p1;
  let fast_text_field0;
  let t2;
  let t3;
  let p2;
  let fast_text_field1;
  let t4;
  let t5;
  let p3;
  let fast_button;
  let t6;
  let mounted;
  let dispose;
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      p0 = element("p");
      fast_switch = element("fast-switch");
      t0 = text$1("Migrations");
      t1 = space();
      p1 = element("p");
      fast_text_field0 = element("fast-text-field");
      t2 = text$1("Schema");
      t3 = space();
      p2 = element("p");
      fast_text_field1 = element("fast-text-field");
      t4 = text$1("New Table");
      t5 = space();
      p3 = element("p");
      fast_button = element("fast-button");
      t6 = text$1("Create table");
      set_custom_element_data(fast_switch, "checked", ctx[3]);
      attr(p0, "class", "gql-endpoint-input svelte-9z0wv6");
      set_custom_element_data(fast_text_field0, "placeholder", "schema");
      set_custom_element_data(fast_text_field0, "class", "gql-input-field svelte-9z0wv6");
      set_custom_element_data(fast_text_field0, "value", ctx[2]);
      attr(p1, "class", "gql-endpoint-input svelte-9z0wv6");
      set_custom_element_data(fast_text_field1, "placeholder", "table_name");
      set_custom_element_data(fast_text_field1, "class", "gql-input-field svelte-9z0wv6");
      set_custom_element_data(fast_text_field1, "value", ctx[0]);
      attr(p2, "class", "gql-endpoint-input svelte-9z0wv6");
      set_custom_element_data(fast_button, "class", "gql-button svelte-9z0wv6");
      set_custom_element_data(fast_button, "disabled", ctx[1]);
      attr(p3, "class", "gql-endpoint-input svelte-9z0wv6");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "height", "100%");
      set_style(fast_design_system_provider, "overflow", "hidden");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, p0);
      append$1(p0, fast_switch);
      append$1(fast_switch, t0);
      append$1(fast_design_system_provider, t1);
      append$1(fast_design_system_provider, p1);
      append$1(p1, fast_text_field0);
      append$1(fast_text_field0, t2);
      append$1(fast_design_system_provider, t3);
      append$1(fast_design_system_provider, p2);
      append$1(p2, fast_text_field1);
      append$1(fast_text_field1, t4);
      append$1(fast_design_system_provider, t5);
      append$1(fast_design_system_provider, p3);
      append$1(p3, fast_button);
      append$1(fast_button, t6);
      if (!mounted) {
        dispose = [
          listen(fast_switch, "change", ctx[4]),
          listen(fast_text_field0, "input", ctx[6]),
          listen(fast_text_field1, "input", ctx[5]),
          listen(fast_button, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        set_custom_element_data(fast_switch, "checked", ctx2[3]);
      }
      if (dirty & 4) {
        set_custom_element_data(fast_text_field0, "value", ctx2[2]);
      }
      if (dirty & 1) {
        set_custom_element_data(fast_text_field1, "value", ctx2[0]);
      }
      if (dirty & 2) {
        set_custom_element_data(fast_button, "disabled", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { tableName = "" } = $$props;
  let { disabled = true } = $$props;
  let { schema: schema2 = "public" } = $$props;
  let { migration = true } = $$props;
  const dispatch2 = createEventDispatcher();
  const checkInput = () => {
    if (tableName === "" || schema2 === "")
      $$invalidate(1, disabled = true);
    else
      $$invalidate(1, disabled = false);
  };
  const handleMigration = (e) => {
    $$invalidate(3, migration = e.target.checked);
  };
  const handleCreateInput = (e) => {
    $$invalidate(0, tableName = e.target.value);
    checkInput();
  };
  const handleSchemaInput = (e) => {
    $$invalidate(2, schema2 = e.target.value);
    checkInput();
  };
  const handleCreateTable2 = () => {
    dispatch2("createTable", { schema: schema2, name: tableName, migration });
    dispatch2("close");
  };
  $$self.$$set = ($$props2) => {
    if ("tableName" in $$props2)
      $$invalidate(0, tableName = $$props2.tableName);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("schema" in $$props2)
      $$invalidate(2, schema2 = $$props2.schema);
    if ("migration" in $$props2)
      $$invalidate(3, migration = $$props2.migration);
  };
  return [
    tableName,
    disabled,
    schema2,
    migration,
    handleMigration,
    handleCreateInput,
    handleSchemaInput,
    handleCreateTable2
  ];
}
class CreateTable extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$9, create_fragment$9, safe_not_equal, {
      tableName: 0,
      disabled: 1,
      schema: 2,
      migration: 3
    }, add_css$4);
  }
}
function create_fragment$8(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: CreateTable,
      props: { okButton: true },
      events: {
        close: ctx[3],
        createTable: ctx[2],
        create: ctx[4]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "350",
      x: ctx[0],
      y: ctx[1],
      title: "Create Table"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 1)
        winbox_changes.x = ctx2[0];
      if (dirty & 2)
        winbox_changes.y = ctx2[1];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { tableCreated = (CreateTableEvent) => {
  } } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const createTable2 = (e) => {
    tableCreated(e.detail);
  };
  const close = () => {
    dispatch2("close", []);
  };
  const create2 = () => {
    dispatch2("create");
  };
  $$self.$$set = ($$props2) => {
    if ("tableCreated" in $$props2)
      $$invalidate(5, tableCreated = $$props2.tableCreated);
    if ("x" in $$props2)
      $$invalidate(0, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(1, y2 = $$props2.y);
  };
  return [x2, y2, createTable2, close, create2, tableCreated];
}
class CreateTableDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$8, create_fragment$8, safe_not_equal, { tableCreated: 5, x: 0, y: 1 });
  }
}
function add_css$3(target) {
  append_styles(target, "svelte-wtnnba", ".gql-endpoint-input.svelte-wtnnba{padding:1rem;display:flex;justify-content:space-between;align-items:flex-end}.gql-button-component.svelte-wtnnba{padding:1rem;display:flex;justify-content:center}.gql-input-field.svelte-wtnnba{width:80%}.gql-button.svelte-wtnnba{width:35%;display:flex;justify-content:center}.gql-checkbox.svelte-wtnnba{padding:1rem;display:flex;justify-content:center;gap:2rem}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i2];
  child_ctx[38] = i2;
  return child_ctx;
}
function create_each_block(ctx) {
  let fast_option;
  let t0_value = ctx[36].name + "";
  let t0;
  let t1;
  let fast_option_value_value;
  return {
    c() {
      fast_option = element("fast-option");
      t0 = text$1(t0_value);
      t1 = space();
      set_custom_element_data(fast_option, "value", fast_option_value_value = ctx[38]);
    },
    m(target, anchor) {
      insert(target, fast_option, anchor);
      append$1(fast_option, t0);
      append$1(fast_option, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8192 && t0_value !== (t0_value = ctx2[36].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(fast_option);
    }
  };
}
function create_if_block$2(ctx) {
  let p0;
  let fast_text_field0;
  let t0;
  let t1;
  let p1;
  let fast_text_field1;
  let t2;
  let t3;
  let p2;
  let fast_text_field2;
  let t4;
  let t5;
  let p3;
  let fast_radio_group0;
  let t17;
  let p4;
  let fast_radio_group1;
  let mounted;
  let dispose;
  return {
    c() {
      p0 = element("p");
      fast_text_field0 = element("fast-text-field");
      t0 = text$1("Reference Schema");
      t1 = space();
      p1 = element("p");
      fast_text_field1 = element("fast-text-field");
      t2 = text$1("Reference Table");
      t3 = space();
      p2 = element("p");
      fast_text_field2 = element("fast-text-field");
      t4 = text$1("Reference Column");
      t5 = space();
      p3 = element("p");
      fast_radio_group0 = element("fast-radio-group");
      fast_radio_group0.innerHTML = `<label slot="label">On Update Violation</label> 
      <fast-radio value="restrict" checked="">Restrict</fast-radio> 
      <fast-radio value="no action">No action</fast-radio> 
      <fast-radio value="cascade">Cascade</fast-radio> 
      <fast-radio value="set null">Set null</fast-radio> 
      <fast-radio value="set default">Set default</fast-radio>`;
      t17 = space();
      p4 = element("p");
      fast_radio_group1 = element("fast-radio-group");
      fast_radio_group1.innerHTML = `<label slot="label">On Delete Violation</label> 
      <fast-radio value="restrict" checked="">Restrict</fast-radio> 
      <fast-radio value="no action">No action</fast-radio> 
      <fast-radio value="cascade">Cascade</fast-radio> 
      <fast-radio value="set null">Set null</fast-radio> 
      <fast-radio value="set default">Set default</fast-radio>`;
      set_custom_element_data(fast_text_field0, "placeholder", "reference schema");
      set_custom_element_data(fast_text_field0, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field0, "value", ctx[9]);
      attr(p0, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field1, "placeholder", "reference table");
      set_custom_element_data(fast_text_field1, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field1, "value", ctx[10]);
      attr(p1, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field2, "placeholder", "reference column");
      set_custom_element_data(fast_text_field2, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field2, "value", ctx[11]);
      attr(p2, "class", "gql-endpoint-input svelte-wtnnba");
      attr(p3, "class", "gql-endpoint-input svelte-wtnnba");
      attr(p4, "class", "gql-endpoint-input svelte-wtnnba");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      append$1(p0, fast_text_field0);
      append$1(fast_text_field0, t0);
      insert(target, t1, anchor);
      insert(target, p1, anchor);
      append$1(p1, fast_text_field1);
      append$1(fast_text_field1, t2);
      insert(target, t3, anchor);
      insert(target, p2, anchor);
      append$1(p2, fast_text_field2);
      append$1(fast_text_field2, t4);
      insert(target, t5, anchor);
      insert(target, p3, anchor);
      append$1(p3, fast_radio_group0);
      insert(target, t17, anchor);
      insert(target, p4, anchor);
      append$1(p4, fast_radio_group1);
      if (!mounted) {
        dispose = [
          listen(fast_text_field0, "input", ctx[19]),
          listen(fast_text_field1, "input", ctx[20]),
          listen(fast_text_field2, "input", ctx[21]),
          listen(fast_radio_group0, "change", ctx[22]),
          listen(fast_radio_group1, "change", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512) {
        set_custom_element_data(fast_text_field0, "value", ctx2[9]);
      }
      if (dirty[0] & 1024) {
        set_custom_element_data(fast_text_field1, "value", ctx2[10]);
      }
      if (dirty[0] & 2048) {
        set_custom_element_data(fast_text_field2, "value", ctx2[11]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(p3);
      if (detaching)
        detach(t17);
      if (detaching)
        detach(p4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$7(ctx) {
  let fast_design_system_provider;
  let p0;
  let fast_switch;
  let t0;
  let t1;
  let p1;
  let fast_text_field0;
  let t2;
  let t3;
  let p2;
  let fast_text_field1;
  let t4;
  let t5;
  let p3;
  let fast_text_field2;
  let t6;
  let t7;
  let p4;
  let fast_text_field3;
  let t8;
  let t9;
  let p5;
  let fast_select;
  let t10;
  let p6;
  let fast_text_field4;
  let t11;
  let t12;
  let p7;
  let fast_checkbox0;
  let t13;
  let t14;
  let fast_checkbox1;
  let t16;
  let p8;
  let fast_checkbox2;
  let t18;
  let t19;
  let p9;
  let fast_button;
  let t20;
  let mounted;
  let dispose;
  let each_value = ctx[13];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  let if_block = ctx[8] && create_if_block$2(ctx);
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      p0 = element("p");
      fast_switch = element("fast-switch");
      t0 = text$1("Migrations");
      t1 = space();
      p1 = element("p");
      fast_text_field0 = element("fast-text-field");
      t2 = text$1("Schema");
      t3 = space();
      p2 = element("p");
      fast_text_field1 = element("fast-text-field");
      t4 = text$1("Table Name");
      t5 = space();
      p3 = element("p");
      fast_text_field2 = element("fast-text-field");
      t6 = text$1("Column Name");
      t7 = space();
      p4 = element("p");
      fast_text_field3 = element("fast-text-field");
      t8 = text$1("Hasura Column Name");
      t9 = space();
      p5 = element("p");
      fast_select = element("fast-select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t10 = space();
      p6 = element("p");
      fast_text_field4 = element("fast-text-field");
      t11 = text$1("Default Value");
      t12 = space();
      p7 = element("p");
      fast_checkbox0 = element("fast-checkbox");
      t13 = text$1("Nullable");
      t14 = space();
      fast_checkbox1 = element("fast-checkbox");
      fast_checkbox1.textContent = "Unique";
      t16 = space();
      p8 = element("p");
      fast_checkbox2 = element("fast-checkbox");
      fast_checkbox2.textContent = "Foreign Key";
      t18 = space();
      if (if_block)
        if_block.c();
      t19 = space();
      p9 = element("p");
      fast_button = element("fast-button");
      t20 = text$1("Add new column");
      set_custom_element_data(fast_switch, "checked", ctx[12]);
      attr(p0, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field0, "placeholder", "schema");
      set_custom_element_data(fast_text_field0, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field0, "value", ctx[7]);
      attr(p1, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field1, "placeholder", "table_name");
      set_custom_element_data(fast_text_field1, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field1, "value", ctx[2]);
      attr(p2, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field2, "placeholder", "column_name");
      set_custom_element_data(fast_text_field2, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field2, "value", ctx[0]);
      attr(p3, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field3, "placeholder", "columnName");
      set_custom_element_data(fast_text_field3, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field3, "value", ctx[6]);
      set_custom_element_data(fast_text_field3, "readonly", "");
      attr(p4, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_select, "value", ctx[5]);
      attr(p5, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_text_field4, "placeholder", "default value");
      set_custom_element_data(fast_text_field4, "class", "gql-input-field svelte-wtnnba");
      set_custom_element_data(fast_text_field4, "value", ctx[1]);
      attr(p6, "class", "gql-endpoint-input svelte-wtnnba");
      set_custom_element_data(fast_checkbox0, "id", "nullable");
      set_custom_element_data(fast_checkbox0, "checked", ctx[4]);
      set_custom_element_data(fast_checkbox1, "id", "unique");
      attr(p7, "class", "gql-checkbox svelte-wtnnba");
      set_custom_element_data(fast_checkbox2, "id", "foreignKey");
      attr(p8, "class", "gql-button-component svelte-wtnnba");
      set_custom_element_data(fast_button, "class", "gql-button svelte-wtnnba");
      set_custom_element_data(fast_button, "disabled", ctx[3]);
      attr(p9, "class", "gql-button-component svelte-wtnnba");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "height", "100%");
      set_style(fast_design_system_provider, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, p0);
      append$1(p0, fast_switch);
      append$1(fast_switch, t0);
      append$1(fast_design_system_provider, t1);
      append$1(fast_design_system_provider, p1);
      append$1(p1, fast_text_field0);
      append$1(fast_text_field0, t2);
      append$1(fast_design_system_provider, t3);
      append$1(fast_design_system_provider, p2);
      append$1(p2, fast_text_field1);
      append$1(fast_text_field1, t4);
      append$1(fast_design_system_provider, t5);
      append$1(fast_design_system_provider, p3);
      append$1(p3, fast_text_field2);
      append$1(fast_text_field2, t6);
      append$1(fast_design_system_provider, t7);
      append$1(fast_design_system_provider, p4);
      append$1(p4, fast_text_field3);
      append$1(fast_text_field3, t8);
      append$1(fast_design_system_provider, t9);
      append$1(fast_design_system_provider, p5);
      append$1(p5, fast_select);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(fast_select, null);
      }
      append$1(fast_design_system_provider, t10);
      append$1(fast_design_system_provider, p6);
      append$1(p6, fast_text_field4);
      append$1(fast_text_field4, t11);
      append$1(fast_design_system_provider, t12);
      append$1(fast_design_system_provider, p7);
      append$1(p7, fast_checkbox0);
      append$1(fast_checkbox0, t13);
      append$1(p7, t14);
      append$1(p7, fast_checkbox1);
      append$1(fast_design_system_provider, t16);
      append$1(fast_design_system_provider, p8);
      append$1(p8, fast_checkbox2);
      append$1(fast_design_system_provider, t18);
      if (if_block)
        if_block.m(fast_design_system_provider, null);
      append$1(fast_design_system_provider, t19);
      append$1(fast_design_system_provider, p9);
      append$1(p9, fast_button);
      append$1(fast_button, t20);
      if (!mounted) {
        dispose = [
          listen(fast_switch, "change", ctx[14]),
          listen(fast_text_field0, "input", ctx[17]),
          listen(fast_text_field1, "input", ctx[15]),
          listen(fast_text_field2, "input", ctx[16]),
          listen(fast_text_field3, "input", ctx[16]),
          listen(fast_select, "change", ctx[25]),
          listen(fast_text_field4, "input", ctx[18]),
          listen(fast_checkbox0, "change", ctx[24]),
          listen(fast_checkbox1, "change", ctx[24]),
          listen(fast_checkbox2, "change", ctx[24]),
          listen(fast_button, "click", ctx[26])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4096) {
        set_custom_element_data(fast_switch, "checked", ctx2[12]);
      }
      if (dirty[0] & 128) {
        set_custom_element_data(fast_text_field0, "value", ctx2[7]);
      }
      if (dirty[0] & 4) {
        set_custom_element_data(fast_text_field1, "value", ctx2[2]);
      }
      if (dirty[0] & 1) {
        set_custom_element_data(fast_text_field2, "value", ctx2[0]);
      }
      if (dirty[0] & 64) {
        set_custom_element_data(fast_text_field3, "value", ctx2[6]);
      }
      if (dirty[0] & 8192) {
        each_value = ctx2[13];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(fast_select, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 32) {
        set_custom_element_data(fast_select, "value", ctx2[5]);
      }
      if (dirty[0] & 2) {
        set_custom_element_data(fast_text_field4, "value", ctx2[1]);
      }
      if (dirty[0] & 16) {
        set_custom_element_data(fast_checkbox0, "checked", ctx2[4]);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          if_block.m(fast_design_system_provider, t19);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & 8) {
        set_custom_element_data(fast_button, "disabled", ctx2[3]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { dataTypes: dataTypes2 = [] } = $$props;
  let { columnName = "" } = $$props;
  let { defaultValue = "" } = $$props;
  let { tableName = "" } = $$props;
  let { disabled = true } = $$props;
  let { unique = false } = $$props;
  let { nullable = true } = $$props;
  let { selectedIndex = 0 } = $$props;
  let { customName = "" } = $$props;
  let { schema: schema2 = "public" } = $$props;
  let { foreignKey = false } = $$props;
  let { referenceSchema = "public" } = $$props;
  let { referenceTable = "" } = $$props;
  let { referenceColumn = "id" } = $$props;
  let { updateConstraints = "" } = $$props;
  let { deleteConstraints = "" } = $$props;
  let { migration = true } = $$props;
  const dispatch2 = createEventDispatcher();
  const checkInputs = () => {
    if (tableName === "" || columnName === "" || schema2 === "")
      $$invalidate(3, disabled = true);
    else
      $$invalidate(3, disabled = false);
  };
  const capitalize2 = (text2) => {
    return text2.charAt(0).toUpperCase() + text2.slice(1);
  };
  const capitalizeFirstLetters2 = (name) => {
    return name.split("_").map((element2) => {
      return capitalize2(element2);
    }).join("");
  };
  const lowerFirstLetter2 = (text2) => {
    return text2.charAt(0).toLowerCase() + text2.slice(1);
  };
  const handleMigration = (e) => {
    $$invalidate(12, migration = e.target.checked);
  };
  const handleTableNameInput = (e) => {
    $$invalidate(2, tableName = e.target.value);
    checkInputs();
  };
  const handleColumnNameInput = (e) => {
    $$invalidate(0, columnName = e.target.value);
    $$invalidate(6, customName = lowerFirstLetter2(capitalizeFirstLetters2(columnName)));
    checkInputs();
  };
  const handleSchemaInput = (e) => {
    $$invalidate(7, schema2 = e.target.value);
    checkInputs();
  };
  const handleDefaultValueInput = (e) => {
    $$invalidate(1, defaultValue = e.target.value);
  };
  const handleReferenceSchemaInput = (e) => {
    $$invalidate(9, referenceSchema = e.target.value);
  };
  const handleReferenceTableInput = (e) => {
    $$invalidate(10, referenceTable = e.target.value);
  };
  const handleReferenceColumnInput = (e) => {
    $$invalidate(11, referenceColumn = e.target.value);
  };
  const handleUpdateViolation = (e) => {
    $$invalidate(28, updateConstraints = e.target.value);
  };
  const handleDeleteViolation = (e) => {
    $$invalidate(29, deleteConstraints = e.target.value);
  };
  const handleCheckBox = (e) => {
    let id = e.target.id;
    switch (id) {
      case "unique":
        $$invalidate(27, unique = e.target.checked);
        break;
      case "nullable":
        $$invalidate(4, nullable = e.target.checked);
        break;
      case "foreignKey":
        $$invalidate(8, foreignKey = e.target.checked);
        break;
    }
  };
  const handleSelect = (e) => {
    $$invalidate(5, selectedIndex = e.target.selectedIndex);
  };
  const returnType2 = () => {
    if (selectedIndex > 0) {
      return dataTypes2[selectedIndex].type;
    }
    return "";
  };
  const handleAddColumn2 = () => {
    dispatch2("addNewColumn", {
      migration,
      schema: schema2,
      tableName,
      columnName,
      defaultValue,
      unique,
      nullable,
      type: returnType2(),
      foreignKey: {
        referenceSchema,
        referenceTable,
        referenceColumn,
        updateConstraints,
        deleteConstraints
      }
    });
    dispatch2("close");
  };
  $$self.$$set = ($$props2) => {
    if ("dataTypes" in $$props2)
      $$invalidate(13, dataTypes2 = $$props2.dataTypes);
    if ("columnName" in $$props2)
      $$invalidate(0, columnName = $$props2.columnName);
    if ("defaultValue" in $$props2)
      $$invalidate(1, defaultValue = $$props2.defaultValue);
    if ("tableName" in $$props2)
      $$invalidate(2, tableName = $$props2.tableName);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("unique" in $$props2)
      $$invalidate(27, unique = $$props2.unique);
    if ("nullable" in $$props2)
      $$invalidate(4, nullable = $$props2.nullable);
    if ("selectedIndex" in $$props2)
      $$invalidate(5, selectedIndex = $$props2.selectedIndex);
    if ("customName" in $$props2)
      $$invalidate(6, customName = $$props2.customName);
    if ("schema" in $$props2)
      $$invalidate(7, schema2 = $$props2.schema);
    if ("foreignKey" in $$props2)
      $$invalidate(8, foreignKey = $$props2.foreignKey);
    if ("referenceSchema" in $$props2)
      $$invalidate(9, referenceSchema = $$props2.referenceSchema);
    if ("referenceTable" in $$props2)
      $$invalidate(10, referenceTable = $$props2.referenceTable);
    if ("referenceColumn" in $$props2)
      $$invalidate(11, referenceColumn = $$props2.referenceColumn);
    if ("updateConstraints" in $$props2)
      $$invalidate(28, updateConstraints = $$props2.updateConstraints);
    if ("deleteConstraints" in $$props2)
      $$invalidate(29, deleteConstraints = $$props2.deleteConstraints);
    if ("migration" in $$props2)
      $$invalidate(12, migration = $$props2.migration);
  };
  return [
    columnName,
    defaultValue,
    tableName,
    disabled,
    nullable,
    selectedIndex,
    customName,
    schema2,
    foreignKey,
    referenceSchema,
    referenceTable,
    referenceColumn,
    migration,
    dataTypes2,
    handleMigration,
    handleTableNameInput,
    handleColumnNameInput,
    handleSchemaInput,
    handleDefaultValueInput,
    handleReferenceSchemaInput,
    handleReferenceTableInput,
    handleReferenceColumnInput,
    handleUpdateViolation,
    handleDeleteViolation,
    handleCheckBox,
    handleSelect,
    handleAddColumn2,
    unique,
    updateConstraints,
    deleteConstraints
  ];
}
class AddColumn extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$7, create_fragment$7, safe_not_equal, {
      dataTypes: 13,
      columnName: 0,
      defaultValue: 1,
      tableName: 2,
      disabled: 3,
      unique: 27,
      nullable: 4,
      selectedIndex: 5,
      customName: 6,
      schema: 7,
      foreignKey: 8,
      referenceSchema: 9,
      referenceTable: 10,
      referenceColumn: 11,
      updateConstraints: 28,
      deleteConstraints: 29,
      migration: 12
    }, add_css$3, [-1, -1]);
  }
}
function create_fragment$6(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: AddColumn,
      props: {
        okButton: true,
        dataTypes: ctx[0]
      },
      events: {
        close: ctx[4],
        addColumn: ctx[5],
        addNewColumn: ctx[3]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "700",
      width: "550",
      x: ctx[1],
      y: ctx[2],
      title: "Add New Column"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 1)
        winbox_changes.props = {
          okButton: true,
          dataTypes: ctx2[0]
        };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { dataTypes: dataTypes2 = [] } = $$props;
  let { columnAdded = (AddNewColumnEvent) => {
  } } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const addNewColumn2 = (e) => {
    columnAdded(e.detail);
  };
  const close = () => {
    dispatch2("close", []);
  };
  const addColumn2 = () => {
    dispatch2("addColumn");
  };
  $$self.$$set = ($$props2) => {
    if ("dataTypes" in $$props2)
      $$invalidate(0, dataTypes2 = $$props2.dataTypes);
    if ("columnAdded" in $$props2)
      $$invalidate(6, columnAdded = $$props2.columnAdded);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
  };
  return [dataTypes2, x2, y2, addNewColumn2, close, addColumn2, columnAdded];
}
class AddColumnDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$6, create_fragment$6, safe_not_equal, { dataTypes: 0, columnAdded: 6, x: 1, y: 2 });
  }
}
function add_css$2(target) {
  append_styles(target, "svelte-7ppw44", ".gql-endpoint-input.svelte-7ppw44{padding:1rem;display:flex;justify-content:space-between}.gql-button.svelte-7ppw44{width:150px;display:flex;justify-content:center;margin:0rem 1rem 0rem 1rem}");
}
function create_fragment$5(ctx) {
  let fast_design_system_provider;
  let p2;
  let fast_switch;
  let t0;
  let t1;
  let fast_button;
  let t3;
  let erd_editor;
  let mounted;
  let dispose;
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      p2 = element("p");
      fast_switch = element("fast-switch");
      t0 = text$1("Migrations");
      t1 = space();
      fast_button = element("fast-button");
      fast_button.textContent = "Save";
      t3 = space();
      erd_editor = element("erd-editor");
      set_custom_element_data(fast_switch, "class", "switch");
      set_custom_element_data(fast_switch, "checked", ctx[0]);
      set_custom_element_data(fast_button, "class", "gql-button svelte-7ppw44");
      attr(p2, "class", "gql-endpoint-input svelte-7ppw44");
      set_custom_element_data(erd_editor, "width", "100%");
      set_custom_element_data(erd_editor, "height", "100%");
      set_custom_element_data(erd_editor, "automaticlayout", true);
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "height", "100%");
      set_style(fast_design_system_provider, "overflow", "hidden");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, p2);
      append$1(p2, fast_switch);
      append$1(fast_switch, t0);
      append$1(p2, t1);
      append$1(p2, fast_button);
      append$1(fast_design_system_provider, t3);
      append$1(fast_design_system_provider, erd_editor);
      if (!mounted) {
        dispose = [
          listen(fast_switch, "change", ctx[1]),
          listen(fast_button, "click", ctx[3]),
          listen(erd_editor, "change", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_custom_element_data(fast_switch, "checked", ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let jsonData = JSON.stringify(data);
  let migration = true;
  const dispatch2 = createEventDispatcher();
  loadVuerd();
  async function loadVuerd() {
    var _a2;
    await import("https://cdn.jsdelivr.net/npm/vuerd/dist/vuerd.min.js");
    var list = document.getElementsByTagName("erd-editor");
    (_a2 = list == null ? void 0 : list[0]) == null ? void 0 : _a2.initLoadJson(jsonData);
  }
  const handleMigration = (e) => {
    $$invalidate(0, migration = e.target.checked);
  };
  const handleChange = (e) => {
    jsonData = e.target.value;
  };
  const handleSave = () => {
    dispatch2("save", {
      jsonData: JSON.parse(jsonData),
      migration
    });
    dispatch2("close");
  };
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(4, data = $$props2.data);
  };
  return [migration, handleMigration, handleChange, handleSave, data];
}
class ERDViewer extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$5, create_fragment$5, safe_not_equal, { data: 4 }, add_css$2);
  }
}
function create_fragment$4(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: ERDViewer,
      props: { data: ctx[0], okButton: true },
      events: {
        close: ctx[3],
        save: ctx[4]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "600",
      width: "800",
      x: ctx[1],
      y: ctx[2],
      title: "Entity-Relationship Diagram"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 1)
        winbox_changes.props = { data: ctx2[0], okButton: true };
      if (dirty & 2)
        winbox_changes.x = ctx2[1];
      if (dirty & 4)
        winbox_changes.y = ctx2[2];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { data } = $$props;
  let { saved = (SaveEvent) => {
  } } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const close = () => {
    dispatch2("close", []);
  };
  const save22 = (e) => {
    saved(e.detail);
  };
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("saved" in $$props2)
      $$invalidate(5, saved = $$props2.saved);
    if ("x" in $$props2)
      $$invalidate(1, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(2, y2 = $$props2.y);
  };
  return [data, x2, y2, close, save22, saved];
}
class ERDViewerDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$4, create_fragment$4, safe_not_equal, { data: 0, saved: 5, x: 1, y: 2 });
  }
}
function add_css$1(target) {
  append_styles(target, "svelte-xttb7a", ".commit-text.svelte-xttb7a{font-size:var(--type-ramp-base-font-size);padding:1rem}.commit-text-warning.svelte-xttb7a{font-size:var(--type-ramp-base-font-size);padding:1rem;color:#ff4545;text-align:center;font-size:18px}.commit-input.svelte-xttb7a{padding:1rem;display:flex;justify-content:space-between;align-items:flex-end}.commit-text.commit-half.svelte-xttb7a,.commit-input.commit-half.svelte-xttb7a{padding:0.5rem 1rem}.commit-input-field.svelte-xttb7a{width:80%}.commit-button.svelte-xttb7a{display:flex;align-items:center;justify-content:center;padding:0.5rem;background-color:#fff;border-radius:2px;color:#000}.commit-save-button.svelte-xttb7a{width:25%;margin-left:1rem;justify-content:center}.custom-icon{vertical-align:middle}.wrapper.svelte-xttb7a{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;padding:1rem}.cors.svelte-xttb7a{margin:1rem;background-color:#00000038;border-radius:5px;padding:1rem}.info.svelte-xttb7a{display:flex;flex-direction:row;align-items:center;margin:0 1rem;background-color:#00000038;padding:1rem;border-radius:5px}.column.svelte-xttb7a{display:flex;flex-direction:column;justify-content:center;text-align:center;padding:0.8rem 0.4rem;margin:0.4rem;background-color:#00000038;border-radius:5px}.column-header.svelte-xttb7a{display:flex;flex-direction:row;justify-content:center;align-items:center}.netlify-badge.svelte-xttb7a{width:100%;height:24px;background:#49494969;border-radius:5px;animation:svelte-xttb7a-netlifyBlink 1s infinite alternate}@keyframes svelte-xttb7a-netlifyBlink{from{background-color:#49494969}to{background-color:#84848469}}");
}
function create_else_block_1(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag();
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[7], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 128)
        html_tag.p(ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block_3$1(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "netlify-badge svelte-xttb7a");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_else_block(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = !ctx[4] && create_if_block_2$1(ctx);
  let if_block1 = ctx[4] && create_if_block_1$1(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$1(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block$1(ctx) {
  let div2;
  let p0;
  let t1;
  let p1;
  let b1;
  let t5;
  let p2;
  let a0;
  let img0;
  let img0_src_value;
  let t6;
  let b2;
  let t8;
  let p3;
  let t10;
  let p4;
  return {
    c() {
      div2 = element("div");
      p0 = element("p");
      p0.innerHTML = `<b>CORS ORIGINS</b>`;
      t1 = space();
      p1 = element("p");
      b1 = element("b");
      b1.textContent = `Be sure to add '${ctx[8]}' to your graph CORS origins so your users can log into app.`;
      t5 = space();
      p2 = element("p");
      a0 = element("a");
      img0 = element("img");
      t6 = space();
      b2 = element("b");
      b2.textContent = "Graph CORS origins";
      t8 = space();
      p3 = element("p");
      p3.innerHTML = `<b>Check if you have enabled Netlify Graph in Profile Settings</b>`;
      t10 = space();
      p4 = element("p");
      p4.innerHTML = `<a class="commit-button svelte-xttb7a" rel="noopener noreferrer" target="_blank" href="https://app.netlify.com/user/labs"><img width="25px" style="margin-right: 0.5rem" alt="netlify" src="https://img.icons8.com/external-tal-revivo-bold-tal-revivo/48/undefined/external-netlify-a-cloud-computing-company-that-offers-hosting-and-serverless-backend-services-for-static-websites-logo-bold-tal-revivo.png"/> 
      <b>Labs Netlify Graph</b></a>`;
      attr(p0, "class", "commit-text-warning svelte-xttb7a");
      attr(p1, "class", "commit-text commit-half svelte-xttb7a");
      attr(img0, "width", "25px");
      set_style(img0, "margin-right", "0.5rem");
      attr(img0, "alt", "netlify");
      if (!src_url_equal(img0.src, img0_src_value = "https://img.icons8.com/external-tal-revivo-bold-tal-revivo/48/undefined/external-netlify-a-cloud-computing-company-that-offers-hosting-and-serverless-backend-services-for-static-websites-logo-bold-tal-revivo.png"))
        attr(img0, "src", img0_src_value);
      attr(a0, "class", "commit-button svelte-xttb7a");
      attr(a0, "rel", "noopener noreferrer");
      attr(a0, "target", "_blank");
      attr(a0, "href", ctx[9]);
      attr(p2, "class", "commit-input commit-half svelte-xttb7a");
      attr(p3, "class", "commit-text commit-half svelte-xttb7a");
      attr(p4, "class", "commit-input commit-half svelte-xttb7a");
      attr(div2, "class", "cors svelte-xttb7a");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append$1(div2, p0);
      append$1(div2, t1);
      append$1(div2, p1);
      append$1(p1, b1);
      append$1(div2, t5);
      append$1(div2, p2);
      append$1(p2, a0);
      append$1(a0, img0);
      append$1(a0, t6);
      append$1(a0, b2);
      append$1(div2, t8);
      append$1(div2, p3);
      append$1(div2, t10);
      append$1(div2, p4);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_if_block_2$1(ctx) {
  let p2;
  let fast_button;
  let mounted;
  let dispose;
  return {
    c() {
      p2 = element("p");
      fast_button = element("fast-button");
      fast_button.innerHTML = `<img width="24px" style="margin: -6px 0px; margin-right: 0.5rem;" alt="github" src="https://img.icons8.com/material-outlined/48/undefined/github.png"/><b>Login to GitHub</b>`;
      set_style(fast_button, "width", "100%");
      attr(p2, "class", "commit-input svelte-xttb7a");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      append$1(p2, fast_button);
      if (!mounted) {
        dispose = listen(fast_button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(p2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1(ctx) {
  let p0;
  let fast_text_field;
  let b0;
  let t1;
  let fast_button0;
  let b1;
  let t3;
  let p1;
  let fast_button1;
  let mounted;
  let dispose;
  return {
    c() {
      p0 = element("p");
      fast_text_field = element("fast-text-field");
      b0 = element("b");
      b0.textContent = "Commit Message";
      t1 = space();
      fast_button0 = element("fast-button");
      b1 = element("b");
      b1.textContent = "Commit Changes";
      t3 = space();
      p1 = element("p");
      fast_button1 = element("fast-button");
      fast_button1.innerHTML = `<img width="24px" style="margin: -6px 0px; margin-right: 0.5rem;" alt="github" src="https://img.icons8.com/material-outlined/48/undefined/github.png"/><b>Logout GitHub</b>`;
      set_custom_element_data(fast_text_field, "placeholder", "Message");
      set_custom_element_data(fast_text_field, "class", "commit-input-field svelte-xttb7a");
      set_custom_element_data(fast_text_field, "value", ctx[0]);
      set_custom_element_data(fast_text_field, "disabled", ctx[6]);
      set_custom_element_data(fast_button0, "class", "commit-save-button svelte-xttb7a");
      set_custom_element_data(fast_button0, "disabled", ctx[5]);
      attr(p0, "class", "commit-input svelte-xttb7a");
      set_style(fast_button1, "width", "100%");
      attr(p1, "class", "commit-input svelte-xttb7a");
    },
    m(target, anchor) {
      insert(target, p0, anchor);
      append$1(p0, fast_text_field);
      append$1(fast_text_field, b0);
      append$1(p0, t1);
      append$1(p0, fast_button0);
      append$1(fast_button0, b1);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      append$1(p1, fast_button1);
      if (!mounted) {
        dispose = [
          listen(fast_text_field, "input", ctx[15]),
          listen(fast_button0, "click", ctx[12]),
          listen(fast_button1, "click", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        set_custom_element_data(fast_text_field, "value", ctx2[0]);
      }
      if (dirty & 64) {
        set_custom_element_data(fast_text_field, "disabled", ctx2[6]);
      }
      if (dirty & 32) {
        set_custom_element_data(fast_button0, "disabled", ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3(ctx) {
  let fast_design_system_provider;
  let div8;
  let div1;
  let div0;
  let t2;
  let p0;
  let t3;
  let div3;
  let div2;
  let t6;
  let p1;
  let b2;
  let t8;
  let div5;
  let div4;
  let t11;
  let p2;
  let b4;
  let t13;
  let div7;
  let div6;
  let t16;
  let p3;
  let b6;
  let t17;
  let t18;
  let p4;
  let img4;
  let img4_src_value;
  let t19;
  let b7;
  let t20_value = ctx[2] == 1 ? ctx[2] + " Changed File" : ctx[2] + " Changed Files";
  let t20;
  let t21;
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].length == 0)
      return create_if_block_3$1;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block$1;
    return create_else_block;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      fast_design_system_provider = element("fast-design-system-provider");
      div8 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img width="24px" alt="netlify" src="https://img.icons8.com/FFFFFF/external-tal-revivo-bold-tal-revivo/48/undefined/external-netlify-a-cloud-computing-company-that-offers-hosting-and-serverless-backend-services-for-static-websites-logo-bold-tal-revivo.png"/> 
        <b style="margin-left: 0.2rem">STATUS</b>`;
      t2 = space();
      p0 = element("p");
      if_block0.c();
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      div2.innerHTML = `<img width="24px" alt="repository" src="https://img.icons8.com/FFFFFF/ios-glyphs/30/undefined/repository.png"/> 
        <b style="margin-left: 0.2rem">REPOSITORY</b>`;
      t6 = space();
      p1 = element("p");
      b2 = element("b");
      b2.textContent = `${ctx[11]}`;
      t8 = space();
      div5 = element("div");
      div4 = element("div");
      div4.innerHTML = `<img width="24px" alt="owner" src="https://img.icons8.com/FFFFFF/ios-glyphs/30/undefined/user--v1.png"/> 
        <b style="margin-left: 0.2rem">OWNER</b>`;
      t11 = space();
      p2 = element("p");
      b4 = element("b");
      b4.textContent = `${ctx[10]}`;
      t13 = space();
      div7 = element("div");
      div6 = element("div");
      div6.innerHTML = `<img width="25px" alt="branch" src="https://img.icons8.com/FFFFFF/material-rounded/24/undefined/commit-git.png"/> 
        <b style="margin-left: 0.2rem">BRANCH</b>`;
      t16 = space();
      p3 = element("p");
      b6 = element("b");
      t17 = text$1(ctx[1]);
      t18 = space();
      p4 = element("p");
      img4 = element("img");
      t19 = space();
      b7 = element("b");
      t20 = text$1(t20_value);
      t21 = space();
      if_block1.c();
      attr(div0, "class", "column-header svelte-xttb7a");
      attr(p0, "class", "commit-text svelte-xttb7a");
      set_style(p0, "padding", "0.8rem 0");
      attr(div1, "class", "column svelte-xttb7a");
      set_style(div1, "margin-left", "0");
      attr(div2, "class", "column-header svelte-xttb7a");
      attr(p1, "class", "commit-text svelte-xttb7a");
      set_style(p1, "padding", "0.8rem 0");
      attr(div3, "class", "column svelte-xttb7a");
      attr(div4, "class", "column-header svelte-xttb7a");
      attr(p2, "class", "commit-text svelte-xttb7a");
      set_style(p2, "padding", "0.8rem 0");
      attr(div5, "class", "column svelte-xttb7a");
      attr(div6, "class", "column-header svelte-xttb7a");
      attr(p3, "class", "commit-text svelte-xttb7a");
      set_style(p3, "padding", "0.8rem 0");
      attr(div7, "class", "column svelte-xttb7a");
      set_style(div7, "margin-right", "0");
      attr(div8, "class", "wrapper svelte-xttb7a");
      attr(img4, "width", "24px");
      set_style(img4, "margin-right", "0.5rem");
      attr(img4, "alt", "branch");
      if (!src_url_equal(img4.src, img4_src_value = "https://img.icons8.com/color/20/undefined/info--v1.png"))
        attr(img4, "src", img4_src_value);
      attr(p4, "class", "commit-text info svelte-xttb7a");
      set_custom_element_data(fast_design_system_provider, "use-defaults", "");
      set_style(fast_design_system_provider, "height", "100%");
      set_style(fast_design_system_provider, "overflow", "hidden");
    },
    m(target, anchor) {
      insert(target, fast_design_system_provider, anchor);
      append$1(fast_design_system_provider, div8);
      append$1(div8, div1);
      append$1(div1, div0);
      append$1(div1, t2);
      append$1(div1, p0);
      if_block0.m(p0, null);
      append$1(div8, t3);
      append$1(div8, div3);
      append$1(div3, div2);
      append$1(div3, t6);
      append$1(div3, p1);
      append$1(p1, b2);
      append$1(div8, t8);
      append$1(div8, div5);
      append$1(div5, div4);
      append$1(div5, t11);
      append$1(div5, p2);
      append$1(p2, b4);
      append$1(div8, t13);
      append$1(div8, div7);
      append$1(div7, div6);
      append$1(div7, t16);
      append$1(div7, p3);
      append$1(p3, b6);
      append$1(b6, t17);
      append$1(fast_design_system_provider, t18);
      append$1(fast_design_system_provider, p4);
      append$1(p4, img4);
      append$1(p4, t19);
      append$1(p4, b7);
      append$1(b7, t20);
      append$1(fast_design_system_provider, t21);
      if_block1.m(fast_design_system_provider, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(p0, null);
        }
      }
      if (dirty & 2)
        set_data(t17, ctx2[1]);
      if (dirty & 4 && t20_value !== (t20_value = ctx2[2] == 1 ? ctx2[2] + " Changed File" : ctx2[2] + " Changed Files"))
        set_data(t20, t20_value);
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(fast_design_system_provider, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(fast_design_system_provider);
      if_block0.d();
      if_block1.d();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let netlifyBadge;
  let { commitMessage = "" } = $$props;
  let { siteId = "" } = $$props;
  let { repositoryUrl = "" } = $$props;
  let { branch = "" } = $$props;
  let { changedFilesCount = 0 } = $$props;
  let { corsCheck = false } = $$props;
  let { isLoggedIn = false } = $$props;
  let disabled = true;
  let disabledInput = false;
  const dispatch2 = createEventDispatcher();
  const currentURL = window.location.protocol + "//" + window.location.hostname + (window.location.port === "" ? "" : ":" + window.location.port);
  const graphSettingsURL = "https://app.netlify.com/site-redirect/" + siteId + "/graph/settings";
  const [organisation, repository] = repositoryUrl.replace("https://github.com/", "").split("/");
  disabled = changedFilesCount == 0;
  disabledInput = changedFilesCount == 0;
  let badge = "";
  onMount(() => {
    const interval = setInterval(async () => {
      const resp = await fetch("https://api.netlify.com/api/v1/badges/" + siteId + "/deploy-status?branch=" + branch);
      $$invalidate(18, badge = await resp.text());
    }, 5e3);
    return () => {
      clearInterval(interval);
    };
  });
  const handleCommit = () => {
    dispatch2("save", { commitMessage });
    dispatch2("close");
  };
  const handleLoginGithub = () => {
    dispatch2("login", { provider: "github", login: true });
    dispatch2("close");
  };
  const handleLogoutGithub = () => {
    dispatch2("login", { provider: "github", login: false });
    dispatch2("close");
  };
  const handleInput = (e) => {
    $$invalidate(0, commitMessage = e.target.value);
    if (commitMessage === "" || changedFilesCount == 0)
      $$invalidate(5, disabled = true);
    else
      $$invalidate(5, disabled = false);
  };
  $$self.$$set = ($$props2) => {
    if ("commitMessage" in $$props2)
      $$invalidate(0, commitMessage = $$props2.commitMessage);
    if ("siteId" in $$props2)
      $$invalidate(16, siteId = $$props2.siteId);
    if ("repositoryUrl" in $$props2)
      $$invalidate(17, repositoryUrl = $$props2.repositoryUrl);
    if ("branch" in $$props2)
      $$invalidate(1, branch = $$props2.branch);
    if ("changedFilesCount" in $$props2)
      $$invalidate(2, changedFilesCount = $$props2.changedFilesCount);
    if ("corsCheck" in $$props2)
      $$invalidate(3, corsCheck = $$props2.corsCheck);
    if ("isLoggedIn" in $$props2)
      $$invalidate(4, isLoggedIn = $$props2.isLoggedIn);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 262144) {
      $$invalidate(7, netlifyBadge = badge);
    }
  };
  return [
    commitMessage,
    branch,
    changedFilesCount,
    corsCheck,
    isLoggedIn,
    disabled,
    disabledInput,
    netlifyBadge,
    currentURL,
    graphSettingsURL,
    organisation,
    repository,
    handleCommit,
    handleLoginGithub,
    handleLogoutGithub,
    handleInput,
    siteId,
    repositoryUrl,
    badge
  ];
}
class CommitChanges extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$3, create_fragment$3, safe_not_equal, {
      commitMessage: 0,
      siteId: 16,
      repositoryUrl: 17,
      branch: 1,
      changedFilesCount: 2,
      corsCheck: 3,
      isLoggedIn: 4
    }, add_css$1);
  }
}
function create_fragment$2(ctx) {
  let winbox2;
  let current;
  winbox2 = new Winbox_1({
    props: {
      component: CommitChanges,
      props: {
        commitMessage: ctx[0],
        corsCheck: ctx[5],
        isLoggedIn: ctx[6],
        siteId: ctx[1],
        repositoryUrl: ctx[2],
        branch: ctx[3],
        changedFilesCount: ctx[4]
      },
      events: {
        close: ctx[11],
        save: ctx[9],
        login: ctx[10]
      },
      classes: "iteria-ignore, gql-wrapper",
      height: "500",
      width: "680",
      x: ctx[7],
      y: ctx[8],
      title: "Commit Changes"
    }
  });
  return {
    c() {
      create_component(winbox2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(winbox2, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const winbox_changes = {};
      if (dirty & 127)
        winbox_changes.props = {
          commitMessage: ctx2[0],
          corsCheck: ctx2[5],
          isLoggedIn: ctx2[6],
          siteId: ctx2[1],
          repositoryUrl: ctx2[2],
          branch: ctx2[3],
          changedFilesCount: ctx2[4]
        };
      if (dirty & 128)
        winbox_changes.x = ctx2[7];
      if (dirty & 256)
        winbox_changes.y = ctx2[8];
      winbox2.$set(winbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(winbox2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(winbox2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(winbox2, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { commitMessage } = $$props;
  let { siteId } = $$props;
  let { repositoryUrl } = $$props;
  let { branch } = $$props;
  let { changedFilesCount } = $$props;
  let { corsCheck } = $$props;
  let { isLoggedIn } = $$props;
  let { commitChanges = (CommitChangesEvent) => {
  } } = $$props;
  let { loginGithub = (LoginGithubEvent) => {
  } } = $$props;
  let { x: x2 = "center" } = $$props;
  let { y: y2 = "center" } = $$props;
  const save22 = (e) => {
    commitChanges(e.detail.commitMessage);
  };
  const login = (e) => {
    loginGithub(e.detail.login);
  };
  const close = () => {
    dispatch2("close", []);
  };
  $$self.$$set = ($$props2) => {
    if ("commitMessage" in $$props2)
      $$invalidate(0, commitMessage = $$props2.commitMessage);
    if ("siteId" in $$props2)
      $$invalidate(1, siteId = $$props2.siteId);
    if ("repositoryUrl" in $$props2)
      $$invalidate(2, repositoryUrl = $$props2.repositoryUrl);
    if ("branch" in $$props2)
      $$invalidate(3, branch = $$props2.branch);
    if ("changedFilesCount" in $$props2)
      $$invalidate(4, changedFilesCount = $$props2.changedFilesCount);
    if ("corsCheck" in $$props2)
      $$invalidate(5, corsCheck = $$props2.corsCheck);
    if ("isLoggedIn" in $$props2)
      $$invalidate(6, isLoggedIn = $$props2.isLoggedIn);
    if ("commitChanges" in $$props2)
      $$invalidate(12, commitChanges = $$props2.commitChanges);
    if ("loginGithub" in $$props2)
      $$invalidate(13, loginGithub = $$props2.loginGithub);
    if ("x" in $$props2)
      $$invalidate(7, x2 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(8, y2 = $$props2.y);
  };
  return [
    commitMessage,
    siteId,
    repositoryUrl,
    branch,
    changedFilesCount,
    corsCheck,
    isLoggedIn,
    x2,
    y2,
    save22,
    login,
    close,
    commitChanges,
    loginGithub
  ];
}
class CommitChangesDialog extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$2, create_fragment$2, safe_not_equal, {
      commitMessage: 0,
      siteId: 1,
      repositoryUrl: 2,
      branch: 3,
      changedFilesCount: 4,
      corsCheck: 5,
      isLoggedIn: 6,
      commitChanges: 12,
      loginGithub: 13,
      x: 7,
      y: 8
    });
  }
}
function hasInputElement(el2, depth2) {
  let found = void 0;
  const dfs = (element2, depthh) => {
    if (element2.tagName === "INPUT") {
      found = element2.name;
      return true;
    }
    if (depthh === 0)
      return false;
    element2.childNodes.forEach((node) => {
      return dfs(node, depth2 - 1);
    });
  };
  dfs(el2, depth2);
  return found;
}
function elementHasList(el2, depth2) {
  let element2 = el2;
  let foundList = void 0;
  let hasRoutes = false;
  while (depth2--) {
    if (element2.tagName === "UL") {
      foundList = element2;
      let li = element2.firstChild;
      while (li) {
        if (li.tagName === "A") {
          hasRoutes = true;
          break;
        }
        li = li.firstChild;
      }
      break;
    }
    if (element2.firstChild) {
      element2 = element2.firstChild;
    } else {
      break;
    }
  }
  return { foundList, hasRoutes };
}
function getHref(el2) {
  let element2 = el2;
  while (element2) {
    if (element2.tagName === "A") {
      return element2.href;
    }
    element2 = element2.firstChild;
  }
  return "";
}
function dragOnColumnHeader(element2) {
  let el2 = element2;
  let found = false;
  let depth2 = 10;
  while (el2 && depth2--) {
    if (el2.getAttribute("role") === "columnheader") {
      found = true;
      break;
    }
    el2 = el2.parentNode;
  }
  return { found, parentElement: el2.parentNode };
}
function getDeepNodeAttribute(element2, attrName, tagName) {
  let el2 = element2;
  let depth2 = 5;
  while (el2 && depth2--) {
    if (tagName && el2.tagName === tagName.toUpperCase()) {
      return el2.getAttribute(attrName);
    }
    el2 = el2.firstChild;
  }
  return void 0;
}
const { window: window_1 } = globals;
function add_css(target) {
  append_styles(target, "svelte-wo59zv", ".sortable-ghost{opacity:0.4}.dragable-item{cursor:move;transition:transform 0.3s;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dragable-item:hover{transform:scale(1.05)}.dragable-item.dragable-ignore{cursor:alias;pointer-events:none}");
}
function create_if_block_15(ctx) {
  let errorsnackbar;
  let t;
  let vscodewindow;
  let updating_hidden;
  let current;
  errorsnackbar = new ErrorSnackbar({
    props: { bundlerError: ctx[1] }
  });
  function vscodewindow_hidden_binding(value2) {
    ctx[62](value2);
  }
  let vscodewindow_props = { title: "Iteria Vscode" };
  if (ctx[31] !== void 0) {
    vscodewindow_props.hidden = ctx[31];
  }
  vscodewindow = new VscodeWindow({ props: vscodewindow_props });
  binding_callbacks.push(() => bind(vscodewindow, "hidden", vscodewindow_hidden_binding));
  vscodewindow.$on("iframeLoaded", ctx[63]);
  vscodewindow.$on("close", ctx[64]);
  return {
    c() {
      create_component(errorsnackbar.$$.fragment);
      t = space();
      create_component(vscodewindow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(errorsnackbar, target, anchor);
      insert(target, t, anchor);
      mount_component(vscodewindow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const errorsnackbar_changes = {};
      if (dirty[0] & 2)
        errorsnackbar_changes.bundlerError = ctx2[1];
      errorsnackbar.$set(errorsnackbar_changes);
      const vscodewindow_changes = {};
      if (!updating_hidden && dirty[1] & 1) {
        updating_hidden = true;
        vscodewindow_changes.hidden = ctx2[31];
        add_flush_callback(() => updating_hidden = false);
      }
      vscodewindow.$set(vscodewindow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(errorsnackbar.$$.fragment, local);
      transition_in(vscodewindow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(errorsnackbar.$$.fragment, local);
      transition_out(vscodewindow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(errorsnackbar, detaching);
      if (detaching)
        detach(t);
      destroy_component(vscodewindow, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let current;
  let if_block0 = (ctx[27] || ctx[24] === "dragable-editing") && create_if_block_14(ctx);
  let if_block1 = ctx[22] && (ctx[24] === "editing" || ctx[24] === "dragable-editing") && create_if_block_12(ctx);
  let if_block2 = ctx[23] && create_if_block_10(ctx);
  let if_block3 = ctx[9] && create_if_block_9(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[27] || ctx2[24] === "dragable-editing") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 150994944) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[22] && (ctx2[24] === "editing" || ctx2[24] === "dragable-editing")) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 20971520) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[23]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 8388608) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[9]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_9(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function create_if_block_14(ctx) {
  let widgetframe;
  let updating_offset;
  let updating_boundries;
  let current;
  function widgetframe_offset_binding(value2) {
    ctx[70](value2);
  }
  function widgetframe_boundries_binding(value2) {
    ctx[71](value2);
  }
  let widgetframe_props = {
    mode: ctx[24],
    element: ctx[22] && ctx[24] !== "inspecting" ? ctx[22] : ctx[21],
    activeAction: ctx[32]
  };
  if (ctx[7] !== void 0) {
    widgetframe_props.offset = ctx[7];
  }
  if (ctx[8] !== void 0) {
    widgetframe_props.boundries = ctx[8];
  }
  widgetframe = new WidgetFrame({ props: widgetframe_props });
  binding_callbacks.push(() => bind(widgetframe, "offset", widgetframe_offset_binding));
  binding_callbacks.push(() => bind(widgetframe, "boundries", widgetframe_boundries_binding));
  widgetframe.$on("clone", ctx[37]);
  widgetframe.$on("hover", ctx[39]);
  widgetframe.$on("modechange", ctx[40]);
  widgetframe.$on("showsource", ctx[41]);
  widgetframe.$on("translate", ctx[42]);
  widgetframe.$on("delete", ctx[52]);
  widgetframe.$on("set_extra_payload", ctx[36]);
  widgetframe.$on("confirmaction", ctx[46]);
  widgetframe.$on("cancelaction", ctx[47]);
  widgetframe.$on("activeaction", ctx[43]);
  widgetframe.$on("drag_and_drop_grid", ctx[44]);
  widgetframe.$on("drag_and_drop_relations", ctx[45]);
  return {
    c() {
      create_component(widgetframe.$$.fragment);
    },
    m(target, anchor) {
      mount_component(widgetframe, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const widgetframe_changes = {};
      if (dirty[0] & 16777216)
        widgetframe_changes.mode = ctx2[24];
      if (dirty[0] & 23068672)
        widgetframe_changes.element = ctx2[22] && ctx2[24] !== "inspecting" ? ctx2[22] : ctx2[21];
      if (dirty[1] & 2)
        widgetframe_changes.activeAction = ctx2[32];
      if (!updating_offset && dirty[0] & 128) {
        updating_offset = true;
        widgetframe_changes.offset = ctx2[7];
        add_flush_callback(() => updating_offset = false);
      }
      if (!updating_boundries && dirty[0] & 256) {
        updating_boundries = true;
        widgetframe_changes.boundries = ctx2[8];
        add_flush_callback(() => updating_boundries = false);
      }
      widgetframe.$set(widgetframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(widgetframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(widgetframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(widgetframe, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let widgetelevation;
  let t;
  let if_block_anchor;
  let current;
  widgetelevation = new WidgetElevation({
    props: {
      element: ctx[24] === "dragable-editing" ? ctx[22].parentElement : ctx[22],
      firstElement: ctx[33].firstElement,
      lastElement: ctx[33].lastElement
    }
  });
  widgetelevation.$on("click", click_handler);
  let if_block = ctx[14] && create_if_block_13(ctx);
  return {
    c() {
      create_component(widgetelevation.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(widgetelevation, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const widgetelevation_changes = {};
      if (dirty[0] & 20971520)
        widgetelevation_changes.element = ctx2[24] === "dragable-editing" ? ctx2[22].parentElement : ctx2[22];
      if (dirty[1] & 4)
        widgetelevation_changes.firstElement = ctx2[33].firstElement;
      if (dirty[1] & 4)
        widgetelevation_changes.lastElement = ctx2[33].lastElement;
      widgetelevation.$set(widgetelevation_changes);
      if (ctx2[14]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(widgetelevation.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(widgetelevation.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(widgetelevation, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_13(ctx) {
  let widgetfieldsdialog;
  let current;
  const widgetfieldsdialog_spread_levels = [
    { x: ctx[25] },
    { y: ctx[26] },
    { title: "Fields" },
    ctx[14]
  ];
  let widgetfieldsdialog_props = {};
  for (let i2 = 0; i2 < widgetfieldsdialog_spread_levels.length; i2 += 1) {
    widgetfieldsdialog_props = assign$1(widgetfieldsdialog_props, widgetfieldsdialog_spread_levels[i2]);
  }
  widgetfieldsdialog = new WidgetFieldsDialog({ props: widgetfieldsdialog_props });
  widgetfieldsdialog.$on("close", ctx[72]);
  widgetfieldsdialog.$on("change", ctx[73]);
  return {
    c() {
      create_component(widgetfieldsdialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(widgetfieldsdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const widgetfieldsdialog_changes = dirty[0] & 100679680 ? get_spread_update(widgetfieldsdialog_spread_levels, [
        dirty[0] & 33554432 && { x: ctx2[25] },
        dirty[0] & 67108864 && { y: ctx2[26] },
        widgetfieldsdialog_spread_levels[2],
        dirty[0] & 16384 && get_spread_object(ctx2[14])
      ]) : {};
      widgetfieldsdialog.$set(widgetfieldsdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(widgetfieldsdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(widgetfieldsdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(widgetfieldsdialog, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[13] && create_if_block_11(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_11(ctx) {
  let chooseentitydialog;
  let current;
  const chooseentitydialog_spread_levels = [
    { x: ctx[25] },
    { y: ctx[26] },
    { title: "Choose Entity" },
    ctx[13]
  ];
  let chooseentitydialog_props = {};
  for (let i2 = 0; i2 < chooseentitydialog_spread_levels.length; i2 += 1) {
    chooseentitydialog_props = assign$1(chooseentitydialog_props, chooseentitydialog_spread_levels[i2]);
  }
  chooseentitydialog = new ChooseEntityDialog({ props: chooseentitydialog_props });
  chooseentitydialog.$on("close", ctx[74]);
  chooseentitydialog.$on("select", ctx[75]);
  chooseentitydialog.$on("ok", ctx[76]);
  chooseentitydialog.$on("create", ctx[77]);
  chooseentitydialog.$on("loadIntrospection", ctx[78]);
  return {
    c() {
      create_component(chooseentitydialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chooseentitydialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const chooseentitydialog_changes = dirty[0] & 100671488 ? get_spread_update(chooseentitydialog_spread_levels, [
        dirty[0] & 33554432 && { x: ctx2[25] },
        dirty[0] & 67108864 && { y: ctx2[26] },
        chooseentitydialog_spread_levels[2],
        dirty[0] & 8192 && get_spread_object(ctx2[13])
      ]) : {};
      chooseentitydialog.$set(chooseentitydialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chooseentitydialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chooseentitydialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chooseentitydialog, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let translationsheetdialog;
  let current;
  translationsheetdialog = new TranslationSheetDialog({
    props: {
      x: ctx[25],
      y: ctx[26],
      title: "Choose Translation",
      translations: ctx[9]
    }
  });
  translationsheetdialog.$on("close", ctx[79]);
  translationsheetdialog.$on("change", ctx[80]);
  translationsheetdialog.$on("ok", ctx[81]);
  return {
    c() {
      create_component(translationsheetdialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(translationsheetdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const translationsheetdialog_changes = {};
      if (dirty[0] & 33554432)
        translationsheetdialog_changes.x = ctx2[25];
      if (dirty[0] & 67108864)
        translationsheetdialog_changes.y = ctx2[26];
      if (dirty[0] & 512)
        translationsheetdialog_changes.translations = ctx2[9];
      translationsheetdialog.$set(translationsheetdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(translationsheetdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(translationsheetdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(translationsheetdialog, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let insertfielddialog;
  let current;
  insertfielddialog = new InsertFieldDialog({
    props: {
      x: ctx[25],
      y: ctx[26],
      title: "Add field",
      intro: ctx[0]
    }
  });
  insertfielddialog.$on("close", ctx[82]);
  insertfielddialog.$on("select", ctx[83]);
  insertfielddialog.$on("addColumn", ctx[84]);
  insertfielddialog.$on("loadIntrospection", ctx[85]);
  return {
    c() {
      create_component(insertfielddialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(insertfielddialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const insertfielddialog_changes = {};
      if (dirty[0] & 33554432)
        insertfielddialog_changes.x = ctx2[25];
      if (dirty[0] & 67108864)
        insertfielddialog_changes.y = ctx2[26];
      if (dirty[0] & 1)
        insertfielddialog_changes.intro = ctx2[0];
      insertfielddialog.$set(insertfielddialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(insertfielddialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(insertfielddialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(insertfielddialog, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let clonedialog;
  let current;
  clonedialog = new CloneDialog({
    props: {
      intro: ctx[0],
      isInsideTable: ctx[3],
      __typename: ctx[6]
    }
  });
  clonedialog.$on("close", ctx[86]);
  clonedialog.$on("ok", ctx[87]);
  return {
    c() {
      create_component(clonedialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clonedialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const clonedialog_changes = {};
      if (dirty[0] & 1)
        clonedialog_changes.intro = ctx2[0];
      if (dirty[0] & 8)
        clonedialog_changes.isInsideTable = ctx2[3];
      if (dirty[0] & 64)
        clonedialog_changes.__typename = ctx2[6];
      clonedialog.$set(clonedialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(clonedialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clonedialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clonedialog, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let commitchangesdialog;
  let current;
  const commitchangesdialog_spread_levels = [ctx[16]];
  let commitchangesdialog_props = {};
  for (let i2 = 0; i2 < commitchangesdialog_spread_levels.length; i2 += 1) {
    commitchangesdialog_props = assign$1(commitchangesdialog_props, commitchangesdialog_spread_levels[i2]);
  }
  commitchangesdialog = new CommitChangesDialog({ props: commitchangesdialog_props });
  commitchangesdialog.$on("close", ctx[88]);
  commitchangesdialog.$on("save", ctx[89]);
  commitchangesdialog.$on("login", ctx[90]);
  return {
    c() {
      create_component(commitchangesdialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(commitchangesdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const commitchangesdialog_changes = dirty[0] & 65536 ? get_spread_update(commitchangesdialog_spread_levels, [get_spread_object(ctx2[16])]) : {};
      commitchangesdialog.$set(commitchangesdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(commitchangesdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(commitchangesdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(commitchangesdialog, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let graphqlendpointdialog;
  let current;
  const graphqlendpointdialog_spread_levels = [ctx[15]];
  let graphqlendpointdialog_props = {};
  for (let i2 = 0; i2 < graphqlendpointdialog_spread_levels.length; i2 += 1) {
    graphqlendpointdialog_props = assign$1(graphqlendpointdialog_props, graphqlendpointdialog_spread_levels[i2]);
  }
  graphqlendpointdialog = new GraphqlEndpointDialog({ props: graphqlendpointdialog_props });
  graphqlendpointdialog.$on("close", ctx[91]);
  graphqlendpointdialog.$on("save", ctx[92]);
  graphqlendpointdialog.$on("create", ctx[93]);
  graphqlendpointdialog.$on("addColumn", ctx[94]);
  graphqlendpointdialog.$on("loadIntrospection", ctx[95]);
  return {
    c() {
      create_component(graphqlendpointdialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(graphqlendpointdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const graphqlendpointdialog_changes = dirty[0] & 32768 ? get_spread_update(graphqlendpointdialog_spread_levels, [get_spread_object(ctx2[15])]) : {};
      graphqlendpointdialog.$set(graphqlendpointdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(graphqlendpointdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(graphqlendpointdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(graphqlendpointdialog, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let createtabledialog;
  let current;
  const createtabledialog_spread_levels = [ctx[18]];
  let createtabledialog_props = {};
  for (let i2 = 0; i2 < createtabledialog_spread_levels.length; i2 += 1) {
    createtabledialog_props = assign$1(createtabledialog_props, createtabledialog_spread_levels[i2]);
  }
  createtabledialog = new CreateTableDialog({ props: createtabledialog_props });
  createtabledialog.$on("close", ctx[96]);
  createtabledialog.$on("createTable", ctx[97]);
  return {
    c() {
      create_component(createtabledialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(createtabledialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const createtabledialog_changes = dirty[0] & 262144 ? get_spread_update(createtabledialog_spread_levels, [get_spread_object(ctx2[18])]) : {};
      createtabledialog.$set(createtabledialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(createtabledialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(createtabledialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(createtabledialog, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let addcolumndialog;
  let current;
  const addcolumndialog_spread_levels = [ctx[19]];
  let addcolumndialog_props = {};
  for (let i2 = 0; i2 < addcolumndialog_spread_levels.length; i2 += 1) {
    addcolumndialog_props = assign$1(addcolumndialog_props, addcolumndialog_spread_levels[i2]);
  }
  addcolumndialog = new AddColumnDialog({ props: addcolumndialog_props });
  addcolumndialog.$on("close", ctx[98]);
  addcolumndialog.$on("addNewColumn", ctx[99]);
  return {
    c() {
      create_component(addcolumndialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(addcolumndialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const addcolumndialog_changes = dirty[0] & 524288 ? get_spread_update(addcolumndialog_spread_levels, [get_spread_object(ctx2[19])]) : {};
      addcolumndialog.$set(addcolumndialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(addcolumndialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(addcolumndialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(addcolumndialog, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let erdviewerdialog;
  let current;
  const erdviewerdialog_spread_levels = [ctx[20]];
  let erdviewerdialog_props = {};
  for (let i2 = 0; i2 < erdviewerdialog_spread_levels.length; i2 += 1) {
    erdviewerdialog_props = assign$1(erdviewerdialog_props, erdviewerdialog_spread_levels[i2]);
  }
  erdviewerdialog = new ERDViewerDialog({ props: erdviewerdialog_props });
  erdviewerdialog.$on("close", ctx[100]);
  return {
    c() {
      create_component(erdviewerdialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(erdviewerdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const erdviewerdialog_changes = dirty[0] & 1048576 ? get_spread_update(erdviewerdialog_spread_levels, [get_spread_object(ctx2[20])]) : {};
      erdviewerdialog.$set(erdviewerdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(erdviewerdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(erdviewerdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(erdviewerdialog, detaching);
    }
  };
}
function create_if_block(ctx) {
  let themeeditordialog;
  let current;
  const themeeditordialog_spread_levels = [ctx[17]];
  let themeeditordialog_props = {};
  for (let i2 = 0; i2 < themeeditordialog_spread_levels.length; i2 += 1) {
    themeeditordialog_props = assign$1(themeeditordialog_props, themeeditordialog_spread_levels[i2]);
  }
  themeeditordialog = new ThemeEditorDialog({ props: themeeditordialog_props });
  themeeditordialog.$on("close", ctx[101]);
  themeeditordialog.$on("save", ctx[102]);
  return {
    c() {
      create_component(themeeditordialog.$$.fragment);
    },
    m(target, anchor) {
      mount_component(themeeditordialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const themeeditordialog_changes = dirty[0] & 131072 ? get_spread_update(themeeditordialog_spread_levels, [get_spread_object(ctx2[17])]) : {};
      themeeditordialog.$set(themeeditordialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(themeeditordialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(themeeditordialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(themeeditordialog, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  var _a2;
  let t0;
  let floatingbutton;
  let updating_showVsCode;
  let updating_hidden;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let if_block9_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[2] && ((_a2 = ctx[4]) == null ? void 0 : _a2.vsCode) != false && ctx[30] != false && create_if_block_15(ctx);
  function floatingbutton_showVsCode_binding(value2) {
    ctx[65](value2);
  }
  function floatingbutton_hidden_binding(value2) {
    ctx[66](value2);
  }
  let floatingbutton_props = {
    isDevserver: ctx[2],
    isNetlify: ctx[5],
    showTippy: ctx[27],
    features: ctx[4]
  };
  if (ctx[30] !== void 0) {
    floatingbutton_props.showVsCode = ctx[30];
  }
  if (ctx[31] !== void 0) {
    floatingbutton_props.hidden = ctx[31];
  }
  floatingbutton = new FloatingButton({ props: floatingbutton_props });
  binding_callbacks.push(() => bind(floatingbutton, "showVsCode", floatingbutton_showVsCode_binding));
  binding_callbacks.push(() => bind(floatingbutton, "hidden", floatingbutton_hidden_binding));
  floatingbutton.$on("generatePage", ctx[48]);
  floatingbutton.$on("commitAllChanges", ctx[56]);
  floatingbutton.$on("saveProjectZip", ctx[57]);
  floatingbutton.$on("loadIntrospection", ctx[67]);
  floatingbutton.$on("addColumn", ctx[38]);
  floatingbutton.$on("toggleTippy", ctx[68]);
  floatingbutton.$on("changeGraphqlEndpoint", ctx[49]);
  floatingbutton.$on("editTranslations", ctx[69]);
  floatingbutton.$on("changeTheme", ctx[51]);
  floatingbutton.$on("viewERD", ctx[55]);
  let if_block1 = (ctx[21] || ctx[22]) && create_if_block_8(ctx);
  let if_block2 = ctx[0] && !ctx[28] && ctx[29] && create_if_block_7(ctx);
  let if_block3 = ctx[28] && create_if_block_6(ctx);
  let if_block4 = ctx[16] && create_if_block_5(ctx);
  let if_block5 = ctx[15] && create_if_block_4(ctx);
  let if_block6 = ctx[18] && create_if_block_3(ctx);
  let if_block7 = ctx[19] && create_if_block_2(ctx);
  let if_block8 = ctx[20] && create_if_block_1(ctx);
  let if_block9 = ctx[17] && create_if_block(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(floatingbutton.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      if_block9_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(floatingbutton, target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, t7, anchor);
      if (if_block7)
        if_block7.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block8)
        if_block8.m(target, anchor);
      insert(target, t9, anchor);
      if (if_block9)
        if_block9.m(target, anchor);
      insert(target, if_block9_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window_1, "keydown", ctx[61]),
          listen(window_1, "pointermove", ctx[35])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a3;
      if (!ctx2[2] && ((_a3 = ctx2[4]) == null ? void 0 : _a3.vsCode) != false && ctx2[30] != false) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1073741844) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const floatingbutton_changes = {};
      if (dirty[0] & 4)
        floatingbutton_changes.isDevserver = ctx2[2];
      if (dirty[0] & 32)
        floatingbutton_changes.isNetlify = ctx2[5];
      if (dirty[0] & 134217728)
        floatingbutton_changes.showTippy = ctx2[27];
      if (dirty[0] & 16)
        floatingbutton_changes.features = ctx2[4];
      if (!updating_showVsCode && dirty[0] & 1073741824) {
        updating_showVsCode = true;
        floatingbutton_changes.showVsCode = ctx2[30];
        add_flush_callback(() => updating_showVsCode = false);
      }
      if (!updating_hidden && dirty[1] & 1) {
        updating_hidden = true;
        floatingbutton_changes.hidden = ctx2[31];
        add_flush_callback(() => updating_hidden = false);
      }
      floatingbutton.$set(floatingbutton_changes);
      if (ctx2[21] || ctx2[22]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 6291456) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[0] && !ctx2[28] && ctx2[29]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 805306369) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[28]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 268435456) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_6(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[16]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 65536) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_5(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t5.parentNode, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[15]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & 32768) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_4(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t6.parentNode, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (ctx2[18]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & 262144) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_3(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(t7.parentNode, t7);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (ctx2[19]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & 524288) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_2(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(t8.parentNode, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (ctx2[20]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty[0] & 1048576) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_1(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(t9.parentNode, t9);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (ctx2[17]) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(if_block9_anchor.parentNode, if_block9_anchor);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(floatingbutton.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(floatingbutton.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(floatingbutton, detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach(t7);
      if (if_block7)
        if_block7.d(detaching);
      if (detaching)
        detach(t8);
      if (if_block8)
        if_block8.d(detaching);
      if (detaching)
        detach(t9);
      if (if_block9)
        if_block9.d(detaching);
      if (detaching)
        detach(if_block9_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = () => {
};
function instance$1($$self, $$props, $$invalidate) {
  var _a2;
  let { win = window } = $$props;
  let { bundlerError = void 0 } = $$props;
  let { introspection = void 0 } = $$props;
  let { isDevserver = true } = $$props;
  let { isInsideTable: isInsideTable2 = void 0 } = $$props;
  let { features = void 0 } = $$props;
  let { isNetlify = false } = $$props;
  let { isInitialized = true } = $$props;
  let { __typename = void 0 } = $$props;
  let displayTranslationSheet;
  let translations = {};
  let displayInsertField;
  let displayChooseEntityResponse;
  let displayChooseEntity;
  let displayWidgetFields;
  let displayChangeGraphqlEndpoint;
  let displayCommitChanges;
  let displayChangeTheme;
  let prevHoverElement;
  let displayCreateTable;
  let displayAddColumn;
  let displayViewERD;
  let hoverElement;
  let editingElement;
  let generatePageButton;
  let wysiwygMode = "inspecting";
  let frameOffset = new DOMRect(0, 0);
  let frameBoundries = new DOMRect();
  let winboxPosX = "center";
  let winboxPosY = "center";
  let showTippy = (_a2 = features == null ? void 0 : features.tippy) != null ? _a2 : true;
  let showCloneDialog = false;
  let showAddColumnDialog = false;
  let showVsCode = true;
  let hidden2 = false;
  let extraPayload = void 0;
  let activeAction = void 0;
  let sortableState = {
    sortable: void 0,
    parentNode: void 0,
    relationName: void 0,
    hasFields: false,
    hasRoutes: false,
    hasColumns: false,
    hasRelations: false,
    lastElement: void 0,
    firstElement: void 0
  };
  const dispatch2 = createEventDispatcher();
  function pointerMoved(event2) {
    const target = event2.target;
    if (!checkIgnore(target)) {
      $$invalidate(21, hoverElement = target);
      $$invalidate(8, frameBoundries = hoverElement.getBoundingClientRect());
    }
  }
  function setExtraPayload(event2) {
    extraPayload = event2.detail;
  }
  function onClone() {
    dispatch2("filterIntrospection");
    if (!isInsideTable2 && __typename === void 0) {
      dispatch2("clone", {
        type: "CLONE_ELEMENT",
        payload: { element: hoverElement }
      });
      hide();
    } else
      $$invalidate(28, showCloneDialog = true);
    cleanUpAction();
  }
  function onAddColumn() {
    dispatch2("filterIntrospection");
    $$invalidate(29, showAddColumnDialog = !showAddColumnDialog);
  }
  function dialogWidgetFields(params) {
    $$invalidate(14, displayWidgetFields = params);
  }
  function dialogChooseEntityFields(params) {
    $$invalidate(13, displayChooseEntity = params);
  }
  function dialogChangeGraphqlEndpoint(params) {
    $$invalidate(15, displayChangeGraphqlEndpoint = params);
  }
  function dialogCommitChanges(params) {
    $$invalidate(16, displayCommitChanges = params);
  }
  function dialogTranslationSheet(params) {
    $$invalidate(9, displayTranslationSheet = params);
    $$invalidate(10, translations = params.translations);
  }
  function dialogThemeEditor(params) {
    $$invalidate(17, displayChangeTheme = params);
  }
  function dialogCreateTable(params) {
    $$invalidate(18, displayCreateTable = params);
  }
  function dialogAddNewColum(params) {
    $$invalidate(19, displayAddColumn = params);
  }
  function dialogViewERD(params) {
    $$invalidate(20, displayViewERD = params);
  }
  function onMouseOver(e) {
    dispatch2("hover", {
      hoverElement,
      inspect: e.detail,
      dialogWidgetFields
    });
  }
  function onModeChange(e) {
    $$invalidate(32, activeAction = void 0);
    if (wysiwygMode === "inspecting") {
      $$invalidate(11, displayInsertField = void 0);
      $$invalidate(14, displayWidgetFields = void 0);
      $$invalidate(22, editingElement = hoverElement);
    }
    $$invalidate(24, wysiwygMode = e.detail.mode);
    dispatch2("modechange", {
      mode: e.detail.mode,
      editingElement,
      dialogWidgetFields,
      hide
    });
    if (wysiwygMode === "editing") {
      dispatch2("editing", {
        mode: e.detail.mode,
        editingElement,
        dialogWidgetFields,
        hide
      });
    }
    if (wysiwygMode === "dragable-editing") {
      dispatch2("dragable-editing", {
        mode: e.detail.mode,
        editingElement,
        dialogWidgetFields,
        hide
      });
    }
  }
  function onShowSource() {
    $$invalidate(31, hidden2 = false);
    dispatch2("showsource", { editingElement });
    hide();
    cleanUpAction();
  }
  function onTranslate() {
    $$invalidate(22, editingElement = hoverElement);
    if (extraPayload.formattedMessageElement) {
      prevHoverElement = hoverElement;
      $$invalidate(22, editingElement = extraPayload.formattedMessageElement);
    }
    dispatch2("translate", { editingElement });
  }
  function onActiveAction(event2) {
    $$invalidate(32, activeAction = event2.detail);
  }
  function onDragAndDropGrid(event2) {
    prevHoverElement = hoverElement;
    $$invalidate(33, sortableState.parentNode = editingElement.parentNode, sortableState);
    const { foundList, hasRoutes } = elementHasList(editingElement.parentNode, 10);
    if (foundList !== void 0) {
      $$invalidate(22, editingElement = foundList);
      $$invalidate(33, sortableState.parentNode = foundList, sortableState);
      $$invalidate(33, sortableState.hasRoutes = hasRoutes, sortableState);
    }
    const { found, parentElement } = dragOnColumnHeader(editingElement.parentNode);
    if (found) {
      $$invalidate(33, sortableState.parentNode = parentElement, sortableState);
      $$invalidate(33, sortableState.hasColumns = true, sortableState);
      $$invalidate(33, sortableState.relationName = getDeepNodeAttribute(editingElement, "data-entity", "span"), sortableState);
      $$invalidate(22, editingElement = parentElement);
    }
    if (sortableState.parentNode === void 0) {
      cleanUpAction();
    }
    $$invalidate(27, showTippy = false);
    let editingElementHasField = void 0;
    const fieldName = hasInputElement(editingElement, 10);
    if (fieldName) {
      editingElementHasField = fieldName;
      $$invalidate(33, sortableState.hasFields = true, sortableState);
    }
    sortableState.parentNode.childNodes.forEach((element2, index2) => {
      if (sortableState.firstElement === void 0 && sortableState.relationName === getDeepNodeAttribute(element2, "data-entity", "span")) {
        $$invalidate(33, sortableState.firstElement = element2, sortableState);
      }
      element2.classList.add("dragable-item");
      element2.dataset.prevIndex = index2;
      if (editingElementHasField) {
        element2.classList.add("dragable-ignore");
      }
      const elementFieldName = hasInputElement(element2, 10);
      if (elementFieldName) {
        $$invalidate(33, sortableState.hasFields = true, sortableState);
        element2.dataset.sortableField = elementFieldName;
        if (!editingElementHasField) {
          element2.classList.add("dragable-ignore");
        } else {
          element2.classList.remove("dragable-ignore");
        }
      } else if (sortableState.hasRoutes) {
        element2.dataset.sortableField = getHref(element2);
      } else if (sortableState.hasColumns) {
        if (getDeepNodeAttribute(element2, "data-entity", "span") !== sortableState.relationName) {
          element2.classList.add("dragable-ignore");
        } else {
          $$invalidate(33, sortableState.lastElement = element2, sortableState);
        }
      }
    });
    $$invalidate(33, sortableState.sortable = new Sortable(sortableState.parentNode, {
      ghostClass: "sortable-ghost",
      animation: 150,
      easing: "cubic-bezier(1, 0, 0, 1)",
      filter: "dragable-ignore"
    }), sortableState);
  }
  function onDragAndDropRelations() {
    $$invalidate(33, sortableState.hasRelations = true, sortableState);
    prevHoverElement = hoverElement;
    $$invalidate(33, sortableState.parentNode = editingElement.parentNode, sortableState);
    const { found, parentElement } = dragOnColumnHeader(editingElement.parentNode);
    if (found) {
      $$invalidate(33, sortableState.parentNode = parentElement, sortableState);
      $$invalidate(33, sortableState.hasRelations = true, sortableState);
      $$invalidate(22, editingElement = parentElement);
    }
    if (sortableState.parentNode === void 0) {
      cleanUpAction();
    }
    $$invalidate(27, showTippy = false);
    const childNodes = Array.from(sortableState.parentNode.childNodes);
    let allPresentRelations = {};
    let prevIndex = 0;
    let unsortableRelationName = void 0;
    childNodes.forEach((node, index2) => {
      const relationName = getDeepNodeAttribute(node, "data-entity", "span");
      if (unsortableRelationName === void 0) {
        unsortableRelationName = relationName;
      }
      if (!(relationName in allPresentRelations))
        prevIndex = index2;
      allPresentRelations[relationName] = { from: prevIndex, to: index2 };
    });
    let wrappers = [];
    Object.keys(allPresentRelations).forEach((key, index2) => {
      let relationWrapperElement = document.createElement("wrapper");
      relationWrapperElement.classList.add(sortableState.parentNode.classList[1]);
      if (key === unsortableRelationName) {
        relationWrapperElement.classList.add("dragable-ignore");
      } else {
        if (sortableState.firstElement === void 0) {
          $$invalidate(33, sortableState.firstElement = relationWrapperElement, sortableState);
        } else {
          $$invalidate(33, sortableState.lastElement = relationWrapperElement, sortableState);
        }
        relationWrapperElement.classList.add("dragable-item");
      }
      relationWrapperElement.dataset.sortableField = key;
      relationWrapperElement.dataset.prevIndex = index2.toString();
      let childNOdesSlice = childNodes.slice(allPresentRelations[key].from, allPresentRelations[key].to + 1);
      while (childNOdesSlice.length) {
        relationWrapperElement.appendChild(childNOdesSlice.shift());
      }
      wrappers.push(relationWrapperElement);
    });
    while (wrappers.length) {
      sortableState.parentNode.appendChild(wrappers.shift());
    }
    $$invalidate(33, sortableState.sortable = new Sortable(sortableState.parentNode, {
      ghostClass: "sortable-ghost",
      animation: 150,
      easing: "cubic-bezier(1, 0, 0, 1)",
      filter: "dragable-ignore"
    }), sortableState);
  }
  function cleanUpAction() {
    if (activeAction === "translate") {
      $$invalidate(22, editingElement = prevHoverElement);
      $$invalidate(24, wysiwygMode = "inspecting");
    }
    if (wysiwygMode === "dragable-editing") {
      if (activeAction === "drag_and_drop_relations") {
        const childNodes = Array.from(sortableState.parentNode.childNodes);
        childNodes.forEach((node) => {
          node.replaceWith(...Array.from(node.children));
        });
      }
      $$invalidate(33, sortableState.hasFields = false, sortableState);
      $$invalidate(33, sortableState.hasRoutes = false, sortableState);
      $$invalidate(33, sortableState.hasColumns = false, sortableState);
      $$invalidate(33, sortableState.relationName = void 0, sortableState);
      $$invalidate(33, sortableState.firstElement = void 0, sortableState);
      $$invalidate(33, sortableState.lastElement = void 0, sortableState);
      sortableState.sortable.destroy();
      sortableState.parentNode.childNodes.forEach((element2) => {
        element2.classList.remove("dragable-item");
        element2.classList.remove("dragable-ignore");
        delete element2.dataset.prevIndex;
        delete element2.dataset.sortableField;
      });
      $$invalidate(33, sortableState.parentNode = void 0, sortableState);
      $$invalidate(27, showTippy = true);
      $$invalidate(24, wysiwygMode = "editing");
      $$invalidate(22, editingElement = prevHoverElement);
    }
    $$invalidate(32, activeAction = void 0);
  }
  function onConfirmAction(event2) {
    const payload = payloadOnEventAction();
    dispatch2("confirmaction", { event: event2, actionType: activeAction, payload });
    $$invalidate(32, activeAction = void 0);
    cleanUpAction();
    hide();
  }
  function payloadOnEventAction() {
    if (activeAction === "drag_and_drop_grid" || activeAction === "drag_and_drop_relations") {
      let payload = {
        elements: [],
        hasFields: sortableState.hasFields,
        hasRoutes: sortableState.hasRoutes,
        hasColumns: sortableState.hasColumns,
        hasRelations: sortableState.hasRelations,
        relationName: sortableState.relationName
      };
      sortableState.parentNode.childNodes.forEach((element2, newIndex2) => {
        if (parseInt(element2.dataset.prevIndex) !== newIndex2) {
          payload.elements.push({
            prevIndex: parseInt(element2.dataset.prevIndex),
            newIndex: newIndex2,
            element: element2,
            fieldName: sortableState.hasColumns ? getDeepNodeAttribute(element2, "data-field", "span") : element2.dataset.sortableField
          });
        }
      });
      onCancelDragAndDropAction();
      return payload;
    }
    return {};
  }
  function onCancelDragAndDropAction() {
    [...sortableState.parentNode.children].sort((a, b) => parseInt(a.dataset.prevIndex) > parseInt(b.dataset.prevIndex) ? 1 : -1).forEach((node) => sortableState.parentNode.appendChild(node));
  }
  function onCancelAction(event2) {
    if (activeAction === "drag_and_drop_grid" || activeAction === "drag_and_drop_relations")
      onCancelDragAndDropAction();
    dispatch2("cancelaction", { event: event2, actionType: activeAction });
    cleanUpAction();
  }
  function onGeneratePage() {
    $$invalidate(22, editingElement = hoverElement);
    $$invalidate(23, generatePageButton = hoverElement);
    dispatch2("generatePage", {
      editingElement,
      dialogChooseEntityFields,
      hide
    });
  }
  function onChangeGraphqlEndpoint() {
    dispatch2("changeGraphqlEndpoint", { dialogChangeGraphqlEndpoint });
  }
  function onShowAllTranslations() {
    dispatch2("listAllTranslations", {
      hoverElement,
      dialogTranslationSheet,
      hide
    });
  }
  function onChangeTheme() {
    dispatch2("changeTheme", { dialogThemeEditor });
  }
  function onDelete() {
    dispatch2("delete", { editingElement });
    hide();
    cleanUpAction();
  }
  function onCreateTable() {
    dispatch2("createTable", { dialogCreateTable });
  }
  function onAddNewColumn() {
    dispatch2("addNewColumn", { dialogAddNewColum });
  }
  function onViewERD() {
    dispatch2("viewERD", { dialogViewERD });
  }
  function onCommitChanges() {
    dispatch2("commitAllChanges", { dialogCommitChanges });
  }
  function onSaveProjectZip() {
    dispatch2("saveProjectZip", {});
  }
  function hide() {
    $$invalidate(22, editingElement = null);
    $$invalidate(23, generatePageButton = null);
    $$invalidate(24, wysiwygMode = "inspecting");
    $$invalidate(11, displayInsertField = null);
    $$invalidate(28, showCloneDialog = false);
  }
  const keydown_handler = (event2) => {
    if (event2.key === "Escape") {
      hide();
    }
  };
  function vscodewindow_hidden_binding(value2) {
    hidden2 = value2;
    $$invalidate(31, hidden2);
  }
  function iframeLoaded_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const close_handler = () => {
    $$invalidate(30, showVsCode = false);
  };
  function floatingbutton_showVsCode_binding(value2) {
    showVsCode = value2;
    $$invalidate(30, showVsCode);
  }
  function floatingbutton_hidden_binding(value2) {
    hidden2 = value2;
    $$invalidate(31, hidden2);
  }
  function loadIntrospection_handler(event2) {
    bubble.call(this, $$self, event2);
  }
  const toggleTippy_handler = () => $$invalidate(27, showTippy = !showTippy);
  const editTranslations_handler = () => onShowAllTranslations();
  function widgetframe_offset_binding(value2) {
    frameOffset = value2;
    $$invalidate(7, frameOffset);
  }
  function widgetframe_boundries_binding(value2) {
    frameBoundries = value2;
    $$invalidate(8, frameBoundries);
  }
  const close_handler_1 = () => {
    $$invalidate(14, displayWidgetFields = void 0);
    if (!displayInsertField)
      $$invalidate(24, wysiwygMode = "inspecting");
  };
  const change_handler = (e) => displayWidgetFields && displayWidgetFields.fieldsChanged && displayWidgetFields.fieldsChanged(e.detail);
  const close_handler_2 = () => {
    $$invalidate(13, displayChooseEntity = void 0);
    $$invalidate(23, generatePageButton = void 0);
    $$invalidate(24, wysiwygMode = "inspecting");
    $$invalidate(0, introspection = null);
  };
  const select_handler = (e) => {
    displayChooseEntity && displayChooseEntity.fieldSelected && displayChooseEntity.fieldSelected(e.detail);
    $$invalidate(0, introspection = null);
  };
  const ok_handler = (e) => {
    $$invalidate(13, displayChooseEntity = void 0);
    $$invalidate(23, generatePageButton = void 0);
    $$invalidate(24, wysiwygMode = "inspecting");
    $$invalidate(12, displayChooseEntityResponse = e.detail);
    $$invalidate(0, introspection = null);
  };
  const create_handler = () => {
    onCreateTable();
  };
  function loadIntrospection_handler_1(event2) {
    bubble.call(this, $$self, event2);
  }
  const close_handler_3 = () => {
    $$invalidate(9, displayTranslationSheet = void 0);
    $$invalidate(24, wysiwygMode = "inspecting");
  };
  const change_handler_1 = (e) => {
    $$invalidate(10, translations = e.detail.translations);
  };
  const ok_handler_1 = (e) => {
    displayTranslationSheet.ok(translations, e.detail);
    $$invalidate(9, displayTranslationSheet = void 0);
  };
  const close_handler_4 = () => {
    $$invalidate(11, displayInsertField = void 0);
    if (!displayWidgetFields)
      $$invalidate(24, wysiwygMode = "inspecting");
    $$invalidate(29, showAddColumnDialog = false);
    $$invalidate(0, introspection = null);
  };
  const select_handler_1 = (e) => {
    dispatch2("clone", {
      type: "CLONE_COLUMN",
      payload: {
        fields: e.detail.selectedFields,
        insertType: e.detail.insertType
      }
    });
    $$invalidate(29, showAddColumnDialog = false);
    $$invalidate(0, introspection = null);
  };
  const addColumn_handler = (e) => {
    onAddNewColumn();
  };
  function loadIntrospection_handler_2(event2) {
    bubble.call(this, $$self, event2);
  }
  const close_handler_5 = () => {
    $$invalidate(28, showCloneDialog = false);
    $$invalidate(0, introspection = null);
  };
  const ok_handler_2 = (e) => {
    e.detail.fields ? !e.detail.__typename ? dispatch2("clone", {
      type: "CLONE_COLUMN",
      payload: {
        fields: e.detail.fields,
        element: hoverElement,
        insertType: e.detail.beforeAfter
      }
    }) : dispatch2("clone", {
      type: "CLONE_AND_RENAME_ELEMENT",
      payload: {
        fields: e.detail.fields,
        __typename: e.detail.__typename,
        element: hoverElement,
        insertType: e.detail.beforeAfter
      }
    }) : dispatch2("clone", {
      type: "CLONE_ELEMENT",
      payload: { element: hoverElement }
    });
    $$invalidate(24, wysiwygMode = "inspecting");
    $$invalidate(28, showCloneDialog = false);
    $$invalidate(0, introspection = null);
  };
  const close_handler_6 = () => {
    $$invalidate(16, displayCommitChanges = void 0);
  };
  const save_handler = (e) => {
    dispatch2("commitAllChanges", { payload: e.detail.commitMessage });
  };
  const login_handler = (e) => {
    dispatch2("loginGithub", { payload: e.detail.login });
  };
  const close_handler_7 = () => {
    $$invalidate(15, displayChangeGraphqlEndpoint = void 0);
  };
  const save_handler_1 = (e) => {
    dispatch2("changeGraphqlEndpoint", {
      payload: e.detail.newEndpoint,
      extraPayload: e.detail.newSecret
    });
  };
  const create_handler_1 = () => {
    onCreateTable();
  };
  const addColumn_handler_1 = () => {
    onAddNewColumn();
  };
  function loadIntrospection_handler_3(event2) {
    bubble.call(this, $$self, event2);
  }
  const close_handler_8 = () => {
    $$invalidate(18, displayCreateTable = void 0);
  };
  const createTable_handler = (e) => {
    dispatch2("createTable", { payload: e.detail.name });
  };
  const close_handler_9 = () => {
    $$invalidate(19, displayAddColumn = void 0);
  };
  const addNewColumn_handler = (e) => {
    dispatch2("addNewColumn", { payload: e.detail });
  };
  const close_handler_10 = () => {
    $$invalidate(20, displayViewERD = void 0);
  };
  const close_handler_11 = () => {
    $$invalidate(17, displayChangeTheme = void 0);
  };
  const save_handler_2 = (e) => {
    displayChangeTheme.save(e.detail.theme);
  };
  $$self.$$set = ($$props2) => {
    if ("win" in $$props2)
      $$invalidate(59, win = $$props2.win);
    if ("bundlerError" in $$props2)
      $$invalidate(1, bundlerError = $$props2.bundlerError);
    if ("introspection" in $$props2)
      $$invalidate(0, introspection = $$props2.introspection);
    if ("isDevserver" in $$props2)
      $$invalidate(2, isDevserver = $$props2.isDevserver);
    if ("isInsideTable" in $$props2)
      $$invalidate(3, isInsideTable2 = $$props2.isInsideTable);
    if ("features" in $$props2)
      $$invalidate(4, features = $$props2.features);
    if ("isNetlify" in $$props2)
      $$invalidate(5, isNetlify = $$props2.isNetlify);
    if ("isInitialized" in $$props2)
      $$invalidate(60, isInitialized = $$props2.isInitialized);
    if ("__typename" in $$props2)
      $$invalidate(6, __typename = $$props2.__typename);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 384) {
      if (frameBoundries) {
        let top = frameOffset.top + frameBoundries.top;
        let left = frameOffset.left + frameBoundries.left;
        $$invalidate(25, winboxPosX = left < (window.innerWidth - frameBoundries.width) / 2 ? "right" : "left");
        $$invalidate(26, winboxPosY = top < (window.innerHeight - frameBoundries.height) / 2 ? "bottom" : "top");
      }
    }
  };
  return [
    introspection,
    bundlerError,
    isDevserver,
    isInsideTable2,
    features,
    isNetlify,
    __typename,
    frameOffset,
    frameBoundries,
    displayTranslationSheet,
    translations,
    displayInsertField,
    displayChooseEntityResponse,
    displayChooseEntity,
    displayWidgetFields,
    displayChangeGraphqlEndpoint,
    displayCommitChanges,
    displayChangeTheme,
    displayCreateTable,
    displayAddColumn,
    displayViewERD,
    hoverElement,
    editingElement,
    generatePageButton,
    wysiwygMode,
    winboxPosX,
    winboxPosY,
    showTippy,
    showCloneDialog,
    showAddColumnDialog,
    showVsCode,
    hidden2,
    activeAction,
    sortableState,
    dispatch2,
    pointerMoved,
    setExtraPayload,
    onClone,
    onAddColumn,
    onMouseOver,
    onModeChange,
    onShowSource,
    onTranslate,
    onActiveAction,
    onDragAndDropGrid,
    onDragAndDropRelations,
    onConfirmAction,
    onCancelAction,
    onGeneratePage,
    onChangeGraphqlEndpoint,
    onShowAllTranslations,
    onChangeTheme,
    onDelete,
    onCreateTable,
    onAddNewColumn,
    onViewERD,
    onCommitChanges,
    onSaveProjectZip,
    hide,
    win,
    isInitialized,
    keydown_handler,
    vscodewindow_hidden_binding,
    iframeLoaded_handler,
    close_handler,
    floatingbutton_showVsCode_binding,
    floatingbutton_hidden_binding,
    loadIntrospection_handler,
    toggleTippy_handler,
    editTranslations_handler,
    widgetframe_offset_binding,
    widgetframe_boundries_binding,
    close_handler_1,
    change_handler,
    close_handler_2,
    select_handler,
    ok_handler,
    create_handler,
    loadIntrospection_handler_1,
    close_handler_3,
    change_handler_1,
    ok_handler_1,
    close_handler_4,
    select_handler_1,
    addColumn_handler,
    loadIntrospection_handler_2,
    close_handler_5,
    ok_handler_2,
    close_handler_6,
    save_handler,
    login_handler,
    close_handler_7,
    save_handler_1,
    create_handler_1,
    addColumn_handler_1,
    loadIntrospection_handler_3,
    close_handler_8,
    createTable_handler,
    close_handler_9,
    addNewColumn_handler,
    close_handler_10,
    close_handler_11,
    save_handler_2
  ];
}
class Wysiwyg extends SvelteComponent {
  constructor(options2) {
    super();
    init$1(this, options2, instance$1, create_fragment$1, safe_not_equal, {
      win: 59,
      bundlerError: 1,
      introspection: 0,
      isDevserver: 2,
      isInsideTable: 3,
      features: 4,
      isNetlify: 5,
      isInitialized: 60,
      __typename: 6
    }, add_css, [-1, -1, -1, -1]);
  }
}
class WysiwygHTMLElement$1 extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "contentWindow", window);
    __publicField(this, "component");
    __publicField(this, "error", null);
    __publicField(this, "intro", null);
    __publicField(this, "featureFlags", null);
    __publicField(this, "insideTable");
    __publicField(this, "typename");
    __publicField(this, "devserver");
    __publicField(this, "initialized", false);
    __publicField(this, "netlify");
  }
  set win(win) {
    this.contentWindow = win;
  }
  get win() {
    return this.contentWindow;
  }
  set bundlerError(bundlerError) {
    this.error = bundlerError;
    this.component.$set({ win: this.contentWindow, bundlerError });
  }
  get bundlerError() {
    return this.error;
  }
  set introspection(introspection) {
    this.intro = introspection;
    this.component.$set({ introspection });
  }
  get introspection() {
    return this.intro;
  }
  set features(featureFlags) {
    this.featureFlags = featureFlags;
  }
  get features() {
    return this.featureFlags;
  }
  set isInsideTable(isInsideTable2) {
    this.insideTable = isInsideTable2;
    this.component.$set({ isInsideTable: isInsideTable2 });
  }
  get isInsideTable() {
    return this.insideTable;
  }
  set __typename(__typename) {
    this.typename = __typename;
    this.component.$set({ __typename });
  }
  get __typename() {
    return this.typename;
  }
  set isDevserver(isDevserver) {
    var _a2;
    this.devserver = isDevserver;
    (_a2 = this.component) == null ? void 0 : _a2.$set({ isDevserver });
  }
  get isDevserver() {
    return this.devserver;
  }
  set isNetlify(isNetlify) {
    var _a2;
    this.netlify = isNetlify;
    (_a2 = this.component) == null ? void 0 : _a2.$set({ isNetlify });
  }
  get isNetlify() {
    return this.netlify;
  }
  get isInitialized() {
    return this.initialized;
  }
  set isInitialized(isInitialized) {
    var _a2;
    this.initialized = isInitialized;
    (_a2 = this.component) == null ? void 0 : _a2.$set({ isInitialized });
  }
  connectedCallback() {
    this.style.width = "100%";
    this.style.height = "100%";
    this.component = new Wysiwyg({
      target: this,
      props: {
        win: this.contentWindow,
        bundlerError: this.error,
        features: this.featureFlags,
        initialized: this.initialized
      }
    });
    this.component.$on("iframeLoaded", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("iframeLoaded", { detail: data }));
    });
    this.component.$on("hover", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("hover", { detail: data }));
    });
    this.component.$on("showsource", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("showsource", { detail: data }));
    });
    this.component.$on("clone", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("clone", { detail: data }));
    });
    this.component.$on("delete", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("delete", { detail: data }));
    });
    this.component.$on("translate", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("translate", { detail: data }));
    });
    this.component.$on("confirmaction", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("confirmaction", { detail: data }));
    });
    this.component.$on("cancelaction", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("cancelaction", { detail: data }));
    });
    this.component.$on("modechange", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("modechange", { detail: data }));
    });
    this.component.$on("editing", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("editing", { detail: data }));
    });
    this.component.$on("generatePage", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("generatePage", { detail: data }));
    });
    this.component.$on("listAllTranslations", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("listAllTranslations", { detail: data }));
    });
    this.component.$on("loadIntrospection", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("loadIntrospection", { detail: data }));
    });
    this.component.$on("filterIntrospection", (event2) => {
      this.dispatchEvent(new CustomEvent("filterIntrospection"));
    });
    this.component.$on("changeGraphqlEndpoint", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("changeGraphqlEndpoint", { detail: data }));
    });
    this.component.$on("changeTheme", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("changeTheme", { detail: data }));
    });
    this.component.$on("createTable", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("createTable", { detail: data }));
    });
    this.component.$on("addNewColumn", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("addNewColumn", { detail: data }));
    });
    this.component.$on("viewERD", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("viewERD", { detail: data }));
    });
    this.component.$on("commitAllChanges", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("commitAllChanges", { detail: data }));
    });
    this.component.$on("saveProjectZip", (event2) => {
      this.dispatchEvent(new CustomEvent("saveProjectZip"));
    });
  }
  disconnectedCallback() {
    this.component.$destroy();
  }
}
const initializeWysiwyg = () => {
  try {
    customElements.define("iteria-wysiwyg", WysiwygHTMLElement$1);
  } catch (e) {
    console.error("define iteria-wysiwyg", e);
  }
};
class WysiwygHTMLElement extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "contentWindow", window);
    __publicField(this, "component");
    __publicField(this, "error", null);
  }
  set win(win) {
    this.contentWindow = win;
  }
  get win() {
    return this.contentWindow;
  }
  set bundlerError(bundlerError) {
    this.error = bundlerError;
    this.component.$set({ win: this.contentWindow, bundlerError });
  }
  get bundlerError() {
    return this.error;
  }
  connectedCallback() {
    this.style.width = "100%";
    this.style.height = "100%";
    this.component = new Wysiwyg({
      target: this,
      props: {
        win: this.contentWindow,
        bundlerError: this.error
      }
    });
    this.component.$on("iframeLoaded", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("iframeLoaded", { detail: data }));
    });
    this.component.$on("hover", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("hover", { detail: data }));
    });
    this.component.$on("showsource", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("showsource", { detail: data }));
    });
    this.component.$on("clone", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("clone", { detail: data }));
    });
    this.component.$on("delete", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("delete", { detail: data }));
    });
    this.component.$on("translate", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("translate", { detail: data }));
    });
    this.component.$on("confirmaction", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("confirmaction", { detail: data }));
    });
    this.component.$on("cancelaction", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("cancelaction", { detail: data }));
    });
    this.component.$on("modechange", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("modechange", { detail: data }));
    });
    this.component.$on("editing", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("editing", { detail: data }));
    });
    this.component.$on("loadIntrospection", (event2) => {
      const data = event2.detail;
      this.dispatchEvent(new CustomEvent("loadIntrospection", { detail: data }));
    });
  }
  disconnectedCallback() {
    this.component.$destroy();
  }
}
try {
  customElements.define("iteria-wysiwyg-shadow", WysiwygHTMLElement);
} catch (e) {
  console.error("define iteria-wysiwyg-shadow", e);
}
var toastify = { exports: {} };
/*!
 * Toastify js 1.11.2
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */
(function(module2) {
  (function(root2, factory2) {
    if (module2.exports) {
      module2.exports = factory2();
    } else {
      root2.Toastify = factory2();
    }
  })(commonjsGlobal$1, function(global2) {
    var Toastify2 = function(options2) {
      return new Toastify2.lib.init(options2);
    }, version2 = "1.11.2";
    Toastify2.defaults = {
      oldestFirst: true,
      text: "Toastify is awesome!",
      node: void 0,
      duration: 3e3,
      selector: void 0,
      callback: function() {
      },
      destination: void 0,
      newWindow: false,
      close: false,
      gravity: "toastify-top",
      positionLeft: false,
      position: "",
      backgroundColor: "",
      avatar: "",
      className: "",
      stopOnFocus: true,
      onClick: function() {
      },
      offset: { x: 0, y: 0 },
      escapeMarkup: true,
      style: { background: "" }
    };
    Toastify2.lib = Toastify2.prototype = {
      toastify: version2,
      constructor: Toastify2,
      init: function(options2) {
        if (!options2) {
          options2 = {};
        }
        this.options = {};
        this.toastElement = null;
        this.options.text = options2.text || Toastify2.defaults.text;
        this.options.node = options2.node || Toastify2.defaults.node;
        this.options.duration = options2.duration === 0 ? 0 : options2.duration || Toastify2.defaults.duration;
        this.options.selector = options2.selector || Toastify2.defaults.selector;
        this.options.callback = options2.callback || Toastify2.defaults.callback;
        this.options.destination = options2.destination || Toastify2.defaults.destination;
        this.options.newWindow = options2.newWindow || Toastify2.defaults.newWindow;
        this.options.close = options2.close || Toastify2.defaults.close;
        this.options.gravity = options2.gravity === "bottom" ? "toastify-bottom" : Toastify2.defaults.gravity;
        this.options.positionLeft = options2.positionLeft || Toastify2.defaults.positionLeft;
        this.options.position = options2.position || Toastify2.defaults.position;
        this.options.backgroundColor = options2.backgroundColor || Toastify2.defaults.backgroundColor;
        this.options.avatar = options2.avatar || Toastify2.defaults.avatar;
        this.options.className = options2.className || Toastify2.defaults.className;
        this.options.stopOnFocus = options2.stopOnFocus === void 0 ? Toastify2.defaults.stopOnFocus : options2.stopOnFocus;
        this.options.onClick = options2.onClick || Toastify2.defaults.onClick;
        this.options.offset = options2.offset || Toastify2.defaults.offset;
        this.options.escapeMarkup = options2.escapeMarkup !== void 0 ? options2.escapeMarkup : Toastify2.defaults.escapeMarkup;
        this.options.style = options2.style || Toastify2.defaults.style;
        if (options2.backgroundColor) {
          this.options.style.background = options2.backgroundColor;
        }
        return this;
      },
      buildToast: function() {
        if (!this.options) {
          throw "Toastify is not initialized";
        }
        var divElement = document.createElement("div");
        divElement.className = "toastify on " + this.options.className;
        if (!!this.options.position) {
          divElement.className += " toastify-" + this.options.position;
        } else {
          if (this.options.positionLeft === true) {
            divElement.className += " toastify-left";
            console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.");
          } else {
            divElement.className += " toastify-right";
          }
        }
        divElement.className += " " + this.options.gravity;
        if (this.options.backgroundColor) {
          console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
        }
        for (var property2 in this.options.style) {
          divElement.style[property2] = this.options.style[property2];
        }
        if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
          divElement.appendChild(this.options.node);
        } else {
          if (this.options.escapeMarkup) {
            divElement.innerText = this.options.text;
          } else {
            divElement.innerHTML = this.options.text;
          }
          if (this.options.avatar !== "") {
            var avatarElement = document.createElement("img");
            avatarElement.src = this.options.avatar;
            avatarElement.className = "toastify-avatar";
            if (this.options.position == "left" || this.options.positionLeft === true) {
              divElement.appendChild(avatarElement);
            } else {
              divElement.insertAdjacentElement("afterbegin", avatarElement);
            }
          }
        }
        if (this.options.close === true) {
          var closeElement = document.createElement("span");
          closeElement.innerHTML = "&#10006;";
          closeElement.className = "toast-close";
          closeElement.addEventListener("click", function(event2) {
            event2.stopPropagation();
            this.removeElement(this.toastElement);
            window.clearTimeout(this.toastElement.timeOutValue);
          }.bind(this));
          var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
            divElement.insertAdjacentElement("afterbegin", closeElement);
          } else {
            divElement.appendChild(closeElement);
          }
        }
        if (this.options.stopOnFocus && this.options.duration > 0) {
          var self2 = this;
          divElement.addEventListener("mouseover", function(event2) {
            window.clearTimeout(divElement.timeOutValue);
          });
          divElement.addEventListener("mouseleave", function() {
            divElement.timeOutValue = window.setTimeout(function() {
              self2.removeElement(divElement);
            }, self2.options.duration);
          });
        }
        if (typeof this.options.destination !== "undefined") {
          divElement.addEventListener("click", function(event2) {
            event2.stopPropagation();
            if (this.options.newWindow === true) {
              window.open(this.options.destination, "_blank");
            } else {
              window.location = this.options.destination;
            }
          }.bind(this));
        }
        if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
          divElement.addEventListener("click", function(event2) {
            event2.stopPropagation();
            this.options.onClick();
          }.bind(this));
        }
        if (typeof this.options.offset === "object") {
          var x2 = getAxisOffsetAValue("x", this.options);
          var y2 = getAxisOffsetAValue("y", this.options);
          var xOffset = this.options.position == "left" ? x2 : "-" + x2;
          var yOffset = this.options.gravity == "toastify-top" ? y2 : "-" + y2;
          divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";
        }
        return divElement;
      },
      showToast: function() {
        this.toastElement = this.buildToast();
        var rootElement;
        if (typeof this.options.selector === "string") {
          rootElement = document.getElementById(this.options.selector);
        } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== "undefined" && this.options.selector instanceof ShadowRoot) {
          rootElement = this.options.selector;
        } else {
          rootElement = document.body;
        }
        if (!rootElement) {
          throw "Root element is not defined";
        }
        var elementToInsert = Toastify2.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
        rootElement.insertBefore(this.toastElement, elementToInsert);
        Toastify2.reposition();
        if (this.options.duration > 0) {
          this.toastElement.timeOutValue = window.setTimeout(function() {
            this.removeElement(this.toastElement);
          }.bind(this), this.options.duration);
        }
        return this;
      },
      hideToast: function() {
        if (this.toastElement.timeOutValue) {
          clearTimeout(this.toastElement.timeOutValue);
        }
        this.removeElement(this.toastElement);
      },
      removeElement: function(toastElement) {
        toastElement.className = toastElement.className.replace(" on", "");
        window.setTimeout(function() {
          if (this.options.node && this.options.node.parentNode) {
            this.options.node.parentNode.removeChild(this.options.node);
          }
          if (toastElement.parentNode) {
            toastElement.parentNode.removeChild(toastElement);
          }
          this.options.callback.call(toastElement);
          Toastify2.reposition();
        }.bind(this), 400);
      }
    };
    Toastify2.reposition = function() {
      var topLeftOffsetSize = {
        top: 15,
        bottom: 15
      };
      var topRightOffsetSize = {
        top: 15,
        bottom: 15
      };
      var offsetSize = {
        top: 15,
        bottom: 15
      };
      var allToasts = document.getElementsByClassName("toastify");
      var classUsed;
      for (var i2 = 0; i2 < allToasts.length; i2++) {
        if (containsClass(allToasts[i2], "toastify-top") === true) {
          classUsed = "toastify-top";
        } else {
          classUsed = "toastify-bottom";
        }
        var height = allToasts[i2].offsetHeight;
        classUsed = classUsed.substr(9, classUsed.length - 1);
        var offset = 15;
        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (width <= 360) {
          allToasts[i2].style[classUsed] = offsetSize[classUsed] + "px";
          offsetSize[classUsed] += height + offset;
        } else {
          if (containsClass(allToasts[i2], "toastify-left") === true) {
            allToasts[i2].style[classUsed] = topLeftOffsetSize[classUsed] + "px";
            topLeftOffsetSize[classUsed] += height + offset;
          } else {
            allToasts[i2].style[classUsed] = topRightOffsetSize[classUsed] + "px";
            topRightOffsetSize[classUsed] += height + offset;
          }
        }
      }
      return this;
    };
    function getAxisOffsetAValue(axis, options2) {
      if (options2.offset[axis]) {
        if (isNaN(options2.offset[axis])) {
          return options2.offset[axis];
        } else {
          return options2.offset[axis] + "px";
        }
      }
      return "0px";
    }
    function containsClass(elem, yourClass) {
      if (!elem || typeof yourClass !== "string") {
        return false;
      } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
        return true;
      } else {
        return false;
      }
    }
    Toastify2.lib.init.prototype = Toastify2.lib;
    return Toastify2;
  });
})(toastify);
var Toastify = toastify.exports;
const colors = {
  "error": "rgb(229, 57, 53)",
  "success": "rgb(45, 196, 51)",
  "info": "rgb(57, 73, 171)",
  "warn": "rgb(255, 192, 0)",
  "load": "#7819A2"
};
const icons = {
  "error": "https://img.icons8.com/color/20/undefined/cancel--v1.png",
  "success": "https://img.icons8.com/color/20/undefined/ok--v1.png",
  "info": "https://img.icons8.com/color/20/undefined/info--v1.png",
  "warn": "https://img.icons8.com/color/20/undefined/error--v1.png",
  "load": "https://img.icons8.com/fluency/20/undefined/spinner-frame-5.png"
};
const toast = (options2) => {
  var _a2, _b, _c;
  Toastify({
    text: options2.message,
    className: `iteria-snackbar ${options2.type}`,
    duration: options2.type === "load" ? 1500 : 5e3,
    avatar: icons[options2.type],
    style: {
      transition: "0.3s",
      display: "flex",
      alignItems: "center",
      background: "rgba(36, 36, 36, 0.75)",
      padding: "15px 25px",
      color: "#FFF",
      fontSize: "0.9rem",
      maxWidth: "35vh",
      zIndex: 2500,
      position: "fixed",
      top: "80px",
      right: "30px",
      borderRadius: "4px",
      borderLeft: `3px solid ${colors[options2.type]}`,
      boxShadow: "0 4px 12px rgb(0 0 0 / 15%)"
    }
  }).showToast();
  (_c = (_b = (_a2 = document.getElementsByClassName("toastify")) == null ? void 0 : _a2[0]) == null ? void 0 : _b.classList) == null ? void 0 : _c.add("iteria-ignore");
};
const showErrorSnackbar = (message) => {
  toast({
    type: "error",
    message
  });
};
const showSuccessSnackbar = (message) => {
  toast({
    type: "success",
    message
  });
};
const showInfoSnackbar = (message) => {
  toast({
    type: "info",
    message
  });
};
const showWarningSnackbar = (message) => {
  toast({
    type: "warn",
    message
  });
};
const showLoadingSnackbar = (message) => {
  toast({
    type: "load",
    message
  });
};
const CLONE_ELEMENT = "CLONE_ELEMENT";
const CLONE_AND_RENAME_ELEMENT = "CLONE_AND_RENAME_ELEMENT";
const TRANSLATE_ELEMENT = "TRANSLATE_ELEMENT";
const NAVIGATE_TO_SOURCE_CODE = "NAVIGATE_TO_SOURCE_CODE";
const REMOVE_ELEMENT = "REMOVE_ELEMENT";
const GENERATE_PAGE = "GENERATE_PAGE";
const CHANGE_GRAPHQL_ENDPOINT = "CHANGE_GRAPHQL_ENDPOINT";
const REORDER_ELEMENT = "REORDER_ELEMENT";
const CHANGE_THEME = "CHANGE_THEME";
const FILE_WRITE = "FILE_WRITE";
const MULTIPLE_FILE_WRITE = "MULTIPLE_FILE_WRITE";
const MULTIPLE_FILE_DELETE = "MULTIPLE_FILE_DELETE";
const FRONTEND_FILE_WRITE = "FRONTEND_FILE_WRITE";
const GET_PROJECT_FROM_ARCHIVE = "GET_PROJECT_FROM_ARCHIVE";
const PROJECT_LOADED = "PROJECT_LOADED";
const BUNDLE_FILES = "BUNDLE_FILES";
const TRANSPILE_FILES = "TRANSPILE_FILES";
const TRANSPILE_SINGLE_FILE = "TRANSPILE_SINGLE_FILE";
const TRANSPILE_MULTIPLE_FILES = "TRANSPILE_MULTIPLE_FILES";
const UPDATE_TRANSPILED_FILES = "UPDATE_TRANSPILED_FILES";
const REFRESH_IFRAME = "REFRESH_IFRAME";
const PERFORM_REACT_REFRESH = "PERFORM_REACT_REFRESH";
const CONNECT_ELEMENT_HIGHLIGHT = "CONNECT_ELEMENT_HIGHLIGHT";
const GENERATE_GRAPHQL = "GENERATE_GRAPHQL";
const SAVE_ZIP = "SAVE_ZIP";
const SHOW_USER_FEEDBACK = "SHOW_USER_FEEDBACK";
const LOWCODE_INITIALIZED = "LOWCODE_INITIALIZED";
const BUNDLER_ERROR = "BUNDLER_ERROR";
const TRANSPILER_ERROR = "TRANSPILER_ERROR";
const COMMIT_ALL_CHANGES = "COMMIT_ALL_CHANGES";
const COMMIT_CHANGES = "COMMIT_CHANGES";
const LOGIN_GITHUB = "LOGIN_GITHUB";
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const throwMarker = Symbol("Comlink.thrown");
const isObject$e = (val) => typeof val === "object" && val !== null || typeof val === "function";
const proxyTransferHandler = {
  canHandle: (val) => isObject$e(val) && val[proxyMarker],
  serialize(obj2) {
    const { port1, port2 } = new MessageChannel();
    expose(obj2, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap$3(port);
  }
};
const throwTransferHandler = {
  canHandle: (value2) => isObject$e(value2) && throwMarker in value2,
  serialize({ value: value2 }) {
    let serialized;
    if (value2 instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value2.message,
          name: value2.name,
          stack: value2.stack
        }
      };
    } else {
      serialized = { isError: false, value: value2 };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
const transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function expose(obj2, ep = self) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    const { id, type: type2, path: path2 } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue2;
    try {
      const parent = path2.slice(0, -1).reduce((obj3, prop) => obj3[prop], obj2);
      const rawValue = path2.reduce((obj3, prop) => obj3[prop], obj2);
      switch (type2) {
        case "GET":
          {
            returnValue2 = rawValue;
          }
          break;
        case "SET":
          {
            parent[path2.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue2 = true;
          }
          break;
        case "APPLY":
          {
            returnValue2 = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value2 = new rawValue(...argumentList);
            returnValue2 = proxy(value2);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj2, port2);
            returnValue2 = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue2 = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value2) {
      returnValue2 = { value: value2, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue2).catch((value2) => {
      return { value: value2, [throwMarker]: 0 };
    }).then((returnValue3) => {
      const [wireValue, transferables] = toWireValue(returnValue3);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type2 === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
      }
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap$3(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function createProxy(ep, path2 = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          return requestResponseMessage(ep, {
            type: "RELEASE",
            path: path2.map((p2) => p2.toString())
          }).then(() => {
            closeEndPoint(ep);
            isProxyReleased = true;
          });
        };
      }
      if (prop === "then") {
        if (path2.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, {
          type: "GET",
          path: path2.map((p2) => p2.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, [...path2, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value2, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, {
        type: "SET",
        path: [...path2, prop].map((p2) => p2.toString()),
        value: value2
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path2[path2.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path2.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "APPLY",
        path: path2.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "CONSTRUCT",
        path: path2.map((p2) => p2.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj2, transfers) {
  transferCache.set(obj2, transfers);
  return obj2;
}
function proxy(obj2) {
  return Object.assign(obj2, { [proxyMarker]: true });
}
function toWireValue(value2) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value2)) {
      const [serializedValue, transferables] = handler.serialize(value2);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value: value2
    },
    transferCache.get(value2) || []
  ];
}
function fromWireValue(value2) {
  switch (value2.type) {
    case "HANDLER":
      return transferHandlers.get(value2.name).deserialize(value2.value);
    case "RAW":
      return value2.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve5) => {
    const id = generateUUID();
    ep.addEventListener("message", function l2(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l2);
      resolve5(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}
const encodedJs$2 = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBfcj1PYmplY3QuZGVmaW5lUHJvcGVydHksRXI9T2JqZWN0LmRlZmluZVByb3BlcnRpZXMsQXI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsZnQ9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyx4cj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFJyPU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsZHQ9KG5lLG9lLGllKT0+b2UgaW4gbmU/X3IobmUsb2Use2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmllfSk6bmVbb2VdPWllLHRlPShuZSxvZSk9Pntmb3IodmFyIGllIGluIG9lfHwob2U9e30pKXhyLmNhbGwob2UsaWUpJiZkdChuZSxpZSxvZVtpZV0pO2lmKGZ0KWZvcih2YXIgaWUgb2YgZnQob2UpKVJyLmNhbGwob2UsaWUpJiZkdChuZSxpZSxvZVtpZV0pO3JldHVybiBuZX0sdWU9KG5lLG9lKT0+RXIobmUsQXIob2UpKTsoZnVuY3Rpb24obmUpe3R5cGVvZiBkZWZpbmU9PSJmdW5jdGlvbiImJmRlZmluZS5hbWQ/ZGVmaW5lKFsiaHR0cHM6Ly9lc20uc2gvdHlwZXNjcmlwdCJdLG5lKTpuZSgpfSkoZnVuY3Rpb24oKXtjb25zdCBuZT1TeW1ib2woIkNvbWxpbmsucHJveHkiKSxvZT1TeW1ib2woIkNvbWxpbmsuZW5kcG9pbnQiKSxpZT1TeW1ib2woIkNvbWxpbmsucmVsZWFzZVByb3h5IiksVWU9U3ltYm9sKCJDb21saW5rLnRocm93biIpLGd0PWU9PnR5cGVvZiBlPT0ib2JqZWN0IiYmZSE9PW51bGx8fHR5cGVvZiBlPT0iZnVuY3Rpb24iLHdyPXtjYW5IYW5kbGU6ZT0+Z3QoZSkmJmVbbmVdLHNlcmlhbGl6ZShlKXtjb25zdHtwb3J0MTpyLHBvcnQyOm59PW5ldyBNZXNzYWdlQ2hhbm5lbDtyZXR1cm4gRmUoZSxyKSxbbixbbl1dfSxkZXNlcmlhbGl6ZShlKXtyZXR1cm4gZS5zdGFydCgpLGtyKGUpfX0sU3I9e2NhbkhhbmRsZTplPT5ndChlKSYmVWUgaW4gZSxzZXJpYWxpemUoe3ZhbHVlOmV9KXtsZXQgcjtyZXR1cm4gZSBpbnN0YW5jZW9mIEVycm9yP3I9e2lzRXJyb3I6ITAsdmFsdWU6e21lc3NhZ2U6ZS5tZXNzYWdlLG5hbWU6ZS5uYW1lLHN0YWNrOmUuc3RhY2t9fTpyPXtpc0Vycm9yOiExLHZhbHVlOmV9LFtyLFtdXX0sZGVzZXJpYWxpemUoZSl7dGhyb3cgZS5pc0Vycm9yP09iamVjdC5hc3NpZ24obmV3IEVycm9yKGUudmFsdWUubWVzc2FnZSksZS52YWx1ZSk6ZS52YWx1ZX19LG10PW5ldyBNYXAoW1sicHJveHkiLHdyXSxbInRocm93IixTcl1dKTtmdW5jdGlvbiBGZShlLHI9c2VsZil7ci5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmdW5jdGlvbiBuKGkpe2lmKCFpfHwhaS5kYXRhKXJldHVybjtjb25zdHtpZDp1LHR5cGU6cCxwYXRoOm99PU9iamVjdC5hc3NpZ24oe3BhdGg6W119LGkuZGF0YSksZD0oaS5kYXRhLmFyZ3VtZW50TGlzdHx8W10pLm1hcChkZSk7bGV0IGY7dHJ5e2NvbnN0IF89by5zbGljZSgwLC0xKS5yZWR1Y2UoKFMsdik9PlNbdl0sZSksbT1vLnJlZHVjZSgoUyx2KT0+U1t2XSxlKTtzd2l0Y2gocCl7Y2FzZSJHRVQiOmY9bTticmVhaztjYXNlIlNFVCI6X1tvLnNsaWNlKC0xKVswXV09ZGUoaS5kYXRhLnZhbHVlKSxmPSEwO2JyZWFrO2Nhc2UiQVBQTFkiOmY9bS5hcHBseShfLGQpO2JyZWFrO2Nhc2UiQ09OU1RSVUNUIjp7Y29uc3QgUz1uZXcgbSguLi5kKTtmPUhyKFMpfWJyZWFrO2Nhc2UiRU5EUE9JTlQiOntjb25zdHtwb3J0MTpTLHBvcnQyOnZ9PW5ldyBNZXNzYWdlQ2hhbm5lbDtGZShlLHYpLGY9T3IoUyxbU10pfWJyZWFrO2Nhc2UiUkVMRUFTRSI6Zj12b2lkIDA7YnJlYWs7ZGVmYXVsdDpyZXR1cm59fWNhdGNoKF8pe2Y9e3ZhbHVlOl8sW1VlXTowfX1Qcm9taXNlLnJlc29sdmUoZikuY2F0Y2goXz0+KHt2YWx1ZTpfLFtVZV06MH0pKS50aGVuKF89Pntjb25zdFttLFNdPXFlKF8pO3IucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG0pLHtpZDp1fSksUykscD09PSJSRUxFQVNFIiYmKHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsbiksdnQocikpfSl9KSxyLnN0YXJ0JiZyLnN0YXJ0KCl9ZnVuY3Rpb24gQ3IoZSl7cmV0dXJuIGUuY29uc3RydWN0b3IubmFtZT09PSJNZXNzYWdlUG9ydCJ9ZnVuY3Rpb24gdnQoZSl7Q3IoZSkmJmUuY2xvc2UoKX1mdW5jdGlvbiBrcihlLHIpe3JldHVybiBCZShlLFtdLHIpfWZ1bmN0aW9uIE9lKGUpe2lmKGUpdGhyb3cgbmV3IEVycm9yKCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGUiKX1mdW5jdGlvbiBCZShlLHI9W10sbj1mdW5jdGlvbigpe30pe2xldCBpPSExO2NvbnN0IHU9bmV3IFByb3h5KG4se2dldChwLG8pe2lmKE9lKGkpLG89PT1pZSlyZXR1cm4oKT0+X2UoZSx7dHlwZToiUkVMRUFTRSIscGF0aDpyLm1hcChkPT5kLnRvU3RyaW5nKCkpfSkudGhlbigoKT0+e3Z0KGUpLGk9ITB9KTtpZihvPT09InRoZW4iKXtpZihyLmxlbmd0aD09PTApcmV0dXJue3RoZW46KCk9PnV9O2NvbnN0IGQ9X2UoZSx7dHlwZToiR0VUIixwYXRoOnIubWFwKGY9PmYudG9TdHJpbmcoKSl9KS50aGVuKGRlKTtyZXR1cm4gZC50aGVuLmJpbmQoZCl9cmV0dXJuIEJlKGUsWy4uLnIsb10pfSxzZXQocCxvLGQpe09lKGkpO2NvbnN0W2YsX109cWUoZCk7cmV0dXJuIF9lKGUse3R5cGU6IlNFVCIscGF0aDpbLi4ucixvXS5tYXAobT0+bS50b1N0cmluZygpKSx2YWx1ZTpmfSxfKS50aGVuKGRlKX0sYXBwbHkocCxvLGQpe09lKGkpO2NvbnN0IGY9cltyLmxlbmd0aC0xXTtpZihmPT09b2UpcmV0dXJuIF9lKGUse3R5cGU6IkVORFBPSU5UIn0pLnRoZW4oZGUpO2lmKGY9PT0iYmluZCIpcmV0dXJuIEJlKGUsci5zbGljZSgwLC0xKSk7Y29uc3RbXyxtXT15dChkKTtyZXR1cm4gX2UoZSx7dHlwZToiQVBQTFkiLHBhdGg6ci5tYXAoUz0+Uy50b1N0cmluZygpKSxhcmd1bWVudExpc3Q6X30sbSkudGhlbihkZSl9LGNvbnN0cnVjdChwLG8pe09lKGkpO2NvbnN0W2QsZl09eXQobyk7cmV0dXJuIF9lKGUse3R5cGU6IkNPTlNUUlVDVCIscGF0aDpyLm1hcChfPT5fLnRvU3RyaW5nKCkpLGFyZ3VtZW50TGlzdDpkfSxmKS50aGVuKGRlKX19KTtyZXR1cm4gdX1mdW5jdGlvbiAkcihlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSxlKX1mdW5jdGlvbiB5dChlKXtjb25zdCByPWUubWFwKHFlKTtyZXR1cm5bci5tYXAobj0+blswXSksJHIoci5tYXAobj0+blsxXSkpXX1jb25zdCBidD1uZXcgV2Vha01hcDtmdW5jdGlvbiBPcihlLHIpe3JldHVybiBidC5zZXQoZSxyKSxlfWZ1bmN0aW9uIEhyKGUpe3JldHVybiBPYmplY3QuYXNzaWduKGUse1tuZV06ITB9KX1mdW5jdGlvbiBxZShlKXtmb3IoY29uc3RbcixuXW9mIG10KWlmKG4uY2FuSGFuZGxlKGUpKXtjb25zdFtpLHVdPW4uc2VyaWFsaXplKGUpO3JldHVyblt7dHlwZToiSEFORExFUiIsbmFtZTpyLHZhbHVlOml9LHVdfXJldHVyblt7dHlwZToiUkFXIix2YWx1ZTplfSxidC5nZXQoZSl8fFtdXX1mdW5jdGlvbiBkZShlKXtzd2l0Y2goZS50eXBlKXtjYXNlIkhBTkRMRVIiOnJldHVybiBtdC5nZXQoZS5uYW1lKS5kZXNlcmlhbGl6ZShlLnZhbHVlKTtjYXNlIlJBVyI6cmV0dXJuIGUudmFsdWV9fWZ1bmN0aW9uIF9lKGUscixuKXtyZXR1cm4gbmV3IFByb21pc2UoaT0+e2NvbnN0IHU9UHIoKTtlLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGZ1bmN0aW9uIHAobyl7IW8uZGF0YXx8IW8uZGF0YS5pZHx8by5kYXRhLmlkIT09dXx8KGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIscCksaShvLmRhdGEpKX0pLGUuc3RhcnQmJmUuc3RhcnQoKSxlLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oe2lkOnV9LHIpLG4pfSl9ZnVuY3Rpb24gUHIoKXtyZXR1cm4gbmV3IEFycmF5KDQpLmZpbGwoMCkubWFwKCgpPT5NYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLnRvU3RyaW5nKDE2KSkuam9pbigiLSIpfXZhciBnZT10eXBlb2YgZ2xvYmFsVGhpcyE9InVuZGVmaW5lZCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93IT0idW5kZWZpbmVkIj93aW5kb3c6dHlwZW9mIGdsb2JhbCE9InVuZGVmaW5lZCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT0idW5kZWZpbmVkIj9zZWxmOnt9O2Z1bmN0aW9uIFRyKGUpe2lmKGUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgcj1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKTtPYmplY3QuZGVmaW5lUHJvcGVydHkocixuLGkuZ2V0P2k6e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbbl19fSl9KSxyfWZ1bmN0aW9uIElyKGUpe3Rocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgIicrZSsnIi4gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgZHluYW1pY1JlcXVpcmVUYXJnZXRzIG9yL2FuZCBpZ25vcmVEeW5hbWljUmVxdWlyZXMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIHdvcmsuJyl9dmFyIF90PXtleHBvcnRzOnt9fSxMcj17fSxqcj1PYmplY3QuZnJlZXplKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7X19wcm90b19fOm51bGwsZGVmYXVsdDpMcn0sU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZToiTW9kdWxlIn0pKSx6cj1Ucihqcik7LyoqIEBsaWNlbnNlIFJlYWN0IHZ1bmRlZmluZWQKKiByZWFjdC1yZWZyZXNoLWJhYmVsLnByb2R1Y3Rpb24ubWluLmpzCioKKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy4KKgoqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZQoqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4KKi92YXIgTnI9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcihBLEUpe3ZhciBIPUEuc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKCJjIik7cmV0dXJuIHouaGFzKEEpfHx6LnNldChBLFtdKSx6LmdldChBKS5wdXNoKHtoYW5kbGU6SCxwZXJzaXN0ZW50SUQ6RX0pLEh9ZnVuY3Rpb24gbihBKXtyZXR1cm4gdHlwZW9mIEE9PSJzdHJpbmciJiYiQSI8PUFbMF0mJiJaIj49QVswXX1mdW5jdGlvbiBpKEEsRSxIKXt2YXIgJD1FLm5vZGU7c3dpdGNoKCQudHlwZSl7Y2FzZSJJZGVudGlmaWVyIjppZighbigkLm5hbWUpKWJyZWFrO3JldHVybiBIKEEsJCxudWxsKSwhMDtjYXNlIkZ1bmN0aW9uRGVjbGFyYXRpb24iOnJldHVybiBIKEEsJC5pZCxudWxsKSwhMDtjYXNlIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIjppZigkLmJvZHkudHlwZT09PSJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiIpYnJlYWs7cmV0dXJuIEgoQSwkLEUpLCEwO2Nhc2UiRnVuY3Rpb25FeHByZXNzaW9uIjpyZXR1cm4gSChBLCQsRSksITA7Y2FzZSJDYWxsRXhwcmVzc2lvbiI6dmFyIHg9RS5nZXQoImFyZ3VtZW50cyIpO2lmKHg9PT12b2lkIDB8fHgubGVuZ3RoPT09MClicmVhazt2YXIgTz1FLmdldCgiY2FsbGVlIik7c3dpdGNoKE8ubm9kZS50eXBlKXtjYXNlIk1lbWJlckV4cHJlc3Npb24iOmNhc2UiSWRlbnRpZmllciI6cmV0dXJuIE89Ty5nZXRTb3VyY2UoKSxpKEErIiQiK08seFswXSxIKT8oSChBLCQsRSksITApOiExO2RlZmF1bHQ6cmV0dXJuITF9Y2FzZSJWYXJpYWJsZURlY2xhcmF0b3IiOmlmKHg9JC5pbml0LHghPT1udWxsJiYoTz0kLmlkLm5hbWUsbihPKSkpe3N3aXRjaCh4LnR5cGUpe2Nhc2UiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iOmNhc2UiRnVuY3Rpb25FeHByZXNzaW9uIjpicmVhaztjYXNlIkNhbGxFeHByZXNzaW9uIjokPXguY2FsbGVlO3ZhciBRPSQudHlwZTtpZihRPT09IkltcG9ydCJ8fFE9PT0iSWRlbnRpZmllciImJigkLm5hbWUuaW5kZXhPZigicmVxdWlyZSIpPT09MHx8JC5uYW1lLmluZGV4T2YoImltcG9ydCIpPT09MCkpcmV0dXJuITE7YnJlYWs7Y2FzZSJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iOmJyZWFrO2RlZmF1bHQ6cmV0dXJuITF9aWYoJD1FLmdldCgiaW5pdCIpLGkoQSwkLEgpKXJldHVybiEwO2lmKE89RS5zY29wZS5nZXRCaW5kaW5nKE8pLE89PT12b2lkIDApcmV0dXJuO2ZvcihFPSExLE89Ty5yZWZlcmVuY2VQYXRocyxRPTA7UTxPLmxlbmd0aDtRKyspe3ZhciB5PU9bUV07aWYoIXkubm9kZXx8eS5ub2RlLnR5cGU9PT0iSlNYSWRlbnRpZmllciJ8fHkubm9kZS50eXBlPT09IklkZW50aWZpZXIiKXtpZih5PXkucGFyZW50LHkudHlwZT09PSJKU1hPcGVuaW5nRWxlbWVudCIpRT0hMDtlbHNlIGlmKHkudHlwZT09PSJDYWxsRXhwcmVzc2lvbiIpe3k9eS5jYWxsZWU7dmFyIEY9dm9pZCAwO3N3aXRjaCh5LnR5cGUpe2Nhc2UiSWRlbnRpZmllciI6Rj15Lm5hbWU7YnJlYWs7Y2FzZSJNZW1iZXJFeHByZXNzaW9uIjpGPXkucHJvcGVydHkubmFtZX1zd2l0Y2goRil7Y2FzZSJjcmVhdGVFbGVtZW50IjpjYXNlImpzeCI6Y2FzZSJqc3hERVYiOmNhc2UianN4cyI6RT0hMH19aWYoRSlyZXR1cm4gSChBLHgsJCksITB9fX19cmV0dXJuITF9ZnVuY3Rpb24gdShBKXtyZXR1cm4gQT1HLmdldChBKSxBPT09dm9pZCAwP251bGw6e2tleTpBLm1hcChmdW5jdGlvbihFKXtyZXR1cm4gRS5uYW1lKyJ7IitFLmtleSsifSJ9KS5qb2luKGAKYCksY3VzdG9tSG9va3M6QS5maWx0ZXIoZnVuY3Rpb24oRSl7ZTpzd2l0Y2goRS5uYW1lKXtjYXNlInVzZVN0YXRlIjpjYXNlIlJlYWN0LnVzZVN0YXRlIjpjYXNlInVzZVJlZHVjZXIiOmNhc2UiUmVhY3QudXNlUmVkdWNlciI6Y2FzZSJ1c2VFZmZlY3QiOmNhc2UiUmVhY3QudXNlRWZmZWN0IjpjYXNlInVzZUxheW91dEVmZmVjdCI6Y2FzZSJSZWFjdC51c2VMYXlvdXRFZmZlY3QiOmNhc2UidXNlTWVtbyI6Y2FzZSJSZWFjdC51c2VNZW1vIjpjYXNlInVzZUNhbGxiYWNrIjpjYXNlIlJlYWN0LnVzZUNhbGxiYWNrIjpjYXNlInVzZVJlZiI6Y2FzZSJSZWFjdC51c2VSZWYiOmNhc2UidXNlQ29udGV4dCI6Y2FzZSJSZWFjdC51c2VDb250ZXh0IjpjYXNlInVzZUltcGVyYXRpdmVIYW5kbGUiOmNhc2UiUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZSI6Y2FzZSJ1c2VEZWJ1Z1ZhbHVlIjpjYXNlIlJlYWN0LnVzZURlYnVnVmFsdWUiOkU9ITA7YnJlYWsgZTtkZWZhdWx0OkU9ITF9cmV0dXJuIUV9KS5tYXAoZnVuY3Rpb24oRSl7cmV0dXJuIG0uY2xvbmVEZWVwKEUuY2FsbGVlKX0pfX1mdW5jdGlvbiBwKEEpe0E9QS5odWIuZmlsZTt2YXIgRT1JLmdldChBKTtpZihFIT09dm9pZCAwKXJldHVybiBFO0U9ITE7Zm9yKHZhciBIPUEuYXN0LmNvbW1lbnRzLCQ9MDskPEgubGVuZ3RoOyQrKylpZihIWyRdLnZhbHVlLmluZGV4T2YoIkByZWZyZXNoIHJlc2V0IikhPT0tMSl7RT0hMDticmVha31yZXR1cm4gSS5zZXQoQSxFKSxFfWZ1bmN0aW9uIG8oQSxFLEgpe3ZhciAkPUUua2V5O0U9RS5jdXN0b21Ib29rczt2YXIgeD1wKEgucGF0aCksTz1bXTtyZXR1cm4gRS5mb3JFYWNoKGZ1bmN0aW9uKFEpe3N3aXRjaChRLnR5cGUpe2Nhc2UiTWVtYmVyRXhwcmVzc2lvbiI6aWYoUS5vYmplY3QudHlwZT09PSJJZGVudGlmaWVyIil2YXIgeT1RLm9iamVjdC5uYW1lO2JyZWFrO2Nhc2UiSWRlbnRpZmllciI6eT1RLm5hbWV9SC5oYXNCaW5kaW5nKHkpP08ucHVzaChRKTp4PSEwfSksRT0kLHR5cGVvZiBJciE9ImZ1bmN0aW9uInx8Zi5lbWl0RnVsbFNpZ25hdHVyZXN8fChFPXpyLmNyZWF0ZUhhc2goInNoYTEiKS51cGRhdGUoJCkuZGlnZXN0KCJiYXNlNjQiKSksQT1bQSxtLnN0cmluZ0xpdGVyYWwoRSldLCh4fHwwPE8ubGVuZ3RoKSYmQS5wdXNoKG0uYm9vbGVhbkxpdGVyYWwoeCkpLDA8Ty5sZW5ndGgmJkEucHVzaChtLmZ1bmN0aW9uRXhwcmVzc2lvbihudWxsLFtdLG0uYmxvY2tTdGF0ZW1lbnQoW20ucmV0dXJuU3RhdGVtZW50KG0uYXJyYXlFeHByZXNzaW9uKE8pKV0pKSksQX1mdW5jdGlvbiBkKEEpe2Zvcih2YXIgRT1bXTs7KXtpZighQSlyZXR1cm4gRTt2YXIgSD1BLnBhcmVudFBhdGg7aWYoIUgpcmV0dXJuIEU7aWYoSC5ub2RlLnR5cGU9PT0iQXNzaWdubWVudEV4cHJlc3Npb24iJiZBLm5vZGU9PT1ILm5vZGUucmlnaHQpQT1IO2Vsc2UgaWYoSC5ub2RlLnR5cGU9PT0iQ2FsbEV4cHJlc3Npb24iJiZBLm5vZGUhPT1ILm5vZGUuY2FsbGVlKUUucHVzaChIKSxBPUg7ZWxzZSByZXR1cm4gRX19dmFyIGY9MTxhcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKHR5cGVvZiBlLmVudj09ImZ1bmN0aW9uIil7dmFyIF89ZS5lbnYoKTtpZihfIT09ImRldmVsb3BtZW50IiYmIWYuc2tpcEVudkNoZWNrKXRocm93IEVycm9yKCdSZWFjdCBSZWZyZXNoIEJhYmVsIHRyYW5zZm9ybSBzaG91bGQgb25seSBiZSBlbmFibGVkIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50LiBJbnN0ZWFkLCB0aGUgZW52aXJvbm1lbnQgaXM6ICInK18rJyIuIElmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgY2hlY2ssIHBhc3Mge3NraXBFbnZDaGVjazogdHJ1ZX0gYXMgcGx1Z2luIG9wdGlvbnMuJyl9dmFyIG09ZS50eXBlcyxTPW0uaWRlbnRpZmllcihmLnJlZnJlc2hSZWd8fCIkUmVmcmVzaFJlZyQiKSx2PW0uaWRlbnRpZmllcihmLnJlZnJlc2hTaWd8fCIkUmVmcmVzaFNpZyQiKSx6PW5ldyBNYXAsST1uZXcgV2Vha01hcCxrPW5ldyBXZWFrU2V0LE09bmV3IFdlYWtTZXQscT1uZXcgV2Vha1NldCxHPW5ldyBXZWFrTWFwLFU9e0NhbGxFeHByZXNzaW9uOmZ1bmN0aW9uKEEpe3ZhciBFPUEubm9kZS5jYWxsZWUsSD1udWxsO3N3aXRjaChFLnR5cGUpe2Nhc2UiSWRlbnRpZmllciI6SD1FLm5hbWU7YnJlYWs7Y2FzZSJNZW1iZXJFeHByZXNzaW9uIjpIPUUucHJvcGVydHkubmFtZX1pZihIIT09bnVsbCYmL151c2VbQS1aXS8udGVzdChIKSYmKEU9QS5zY29wZS5nZXRGdW5jdGlvblBhcmVudCgpLEUhPT1udWxsKSl7RT1FLmJsb2NrLEcuaGFzKEUpfHxHLnNldChFLFtdKSxFPUcuZ2V0KEUpO3ZhciAkPSIiO0EucGFyZW50LnR5cGU9PT0iVmFyaWFibGVEZWNsYXJhdG9yIiYmKCQ9QS5wYXJlbnRQYXRoLmdldCgiaWQiKS5nZXRTb3VyY2UoKSk7dmFyIHg9QS5nZXQoImFyZ3VtZW50cyIpO0g9PT0idXNlU3RhdGUiJiYwPHgubGVuZ3RoPyQrPSIoIit4WzBdLmdldFNvdXJjZSgpKyIpIjpIPT09InVzZVJlZHVjZXIiJiYxPHgubGVuZ3RoJiYoJCs9IigiK3hbMV0uZ2V0U291cmNlKCkrIikiKSxFLnB1c2goe2NhbGxlZTpBLm5vZGUuY2FsbGVlLG5hbWU6SCxrZXk6JH0pfX19O3JldHVybnt2aXNpdG9yOntFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ZnVuY3Rpb24oQSl7dmFyIEU9QS5ub2RlLEg9RS5kZWNsYXJhdGlvbiwkPUEuZ2V0KCJkZWNsYXJhdGlvbiIpO2lmKEgudHlwZT09PSJDYWxsRXhwcmVzc2lvbiImJiFrLmhhcyhFKSl7ay5hZGQoRSk7dmFyIHg9QS5wYXJlbnRQYXRoO2koIiVkZWZhdWx0JSIsJCxmdW5jdGlvbihPLFEseSl7eSE9PW51bGwmJihPPXIoeCxPKSx5LnJlcGxhY2VXaXRoKG0uYXNzaWdubWVudEV4cHJlc3Npb24oIj0iLE8sUSkpKX0pfX0sRnVuY3Rpb25EZWNsYXJhdGlvbjp7ZW50ZXI6ZnVuY3Rpb24oQSl7dmFyIEU9QS5ub2RlO3N3aXRjaChBLnBhcmVudC50eXBlKXtjYXNlIlByb2dyYW0iOnZhciBIPUEsJD1BLnBhcmVudFBhdGg7YnJlYWs7Y2FzZSJFeHBvcnROYW1lZERlY2xhcmF0aW9uIjpIPUEucGFyZW50UGF0aCwkPUgucGFyZW50UGF0aDticmVhaztjYXNlIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiI6SD1BLnBhcmVudFBhdGgsJD1ILnBhcmVudFBhdGg7YnJlYWs7ZGVmYXVsdDpyZXR1cm59dmFyIHg9RS5pZDt4IT09bnVsbCYmKHg9eC5uYW1lLG4oeCkmJiFrLmhhcyhFKSYmKGsuYWRkKEUpLGkoeCxBLGZ1bmN0aW9uKE8sUSl7Tz1yKCQsTyksSC5pbnNlcnRBZnRlcihtLmV4cHJlc3Npb25TdGF0ZW1lbnQobS5hc3NpZ25tZW50RXhwcmVzc2lvbigiPSIsTyxRKSkpfSkpKX0sZXhpdDpmdW5jdGlvbihBKXt2YXIgRT1BLm5vZGUsSD1FLmlkO2lmKEghPT1udWxsKXt2YXIgJD11KEUpO2lmKCQhPT1udWxsJiYhTS5oYXMoRSkpe00uYWRkKEUpLEU9QS5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoIl9zIiksQS5zY29wZS5wYXJlbnQucHVzaCh7aWQ6RSxpbml0Om0uY2FsbEV4cHJlc3Npb24odixbXSl9KSxBLmdldCgiYm9keSIpLnVuc2hpZnRDb250YWluZXIoImJvZHkiLG0uZXhwcmVzc2lvblN0YXRlbWVudChtLmNhbGxFeHByZXNzaW9uKEUsW10pKSk7dmFyIHg9bnVsbDtBLmZpbmQoZnVuY3Rpb24oTyl7aWYoTy5wYXJlbnRQYXRoLmlzQmxvY2soKSlyZXR1cm4geD1PLCEwfSkseCE9PW51bGwmJnguaW5zZXJ0QWZ0ZXIobS5leHByZXNzaW9uU3RhdGVtZW50KG0uY2FsbEV4cHJlc3Npb24oRSxvKEgsJCx4LnNjb3BlKSkpKX19fX0sIkFycm93RnVuY3Rpb25FeHByZXNzaW9ufEZ1bmN0aW9uRXhwcmVzc2lvbiI6e2V4aXQ6ZnVuY3Rpb24oQSl7dmFyIEU9QS5ub2RlLEg9dShFKTtpZihIIT09bnVsbCYmIU0uaGFzKEUpKXtNLmFkZChFKTt2YXIgJD1BLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcigiX3MiKTtpZihBLnNjb3BlLnBhcmVudC5wdXNoKHtpZDokLGluaXQ6bS5jYWxsRXhwcmVzc2lvbih2LFtdKX0pLEEubm9kZS5ib2R5LnR5cGUhPT0iQmxvY2tTdGF0ZW1lbnQiJiYoQS5ub2RlLmJvZHk9bS5ibG9ja1N0YXRlbWVudChbbS5yZXR1cm5TdGF0ZW1lbnQoQS5ub2RlLmJvZHkpXSkpLEEuZ2V0KCJib2R5IikudW5zaGlmdENvbnRhaW5lcigiYm9keSIsbS5leHByZXNzaW9uU3RhdGVtZW50KG0uY2FsbEV4cHJlc3Npb24oJCxbXSkpKSxBLnBhcmVudC50eXBlPT09IlZhcmlhYmxlRGVjbGFyYXRvciIpe3ZhciB4PW51bGw7QS5maW5kKGZ1bmN0aW9uKE8pe2lmKE8ucGFyZW50UGF0aC5pc0Jsb2NrKCkpcmV0dXJuIHg9TywhMH0pLHghPT1udWxsJiZ4Lmluc2VydEFmdGVyKG0uZXhwcmVzc2lvblN0YXRlbWVudChtLmNhbGxFeHByZXNzaW9uKCQsbyhBLnBhcmVudC5pZCxILHguc2NvcGUpKSkpfWVsc2VbQV0uY29uY2F0KGQoQSkpLmZvckVhY2goZnVuY3Rpb24oTyl7Ty5yZXBsYWNlV2l0aChtLmNhbGxFeHByZXNzaW9uKCQsbyhPLm5vZGUsSCxPLnNjb3BlKSkpfSl9fX0sVmFyaWFibGVEZWNsYXJhdGlvbjpmdW5jdGlvbihBKXt2YXIgRT1BLm5vZGU7c3dpdGNoKEEucGFyZW50LnR5cGUpe2Nhc2UiUHJvZ3JhbSI6dmFyIEg9QSwkPUEucGFyZW50UGF0aDticmVhaztjYXNlIkV4cG9ydE5hbWVkRGVjbGFyYXRpb24iOkg9QS5wYXJlbnRQYXRoLCQ9SC5wYXJlbnRQYXRoO2JyZWFrO2Nhc2UiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIjpIPUEucGFyZW50UGF0aCwkPUgucGFyZW50UGF0aDticmVhaztkZWZhdWx0OnJldHVybn1pZighay5oYXMoRSkmJihrLmFkZChFKSxBPUEuZ2V0KCJkZWNsYXJhdGlvbnMiKSxBLmxlbmd0aD09PTEpKXt2YXIgeD1BWzBdO2koeC5ub2RlLmlkLm5hbWUseCxmdW5jdGlvbihPLFEseSl7eSE9PW51bGwmJihPPXIoJCxPKSx5LnBhcmVudC50eXBlPT09IlZhcmlhYmxlRGVjbGFyYXRvciI/SC5pbnNlcnRBZnRlcihtLmV4cHJlc3Npb25TdGF0ZW1lbnQobS5hc3NpZ25tZW50RXhwcmVzc2lvbigiPSIsTyx4Lm5vZGUuaWQpKSk6eS5yZXBsYWNlV2l0aChtLmFzc2lnbm1lbnRFeHByZXNzaW9uKCI9IixPLFEpKSl9KX19LFByb2dyYW06e2VudGVyOmZ1bmN0aW9uKEEpe0EudHJhdmVyc2UoVSl9LGV4aXQ6ZnVuY3Rpb24oQSl7dmFyIEU9ei5nZXQoQSk7aWYoRSE9PXZvaWQgMCl7dmFyIEg9QS5ub2RlO2lmKCFxLmhhcyhIKSl7cS5hZGQoSCksei5kZWxldGUoQSk7dmFyICQ9W107QS5wdXNoQ29udGFpbmVyKCJib2R5IixtLnZhcmlhYmxlRGVjbGFyYXRpb24oInZhciIsJCkpLEUuZm9yRWFjaChmdW5jdGlvbih4KXt2YXIgTz14LmhhbmRsZTtBLnB1c2hDb250YWluZXIoImJvZHkiLG0uZXhwcmVzc2lvblN0YXRlbWVudChtLmNhbGxFeHByZXNzaW9uKFMsW08sbS5zdHJpbmdMaXRlcmFsKHgucGVyc2lzdGVudElEKV0pKSksJC5wdXNoKG0udmFyaWFibGVEZWNsYXJhdG9yKE8pKX0pfX19fX19fTtfdC5leHBvcnRzPU5yO3ZhciBEcj1fdC5leHBvcnRzO2NvbnN0IEdlPVsiLmpzIiwiLmpzeCIsIi50cyIsIi50c3giXSxFdD0oZSxyKT0+e2NvbnN0IG49W10saT0odSxwKT0+KHAodSkmJm4ucHVzaCh1KSx1LmZvckVhY2hDaGlsZChvPT5pKG8scCkpKTtyZXR1cm4gaShlLHIpLG59LEF0PWU9Pntjb25zdCByPWUubGFzdEluZGV4T2YoIi4iKTtyZXR1cm4gcj4wJiZyPGUubGVuZ3RoP2Uuc3Vic3RyaW5nKDAscik6ZX0seHQ9KGUscik9PntlLmdldEltcG9ydERlY2xhcmF0aW9ucygpLmZvckVhY2gobj0+e2xldCBpPW4uZ2V0TW9kdWxlU3BlY2lmaWVyVmFsdWUoKTtpZigoaT09PSIuLyJ8fGk9PT0iLiIpJiZuLnNldE1vZHVsZVNwZWNpZmllcigiLi9pbmRleCIpLCFuLmlzTW9kdWxlU3BlY2lmaWVyUmVsYXRpdmUoKSYmaS5zdGFydHNXaXRoKCJzcmMvIikpe2xldCB1PU1yKFVyKGksIi8iKSxyKTtuLnNldE1vZHVsZVNwZWNpZmllcih1KX1lbHNlIW4uaXNNb2R1bGVTcGVjaWZpZXJSZWxhdGl2ZSgpJiYhaS5lbmRzV2l0aCgiLmNzcyIpP1FyKG4pOmkuZW5kc1dpdGgoIi5jc3MiKSYmbi5yZXBsYWNlV2l0aFRleHQoYC8vJHtuLmdldFRleHQoKX1gKX0pfSxSdD0oZSxyKT0+e09iamVjdC5rZXlzKHIpLmZvckVhY2gobj0+e2NvbnN0IGk9RXQoZSx1PT57aWYoa2UuTm9kZS5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbih1KSl7Y29uc3QgcD11LmdldFRleHQoKTtyZXR1cm4gcC5tYXRjaCgvXGJpbXBvcnRcYi5tZXRhLmVudi4vZykhPW51bGwmJnAuZW5kc1dpdGgobil9cmV0dXJuITF9KTtpLmxlbmd0aCE9MCYmaS5mb3JFYWNoKHU9PnUucmVwbGFjZVdpdGhUZXh0KGAnJHtyW25dfSdgKSl9KX0sTXI9KGUscik9Pntjb25zdCBuPXIuc3BsaXQoIi8iKTtsZXQgaT0iIjtuLnBvcCgpO2NvbnN0IHU9bltuLmxlbmd0aC0xXTtpZihlLm1hdGNoKGAvJHt1fS9gKSl7Y29uc3QgcD1lLnN1YnN0cmluZyhlLmxhc3RJbmRleE9mKGAvJHt1fS9gKStgLyR7dX0vYC5sZW5ndGgpO3JldHVybiIuLyIrcH1lbHNlIGkrPSIuLi8iLG4ucG9wKCk7Zm9yKDtuLmxlbmd0aD4wOyl7Y29uc3QgcD1uLnBvcCgpO2lmKGUubWF0Y2goYC8ke3B9L2ApKXtjb25zdCBvPWUuc3Vic3RyaW5nKGUubGFzdEluZGV4T2YoYC8ke3B9L2ApK2AvJHtwfS9gLmxlbmd0aCk7cmV0dXJuIGkrb31lbHNlIGkrPSIuLi8ifXJldHVybiBlfSxRcj1lPT57dmFyIHIsbixpO2NvbnN0IHU9YGNvbnN0ICR7KGk9KHI9ZS5nZXREZWZhdWx0SW1wb3J0KCkpPT1udWxsP3ZvaWQgMDpyLnByaW50KCkpIT1udWxsP2k6KG49ZS5nZXROYW1lc3BhY2VJbXBvcnQoKSk9PW51bGw/dm9pZCAwOm4ucHJpbnQoKX0gPSByZXF1aXJlRGVmYXVsdCgnJHtlLmdldE1vZHVsZVNwZWNpZmllclZhbHVlKCl9JylgLHA9YGNvbnN0IHsgJHtlLmdldE5hbWVkSW1wb3J0cygpLm1hcChvPT5vLnByaW50KCkucmVwbGFjZUFsbCgvYXMvZywiOiIpKS5qb2luKCIsIil9IH0gPSByZXF1aXJlKCcke2UuZ2V0TW9kdWxlU3BlY2lmaWVyVmFsdWUoKX0nKWA7ZS5nZXROYW1lZEltcG9ydHMoKS5sZW5ndGgmJmUuZ2V0RGVmYXVsdEltcG9ydCgpP2UucmVwbGFjZVdpdGhUZXh0KHUrYApgK3ApOmUuZ2V0RGVmYXVsdEltcG9ydCgpfHxlLmdldE5hbWVzcGFjZUltcG9ydCgpP2UucmVwbGFjZVdpdGhUZXh0KHUpOmUuZ2V0TmFtZWRJbXBvcnRzKCkmJmUucmVwbGFjZVdpdGhUZXh0KHApfSxVcj0oZSxyKT0+ZS5zdGFydHNXaXRoKHIpP2U6citlO3ZhciBIZT17fSxGcj1mdW5jdGlvbihlKXtyZXR1cm4gZSYmdHlwZW9mIGU9PSJvYmplY3QiJiZ0eXBlb2YgZS5jb3B5PT0iZnVuY3Rpb24iJiZ0eXBlb2YgZS5maWxsPT0iZnVuY3Rpb24iJiZ0eXBlb2YgZS5yZWFkVUludDg9PSJmdW5jdGlvbiJ9LFdlPXtleHBvcnRzOnt9fTt0eXBlb2YgT2JqZWN0LmNyZWF0ZT09ImZ1bmN0aW9uIj9XZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7ZS5zdXBlcl89cixlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KX06V2UuZXhwb3J0cz1mdW5jdGlvbihlLHIpe2Uuc3VwZXJfPXI7dmFyIG49ZnVuY3Rpb24oKXt9O24ucHJvdG90eXBlPXIucHJvdG90eXBlLGUucHJvdG90eXBlPW5ldyBuLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWV9LGZ1bmN0aW9uKGUpe3ZhciByPS8lW3NkaiVdL2c7ZS5mb3JtYXQ9ZnVuY3Rpb24obCl7aWYoIVUobCkpe2Zvcih2YXIgaD1bXSxnPTA7Zzxhcmd1bWVudHMubGVuZ3RoO2crKyloLnB1c2godShhcmd1bWVudHNbZ10pKTtyZXR1cm4gaC5qb2luKCIgIil9Zm9yKHZhciBnPTEsYj1hcmd1bWVudHMsUj1iLmxlbmd0aCxQPVN0cmluZyhsKS5yZXBsYWNlKHIsZnVuY3Rpb24oail7aWYoaj09PSIlJSIpcmV0dXJuIiUiO2lmKGc+PVIpcmV0dXJuIGo7c3dpdGNoKGope2Nhc2UiJXMiOnJldHVybiBTdHJpbmcoYltnKytdKTtjYXNlIiVkIjpyZXR1cm4gTnVtYmVyKGJbZysrXSk7Y2FzZSIlaiI6dHJ5e3JldHVybiBKU09OLnN0cmluZ2lmeShiW2crK10pfWNhdGNoe3JldHVybiJbQ2lyY3VsYXJdIn1kZWZhdWx0OnJldHVybiBqfX0pLEw9YltnXTtnPFI7TD1iWysrZ10pTShMKXx8ISQoTCk/UCs9IiAiK0w6UCs9IiAiK3UoTCk7cmV0dXJuIFB9LGUuZGVwcmVjYXRlPWZ1bmN0aW9uKGwsaCl7aWYoRShnZS5wcm9jZXNzKSlyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5kZXByZWNhdGUobCxoKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2lmKHByb2Nlc3Mubm9EZXByZWNhdGlvbj09PSEwKXJldHVybiBsO3ZhciBnPSExO2Z1bmN0aW9uIGIoKXtpZighZyl7aWYocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKXRocm93IG5ldyBFcnJvcihoKTtwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24/Y29uc29sZS50cmFjZShoKTpjb25zb2xlLmVycm9yKGgpLGc9ITB9cmV0dXJuIGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBifTt2YXIgbj17fSxpO2UuZGVidWdsb2c9ZnVuY3Rpb24obCl7aWYoRShpKSYmKGk9e30uTk9ERV9ERUJVR3x8IiIpLGw9bC50b1VwcGVyQ2FzZSgpLCFuW2xdKWlmKG5ldyBSZWdFeHAoIlxcYiIrbCsiXFxiIiwiaSIpLnRlc3QoaSkpe3ZhciBoPXByb2Nlc3MucGlkO25bbF09ZnVuY3Rpb24oKXt2YXIgZz1lLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cyk7Y29uc29sZS5lcnJvcigiJXMgJWQ6ICVzIixsLGgsZyl9fWVsc2UgbltsXT1mdW5jdGlvbigpe307cmV0dXJuIG5bbF19O2Z1bmN0aW9uIHUobCxoKXt2YXIgZz17c2VlbjpbXSxzdHlsaXplOm99O3JldHVybiBhcmd1bWVudHMubGVuZ3RoPj0zJiYoZy5kZXB0aD1hcmd1bWVudHNbMl0pLGFyZ3VtZW50cy5sZW5ndGg+PTQmJihnLmNvbG9ycz1hcmd1bWVudHNbM10pLGsoaCk/Zy5zaG93SGlkZGVuPWg6aCYmZS5fZXh0ZW5kKGcsaCksRShnLnNob3dIaWRkZW4pJiYoZy5zaG93SGlkZGVuPSExKSxFKGcuZGVwdGgpJiYoZy5kZXB0aD0yKSxFKGcuY29sb3JzKSYmKGcuY29sb3JzPSExKSxFKGcuY3VzdG9tSW5zcGVjdCkmJihnLmN1c3RvbUluc3BlY3Q9ITApLGcuY29sb3JzJiYoZy5zdHlsaXplPXApLGYoZyxsLGcuZGVwdGgpfWUuaW5zcGVjdD11LHUuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfSx1LnN0eWxlcz17c3BlY2lhbDoiY3lhbiIsbnVtYmVyOiJ5ZWxsb3ciLGJvb2xlYW46InllbGxvdyIsdW5kZWZpbmVkOiJncmV5IixudWxsOiJib2xkIixzdHJpbmc6ImdyZWVuIixkYXRlOiJtYWdlbnRhIixyZWdleHA6InJlZCJ9O2Z1bmN0aW9uIHAobCxoKXt2YXIgZz11LnN0eWxlc1toXTtyZXR1cm4gZz8iXHgxQlsiK3UuY29sb3JzW2ddWzBdKyJtIitsKyJceDFCWyIrdS5jb2xvcnNbZ11bMV0rIm0iOmx9ZnVuY3Rpb24gbyhsLGgpe3JldHVybiBsfWZ1bmN0aW9uIGQobCl7dmFyIGg9e307cmV0dXJuIGwuZm9yRWFjaChmdW5jdGlvbihnLGIpe2hbZ109ITB9KSxofWZ1bmN0aW9uIGYobCxoLGcpe2lmKGwuY3VzdG9tSW5zcGVjdCYmaCYmUShoLmluc3BlY3QpJiZoLmluc3BlY3QhPT1lLmluc3BlY3QmJiEoaC5jb25zdHJ1Y3RvciYmaC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT1oKSl7dmFyIGI9aC5pbnNwZWN0KGcsbCk7cmV0dXJuIFUoYil8fChiPWYobCxiLGcpKSxifXZhciBSPV8obCxoKTtpZihSKXJldHVybiBSO3ZhciBQPU9iamVjdC5rZXlzKGgpLEw9ZChQKTtpZihsLnNob3dIaWRkZW4mJihQPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGgpKSxPKGgpJiYoUC5pbmRleE9mKCJtZXNzYWdlIik+PTB8fFAuaW5kZXhPZigiZGVzY3JpcHRpb24iKT49MCkpcmV0dXJuIG0oaCk7aWYoUC5sZW5ndGg9PT0wKXtpZihRKGgpKXt2YXIgTj1oLm5hbWU/IjogIitoLm5hbWU6IiI7cmV0dXJuIGwuc3R5bGl6ZSgiW0Z1bmN0aW9uIitOKyJdIiwic3BlY2lhbCIpfWlmKEgoaCkpcmV0dXJuIGwuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaCksInJlZ2V4cCIpO2lmKHgoaCkpcmV0dXJuIGwuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpLCJkYXRlIik7aWYoTyhoKSlyZXR1cm4gbShoKX12YXIgaj0iIixUPSExLEs9WyJ7IiwifSJdO2lmKEkoaCkmJihUPSEwLEs9WyJbIiwiXSJdKSxRKGgpKXt2YXIgcmU9aC5uYW1lPyI6ICIraC5uYW1lOiIiO2o9IiBbRnVuY3Rpb24iK3JlKyJdIn1pZihIKGgpJiYoaj0iICIrUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpKSx4KGgpJiYoaj0iICIrRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbChoKSksTyhoKSYmKGo9IiAiK20oaCkpLFAubGVuZ3RoPT09MCYmKCFUfHxoLmxlbmd0aD09MCkpcmV0dXJuIEtbMF0raitLWzFdO2lmKGc8MClyZXR1cm4gSChoKT9sLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpLCJyZWdleHAiKTpsLnN0eWxpemUoIltPYmplY3RdIiwic3BlY2lhbCIpO2wuc2Vlbi5wdXNoKGgpO3ZhciBDO3JldHVybiBUP0M9UyhsLGgsZyxMLFApOkM9UC5tYXAoZnVuY3Rpb24oQil7cmV0dXJuIHYobCxoLGcsTCxCLFQpfSksbC5zZWVuLnBvcCgpLHooQyxqLEspfWZ1bmN0aW9uIF8obCxoKXtpZihFKGgpKXJldHVybiBsLnN0eWxpemUoInVuZGVmaW5lZCIsInVuZGVmaW5lZCIpO2lmKFUoaCkpe3ZhciBnPSInIitKU09OLnN0cmluZ2lmeShoKS5yZXBsYWNlKC9eInwiJC9nLCIiKS5yZXBsYWNlKC8nL2csIlxcJyIpLnJlcGxhY2UoL1xcIi9nLCciJykrIiciO3JldHVybiBsLnN0eWxpemUoZywic3RyaW5nIil9aWYoRyhoKSlyZXR1cm4gbC5zdHlsaXplKCIiK2gsIm51bWJlciIpO2lmKGsoaCkpcmV0dXJuIGwuc3R5bGl6ZSgiIitoLCJib29sZWFuIik7aWYoTShoKSlyZXR1cm4gbC5zdHlsaXplKCJudWxsIiwibnVsbCIpfWZ1bmN0aW9uIG0obCl7cmV0dXJuIlsiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGwpKyJdIn1mdW5jdGlvbiBTKGwsaCxnLGIsUil7Zm9yKHZhciBQPVtdLEw9MCxOPWgubGVuZ3RoO0w8TjsrK0wpYyhoLFN0cmluZyhMKSk/UC5wdXNoKHYobCxoLGcsYixTdHJpbmcoTCksITApKTpQLnB1c2goIiIpO3JldHVybiBSLmZvckVhY2goZnVuY3Rpb24oail7ai5tYXRjaCgvXlxkKyQvKXx8UC5wdXNoKHYobCxoLGcsYixqLCEwKSl9KSxQfWZ1bmN0aW9uIHYobCxoLGcsYixSLFApe3ZhciBMLE4sajtpZihqPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaCxSKXx8e3ZhbHVlOmhbUl19LGouZ2V0P2ouc2V0P049bC5zdHlsaXplKCJbR2V0dGVyL1NldHRlcl0iLCJzcGVjaWFsIik6Tj1sLnN0eWxpemUoIltHZXR0ZXJdIiwic3BlY2lhbCIpOmouc2V0JiYoTj1sLnN0eWxpemUoIltTZXR0ZXJdIiwic3BlY2lhbCIpKSxjKGIsUil8fChMPSJbIitSKyJdIiksTnx8KGwuc2Vlbi5pbmRleE9mKGoudmFsdWUpPDA/KE0oZyk/Tj1mKGwsai52YWx1ZSxudWxsKTpOPWYobCxqLnZhbHVlLGctMSksTi5pbmRleE9mKGAKYCk+LTEmJihQP049Ti5zcGxpdChgCmApLm1hcChmdW5jdGlvbihUKXtyZXR1cm4iICAiK1R9KS5qb2luKGAKYCkuc3Vic3RyKDIpOk49YApgK04uc3BsaXQoYApgKS5tYXAoZnVuY3Rpb24oVCl7cmV0dXJuIiAgICIrVH0pLmpvaW4oYApgKSkpOk49bC5zdHlsaXplKCJbQ2lyY3VsYXJdIiwic3BlY2lhbCIpKSxFKEwpKXtpZihQJiZSLm1hdGNoKC9eXGQrJC8pKXJldHVybiBOO0w9SlNPTi5zdHJpbmdpZnkoIiIrUiksTC5tYXRjaCgvXiIoW2EtekEtWl9dW2EtekEtWl8wLTldKikiJC8pPyhMPUwuc3Vic3RyKDEsTC5sZW5ndGgtMiksTD1sLnN0eWxpemUoTCwibmFtZSIpKTooTD1MLnJlcGxhY2UoLycvZywiXFwnIikucmVwbGFjZSgvXFwiL2csJyInKS5yZXBsYWNlKC8oXiJ8IiQpL2csIiciKSxMPWwuc3R5bGl6ZShMLCJzdHJpbmciKSl9cmV0dXJuIEwrIjogIitOfWZ1bmN0aW9uIHoobCxoLGcpe3ZhciBiPWwucmVkdWNlKGZ1bmN0aW9uKFIsUCl7cmV0dXJuIFAuaW5kZXhPZihgCmApPj0wLFIrUC5yZXBsYWNlKC9cdTAwMWJcW1xkXGQ/bS9nLCIiKS5sZW5ndGgrMX0sMCk7cmV0dXJuIGI+NjA/Z1swXSsoaD09PSIiPyIiOmgrYAogYCkrIiAiK2wuam9pbihgLAogIGApKyIgIitnWzFdOmdbMF0raCsiICIrbC5qb2luKCIsICIpKyIgIitnWzFdfWZ1bmN0aW9uIEkobCl7cmV0dXJuIEFycmF5LmlzQXJyYXkobCl9ZS5pc0FycmF5PUk7ZnVuY3Rpb24gayhsKXtyZXR1cm4gdHlwZW9mIGw9PSJib29sZWFuIn1lLmlzQm9vbGVhbj1rO2Z1bmN0aW9uIE0obCl7cmV0dXJuIGw9PT1udWxsfWUuaXNOdWxsPU07ZnVuY3Rpb24gcShsKXtyZXR1cm4gbD09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPXE7ZnVuY3Rpb24gRyhsKXtyZXR1cm4gdHlwZW9mIGw9PSJudW1iZXIifWUuaXNOdW1iZXI9RztmdW5jdGlvbiBVKGwpe3JldHVybiB0eXBlb2YgbD09InN0cmluZyJ9ZS5pc1N0cmluZz1VO2Z1bmN0aW9uIEEobCl7cmV0dXJuIHR5cGVvZiBsPT0ic3ltYm9sIn1lLmlzU3ltYm9sPUE7ZnVuY3Rpb24gRShsKXtyZXR1cm4gbD09PXZvaWQgMH1lLmlzVW5kZWZpbmVkPUU7ZnVuY3Rpb24gSChsKXtyZXR1cm4gJChsKSYmRihsKT09PSJbb2JqZWN0IFJlZ0V4cF0ifWUuaXNSZWdFeHA9SDtmdW5jdGlvbiAkKGwpe3JldHVybiB0eXBlb2YgbD09Im9iamVjdCImJmwhPT1udWxsfWUuaXNPYmplY3Q9JDtmdW5jdGlvbiB4KGwpe3JldHVybiAkKGwpJiZGKGwpPT09IltvYmplY3QgRGF0ZV0ifWUuaXNEYXRlPXg7ZnVuY3Rpb24gTyhsKXtyZXR1cm4gJChsKSYmKEYobCk9PT0iW29iamVjdCBFcnJvcl0ifHxsIGluc3RhbmNlb2YgRXJyb3IpfWUuaXNFcnJvcj1PO2Z1bmN0aW9uIFEobCl7cmV0dXJuIHR5cGVvZiBsPT0iZnVuY3Rpb24ifWUuaXNGdW5jdGlvbj1RO2Z1bmN0aW9uIHkobCl7cmV0dXJuIGw9PT1udWxsfHx0eXBlb2YgbD09ImJvb2xlYW4ifHx0eXBlb2YgbD09Im51bWJlciJ8fHR5cGVvZiBsPT0ic3RyaW5nInx8dHlwZW9mIGw9PSJzeW1ib2wifHx0eXBlb2YgbD09InVuZGVmaW5lZCJ9ZS5pc1ByaW1pdGl2ZT15LGUuaXNCdWZmZXI9RnI7ZnVuY3Rpb24gRihsKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGwpfWZ1bmN0aW9uIHQobCl7cmV0dXJuIGw8MTA/IjAiK2wudG9TdHJpbmcoMTApOmwudG9TdHJpbmcoMTApfXZhciBzPVsiSmFuIiwiRmViIiwiTWFyIiwiQXByIiwiTWF5IiwiSnVuIiwiSnVsIiwiQXVnIiwiU2VwIiwiT2N0IiwiTm92IiwiRGVjIl07ZnVuY3Rpb24gYSgpe3ZhciBsPW5ldyBEYXRlLGg9W3QobC5nZXRIb3VycygpKSx0KGwuZ2V0TWludXRlcygpKSx0KGwuZ2V0U2Vjb25kcygpKV0uam9pbigiOiIpO3JldHVybltsLmdldERhdGUoKSxzW2wuZ2V0TW9udGgoKV0saF0uam9pbigiICIpfWUubG9nPWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coIiVzIC0gJXMiLGEoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfSxlLmluaGVyaXRzPVdlLmV4cG9ydHMsZS5fZXh0ZW5kPWZ1bmN0aW9uKGwsaCl7aWYoIWh8fCEkKGgpKXJldHVybiBsO2Zvcih2YXIgZz1PYmplY3Qua2V5cyhoKSxiPWcubGVuZ3RoO2ItLTspbFtnW2JdXT1oW2dbYl1dO3JldHVybiBsfTtmdW5jdGlvbiBjKGwsaCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsLGgpfX0oSGUpO3ZhciBQZT17fTsoZnVuY3Rpb24oZSl7ZS5pc0ludGVnZXI9cj0+dHlwZW9mIHI9PSJudW1iZXIiP051bWJlci5pc0ludGVnZXIocik6dHlwZW9mIHI9PSJzdHJpbmciJiZyLnRyaW0oKSE9PSIiP051bWJlci5pc0ludGVnZXIoTnVtYmVyKHIpKTohMSxlLmZpbmQ9KHIsbik9PnIubm9kZXMuZmluZChpPT5pLnR5cGU9PT1uKSxlLmV4Y2VlZHNMaW1pdD0ocixuLGk9MSx1KT0+dT09PSExfHwhZS5pc0ludGVnZXIocil8fCFlLmlzSW50ZWdlcihuKT8hMTooTnVtYmVyKG4pLU51bWJlcihyKSkvTnVtYmVyKGkpPj11LGUuZXNjYXBlTm9kZT0ocixuPTAsaSk9PntsZXQgdT1yLm5vZGVzW25dOyF1fHwoaSYmdS50eXBlPT09aXx8dS50eXBlPT09Im9wZW4ifHx1LnR5cGU9PT0iY2xvc2UiKSYmdS5lc2NhcGVkIT09ITAmJih1LnZhbHVlPSJcXCIrdS52YWx1ZSx1LmVzY2FwZWQ9ITApfSxlLmVuY2xvc2VCcmFjZT1yPT5yLnR5cGUhPT0iYnJhY2UiPyExOnIuY29tbWFzPj4wK3IucmFuZ2VzPj4wPT09MD8oci5pbnZhbGlkPSEwLCEwKTohMSxlLmlzSW52YWxpZEJyYWNlPXI9PnIudHlwZSE9PSJicmFjZSI/ITE6ci5pbnZhbGlkPT09ITB8fHIuZG9sbGFyPyEwOnIuY29tbWFzPj4wK3IucmFuZ2VzPj4wPT09MHx8ci5vcGVuIT09ITB8fHIuY2xvc2UhPT0hMD8oci5pbnZhbGlkPSEwLCEwKTohMSxlLmlzT3Blbk9yQ2xvc2U9cj0+ci50eXBlPT09Im9wZW4ifHxyLnR5cGU9PT0iY2xvc2UiPyEwOnIub3Blbj09PSEwfHxyLmNsb3NlPT09ITAsZS5yZWR1Y2U9cj0+ci5yZWR1Y2UoKG4saSk9PihpLnR5cGU9PT0idGV4dCImJm4ucHVzaChpLnZhbHVlKSxpLnR5cGU9PT0icmFuZ2UiJiYoaS50eXBlPSJ0ZXh0IiksbiksW10pLGUuZmxhdHRlbj0oLi4ucik9Pntjb25zdCBuPVtdLGk9dT0+e2ZvcihsZXQgcD0wO3A8dS5sZW5ndGg7cCsrKXtsZXQgbz11W3BdO0FycmF5LmlzQXJyYXkobyk/aShvKTpvIT09dm9pZCAwJiZuLnB1c2gobyl9cmV0dXJuIG59O3JldHVybiBpKHIpLG59fSkoUGUpO2NvbnN0IHd0PVBlO3ZhciBLZT0oZSxyPXt9KT0+e2xldCBuPShpLHU9e30pPT57bGV0IHA9ci5lc2NhcGVJbnZhbGlkJiZ3dC5pc0ludmFsaWRCcmFjZSh1KSxvPWkuaW52YWxpZD09PSEwJiZyLmVzY2FwZUludmFsaWQ9PT0hMCxkPSIiO2lmKGkudmFsdWUpcmV0dXJuKHB8fG8pJiZ3dC5pc09wZW5PckNsb3NlKGkpPyJcXCIraS52YWx1ZTppLnZhbHVlO2lmKGkudmFsdWUpcmV0dXJuIGkudmFsdWU7aWYoaS5ub2Rlcylmb3IobGV0IGYgb2YgaS5ub2RlcylkKz1uKGYpO3JldHVybiBkfTtyZXR1cm4gbihlKX07LyohCiogaXMtbnVtYmVyIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1udW1iZXI+CioKKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuCiogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgoqL3ZhciBCcj1mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PSJudW1iZXIiP2UtZT09PTA6dHlwZW9mIGU9PSJzdHJpbmciJiZlLnRyaW0oKSE9PSIiP051bWJlci5pc0Zpbml0ZT9OdW1iZXIuaXNGaW5pdGUoK2UpOmlzRmluaXRlKCtlKTohMX07LyohCiogdG8tcmVnZXgtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb21hdGNoL3RvLXJlZ2V4LXJhbmdlPgoqCiogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEpvbiBTY2hsaW5rZXJ0LgoqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4KKi9jb25zdCBTdD1CcixtZT0oZSxyLG4pPT57aWYoU3QoZSk9PT0hMSl0aHJvdyBuZXcgVHlwZUVycm9yKCJ0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhIG51bWJlciIpO2lmKHI9PT12b2lkIDB8fGU9PT1yKXJldHVybiBTdHJpbmcoZSk7aWYoU3Qocik9PT0hMSl0aHJvdyBuZXcgVHlwZUVycm9yKCJ0b1JlZ2V4UmFuZ2U6IGV4cGVjdGVkIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBudW1iZXIuIik7bGV0IGk9dGUoe3JlbGF4WmVyb3M6ITB9LG4pO3R5cGVvZiBpLnN0cmljdFplcm9zPT0iYm9vbGVhbiImJihpLnJlbGF4WmVyb3M9aS5zdHJpY3RaZXJvcz09PSExKTtsZXQgdT1TdHJpbmcoaS5yZWxheFplcm9zKSxwPVN0cmluZyhpLnNob3J0aGFuZCksbz1TdHJpbmcoaS5jYXB0dXJlKSxkPVN0cmluZyhpLndyYXApLGY9ZSsiOiIrcisiPSIrdStwK28rZDtpZihtZS5jYWNoZS5oYXNPd25Qcm9wZXJ0eShmKSlyZXR1cm4gbWUuY2FjaGVbZl0ucmVzdWx0O2xldCBfPU1hdGgubWluKGUsciksbT1NYXRoLm1heChlLHIpO2lmKE1hdGguYWJzKF8tbSk9PT0xKXtsZXQgaz1lKyJ8IityO3JldHVybiBpLmNhcHR1cmU/YCgke2t9KWA6aS53cmFwPT09ITE/azpgKD86JHtrfSlgfWxldCBTPVB0KGUpfHxQdChyKSx2PXttaW46ZSxtYXg6cixhOl8sYjptfSx6PVtdLEk9W107aWYoUyYmKHYuaXNQYWRkZWQ9Uyx2Lm1heExlbj1TdHJpbmcodi5tYXgpLmxlbmd0aCksXzwwKXtsZXQgaz1tPDA/TWF0aC5hYnMobSk6MTtJPUN0KGssTWF0aC5hYnMoXyksdixpKSxfPXYuYT0wfXJldHVybiBtPj0wJiYoej1DdChfLG0sdixpKSksdi5uZWdhdGl2ZXM9SSx2LnBvc2l0aXZlcz16LHYucmVzdWx0PXFyKEkseiksaS5jYXB0dXJlPT09ITA/di5yZXN1bHQ9YCgke3YucmVzdWx0fSlgOmkud3JhcCE9PSExJiZ6Lmxlbmd0aCtJLmxlbmd0aD4xJiYodi5yZXN1bHQ9YCg/OiR7di5yZXN1bHR9KWApLG1lLmNhY2hlW2ZdPXYsdi5yZXN1bHR9O2Z1bmN0aW9uIHFyKGUscixuKXtsZXQgaT1aZShlLHIsIi0iLCExKXx8W10sdT1aZShyLGUsIiIsITEpfHxbXSxwPVplKGUsciwiLT8iLCEwKXx8W107cmV0dXJuIGkuY29uY2F0KHApLmNvbmNhdCh1KS5qb2luKCJ8Iil9ZnVuY3Rpb24gR3IoZSxyKXtsZXQgbj0xLGk9MSx1PSR0KGUsbikscD1uZXcgU2V0KFtyXSk7Zm9yKDtlPD11JiZ1PD1yOylwLmFkZCh1KSxuKz0xLHU9JHQoZSxuKTtmb3IodT1PdChyKzEsaSktMTtlPHUmJnU8PXI7KXAuYWRkKHUpLGkrPTEsdT1PdChyKzEsaSktMTtyZXR1cm4gcD1bLi4ucF0scC5zb3J0KFpyKSxwfWZ1bmN0aW9uIFdyKGUscixuKXtpZihlPT09cilyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfTtsZXQgaT1LcihlLHIpLHU9aS5sZW5ndGgscD0iIixvPTA7Zm9yKGxldCBkPTA7ZDx1O2QrKyl7bGV0W2YsX109aVtkXTtmPT09Xz9wKz1mOmYhPT0iMCJ8fF8hPT0iOSI/cCs9WHIoZixfKTpvKyt9cmV0dXJuIG8mJihwKz1uLnNob3J0aGFuZD09PSEwPyJcXGQiOiJbMC05XSIpLHtwYXR0ZXJuOnAsY291bnQ6W29dLGRpZ2l0czp1fX1mdW5jdGlvbiBDdChlLHIsbixpKXtsZXQgdT1HcihlLHIpLHA9W10sbz1lLGQ7Zm9yKGxldCBmPTA7Zjx1Lmxlbmd0aDtmKyspe2xldCBfPXVbZl0sbT1XcihTdHJpbmcobyksU3RyaW5nKF8pLGkpLFM9IiI7aWYoIW4uaXNQYWRkZWQmJmQmJmQucGF0dGVybj09PW0ucGF0dGVybil7ZC5jb3VudC5sZW5ndGg+MSYmZC5jb3VudC5wb3AoKSxkLmNvdW50LnB1c2gobS5jb3VudFswXSksZC5zdHJpbmc9ZC5wYXR0ZXJuK0h0KGQuY291bnQpLG89XysxO2NvbnRpbnVlfW4uaXNQYWRkZWQmJihTPVZyKF8sbixpKSksbS5zdHJpbmc9UyttLnBhdHRlcm4rSHQobS5jb3VudCkscC5wdXNoKG0pLG89XysxLGQ9bX1yZXR1cm4gcH1mdW5jdGlvbiBaZShlLHIsbixpLHUpe2xldCBwPVtdO2ZvcihsZXQgbyBvZiBlKXtsZXR7c3RyaW5nOmR9PW87IWkmJiFrdChyLCJzdHJpbmciLGQpJiZwLnB1c2gobitkKSxpJiZrdChyLCJzdHJpbmciLGQpJiZwLnB1c2gobitkKX1yZXR1cm4gcH1mdW5jdGlvbiBLcihlLHIpe2xldCBuPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKW4ucHVzaChbZVtpXSxyW2ldXSk7cmV0dXJuIG59ZnVuY3Rpb24gWnIoZSxyKXtyZXR1cm4gZT5yPzE6cj5lPy0xOjB9ZnVuY3Rpb24ga3QoZSxyLG4pe3JldHVybiBlLnNvbWUoaT0+aVtyXT09PW4pfWZ1bmN0aW9uICR0KGUscil7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtcikrIjkiLnJlcGVhdChyKSl9ZnVuY3Rpb24gT3QoZSxyKXtyZXR1cm4gZS1lJU1hdGgucG93KDEwLHIpfWZ1bmN0aW9uIEh0KGUpe2xldFtyPTAsbj0iIl09ZTtyZXR1cm4gbnx8cj4xP2B7JHtyKyhuPyIsIituOiIiKX19YDoiIn1mdW5jdGlvbiBYcihlLHIsbil7cmV0dXJuYFske2V9JHtyLWU9PT0xPyIiOiItIn0ke3J9XWB9ZnVuY3Rpb24gUHQoZSl7cmV0dXJuL14tPygwKylcZC8udGVzdChlKX1mdW5jdGlvbiBWcihlLHIsbil7aWYoIXIuaXNQYWRkZWQpcmV0dXJuIGU7bGV0IGk9TWF0aC5hYnMoci5tYXhMZW4tU3RyaW5nKGUpLmxlbmd0aCksdT1uLnJlbGF4WmVyb3MhPT0hMTtzd2l0Y2goaSl7Y2FzZSAwOnJldHVybiIiO2Nhc2UgMTpyZXR1cm4gdT8iMD8iOiIwIjtjYXNlIDI6cmV0dXJuIHU/IjB7MCwyfSI6IjAwIjtkZWZhdWx0OnJldHVybiB1P2AwezAsJHtpfX1gOmAweyR7aX19YH19bWUuY2FjaGU9e30sbWUuY2xlYXJDYWNoZT0oKT0+bWUuY2FjaGU9e307dmFyIFlyPW1lOy8qIQoqIGZpbGwtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZpbGwtcmFuZ2U+CioKKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuCiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgoqL2NvbnN0IEpyPUhlLFR0PVlyLEl0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09Im9iamVjdCImJiFBcnJheS5pc0FycmF5KGUpLGVuPWU9PnI9PmU9PT0hMD9OdW1iZXIocik6U3RyaW5nKHIpLFhlPWU9PnR5cGVvZiBlPT0ibnVtYmVyInx8dHlwZW9mIGU9PSJzdHJpbmciJiZlIT09IiIsUmU9ZT0+TnVtYmVyLmlzSW50ZWdlcigrZSksVmU9ZT0+e2xldCByPWAke2V9YCxuPS0xO2lmKHJbMF09PT0iLSImJihyPXIuc2xpY2UoMSkpLHI9PT0iMCIpcmV0dXJuITE7Zm9yKDtyWysrbl09PT0iMCI7KTtyZXR1cm4gbj4wfSx0bj0oZSxyLG4pPT50eXBlb2YgZT09InN0cmluZyJ8fHR5cGVvZiByPT0ic3RyaW5nIj8hMDpuLnN0cmluZ2lmeT09PSEwLHJuPShlLHIsbik9PntpZihyPjApe2xldCBpPWVbMF09PT0iLSI/Ii0iOiIiO2kmJihlPWUuc2xpY2UoMSkpLGU9aStlLnBhZFN0YXJ0KGk/ci0xOnIsIjAiKX1yZXR1cm4gbj09PSExP1N0cmluZyhlKTplfSxMdD0oZSxyKT0+e2xldCBuPWVbMF09PT0iLSI/Ii0iOiIiO2ZvcihuJiYoZT1lLnNsaWNlKDEpLHItLSk7ZS5sZW5ndGg8cjspZT0iMCIrZTtyZXR1cm4gbj8iLSIrZTplfSxubj0oZSxyKT0+e2UubmVnYXRpdmVzLnNvcnQoKG8sZCk9Pm88ZD8tMTpvPmQ/MTowKSxlLnBvc2l0aXZlcy5zb3J0KChvLGQpPT5vPGQ/LTE6bz5kPzE6MCk7bGV0IG49ci5jYXB0dXJlPyIiOiI/OiIsaT0iIix1PSIiLHA7cmV0dXJuIGUucG9zaXRpdmVzLmxlbmd0aCYmKGk9ZS5wb3NpdGl2ZXMuam9pbigifCIpKSxlLm5lZ2F0aXZlcy5sZW5ndGgmJih1PWAtKCR7bn0ke2UubmVnYXRpdmVzLmpvaW4oInwiKX0pYCksaSYmdT9wPWAke2l9fCR7dX1gOnA9aXx8dSxyLndyYXA/YCgke259JHtwfSlgOnB9LGp0PShlLHIsbixpKT0+e2lmKG4pcmV0dXJuIFR0KGUscix0ZSh7d3JhcDohMX0saSkpO2xldCB1PVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7aWYoZT09PXIpcmV0dXJuIHU7bGV0IHA9U3RyaW5nLmZyb21DaGFyQ29kZShyKTtyZXR1cm5gWyR7dX0tJHtwfV1gfSx6dD0oZSxyLG4pPT57aWYoQXJyYXkuaXNBcnJheShlKSl7bGV0IGk9bi53cmFwPT09ITAsdT1uLmNhcHR1cmU/IiI6Ij86IjtyZXR1cm4gaT9gKCR7dX0ke2Uuam9pbigifCIpfSlgOmUuam9pbigifCIpfXJldHVybiBUdChlLHIsbil9LE50PSguLi5lKT0+bmV3IFJhbmdlRXJyb3IoIkludmFsaWQgcmFuZ2UgYXJndW1lbnRzOiAiK0pyLmluc3BlY3QoLi4uZSkpLER0PShlLHIsbik9PntpZihuLnN0cmljdFJhbmdlcz09PSEwKXRocm93IE50KFtlLHJdKTtyZXR1cm5bXX0sb249KGUscik9PntpZihyLnN0cmljdFJhbmdlcz09PSEwKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0ZXAgIiR7ZX0iIHRvIGJlIGEgbnVtYmVyYCk7cmV0dXJuW119LHNuPShlLHIsbj0xLGk9e30pPT57bGV0IHU9TnVtYmVyKGUpLHA9TnVtYmVyKHIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHUpfHwhTnVtYmVyLmlzSW50ZWdlcihwKSl7aWYoaS5zdHJpY3RSYW5nZXM9PT0hMCl0aHJvdyBOdChbZSxyXSk7cmV0dXJuW119dT09PTAmJih1PTApLHA9PT0wJiYocD0wKTtsZXQgbz11PnAsZD1TdHJpbmcoZSksZj1TdHJpbmcociksXz1TdHJpbmcobik7bj1NYXRoLm1heChNYXRoLmFicyhuKSwxKTtsZXQgbT1WZShkKXx8VmUoZil8fFZlKF8pLFM9bT9NYXRoLm1heChkLmxlbmd0aCxmLmxlbmd0aCxfLmxlbmd0aCk6MCx2PW09PT0hMSYmdG4oZSxyLGkpPT09ITEsej1pLnRyYW5zZm9ybXx8ZW4odik7aWYoaS50b1JlZ2V4JiZuPT09MSlyZXR1cm4ganQoTHQoZSxTKSxMdChyLFMpLCEwLGkpO2xldCBJPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfSxrPUc9PklbRzwwPyJuZWdhdGl2ZXMiOiJwb3NpdGl2ZXMiXS5wdXNoKE1hdGguYWJzKEcpKSxNPVtdLHE9MDtmb3IoO28/dT49cDp1PD1wOylpLnRvUmVnZXg9PT0hMCYmbj4xP2sodSk6TS5wdXNoKHJuKHoodSxxKSxTLHYpKSx1PW8/dS1uOnUrbixxKys7cmV0dXJuIGkudG9SZWdleD09PSEwP24+MT9ubihJLGkpOnp0KE0sbnVsbCx0ZSh7d3JhcDohMX0saSkpOk19LGFuPShlLHIsbj0xLGk9e30pPT57aWYoIVJlKGUpJiZlLmxlbmd0aD4xfHwhUmUocikmJnIubGVuZ3RoPjEpcmV0dXJuIER0KGUscixpKTtsZXQgdT1pLnRyYW5zZm9ybXx8KHY9PlN0cmluZy5mcm9tQ2hhckNvZGUodikpLHA9YCR7ZX1gLmNoYXJDb2RlQXQoMCksbz1gJHtyfWAuY2hhckNvZGVBdCgwKSxkPXA+byxmPU1hdGgubWluKHAsbyksXz1NYXRoLm1heChwLG8pO2lmKGkudG9SZWdleCYmbj09PTEpcmV0dXJuIGp0KGYsXywhMSxpKTtsZXQgbT1bXSxTPTA7Zm9yKDtkP3A+PW86cDw9bzspbS5wdXNoKHUocCxTKSkscD1kP3AtbjpwK24sUysrO3JldHVybiBpLnRvUmVnZXg9PT0hMD96dChtLG51bGwse3dyYXA6ITEsb3B0aW9uczppfSk6bX0sVGU9KGUscixuLGk9e30pPT57aWYocj09bnVsbCYmWGUoZSkpcmV0dXJuW2VdO2lmKCFYZShlKXx8IVhlKHIpKXJldHVybiBEdChlLHIsaSk7aWYodHlwZW9mIG49PSJmdW5jdGlvbiIpcmV0dXJuIFRlKGUsciwxLHt0cmFuc2Zvcm06bn0pO2lmKEl0KG4pKXJldHVybiBUZShlLHIsMCxuKTtsZXQgdT10ZSh7fSxpKTtyZXR1cm4gdS5jYXB0dXJlPT09ITAmJih1LndyYXA9ITApLG49bnx8dS5zdGVwfHwxLFJlKG4pP1JlKGUpJiZSZShyKT9zbihlLHIsbix1KTphbihlLHIsTWF0aC5tYXgoTWF0aC5hYnMobiksMSksdSk6biE9bnVsbCYmIUl0KG4pP29uKG4sdSk6VGUoZSxyLDEsbil9O3ZhciBNdD1UZTtjb25zdCB1bj1NdCxRdD1QZTt2YXIgY249KGUscj17fSk9PntsZXQgbj0oaSx1PXt9KT0+e2xldCBwPVF0LmlzSW52YWxpZEJyYWNlKHUpLG89aS5pbnZhbGlkPT09ITAmJnIuZXNjYXBlSW52YWxpZD09PSEwLGQ9cD09PSEwfHxvPT09ITAsZj1yLmVzY2FwZUludmFsaWQ9PT0hMD8iXFwiOiIiLF89IiI7aWYoaS5pc09wZW49PT0hMHx8aS5pc0Nsb3NlPT09ITApcmV0dXJuIGYraS52YWx1ZTtpZihpLnR5cGU9PT0ib3BlbiIpcmV0dXJuIGQ/ZitpLnZhbHVlOiIoIjtpZihpLnR5cGU9PT0iY2xvc2UiKXJldHVybiBkP2YraS52YWx1ZToiKSI7aWYoaS50eXBlPT09ImNvbW1hIilyZXR1cm4gaS5wcmV2LnR5cGU9PT0iY29tbWEiPyIiOmQ/aS52YWx1ZToifCI7aWYoaS52YWx1ZSlyZXR1cm4gaS52YWx1ZTtpZihpLm5vZGVzJiZpLnJhbmdlcz4wKXtsZXQgbT1RdC5yZWR1Y2UoaS5ub2RlcyksUz11biguLi5tLHVlKHRlKHt9LHIpLHt3cmFwOiExLHRvUmVnZXg6ITB9KSk7aWYoUy5sZW5ndGghPT0wKXJldHVybiBtLmxlbmd0aD4xJiZTLmxlbmd0aD4xP2AoJHtTfSlgOlN9aWYoaS5ub2Rlcylmb3IobGV0IG0gb2YgaS5ub2RlcylfKz1uKG0saSk7cmV0dXJuIF99O3JldHVybiBuKGUpfTtjb25zdCBsbj1NdCxVdD1LZSxFZT1QZSx2ZT0oZT0iIixyPSIiLG49ITEpPT57bGV0IGk9W107aWYoZT1bXS5jb25jYXQoZSkscj1bXS5jb25jYXQociksIXIubGVuZ3RoKXJldHVybiBlO2lmKCFlLmxlbmd0aClyZXR1cm4gbj9FZS5mbGF0dGVuKHIpLm1hcCh1PT5geyR7dX19YCk6cjtmb3IobGV0IHUgb2YgZSlpZihBcnJheS5pc0FycmF5KHUpKWZvcihsZXQgcCBvZiB1KWkucHVzaCh2ZShwLHIsbikpO2Vsc2UgZm9yKGxldCBwIG9mIHIpbj09PSEwJiZ0eXBlb2YgcD09InN0cmluZyImJihwPWB7JHtwfX1gKSxpLnB1c2goQXJyYXkuaXNBcnJheShwKT92ZSh1LHAsbik6dStwKTtyZXR1cm4gRWUuZmxhdHRlbihpKX07dmFyIHBuPShlLHI9e30pPT57bGV0IG49ci5yYW5nZUxpbWl0PT09dm9pZCAwPzFlMzpyLnJhbmdlTGltaXQsaT0odSxwPXt9KT0+e3UucXVldWU9W107bGV0IG89cCxkPXAucXVldWU7Zm9yKDtvLnR5cGUhPT0iYnJhY2UiJiZvLnR5cGUhPT0icm9vdCImJm8ucGFyZW50OylvPW8ucGFyZW50LGQ9by5xdWV1ZTtpZih1LmludmFsaWR8fHUuZG9sbGFyKXtkLnB1c2godmUoZC5wb3AoKSxVdCh1LHIpKSk7cmV0dXJufWlmKHUudHlwZT09PSJicmFjZSImJnUuaW52YWxpZCE9PSEwJiZ1Lm5vZGVzLmxlbmd0aD09PTIpe2QucHVzaCh2ZShkLnBvcCgpLFsie30iXSkpO3JldHVybn1pZih1Lm5vZGVzJiZ1LnJhbmdlcz4wKXtsZXQgUz1FZS5yZWR1Y2UodS5ub2Rlcyk7aWYoRWUuZXhjZWVkc0xpbWl0KC4uLlMsci5zdGVwLG4pKXRocm93IG5ldyBSYW5nZUVycm9yKCJleHBhbmRlZCBhcnJheSBsZW5ndGggZXhjZWVkcyByYW5nZSBsaW1pdC4gVXNlIG9wdGlvbnMucmFuZ2VMaW1pdCB0byBpbmNyZWFzZSBvciBkaXNhYmxlIHRoZSBsaW1pdC4iKTtsZXQgdj1sbiguLi5TLHIpO3YubGVuZ3RoPT09MCYmKHY9VXQodSxyKSksZC5wdXNoKHZlKGQucG9wKCksdikpLHUubm9kZXM9W107cmV0dXJufWxldCBmPUVlLmVuY2xvc2VCcmFjZSh1KSxfPXUucXVldWUsbT11O2Zvcig7bS50eXBlIT09ImJyYWNlIiYmbS50eXBlIT09InJvb3QiJiZtLnBhcmVudDspbT1tLnBhcmVudCxfPW0ucXVldWU7Zm9yKGxldCBTPTA7Uzx1Lm5vZGVzLmxlbmd0aDtTKyspe2xldCB2PXUubm9kZXNbU107aWYodi50eXBlPT09ImNvbW1hIiYmdS50eXBlPT09ImJyYWNlIil7Uz09PTEmJl8ucHVzaCgiIiksXy5wdXNoKCIiKTtjb250aW51ZX1pZih2LnR5cGU9PT0iY2xvc2UiKXtkLnB1c2godmUoZC5wb3AoKSxfLGYpKTtjb250aW51ZX1pZih2LnZhbHVlJiZ2LnR5cGUhPT0ib3BlbiIpe18ucHVzaCh2ZShfLnBvcCgpLHYudmFsdWUpKTtjb250aW51ZX12Lm5vZGVzJiZpKHYsdSl9cmV0dXJuIF99O3JldHVybiBFZS5mbGF0dGVuKGkoZSkpfSxobj17TUFYX0xFTkdUSDoxMDI0KjY0LENIQVJfMDoiMCIsQ0hBUl85OiI5IixDSEFSX1VQUEVSQ0FTRV9BOiJBIixDSEFSX0xPV0VSQ0FTRV9BOiJhIixDSEFSX1VQUEVSQ0FTRV9aOiJaIixDSEFSX0xPV0VSQ0FTRV9aOiJ6IixDSEFSX0xFRlRfUEFSRU5USEVTRVM6IigiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6IikiLENIQVJfQVNURVJJU0s6IioiLENIQVJfQU1QRVJTQU5EOiImIixDSEFSX0FUOiJAIixDSEFSX0JBQ0tTTEFTSDoiXFwiLENIQVJfQkFDS1RJQ0s6ImAiLENIQVJfQ0FSUklBR0VfUkVUVVJOOiJcciIsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDoiXiIsQ0hBUl9DT0xPTjoiOiIsQ0hBUl9DT01NQToiLCIsQ0hBUl9ET0xMQVI6IiQiLENIQVJfRE9UOiIuIixDSEFSX0RPVUJMRV9RVU9URTonIicsQ0hBUl9FUVVBTDoiPSIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOiIhIixDSEFSX0ZPUk1fRkVFRDoiXGYiLENIQVJfRk9SV0FSRF9TTEFTSDoiLyIsQ0hBUl9IQVNIOiIjIixDSEFSX0hZUEhFTl9NSU5VUzoiLSIsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6IjwiLENIQVJfTEVGVF9DVVJMWV9CUkFDRToieyIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOiJbIixDSEFSX0xJTkVfRkVFRDpgCmAsQ0hBUl9OT19CUkVBS19TUEFDRToiXHhBMCIsQ0hBUl9QRVJDRU5UOiIlIixDSEFSX1BMVVM6IisiLENIQVJfUVVFU1RJT05fTUFSSzoiPyIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOiI+IixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOiJ9IixDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOiJdIixDSEFSX1NFTUlDT0xPTjoiOyIsQ0hBUl9TSU5HTEVfUVVPVEU6IiciLENIQVJfU1BBQ0U6IiAiLENIQVJfVEFCOiIJIixDSEFSX1VOREVSU0NPUkU6Il8iLENIQVJfVkVSVElDQUxfTElORToifCIsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6Ilx1RkVGRiJ9O2NvbnN0IGZuPUtlLHtNQVhfTEVOR1RIOkZ0LENIQVJfQkFDS1NMQVNIOlllLENIQVJfQkFDS1RJQ0s6ZG4sQ0hBUl9DT01NQTpnbixDSEFSX0RPVDptbixDSEFSX0xFRlRfUEFSRU5USEVTRVM6dm4sQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzp5bixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6Ym4sQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpfbixDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6QnQsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpxdCxDSEFSX0RPVUJMRV9RVU9URTpFbixDSEFSX1NJTkdMRV9RVU9URTpBbixDSEFSX05PX0JSRUFLX1NQQUNFOnhuLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOlJufT1objt2YXIgd249KGUscj17fSk9PntpZih0eXBlb2YgZSE9InN0cmluZyIpdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0ZWQgYSBzdHJpbmciKTtsZXQgbj1yfHx7fSxpPXR5cGVvZiBuLm1heExlbmd0aD09Im51bWJlciI/TWF0aC5taW4oRnQsbi5tYXhMZW5ndGgpOkZ0O2lmKGUubGVuZ3RoPmkpdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGggKCR7ZS5sZW5ndGh9KSwgZXhjZWVkcyBtYXggY2hhcmFjdGVycyAoJHtpfSlgKTtsZXQgdT17dHlwZToicm9vdCIsaW5wdXQ6ZSxub2RlczpbXX0scD1bdV0sbz11LGQ9dSxmPTAsXz1lLmxlbmd0aCxtPTAsUz0wLHY7Y29uc3Qgej0oKT0+ZVttKytdLEk9az0+e2lmKGsudHlwZT09PSJ0ZXh0IiYmZC50eXBlPT09ImRvdCImJihkLnR5cGU9InRleHQiKSxkJiZkLnR5cGU9PT0idGV4dCImJmsudHlwZT09PSJ0ZXh0Iil7ZC52YWx1ZSs9ay52YWx1ZTtyZXR1cm59cmV0dXJuIG8ubm9kZXMucHVzaChrKSxrLnBhcmVudD1vLGsucHJldj1kLGQ9ayxrfTtmb3IoSSh7dHlwZToiYm9zIn0pO208XzspaWYobz1wW3AubGVuZ3RoLTFdLHY9eigpLCEodj09PVJufHx2PT09eG4pKXtpZih2PT09WWUpe0koe3R5cGU6InRleHQiLHZhbHVlOihyLmtlZXBFc2NhcGluZz92OiIiKSt6KCl9KTtjb250aW51ZX1pZih2PT09cXQpe0koe3R5cGU6InRleHQiLHZhbHVlOiJcXCIrdn0pO2NvbnRpbnVlfWlmKHY9PT1CdCl7ZisrO2xldCBrO2Zvcig7bTxfJiYoaz16KCkpOyl7aWYodis9ayxrPT09QnQpe2YrKztjb250aW51ZX1pZihrPT09WWUpe3YrPXooKTtjb250aW51ZX1pZihrPT09cXQmJihmLS0sZj09PTApKWJyZWFrfUkoe3R5cGU6InRleHQiLHZhbHVlOnZ9KTtjb250aW51ZX1pZih2PT09dm4pe289SSh7dHlwZToicGFyZW4iLG5vZGVzOltdfSkscC5wdXNoKG8pLEkoe3R5cGU6InRleHQiLHZhbHVlOnZ9KTtjb250aW51ZX1pZih2PT09eW4pe2lmKG8udHlwZSE9PSJwYXJlbiIpe0koe3R5cGU6InRleHQiLHZhbHVlOnZ9KTtjb250aW51ZX1vPXAucG9wKCksSSh7dHlwZToidGV4dCIsdmFsdWU6dn0pLG89cFtwLmxlbmd0aC0xXTtjb250aW51ZX1pZih2PT09RW58fHY9PT1Bbnx8dj09PWRuKXtsZXQgaz12LE07Zm9yKHIua2VlcFF1b3RlcyE9PSEwJiYodj0iIik7bTxfJiYoTT16KCkpOyl7aWYoTT09PVllKXt2Kz1NK3ooKTtjb250aW51ZX1pZihNPT09ayl7ci5rZWVwUXVvdGVzPT09ITAmJih2Kz1NKTticmVha312Kz1NfUkoe3R5cGU6InRleHQiLHZhbHVlOnZ9KTtjb250aW51ZX1pZih2PT09Ym4pe1MrKztsZXQgaz1kLnZhbHVlJiZkLnZhbHVlLnNsaWNlKC0xKT09PSIkInx8by5kb2xsYXI9PT0hMDtvPUkoe3R5cGU6ImJyYWNlIixvcGVuOiEwLGNsb3NlOiExLGRvbGxhcjprLGRlcHRoOlMsY29tbWFzOjAscmFuZ2VzOjAsbm9kZXM6W119KSxwLnB1c2gobyksSSh7dHlwZToib3BlbiIsdmFsdWU6dn0pO2NvbnRpbnVlfWlmKHY9PT1fbil7aWYoby50eXBlIT09ImJyYWNlIil7SSh7dHlwZToidGV4dCIsdmFsdWU6dn0pO2NvbnRpbnVlfWxldCBrPSJjbG9zZSI7bz1wLnBvcCgpLG8uY2xvc2U9ITAsSSh7dHlwZTprLHZhbHVlOnZ9KSxTLS0sbz1wW3AubGVuZ3RoLTFdO2NvbnRpbnVlfWlmKHY9PT1nbiYmUz4wKXtpZihvLnJhbmdlcz4wKXtvLnJhbmdlcz0wO2xldCBrPW8ubm9kZXMuc2hpZnQoKTtvLm5vZGVzPVtrLHt0eXBlOiJ0ZXh0Iix2YWx1ZTpmbihvKX1dfUkoe3R5cGU6ImNvbW1hIix2YWx1ZTp2fSksby5jb21tYXMrKztjb250aW51ZX1pZih2PT09bW4mJlM+MCYmby5jb21tYXM9PT0wKXtsZXQgaz1vLm5vZGVzO2lmKFM9PT0wfHxrLmxlbmd0aD09PTApe0koe3R5cGU6InRleHQiLHZhbHVlOnZ9KTtjb250aW51ZX1pZihkLnR5cGU9PT0iZG90Iil7aWYoby5yYW5nZT1bXSxkLnZhbHVlKz12LGQudHlwZT0icmFuZ2UiLG8ubm9kZXMubGVuZ3RoIT09MyYmby5ub2Rlcy5sZW5ndGghPT01KXtvLmludmFsaWQ9ITAsby5yYW5nZXM9MCxkLnR5cGU9InRleHQiO2NvbnRpbnVlfW8ucmFuZ2VzKyssby5hcmdzPVtdO2NvbnRpbnVlfWlmKGQudHlwZT09PSJyYW5nZSIpe2sucG9wKCk7bGV0IE09a1trLmxlbmd0aC0xXTtNLnZhbHVlKz1kLnZhbHVlK3YsZD1NLG8ucmFuZ2VzLS07Y29udGludWV9SSh7dHlwZToiZG90Iix2YWx1ZTp2fSk7Y29udGludWV9SSh7dHlwZToidGV4dCIsdmFsdWU6dn0pfWRvIGlmKG89cC5wb3AoKSxvLnR5cGUhPT0icm9vdCIpe28ubm9kZXMuZm9yRWFjaChxPT57cS5ub2Rlc3x8KHEudHlwZT09PSJvcGVuIiYmKHEuaXNPcGVuPSEwKSxxLnR5cGU9PT0iY2xvc2UiJiYocS5pc0Nsb3NlPSEwKSxxLm5vZGVzfHwocS50eXBlPSJ0ZXh0IikscS5pbnZhbGlkPSEwKX0pO2xldCBrPXBbcC5sZW5ndGgtMV0sTT1rLm5vZGVzLmluZGV4T2Yobyk7ay5ub2Rlcy5zcGxpY2UoTSwxLC4uLm8ubm9kZXMpfXdoaWxlKHAubGVuZ3RoPjApO3JldHVybiBJKHt0eXBlOiJlb3MifSksdX07Y29uc3QgU249S2UsQ249Y24sa249cG4sJG49d24sc2U9KGUscj17fSk9PntsZXQgbj1bXTtpZihBcnJheS5pc0FycmF5KGUpKWZvcihsZXQgaSBvZiBlKXtsZXQgdT1zZS5jcmVhdGUoaSxyKTtBcnJheS5pc0FycmF5KHUpP24ucHVzaCguLi51KTpuLnB1c2godSl9ZWxzZSBuPVtdLmNvbmNhdChzZS5jcmVhdGUoZSxyKSk7cmV0dXJuIHImJnIuZXhwYW5kPT09ITAmJnIubm9kdXBlcz09PSEwJiYobj1bLi4ubmV3IFNldChuKV0pLG59O3NlLnBhcnNlPShlLHI9e30pPT4kbihlLHIpLHNlLnN0cmluZ2lmeT0oZSxyPXt9KT0+U24odHlwZW9mIGU9PSJzdHJpbmciP3NlLnBhcnNlKGUscik6ZSxyKSxzZS5jb21waWxlPShlLHI9e30pPT4odHlwZW9mIGU9PSJzdHJpbmciJiYoZT1zZS5wYXJzZShlLHIpKSxDbihlLHIpKSxzZS5leHBhbmQ9KGUscj17fSk9Pnt0eXBlb2YgZT09InN0cmluZyImJihlPXNlLnBhcnNlKGUscikpO2xldCBuPWtuKGUscik7cmV0dXJuIHIubm9lbXB0eT09PSEwJiYobj1uLmZpbHRlcihCb29sZWFuKSksci5ub2R1cGVzPT09ITAmJihuPVsuLi5uZXcgU2V0KG4pXSksbn0sc2UuY3JlYXRlPShlLHI9e30pPT5lPT09IiJ8fGUubGVuZ3RoPDM/W2VdOnIuZXhwYW5kIT09ITA/c2UuY29tcGlsZShlLHIpOnNlLmV4cGFuZChlLHIpO3ZhciBPbj1zZSxBZT17ZXhwb3J0czp7fX0sY2U9SGU7ZnVuY3Rpb24gSWUoZSxyKXtmb3IodmFyIG49W10saT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgdT1lW2ldOyF1fHx1PT09Ii4ifHwodT09PSIuLiI/bi5sZW5ndGgmJm5bbi5sZW5ndGgtMV0hPT0iLi4iP24ucG9wKCk6ciYmbi5wdXNoKCIuLiIpOm4ucHVzaCh1KSl9cmV0dXJuIG59ZnVuY3Rpb24gd2UoZSl7Zm9yKHZhciByPWUubGVuZ3RoLTEsbj0wO248PXImJiFlW25dO24rKyk7Zm9yKHZhciBpPXI7aT49MCYmIWVbaV07aS0tKTtyZXR1cm4gbj09PTAmJmk9PT1yP2U6bj5pP1tdOmUuc2xpY2UobixpKzEpfXZhciBHdD0vXihbYS16QS1aXTp8W1xcXC9dezJ9W15cXFwvXStbXFxcL10rW15cXFwvXSspPyhbXFxcL10pPyhbXHNcU10qPykkLyxIbj0vXihbXHNcU10qPykoKD86XC57MSwyfXxbXlxcXC9dKz98KShcLlteLlwvXFxdKnwpKSg/OltcXFwvXSopJC8sSj17fTtmdW5jdGlvbiBMZShlKXt2YXIgcj1HdC5leGVjKGUpLG49KHJbMV18fCIiKSsoclsyXXx8IiIpLGk9clszXXx8IiIsdT1Ibi5leGVjKGkpLHA9dVsxXSxvPXVbMl0sZD11WzNdO3JldHVybltuLHAsbyxkXX1mdW5jdGlvbiBKZShlKXt2YXIgcj1HdC5leGVjKGUpLG49clsxXXx8IiIsaT0hIW4mJm5bMV0hPT0iOiI7cmV0dXJue2RldmljZTpuLGlzVW5jOmksaXNBYnNvbHV0ZTppfHwhIXJbMl0sdGFpbDpyWzNdfX1mdW5jdGlvbiBXdChlKXtyZXR1cm4iXFxcXCIrZS5yZXBsYWNlKC9eW1xcXC9dKy8sIiIpLnJlcGxhY2UoL1tcXFwvXSsvZywiXFwiKX1KLnJlc29sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9IiIscj0iIixuPSExLGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xO2ktLSl7dmFyIHU7aWYoaT49MD91PWFyZ3VtZW50c1tpXTplPyh1PXByb2Nlc3MuZW52WyI9IitlXSwoIXV8fHUuc3Vic3RyKDAsMykudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSsiXFwiKSYmKHU9ZSsiXFwiKSk6dT1wcm9jZXNzLmN3ZCgpLGNlLmlzU3RyaW5nKHUpKXtpZighdSljb250aW51ZX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzIik7dmFyIHA9SmUodSksbz1wLmRldmljZSxkPXAuaXNVbmMsZj1wLmlzQWJzb2x1dGUsXz1wLnRhaWw7aWYoIShvJiZlJiZvLnRvTG93ZXJDYXNlKCkhPT1lLnRvTG93ZXJDYXNlKCkpJiYoZXx8KGU9byksbnx8KHI9XysiXFwiK3Isbj1mKSxlJiZuKSlicmVha31yZXR1cm4gZCYmKGU9V3QoZSkpLHI9SWUoci5zcGxpdCgvW1xcXC9dKy8pLCFuKS5qb2luKCJcXCIpLGUrKG4/IlxcIjoiIikrcnx8Ii4ifSxKLm5vcm1hbGl6ZT1mdW5jdGlvbihlKXt2YXIgcj1KZShlKSxuPXIuZGV2aWNlLGk9ci5pc1VuYyx1PXIuaXNBYnNvbHV0ZSxwPXIudGFpbCxvPS9bXFxcL10kLy50ZXN0KHApO3JldHVybiBwPUllKHAuc3BsaXQoL1tcXFwvXSsvKSwhdSkuam9pbigiXFwiKSwhcCYmIXUmJihwPSIuIikscCYmbyYmKHArPSJcXCIpLGkmJihuPVd0KG4pKSxuKyh1PyJcXCI6IiIpK3B9LEouaXNBYnNvbHV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gSmUoZSkuaXNBYnNvbHV0ZX0sSi5qb2luPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt2YXIgbj1hcmd1bWVudHNbcl07aWYoIWNlLmlzU3RyaW5nKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoIkFyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzIik7biYmZS5wdXNoKG4pfXZhciBpPWUuam9pbigiXFwiKTtyZXR1cm4vXltcXFwvXXsyfVteXFxcL10vLnRlc3QoZVswXSl8fChpPWkucmVwbGFjZSgvXltcXFwvXXsyLH0vLCJcXCIpKSxKLm5vcm1hbGl6ZShpKX0sSi5yZWxhdGl2ZT1mdW5jdGlvbihlLHIpe2U9Si5yZXNvbHZlKGUpLHI9Si5yZXNvbHZlKHIpO2Zvcih2YXIgbj1lLnRvTG93ZXJDYXNlKCksaT1yLnRvTG93ZXJDYXNlKCksdT13ZShyLnNwbGl0KCJcXCIpKSxwPXdlKG4uc3BsaXQoIlxcIikpLG89d2UoaS5zcGxpdCgiXFwiKSksZD1NYXRoLm1pbihwLmxlbmd0aCxvLmxlbmd0aCksZj1kLF89MDtfPGQ7XysrKWlmKHBbX10hPT1vW19dKXtmPV87YnJlYWt9aWYoZj09MClyZXR1cm4gcjtmb3IodmFyIG09W10sXz1mO188cC5sZW5ndGg7XysrKW0ucHVzaCgiLi4iKTtyZXR1cm4gbT1tLmNvbmNhdCh1LnNsaWNlKGYpKSxtLmpvaW4oIlxcIil9LEouX21ha2VMb25nPWZ1bmN0aW9uKGUpe2lmKCFjZS5pc1N0cmluZyhlKSlyZXR1cm4gZTtpZighZSlyZXR1cm4iIjt2YXIgcj1KLnJlc29sdmUoZSk7cmV0dXJuL15bYS16QS1aXVw6XFwvLnRlc3Qocik/IlxcXFw/XFwiK3I6L15cXFxcW14/Ll0vLnRlc3Qocik/IlxcXFw/XFxVTkNcXCIrci5zdWJzdHJpbmcoMik6ZX0sSi5kaXJuYW1lPWZ1bmN0aW9uKGUpe3ZhciByPUxlKGUpLG49clswXSxpPXJbMV07cmV0dXJuIW4mJiFpPyIuIjooaSYmKGk9aS5zdWJzdHIoMCxpLmxlbmd0aC0xKSksbitpKX0sSi5iYXNlbmFtZT1mdW5jdGlvbihlLHIpe3ZhciBuPUxlKGUpWzJdO3JldHVybiByJiZuLnN1YnN0cigtMSpyLmxlbmd0aCk9PT1yJiYobj1uLnN1YnN0cigwLG4ubGVuZ3RoLXIubGVuZ3RoKSksbn0sSi5leHRuYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBMZShlKVszXX0sSi5mb3JtYXQ9ZnVuY3Rpb24oZSl7aWYoIWNlLmlzT2JqZWN0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIlBhcmFtZXRlciAncGF0aE9iamVjdCcgbXVzdCBiZSBhbiBvYmplY3QsIG5vdCAiK3R5cGVvZiBlKTt2YXIgcj1lLnJvb3R8fCIiO2lmKCFjZS5pc1N0cmluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKCIncGF0aE9iamVjdC5yb290JyBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCwgbm90ICIrdHlwZW9mIGUucm9vdCk7dmFyIG49ZS5kaXIsaT1lLmJhc2V8fCIiO3JldHVybiBuP25bbi5sZW5ndGgtMV09PT1KLnNlcD9uK2k6bitKLnNlcCtpOml9LEoucGFyc2U9ZnVuY3Rpb24oZSl7aWYoIWNlLmlzU3RyaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIlBhcmFtZXRlciAncGF0aFN0cmluZycgbXVzdCBiZSBhIHN0cmluZywgbm90ICIrdHlwZW9mIGUpO3ZhciByPUxlKGUpO2lmKCFyfHxyLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBwYXRoICciK2UrIiciKTtyZXR1cm57cm9vdDpyWzBdLGRpcjpyWzBdK3JbMV0uc2xpY2UoMCwtMSksYmFzZTpyWzJdLGV4dDpyWzNdLG5hbWU6clsyXS5zbGljZSgwLHJbMl0ubGVuZ3RoLXJbM10ubGVuZ3RoKX19LEouc2VwPSJcXCIsSi5kZWxpbWl0ZXI9IjsiO3ZhciBQbj0vXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC8sZWU9e307ZnVuY3Rpb24gamUoZSl7cmV0dXJuIFBuLmV4ZWMoZSkuc2xpY2UoMSl9ZWUucmVzb2x2ZT1mdW5jdGlvbigpe2Zvcih2YXIgZT0iIixyPSExLG49YXJndW1lbnRzLmxlbmd0aC0xO24+PS0xJiYhcjtuLS0pe3ZhciBpPW4+PTA/YXJndW1lbnRzW25dOnByb2Nlc3MuY3dkKCk7aWYoY2UuaXNTdHJpbmcoaSkpe2lmKCFpKWNvbnRpbnVlfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTtlPWkrIi8iK2Uscj1pWzBdPT09Ii8ifXJldHVybiBlPUllKGUuc3BsaXQoIi8iKSwhcikuam9pbigiLyIpLChyPyIvIjoiIikrZXx8Ii4ifSxlZS5ub3JtYWxpemU9ZnVuY3Rpb24oZSl7dmFyIHI9ZWUuaXNBYnNvbHV0ZShlKSxuPWUmJmVbZS5sZW5ndGgtMV09PT0iLyI7cmV0dXJuIGU9SWUoZS5zcGxpdCgiLyIpLCFyKS5qb2luKCIvIiksIWUmJiFyJiYoZT0iLiIpLGUmJm4mJihlKz0iLyIpLChyPyIvIjoiIikrZX0sZWUuaXNBYnNvbHV0ZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQXQoMCk9PT0iLyJ9LGVlLmpvaW49ZnVuY3Rpb24oKXtmb3IodmFyIGU9IiIscj0wO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3ZhciBuPWFyZ3VtZW50c1tyXTtpZighY2UuaXNTdHJpbmcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MiKTtuJiYoZT9lKz0iLyIrbjplKz1uKX1yZXR1cm4gZWUubm9ybWFsaXplKGUpfSxlZS5yZWxhdGl2ZT1mdW5jdGlvbihlLHIpe2U9ZWUucmVzb2x2ZShlKS5zdWJzdHIoMSkscj1lZS5yZXNvbHZlKHIpLnN1YnN0cigxKTtmb3IodmFyIG49d2UoZS5zcGxpdCgiLyIpKSxpPXdlKHIuc3BsaXQoIi8iKSksdT1NYXRoLm1pbihuLmxlbmd0aCxpLmxlbmd0aCkscD11LG89MDtvPHU7bysrKWlmKG5bb10hPT1pW29dKXtwPW87YnJlYWt9Zm9yKHZhciBkPVtdLG89cDtvPG4ubGVuZ3RoO28rKylkLnB1c2goIi4uIik7cmV0dXJuIGQ9ZC5jb25jYXQoaS5zbGljZShwKSksZC5qb2luKCIvIil9LGVlLl9tYWtlTG9uZz1mdW5jdGlvbihlKXtyZXR1cm4gZX0sZWUuZGlybmFtZT1mdW5jdGlvbihlKXt2YXIgcj1qZShlKSxuPXJbMF0saT1yWzFdO3JldHVybiFuJiYhaT8iLiI6KGkmJihpPWkuc3Vic3RyKDAsaS5sZW5ndGgtMSkpLG4raSl9LGVlLmJhc2VuYW1lPWZ1bmN0aW9uKGUscil7dmFyIG49amUoZSlbMl07cmV0dXJuIHImJm4uc3Vic3RyKC0xKnIubGVuZ3RoKT09PXImJihuPW4uc3Vic3RyKDAsbi5sZW5ndGgtci5sZW5ndGgpKSxufSxlZS5leHRuYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBqZShlKVszXX0sZWUuZm9ybWF0PWZ1bmN0aW9uKGUpe2lmKCFjZS5pc09iamVjdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJQYXJhbWV0ZXIgJ3BhdGhPYmplY3QnIG11c3QgYmUgYW4gb2JqZWN0LCBub3QgIit0eXBlb2YgZSk7dmFyIHI9ZS5yb290fHwiIjtpZighY2UuaXNTdHJpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcigiJ3BhdGhPYmplY3Qucm9vdCcgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIG5vdCAiK3R5cGVvZiBlLnJvb3QpO3ZhciBuPWUuZGlyP2UuZGlyK2VlLnNlcDoiIixpPWUuYmFzZXx8IiI7cmV0dXJuIG4raX0sZWUucGFyc2U9ZnVuY3Rpb24oZSl7aWYoIWNlLmlzU3RyaW5nKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIlBhcmFtZXRlciAncGF0aFN0cmluZycgbXVzdCBiZSBhIHN0cmluZywgbm90ICIrdHlwZW9mIGUpO3ZhciByPWplKGUpO2lmKCFyfHxyLmxlbmd0aCE9PTQpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBwYXRoICciK2UrIiciKTtyZXR1cm4gclsxXT1yWzFdfHwiIixyWzJdPXJbMl18fCIiLHJbM109clszXXx8IiIse3Jvb3Q6clswXSxkaXI6clswXStyWzFdLnNsaWNlKDAsLTEpLGJhc2U6clsyXSxleHQ6clszXSxuYW1lOnJbMl0uc2xpY2UoMCxyWzJdLmxlbmd0aC1yWzNdLmxlbmd0aCl9fSxlZS5zZXA9Ii8iLGVlLmRlbGltaXRlcj0iOiIsQWUuZXhwb3J0cz1lZSxBZS5leHBvcnRzLnBvc2l4PWVlLEFlLmV4cG9ydHMud2luMzI9Sjt2YXIgU2U9e307Y29uc3QgVG49QWUuZXhwb3J0cyxsZT0iXFxcXC8iLEt0PWBbXiR7bGV9XWAsZmU9IlxcLiIsSW49IlxcKyIsTG49IlxcPyIsemU9IlxcLyIsam49Iig/PS4pIixadD0iW14vXSIsZXQ9YCg/OiR7emV9fCQpYCxYdD1gKD86Xnwke3plfSlgLHR0PWAke2ZlfXsxLDJ9JHtldH1gLHpuPWAoPyEke2ZlfSlgLE5uPWAoPyEke1h0fSR7dHR9KWAsRG49YCg/ISR7ZmV9ezAsMX0ke2V0fSlgLE1uPWAoPyEke3R0fSlgLFFuPWBbXi4ke3plfV1gLFVuPWAke1p0fSo/YCxWdD17RE9UX0xJVEVSQUw6ZmUsUExVU19MSVRFUkFMOkluLFFNQVJLX0xJVEVSQUw6TG4sU0xBU0hfTElURVJBTDp6ZSxPTkVfQ0hBUjpqbixRTUFSSzpadCxFTkRfQU5DSE9SOmV0LERPVFNfU0xBU0g6dHQsTk9fRE9UOnpuLE5PX0RPVFM6Tm4sTk9fRE9UX1NMQVNIOkRuLE5PX0RPVFNfU0xBU0g6TW4sUU1BUktfTk9fRE9UOlFuLFNUQVI6VW4sU1RBUlRfQU5DSE9SOlh0fSxGbj11ZSh0ZSh7fSxWdCkse1NMQVNIX0xJVEVSQUw6YFske2xlfV1gLFFNQVJLOkt0LFNUQVI6YCR7S3R9Kj9gLERPVFNfU0xBU0g6YCR7ZmV9ezEsMn0oPzpbJHtsZX1dfCQpYCxOT19ET1Q6YCg/ISR7ZmV9KWAsTk9fRE9UUzpgKD8hKD86XnxbJHtsZX1dKSR7ZmV9ezEsMn0oPzpbJHtsZX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke2ZlfXswLDF9KD86WyR7bGV9XXwkKSlgLE5PX0RPVFNfU0xBU0g6YCg/ISR7ZmV9ezEsMn0oPzpbJHtsZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2xlfV1gLFNUQVJUX0FOQ0hPUjpgKD86XnxbJHtsZX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7bGV9XXwkKWB9KSxCbj17YWxudW06ImEtekEtWjAtOSIsYWxwaGE6ImEtekEtWiIsYXNjaWk6IlxceDAwLVxceDdGIixibGFuazoiIFxcdCIsY250cmw6IlxceDAwLVxceDFGXFx4N0YiLGRpZ2l0OiIwLTkiLGdyYXBoOiJcXHgyMS1cXHg3RSIsbG93ZXI6ImEteiIscHJpbnQ6IlxceDIwLVxceDdFICIscHVuY3Q6IlxcLSFcIiMkJSYnKClcXCorLC4vOjs8PT4/QFtcXF1eX2B7fH1+IixzcGFjZToiIFxcdFxcclxcblxcdlxcZiIsdXBwZXI6IkEtWiIsd29yZDoiQS1aYS16MC05XyIseGRpZ2l0OiJBLUZhLWYwLTkifTt2YXIgTmU9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6Qm4sUkVHRVhfQkFDS1NMQVNIOi9cXCg/IVsqKz9eJHt9KHwpW1xdXSkvZyxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzovXlteQCFbXF0uLCQqKz9ee30oKXxcXC9dKy8sUkVHRVhfU1BFQ0lBTF9DSEFSUzovWy0qKz8uXiR7fSh8KVtcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcPykoKFxXKShcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXV0pL2csUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDovKD86XFsuKj9bXlxcXVxdfFxcKD89LikpL2csUkVQTEFDRU1FTlRTOnsiKioqIjoiKiIsIioqLyoqIjoiKioiLCIqKi8qKi8qKiI6IioqIn0sQ0hBUl8wOjQ4LENIQVJfOTo1NyxDSEFSX1VQUEVSQ0FTRV9BOjY1LENIQVJfTE9XRVJDQVNFX0E6OTcsQ0hBUl9VUFBFUkNBU0VfWjo5MCxDSEFSX0xPV0VSQ0FTRV9aOjEyMixDSEFSX0xFRlRfUEFSRU5USEVTRVM6NDAsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzo0MSxDSEFSX0FTVEVSSVNLOjQyLENIQVJfQU1QRVJTQU5EOjM4LENIQVJfQVQ6NjQsQ0hBUl9CQUNLV0FSRF9TTEFTSDo5MixDSEFSX0NBUlJJQUdFX1JFVFVSTjoxMyxDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOjk0LENIQVJfQ09MT046NTgsQ0hBUl9DT01NQTo0NCxDSEFSX0RPVDo0NixDSEFSX0RPVUJMRV9RVU9URTozNCxDSEFSX0VRVUFMOjYxLENIQVJfRVhDTEFNQVRJT05fTUFSSzozMyxDSEFSX0ZPUk1fRkVFRDoxMixDSEFSX0ZPUldBUkRfU0xBU0g6NDcsQ0hBUl9HUkFWRV9BQ0NFTlQ6OTYsQ0hBUl9IQVNIOjM1LENIQVJfSFlQSEVOX01JTlVTOjQ1LENIQVJfTEVGVF9BTkdMRV9CUkFDS0VUOjYwLENIQVJfTEVGVF9DVVJMWV9CUkFDRToxMjMsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOjkxLENIQVJfTElORV9GRUVEOjEwLENIQVJfTk9fQlJFQUtfU1BBQ0U6MTYwLENIQVJfUEVSQ0VOVDozNyxDSEFSX1BMVVM6NDMsQ0hBUl9RVUVTVElPTl9NQVJLOjYzLENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDo2MixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOjEyNSxDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUOjkzLENIQVJfU0VNSUNPTE9OOjU5LENIQVJfU0lOR0xFX1FVT1RFOjM5LENIQVJfU1BBQ0U6MzIsQ0hBUl9UQUI6OSxDSEFSX1VOREVSU0NPUkU6OTUsQ0hBUl9WRVJUSUNBTF9MSU5FOjEyNCxDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTo2NTI3OSxTRVA6VG4uc2VwLGV4dGdsb2JDaGFycyhlKXtyZXR1cm57IiEiOnt0eXBlOiJuZWdhdGUiLG9wZW46Iig/Oig/ISg/OiIsY2xvc2U6YCkpJHtlLlNUQVJ9KWB9LCI/Ijp7dHlwZToicW1hcmsiLG9wZW46Iig/OiIsY2xvc2U6Iik/In0sIisiOnt0eXBlOiJwbHVzIixvcGVuOiIoPzoiLGNsb3NlOiIpKyJ9LCIqIjp7dHlwZToic3RhciIsb3BlbjoiKD86IixjbG9zZToiKSoifSwiQCI6e3R5cGU6ImF0IixvcGVuOiIoPzoiLGNsb3NlOiIpIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT0hMD9GbjpWdH19OyhmdW5jdGlvbihlKXtjb25zdCByPUFlLmV4cG9ydHMse1JFR0VYX0JBQ0tTTEFTSDpuLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6aSxSRUdFWF9TUEVDSUFMX0NIQVJTOnUsUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6cH09TmU7ZS5pc09iamVjdD1vPT5vIT09bnVsbCYmdHlwZW9mIG89PSJvYmplY3QiJiYhQXJyYXkuaXNBcnJheShvKSxlLmhhc1JlZ2V4Q2hhcnM9bz0+dS50ZXN0KG8pLGUuaXNSZWdleENoYXI9bz0+by5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnMobyksZS5lc2NhcGVSZWdleD1vPT5vLnJlcGxhY2UocCwiXFwkMSIpLGUudG9Qb3NpeFNsYXNoZXM9bz0+by5yZXBsYWNlKG4sIi8iKSxlLnJlbW92ZUJhY2tzbGFzaGVzPW89Pm8ucmVwbGFjZShpLGQ9PmQ9PT0iXFwiPyIiOmQpLGUuc3VwcG9ydHNMb29rYmVoaW5kcz0oKT0+e2NvbnN0IG89cHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpLnNwbGl0KCIuIikubWFwKE51bWJlcik7cmV0dXJuIG8ubGVuZ3RoPT09MyYmb1swXT49OXx8b1swXT09PTgmJm9bMV0+PTEwfSxlLmlzV2luZG93cz1vPT5vJiZ0eXBlb2Ygby53aW5kb3dzPT0iYm9vbGVhbiI/by53aW5kb3dzOnIuc2VwPT09IlxcIixlLmVzY2FwZUxhc3Q9KG8sZCxmKT0+e2NvbnN0IF89by5sYXN0SW5kZXhPZihkLGYpO3JldHVybiBfPT09LTE/bzpvW18tMV09PT0iXFwiP2UuZXNjYXBlTGFzdChvLGQsXy0xKTpgJHtvLnNsaWNlKDAsXyl9XFwke28uc2xpY2UoXyl9YH0sZS5yZW1vdmVQcmVmaXg9KG8sZD17fSk9PntsZXQgZj1vO3JldHVybiBmLnN0YXJ0c1dpdGgoIi4vIikmJihmPWYuc2xpY2UoMiksZC5wcmVmaXg9Ii4vIiksZn0sZS53cmFwT3V0cHV0PShvLGQ9e30sZj17fSk9Pntjb25zdCBfPWYuY29udGFpbnM/IiI6Il4iLG09Zi5jb250YWlucz8iIjoiJCI7bGV0IFM9YCR7X30oPzoke299KSR7bX1gO3JldHVybiBkLm5lZ2F0ZWQ9PT0hMCYmKFM9YCg/Ol4oPyEke1N9KS4qJClgKSxTfX0pKFNlKTtjb25zdCBZdD1TZSx7Q0hBUl9BU1RFUklTSzpydCxDSEFSX0FUOnFuLENIQVJfQkFDS1dBUkRfU0xBU0g6Q2UsQ0hBUl9DT01NQTpHbixDSEFSX0RPVDpudCxDSEFSX0VYQ0xBTUFUSU9OX01BUks6b3QsQ0hBUl9GT1JXQVJEX1NMQVNIOkp0LENIQVJfTEVGVF9DVVJMWV9CUkFDRTpzdCxDSEFSX0xFRlRfUEFSRU5USEVTRVM6YXQsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlduLENIQVJfUExVUzpLbixDSEFSX1FVRVNUSU9OX01BUks6ZXIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpabixDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOnRyLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6WG59PU5lLHJyPWU9PmU9PT1KdHx8ZT09PUNlLG5yPWU9PntlLmlzUHJlZml4IT09ITAmJihlLmRlcHRoPWUuaXNHbG9ic3Rhcj8xLzA6MSl9O3ZhciBWbj0oZSxyKT0+e2NvbnN0IG49cnx8e30saT1lLmxlbmd0aC0xLHU9bi5wYXJ0cz09PSEwfHxuLnNjYW5Ub0VuZD09PSEwLHA9W10sbz1bXSxkPVtdO2xldCBmPWUsXz0tMSxtPTAsUz0wLHY9ITEsej0hMSxJPSExLGs9ITEsTT0hMSxxPSExLEc9ITEsVT0hMSxBPSExLEU9ITEsSD0wLCQseCxPPXt2YWx1ZToiIixkZXB0aDowLGlzR2xvYjohMX07Y29uc3QgUT0oKT0+Xz49aSx5PSgpPT5mLmNoYXJDb2RlQXQoXysxKSxGPSgpPT4oJD14LGYuY2hhckNvZGVBdCgrK18pKTtmb3IoO188aTspe3g9RigpO2xldCBsO2lmKHg9PT1DZSl7Rz1PLmJhY2tzbGFzaGVzPSEwLHg9RigpLHg9PT1zdCYmKHE9ITApO2NvbnRpbnVlfWlmKHE9PT0hMHx8eD09PXN0KXtmb3IoSCsrO1EoKSE9PSEwJiYoeD1GKCkpOyl7aWYoeD09PUNlKXtHPU8uYmFja3NsYXNoZXM9ITAsRigpO2NvbnRpbnVlfWlmKHg9PT1zdCl7SCsrO2NvbnRpbnVlfWlmKHEhPT0hMCYmeD09PW50JiYoeD1GKCkpPT09bnQpe2lmKHY9Ty5pc0JyYWNlPSEwLEk9Ty5pc0dsb2I9ITAsRT0hMCx1PT09ITApY29udGludWU7YnJlYWt9aWYocSE9PSEwJiZ4PT09R24pe2lmKHY9Ty5pc0JyYWNlPSEwLEk9Ty5pc0dsb2I9ITAsRT0hMCx1PT09ITApY29udGludWU7YnJlYWt9aWYoeD09PVpuJiYoSC0tLEg9PT0wKSl7cT0hMSx2PU8uaXNCcmFjZT0hMCxFPSEwO2JyZWFrfX1pZih1PT09ITApY29udGludWU7YnJlYWt9aWYoeD09PUp0KXtpZihwLnB1c2goXyksby5wdXNoKE8pLE89e3ZhbHVlOiIiLGRlcHRoOjAsaXNHbG9iOiExfSxFPT09ITApY29udGludWU7aWYoJD09PW50JiZfPT09bSsxKXttKz0yO2NvbnRpbnVlfVM9XysxO2NvbnRpbnVlfWlmKG4ubm9leHQhPT0hMCYmKHg9PT1Lbnx8eD09PXFufHx4PT09cnR8fHg9PT1lcnx8eD09PW90KSYmeSgpPT09YXQpe2lmKEk9Ty5pc0dsb2I9ITAsaz1PLmlzRXh0Z2xvYj0hMCxFPSEwLHg9PT1vdCYmXz09PW0mJihBPSEwKSx1PT09ITApe2Zvcig7USgpIT09ITAmJih4PUYoKSk7KXtpZih4PT09Q2Upe0c9Ty5iYWNrc2xhc2hlcz0hMCx4PUYoKTtjb250aW51ZX1pZih4PT09dHIpe0k9Ty5pc0dsb2I9ITAsRT0hMDticmVha319Y29udGludWV9YnJlYWt9aWYoeD09PXJ0KXtpZigkPT09cnQmJihNPU8uaXNHbG9ic3Rhcj0hMCksST1PLmlzR2xvYj0hMCxFPSEwLHU9PT0hMCljb250aW51ZTticmVha31pZih4PT09ZXIpe2lmKEk9Ty5pc0dsb2I9ITAsRT0hMCx1PT09ITApY29udGludWU7YnJlYWt9aWYoeD09PVduKXtmb3IoO1EoKSE9PSEwJiYobD1GKCkpOyl7aWYobD09PUNlKXtHPU8uYmFja3NsYXNoZXM9ITAsRigpO2NvbnRpbnVlfWlmKGw9PT1Ybil7ej1PLmlzQnJhY2tldD0hMCxJPU8uaXNHbG9iPSEwLEU9ITA7YnJlYWt9fWlmKHU9PT0hMCljb250aW51ZTticmVha31pZihuLm5vbmVnYXRlIT09ITAmJng9PT1vdCYmXz09PW0pe1U9Ty5uZWdhdGVkPSEwLG0rKztjb250aW51ZX1pZihuLm5vcGFyZW4hPT0hMCYmeD09PWF0KXtpZihJPU8uaXNHbG9iPSEwLHU9PT0hMCl7Zm9yKDtRKCkhPT0hMCYmKHg9RigpKTspe2lmKHg9PT1hdCl7Rz1PLmJhY2tzbGFzaGVzPSEwLHg9RigpO2NvbnRpbnVlfWlmKHg9PT10cil7RT0hMDticmVha319Y29udGludWV9YnJlYWt9aWYoST09PSEwKXtpZihFPSEwLHU9PT0hMCljb250aW51ZTticmVha319bi5ub2V4dD09PSEwJiYoaz0hMSxJPSExKTtsZXQgdD1mLHM9IiIsYT0iIjttPjAmJihzPWYuc2xpY2UoMCxtKSxmPWYuc2xpY2UobSksUy09bSksdCYmST09PSEwJiZTPjA/KHQ9Zi5zbGljZSgwLFMpLGE9Zi5zbGljZShTKSk6ST09PSEwPyh0PSIiLGE9Zik6dD1mLHQmJnQhPT0iIiYmdCE9PSIvIiYmdCE9PWYmJnJyKHQuY2hhckNvZGVBdCh0Lmxlbmd0aC0xKSkmJih0PXQuc2xpY2UoMCwtMSkpLG4udW5lc2NhcGU9PT0hMCYmKGEmJihhPVl0LnJlbW92ZUJhY2tzbGFzaGVzKGEpKSx0JiZHPT09ITAmJih0PVl0LnJlbW92ZUJhY2tzbGFzaGVzKHQpKSk7Y29uc3QgYz17cHJlZml4OnMsaW5wdXQ6ZSxzdGFydDptLGJhc2U6dCxnbG9iOmEsaXNCcmFjZTp2LGlzQnJhY2tldDp6LGlzR2xvYjpJLGlzRXh0Z2xvYjprLGlzR2xvYnN0YXI6TSxuZWdhdGVkOlUsbmVnYXRlZEV4dGdsb2I6QX07aWYobi50b2tlbnM9PT0hMCYmKGMubWF4RGVwdGg9MCxycih4KXx8by5wdXNoKE8pLGMudG9rZW5zPW8pLG4ucGFydHM9PT0hMHx8bi50b2tlbnM9PT0hMCl7bGV0IGw7Zm9yKGxldCBoPTA7aDxwLmxlbmd0aDtoKyspe2NvbnN0IGc9bD9sKzE6bSxiPXBbaF0sUj1lLnNsaWNlKGcsYik7bi50b2tlbnMmJihoPT09MCYmbSE9PTA/KG9baF0uaXNQcmVmaXg9ITAsb1toXS52YWx1ZT1zKTpvW2hdLnZhbHVlPVIsbnIob1toXSksYy5tYXhEZXB0aCs9b1toXS5kZXB0aCksKGghPT0wfHxSIT09IiIpJiZkLnB1c2goUiksbD1ifWlmKGwmJmwrMTxlLmxlbmd0aCl7Y29uc3QgaD1lLnNsaWNlKGwrMSk7ZC5wdXNoKGgpLG4udG9rZW5zJiYob1tvLmxlbmd0aC0xXS52YWx1ZT1oLG5yKG9bby5sZW5ndGgtMV0pLGMubWF4RGVwdGgrPW9bby5sZW5ndGgtMV0uZGVwdGgpfWMuc2xhc2hlcz1wLGMucGFydHM9ZH1yZXR1cm4gY307Y29uc3QgRGU9TmUsYWU9U2Use01BWF9MRU5HVEg6TWUsUE9TSVhfUkVHRVhfU09VUkNFOlluLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOkpuLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjplbyxSRVBMQUNFTUVOVFM6b3J9PURlLHRvPShlLHIpPT57aWYodHlwZW9mIHIuZXhwYW5kUmFuZ2U9PSJmdW5jdGlvbiIpcmV0dXJuIHIuZXhwYW5kUmFuZ2UoLi4uZSxyKTtlLnNvcnQoKTtjb25zdCBuPWBbJHtlLmpvaW4oIi0iKX1dYDt0cnl7bmV3IFJlZ0V4cChuKX1jYXRjaHtyZXR1cm4gZS5tYXAoaT0+YWUuZXNjYXBlUmVnZXgoaSkpLmpvaW4oIi4uIil9cmV0dXJuIG59LHhlPShlLHIpPT5gTWlzc2luZyAke2V9OiAiJHtyfSIgLSB1c2UgIlxcXFwke3J9IiB0byBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnNgLGl0PShlLHIpPT57aWYodHlwZW9mIGUhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIGEgc3RyaW5nIik7ZT1vcltlXXx8ZTtjb25zdCBuPXRlKHt9LHIpLGk9dHlwZW9mIG4ubWF4TGVuZ3RoPT0ibnVtYmVyIj9NYXRoLm1pbihNZSxuLm1heExlbmd0aCk6TWU7bGV0IHU9ZS5sZW5ndGg7aWYodT5pKXRocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke3V9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7aX1gKTtjb25zdCBwPXt0eXBlOiJib3MiLHZhbHVlOiIiLG91dHB1dDpuLnByZXBlbmR8fCIifSxvPVtwXSxkPW4uY2FwdHVyZT8iIjoiPzoiLGY9YWUuaXNXaW5kb3dzKHIpLF89RGUuZ2xvYkNoYXJzKGYpLG09RGUuZXh0Z2xvYkNoYXJzKF8pLHtET1RfTElURVJBTDpTLFBMVVNfTElURVJBTDp2LFNMQVNIX0xJVEVSQUw6eixPTkVfQ0hBUjpJLERPVFNfU0xBU0g6ayxOT19ET1Q6TSxOT19ET1RfU0xBU0g6cSxOT19ET1RTX1NMQVNIOkcsUU1BUks6VSxRTUFSS19OT19ET1Q6QSxTVEFSOkUsU1RBUlRfQU5DSE9SOkh9PV8sJD1DPT5gKCR7ZH0oPzooPyEke0h9JHtDLmRvdD9rOlN9KS4pKj8pYCx4PW4uZG90PyIiOk0sTz1uLmRvdD9VOkE7bGV0IFE9bi5iYXNoPT09ITA/JChuKTpFO24uY2FwdHVyZSYmKFE9YCgke1F9KWApLHR5cGVvZiBuLm5vZXh0PT0iYm9vbGVhbiImJihuLm5vZXh0Z2xvYj1uLm5vZXh0KTtjb25zdCB5PXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90Om4uZG90PT09ITAsY29uc3VtZWQ6IiIsb3V0cHV0OiIiLHByZWZpeDoiIixiYWNrdHJhY2s6ITEsbmVnYXRlZDohMSxicmFja2V0czowLGJyYWNlczowLHBhcmVuczowLHF1b3RlczowLGdsb2JzdGFyOiExLHRva2VuczpvfTtlPWFlLnJlbW92ZVByZWZpeChlLHkpLHU9ZS5sZW5ndGg7Y29uc3QgRj1bXSx0PVtdLHM9W107bGV0IGE9cCxjO2NvbnN0IGw9KCk9PnkuaW5kZXg9PT11LTEsaD15LnBlZWs9KEM9MSk9PmVbeS5pbmRleCtDXSxnPXkuYWR2YW5jZT0oKT0+ZVsrK3kuaW5kZXhdfHwiIixiPSgpPT5lLnNsaWNlKHkuaW5kZXgrMSksUj0oQz0iIixCPTApPT57eS5jb25zdW1lZCs9Qyx5LmluZGV4Kz1CfSxQPUM9Pnt5Lm91dHB1dCs9Qy5vdXRwdXQhPW51bGw/Qy5vdXRwdXQ6Qy52YWx1ZSxSKEMudmFsdWUpfSxMPSgpPT57bGV0IEM9MTtmb3IoO2goKT09PSIhIiYmKGgoMikhPT0iKCJ8fGgoMyk9PT0iPyIpOylnKCkseS5zdGFydCsrLEMrKztyZXR1cm4gQyUyPT09MD8hMTooeS5uZWdhdGVkPSEwLHkuc3RhcnQrKywhMCl9LE49Qz0+e3lbQ10rKyxzLnB1c2goQyl9LGo9Qz0+e3lbQ10tLSxzLnBvcCgpfSxUPUM9PntpZihhLnR5cGU9PT0iZ2xvYnN0YXIiKXtjb25zdCBCPXkuYnJhY2VzPjAmJihDLnR5cGU9PT0iY29tbWEifHxDLnR5cGU9PT0iYnJhY2UiKSx3PUMuZXh0Z2xvYj09PSEwfHxGLmxlbmd0aCYmKEMudHlwZT09PSJwaXBlInx8Qy50eXBlPT09InBhcmVuIik7Qy50eXBlIT09InNsYXNoIiYmQy50eXBlIT09InBhcmVuIiYmIUImJiF3JiYoeS5vdXRwdXQ9eS5vdXRwdXQuc2xpY2UoMCwtYS5vdXRwdXQubGVuZ3RoKSxhLnR5cGU9InN0YXIiLGEudmFsdWU9IioiLGEub3V0cHV0PVEseS5vdXRwdXQrPWEub3V0cHV0KX1pZihGLmxlbmd0aCYmQy50eXBlIT09InBhcmVuIiYmKEZbRi5sZW5ndGgtMV0uaW5uZXIrPUMudmFsdWUpLChDLnZhbHVlfHxDLm91dHB1dCkmJlAoQyksYSYmYS50eXBlPT09InRleHQiJiZDLnR5cGU9PT0idGV4dCIpe2EudmFsdWUrPUMudmFsdWUsYS5vdXRwdXQ9KGEub3V0cHV0fHwiIikrQy52YWx1ZTtyZXR1cm59Qy5wcmV2PWEsby5wdXNoKEMpLGE9Q30sSz0oQyxCKT0+e2NvbnN0IHc9dWUodGUoe30sbVtCXSkse2NvbmRpdGlvbnM6MSxpbm5lcjoiIn0pO3cucHJldj1hLHcucGFyZW5zPXkucGFyZW5zLHcub3V0cHV0PXkub3V0cHV0O2NvbnN0IEQ9KG4uY2FwdHVyZT8iKCI6IiIpK3cub3BlbjtOKCJwYXJlbnMiKSxUKHt0eXBlOkMsdmFsdWU6QixvdXRwdXQ6eS5vdXRwdXQ/IiI6SX0pLFQoe3R5cGU6InBhcmVuIixleHRnbG9iOiEwLHZhbHVlOmcoKSxvdXRwdXQ6RH0pLEYucHVzaCh3KX0scmU9Qz0+e2xldCBCPUMuY2xvc2UrKG4uY2FwdHVyZT8iKSI6IiIpLHc7aWYoQy50eXBlPT09Im5lZ2F0ZSIpe2xldCBEPVE7aWYoQy5pbm5lciYmQy5pbm5lci5sZW5ndGg+MSYmQy5pbm5lci5pbmNsdWRlcygiLyIpJiYoRD0kKG4pKSwoRCE9PVF8fGwoKXx8L15cKSskLy50ZXN0KGIoKSkpJiYoQj1DLmNsb3NlPWApJCkpJHtEfWApLEMuaW5uZXIuaW5jbHVkZXMoIioiKSYmKHc9YigpKSYmL15cLlteXFwvLl0rJC8udGVzdCh3KSl7Y29uc3QgVz1pdCh3LHVlKHRlKHt9LHIpLHtmYXN0cGF0aHM6ITF9KSkub3V0cHV0O0I9Qy5jbG9zZT1gKSR7V30pJHtEfSlgfUMucHJldi50eXBlPT09ImJvcyImJih5Lm5lZ2F0ZWRFeHRnbG9iPSEwKX1UKHt0eXBlOiJwYXJlbiIsZXh0Z2xvYjohMCx2YWx1ZTpjLG91dHB1dDpCfSksaigicGFyZW5zIil9O2lmKG4uZmFzdHBhdGhzIT09ITEmJiEvKF5bKiFdfFsvKClbXF17fSJdKS8udGVzdChlKSl7bGV0IEM9ITEsQj1lLnJlcGxhY2UoZW8sKHcsRCxXLFYsWixiZSk9PlY9PT0iXFwiPyhDPSEwLHcpOlY9PT0iPyI/RD9EK1YrKFo/VS5yZXBlYXQoWi5sZW5ndGgpOiIiKTpiZT09PTA/TysoWj9VLnJlcGVhdChaLmxlbmd0aCk6IiIpOlUucmVwZWF0KFcubGVuZ3RoKTpWPT09Ii4iP1MucmVwZWF0KFcubGVuZ3RoKTpWPT09IioiP0Q/RCtWKyhaP1E6IiIpOlE6RD93OmBcXCR7d31gKTtyZXR1cm4gQz09PSEwJiYobi51bmVzY2FwZT09PSEwP0I9Qi5yZXBsYWNlKC9cXC9nLCIiKTpCPUIucmVwbGFjZSgvXFwrL2csdz0+dy5sZW5ndGglMj09PTA/IlxcXFwiOnc/IlxcIjoiIikpLEI9PT1lJiZuLmNvbnRhaW5zPT09ITA/KHkub3V0cHV0PWUseSk6KHkub3V0cHV0PWFlLndyYXBPdXRwdXQoQix5LHIpLHkpfWZvcig7IWwoKTspe2lmKGM9ZygpLGM9PT0iXDAiKWNvbnRpbnVlO2lmKGM9PT0iXFwiKXtjb25zdCB3PWgoKTtpZih3PT09Ii8iJiZuLmJhc2ghPT0hMHx8dz09PSIuInx8dz09PSI7Iiljb250aW51ZTtpZighdyl7Yys9IlxcIixUKHt0eXBlOiJ0ZXh0Iix2YWx1ZTpjfSk7Y29udGludWV9Y29uc3QgRD0vXlxcKy8uZXhlYyhiKCkpO2xldCBXPTA7aWYoRCYmRFswXS5sZW5ndGg+MiYmKFc9RFswXS5sZW5ndGgseS5pbmRleCs9VyxXJTIhPT0wJiYoYys9IlxcIikpLG4udW5lc2NhcGU9PT0hMD9jPWcoKTpjKz1nKCkseS5icmFja2V0cz09PTApe1Qoe3R5cGU6InRleHQiLHZhbHVlOmN9KTtjb250aW51ZX19aWYoeS5icmFja2V0cz4wJiYoYyE9PSJdInx8YS52YWx1ZT09PSJbInx8YS52YWx1ZT09PSJbXiIpKXtpZihuLnBvc2l4IT09ITEmJmM9PT0iOiIpe2NvbnN0IHc9YS52YWx1ZS5zbGljZSgxKTtpZih3LmluY2x1ZGVzKCJbIikmJihhLnBvc2l4PSEwLHcuaW5jbHVkZXMoIjoiKSkpe2NvbnN0IEQ9YS52YWx1ZS5sYXN0SW5kZXhPZigiWyIpLFc9YS52YWx1ZS5zbGljZSgwLEQpLFY9YS52YWx1ZS5zbGljZShEKzIpLFo9WW5bVl07aWYoWil7YS52YWx1ZT1XK1oseS5iYWNrdHJhY2s9ITAsZygpLCFwLm91dHB1dCYmby5pbmRleE9mKGEpPT09MSYmKHAub3V0cHV0PUkpO2NvbnRpbnVlfX19KGM9PT0iWyImJmgoKSE9PSI6Inx8Yz09PSItIiYmaCgpPT09Il0iKSYmKGM9YFxcJHtjfWApLGM9PT0iXSImJihhLnZhbHVlPT09IlsifHxhLnZhbHVlPT09IlteIikmJihjPWBcXCR7Y31gKSxuLnBvc2l4PT09ITAmJmM9PT0iISImJmEudmFsdWU9PT0iWyImJihjPSJeIiksYS52YWx1ZSs9YyxQKHt2YWx1ZTpjfSk7Y29udGludWV9aWYoeS5xdW90ZXM9PT0xJiZjIT09JyInKXtjPWFlLmVzY2FwZVJlZ2V4KGMpLGEudmFsdWUrPWMsUCh7dmFsdWU6Y30pO2NvbnRpbnVlfWlmKGM9PT0nIicpe3kucXVvdGVzPXkucXVvdGVzPT09MT8wOjEsbi5rZWVwUXVvdGVzPT09ITAmJlQoe3R5cGU6InRleHQiLHZhbHVlOmN9KTtjb250aW51ZX1pZihjPT09IigiKXtOKCJwYXJlbnMiKSxUKHt0eXBlOiJwYXJlbiIsdmFsdWU6Y30pO2NvbnRpbnVlfWlmKGM9PT0iKSIpe2lmKHkucGFyZW5zPT09MCYmbi5zdHJpY3RCcmFja2V0cz09PSEwKXRocm93IG5ldyBTeW50YXhFcnJvcih4ZSgib3BlbmluZyIsIigiKSk7Y29uc3Qgdz1GW0YubGVuZ3RoLTFdO2lmKHcmJnkucGFyZW5zPT09dy5wYXJlbnMrMSl7cmUoRi5wb3AoKSk7Y29udGludWV9VCh7dHlwZToicGFyZW4iLHZhbHVlOmMsb3V0cHV0OnkucGFyZW5zPyIpIjoiXFwpIn0pLGooInBhcmVucyIpO2NvbnRpbnVlfWlmKGM9PT0iWyIpe2lmKG4ubm9icmFja2V0PT09ITB8fCFiKCkuaW5jbHVkZXMoIl0iKSl7aWYobi5ub2JyYWNrZXQhPT0hMCYmbi5zdHJpY3RCcmFja2V0cz09PSEwKXRocm93IG5ldyBTeW50YXhFcnJvcih4ZSgiY2xvc2luZyIsIl0iKSk7Yz1gXFwke2N9YH1lbHNlIE4oImJyYWNrZXRzIik7VCh7dHlwZToiYnJhY2tldCIsdmFsdWU6Y30pO2NvbnRpbnVlfWlmKGM9PT0iXSIpe2lmKG4ubm9icmFja2V0PT09ITB8fGEmJmEudHlwZT09PSJicmFja2V0IiYmYS52YWx1ZS5sZW5ndGg9PT0xKXtUKHt0eXBlOiJ0ZXh0Iix2YWx1ZTpjLG91dHB1dDpgXFwke2N9YH0pO2NvbnRpbnVlfWlmKHkuYnJhY2tldHM9PT0wKXtpZihuLnN0cmljdEJyYWNrZXRzPT09ITApdGhyb3cgbmV3IFN5bnRheEVycm9yKHhlKCJvcGVuaW5nIiwiWyIpKTtUKHt0eXBlOiJ0ZXh0Iix2YWx1ZTpjLG91dHB1dDpgXFwke2N9YH0pO2NvbnRpbnVlfWooImJyYWNrZXRzIik7Y29uc3Qgdz1hLnZhbHVlLnNsaWNlKDEpO2lmKGEucG9zaXghPT0hMCYmd1swXT09PSJeIiYmIXcuaW5jbHVkZXMoIi8iKSYmKGM9YC8ke2N9YCksYS52YWx1ZSs9YyxQKHt2YWx1ZTpjfSksbi5saXRlcmFsQnJhY2tldHM9PT0hMXx8YWUuaGFzUmVnZXhDaGFycyh3KSljb250aW51ZTtjb25zdCBEPWFlLmVzY2FwZVJlZ2V4KGEudmFsdWUpO2lmKHkub3V0cHV0PXkub3V0cHV0LnNsaWNlKDAsLWEudmFsdWUubGVuZ3RoKSxuLmxpdGVyYWxCcmFja2V0cz09PSEwKXt5Lm91dHB1dCs9RCxhLnZhbHVlPUQ7Y29udGludWV9YS52YWx1ZT1gKCR7ZH0ke0R9fCR7YS52YWx1ZX0pYCx5Lm91dHB1dCs9YS52YWx1ZTtjb250aW51ZX1pZihjPT09InsiJiZuLm5vYnJhY2UhPT0hMCl7TigiYnJhY2VzIik7Y29uc3Qgdz17dHlwZToiYnJhY2UiLHZhbHVlOmMsb3V0cHV0OiIoIixvdXRwdXRJbmRleDp5Lm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6eS50b2tlbnMubGVuZ3RofTt0LnB1c2godyksVCh3KTtjb250aW51ZX1pZihjPT09In0iKXtjb25zdCB3PXRbdC5sZW5ndGgtMV07aWYobi5ub2JyYWNlPT09ITB8fCF3KXtUKHt0eXBlOiJ0ZXh0Iix2YWx1ZTpjLG91dHB1dDpjfSk7Y29udGludWV9bGV0IEQ9IikiO2lmKHcuZG90cz09PSEwKXtjb25zdCBXPW8uc2xpY2UoKSxWPVtdO2ZvcihsZXQgWj1XLmxlbmd0aC0xO1o+PTAmJihvLnBvcCgpLFdbWl0udHlwZSE9PSJicmFjZSIpO1otLSlXW1pdLnR5cGUhPT0iZG90cyImJlYudW5zaGlmdChXW1pdLnZhbHVlKTtEPXRvKFYsbikseS5iYWNrdHJhY2s9ITB9aWYody5jb21tYSE9PSEwJiZ3LmRvdHMhPT0hMCl7Y29uc3QgVz15Lm91dHB1dC5zbGljZSgwLHcub3V0cHV0SW5kZXgpLFY9eS50b2tlbnMuc2xpY2Uody50b2tlbnNJbmRleCk7dy52YWx1ZT13Lm91dHB1dD0iXFx7IixjPUQ9IlxcfSIseS5vdXRwdXQ9Vztmb3IoY29uc3QgWiBvZiBWKXkub3V0cHV0Kz1aLm91dHB1dHx8Wi52YWx1ZX1UKHt0eXBlOiJicmFjZSIsdmFsdWU6YyxvdXRwdXQ6RH0pLGooImJyYWNlcyIpLHQucG9wKCk7Y29udGludWV9aWYoYz09PSJ8Iil7Ri5sZW5ndGg+MCYmRltGLmxlbmd0aC0xXS5jb25kaXRpb25zKyssVCh7dHlwZToidGV4dCIsdmFsdWU6Y30pO2NvbnRpbnVlfWlmKGM9PT0iLCIpe2xldCB3PWM7Y29uc3QgRD10W3QubGVuZ3RoLTFdO0QmJnNbcy5sZW5ndGgtMV09PT0iYnJhY2VzIiYmKEQuY29tbWE9ITAsdz0ifCIpLFQoe3R5cGU6ImNvbW1hIix2YWx1ZTpjLG91dHB1dDp3fSk7Y29udGludWV9aWYoYz09PSIvIil7aWYoYS50eXBlPT09ImRvdCImJnkuaW5kZXg9PT15LnN0YXJ0KzEpe3kuc3RhcnQ9eS5pbmRleCsxLHkuY29uc3VtZWQ9IiIseS5vdXRwdXQ9IiIsby5wb3AoKSxhPXA7Y29udGludWV9VCh7dHlwZToic2xhc2giLHZhbHVlOmMsb3V0cHV0Onp9KTtjb250aW51ZX1pZihjPT09Ii4iKXtpZih5LmJyYWNlcz4wJiZhLnR5cGU9PT0iZG90Iil7YS52YWx1ZT09PSIuIiYmKGEub3V0cHV0PVMpO2NvbnN0IHc9dFt0Lmxlbmd0aC0xXTthLnR5cGU9ImRvdHMiLGEub3V0cHV0Kz1jLGEudmFsdWUrPWMsdy5kb3RzPSEwO2NvbnRpbnVlfWlmKHkuYnJhY2VzK3kucGFyZW5zPT09MCYmYS50eXBlIT09ImJvcyImJmEudHlwZSE9PSJzbGFzaCIpe1Qoe3R5cGU6InRleHQiLHZhbHVlOmMsb3V0cHV0OlN9KTtjb250aW51ZX1UKHt0eXBlOiJkb3QiLHZhbHVlOmMsb3V0cHV0OlN9KTtjb250aW51ZX1pZihjPT09Ij8iKXtpZighKGEmJmEudmFsdWU9PT0iKCIpJiZuLm5vZXh0Z2xvYiE9PSEwJiZoKCk9PT0iKCImJmgoMikhPT0iPyIpe0soInFtYXJrIixjKTtjb250aW51ZX1pZihhJiZhLnR5cGU9PT0icGFyZW4iKXtjb25zdCB3PWgoKTtsZXQgRD1jO2lmKHc9PT0iPCImJiFhZS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpdGhyb3cgbmV3IEVycm9yKCJOb2RlLmpzIHYxMCBvciBoaWdoZXIgaXMgcmVxdWlyZWQgZm9yIHJlZ2V4IGxvb2tiZWhpbmRzIik7KGEudmFsdWU9PT0iKCImJiEvWyE9PDpdLy50ZXN0KHcpfHx3PT09IjwiJiYhLzwoWyE9XXxcdys+KS8udGVzdChiKCkpKSYmKEQ9YFxcJHtjfWApLFQoe3R5cGU6InRleHQiLHZhbHVlOmMsb3V0cHV0OkR9KTtjb250aW51ZX1pZihuLmRvdCE9PSEwJiYoYS50eXBlPT09InNsYXNoInx8YS50eXBlPT09ImJvcyIpKXtUKHt0eXBlOiJxbWFyayIsdmFsdWU6YyxvdXRwdXQ6QX0pO2NvbnRpbnVlfVQoe3R5cGU6InFtYXJrIix2YWx1ZTpjLG91dHB1dDpVfSk7Y29udGludWV9aWYoYz09PSIhIil7aWYobi5ub2V4dGdsb2IhPT0hMCYmaCgpPT09IigiJiYoaCgyKSE9PSI/Inx8IS9bIT08Ol0vLnRlc3QoaCgzKSkpKXtLKCJuZWdhdGUiLGMpO2NvbnRpbnVlfWlmKG4ubm9uZWdhdGUhPT0hMCYmeS5pbmRleD09PTApe0woKTtjb250aW51ZX19aWYoYz09PSIrIil7aWYobi5ub2V4dGdsb2IhPT0hMCYmaCgpPT09IigiJiZoKDIpIT09Ij8iKXtLKCJwbHVzIixjKTtjb250aW51ZX1pZihhJiZhLnZhbHVlPT09IigifHxuLnJlZ2V4PT09ITEpe1Qoe3R5cGU6InBsdXMiLHZhbHVlOmMsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihhJiYoYS50eXBlPT09ImJyYWNrZXQifHxhLnR5cGU9PT0icGFyZW4ifHxhLnR5cGU9PT0iYnJhY2UiKXx8eS5wYXJlbnM+MCl7VCh7dHlwZToicGx1cyIsdmFsdWU6Y30pO2NvbnRpbnVlfVQoe3R5cGU6InBsdXMiLHZhbHVlOnZ9KTtjb250aW51ZX1pZihjPT09IkAiKXtpZihuLm5vZXh0Z2xvYiE9PSEwJiZoKCk9PT0iKCImJmgoMikhPT0iPyIpe1Qoe3R5cGU6ImF0IixleHRnbG9iOiEwLHZhbHVlOmMsb3V0cHV0OiIifSk7Y29udGludWV9VCh7dHlwZToidGV4dCIsdmFsdWU6Y30pO2NvbnRpbnVlfWlmKGMhPT0iKiIpeyhjPT09IiQifHxjPT09Il4iKSYmKGM9YFxcJHtjfWApO2NvbnN0IHc9Sm4uZXhlYyhiKCkpO3cmJihjKz13WzBdLHkuaW5kZXgrPXdbMF0ubGVuZ3RoKSxUKHt0eXBlOiJ0ZXh0Iix2YWx1ZTpjfSk7Y29udGludWV9aWYoYSYmKGEudHlwZT09PSJnbG9ic3RhciJ8fGEuc3Rhcj09PSEwKSl7YS50eXBlPSJzdGFyIixhLnN0YXI9ITAsYS52YWx1ZSs9YyxhLm91dHB1dD1RLHkuYmFja3RyYWNrPSEwLHkuZ2xvYnN0YXI9ITAsUihjKTtjb250aW51ZX1sZXQgQz1iKCk7aWYobi5ub2V4dGdsb2IhPT0hMCYmL15cKFteP10vLnRlc3QoQykpe0soInN0YXIiLGMpO2NvbnRpbnVlfWlmKGEudHlwZT09PSJzdGFyIil7aWYobi5ub2dsb2JzdGFyPT09ITApe1IoYyk7Y29udGludWV9Y29uc3Qgdz1hLnByZXYsRD13LnByZXYsVz13LnR5cGU9PT0ic2xhc2gifHx3LnR5cGU9PT0iYm9zIixWPUQmJihELnR5cGU9PT0ic3RhciJ8fEQudHlwZT09PSJnbG9ic3RhciIpO2lmKG4uYmFzaD09PSEwJiYoIVd8fENbMF0mJkNbMF0hPT0iLyIpKXtUKHt0eXBlOiJzdGFyIix2YWx1ZTpjLG91dHB1dDoiIn0pO2NvbnRpbnVlfWNvbnN0IFo9eS5icmFjZXM+MCYmKHcudHlwZT09PSJjb21tYSJ8fHcudHlwZT09PSJicmFjZSIpLGJlPUYubGVuZ3RoJiYody50eXBlPT09InBpcGUifHx3LnR5cGU9PT0icGFyZW4iKTtpZighVyYmdy50eXBlIT09InBhcmVuIiYmIVomJiFiZSl7VCh7dHlwZToic3RhciIsdmFsdWU6YyxvdXRwdXQ6IiJ9KTtjb250aW51ZX1mb3IoO0Muc2xpY2UoMCwzKT09PSIvKioiOyl7Y29uc3QgUWU9ZVt5LmluZGV4KzRdO2lmKFFlJiZRZSE9PSIvIilicmVhaztDPUMuc2xpY2UoMyksUigiLyoqIiwzKX1pZih3LnR5cGU9PT0iYm9zIiYmbCgpKXthLnR5cGU9Imdsb2JzdGFyIixhLnZhbHVlKz1jLGEub3V0cHV0PSQobikseS5vdXRwdXQ9YS5vdXRwdXQseS5nbG9ic3Rhcj0hMCxSKGMpO2NvbnRpbnVlfWlmKHcudHlwZT09PSJzbGFzaCImJncucHJldi50eXBlIT09ImJvcyImJiFWJiZsKCkpe3kub3V0cHV0PXkub3V0cHV0LnNsaWNlKDAsLSh3Lm91dHB1dCthLm91dHB1dCkubGVuZ3RoKSx3Lm91dHB1dD1gKD86JHt3Lm91dHB1dH1gLGEudHlwZT0iZ2xvYnN0YXIiLGEub3V0cHV0PSQobikrKG4uc3RyaWN0U2xhc2hlcz8iKSI6InwkKSIpLGEudmFsdWUrPWMseS5nbG9ic3Rhcj0hMCx5Lm91dHB1dCs9dy5vdXRwdXQrYS5vdXRwdXQsUihjKTtjb250aW51ZX1pZih3LnR5cGU9PT0ic2xhc2giJiZ3LnByZXYudHlwZSE9PSJib3MiJiZDWzBdPT09Ii8iKXtjb25zdCBRZT1DWzFdIT09dm9pZCAwPyJ8JCI6IiI7eS5vdXRwdXQ9eS5vdXRwdXQuc2xpY2UoMCwtKHcub3V0cHV0K2Eub3V0cHV0KS5sZW5ndGgpLHcub3V0cHV0PWAoPzoke3cub3V0cHV0fWAsYS50eXBlPSJnbG9ic3RhciIsYS5vdXRwdXQ9YCR7JChuKX0ke3p9fCR7en0ke1FlfSlgLGEudmFsdWUrPWMseS5vdXRwdXQrPXcub3V0cHV0K2Eub3V0cHV0LHkuZ2xvYnN0YXI9ITAsUihjK2coKSksVCh7dHlwZToic2xhc2giLHZhbHVlOiIvIixvdXRwdXQ6IiJ9KTtjb250aW51ZX1pZih3LnR5cGU9PT0iYm9zIiYmQ1swXT09PSIvIil7YS50eXBlPSJnbG9ic3RhciIsYS52YWx1ZSs9YyxhLm91dHB1dD1gKD86Xnwke3p9fCR7JChuKX0ke3p9KWAseS5vdXRwdXQ9YS5vdXRwdXQseS5nbG9ic3Rhcj0hMCxSKGMrZygpKSxUKHt0eXBlOiJzbGFzaCIsdmFsdWU6Ii8iLG91dHB1dDoiIn0pO2NvbnRpbnVlfXkub3V0cHV0PXkub3V0cHV0LnNsaWNlKDAsLWEub3V0cHV0Lmxlbmd0aCksYS50eXBlPSJnbG9ic3RhciIsYS5vdXRwdXQ9JChuKSxhLnZhbHVlKz1jLHkub3V0cHV0Kz1hLm91dHB1dCx5Lmdsb2JzdGFyPSEwLFIoYyk7Y29udGludWV9Y29uc3QgQj17dHlwZToic3RhciIsdmFsdWU6YyxvdXRwdXQ6UX07aWYobi5iYXNoPT09ITApe0Iub3V0cHV0PSIuKj8iLChhLnR5cGU9PT0iYm9zInx8YS50eXBlPT09InNsYXNoIikmJihCLm91dHB1dD14K0Iub3V0cHV0KSxUKEIpO2NvbnRpbnVlfWlmKGEmJihhLnR5cGU9PT0iYnJhY2tldCJ8fGEudHlwZT09PSJwYXJlbiIpJiZuLnJlZ2V4PT09ITApe0Iub3V0cHV0PWMsVChCKTtjb250aW51ZX0oeS5pbmRleD09PXkuc3RhcnR8fGEudHlwZT09PSJzbGFzaCJ8fGEudHlwZT09PSJkb3QiKSYmKGEudHlwZT09PSJkb3QiPyh5Lm91dHB1dCs9cSxhLm91dHB1dCs9cSk6bi5kb3Q9PT0hMD8oeS5vdXRwdXQrPUcsYS5vdXRwdXQrPUcpOih5Lm91dHB1dCs9eCxhLm91dHB1dCs9eCksaCgpIT09IioiJiYoeS5vdXRwdXQrPUksYS5vdXRwdXQrPUkpKSxUKEIpfWZvcig7eS5icmFja2V0cz4wOyl7aWYobi5zdHJpY3RCcmFja2V0cz09PSEwKXRocm93IG5ldyBTeW50YXhFcnJvcih4ZSgiY2xvc2luZyIsIl0iKSk7eS5vdXRwdXQ9YWUuZXNjYXBlTGFzdCh5Lm91dHB1dCwiWyIpLGooImJyYWNrZXRzIil9Zm9yKDt5LnBhcmVucz4wOyl7aWYobi5zdHJpY3RCcmFja2V0cz09PSEwKXRocm93IG5ldyBTeW50YXhFcnJvcih4ZSgiY2xvc2luZyIsIikiKSk7eS5vdXRwdXQ9YWUuZXNjYXBlTGFzdCh5Lm91dHB1dCwiKCIpLGooInBhcmVucyIpfWZvcig7eS5icmFjZXM+MDspe2lmKG4uc3RyaWN0QnJhY2tldHM9PT0hMCl0aHJvdyBuZXcgU3ludGF4RXJyb3IoeGUoImNsb3NpbmciLCJ9IikpO3kub3V0cHV0PWFlLmVzY2FwZUxhc3QoeS5vdXRwdXQsInsiKSxqKCJicmFjZXMiKX1pZihuLnN0cmljdFNsYXNoZXMhPT0hMCYmKGEudHlwZT09PSJzdGFyInx8YS50eXBlPT09ImJyYWNrZXQiKSYmVCh7dHlwZToibWF5YmVfc2xhc2giLHZhbHVlOiIiLG91dHB1dDpgJHt6fT9gfSkseS5iYWNrdHJhY2s9PT0hMCl7eS5vdXRwdXQ9IiI7Zm9yKGNvbnN0IEMgb2YgeS50b2tlbnMpeS5vdXRwdXQrPUMub3V0cHV0IT1udWxsP0Mub3V0cHV0OkMudmFsdWUsQy5zdWZmaXgmJih5Lm91dHB1dCs9Qy5zdWZmaXgpfXJldHVybiB5fTtpdC5mYXN0cGF0aHM9KGUscik9Pntjb25zdCBuPXRlKHt9LHIpLGk9dHlwZW9mIG4ubWF4TGVuZ3RoPT0ibnVtYmVyIj9NYXRoLm1pbihNZSxuLm1heExlbmd0aCk6TWUsdT1lLmxlbmd0aDtpZih1PmkpdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7dX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtpfWApO2U9b3JbZV18fGU7Y29uc3QgcD1hZS5pc1dpbmRvd3Mocikse0RPVF9MSVRFUkFMOm8sU0xBU0hfTElURVJBTDpkLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpfLE5PX0RPVDptLE5PX0RPVFM6UyxOT19ET1RTX1NMQVNIOnYsU1RBUjp6LFNUQVJUX0FOQ0hPUjpJfT1EZS5nbG9iQ2hhcnMocCksaz1uLmRvdD9TOm0sTT1uLmRvdD92Om0scT1uLmNhcHR1cmU/IiI6Ij86IixHPXtuZWdhdGVkOiExLHByZWZpeDoiIn07bGV0IFU9bi5iYXNoPT09ITA/Ii4qPyI6ejtuLmNhcHR1cmUmJihVPWAoJHtVfSlgKTtjb25zdCBBPXg9Pngubm9nbG9ic3Rhcj09PSEwP1U6YCgke3F9KD86KD8hJHtJfSR7eC5kb3Q/XzpvfSkuKSo/KWAsRT14PT57c3dpdGNoKHgpe2Nhc2UiKiI6cmV0dXJuYCR7a30ke2Z9JHtVfWA7Y2FzZSIuKiI6cmV0dXJuYCR7b30ke2Z9JHtVfWA7Y2FzZSIqLioiOnJldHVybmAke2t9JHtVfSR7b30ke2Z9JHtVfWA7Y2FzZSIqLyoiOnJldHVybmAke2t9JHtVfSR7ZH0ke2Z9JHtNfSR7VX1gO2Nhc2UiKioiOnJldHVybiBrK0Eobik7Y2FzZSIqKi8qIjpyZXR1cm5gKD86JHtrfSR7QShuKX0ke2R9KT8ke019JHtmfSR7VX1gO2Nhc2UiKiovKi4qIjpyZXR1cm5gKD86JHtrfSR7QShuKX0ke2R9KT8ke019JHtVfSR7b30ke2Z9JHtVfWA7Y2FzZSIqKi8uKiI6cmV0dXJuYCg/OiR7a30ke0Eobil9JHtkfSk/JHtvfSR7Zn0ke1V9YDtkZWZhdWx0Ontjb25zdCBPPS9eKC4qPylcLihcdyspJC8uZXhlYyh4KTtpZighTylyZXR1cm47Y29uc3QgUT1FKE9bMV0pO3JldHVybiBRP1ErbytPWzJdOnZvaWQgMH19fSxIPWFlLnJlbW92ZVByZWZpeChlLEcpO2xldCAkPUUoSCk7cmV0dXJuICQmJm4uc3RyaWN0U2xhc2hlcyE9PSEwJiYoJCs9YCR7ZH0/YCksJH07dmFyIHJvPWl0O2NvbnN0IG5vPUFlLmV4cG9ydHMsb289Vm4sdXQ9cm8sY3Q9U2Usc289TmUsYW89ZT0+ZSYmdHlwZW9mIGU9PSJvYmplY3QiJiYhQXJyYXkuaXNBcnJheShlKSxZPShlLHIsbj0hMSk9PntpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCBtPWUubWFwKFM9PlkoUyxyLG4pKTtyZXR1cm4gUz0+e2Zvcihjb25zdCB2IG9mIG0pe2NvbnN0IHo9dihTKTtpZih6KXJldHVybiB6fXJldHVybiExfX1jb25zdCBpPWFvKGUpJiZlLnRva2VucyYmZS5pbnB1dDtpZihlPT09IiJ8fHR5cGVvZiBlIT0ic3RyaW5nIiYmIWkpdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmciKTtjb25zdCB1PXJ8fHt9LHA9Y3QuaXNXaW5kb3dzKHIpLG89aT9ZLmNvbXBpbGVSZShlLHIpOlkubWFrZVJlKGUsciwhMSwhMCksZD1vLnN0YXRlO2RlbGV0ZSBvLnN0YXRlO2xldCBmPSgpPT4hMTtpZih1Lmlnbm9yZSl7Y29uc3QgbT11ZSh0ZSh7fSxyKSx7aWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9KTtmPVkodS5pZ25vcmUsbSxuKX1jb25zdCBfPShtLFM9ITEpPT57Y29uc3R7aXNNYXRjaDp2LG1hdGNoOnosb3V0cHV0Okl9PVkudGVzdChtLG8scix7Z2xvYjplLHBvc2l4OnB9KSxrPXtnbG9iOmUsc3RhdGU6ZCxyZWdleDpvLHBvc2l4OnAsaW5wdXQ6bSxvdXRwdXQ6SSxtYXRjaDp6LGlzTWF0Y2g6dn07cmV0dXJuIHR5cGVvZiB1Lm9uUmVzdWx0PT0iZnVuY3Rpb24iJiZ1Lm9uUmVzdWx0KGspLHY9PT0hMT8oay5pc01hdGNoPSExLFM/azohMSk6ZihtKT8odHlwZW9mIHUub25JZ25vcmU9PSJmdW5jdGlvbiImJnUub25JZ25vcmUoayksay5pc01hdGNoPSExLFM/azohMSk6KHR5cGVvZiB1Lm9uTWF0Y2g9PSJmdW5jdGlvbiImJnUub25NYXRjaChrKSxTP2s6ITApfTtyZXR1cm4gbiYmKF8uc3RhdGU9ZCksX307WS50ZXN0PShlLHIsbix7Z2xvYjppLHBvc2l4OnV9PXt9KT0+e2lmKHR5cGVvZiBlIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZyIpO2lmKGU9PT0iIilyZXR1cm57aXNNYXRjaDohMSxvdXRwdXQ6IiJ9O2NvbnN0IHA9bnx8e30sbz1wLmZvcm1hdHx8KHU/Y3QudG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGQ9ZT09PWksZj1kJiZvP28oZSk6ZTtyZXR1cm4gZD09PSExJiYoZj1vP28oZSk6ZSxkPWY9PT1pKSwoZD09PSExfHxwLmNhcHR1cmU9PT0hMCkmJihwLm1hdGNoQmFzZT09PSEwfHxwLmJhc2VuYW1lPT09ITA/ZD1ZLm1hdGNoQmFzZShlLHIsbix1KTpkPXIuZXhlYyhmKSkse2lzTWF0Y2g6Qm9vbGVhbihkKSxtYXRjaDpkLG91dHB1dDpmfX0sWS5tYXRjaEJhc2U9KGUscixuLGk9Y3QuaXNXaW5kb3dzKG4pKT0+KHIgaW5zdGFuY2VvZiBSZWdFeHA/cjpZLm1ha2VSZShyLG4pKS50ZXN0KG5vLmJhc2VuYW1lKGUpKSxZLmlzTWF0Y2g9KGUscixuKT0+WShyLG4pKGUpLFkucGFyc2U9KGUscik9PkFycmF5LmlzQXJyYXkoZSk/ZS5tYXAobj0+WS5wYXJzZShuLHIpKTp1dChlLHVlKHRlKHt9LHIpLHtmYXN0cGF0aHM6ITF9KSksWS5zY2FuPShlLHIpPT5vbyhlLHIpLFkuY29tcGlsZVJlPShlLHIsbj0hMSxpPSExKT0+e2lmKG49PT0hMClyZXR1cm4gZS5vdXRwdXQ7Y29uc3QgdT1yfHx7fSxwPXUuY29udGFpbnM/IiI6Il4iLG89dS5jb250YWlucz8iIjoiJCI7bGV0IGQ9YCR7cH0oPzoke2Uub3V0cHV0fSkke299YDtlJiZlLm5lZ2F0ZWQ9PT0hMCYmKGQ9YF4oPyEke2R9KS4qJGApO2NvbnN0IGY9WS50b1JlZ2V4KGQscik7cmV0dXJuIGk9PT0hMCYmKGYuc3RhdGU9ZSksZn0sWS5tYWtlUmU9KGUscj17fSxuPSExLGk9ITEpPT57aWYoIWV8fHR5cGVvZiBlIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCBhIG5vbi1lbXB0eSBzdHJpbmciKTtsZXQgdT17bmVnYXRlZDohMSxmYXN0cGF0aHM6ITB9O3JldHVybiByLmZhc3RwYXRocyE9PSExJiYoZVswXT09PSIuInx8ZVswXT09PSIqIikmJih1Lm91dHB1dD11dC5mYXN0cGF0aHMoZSxyKSksdS5vdXRwdXR8fCh1PXV0KGUscikpLFkuY29tcGlsZVJlKHUscixuLGkpfSxZLnRvUmVnZXg9KGUscik9Pnt0cnl7Y29uc3Qgbj1yfHx7fTtyZXR1cm4gbmV3IFJlZ0V4cChlLG4uZmxhZ3N8fChuLm5vY2FzZT8iaSI6IiIpKX1jYXRjaChuKXtpZihyJiZyLmRlYnVnPT09ITApdGhyb3cgbjtyZXR1cm4vJF4vfX0sWS5jb25zdGFudHM9c287dmFyIGlvPVksdW89aW87Y29uc3Qgc3I9SGUsYXI9T24scGU9dW8sbHQ9U2UsaXI9ZT0+ZT09PSIifHxlPT09Ii4vIixYPShlLHIsbik9PntyPVtdLmNvbmNhdChyKSxlPVtdLmNvbmNhdChlKTtsZXQgaT1uZXcgU2V0LHU9bmV3IFNldCxwPW5ldyBTZXQsbz0wLGQ9Xz0+e3AuYWRkKF8ub3V0cHV0KSxuJiZuLm9uUmVzdWx0JiZuLm9uUmVzdWx0KF8pfTtmb3IobGV0IF89MDtfPHIubGVuZ3RoO18rKyl7bGV0IG09cGUoU3RyaW5nKHJbX10pLHVlKHRlKHt9LG4pLHtvblJlc3VsdDpkfSksITApLFM9bS5zdGF0ZS5uZWdhdGVkfHxtLnN0YXRlLm5lZ2F0ZWRFeHRnbG9iO1MmJm8rKztmb3IobGV0IHYgb2YgZSl7bGV0IHo9bSh2LCEwKTshKFM/IXouaXNNYXRjaDp6LmlzTWF0Y2gpfHwoUz9pLmFkZCh6Lm91dHB1dCk6KGkuZGVsZXRlKHoub3V0cHV0KSx1LmFkZCh6Lm91dHB1dCkpKX19bGV0IGY9KG89PT1yLmxlbmd0aD9bLi4ucF06Wy4uLnVdKS5maWx0ZXIoXz0+IWkuaGFzKF8pKTtpZihuJiZmLmxlbmd0aD09PTApe2lmKG4uZmFpbGdsb2I9PT0hMCl0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yICIke3Iuam9pbigiLCAiKX0iYCk7aWYobi5ub251bGw9PT0hMHx8bi5udWxsZ2xvYj09PSEwKXJldHVybiBuLnVuZXNjYXBlP3IubWFwKF89Pl8ucmVwbGFjZSgvXFwvZywiIikpOnJ9cmV0dXJuIGZ9O1gubWF0Y2g9WCxYLm1hdGNoZXI9KGUscik9PnBlKGUsciksWC5pc01hdGNoPShlLHIsbik9PnBlKHIsbikoZSksWC5hbnk9WC5pc01hdGNoLFgubm90PShlLHIsbj17fSk9PntyPVtdLmNvbmNhdChyKS5tYXAoU3RyaW5nKTtsZXQgaT1uZXcgU2V0LHU9W10scD1kPT57bi5vblJlc3VsdCYmbi5vblJlc3VsdChkKSx1LnB1c2goZC5vdXRwdXQpfSxvPW5ldyBTZXQoWChlLHIsdWUodGUoe30sbikse29uUmVzdWx0OnB9KSkpO2ZvcihsZXQgZCBvZiB1KW8uaGFzKGQpfHxpLmFkZChkKTtyZXR1cm5bLi4uaV19LFguY29udGFpbnM9KGUscixuKT0+e2lmKHR5cGVvZiBlIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZzogIiR7c3IuaW5zcGVjdChlKX0iYCk7aWYoQXJyYXkuaXNBcnJheShyKSlyZXR1cm4gci5zb21lKGk9PlguY29udGFpbnMoZSxpLG4pKTtpZih0eXBlb2Ygcj09InN0cmluZyIpe2lmKGlyKGUpfHxpcihyKSlyZXR1cm4hMTtpZihlLmluY2x1ZGVzKHIpfHxlLnN0YXJ0c1dpdGgoIi4vIikmJmUuc2xpY2UoMikuaW5jbHVkZXMocikpcmV0dXJuITB9cmV0dXJuIFguaXNNYXRjaChlLHIsdWUodGUoe30sbikse2NvbnRhaW5zOiEwfSkpfSxYLm1hdGNoS2V5cz0oZSxyLG4pPT57aWYoIWx0LmlzT2JqZWN0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIHRoZSBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QiKTtsZXQgaT1YKE9iamVjdC5rZXlzKGUpLHIsbiksdT17fTtmb3IobGV0IHAgb2YgaSl1W3BdPWVbcF07cmV0dXJuIHV9LFguc29tZT0oZSxyLG4pPT57bGV0IGk9W10uY29uY2F0KGUpO2ZvcihsZXQgdSBvZltdLmNvbmNhdChyKSl7bGV0IHA9cGUoU3RyaW5nKHUpLG4pO2lmKGkuc29tZShvPT5wKG8pKSlyZXR1cm4hMH1yZXR1cm4hMX0sWC5ldmVyeT0oZSxyLG4pPT57bGV0IGk9W10uY29uY2F0KGUpO2ZvcihsZXQgdSBvZltdLmNvbmNhdChyKSl7bGV0IHA9cGUoU3RyaW5nKHUpLG4pO2lmKCFpLmV2ZXJ5KG89PnAobykpKXJldHVybiExfXJldHVybiEwfSxYLmFsbD0oZSxyLG4pPT57aWYodHlwZW9mIGUhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiAiJHtzci5pbnNwZWN0KGUpfSJgKTtyZXR1cm5bXS5jb25jYXQocikuZXZlcnkoaT0+cGUoaSxuKShlKSl9LFguY2FwdHVyZT0oZSxyLG4pPT57bGV0IGk9bHQuaXNXaW5kb3dzKG4pLHU9cGUubWFrZVJlKFN0cmluZyhlKSx1ZSh0ZSh7fSxuKSx7Y2FwdHVyZTohMH0pKS5leGVjKGk/bHQudG9Qb3NpeFNsYXNoZXMocik6cik7aWYodSlyZXR1cm4gdS5zbGljZSgxKS5tYXAocD0+cD09PXZvaWQgMD8iIjpwKX0sWC5tYWtlUmU9KC4uLmUpPT5wZS5tYWtlUmUoLi4uZSksWC5zY2FuPSguLi5lKT0+cGUuc2NhbiguLi5lKSxYLnBhcnNlPShlLHIpPT57bGV0IG49W107Zm9yKGxldCBpIG9mW10uY29uY2F0KGV8fFtdKSlmb3IobGV0IHUgb2YgYXIoU3RyaW5nKGkpLHIpKW4ucHVzaChwZS5wYXJzZSh1LHIpKTtyZXR1cm4gbn0sWC5icmFjZXM9KGUscik9PntpZih0eXBlb2YgZSE9InN0cmluZyIpdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0ZWQgYSBzdHJpbmciKTtyZXR1cm4gciYmci5ub2JyYWNlPT09ITB8fCEvXHsuKlx9Ly50ZXN0KGUpP1tlXTphcihlLHIpfSxYLmJyYWNlRXhwYW5kPShlLHIpPT57aWYodHlwZW9mIGUhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIGEgc3RyaW5nIik7cmV0dXJuIFguYnJhY2VzKGUsdWUodGUoe30scikse2V4cGFuZDohMH0pKX07dmFyIGNvPVgsdXI9e2V4cG9ydHM6e319LHB0PXtleHBvcnRzOnt9fTsvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMCBieSBAbWF0aGlhcyAqLyhmdW5jdGlvbihlLHIpeyhmdW5jdGlvbihuKXt2YXIgaT1yJiYhci5ub2RlVHlwZSYmcix1PWUmJiFlLm5vZGVUeXBlJiZlLHA9dHlwZW9mIGdlPT0ib2JqZWN0IiYmZ2U7KHAuZ2xvYmFsPT09cHx8cC53aW5kb3c9PT1wfHxwLnNlbGY9PT1wKSYmKG49cCk7dmFyIG8sZD0yMTQ3NDgzNjQ3LGY9MzYsXz0xLG09MjYsUz0zOCx2PTcwMCx6PTcyLEk9MTI4LGs9Ii0iLE09L154bi0tLyxxPS9bXlx4MjAtXHg3RV0vLEc9L1tceDJFXHUzMDAyXHVGRjBFXHVGRjYxXS9nLFU9e292ZXJmbG93OiJPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcyIsIm5vdC1iYXNpYyI6IklsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCkiLCJpbnZhbGlkLWlucHV0IjoiSW52YWxpZCBpbnB1dCJ9LEE9Zi1fLEU9TWF0aC5mbG9vcixIPVN0cmluZy5mcm9tQ2hhckNvZGUsJDtmdW5jdGlvbiB4KGIpe3Rocm93IG5ldyBSYW5nZUVycm9yKFVbYl0pfWZ1bmN0aW9uIE8oYixSKXtmb3IodmFyIFA9Yi5sZW5ndGgsTD1bXTtQLS07KUxbUF09UihiW1BdKTtyZXR1cm4gTH1mdW5jdGlvbiBRKGIsUil7dmFyIFA9Yi5zcGxpdCgiQCIpLEw9IiI7UC5sZW5ndGg+MSYmKEw9UFswXSsiQCIsYj1QWzFdKSxiPWIucmVwbGFjZShHLCIuIik7dmFyIE49Yi5zcGxpdCgiLiIpLGo9TyhOLFIpLmpvaW4oIi4iKTtyZXR1cm4gTCtqfWZ1bmN0aW9uIHkoYil7Zm9yKHZhciBSPVtdLFA9MCxMPWIubGVuZ3RoLE4sajtQPEw7KU49Yi5jaGFyQ29kZUF0KFArKyksTj49NTUyOTYmJk48PTU2MzE5JiZQPEw/KGo9Yi5jaGFyQ29kZUF0KFArKyksKGomNjQ1MTIpPT01NjMyMD9SLnB1c2goKChOJjEwMjMpPDwxMCkrKGomMTAyMykrNjU1MzYpOihSLnB1c2goTiksUC0tKSk6Ui5wdXNoKE4pO3JldHVybiBSfWZ1bmN0aW9uIEYoYil7cmV0dXJuIE8oYixmdW5jdGlvbihSKXt2YXIgUD0iIjtyZXR1cm4gUj42NTUzNSYmKFItPTY1NTM2LFArPUgoUj4+PjEwJjEwMjN8NTUyOTYpLFI9NTYzMjB8UiYxMDIzKSxQKz1IKFIpLFB9KS5qb2luKCIiKX1mdW5jdGlvbiB0KGIpe3JldHVybiBiLTQ4PDEwP2ItMjI6Yi02NTwyNj9iLTY1OmItOTc8MjY/Yi05NzpmfWZ1bmN0aW9uIHMoYixSKXtyZXR1cm4gYisyMis3NSooYjwyNiktKChSIT0wKTw8NSl9ZnVuY3Rpb24gYShiLFIsUCl7dmFyIEw9MDtmb3IoYj1QP0UoYi92KTpiPj4xLGIrPUUoYi9SKTtiPkEqbT4+MTtMKz1mKWI9RShiL0EpO3JldHVybiBFKEwrKEErMSkqYi8oYitTKSl9ZnVuY3Rpb24gYyhiKXt2YXIgUj1bXSxQPWIubGVuZ3RoLEwsTj0wLGo9SSxUPXosSyxyZSxDLEIsdyxELFcsVixaO2ZvcihLPWIubGFzdEluZGV4T2YoayksSzwwJiYoSz0wKSxyZT0wO3JlPEs7KytyZSliLmNoYXJDb2RlQXQocmUpPj0xMjgmJngoIm5vdC1iYXNpYyIpLFIucHVzaChiLmNoYXJDb2RlQXQocmUpKTtmb3IoQz1LPjA/SysxOjA7QzxQOyl7Zm9yKEI9Tix3PTEsRD1mO0M+PVAmJngoImludmFsaWQtaW5wdXQiKSxXPXQoYi5jaGFyQ29kZUF0KEMrKykpLChXPj1mfHxXPkUoKGQtTikvdykpJiZ4KCJvdmVyZmxvdyIpLE4rPVcqdyxWPUQ8PVQ/XzpEPj1UK20/bTpELVQsIShXPFYpO0QrPWYpWj1mLVYsdz5FKGQvWikmJngoIm92ZXJmbG93Iiksdyo9WjtMPVIubGVuZ3RoKzEsVD1hKE4tQixMLEI9PTApLEUoTi9MKT5kLWomJngoIm92ZXJmbG93Iiksais9RShOL0wpLE4lPUwsUi5zcGxpY2UoTisrLDAsail9cmV0dXJuIEYoUil9ZnVuY3Rpb24gbChiKXt2YXIgUixQLEwsTixqLFQsSyxyZSxDLEIsdyxEPVtdLFcsVixaLGJlO2ZvcihiPXkoYiksVz1iLmxlbmd0aCxSPUksUD0wLGo9eixUPTA7VDxXOysrVCl3PWJbVF0sdzwxMjgmJkQucHVzaChIKHcpKTtmb3IoTD1OPUQubGVuZ3RoLE4mJkQucHVzaChrKTtMPFc7KXtmb3IoSz1kLFQ9MDtUPFc7KytUKXc9YltUXSx3Pj1SJiZ3PEsmJihLPXcpO2ZvcihWPUwrMSxLLVI+RSgoZC1QKS9WKSYmeCgib3ZlcmZsb3ciKSxQKz0oSy1SKSpWLFI9SyxUPTA7VDxXOysrVClpZih3PWJbVF0sdzxSJiYrK1A+ZCYmeCgib3ZlcmZsb3ciKSx3PT1SKXtmb3IocmU9UCxDPWY7Qj1DPD1qP186Qz49aittP206Qy1qLCEocmU8Qik7Qys9ZiliZT1yZS1CLFo9Zi1CLEQucHVzaChIKHMoQitiZSVaLDApKSkscmU9RShiZS9aKTtELnB1c2goSChzKHJlLDApKSksaj1hKFAsVixMPT1OKSxQPTAsKytMfSsrUCwrK1J9cmV0dXJuIEQuam9pbigiIil9ZnVuY3Rpb24gaChiKXtyZXR1cm4gUShiLGZ1bmN0aW9uKFIpe3JldHVybiBNLnRlc3QoUik/YyhSLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpOlJ9KX1mdW5jdGlvbiBnKGIpe3JldHVybiBRKGIsZnVuY3Rpb24oUil7cmV0dXJuIHEudGVzdChSKT8ieG4tLSIrbChSKTpSfSl9aWYobz17dmVyc2lvbjoiMS4zLjIiLHVjczI6e2RlY29kZTp5LGVuY29kZTpGfSxkZWNvZGU6YyxlbmNvZGU6bCx0b0FTQ0lJOmcsdG9Vbmljb2RlOmh9LGkmJnUpaWYoZS5leHBvcnRzPT1pKXUuZXhwb3J0cz1vO2Vsc2UgZm9yKCQgaW4gbylvLmhhc093blByb3BlcnR5KCQpJiYoaVskXT1vWyRdKTtlbHNlIG4ucHVueWNvZGU9b30pKGdlKX0pKHB0LHB0LmV4cG9ydHMpO3ZhciBjcj17ZXhwb3J0czp7fX07LyohCiogVVJJLmpzIC0gTXV0YXRpbmcgVVJMcwoqIElQdjYgU3VwcG9ydAoqCiogVmVyc2lvbjogMS4xOS4xMQoqCiogQXV0aG9yOiBSb2RuZXkgUmVobQoqIFdlYjogaHR0cDovL21lZGlhbGl6ZS5naXRodWIuaW8vVVJJLmpzLwoqCiogTGljZW5zZWQgdW5kZXIKKiAgIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKKgoqLyhmdW5jdGlvbihlKXsoZnVuY3Rpb24ocixuKXtlLmV4cG9ydHM/ZS5leHBvcnRzPW4oKTpyLklQdjY9bihyKX0pKGdlLGZ1bmN0aW9uKHIpe3ZhciBuPXImJnIuSVB2NjtmdW5jdGlvbiBpKHApe3ZhciBvPXAudG9Mb3dlckNhc2UoKSxkPW8uc3BsaXQoIjoiKSxmPWQubGVuZ3RoLF89ODtkWzBdPT09IiImJmRbMV09PT0iIiYmZFsyXT09PSIiPyhkLnNoaWZ0KCksZC5zaGlmdCgpKTpkWzBdPT09IiImJmRbMV09PT0iIj9kLnNoaWZ0KCk6ZFtmLTFdPT09IiImJmRbZi0yXT09PSIiJiZkLnBvcCgpLGY9ZC5sZW5ndGgsZFtmLTFdLmluZGV4T2YoIi4iKSE9PS0xJiYoXz03KTt2YXIgbTtmb3IobT0wO208ZiYmZFttXSE9PSIiO20rKyk7aWYobTxfKWZvcihkLnNwbGljZShtLDEsIjAwMDAiKTtkLmxlbmd0aDxfOylkLnNwbGljZShtLDAsIjAwMDAiKTtmb3IodmFyIFMsdj0wO3Y8Xzt2Kyspe1M9ZFt2XS5zcGxpdCgiIik7Zm9yKHZhciB6PTA7ejwzJiZTWzBdPT09IjAiJiZTLmxlbmd0aD4xO3orKylTLnNwbGljZSgwLDEpO2Rbdl09Uy5qb2luKCIiKX12YXIgST0tMSxrPTAsTT0wLHE9LTEsRz0hMTtmb3Iodj0wO3Y8Xzt2KyspRz9kW3ZdPT09IjAiP00rPTE6KEc9ITEsTT5rJiYoST1xLGs9TSkpOmRbdl09PT0iMCImJihHPSEwLHE9dixNPTEpO00+ayYmKEk9cSxrPU0pLGs+MSYmZC5zcGxpY2UoSSxrLCIiKSxmPWQubGVuZ3RoO3ZhciBVPSIiO2ZvcihkWzBdPT09IiImJihVPSI6Iiksdj0wO3Y8ZiYmKFUrPWRbdl0sdiE9PWYtMSk7disrKVUrPSI6IjtyZXR1cm4gZFtmLTFdPT09IiImJihVKz0iOiIpLFV9ZnVuY3Rpb24gdSgpe3JldHVybiByLklQdjY9PT10aGlzJiYoci5JUHY2PW4pLHRoaXN9cmV0dXJue2Jlc3Q6aSxub0NvbmZsaWN0OnV9fSl9KShjcik7dmFyIGxyPXtleHBvcnRzOnt9fTsvKiEKKiBVUkkuanMgLSBNdXRhdGluZyBVUkxzCiogU2Vjb25kIExldmVsIERvbWFpbiAoU0xEKSBTdXBwb3J0CioKKiBWZXJzaW9uOiAxLjE5LjExCioKKiBBdXRob3I6IFJvZG5leSBSZWhtCiogV2ViOiBodHRwOi8vbWVkaWFsaXplLmdpdGh1Yi5pby9VUkkuanMvCioKKiBMaWNlbnNlZCB1bmRlcgoqICAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQoqCiovKGZ1bmN0aW9uKGUpeyhmdW5jdGlvbihyLG4pe2UuZXhwb3J0cz9lLmV4cG9ydHM9bigpOnIuU2Vjb25kTGV2ZWxEb21haW5zPW4ocil9KShnZSxmdW5jdGlvbihyKXt2YXIgbj1yJiZyLlNlY29uZExldmVsRG9tYWlucyxpPXtsaXN0OnthYzoiIGNvbSBnb3YgbWlsIG5ldCBvcmcgIixhZToiIGFjIGNvIGdvdiBtaWwgbmFtZSBuZXQgb3JnIHBybyBzY2ggIixhZjoiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixhbDoiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIsYW86IiBjbyBlZCBndiBpdCBvZyBwYiAiLGFyOiIgY29tIGVkdSBnb2IgZ292IGludCBtaWwgbmV0IG9yZyB0dXIgIixhdDoiIGFjIGNvIGd2IG9yICIsYXU6IiBhc24gY29tIGNzaXJvIGVkdSBnb3YgaWQgbmV0IG9yZyAiLGJhOiIgY28gY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgcnMgdW5iaSB1bm1vIHVuc2EgdW50eiB1bnplICIsYmI6IiBiaXogY28gY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnIHN0b3JlIHR2ICIsYmg6IiBiaXogY2MgY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnICIsYm46IiBjb20gZWR1IGdvdiBuZXQgb3JnICIsYm86IiBjb20gZWR1IGdvYiBnb3YgaW50IG1pbCBuZXQgb3JnIHR2ICIsYnI6IiBhZG0gYWR2IGFnciBhbSBhcnEgYXJ0IGF0byBiIGJpbyBibG9nIGJtZCBjaW0gY25nIGNudCBjb20gY29vcCBlY24gZWR1IGVuZyBlc3AgZXRjIGV0aSBmYXIgZmxvZyBmbSBmbmQgZm90IGZzdCBnMTIgZ2dmIGdvdiBpbWIgaW5kIGluZiBqb3IganVzIGxlbCBtYXQgbWVkIG1pbCBtdXMgbmV0IG5vbSBub3QgbnRyIG9kbyBvcmcgcHBnIHBybyBwc2MgcHNpIHFzbCByZWMgc2xnIHNydiB0bXAgdHJkIHR1ciB0diB2ZXQgdmxvZyB3aWtpIHpsZyAiLGJzOiIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLGJ6OiIgZHUgZXQgb20gb3YgcmcgIixjYToiIGFiIGJjIG1iIG5iIG5mIG5sIG5zIG50IG51IG9uIHBlIHFjIHNrIHlrICIsY2s6IiBiaXogY28gZWR1IGdlbiBnb3YgaW5mbyBuZXQgb3JnICIsY246IiBhYyBhaCBiaiBjb20gY3EgZWR1IGZqIGdkIGdvdiBncyBneCBneiBoYSBoYiBoZSBoaSBobCBobiBqbCBqcyBqeCBsbiBtaWwgbmV0IG5tIG54IG9yZyBxaCBzYyBzZCBzaCBzbiBzeCB0aiB0dyB4aiB4eiB5biB6aiAiLGNvOiIgY29tIGVkdSBnb3YgbWlsIG5ldCBub20gb3JnICIsY3I6IiBhYyBjIGNvIGVkIGZpIGdvIG9yIHNhICIsY3k6IiBhYyBiaXogY29tIGVrbG9nZXMgZ292IGx0ZCBuYW1lIG5ldCBvcmcgcGFybGlhbWVudCBwcmVzcyBwcm8gdG0gIixkbzoiIGFydCBjb20gZWR1IGdvYiBnb3YgbWlsIG5ldCBvcmcgc2xkIHdlYiAiLGR6OiIgYXJ0IGFzc28gY29tIGVkdSBnb3YgbmV0IG9yZyBwb2wgIixlYzoiIGNvbSBlZHUgZmluIGdvdiBpbmZvIG1lZCBtaWwgbmV0IG9yZyBwcm8gIixlZzoiIGNvbSBlZHUgZXVuIGdvdiBtaWwgbmFtZSBuZXQgb3JnIHNjaSAiLGVyOiIgY29tIGVkdSBnb3YgaW5kIG1pbCBuZXQgb3JnIHJvY2hlc3QgdyAiLGVzOiIgY29tIGVkdSBnb2Igbm9tIG9yZyAiLGV0OiIgYml6IGNvbSBlZHUgZ292IGluZm8gbmFtZSBuZXQgb3JnICIsZmo6IiBhYyBiaXogY29tIGluZm8gbWlsIG5hbWUgbmV0IG9yZyBwcm8gIixmazoiIGFjIGNvIGdvdiBuZXQgbm9tIG9yZyAiLGZyOiIgYXNzbyBjb20gZiBnb3V2IG5vbSBwcmQgcHJlc3NlIHRtICIsZ2c6IiBjbyBuZXQgb3JnICIsZ2g6IiBjb20gZWR1IGdvdiBtaWwgb3JnICIsZ246IiBhYyBjb20gZ292IG5ldCBvcmcgIixncjoiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIsZ3Q6IiBjb20gZWR1IGdvYiBpbmQgbWlsIG5ldCBvcmcgIixndToiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixoazoiIGNvbSBlZHUgZ292IGlkdiBuZXQgb3JnICIsaHU6IiAyMDAwIGFncmFyIGJvbHQgY2FzaW5vIGNpdHkgY28gZXJvdGljYSBlcm90aWthIGZpbG0gZm9ydW0gZ2FtZXMgaG90ZWwgaW5mbyBpbmdhdGxhbiBqb2dhc3oga29ueXZlbG8gbGFrYXMgbWVkaWEgbmV3cyBvcmcgcHJpdiByZWtsYW0gc2V4IHNob3Agc3BvcnQgc3VsaSBzemV4IHRtIHRvenNkZSB1dGF6YXMgdmlkZW8gIixpZDoiIGFjIGNvIGdvIG1pbCBuZXQgb3Igc2NoIHdlYiAiLGlsOiIgYWMgY28gZ292IGlkZiBrMTIgbXVuaSBuZXQgb3JnICIsaW46IiBhYyBjbyBlZHUgZXJuZXQgZmlybSBnZW4gZ292IGkgaW5kIG1pbCBuZXQgbmljIG9yZyByZXMgIixpcToiIGNvbSBlZHUgZ292IGkgbWlsIG5ldCBvcmcgIixpcjoiIGFjIGNvIGRuc3NlYyBnb3YgaSBpZCBuZXQgb3JnIHNjaCAiLGl0OiIgZWR1IGdvdiAiLGplOiIgY28gbmV0IG9yZyAiLGpvOiIgY29tIGVkdSBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2ggIixqcDoiIGFjIGFkIGNvIGVkIGdvIGdyIGxnIG5lIG9yICIsa2U6IiBhYyBjbyBnbyBpbmZvIG1lIG1vYmkgbmUgb3Igc2MgIixraDoiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnIHBlciAiLGtpOiIgYml6IGNvbSBkZSBlZHUgZ292IGluZm8gbW9iIG5ldCBvcmcgdGVsICIsa206IiBhc3NvIGNvbSBjb29wIGVkdSBnb3V2IGsgbWVkZWNpbiBtaWwgbm9tIG5vdGFpcmVzIHBoYXJtYWNpZW5zIHByZXNzZSB0bSB2ZXRlcmluYWlyZSAiLGtuOiIgZWR1IGdvdiBuZXQgb3JnICIsa3I6IiBhYyBidXNhbiBjaHVuZ2J1ayBjaHVuZ25hbSBjbyBkYWVndSBkYWVqZW9uIGVzIGdhbmd3b24gZ28gZ3dhbmdqdSBneWVvbmdidWsgZ3llb25nZ2kgZ3llb25nbmFtIGhzIGluY2hlb24gamVqdSBqZW9uYnVrIGplb25uYW0gayBrZyBtaWwgbXMgbmUgb3IgcGUgcmUgc2Mgc2VvdWwgdWxzYW4gIixrdzoiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixreToiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixrejoiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIsbGI6IiBjb20gZWR1IGdvdiBuZXQgb3JnICIsbGs6IiBhc3NuIGNvbSBlZHUgZ292IGdycCBob3RlbCBpbnQgbHRkIG5ldCBuZ28gb3JnIHNjaCBzb2Mgd2ViICIsbHI6IiBjb20gZWR1IGdvdiBuZXQgb3JnICIsbHY6IiBhc24gY29tIGNvbmYgZWR1IGdvdiBpZCBtaWwgbmV0IG9yZyAiLGx5OiIgY29tIGVkdSBnb3YgaWQgbWVkIG5ldCBvcmcgcGxjIHNjaCAiLG1hOiIgYWMgY28gZ292IG0gbmV0IG9yZyBwcmVzcyAiLG1jOiIgYXNzbyB0bSAiLG1lOiIgYWMgY28gZWR1IGdvdiBpdHMgbmV0IG9yZyBwcml2ICIsbWc6IiBjb20gZWR1IGdvdiBtaWwgbm9tIG9yZyBwcmQgdG0gIixtazoiIGNvbSBlZHUgZ292IGluZiBuYW1lIG5ldCBvcmcgcHJvICIsbWw6IiBjb20gZWR1IGdvdiBuZXQgb3JnIHByZXNzZSAiLG1uOiIgZWR1IGdvdiBvcmcgIixtbzoiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixtdDoiIGNvbSBlZHUgZ292IG5ldCBvcmcgIixtdjoiIGFlcm8gYml6IGNvbSBjb29wIGVkdSBnb3YgaW5mbyBpbnQgbWlsIG11c2V1bSBuYW1lIG5ldCBvcmcgcHJvICIsbXc6IiBhYyBjbyBjb20gY29vcCBlZHUgZ292IGludCBtdXNldW0gbmV0IG9yZyAiLG14OiIgY29tIGVkdSBnb2IgbmV0IG9yZyAiLG15OiIgY29tIGVkdSBnb3YgbWlsIG5hbWUgbmV0IG9yZyBzY2ggIixuZjoiIGFydHMgY29tIGZpcm0gaW5mbyBuZXQgb3RoZXIgcGVyIHJlYyBzdG9yZSB3ZWIgIixuZzoiIGJpeiBjb20gZWR1IGdvdiBtaWwgbW9iaSBuYW1lIG5ldCBvcmcgc2NoICIsbmk6IiBhYyBjbyBjb20gZWR1IGdvYiBtaWwgbmV0IG5vbSBvcmcgIixucDoiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIsbnI6IiBiaXogY29tIGVkdSBnb3YgaW5mbyBuZXQgb3JnICIsb206IiBhYyBiaXogY28gY29tIGVkdSBnb3YgbWVkIG1pbCBtdXNldW0gbmV0IG9yZyBwcm8gc2NoICIscGU6IiBjb20gZWR1IGdvYiBtaWwgbmV0IG5vbSBvcmcgc2xkICIscGg6IiBjb20gZWR1IGdvdiBpIG1pbCBuZXQgbmdvIG9yZyAiLHBrOiIgYml6IGNvbSBlZHUgZmFtIGdvYiBnb2sgZ29uIGdvcCBnb3MgZ292IG5ldCBvcmcgd2ViICIscGw6IiBhcnQgYmlhbHlzdG9rIGJpeiBjb20gZWR1IGdkYSBnZGFuc2sgZ29yem93IGdvdiBpbmZvIGthdG93aWNlIGtyYWtvdyBsb2R6IGx1YmxpbiBtaWwgbmV0IG5nbyBvbHN6dHluIG9yZyBwb3puYW4gcHdyIHJhZG9tIHNsdXBzayBzemN6ZWNpbiB0b3J1biB3YXJzemF3YSB3YXcgd3JvYyB3cm9jbGF3IHpnb3JhICIscHI6IiBhYyBiaXogY29tIGVkdSBlc3QgZ292IGluZm8gaXNsYSBuYW1lIG5ldCBvcmcgcHJvIHByb2YgIixwczoiIGNvbSBlZHUgZ292IG5ldCBvcmcgcGxvIHNlYyAiLHB3OiIgYmVsYXUgY28gZWQgZ28gbmUgb3IgIixybzoiIGFydHMgY29tIGZpcm0gaW5mbyBub20gbnQgb3JnIHJlYyBzdG9yZSB0bSB3d3cgIixyczoiIGFjIGNvIGVkdSBnb3YgaW4gb3JnICIsc2I6IiBjb20gZWR1IGdvdiBuZXQgb3JnICIsc2M6IiBjb20gZWR1IGdvdiBuZXQgb3JnICIsc2g6IiBjbyBjb20gZWR1IGdvdiBuZXQgbm9tIG9yZyAiLHNsOiIgY29tIGVkdSBnb3YgbmV0IG9yZyAiLHN0OiIgY28gY29tIGNvbnN1bGFkbyBlZHUgZW1iYWl4YWRhIGdvdiBtaWwgbmV0IG9yZyBwcmluY2lwZSBzYW90b21lIHN0b3JlICIsc3Y6IiBjb20gZWR1IGdvYiBvcmcgcmVkICIsc3o6IiBhYyBjbyBvcmcgIix0cjoiIGF2IGJicyBiZWwgYml6IGNvbSBkciBlZHUgZ2VuIGdvdiBpbmZvIGsxMiBuYW1lIG5ldCBvcmcgcG9sIHRlbCB0c2sgdHYgd2ViICIsdHQ6IiBhZXJvIGJpeiBjYXQgY28gY29tIGNvb3AgZWR1IGdvdiBpbmZvIGludCBqb2JzIG1pbCBtb2JpIG11c2V1bSBuYW1lIG5ldCBvcmcgcHJvIHRlbCB0cmF2ZWwgIix0dzoiIGNsdWIgY29tIGViaXogZWR1IGdhbWUgZ292IGlkdiBtaWwgbmV0IG9yZyAiLG11OiIgYWMgY28gY29tIGdvdiBuZXQgb3Igb3JnICIsbXo6IiBhYyBjbyBlZHUgZ292IG9yZyAiLG5hOiIgY28gY29tICIsbno6IiBhYyBjbyBjcmkgZ2VlayBnZW4gZ292dCBoZWFsdGggaXdpIG1hb3JpIG1pbCBuZXQgb3JnIHBhcmxpYW1lbnQgc2Nob29sICIscGE6IiBhYm8gYWMgY29tIGVkdSBnb2IgaW5nIG1lZCBuZXQgbm9tIG9yZyBzbGQgIixwdDoiIGNvbSBlZHUgZ292IGludCBuZXQgbm9tZSBvcmcgcHVibCAiLHB5OiIgY29tIGVkdSBnb3YgbWlsIG5ldCBvcmcgIixxYToiIGNvbSBlZHUgZ292IG1pbCBuZXQgb3JnICIscmU6IiBhc3NvIGNvbSBub20gIixydToiIGFjIGFkeWdleWEgYWx0YWkgYW11ciBhcmtoYW5nZWxzayBhc3RyYWtoYW4gYmFzaGtpcmlhIGJlbGdvcm9kIGJpciBicnlhbnNrIGJ1cnlhdGlhIGNiZyBjaGVsIGNoZWx5YWJpbnNrIGNoaXRhIGNodWtvdGthIGNodXZhc2hpYSBjb20gZGFnZXN0YW4gZS1idXJnIGVkdSBnb3YgZ3Jvem55IGludCBpcmt1dHNrIGl2YW5vdm8gaXpoZXZzayBqYXIgam9zaGthci1vbGEga2FsbXlraWEga2FsdWdhIGthbWNoYXRrYSBrYXJlbGlhIGthemFuIGtjaHIga2VtZXJvdm8ga2hhYmFyb3ZzayBraGFrYXNzaWEga2h2IGtpcm92IGtvZW5pZyBrb21pIGtvc3Ryb21hIGtyYW5veWFyc2sga3ViYW4ga3VyZ2FuIGt1cnNrIGxpcGV0c2sgbWFnYWRhbiBtYXJpIG1hcmktZWwgbWFyaW5lIG1pbCBtb3Jkb3ZpYSBtb3NyZWcgbXNrIG11cm1hbnNrIG5hbGNoaWsgbmV0IG5ub3Ygbm92IG5vdm9zaWJpcnNrIG5zayBvbXNrIG9yZW5idXJnIG9yZyBvcnlvbCBwZW56YSBwZXJtIHBwIHBza292IHB0eiBybmQgcnlhemFuIHNha2hhbGluIHNhbWFyYSBzYXJhdG92IHNpbWJpcnNrIHNtb2xlbnNrIHNwYiBzdGF2cm9wb2wgc3R2IHN1cmd1dCB0YW1ib3YgdGF0YXJzdGFuIHRvbSB0b21zayB0c2FyaXRzeW4gdHNrIHR1bGEgdHV2YSB0dmVyIHR5dW1lbiB1ZG0gdWRtdXJ0aWEgdWxhbi11ZGUgdmxhZGlrYXZrYXogdmxhZGltaXIgdmxhZGl2b3N0b2sgdm9sZ29ncmFkIHZvbG9nZGEgdm9yb25lemggdnJuIHZ5YXRrYSB5YWt1dGlhIHlhbWFsIHlla2F0ZXJpbmJ1cmcgeXV6aG5vLXNha2hhbGluc2sgIixydzoiIGFjIGNvIGNvbSBlZHUgZ291diBnb3YgaW50IG1pbCBuZXQgIixzYToiIGNvbSBlZHUgZ292IG1lZCBuZXQgb3JnIHB1YiBzY2ggIixzZDoiIGNvbSBlZHUgZ292IGluZm8gbWVkIG5ldCBvcmcgdHYgIixzZToiIGEgYWMgYiBiZCBjIGQgZSBmIGcgaCBpIGsgbCBtIG4gbyBvcmcgcCBwYXJ0aSBwcCBwcmVzcyByIHMgdCB0bSB1IHcgeCB5IHogIixzZzoiIGNvbSBlZHUgZ292IGlkbiBuZXQgb3JnIHBlciAiLHNuOiIgYXJ0IGNvbSBlZHUgZ291diBvcmcgcGVyc28gdW5pdiAiLHN5OiIgY29tIGVkdSBnb3YgbWlsIG5ldCBuZXdzIG9yZyAiLHRoOiIgYWMgY28gZ28gaW4gbWkgbmV0IG9yICIsdGo6IiBhYyBiaXogY28gY29tIGVkdSBnbyBnb3YgaW5mbyBpbnQgbWlsIG5hbWUgbmV0IG5pYyBvcmcgdGVzdCB3ZWIgIix0bjoiIGFncmluZXQgY29tIGRlZmVuc2UgZWR1bmV0IGVucyBmaW4gZ292IGluZCBpbmZvIGludGwgbWluY29tIG5hdCBuZXQgb3JnIHBlcnNvIHJucnQgcm5zIHJudSB0b3VyaXNtICIsdHo6IiBhYyBjbyBnbyBuZSBvciAiLHVhOiIgYml6IGNoZXJrYXNzeSBjaGVybmlnb3YgY2hlcm5vdnRzeSBjayBjbiBjbyBjb20gY3JpbWVhIGN2IGRuIGRuZXByb3BldHJvdnNrIGRvbmV0c2sgZHAgZWR1IGdvdiBpZiBpbiBpdmFuby1mcmFua2l2c2sga2gga2hhcmtvdiBraGVyc29uIGtobWVsbml0c2tpeSBraWV2IGtpcm92b2dyYWQga20ga3Iga3Mga3YgbGcgbHVnYW5zayBsdXRzayBsdml2IG1lIG1rIG5ldCBuaWtvbGFldiBvZCBvZGVzc2Egb3JnIHBsIHBvbHRhdmEgcHAgcm92bm8gcnYgc2ViYXN0b3BvbCBzdW15IHRlIHRlcm5vcGlsIHV6aGdvcm9kIHZpbm5pY2Egdm4gemFwb3Jpemh6aGUgemhpdG9taXIgenAgenQgIix1ZzoiIGFjIGNvIGdvIG5lIG9yIG9yZyBzYyAiLHVrOiIgYWMgYmwgYnJpdGlzaC1saWJyYXJ5IGNvIGN5bSBnb3YgZ292dCBpY25ldCBqZXQgbGVhIGx0ZCBtZSBtaWwgbW9kIG5hdGlvbmFsLWxpYnJhcnktc2NvdGxhbmQgbmVsIG5ldCBuaHMgbmljIG5scyBvcmcgb3JnbiBwYXJsaWFtZW50IHBsYyBwb2xpY2Ugc2NoIHNjb3Qgc29jICIsdXM6IiBkbmkgZmVkIGlzYSBraWRzIG5zbiAiLHV5OiIgY29tIGVkdSBndWIgbWlsIG5ldCBvcmcgIix2ZToiIGNvIGNvbSBlZHUgZ29iIGluZm8gbWlsIG5ldCBvcmcgd2ViICIsdmk6IiBjbyBjb20gazEyIG5ldCBvcmcgIix2bjoiIGFjIGJpeiBjb20gZWR1IGdvdiBoZWFsdGggaW5mbyBpbnQgbmFtZSBuZXQgb3JnIHBybyAiLHllOiIgY28gY29tIGdvdiBsdGQgbWUgbmV0IG9yZyBwbGMgIix5dToiIGFjIGNvIGVkdSBnb3Ygb3JnICIsemE6IiBhYyBhZ3JpYyBhbHQgYm91cnNlIGNpdHkgY28gY3liZXJuZXQgZGIgZWR1IGdvdiBncm9uZGFyIGlhY2Nlc3MgaW10IGluY2EgbGFuZGVzaWduIGxhdyBtaWwgbmV0IG5nbyBuaXMgbm9tIG9saXZldHRpIG9yZyBwaXggc2Nob29sIHRtIHdlYiAiLHptOiIgYWMgY28gY29tIGVkdSBnb3YgbmV0IG9yZyBzY2ggIixjb206ImFyIGJyIGNuIGRlIGV1IGdiIGdyIGh1IGpwbiBrciBubyBxYyBydSBzYSBzZSB1ayB1cyB1eSB6YSAiLG5ldDoiZ2IganAgc2UgdWsgIixvcmc6ImFlIixkZToiY29tICJ9LGhhczpmdW5jdGlvbih1KXt2YXIgcD11Lmxhc3RJbmRleE9mKCIuIik7aWYocDw9MHx8cD49dS5sZW5ndGgtMSlyZXR1cm4hMTt2YXIgbz11Lmxhc3RJbmRleE9mKCIuIixwLTEpO2lmKG88PTB8fG8+PXAtMSlyZXR1cm4hMTt2YXIgZD1pLmxpc3RbdS5zbGljZShwKzEpXTtyZXR1cm4gZD9kLmluZGV4T2YoIiAiK3Uuc2xpY2UobysxLHApKyIgIik+PTA6ITF9LGlzOmZ1bmN0aW9uKHUpe3ZhciBwPXUubGFzdEluZGV4T2YoIi4iKTtpZihwPD0wfHxwPj11Lmxlbmd0aC0xKXJldHVybiExO3ZhciBvPXUubGFzdEluZGV4T2YoIi4iLHAtMSk7aWYobz49MClyZXR1cm4hMTt2YXIgZD1pLmxpc3RbdS5zbGljZShwKzEpXTtyZXR1cm4gZD9kLmluZGV4T2YoIiAiK3Uuc2xpY2UoMCxwKSsiICIpPj0wOiExfSxnZXQ6ZnVuY3Rpb24odSl7dmFyIHA9dS5sYXN0SW5kZXhPZigiLiIpO2lmKHA8PTB8fHA+PXUubGVuZ3RoLTEpcmV0dXJuIG51bGw7dmFyIG89dS5sYXN0SW5kZXhPZigiLiIscC0xKTtpZihvPD0wfHxvPj1wLTEpcmV0dXJuIG51bGw7dmFyIGQ9aS5saXN0W3Uuc2xpY2UocCsxKV07cmV0dXJuIWR8fGQuaW5kZXhPZigiICIrdS5zbGljZShvKzEscCkrIiAiKTwwP251bGw6dS5zbGljZShvKzEpfSxub0NvbmZsaWN0OmZ1bmN0aW9uKCl7cmV0dXJuIHIuU2Vjb25kTGV2ZWxEb21haW5zPT09dGhpcyYmKHIuU2Vjb25kTGV2ZWxEb21haW5zPW4pLHRoaXN9fTtyZXR1cm4gaX0pfSkobHIpOy8qIQoqIFVSSS5qcyAtIE11dGF0aW5nIFVSTHMKKgoqIFZlcnNpb246IDEuMTkuMTEKKgoqIEF1dGhvcjogUm9kbmV5IFJlaG0KKiBXZWI6IGh0dHA6Ly9tZWRpYWxpemUuZ2l0aHViLmlvL1VSSS5qcy8KKgoqIExpY2Vuc2VkIHVuZGVyCiogICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCioKKi8oZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKHIsbil7ZS5leHBvcnRzP2UuZXhwb3J0cz1uKHB0LmV4cG9ydHMsY3IuZXhwb3J0cyxsci5leHBvcnRzKTpyLlVSST1uKHIucHVueWNvZGUsci5JUHY2LHIuU2Vjb25kTGV2ZWxEb21haW5zLHIpfSkoZ2UsZnVuY3Rpb24ocixuLGksdSl7dmFyIHA9dSYmdS5VUkk7ZnVuY3Rpb24gbyh0LHMpe3ZhciBhPWFyZ3VtZW50cy5sZW5ndGg+PTEsYz1hcmd1bWVudHMubGVuZ3RoPj0yO2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBhP2M/bmV3IG8odCxzKTpuZXcgbyh0KTpuZXcgbztpZih0PT09dm9pZCAwKXtpZihhKXRocm93IG5ldyBUeXBlRXJyb3IoInVuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCBhcmd1bWVudCBmb3IgVVJJIik7dHlwZW9mIGxvY2F0aW9uIT0idW5kZWZpbmVkIj90PWxvY2F0aW9uLmhyZWYrIiI6dD0iIn1pZih0PT09bnVsbCYmYSl0aHJvdyBuZXcgVHlwZUVycm9yKCJudWxsIGlzIG5vdCBhIHZhbGlkIGFyZ3VtZW50IGZvciBVUkkiKTtyZXR1cm4gdGhpcy5ocmVmKHQpLHMhPT12b2lkIDA/dGhpcy5hYnNvbHV0ZVRvKHMpOnRoaXN9ZnVuY3Rpb24gZCh0KXtyZXR1cm4vXlswLTldKyQvLnRlc3QodCl9by52ZXJzaW9uPSIxLjE5LjExIjt2YXIgZj1vLnByb3RvdHlwZSxfPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZnVuY3Rpb24gbSh0KXtyZXR1cm4gdC5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xdXC9cXF0pL2csIlxcJDEiKX1mdW5jdGlvbiBTKHQpe3JldHVybiB0PT09dm9pZCAwPyJVbmRlZmluZWQiOlN0cmluZyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpLnNsaWNlKDgsLTEpfWZ1bmN0aW9uIHYodCl7cmV0dXJuIFModCk9PT0iQXJyYXkifWZ1bmN0aW9uIHoodCxzKXt2YXIgYT17fSxjLGw7aWYoUyhzKT09PSJSZWdFeHAiKWE9bnVsbDtlbHNlIGlmKHYocykpZm9yKGM9MCxsPXMubGVuZ3RoO2M8bDtjKyspYVtzW2NdXT0hMDtlbHNlIGFbc109ITA7Zm9yKGM9MCxsPXQubGVuZ3RoO2M8bDtjKyspe3ZhciBoPWEmJmFbdFtjXV0hPT12b2lkIDB8fCFhJiZzLnRlc3QodFtjXSk7aCYmKHQuc3BsaWNlKGMsMSksbC0tLGMtLSl9cmV0dXJuIHR9ZnVuY3Rpb24gSSh0LHMpe3ZhciBhLGM7aWYodihzKSl7Zm9yKGE9MCxjPXMubGVuZ3RoO2E8YzthKyspaWYoIUkodCxzW2FdKSlyZXR1cm4hMTtyZXR1cm4hMH12YXIgbD1TKHMpO2ZvcihhPTAsYz10Lmxlbmd0aDthPGM7YSsrKWlmKGw9PT0iUmVnRXhwIil7aWYodHlwZW9mIHRbYV09PSJzdHJpbmciJiZ0W2FdLm1hdGNoKHMpKXJldHVybiEwfWVsc2UgaWYodFthXT09PXMpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gayh0LHMpe2lmKCF2KHQpfHwhdihzKXx8dC5sZW5ndGghPT1zLmxlbmd0aClyZXR1cm4hMTt0LnNvcnQoKSxzLnNvcnQoKTtmb3IodmFyIGE9MCxjPXQubGVuZ3RoO2E8YzthKyspaWYodFthXSE9PXNbYV0pcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gTSh0KXt2YXIgcz0vXlwvK3xcLyskL2c7cmV0dXJuIHQucmVwbGFjZShzLCIiKX1vLl9wYXJ0cz1mdW5jdGlvbigpe3JldHVybntwcm90b2NvbDpudWxsLHVzZXJuYW1lOm51bGwscGFzc3dvcmQ6bnVsbCxob3N0bmFtZTpudWxsLHVybjpudWxsLHBvcnQ6bnVsbCxwYXRoOm51bGwscXVlcnk6bnVsbCxmcmFnbWVudDpudWxsLHByZXZlbnRJbnZhbGlkSG9zdG5hbWU6by5wcmV2ZW50SW52YWxpZEhvc3RuYW1lLGR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVyczpvLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyxlc2NhcGVRdWVyeVNwYWNlOm8uZXNjYXBlUXVlcnlTcGFjZX19LG8ucHJldmVudEludmFsaWRIb3N0bmFtZT0hMSxvLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycz0hMSxvLmVzY2FwZVF1ZXJ5U3BhY2U9ITAsby5wcm90b2NvbF9leHByZXNzaW9uPS9eW2Etel1bYS16MC05ListXSokL2ksby5pZG5fZXhwcmVzc2lvbj0vW15hLXowLTlcLl8tXS9pLG8ucHVueWNvZGVfZXhwcmVzc2lvbj0vKHhuLS0pL2ksby5pcDRfZXhwcmVzc2lvbj0vXlxkezEsM31cLlxkezEsM31cLlxkezEsM31cLlxkezEsM30kLyxvLmlwNl9leHByZXNzaW9uPS9eXHMqKCgoWzAtOUEtRmEtZl17MSw0fTopezd9KFswLTlBLUZhLWZdezEsNH18OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezZ9KDpbMC05QS1GYS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7NX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7NH0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOUEtRmEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezN9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNH0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKShcLigyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7Mn0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKFwuKDI1WzAtNV18MlswLTRdXGR8MVxkXGR8WzEtOV0/XGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXsxfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkoXC4oMjVbMC01XXwyWzAtNF1cZHwxXGRcZHxbMS05XT9cZCkpezN9KSl8OikpfCg6KCgoOlswLTlBLUZhLWZdezEsNH0pezEsN30pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKShcLigyNVswLTVdfDJbMC00XVxkfDFcZFxkfFsxLTldP1xkKSl7M30pKXw6KSkpKCUuKyk/XHMqJC8sby5maW5kX3VyaV9leHByZXNzaW9uPS9cYigoPzpbYS16XVtcdy1dKzooPzpcL3sxLDN9fFthLXowLTklXSl8d3d3XGR7MCwzfVsuXXxbYS16MC05LlwtXStbLl1bYS16XXsyLDR9XC8pKD86W15ccygpPD5dK3xcKChbXlxzKCk8Pl0rfChcKFteXHMoKTw+XStcKSkpKlwpKSsoPzpcKChbXlxzKCk8Pl0rfChcKFteXHMoKTw+XStcKSkpKlwpfFteXHNgISgpXFtcXXt9OzonIi4sPD4/wqvCu+KAnOKAneKAmOKAmV0pKS9pZyxvLmZpbmRVcmk9e3N0YXJ0Oi9cYig/OihbYS16XVthLXowLTkuKy1dKjpcL1wvKXx3d3dcLikvZ2ksZW5kOi9bXHNcclxuXXwkLyx0cmltOi9bYCEoKVxbXF17fTs6JyIuLDw+P8KrwrvigJzigJ3igJ7igJjigJldKyQvLHBhcmVuczovKFwoW15cKV0qXCl8XFtbXlxdXSpcXXxce1tefV0qXH18PFtePl0qPikvZ30sby5sZWFkaW5nX3doaXRlc3BhY2VfZXhwcmVzc2lvbj0vXltceDAwLVx4MjBcdTAwYTBcdTE2ODBcdTIwMDAtXHUyMDBhXHUyMDI4XHUyMDI5XHUyMDJmXHUyMDVmXHUzMDAwXHVmZWZmXSsvLG8uYXNjaWlfdGFiX3doaXRlc3BhY2U9L1tcdTAwMDlcdTAwMEFcdTAwMERdKy9nLG8uZGVmYXVsdFBvcnRzPXtodHRwOiI4MCIsaHR0cHM6IjQ0MyIsZnRwOiIyMSIsZ29waGVyOiI3MCIsd3M6IjgwIix3c3M6IjQ0MyJ9LG8uaG9zdFByb3RvY29scz1bImh0dHAiLCJodHRwcyJdLG8uaW52YWxpZF9ob3N0bmFtZV9jaGFyYWN0ZXJzPS9bXmEtekEtWjAtOVwuXC06X10vLG8uZG9tQXR0cmlidXRlcz17YToiaHJlZiIsYmxvY2txdW90ZToiY2l0ZSIsbGluazoiaHJlZiIsYmFzZToiaHJlZiIsc2NyaXB0OiJzcmMiLGZvcm06ImFjdGlvbiIsaW1nOiJzcmMiLGFyZWE6ImhyZWYiLGlmcmFtZToic3JjIixlbWJlZDoic3JjIixzb3VyY2U6InNyYyIsdHJhY2s6InNyYyIsaW5wdXQ6InNyYyIsYXVkaW86InNyYyIsdmlkZW86InNyYyJ9LG8uZ2V0RG9tQXR0cmlidXRlPWZ1bmN0aW9uKHQpe2lmKCEoIXR8fCF0Lm5vZGVOYW1lKSl7dmFyIHM9dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKCEocz09PSJpbnB1dCImJnQudHlwZSE9PSJpbWFnZSIpKXJldHVybiBvLmRvbUF0dHJpYnV0ZXNbc119fTtmdW5jdGlvbiBxKHQpe3JldHVybiBlc2NhcGUodCl9ZnVuY3Rpb24gRyh0KXtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHQpLnJlcGxhY2UoL1shJygpKl0vZyxxKS5yZXBsYWNlKC9cKi9nLCIlMkEiKX1vLmVuY29kZT1HLG8uZGVjb2RlPWRlY29kZVVSSUNvbXBvbmVudCxvLmlzbzg4NTk9ZnVuY3Rpb24oKXtvLmVuY29kZT1lc2NhcGUsby5kZWNvZGU9dW5lc2NhcGV9LG8udW5pY29kZT1mdW5jdGlvbigpe28uZW5jb2RlPUcsby5kZWNvZGU9ZGVjb2RlVVJJQ29tcG9uZW50fSxvLmNoYXJhY3RlcnM9e3BhdGhuYW1lOntlbmNvZGU6e2V4cHJlc3Npb246LyUoMjR8MjZ8MkJ8MkN8M0J8M0R8M0F8NDApL2lnLG1hcDp7IiUyNCI6IiQiLCIlMjYiOiImIiwiJTJCIjoiKyIsIiUyQyI6IiwiLCIlM0IiOiI7IiwiJTNEIjoiPSIsIiUzQSI6IjoiLCIlNDAiOiJAIn19LGRlY29kZTp7ZXhwcmVzc2lvbjovW1wvXD8jXS9nLG1hcDp7Ii8iOiIlMkYiLCI/IjoiJTNGIiwiIyI6IiUyMyJ9fX0scmVzZXJ2ZWQ6e2VuY29kZTp7ZXhwcmVzc2lvbjovJSgyMXwyM3wyNHwyNnwyN3wyOHwyOXwyQXwyQnwyQ3wyRnwzQXwzQnwzRHwzRnw0MHw1Qnw1RCkvaWcsbWFwOnsiJTNBIjoiOiIsIiUyRiI6Ii8iLCIlM0YiOiI/IiwiJTIzIjoiIyIsIiU1QiI6IlsiLCIlNUQiOiJdIiwiJTQwIjoiQCIsIiUyMSI6IiEiLCIlMjQiOiIkIiwiJTI2IjoiJiIsIiUyNyI6IiciLCIlMjgiOiIoIiwiJTI5IjoiKSIsIiUyQSI6IioiLCIlMkIiOiIrIiwiJTJDIjoiLCIsIiUzQiI6IjsiLCIlM0QiOiI9In19fSx1cm5wYXRoOntlbmNvZGU6e2V4cHJlc3Npb246LyUoMjF8MjR8Mjd8Mjh8Mjl8MkF8MkJ8MkN8M0J8M0R8NDApL2lnLG1hcDp7IiUyMSI6IiEiLCIlMjQiOiIkIiwiJTI3IjoiJyIsIiUyOCI6IigiLCIlMjkiOiIpIiwiJTJBIjoiKiIsIiUyQiI6IisiLCIlMkMiOiIsIiwiJTNCIjoiOyIsIiUzRCI6Ij0iLCIlNDAiOiJAIn19LGRlY29kZTp7ZXhwcmVzc2lvbjovW1wvXD8jOl0vZyxtYXA6eyIvIjoiJTJGIiwiPyI6IiUzRiIsIiMiOiIlMjMiLCI6IjoiJTNBIn19fX0sby5lbmNvZGVRdWVyeT1mdW5jdGlvbih0LHMpe3ZhciBhPW8uZW5jb2RlKHQrIiIpO3JldHVybiBzPT09dm9pZCAwJiYocz1vLmVzY2FwZVF1ZXJ5U3BhY2UpLHM/YS5yZXBsYWNlKC8lMjAvZywiKyIpOmF9LG8uZGVjb2RlUXVlcnk9ZnVuY3Rpb24odCxzKXt0Kz0iIixzPT09dm9pZCAwJiYocz1vLmVzY2FwZVF1ZXJ5U3BhY2UpO3RyeXtyZXR1cm4gby5kZWNvZGUocz90LnJlcGxhY2UoL1wrL2csIiUyMCIpOnQpfWNhdGNoe3JldHVybiB0fX07dmFyIFU9e2VuY29kZToiZW5jb2RlIixkZWNvZGU6ImRlY29kZSJ9LEEsRT1mdW5jdGlvbih0LHMpe3JldHVybiBmdW5jdGlvbihhKXt0cnl7cmV0dXJuIG9bc10oYSsiIikucmVwbGFjZShvLmNoYXJhY3RlcnNbdF1bc10uZXhwcmVzc2lvbixmdW5jdGlvbihjKXtyZXR1cm4gby5jaGFyYWN0ZXJzW3RdW3NdLm1hcFtjXX0pfWNhdGNoe3JldHVybiBhfX19O2ZvcihBIGluIFUpb1tBKyJQYXRoU2VnbWVudCJdPUUoInBhdGhuYW1lIixVW0FdKSxvW0ErIlVyblBhdGhTZWdtZW50Il09RSgidXJucGF0aCIsVVtBXSk7dmFyIEg9ZnVuY3Rpb24odCxzLGEpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgbDthP2w9ZnVuY3Rpb24oUil7cmV0dXJuIG9bc10ob1thXShSKSl9Omw9b1tzXTtmb3IodmFyIGg9KGMrIiIpLnNwbGl0KHQpLGc9MCxiPWgubGVuZ3RoO2c8YjtnKyspaFtnXT1sKGhbZ10pO3JldHVybiBoLmpvaW4odCl9fTtvLmRlY29kZVBhdGg9SCgiLyIsImRlY29kZVBhdGhTZWdtZW50Iiksby5kZWNvZGVVcm5QYXRoPUgoIjoiLCJkZWNvZGVVcm5QYXRoU2VnbWVudCIpLG8ucmVjb2RlUGF0aD1IKCIvIiwiZW5jb2RlUGF0aFNlZ21lbnQiLCJkZWNvZGUiKSxvLnJlY29kZVVyblBhdGg9SCgiOiIsImVuY29kZVVyblBhdGhTZWdtZW50IiwiZGVjb2RlIiksby5lbmNvZGVSZXNlcnZlZD1FKCJyZXNlcnZlZCIsImVuY29kZSIpLG8ucGFyc2U9ZnVuY3Rpb24odCxzKXt2YXIgYTtyZXR1cm4gc3x8KHM9e3ByZXZlbnRJbnZhbGlkSG9zdG5hbWU6by5wcmV2ZW50SW52YWxpZEhvc3RuYW1lfSksdD10LnJlcGxhY2Uoby5sZWFkaW5nX3doaXRlc3BhY2VfZXhwcmVzc2lvbiwiIiksdD10LnJlcGxhY2Uoby5hc2NpaV90YWJfd2hpdGVzcGFjZSwiIiksYT10LmluZGV4T2YoIiMiKSxhPi0xJiYocy5mcmFnbWVudD10LnN1YnN0cmluZyhhKzEpfHxudWxsLHQ9dC5zdWJzdHJpbmcoMCxhKSksYT10LmluZGV4T2YoIj8iKSxhPi0xJiYocy5xdWVyeT10LnN1YnN0cmluZyhhKzEpfHxudWxsLHQ9dC5zdWJzdHJpbmcoMCxhKSksdD10LnJlcGxhY2UoL14oaHR0cHM/fGZ0cHx3c3M/KT86K1svXFxdKi9pLCIkMTovLyIpLHQ9dC5yZXBsYWNlKC9eWy9cXF17Mix9L2ksIi8vIiksdC5zdWJzdHJpbmcoMCwyKT09PSIvLyI/KHMucHJvdG9jb2w9bnVsbCx0PXQuc3Vic3RyaW5nKDIpLHQ9by5wYXJzZUF1dGhvcml0eSh0LHMpKTooYT10LmluZGV4T2YoIjoiKSxhPi0xJiYocy5wcm90b2NvbD10LnN1YnN0cmluZygwLGEpfHxudWxsLHMucHJvdG9jb2wmJiFzLnByb3RvY29sLm1hdGNoKG8ucHJvdG9jb2xfZXhwcmVzc2lvbik/cy5wcm90b2NvbD12b2lkIDA6dC5zdWJzdHJpbmcoYSsxLGErMykucmVwbGFjZSgvXFwvZywiLyIpPT09Ii8vIj8odD10LnN1YnN0cmluZyhhKzMpLHQ9by5wYXJzZUF1dGhvcml0eSh0LHMpKToodD10LnN1YnN0cmluZyhhKzEpLHMudXJuPSEwKSkpLHMucGF0aD10LHN9LG8ucGFyc2VIb3N0PWZ1bmN0aW9uKHQscyl7dHx8KHQ9IiIpLHQ9dC5yZXBsYWNlKC9cXC9nLCIvIik7dmFyIGE9dC5pbmRleE9mKCIvIiksYyxsO2lmKGE9PT0tMSYmKGE9dC5sZW5ndGgpLHQuY2hhckF0KDApPT09IlsiKWM9dC5pbmRleE9mKCJdIikscy5ob3N0bmFtZT10LnN1YnN0cmluZygxLGMpfHxudWxsLHMucG9ydD10LnN1YnN0cmluZyhjKzIsYSl8fG51bGwscy5wb3J0PT09Ii8iJiYocy5wb3J0PW51bGwpO2Vsc2V7dmFyIGg9dC5pbmRleE9mKCI6IiksZz10LmluZGV4T2YoIi8iKSxiPXQuaW5kZXhPZigiOiIsaCsxKTtiIT09LTEmJihnPT09LTF8fGI8Zyk/KHMuaG9zdG5hbWU9dC5zdWJzdHJpbmcoMCxhKXx8bnVsbCxzLnBvcnQ9bnVsbCk6KGw9dC5zdWJzdHJpbmcoMCxhKS5zcGxpdCgiOiIpLHMuaG9zdG5hbWU9bFswXXx8bnVsbCxzLnBvcnQ9bFsxXXx8bnVsbCl9cmV0dXJuIHMuaG9zdG5hbWUmJnQuc3Vic3RyaW5nKGEpLmNoYXJBdCgwKSE9PSIvIiYmKGErKyx0PSIvIit0KSxzLnByZXZlbnRJbnZhbGlkSG9zdG5hbWUmJm8uZW5zdXJlVmFsaWRIb3N0bmFtZShzLmhvc3RuYW1lLHMucHJvdG9jb2wpLHMucG9ydCYmby5lbnN1cmVWYWxpZFBvcnQocy5wb3J0KSx0LnN1YnN0cmluZyhhKXx8Ii8ifSxvLnBhcnNlQXV0aG9yaXR5PWZ1bmN0aW9uKHQscyl7cmV0dXJuIHQ9by5wYXJzZVVzZXJpbmZvKHQscyksby5wYXJzZUhvc3QodCxzKX0sby5wYXJzZVVzZXJpbmZvPWZ1bmN0aW9uKHQscyl7dmFyIGE9dCxjPXQuaW5kZXhPZigiXFwiKTtjIT09LTEmJih0PXQucmVwbGFjZSgvXFwvZywiLyIpKTt2YXIgbD10LmluZGV4T2YoIi8iKSxoPXQubGFzdEluZGV4T2YoIkAiLGw+LTE/bDp0Lmxlbmd0aC0xKSxnO3JldHVybiBoPi0xJiYobD09PS0xfHxoPGwpPyhnPXQuc3Vic3RyaW5nKDAsaCkuc3BsaXQoIjoiKSxzLnVzZXJuYW1lPWdbMF0/by5kZWNvZGUoZ1swXSk6bnVsbCxnLnNoaWZ0KCkscy5wYXNzd29yZD1nWzBdP28uZGVjb2RlKGcuam9pbigiOiIpKTpudWxsLHQ9YS5zdWJzdHJpbmcoaCsxKSk6KHMudXNlcm5hbWU9bnVsbCxzLnBhc3N3b3JkPW51bGwpLHR9LG8ucGFyc2VRdWVyeT1mdW5jdGlvbih0LHMpe2lmKCF0KXJldHVybnt9O2lmKHQ9dC5yZXBsYWNlKC8mKy9nLCImIikucmVwbGFjZSgvXlw/KiYqfCYrJC9nLCIiKSwhdClyZXR1cm57fTtmb3IodmFyIGE9e30sYz10LnNwbGl0KCImIiksbD1jLmxlbmd0aCxoLGcsYixSPTA7UjxsO1IrKyloPWNbUl0uc3BsaXQoIj0iKSxnPW8uZGVjb2RlUXVlcnkoaC5zaGlmdCgpLHMpLGI9aC5sZW5ndGg/by5kZWNvZGVRdWVyeShoLmpvaW4oIj0iKSxzKTpudWxsLGchPT0iX19wcm90b19fIiYmKF8uY2FsbChhLGcpPygodHlwZW9mIGFbZ109PSJzdHJpbmcifHxhW2ddPT09bnVsbCkmJihhW2ddPVthW2ddXSksYVtnXS5wdXNoKGIpKTphW2ddPWIpO3JldHVybiBhfSxvLmJ1aWxkPWZ1bmN0aW9uKHQpe3ZhciBzPSIiLGE9ITE7cmV0dXJuIHQucHJvdG9jb2wmJihzKz10LnByb3RvY29sKyI6IiksIXQudXJuJiYoc3x8dC5ob3N0bmFtZSkmJihzKz0iLy8iLGE9ITApLHMrPW8uYnVpbGRBdXRob3JpdHkodCl8fCIiLHR5cGVvZiB0LnBhdGg9PSJzdHJpbmciJiYodC5wYXRoLmNoYXJBdCgwKSE9PSIvIiYmYSYmKHMrPSIvIikscys9dC5wYXRoKSx0eXBlb2YgdC5xdWVyeT09InN0cmluZyImJnQucXVlcnkmJihzKz0iPyIrdC5xdWVyeSksdHlwZW9mIHQuZnJhZ21lbnQ9PSJzdHJpbmciJiZ0LmZyYWdtZW50JiYocys9IiMiK3QuZnJhZ21lbnQpLHN9LG8uYnVpbGRIb3N0PWZ1bmN0aW9uKHQpe3ZhciBzPSIiO2lmKHQuaG9zdG5hbWUpby5pcDZfZXhwcmVzc2lvbi50ZXN0KHQuaG9zdG5hbWUpP3MrPSJbIit0Lmhvc3RuYW1lKyJdIjpzKz10Lmhvc3RuYW1lO2Vsc2UgcmV0dXJuIiI7cmV0dXJuIHQucG9ydCYmKHMrPSI6Iit0LnBvcnQpLHN9LG8uYnVpbGRBdXRob3JpdHk9ZnVuY3Rpb24odCl7cmV0dXJuIG8uYnVpbGRVc2VyaW5mbyh0KStvLmJ1aWxkSG9zdCh0KX0sby5idWlsZFVzZXJpbmZvPWZ1bmN0aW9uKHQpe3ZhciBzPSIiO3JldHVybiB0LnVzZXJuYW1lJiYocys9by5lbmNvZGUodC51c2VybmFtZSkpLHQucGFzc3dvcmQmJihzKz0iOiIrby5lbmNvZGUodC5wYXNzd29yZCkpLHMmJihzKz0iQCIpLHN9LG8uYnVpbGRRdWVyeT1mdW5jdGlvbih0LHMsYSl7dmFyIGM9IiIsbCxoLGcsYjtmb3IoaCBpbiB0KWlmKGghPT0iX19wcm90b19fIiYmXy5jYWxsKHQsaCkpaWYodih0W2hdKSlmb3IobD17fSxnPTAsYj10W2hdLmxlbmd0aDtnPGI7ZysrKXRbaF1bZ10hPT12b2lkIDAmJmxbdFtoXVtnXSsiIl09PT12b2lkIDAmJihjKz0iJiIrby5idWlsZFF1ZXJ5UGFyYW1ldGVyKGgsdFtoXVtnXSxhKSxzIT09ITAmJihsW3RbaF1bZ10rIiJdPSEwKSk7ZWxzZSB0W2hdIT09dm9pZCAwJiYoYys9IiYiK28uYnVpbGRRdWVyeVBhcmFtZXRlcihoLHRbaF0sYSkpO3JldHVybiBjLnN1YnN0cmluZygxKX0sby5idWlsZFF1ZXJ5UGFyYW1ldGVyPWZ1bmN0aW9uKHQscyxhKXtyZXR1cm4gby5lbmNvZGVRdWVyeSh0LGEpKyhzIT09bnVsbD8iPSIrby5lbmNvZGVRdWVyeShzLGEpOiIiKX0sby5hZGRRdWVyeT1mdW5jdGlvbih0LHMsYSl7aWYodHlwZW9mIHM9PSJvYmplY3QiKWZvcih2YXIgYyBpbiBzKV8uY2FsbChzLGMpJiZvLmFkZFF1ZXJ5KHQsYyxzW2NdKTtlbHNlIGlmKHR5cGVvZiBzPT0ic3RyaW5nIil7aWYodFtzXT09PXZvaWQgMCl7dFtzXT1hO3JldHVybn1lbHNlIHR5cGVvZiB0W3NdPT0ic3RyaW5nIiYmKHRbc109W3Rbc11dKTt2KGEpfHwoYT1bYV0pLHRbc109KHRbc118fFtdKS5jb25jYXQoYSl9ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJVUkkuYWRkUXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nIGFzIHRoZSBuYW1lIHBhcmFtZXRlciIpfSxvLnNldFF1ZXJ5PWZ1bmN0aW9uKHQscyxhKXtpZih0eXBlb2Ygcz09Im9iamVjdCIpZm9yKHZhciBjIGluIHMpXy5jYWxsKHMsYykmJm8uc2V0UXVlcnkodCxjLHNbY10pO2Vsc2UgaWYodHlwZW9mIHM9PSJzdHJpbmciKXRbc109YT09PXZvaWQgMD9udWxsOmE7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJVUkkuc2V0UXVlcnkoKSBhY2NlcHRzIGFuIG9iamVjdCwgc3RyaW5nIGFzIHRoZSBuYW1lIHBhcmFtZXRlciIpfSxvLnJlbW92ZVF1ZXJ5PWZ1bmN0aW9uKHQscyxhKXt2YXIgYyxsLGg7aWYodihzKSlmb3IoYz0wLGw9cy5sZW5ndGg7YzxsO2MrKyl0W3NbY11dPXZvaWQgMDtlbHNlIGlmKFMocyk9PT0iUmVnRXhwIilmb3IoaCBpbiB0KXMudGVzdChoKSYmKHRbaF09dm9pZCAwKTtlbHNlIGlmKHR5cGVvZiBzPT0ib2JqZWN0Iilmb3IoaCBpbiBzKV8uY2FsbChzLGgpJiZvLnJlbW92ZVF1ZXJ5KHQsaCxzW2hdKTtlbHNlIGlmKHR5cGVvZiBzPT0ic3RyaW5nIilhIT09dm9pZCAwP1MoYSk9PT0iUmVnRXhwIj8hdih0W3NdKSYmYS50ZXN0KHRbc10pP3Rbc109dm9pZCAwOnRbc109eih0W3NdLGEpOnRbc109PT1TdHJpbmcoYSkmJighdihhKXx8YS5sZW5ndGg9PT0xKT90W3NdPXZvaWQgMDp2KHRbc10pJiYodFtzXT16KHRbc10sYSkpOnRbc109dm9pZCAwO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiVVJJLnJlbW92ZVF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZywgUmVnRXhwIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIiKX0sby5oYXNRdWVyeT1mdW5jdGlvbih0LHMsYSxjKXtzd2l0Y2goUyhzKSl7Y2FzZSJTdHJpbmciOmJyZWFrO2Nhc2UiUmVnRXhwIjpmb3IodmFyIGwgaW4gdClpZihfLmNhbGwodCxsKSYmcy50ZXN0KGwpJiYoYT09PXZvaWQgMHx8by5oYXNRdWVyeSh0LGwsYSkpKXJldHVybiEwO3JldHVybiExO2Nhc2UiT2JqZWN0Ijpmb3IodmFyIGggaW4gcylpZihfLmNhbGwocyxoKSYmIW8uaGFzUXVlcnkodCxoLHNbaF0pKXJldHVybiExO3JldHVybiEwO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVVJJLmhhc1F1ZXJ5KCkgYWNjZXB0cyBhIHN0cmluZywgcmVndWxhciBleHByZXNzaW9uIG9yIG9iamVjdCBhcyB0aGUgbmFtZSBwYXJhbWV0ZXIiKX1zd2l0Y2goUyhhKSl7Y2FzZSJVbmRlZmluZWQiOnJldHVybiBzIGluIHQ7Y2FzZSJCb29sZWFuIjp2YXIgZz1Cb29sZWFuKHYodFtzXSk/dFtzXS5sZW5ndGg6dFtzXSk7cmV0dXJuIGE9PT1nO2Nhc2UiRnVuY3Rpb24iOnJldHVybiEhYSh0W3NdLHMsdCk7Y2FzZSJBcnJheSI6aWYoIXYodFtzXSkpcmV0dXJuITE7dmFyIGI9Yz9JOms7cmV0dXJuIGIodFtzXSxhKTtjYXNlIlJlZ0V4cCI6cmV0dXJuIHYodFtzXSk/Yz9JKHRbc10sYSk6ITE6Qm9vbGVhbih0W3NdJiZ0W3NdLm1hdGNoKGEpKTtjYXNlIk51bWJlciI6YT1TdHJpbmcoYSk7Y2FzZSJTdHJpbmciOnJldHVybiB2KHRbc10pP2M/SSh0W3NdLGEpOiExOnRbc109PT1hO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVVJJLmhhc1F1ZXJ5KCkgYWNjZXB0cyB1bmRlZmluZWQsIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyLCBSZWdFeHAsIEZ1bmN0aW9uIGFzIHRoZSB2YWx1ZSBwYXJhbWV0ZXIiKX19LG8uam9pblBhdGhzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLHM9W10sYT0wLGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKXt2YXIgbD1uZXcgbyhhcmd1bWVudHNbY10pO3QucHVzaChsKTtmb3IodmFyIGg9bC5zZWdtZW50KCksZz0wO2c8aC5sZW5ndGg7ZysrKXR5cGVvZiBoW2ddPT0ic3RyaW5nIiYmcy5wdXNoKGhbZ10pLGhbZ10mJmErK31pZighcy5sZW5ndGh8fCFhKXJldHVybiBuZXcgbygiIik7dmFyIGI9bmV3IG8oIiIpLnNlZ21lbnQocyk7cmV0dXJuKHRbMF0ucGF0aCgpPT09IiJ8fHRbMF0ucGF0aCgpLnNsaWNlKDAsMSk9PT0iLyIpJiZiLnBhdGgoIi8iK2IucGF0aCgpKSxiLm5vcm1hbGl6ZSgpfSxvLmNvbW1vblBhdGg9ZnVuY3Rpb24odCxzKXt2YXIgYT1NYXRoLm1pbih0Lmxlbmd0aCxzLmxlbmd0aCksYztmb3IoYz0wO2M8YTtjKyspaWYodC5jaGFyQXQoYykhPT1zLmNoYXJBdChjKSl7Yy0tO2JyZWFrfXJldHVybiBjPDE/dC5jaGFyQXQoMCk9PT1zLmNoYXJBdCgwKSYmdC5jaGFyQXQoMCk9PT0iLyI/Ii8iOiIiOigodC5jaGFyQXQoYykhPT0iLyJ8fHMuY2hhckF0KGMpIT09Ii8iKSYmKGM9dC5zdWJzdHJpbmcoMCxjKS5sYXN0SW5kZXhPZigiLyIpKSx0LnN1YnN0cmluZygwLGMrMSkpfSxvLndpdGhpblN0cmluZz1mdW5jdGlvbih0LHMsYSl7YXx8KGE9e30pO3ZhciBjPWEuc3RhcnR8fG8uZmluZFVyaS5zdGFydCxsPWEuZW5kfHxvLmZpbmRVcmkuZW5kLGg9YS50cmltfHxvLmZpbmRVcmkudHJpbSxnPWEucGFyZW5zfHxvLmZpbmRVcmkucGFyZW5zLGI9L1thLXowLTktXT1bIiddPyQvaTtmb3IoYy5sYXN0SW5kZXg9MDs7KXt2YXIgUj1jLmV4ZWModCk7aWYoIVIpYnJlYWs7dmFyIFA9Ui5pbmRleDtpZihhLmlnbm9yZUh0bWwpe3ZhciBMPXQuc2xpY2UoTWF0aC5tYXgoUC0zLDApLFApO2lmKEwmJmIudGVzdChMKSljb250aW51ZX1mb3IodmFyIE49UCt0LnNsaWNlKFApLnNlYXJjaChsKSxqPXQuc2xpY2UoUCxOKSxUPS0xOzspe3ZhciBLPWcuZXhlYyhqKTtpZighSylicmVhazt2YXIgcmU9Sy5pbmRleCtLWzBdLmxlbmd0aDtUPU1hdGgubWF4KFQscmUpfWlmKFQ+LTE/aj1qLnNsaWNlKDAsVCkrai5zbGljZShUKS5yZXBsYWNlKGgsIiIpOmo9ai5yZXBsYWNlKGgsIiIpLCEoai5sZW5ndGg8PVJbMF0ubGVuZ3RoKSYmIShhLmlnbm9yZSYmYS5pZ25vcmUudGVzdChqKSkpe049UCtqLmxlbmd0aDt2YXIgQz1zKGosUCxOLHQpO2lmKEM9PT12b2lkIDApe2MubGFzdEluZGV4PU47Y29udGludWV9Qz1TdHJpbmcoQyksdD10LnNsaWNlKDAsUCkrQyt0LnNsaWNlKE4pLGMubGFzdEluZGV4PVArQy5sZW5ndGh9fXJldHVybiBjLmxhc3RJbmRleD0wLHR9LG8uZW5zdXJlVmFsaWRIb3N0bmFtZT1mdW5jdGlvbih0LHMpe3ZhciBhPSEhdCxjPSEhcyxsPSExO2lmKGMmJihsPUkoby5ob3N0UHJvdG9jb2xzLHMpKSxsJiYhYSl0aHJvdyBuZXcgVHlwZUVycm9yKCJIb3N0bmFtZSBjYW5ub3QgYmUgZW1wdHksIGlmIHByb3RvY29sIGlzICIrcyk7aWYodCYmdC5tYXRjaChvLmludmFsaWRfaG9zdG5hbWVfY2hhcmFjdGVycykpe2lmKCFyKXRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lICInK3QrJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLTpfXSBhbmQgUHVueWNvZGUuanMgaXMgbm90IGF2YWlsYWJsZScpO2lmKHIudG9BU0NJSSh0KS5tYXRjaChvLmludmFsaWRfaG9zdG5hbWVfY2hhcmFjdGVycykpdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgIicrdCsnIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tOl9dJyl9fSxvLmVuc3VyZVZhbGlkUG9ydD1mdW5jdGlvbih0KXtpZih0KXt2YXIgcz1OdW1iZXIodCk7aWYoIShkKHMpJiZzPjAmJnM8NjU1MzYpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1BvcnQgIicrdCsnIiBpcyBub3QgYSB2YWxpZCBwb3J0Jyl9fSxvLm5vQ29uZmxpY3Q9ZnVuY3Rpb24odCl7aWYodCl7dmFyIHM9e1VSSTp0aGlzLm5vQ29uZmxpY3QoKX07cmV0dXJuIHUuVVJJVGVtcGxhdGUmJnR5cGVvZiB1LlVSSVRlbXBsYXRlLm5vQ29uZmxpY3Q9PSJmdW5jdGlvbiImJihzLlVSSVRlbXBsYXRlPXUuVVJJVGVtcGxhdGUubm9Db25mbGljdCgpKSx1LklQdjYmJnR5cGVvZiB1LklQdjYubm9Db25mbGljdD09ImZ1bmN0aW9uIiYmKHMuSVB2Nj11LklQdjYubm9Db25mbGljdCgpKSx1LlNlY29uZExldmVsRG9tYWlucyYmdHlwZW9mIHUuU2Vjb25kTGV2ZWxEb21haW5zLm5vQ29uZmxpY3Q9PSJmdW5jdGlvbiImJihzLlNlY29uZExldmVsRG9tYWlucz11LlNlY29uZExldmVsRG9tYWlucy5ub0NvbmZsaWN0KCkpLHN9ZWxzZSB1LlVSST09PXRoaXMmJih1LlVSST1wKTtyZXR1cm4gdGhpc30sZi5idWlsZD1mdW5jdGlvbih0KXtyZXR1cm4gdD09PSEwP3RoaXMuX2RlZmVycmVkX2J1aWxkPSEwOih0PT09dm9pZCAwfHx0aGlzLl9kZWZlcnJlZF9idWlsZCkmJih0aGlzLl9zdHJpbmc9by5idWlsZCh0aGlzLl9wYXJ0cyksdGhpcy5fZGVmZXJyZWRfYnVpbGQ9ITEpLHRoaXN9LGYuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG8odGhpcyl9LGYudmFsdWVPZj1mLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbGQoITEpLl9zdHJpbmd9O2Z1bmN0aW9uICQodCl7cmV0dXJuIGZ1bmN0aW9uKHMsYSl7cmV0dXJuIHM9PT12b2lkIDA/dGhpcy5fcGFydHNbdF18fCIiOih0aGlzLl9wYXJ0c1t0XT1zfHxudWxsLHRoaXMuYnVpbGQoIWEpLHRoaXMpfX1mdW5jdGlvbiB4KHQscyl7cmV0dXJuIGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGE9PT12b2lkIDA/dGhpcy5fcGFydHNbdF18fCIiOihhIT09bnVsbCYmKGE9YSsiIixhLmNoYXJBdCgwKT09PXMmJihhPWEuc3Vic3RyaW5nKDEpKSksdGhpcy5fcGFydHNbdF09YSx0aGlzLmJ1aWxkKCFjKSx0aGlzKX19Zi5wcm90b2NvbD0kKCJwcm90b2NvbCIpLGYudXNlcm5hbWU9JCgidXNlcm5hbWUiKSxmLnBhc3N3b3JkPSQoInBhc3N3b3JkIiksZi5ob3N0bmFtZT0kKCJob3N0bmFtZSIpLGYucG9ydD0kKCJwb3J0IiksZi5xdWVyeT14KCJxdWVyeSIsIj8iKSxmLmZyYWdtZW50PXgoImZyYWdtZW50IiwiIyIpLGYuc2VhcmNoPWZ1bmN0aW9uKHQscyl7dmFyIGE9dGhpcy5xdWVyeSh0LHMpO3JldHVybiB0eXBlb2YgYT09InN0cmluZyImJmEubGVuZ3RoPyI/IithOmF9LGYuaGFzaD1mdW5jdGlvbih0LHMpe3ZhciBhPXRoaXMuZnJhZ21lbnQodCxzKTtyZXR1cm4gdHlwZW9mIGE9PSJzdHJpbmciJiZhLmxlbmd0aD8iIyIrYTphfSxmLnBhdGhuYW1lPWZ1bmN0aW9uKHQscyl7aWYodD09PXZvaWQgMHx8dD09PSEwKXt2YXIgYT10aGlzLl9wYXJ0cy5wYXRofHwodGhpcy5fcGFydHMuaG9zdG5hbWU/Ii8iOiIiKTtyZXR1cm4gdD8odGhpcy5fcGFydHMudXJuP28uZGVjb2RlVXJuUGF0aDpvLmRlY29kZVBhdGgpKGEpOmF9ZWxzZSByZXR1cm4gdGhpcy5fcGFydHMudXJuP3RoaXMuX3BhcnRzLnBhdGg9dD9vLnJlY29kZVVyblBhdGgodCk6IiI6dGhpcy5fcGFydHMucGF0aD10P28ucmVjb2RlUGF0aCh0KToiLyIsdGhpcy5idWlsZCghcyksdGhpc30sZi5wYXRoPWYucGF0aG5hbWUsZi5ocmVmPWZ1bmN0aW9uKHQscyl7dmFyIGE7aWYodD09PXZvaWQgMClyZXR1cm4gdGhpcy50b1N0cmluZygpO3RoaXMuX3N0cmluZz0iIix0aGlzLl9wYXJ0cz1vLl9wYXJ0cygpO3ZhciBjPXQgaW5zdGFuY2VvZiBvLGw9dHlwZW9mIHQ9PSJvYmplY3QiJiYodC5ob3N0bmFtZXx8dC5wYXRofHx0LnBhdGhuYW1lKTtpZih0Lm5vZGVOYW1lKXt2YXIgaD1vLmdldERvbUF0dHJpYnV0ZSh0KTt0PXRbaF18fCIiLGw9ITF9aWYoIWMmJmwmJnQucGF0aG5hbWUhPT12b2lkIDAmJih0PXQudG9TdHJpbmcoKSksdHlwZW9mIHQ9PSJzdHJpbmcifHx0IGluc3RhbmNlb2YgU3RyaW5nKXRoaXMuX3BhcnRzPW8ucGFyc2UoU3RyaW5nKHQpLHRoaXMuX3BhcnRzKTtlbHNlIGlmKGN8fGwpe3ZhciBnPWM/dC5fcGFydHM6dDtmb3IoYSBpbiBnKWEhPT0icXVlcnkiJiZfLmNhbGwodGhpcy5fcGFydHMsYSkmJih0aGlzLl9wYXJ0c1thXT1nW2FdKTtnLnF1ZXJ5JiZ0aGlzLnF1ZXJ5KGcucXVlcnksITEpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiaW52YWxpZCBpbnB1dCIpO3JldHVybiB0aGlzLmJ1aWxkKCFzKSx0aGlzfSxmLmlzPWZ1bmN0aW9uKHQpe3ZhciBzPSExLGE9ITEsYz0hMSxsPSExLGg9ITEsZz0hMSxiPSExLFI9IXRoaXMuX3BhcnRzLnVybjtzd2l0Y2godGhpcy5fcGFydHMuaG9zdG5hbWUmJihSPSExLGE9by5pcDRfZXhwcmVzc2lvbi50ZXN0KHRoaXMuX3BhcnRzLmhvc3RuYW1lKSxjPW8uaXA2X2V4cHJlc3Npb24udGVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkscz1hfHxjLGw9IXMsaD1sJiZpJiZpLmhhcyh0aGlzLl9wYXJ0cy5ob3N0bmFtZSksZz1sJiZvLmlkbl9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpLGI9bCYmby5wdW55Y29kZV9leHByZXNzaW9uLnRlc3QodGhpcy5fcGFydHMuaG9zdG5hbWUpKSx0LnRvTG93ZXJDYXNlKCkpe2Nhc2UicmVsYXRpdmUiOnJldHVybiBSO2Nhc2UiYWJzb2x1dGUiOnJldHVybiFSO2Nhc2UiZG9tYWluIjpjYXNlIm5hbWUiOnJldHVybiBsO2Nhc2Uic2xkIjpyZXR1cm4gaDtjYXNlImlwIjpyZXR1cm4gcztjYXNlImlwNCI6Y2FzZSJpcHY0IjpjYXNlImluZXQ0IjpyZXR1cm4gYTtjYXNlImlwNiI6Y2FzZSJpcHY2IjpjYXNlImluZXQ2IjpyZXR1cm4gYztjYXNlImlkbiI6cmV0dXJuIGc7Y2FzZSJ1cmwiOnJldHVybiF0aGlzLl9wYXJ0cy51cm47Y2FzZSJ1cm4iOnJldHVybiEhdGhpcy5fcGFydHMudXJuO2Nhc2UicHVueWNvZGUiOnJldHVybiBifXJldHVybiBudWxsfTt2YXIgTz1mLnByb3RvY29sLFE9Zi5wb3J0LHk9Zi5ob3N0bmFtZTtmLnByb3RvY29sPWZ1bmN0aW9uKHQscyl7aWYodCYmKHQ9dC5yZXBsYWNlKC86KFwvXC8pPyQvLCIiKSwhdC5tYXRjaChvLnByb3RvY29sX2V4cHJlc3Npb24pKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm90b2NvbCAiJyt0K2AiIGNvbnRhaW5zIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBbQS1aMC05ListXSBvciBkb2Vzbid0IHN0YXJ0IHdpdGggW0EtWl1gKTtyZXR1cm4gTy5jYWxsKHRoaXMsdCxzKX0sZi5zY2hlbWU9Zi5wcm90b2NvbCxmLnBvcnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gdGhpcy5fcGFydHMudXJuP3Q9PT12b2lkIDA/IiI6dGhpczoodCE9PXZvaWQgMCYmKHQ9PT0wJiYodD1udWxsKSx0JiYodCs9IiIsdC5jaGFyQXQoMCk9PT0iOiImJih0PXQuc3Vic3RyaW5nKDEpKSxvLmVuc3VyZVZhbGlkUG9ydCh0KSkpLFEuY2FsbCh0aGlzLHQscykpfSxmLmhvc3RuYW1lPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodCE9PXZvaWQgMCl7dmFyIGE9e3ByZXZlbnRJbnZhbGlkSG9zdG5hbWU6dGhpcy5fcGFydHMucHJldmVudEludmFsaWRIb3N0bmFtZX0sYz1vLnBhcnNlSG9zdCh0LGEpO2lmKGMhPT0iLyIpdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgIicrdCsnIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tXScpO3Q9YS5ob3N0bmFtZSx0aGlzLl9wYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lJiZvLmVuc3VyZVZhbGlkSG9zdG5hbWUodCx0aGlzLl9wYXJ0cy5wcm90b2NvbCl9cmV0dXJuIHkuY2FsbCh0aGlzLHQscyl9LGYub3JpZ2luPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodD09PXZvaWQgMCl7dmFyIGE9dGhpcy5wcm90b2NvbCgpLGM9dGhpcy5hdXRob3JpdHkoKTtyZXR1cm4gYz8oYT9hKyI6Ly8iOiIiKSt0aGlzLmF1dGhvcml0eSgpOiIifWVsc2V7dmFyIGw9byh0KTtyZXR1cm4gdGhpcy5wcm90b2NvbChsLnByb3RvY29sKCkpLmF1dGhvcml0eShsLmF1dGhvcml0eSgpKS5idWlsZCghcyksdGhpc319LGYuaG9zdD1mdW5jdGlvbih0LHMpe2lmKHRoaXMuX3BhcnRzLnVybilyZXR1cm4gdD09PXZvaWQgMD8iIjp0aGlzO2lmKHQ9PT12b2lkIDApcmV0dXJuIHRoaXMuX3BhcnRzLmhvc3RuYW1lP28uYnVpbGRIb3N0KHRoaXMuX3BhcnRzKToiIjt2YXIgYT1vLnBhcnNlSG9zdCh0LHRoaXMuX3BhcnRzKTtpZihhIT09Ii8iKXRocm93IG5ldyBUeXBlRXJyb3IoJ0hvc3RuYW1lICInK3QrJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTkuLV0nKTtyZXR1cm4gdGhpcy5idWlsZCghcyksdGhpc30sZi5hdXRob3JpdHk9ZnVuY3Rpb24odCxzKXtpZih0aGlzLl9wYXJ0cy51cm4pcmV0dXJuIHQ9PT12b2lkIDA/IiI6dGhpcztpZih0PT09dm9pZCAwKXJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZT9vLmJ1aWxkQXV0aG9yaXR5KHRoaXMuX3BhcnRzKToiIjt2YXIgYT1vLnBhcnNlQXV0aG9yaXR5KHQsdGhpcy5fcGFydHMpO2lmKGEhPT0iLyIpdGhyb3cgbmV3IFR5cGVFcnJvcignSG9zdG5hbWUgIicrdCsnIiBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gW0EtWjAtOS4tXScpO3JldHVybiB0aGlzLmJ1aWxkKCFzKSx0aGlzfSxmLnVzZXJpbmZvPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodD09PXZvaWQgMCl7dmFyIGE9by5idWlsZFVzZXJpbmZvKHRoaXMuX3BhcnRzKTtyZXR1cm4gYSYmYS5zdWJzdHJpbmcoMCxhLmxlbmd0aC0xKX1lbHNlIHJldHVybiB0W3QubGVuZ3RoLTFdIT09IkAiJiYodCs9IkAiKSxvLnBhcnNlVXNlcmluZm8odCx0aGlzLl9wYXJ0cyksdGhpcy5idWlsZCghcyksdGhpc30sZi5yZXNvdXJjZT1mdW5jdGlvbih0LHMpe3ZhciBhO3JldHVybiB0PT09dm9pZCAwP3RoaXMucGF0aCgpK3RoaXMuc2VhcmNoKCkrdGhpcy5oYXNoKCk6KGE9by5wYXJzZSh0KSx0aGlzLl9wYXJ0cy5wYXRoPWEucGF0aCx0aGlzLl9wYXJ0cy5xdWVyeT1hLnF1ZXJ5LHRoaXMuX3BhcnRzLmZyYWdtZW50PWEuZnJhZ21lbnQsdGhpcy5idWlsZCghcyksdGhpcyl9LGYuc3ViZG9tYWluPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodD09PXZvaWQgMCl7aWYoIXRoaXMuX3BhcnRzLmhvc3RuYW1lfHx0aGlzLmlzKCJJUCIpKXJldHVybiIiO3ZhciBhPXRoaXMuX3BhcnRzLmhvc3RuYW1lLmxlbmd0aC10aGlzLmRvbWFpbigpLmxlbmd0aC0xO3JldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCxhKXx8IiJ9ZWxzZXt2YXIgYz10aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGgtdGhpcy5kb21haW4oKS5sZW5ndGgsbD10aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoMCxjKSxoPW5ldyBSZWdFeHAoIl4iK20obCkpO2lmKHQmJnQuY2hhckF0KHQubGVuZ3RoLTEpIT09Ii4iJiYodCs9Ii4iKSx0LmluZGV4T2YoIjoiKSE9PS0xKXRocm93IG5ldyBUeXBlRXJyb3IoIkRvbWFpbnMgY2Fubm90IGNvbnRhaW4gY29sb25zIik7cmV0dXJuIHQmJm8uZW5zdXJlVmFsaWRIb3N0bmFtZSh0LHRoaXMuX3BhcnRzLnByb3RvY29sKSx0aGlzLl9wYXJ0cy5ob3N0bmFtZT10aGlzLl9wYXJ0cy5ob3N0bmFtZS5yZXBsYWNlKGgsdCksdGhpcy5idWlsZCghcyksdGhpc319LGYuZG9tYWluPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodHlwZW9mIHQ9PSJib29sZWFuIiYmKHM9dCx0PXZvaWQgMCksdD09PXZvaWQgMCl7aWYoIXRoaXMuX3BhcnRzLmhvc3RuYW1lfHx0aGlzLmlzKCJJUCIpKXJldHVybiIiO3ZhciBhPXRoaXMuX3BhcnRzLmhvc3RuYW1lLm1hdGNoKC9cLi9nKTtpZihhJiZhLmxlbmd0aDwyKXJldHVybiB0aGlzLl9wYXJ0cy5ob3N0bmFtZTt2YXIgYz10aGlzLl9wYXJ0cy5ob3N0bmFtZS5sZW5ndGgtdGhpcy50bGQocykubGVuZ3RoLTE7cmV0dXJuIGM9dGhpcy5fcGFydHMuaG9zdG5hbWUubGFzdEluZGV4T2YoIi4iLGMtMSkrMSx0aGlzLl9wYXJ0cy5ob3N0bmFtZS5zdWJzdHJpbmcoYyl8fCIifWVsc2V7aWYoIXQpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2Fubm90IHNldCBkb21haW4gZW1wdHkiKTtpZih0LmluZGV4T2YoIjoiKSE9PS0xKXRocm93IG5ldyBUeXBlRXJyb3IoIkRvbWFpbnMgY2Fubm90IGNvbnRhaW4gY29sb25zIik7aWYoby5lbnN1cmVWYWxpZEhvc3RuYW1lKHQsdGhpcy5fcGFydHMucHJvdG9jb2wpLCF0aGlzLl9wYXJ0cy5ob3N0bmFtZXx8dGhpcy5pcygiSVAiKSl0aGlzLl9wYXJ0cy5ob3N0bmFtZT10O2Vsc2V7dmFyIGw9bmV3IFJlZ0V4cChtKHRoaXMuZG9tYWluKCkpKyIkIik7dGhpcy5fcGFydHMuaG9zdG5hbWU9dGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShsLHQpfXJldHVybiB0aGlzLmJ1aWxkKCFzKSx0aGlzfX0sZi50bGQ9ZnVuY3Rpb24odCxzKXtpZih0aGlzLl9wYXJ0cy51cm4pcmV0dXJuIHQ9PT12b2lkIDA/IiI6dGhpcztpZih0eXBlb2YgdD09ImJvb2xlYW4iJiYocz10LHQ9dm9pZCAwKSx0PT09dm9pZCAwKXtpZighdGhpcy5fcGFydHMuaG9zdG5hbWV8fHRoaXMuaXMoIklQIikpcmV0dXJuIiI7dmFyIGE9dGhpcy5fcGFydHMuaG9zdG5hbWUubGFzdEluZGV4T2YoIi4iKSxjPXRoaXMuX3BhcnRzLmhvc3RuYW1lLnN1YnN0cmluZyhhKzEpO3JldHVybiBzIT09ITAmJmkmJmkubGlzdFtjLnRvTG93ZXJDYXNlKCldJiZpLmdldCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSl8fGN9ZWxzZXt2YXIgbDtpZih0KWlmKHQubWF0Y2goL1teYS16QS1aMC05LV0vKSlpZihpJiZpLmlzKHQpKWw9bmV3IFJlZ0V4cChtKHRoaXMudGxkKCkpKyIkIiksdGhpcy5fcGFydHMuaG9zdG5hbWU9dGhpcy5fcGFydHMuaG9zdG5hbWUucmVwbGFjZShsLHQpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcignVExEICInK3QrJyIgY29udGFpbnMgY2hhcmFjdGVycyBvdGhlciB0aGFuIFtBLVowLTldJyk7ZWxzZXtpZighdGhpcy5fcGFydHMuaG9zdG5hbWV8fHRoaXMuaXMoIklQIikpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJjYW5ub3Qgc2V0IFRMRCBvbiBub24tZG9tYWluIGhvc3QiKTtsPW5ldyBSZWdFeHAobSh0aGlzLnRsZCgpKSsiJCIpLHRoaXMuX3BhcnRzLmhvc3RuYW1lPXRoaXMuX3BhcnRzLmhvc3RuYW1lLnJlcGxhY2UobCx0KX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImNhbm5vdCBzZXQgVExEIGVtcHR5Iik7cmV0dXJuIHRoaXMuYnVpbGQoIXMpLHRoaXN9fSxmLmRpcmVjdG9yeT1mdW5jdGlvbih0LHMpe2lmKHRoaXMuX3BhcnRzLnVybilyZXR1cm4gdD09PXZvaWQgMD8iIjp0aGlzO2lmKHQ9PT12b2lkIDB8fHQ9PT0hMCl7aWYoIXRoaXMuX3BhcnRzLnBhdGgmJiF0aGlzLl9wYXJ0cy5ob3N0bmFtZSlyZXR1cm4iIjtpZih0aGlzLl9wYXJ0cy5wYXRoPT09Ii8iKXJldHVybiIvIjt2YXIgYT10aGlzLl9wYXJ0cy5wYXRoLmxlbmd0aC10aGlzLmZpbGVuYW1lKCkubGVuZ3RoLTEsYz10aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZygwLGEpfHwodGhpcy5fcGFydHMuaG9zdG5hbWU/Ii8iOiIiKTtyZXR1cm4gdD9vLmRlY29kZVBhdGgoYyk6Y31lbHNle3ZhciBsPXRoaXMuX3BhcnRzLnBhdGgubGVuZ3RoLXRoaXMuZmlsZW5hbWUoKS5sZW5ndGgsaD10aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZygwLGwpLGc9bmV3IFJlZ0V4cCgiXiIrbShoKSk7cmV0dXJuIHRoaXMuaXMoInJlbGF0aXZlIil8fCh0fHwodD0iLyIpLHQuY2hhckF0KDApIT09Ii8iJiYodD0iLyIrdCkpLHQmJnQuY2hhckF0KHQubGVuZ3RoLTEpIT09Ii8iJiYodCs9Ii8iKSx0PW8ucmVjb2RlUGF0aCh0KSx0aGlzLl9wYXJ0cy5wYXRoPXRoaXMuX3BhcnRzLnBhdGgucmVwbGFjZShnLHQpLHRoaXMuYnVpbGQoIXMpLHRoaXN9fSxmLmZpbGVuYW1lPWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodHlwZW9mIHQhPSJzdHJpbmciKXtpZighdGhpcy5fcGFydHMucGF0aHx8dGhpcy5fcGFydHMucGF0aD09PSIvIilyZXR1cm4iIjt2YXIgYT10aGlzLl9wYXJ0cy5wYXRoLmxhc3RJbmRleE9mKCIvIiksYz10aGlzLl9wYXJ0cy5wYXRoLnN1YnN0cmluZyhhKzEpO3JldHVybiB0P28uZGVjb2RlUGF0aFNlZ21lbnQoYyk6Y31lbHNle3ZhciBsPSExO3QuY2hhckF0KDApPT09Ii8iJiYodD10LnN1YnN0cmluZygxKSksdC5tYXRjaCgvXC4/XC8vKSYmKGw9ITApO3ZhciBoPW5ldyBSZWdFeHAobSh0aGlzLmZpbGVuYW1lKCkpKyIkIik7cmV0dXJuIHQ9by5yZWNvZGVQYXRoKHQpLHRoaXMuX3BhcnRzLnBhdGg9dGhpcy5fcGFydHMucGF0aC5yZXBsYWNlKGgsdCksbD90aGlzLm5vcm1hbGl6ZVBhdGgocyk6dGhpcy5idWlsZCghcyksdGhpc319LGYuc3VmZml4PWZ1bmN0aW9uKHQscyl7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0PT09dm9pZCAwPyIiOnRoaXM7aWYodD09PXZvaWQgMHx8dD09PSEwKXtpZighdGhpcy5fcGFydHMucGF0aHx8dGhpcy5fcGFydHMucGF0aD09PSIvIilyZXR1cm4iIjt2YXIgYT10aGlzLmZpbGVuYW1lKCksYz1hLmxhc3RJbmRleE9mKCIuIiksbCxoO3JldHVybiBjPT09LTE/IiI6KGw9YS5zdWJzdHJpbmcoYysxKSxoPS9eW2EtejAtOSVdKyQvaS50ZXN0KGwpP2w6IiIsdD9vLmRlY29kZVBhdGhTZWdtZW50KGgpOmgpfWVsc2V7dC5jaGFyQXQoMCk9PT0iLiImJih0PXQuc3Vic3RyaW5nKDEpKTt2YXIgZz10aGlzLnN1ZmZpeCgpLGI7aWYoZyl0P2I9bmV3IFJlZ0V4cChtKGcpKyIkIik6Yj1uZXcgUmVnRXhwKG0oIi4iK2cpKyIkIik7ZWxzZXtpZighdClyZXR1cm4gdGhpczt0aGlzLl9wYXJ0cy5wYXRoKz0iLiIrby5yZWNvZGVQYXRoKHQpfXJldHVybiBiJiYodD1vLnJlY29kZVBhdGgodCksdGhpcy5fcGFydHMucGF0aD10aGlzLl9wYXJ0cy5wYXRoLnJlcGxhY2UoYix0KSksdGhpcy5idWlsZCghcyksdGhpc319LGYuc2VnbWVudD1mdW5jdGlvbih0LHMsYSl7dmFyIGM9dGhpcy5fcGFydHMudXJuPyI6IjoiLyIsbD10aGlzLnBhdGgoKSxoPWwuc3Vic3RyaW5nKDAsMSk9PT0iLyIsZz1sLnNwbGl0KGMpO2lmKHQhPT12b2lkIDAmJnR5cGVvZiB0IT0ibnVtYmVyIiYmKGE9cyxzPXQsdD12b2lkIDApLHQhPT12b2lkIDAmJnR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzZWdtZW50ICInK3QrJyIsIG11c3QgYmUgMC1iYXNlZCBpbnRlZ2VyJyk7aWYoaCYmZy5zaGlmdCgpLHQ8MCYmKHQ9TWF0aC5tYXgoZy5sZW5ndGgrdCwwKSkscz09PXZvaWQgMClyZXR1cm4gdD09PXZvaWQgMD9nOmdbdF07aWYodD09PW51bGx8fGdbdF09PT12b2lkIDApaWYodihzKSl7Zz1bXTtmb3IodmFyIGI9MCxSPXMubGVuZ3RoO2I8UjtiKyspIXNbYl0ubGVuZ3RoJiYoIWcubGVuZ3RofHwhZ1tnLmxlbmd0aC0xXS5sZW5ndGgpfHwoZy5sZW5ndGgmJiFnW2cubGVuZ3RoLTFdLmxlbmd0aCYmZy5wb3AoKSxnLnB1c2goTShzW2JdKSkpfWVsc2Uoc3x8dHlwZW9mIHM9PSJzdHJpbmciKSYmKHM9TShzKSxnW2cubGVuZ3RoLTFdPT09IiI/Z1tnLmxlbmd0aC0xXT1zOmcucHVzaChzKSk7ZWxzZSBzP2dbdF09TShzKTpnLnNwbGljZSh0LDEpO3JldHVybiBoJiZnLnVuc2hpZnQoIiIpLHRoaXMucGF0aChnLmpvaW4oYyksYSl9LGYuc2VnbWVudENvZGVkPWZ1bmN0aW9uKHQscyxhKXt2YXIgYyxsLGg7aWYodHlwZW9mIHQhPSJudW1iZXIiJiYoYT1zLHM9dCx0PXZvaWQgMCkscz09PXZvaWQgMCl7aWYoYz10aGlzLnNlZ21lbnQodCxzLGEpLCF2KGMpKWM9YyE9PXZvaWQgMD9vLmRlY29kZShjKTp2b2lkIDA7ZWxzZSBmb3IobD0wLGg9Yy5sZW5ndGg7bDxoO2wrKyljW2xdPW8uZGVjb2RlKGNbbF0pO3JldHVybiBjfWlmKCF2KHMpKXM9dHlwZW9mIHM9PSJzdHJpbmcifHxzIGluc3RhbmNlb2YgU3RyaW5nP28uZW5jb2RlKHMpOnM7ZWxzZSBmb3IobD0wLGg9cy5sZW5ndGg7bDxoO2wrKylzW2xdPW8uZW5jb2RlKHNbbF0pO3JldHVybiB0aGlzLnNlZ21lbnQodCxzLGEpfTt2YXIgRj1mLnF1ZXJ5O3JldHVybiBmLnF1ZXJ5PWZ1bmN0aW9uKHQscyl7aWYodD09PSEwKXJldHVybiBvLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7aWYodHlwZW9mIHQ9PSJmdW5jdGlvbiIpe3ZhciBhPW8ucGFyc2VRdWVyeSh0aGlzLl9wYXJ0cy5xdWVyeSx0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKSxjPXQuY2FsbCh0aGlzLGEpO3JldHVybiB0aGlzLl9wYXJ0cy5xdWVyeT1vLmJ1aWxkUXVlcnkoY3x8YSx0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSksdGhpcy5idWlsZCghcyksdGhpc31lbHNlIHJldHVybiB0IT09dm9pZCAwJiZ0eXBlb2YgdCE9InN0cmluZyI/KHRoaXMuX3BhcnRzLnF1ZXJ5PW8uYnVpbGRRdWVyeSh0LHRoaXMuX3BhcnRzLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycyx0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKSx0aGlzLmJ1aWxkKCFzKSx0aGlzKTpGLmNhbGwodGhpcyx0LHMpfSxmLnNldFF1ZXJ5PWZ1bmN0aW9uKHQscyxhKXt2YXIgYz1vLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7aWYodHlwZW9mIHQ9PSJzdHJpbmcifHx0IGluc3RhbmNlb2YgU3RyaW5nKWNbdF09cyE9PXZvaWQgMD9zOm51bGw7ZWxzZSBpZih0eXBlb2YgdD09Im9iamVjdCIpZm9yKHZhciBsIGluIHQpXy5jYWxsKHQsbCkmJihjW2xdPXRbbF0pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcigiVVJJLmFkZFF1ZXJ5KCkgYWNjZXB0cyBhbiBvYmplY3QsIHN0cmluZyBhcyB0aGUgbmFtZSBwYXJhbWV0ZXIiKTtyZXR1cm4gdGhpcy5fcGFydHMucXVlcnk9by5idWlsZFF1ZXJ5KGMsdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpLHR5cGVvZiB0IT0ic3RyaW5nIiYmKGE9cyksdGhpcy5idWlsZCghYSksdGhpc30sZi5hZGRRdWVyeT1mdW5jdGlvbih0LHMsYSl7dmFyIGM9by5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO3JldHVybiBvLmFkZFF1ZXJ5KGMsdCxzPT09dm9pZCAwP251bGw6cyksdGhpcy5fcGFydHMucXVlcnk9by5idWlsZFF1ZXJ5KGMsdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzLHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpLHR5cGVvZiB0IT0ic3RyaW5nIiYmKGE9cyksdGhpcy5idWlsZCghYSksdGhpc30sZi5yZW1vdmVRdWVyeT1mdW5jdGlvbih0LHMsYSl7dmFyIGM9by5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpO3JldHVybiBvLnJlbW92ZVF1ZXJ5KGMsdCxzKSx0aGlzLl9wYXJ0cy5xdWVyeT1vLmJ1aWxkUXVlcnkoYyx0aGlzLl9wYXJ0cy5kdXBsaWNhdGVRdWVyeVBhcmFtZXRlcnMsdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSksdHlwZW9mIHQhPSJzdHJpbmciJiYoYT1zKSx0aGlzLmJ1aWxkKCFhKSx0aGlzfSxmLmhhc1F1ZXJ5PWZ1bmN0aW9uKHQscyxhKXt2YXIgYz1vLnBhcnNlUXVlcnkodGhpcy5fcGFydHMucXVlcnksdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSk7cmV0dXJuIG8uaGFzUXVlcnkoYyx0LHMsYSl9LGYuc2V0U2VhcmNoPWYuc2V0UXVlcnksZi5hZGRTZWFyY2g9Zi5hZGRRdWVyeSxmLnJlbW92ZVNlYXJjaD1mLnJlbW92ZVF1ZXJ5LGYuaGFzU2VhcmNoPWYuaGFzUXVlcnksZi5ub3JtYWxpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGFydHMudXJuP3RoaXMubm9ybWFsaXplUHJvdG9jb2woITEpLm5vcm1hbGl6ZVBhdGgoITEpLm5vcm1hbGl6ZVF1ZXJ5KCExKS5ub3JtYWxpemVGcmFnbWVudCghMSkuYnVpbGQoKTp0aGlzLm5vcm1hbGl6ZVByb3RvY29sKCExKS5ub3JtYWxpemVIb3N0bmFtZSghMSkubm9ybWFsaXplUG9ydCghMSkubm9ybWFsaXplUGF0aCghMSkubm9ybWFsaXplUXVlcnkoITEpLm5vcm1hbGl6ZUZyYWdtZW50KCExKS5idWlsZCgpfSxmLm5vcm1hbGl6ZVByb3RvY29sPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdGhpcy5fcGFydHMucHJvdG9jb2w9PSJzdHJpbmciJiYodGhpcy5fcGFydHMucHJvdG9jb2w9dGhpcy5fcGFydHMucHJvdG9jb2wudG9Mb3dlckNhc2UoKSx0aGlzLmJ1aWxkKCF0KSksdGhpc30sZi5ub3JtYWxpemVIb3N0bmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGFydHMuaG9zdG5hbWUmJih0aGlzLmlzKCJJRE4iKSYmcj90aGlzLl9wYXJ0cy5ob3N0bmFtZT1yLnRvQVNDSUkodGhpcy5fcGFydHMuaG9zdG5hbWUpOnRoaXMuaXMoIklQdjYiKSYmbiYmKHRoaXMuX3BhcnRzLmhvc3RuYW1lPW4uYmVzdCh0aGlzLl9wYXJ0cy5ob3N0bmFtZSkpLHRoaXMuX3BhcnRzLmhvc3RuYW1lPXRoaXMuX3BhcnRzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCksdGhpcy5idWlsZCghdCkpLHRoaXN9LGYubm9ybWFsaXplUG9ydD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHRoaXMuX3BhcnRzLnByb3RvY29sPT0ic3RyaW5nIiYmdGhpcy5fcGFydHMucG9ydD09PW8uZGVmYXVsdFBvcnRzW3RoaXMuX3BhcnRzLnByb3RvY29sXSYmKHRoaXMuX3BhcnRzLnBvcnQ9bnVsbCx0aGlzLmJ1aWxkKCF0KSksdGhpc30sZi5ub3JtYWxpemVQYXRoPWZ1bmN0aW9uKHQpe3ZhciBzPXRoaXMuX3BhcnRzLnBhdGg7aWYoIXMpcmV0dXJuIHRoaXM7aWYodGhpcy5fcGFydHMudXJuKXJldHVybiB0aGlzLl9wYXJ0cy5wYXRoPW8ucmVjb2RlVXJuUGF0aCh0aGlzLl9wYXJ0cy5wYXRoKSx0aGlzLmJ1aWxkKCF0KSx0aGlzO2lmKHRoaXMuX3BhcnRzLnBhdGg9PT0iLyIpcmV0dXJuIHRoaXM7cz1vLnJlY29kZVBhdGgocyk7dmFyIGEsYz0iIixsLGg7Zm9yKHMuY2hhckF0KDApIT09Ii8iJiYoYT0hMCxzPSIvIitzKSwocy5zbGljZSgtMyk9PT0iLy4uInx8cy5zbGljZSgtMik9PT0iLy4iKSYmKHMrPSIvIikscz1zLnJlcGxhY2UoLyhcLyhcLlwvKSspfChcL1wuJCkvZywiLyIpLnJlcGxhY2UoL1wvezIsfS9nLCIvIiksYSYmKGM9cy5zdWJzdHJpbmcoMSkubWF0Y2goL14oXC5cLlwvKSsvKXx8IiIsYyYmKGM9Y1swXSkpO2w9cy5zZWFyY2goL1wvXC5cLihcL3wkKS8pLGwhPT0tMTspe2lmKGw9PT0wKXtzPXMuc3Vic3RyaW5nKDMpO2NvbnRpbnVlfWg9cy5zdWJzdHJpbmcoMCxsKS5sYXN0SW5kZXhPZigiLyIpLGg9PT0tMSYmKGg9bCkscz1zLnN1YnN0cmluZygwLGgpK3Muc3Vic3RyaW5nKGwrMyl9cmV0dXJuIGEmJnRoaXMuaXMoInJlbGF0aXZlIikmJihzPWMrcy5zdWJzdHJpbmcoMSkpLHRoaXMuX3BhcnRzLnBhdGg9cyx0aGlzLmJ1aWxkKCF0KSx0aGlzfSxmLm5vcm1hbGl6ZVBhdGhuYW1lPWYubm9ybWFsaXplUGF0aCxmLm5vcm1hbGl6ZVF1ZXJ5PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdGhpcy5fcGFydHMucXVlcnk9PSJzdHJpbmciJiYodGhpcy5fcGFydHMucXVlcnkubGVuZ3RoP3RoaXMucXVlcnkoby5wYXJzZVF1ZXJ5KHRoaXMuX3BhcnRzLnF1ZXJ5LHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2UpKTp0aGlzLl9wYXJ0cy5xdWVyeT1udWxsLHRoaXMuYnVpbGQoIXQpKSx0aGlzfSxmLm5vcm1hbGl6ZUZyYWdtZW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXJ0cy5mcmFnbWVudHx8KHRoaXMuX3BhcnRzLmZyYWdtZW50PW51bGwsdGhpcy5idWlsZCghdCkpLHRoaXN9LGYubm9ybWFsaXplU2VhcmNoPWYubm9ybWFsaXplUXVlcnksZi5ub3JtYWxpemVIYXNoPWYubm9ybWFsaXplRnJhZ21lbnQsZi5pc284ODU5PWZ1bmN0aW9uKCl7dmFyIHQ9by5lbmNvZGUscz1vLmRlY29kZTtvLmVuY29kZT1lc2NhcGUsby5kZWNvZGU9ZGVjb2RlVVJJQ29tcG9uZW50O3RyeXt0aGlzLm5vcm1hbGl6ZSgpfWZpbmFsbHl7by5lbmNvZGU9dCxvLmRlY29kZT1zfXJldHVybiB0aGlzfSxmLnVuaWNvZGU9ZnVuY3Rpb24oKXt2YXIgdD1vLmVuY29kZSxzPW8uZGVjb2RlO28uZW5jb2RlPUcsby5kZWNvZGU9dW5lc2NhcGU7dHJ5e3RoaXMubm9ybWFsaXplKCl9ZmluYWxseXtvLmVuY29kZT10LG8uZGVjb2RlPXN9cmV0dXJuIHRoaXN9LGYucmVhZGFibGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNsb25lKCk7dC51c2VybmFtZSgiIikucGFzc3dvcmQoIiIpLm5vcm1hbGl6ZSgpO3ZhciBzPSIiO2lmKHQuX3BhcnRzLnByb3RvY29sJiYocys9dC5fcGFydHMucHJvdG9jb2wrIjovLyIpLHQuX3BhcnRzLmhvc3RuYW1lJiYodC5pcygicHVueWNvZGUiKSYmcj8ocys9ci50b1VuaWNvZGUodC5fcGFydHMuaG9zdG5hbWUpLHQuX3BhcnRzLnBvcnQmJihzKz0iOiIrdC5fcGFydHMucG9ydCkpOnMrPXQuaG9zdCgpKSx0Ll9wYXJ0cy5ob3N0bmFtZSYmdC5fcGFydHMucGF0aCYmdC5fcGFydHMucGF0aC5jaGFyQXQoMCkhPT0iLyImJihzKz0iLyIpLHMrPXQucGF0aCghMCksdC5fcGFydHMucXVlcnkpe2Zvcih2YXIgYT0iIixjPTAsbD10Ll9wYXJ0cy5xdWVyeS5zcGxpdCgiJiIpLGg9bC5sZW5ndGg7YzxoO2MrKyl7dmFyIGc9KGxbY118fCIiKS5zcGxpdCgiPSIpO2ErPSImIitvLmRlY29kZVF1ZXJ5KGdbMF0sdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSkucmVwbGFjZSgvJi9nLCIlMjYiKSxnWzFdIT09dm9pZCAwJiYoYSs9Ij0iK28uZGVjb2RlUXVlcnkoZ1sxXSx0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKS5yZXBsYWNlKC8mL2csIiUyNiIpKX1zKz0iPyIrYS5zdWJzdHJpbmcoMSl9cmV0dXJuIHMrPW8uZGVjb2RlUXVlcnkodC5oYXNoKCksITApLHN9LGYuYWJzb2x1dGVUbz1mdW5jdGlvbih0KXt2YXIgcz10aGlzLmNsb25lKCksYT1bInByb3RvY29sIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImhvc3RuYW1lIiwicG9ydCJdLGMsbCxoO2lmKHRoaXMuX3BhcnRzLnVybil0aHJvdyBuZXcgRXJyb3IoIlVSTnMgZG8gbm90IGhhdmUgYW55IGdlbmVyYWxseSBkZWZpbmVkIGhpZXJhcmNoaWNhbCBjb21wb25lbnRzIik7aWYodCBpbnN0YW5jZW9mIG98fCh0PW5ldyBvKHQpKSxzLl9wYXJ0cy5wcm90b2NvbHx8KHMuX3BhcnRzLnByb3RvY29sPXQuX3BhcnRzLnByb3RvY29sLHRoaXMuX3BhcnRzLmhvc3RuYW1lKSlyZXR1cm4gcztmb3IobD0wO2g9YVtsXTtsKyspcy5fcGFydHNbaF09dC5fcGFydHNbaF07cmV0dXJuIHMuX3BhcnRzLnBhdGg/KHMuX3BhcnRzLnBhdGguc3Vic3RyaW5nKC0yKT09PSIuLiImJihzLl9wYXJ0cy5wYXRoKz0iLyIpLHMucGF0aCgpLmNoYXJBdCgwKSE9PSIvIiYmKGM9dC5kaXJlY3RvcnkoKSxjPWN8fCh0LnBhdGgoKS5pbmRleE9mKCIvIik9PT0wPyIvIjoiIikscy5fcGFydHMucGF0aD0oYz9jKyIvIjoiIikrcy5fcGFydHMucGF0aCxzLm5vcm1hbGl6ZVBhdGgoKSkpOihzLl9wYXJ0cy5wYXRoPXQuX3BhcnRzLnBhdGgscy5fcGFydHMucXVlcnl8fChzLl9wYXJ0cy5xdWVyeT10Ll9wYXJ0cy5xdWVyeSkpLHMuYnVpbGQoKSxzfSxmLnJlbGF0aXZlVG89ZnVuY3Rpb24odCl7dmFyIHM9dGhpcy5jbG9uZSgpLm5vcm1hbGl6ZSgpLGEsYyxsLGgsZztpZihzLl9wYXJ0cy51cm4pdGhyb3cgbmV3IEVycm9yKCJVUk5zIGRvIG5vdCBoYXZlIGFueSBnZW5lcmFsbHkgZGVmaW5lZCBoaWVyYXJjaGljYWwgY29tcG9uZW50cyIpO2lmKHQ9bmV3IG8odCkubm9ybWFsaXplKCksYT1zLl9wYXJ0cyxjPXQuX3BhcnRzLGg9cy5wYXRoKCksZz10LnBhdGgoKSxoLmNoYXJBdCgwKSE9PSIvIil0aHJvdyBuZXcgRXJyb3IoIlVSSSBpcyBhbHJlYWR5IHJlbGF0aXZlIik7aWYoZy5jaGFyQXQoMCkhPT0iLyIpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgY2FsY3VsYXRlIGEgVVJJIHJlbGF0aXZlIHRvIGFub3RoZXIgcmVsYXRpdmUgVVJJIik7aWYoYS5wcm90b2NvbD09PWMucHJvdG9jb2wmJihhLnByb3RvY29sPW51bGwpLGEudXNlcm5hbWUhPT1jLnVzZXJuYW1lfHxhLnBhc3N3b3JkIT09Yy5wYXNzd29yZHx8YS5wcm90b2NvbCE9PW51bGx8fGEudXNlcm5hbWUhPT1udWxsfHxhLnBhc3N3b3JkIT09bnVsbClyZXR1cm4gcy5idWlsZCgpO2lmKGEuaG9zdG5hbWU9PT1jLmhvc3RuYW1lJiZhLnBvcnQ9PT1jLnBvcnQpYS5ob3N0bmFtZT1udWxsLGEucG9ydD1udWxsO2Vsc2UgcmV0dXJuIHMuYnVpbGQoKTtpZihoPT09ZylyZXR1cm4gYS5wYXRoPSIiLHMuYnVpbGQoKTtpZihsPW8uY29tbW9uUGF0aChoLGcpLCFsKXJldHVybiBzLmJ1aWxkKCk7dmFyIGI9Yy5wYXRoLnN1YnN0cmluZyhsLmxlbmd0aCkucmVwbGFjZSgvW15cL10qJC8sIiIpLnJlcGxhY2UoLy4qP1wvL2csIi4uLyIpO3JldHVybiBhLnBhdGg9YithLnBhdGguc3Vic3RyaW5nKGwubGVuZ3RoKXx8Ii4vIixzLmJ1aWxkKCl9LGYuZXF1YWxzPWZ1bmN0aW9uKHQpe3ZhciBzPXRoaXMuY2xvbmUoKSxhPW5ldyBvKHQpLGM9e30sbD17fSxoPXt9LGcsYixSO2lmKHMubm9ybWFsaXplKCksYS5ub3JtYWxpemUoKSxzLnRvU3RyaW5nKCk9PT1hLnRvU3RyaW5nKCkpcmV0dXJuITA7aWYoZz1zLnF1ZXJ5KCksYj1hLnF1ZXJ5KCkscy5xdWVyeSgiIiksYS5xdWVyeSgiIikscy50b1N0cmluZygpIT09YS50b1N0cmluZygpfHxnLmxlbmd0aCE9PWIubGVuZ3RoKXJldHVybiExO2M9by5wYXJzZVF1ZXJ5KGcsdGhpcy5fcGFydHMuZXNjYXBlUXVlcnlTcGFjZSksbD1vLnBhcnNlUXVlcnkoYix0aGlzLl9wYXJ0cy5lc2NhcGVRdWVyeVNwYWNlKTtmb3IoUiBpbiBjKWlmKF8uY2FsbChjLFIpKXtpZih2KGNbUl0pKXtpZighayhjW1JdLGxbUl0pKXJldHVybiExfWVsc2UgaWYoY1tSXSE9PWxbUl0pcmV0dXJuITE7aFtSXT0hMH1mb3IoUiBpbiBsKWlmKF8uY2FsbChsLFIpJiYhaFtSXSlyZXR1cm4hMTtyZXR1cm4hMH0sZi5wcmV2ZW50SW52YWxpZEhvc3RuYW1lPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9wYXJ0cy5wcmV2ZW50SW52YWxpZEhvc3RuYW1lPSEhdCx0aGlzfSxmLmR1cGxpY2F0ZVF1ZXJ5UGFyYW1ldGVycz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGFydHMuZHVwbGljYXRlUXVlcnlQYXJhbWV0ZXJzPSEhdCx0aGlzfSxmLmVzY2FwZVF1ZXJ5U3BhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BhcnRzLmVzY2FwZVF1ZXJ5U3BhY2U9ISF0LHRoaXN9LG99KX0pKHVyKTt2YXIgbG89dXIuZXhwb3J0cztjb25zdCBwcj0oZSxyLG4pPT57Y29uc3QgaT1FdChlLHU9PmtlLk5vZGUuaXNDYWxsRXhwcmVzc2lvbih1KT91LmdldFRleHQoKS5tYXRjaCgvXGJpbXBvcnRcYi5tZXRhLmdsb2JFYWdlci9nKSE9bnVsbDohMSk7cmV0dXJuIGkubGVuZ3RoIT0wJiZpLmZvckVhY2godT0+e2NvbnN0IHA9cG8odS5jb21waWxlck5vZGUpLG89aG8ocCxyLG4pO28uZm9yRWFjaChtPT57ZS5hZGRJbXBvcnREZWNsYXJhdGlvbih7ZGVmYXVsdEltcG9ydDpmcihtKSxtb2R1bGVTcGVjaWZpZXI6QXQobSl9KX0pO2NvbnN0IGQ9dS5nZXRQYXJlbnQoKS5nZXROYW1lKCksZj1lLmdldFZhcmlhYmxlRGVjbGFyYXRpb24oZCksXz17fTtvLmZvckVhY2gobT0+e19bSlNPTi5zdHJpbmdpZnkobSldPWZyKG0pfSksZi5zZXRJbml0aWFsaXplcihrZS5Xcml0ZXJzLm9iamVjdChfKSl9KSxlfSxwbz1lPT5lLmFyZ3VtZW50c1swXS50ZXh0LGhvPShlLHIsbik9Pntjb25zdCBpPU9iamVjdC5rZXlzKG4pO3JldHVybiBjbyhpLGAqKiR7aHIoZSl9YCkubWFwKHU9Pntjb25zdCBwPWxvKHUpLnJlbGF0aXZlVG8ocikuX3N0cmluZztyZXR1cm4gcC5zdGFydHNXaXRoKCIuLiIpP3A6YC4vJHtwfWB9KX0saHI9ZT0+KGU9PW51bGw/dm9pZCAwOmUuc3RhcnRzV2l0aCgiLiIpKXx8KGU9PW51bGw/dm9pZCAwOmUuc3RhcnRzV2l0aCgiLyIpKSYmKGU9PW51bGw/dm9pZCAwOmUuY2hhckF0KDEpKT09PSIuIj9ocihlPT1udWxsP3ZvaWQgMDplLnN1YnN0cmluZygxKSk6ZSxmcj1lPT5lPT1udWxsP3ZvaWQgMDplLnNwbGl0KCIvIikucmV2ZXJzZSgpWzBdLnNwbGl0KCIuIilbMF07bGV0IGhlLGtlLCRlO2NvbnN0IGRyPWFzeW5jKCk9Pnt0cnl7aGU9YXdhaXQgaW1wb3J0KCJodHRwczovL2VzbS5zaC9AYmFiZWwvc3RhbmRhbG9uZSIpLGhlPT1udWxsfHxoZS5yZWdpc3RlclByZXNldCgiaXRlcmlhUHJlc2V0Iix7cHJlc2V0czpbW2hlLmF2YWlsYWJsZVByZXNldHMudHlwZXNjcmlwdF0sW2hlLmF2YWlsYWJsZVByZXNldHMucmVhY3RdLFtoZS5hdmFpbGFibGVQcmVzZXRzLmVudix7dGFyZ2V0czp7ZXNtb2R1bGVzOiEwfSxtb2R1bGVzOiExfV1dLHBsdWdpbnM6W1toZS5hdmFpbGFibGVQbHVnaW5zWyJ0cmFuc2Zvcm0tcmVhY3QtanN4LXNvdXJjZSJdXSxbRHIse3NraXBFbnZDaGVjazohMCxlbWl0RnVsbFNpZ25hdHVyZXM6ITB9XV19KX1jYXRjaChlKXtyZXR1cm4gZX19LGdyPWFzeW5jKCk9Pnt0cnl7a2U9YXdhaXQgaW1wb3J0KCJodHRwczovL2VzbS5zaC90cy1tb3JwaCIpLCRlPW5ldyBrZS5Qcm9qZWN0KHt1c2VJbk1lbW9yeUZpbGVTeXN0ZW06ITB9KX1jYXRjaChlKXtyZXR1cm4gZX19LG1yPShlLHIpPT5oZS50cmFuc2Zvcm0oZSx7ZmlsZW5hbWU6cixwcmVzZXRzOlsiaXRlcmlhUHJlc2V0Il19KSxmbz1hc3luYyhlLHIpPT57JGV8fGF3YWl0IGdyKCksaGV8fGF3YWl0IGRyKCk7Y29uc3Qgbj17fTtmb3IoY29uc3QgaSBpbiBlKXtpZihpLnN0YXJ0c1dpdGgoIi9ub2RlX21vZHVsZXMvIikpe25baV09ZVtpXTtjb250aW51ZX1pZihHZS5zb21lKHU9PmkuZW5kc1dpdGgodSkpKXRyeXtjb25zdCB1PW1yKGVbaV0saSk7aWYodSE9bnVsbCYmdS5jb2RlKXtjb25zdCBwPSRlLmNyZWF0ZVNvdXJjZUZpbGUoaSx1LmNvZGUse292ZXJ3cml0ZTohMH0pO3ByKHAsaSxlKSxSdChwLHIpLHh0KHAsaSk7Y29uc3Qgbz1wLnByaW50KCksZD12cihvLGkpO25baV09ZH19Y2F0Y2godSl7cmV0dXJuIGNvbnNvbGUuZXJyb3IodSkse2Vycm9yOnV9fWVsc2UgaS5lbmRzV2l0aCgiLmpzb24iKT9uW2ldPSJleHBvcnQgZGVmYXVsdCIrZVtpXTpuW2ldPWVbaV19cmV0dXJuIG59LGdvPWFzeW5jKGUscixuLGkpPT57aWYoJGV8fGF3YWl0IGdyKCksaGV8fGF3YWl0IGRyKCksR2Uuc29tZSh1PT5lLmVuZHNXaXRoKHUpKSl0cnl7Y29uc3QgdT1tcihyLGUpLHA9JGUuY3JlYXRlU291cmNlRmlsZShlLHUuY29kZSx7b3ZlcndyaXRlOiEwfSk7cHIocCxlLGkpLFJ0KHAsbikseHQocCxlKTtjb25zdCBvPXAucHJpbnQoKTtyZXR1cm4gdnIobyxlKX1jYXRjaCh1KXtyZXR1cm57ZXJyb3I6dX19ZWxzZSByZXR1cm4gZS5lbmRzV2l0aCgiLmpzb24iKT8iZXhwb3J0IGRlZmF1bHQiK3I6cn0sdnI9KGUscik9PmAKICAgIGZ1bmN0aW9uICRSZWZyZXNoUmVnJChjLCBpZCkgewogICAgICBjb25zdCBwYXRoID0gIiR7cn0iOwogICAgICB3aW5kb3cuJFJlZnJlc2hSZWdHbG9iYWwkKGMsICcuJyArICBwYXRoICsgJyAnICsgaWQpOwogICAgfQogICAgYCtlO2Z1bmN0aW9uIG1vKGUscil7Zm9yKHZhciBuPSIiLGk9MCx1PS0xLHA9MCxvLGQ9MDtkPD1lLmxlbmd0aDsrK2Qpe2lmKGQ8ZS5sZW5ndGgpbz1lLmNoYXJDb2RlQXQoZCk7ZWxzZXtpZihvPT09NDcpYnJlYWs7bz00N31pZihvPT09NDcpe2lmKCEodT09PWQtMXx8cD09PTEpKWlmKHUhPT1kLTEmJnA9PT0yKXtpZihuLmxlbmd0aDwyfHxpIT09Mnx8bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTEpIT09NDZ8fG4uY2hhckNvZGVBdChuLmxlbmd0aC0yKSE9PTQ2KXtpZihuLmxlbmd0aD4yKXt2YXIgZj1uLmxhc3RJbmRleE9mKCIvIik7aWYoZiE9PW4ubGVuZ3RoLTEpe2Y9PT0tMT8obj0iIixpPTApOihuPW4uc2xpY2UoMCxmKSxpPW4ubGVuZ3RoLTEtbi5sYXN0SW5kZXhPZigiLyIpKSx1PWQscD0wO2NvbnRpbnVlfX1lbHNlIGlmKG4ubGVuZ3RoPT09Mnx8bi5sZW5ndGg9PT0xKXtuPSIiLGk9MCx1PWQscD0wO2NvbnRpbnVlfX1yJiYobi5sZW5ndGg+MD9uKz0iLy4uIjpuPSIuLiIsaT0yKX1lbHNlIG4ubGVuZ3RoPjA/bis9Ii8iK2Uuc2xpY2UodSsxLGQpOm49ZS5zbGljZSh1KzEsZCksaT1kLXUtMTt1PWQscD0wfWVsc2Ugbz09PTQ2JiZwIT09LTE/KytwOnA9LTF9cmV0dXJuIG59ZnVuY3Rpb24geXIoZSl7aWYodHlwZW9mIGUhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgIitKU09OLnN0cmluZ2lmeShlKSl9ZnVuY3Rpb24gdm8oZSl7aWYoeXIoZSksZS5sZW5ndGg9PT0wKXJldHVybiIuIjtmb3IodmFyIHI9ZS5jaGFyQ29kZUF0KDApLG49cj09PTQ3LGk9LTEsdT0hMCxwPWUubGVuZ3RoLTE7cD49MTstLXApaWYocj1lLmNoYXJDb2RlQXQocCkscj09PTQ3KXtpZighdSl7aT1wO2JyZWFrfX1lbHNlIHU9ITE7cmV0dXJuIGk9PT0tMT9uPyIvIjoiLiI6biYmaT09PTE/Ii8vIjplLnNsaWNlKDAsaSl9ZnVuY3Rpb24gYnIoLi4uZSl7Zm9yKHZhciByPSIiLG49ITEsaT1hcmd1bWVudHMubGVuZ3RoLTE7aT49LTEmJiFuO2ktLSl7dmFyIHU7aT49MCYmKHU9YXJndW1lbnRzW2ldKSx5cih1KSx1Lmxlbmd0aCE9PTAmJihyPXUrIi8iK3Isbj11LmNoYXJDb2RlQXQoMCk9PT00Nyl9cmV0dXJuIHI9bW8ociwhbiksbj9yLmxlbmd0aD4wPyIvIityOiIvIjpyLmxlbmd0aD4wP3I6Ii4ifWNvbnN0IHllPSJcMHZpcnR1YWw6Iix5bz1lPT57Y29uc3Qgcj1uZXcgTWFwO3JldHVybiBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKG49PntyLnNldChicihuKSxlW25dKX0pLHtuYW1lOiJ2aXJ0dWFsIixyZXNvbHZlSWQobixpKXtpZihuIGluIGUpcmV0dXJuIHllK247aWYoaSl7Y29uc3QgdT1pLnN0YXJ0c1dpdGgoeWUpP2kuc2xpY2UoeWUubGVuZ3RoKTppLHA9YnIodm8odSksbik7aWYoci5oYXMocCkpcmV0dXJuIHllK3A7aWYoci5oYXMocCsiL2luZGV4IikpcmV0dXJuIHllK3ArIi9pbmRleCJ9cmV0dXJuIG51bGx9LGxvYWQobil7aWYobi5zdGFydHNXaXRoKHllKSl7Y29uc3QgaT1uLnNsaWNlKHllLmxlbmd0aCk7cmV0dXJuIGkgaW4gZT9lW2ldOnIuZ2V0KGkpfXJldHVybiBudWxsfX19LGJvPXtmb3JtYXQ6ImlpZmUiLG5hbWU6Im15QnVuZGxlIixnbG9iYWxzOnt9fTtsZXQgaHQ7Y29uc3QgX289YXN5bmMoKT0+e3ZhciBlO3RyeXtodD0oZT1hd2FpdCBpbXBvcnQoImh0dHBzOi8vdW5wa2cuY29tL3JvbGx1cC9kaXN0L2VzL3JvbGx1cC5icm93c2VyLmpzIikpPT1udWxsP3ZvaWQgMDplLnJvbGx1cH1jYXRjaChyKXtyZXR1cm4gcn19O0ZlKHt0cmFuc3BpbGVGaWxlczpmbyx0cmFuc3BpbGVTaW5nbGVGaWxlOmdvLGJ1bmRsZUZpbGVzOmFzeW5jKGUscj0iL3NyYy9pbmRleCIpPT57aHR8fGF3YWl0IF9vKCksT2JqZWN0LmtleXMoZSkuZmlsdGVyKG49PkdlLnNvbWUoaT0+bi5lbmRzV2l0aChpKSkpLmZvckVhY2gobj0+e2VbQXQobildPWVbbl0sZGVsZXRlIGVbbl19KTt0cnl7cmV0dXJuKGF3YWl0KGF3YWl0IGh0KHtpbnB1dDpyLHBsdWdpbnM6W3lvKGUpXX0pKS5nZW5lcmF0ZShibykpLm91dHB1dFswXS5jb2RlfWNhdGNoKG4pe3JldHVybiBjb25zb2xlLmVycm9yKG4pLHtlcnJvcjpufX19fSl9KX0pKCk7Cg==";
const blob$2 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$2)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper$2() {
  const objURL = blob$2 && (window.URL || window.webkitURL).createObjectURL(blob$2);
  try {
    return objURL ? new Worker(objURL, {}) : new Worker("data:application/javascript;base64," + encodedJs$2, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const encodedJs$1 = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiOyhmdW5jdGlvbihkKXt0eXBlb2YgZGVmaW5lPT0iZnVuY3Rpb24iJiZkZWZpbmUuYW1kP2RlZmluZShkKTpkKCl9KShmdW5jdGlvbigpe2NvbnN0IGQ9U3ltYm9sKCJDb21saW5rLnByb3h5IiksUD1TeW1ib2woIkNvbWxpbmsuZW5kcG9pbnQiKSxDPVN5bWJvbCgiQ29tbGluay5yZWxlYXNlUHJveHkiKSx5PVN5bWJvbCgiQ29tbGluay50aHJvd24iKSx3PXQ9PnR5cGVvZiB0PT0ib2JqZWN0IiYmdCE9PW51bGx8fHR5cGVvZiB0PT0iZnVuY3Rpb24iLFQ9e2NhbkhhbmRsZTp0PT53KHQpJiZ0W2RdLHNlcmlhbGl6ZSh0KXtjb25zdHtwb3J0MTplLHBvcnQyOm59PW5ldyBNZXNzYWdlQ2hhbm5lbDtyZXR1cm4gRSh0LGUpLFtuLFtuXV19LGRlc2VyaWFsaXplKHQpe3JldHVybiB0LnN0YXJ0KCksTyh0KX19LE09e2NhbkhhbmRsZTp0PT53KHQpJiZ5IGluIHQsc2VyaWFsaXplKHt2YWx1ZTp0fSl7bGV0IGU7cmV0dXJuIHQgaW5zdGFuY2VvZiBFcnJvcj9lPXtpc0Vycm9yOiEwLHZhbHVlOnttZXNzYWdlOnQubWVzc2FnZSxuYW1lOnQubmFtZSxzdGFjazp0LnN0YWNrfX06ZT17aXNFcnJvcjohMSx2YWx1ZTp0fSxbZSxbXV19LGRlc2VyaWFsaXplKHQpe3Rocm93IHQuaXNFcnJvcj9PYmplY3QuYXNzaWduKG5ldyBFcnJvcih0LnZhbHVlLm1lc3NhZ2UpLHQudmFsdWUpOnQudmFsdWV9fSxTPW5ldyBNYXAoW1sicHJveHkiLFRdLFsidGhyb3ciLE1dXSk7ZnVuY3Rpb24gRSh0LGU9c2VsZil7ZS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmdW5jdGlvbiBuKHIpe2lmKCFyfHwhci5kYXRhKXJldHVybjtjb25zdHtpZDp1LHR5cGU6cCxwYXRoOmF9PU9iamVjdC5hc3NpZ24oe3BhdGg6W119LHIuZGF0YSksaT0oci5kYXRhLmFyZ3VtZW50TGlzdHx8W10pLm1hcChmKTtsZXQgczt0cnl7Y29uc3Qgbz1hLnNsaWNlKDAsLTEpLnJlZHVjZSgoYyxnKT0+Y1tnXSx0KSxsPWEucmVkdWNlKChjLGcpPT5jW2ddLHQpO3N3aXRjaChwKXtjYXNlIkdFVCI6cz1sO2JyZWFrO2Nhc2UiU0VUIjpvW2Euc2xpY2UoLTEpWzBdXT1mKHIuZGF0YS52YWx1ZSkscz0hMDticmVhaztjYXNlIkFQUExZIjpzPWwuYXBwbHkobyxpKTticmVhaztjYXNlIkNPTlNUUlVDVCI6e2NvbnN0IGM9bmV3IGwoLi4uaSk7cz14KGMpfWJyZWFrO2Nhc2UiRU5EUE9JTlQiOntjb25zdHtwb3J0MTpjLHBvcnQyOmd9PW5ldyBNZXNzYWdlQ2hhbm5lbDtFKHQsZykscz1qKGMsW2NdKX1icmVhaztjYXNlIlJFTEVBU0UiOnM9dm9pZCAwO2JyZWFrO2RlZmF1bHQ6cmV0dXJufX1jYXRjaChvKXtzPXt2YWx1ZTpvLFt5XTowfX1Qcm9taXNlLnJlc29sdmUocykuY2F0Y2gobz0+KHt2YWx1ZTpvLFt5XTowfSkpLnRoZW4obz0+e2NvbnN0W2wsY109dihvKTtlLnBvc3RNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsKSx7aWQ6dX0pLGMpLHA9PT0iUkVMRUFTRSImJihlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLG4pLEwoZSkpfSl9KSxlLnN0YXJ0JiZlLnN0YXJ0KCl9ZnVuY3Rpb24gTih0KXtyZXR1cm4gdC5jb25zdHJ1Y3Rvci5uYW1lPT09Ik1lc3NhZ2VQb3J0In1mdW5jdGlvbiBMKHQpe04odCkmJnQuY2xvc2UoKX1mdW5jdGlvbiBPKHQsZSl7cmV0dXJuIGIodCxbXSxlKX1mdW5jdGlvbiBoKHQpe2lmKHQpdGhyb3cgbmV3IEVycm9yKCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGUiKX1mdW5jdGlvbiBiKHQsZT1bXSxuPWZ1bmN0aW9uKCl7fSl7bGV0IHI9ITE7Y29uc3QgdT1uZXcgUHJveHkobix7Z2V0KHAsYSl7aWYoaChyKSxhPT09QylyZXR1cm4oKT0+bSh0LHt0eXBlOiJSRUxFQVNFIixwYXRoOmUubWFwKGk9PmkudG9TdHJpbmcoKSl9KS50aGVuKCgpPT57TCh0KSxyPSEwfSk7aWYoYT09PSJ0aGVuIil7aWYoZS5sZW5ndGg9PT0wKXJldHVybnt0aGVuOigpPT51fTtjb25zdCBpPW0odCx7dHlwZToiR0VUIixwYXRoOmUubWFwKHM9PnMudG9TdHJpbmcoKSl9KS50aGVuKGYpO3JldHVybiBpLnRoZW4uYmluZChpKX1yZXR1cm4gYih0LFsuLi5lLGFdKX0sc2V0KHAsYSxpKXtoKHIpO2NvbnN0W3Msb109dihpKTtyZXR1cm4gbSh0LHt0eXBlOiJTRVQiLHBhdGg6Wy4uLmUsYV0ubWFwKGw9PmwudG9TdHJpbmcoKSksdmFsdWU6c30sbykudGhlbihmKX0sYXBwbHkocCxhLGkpe2gocik7Y29uc3Qgcz1lW2UubGVuZ3RoLTFdO2lmKHM9PT1QKXJldHVybiBtKHQse3R5cGU6IkVORFBPSU5UIn0pLnRoZW4oZik7aWYocz09PSJiaW5kIilyZXR1cm4gYih0LGUuc2xpY2UoMCwtMSkpO2NvbnN0W28sbF09ayhpKTtyZXR1cm4gbSh0LHt0eXBlOiJBUFBMWSIscGF0aDplLm1hcChjPT5jLnRvU3RyaW5nKCkpLGFyZ3VtZW50TGlzdDpvfSxsKS50aGVuKGYpfSxjb25zdHJ1Y3QocCxhKXtoKHIpO2NvbnN0W2ksc109ayhhKTtyZXR1cm4gbSh0LHt0eXBlOiJDT05TVFJVQ1QiLHBhdGg6ZS5tYXAobz0+by50b1N0cmluZygpKSxhcmd1bWVudExpc3Q6aX0scykudGhlbihmKX19KTtyZXR1cm4gdX1mdW5jdGlvbiBSKHQpe3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLHQpfWZ1bmN0aW9uIGsodCl7Y29uc3QgZT10Lm1hcCh2KTtyZXR1cm5bZS5tYXAobj0+blswXSksUihlLm1hcChuPT5uWzFdKSldfWNvbnN0IEE9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gaih0LGUpe3JldHVybiBBLnNldCh0LGUpLHR9ZnVuY3Rpb24geCh0KXtyZXR1cm4gT2JqZWN0LmFzc2lnbih0LHtbZF06ITB9KX1mdW5jdGlvbiB2KHQpe2Zvcihjb25zdFtlLG5db2YgUylpZihuLmNhbkhhbmRsZSh0KSl7Y29uc3Rbcix1XT1uLnNlcmlhbGl6ZSh0KTtyZXR1cm5be3R5cGU6IkhBTkRMRVIiLG5hbWU6ZSx2YWx1ZTpyfSx1XX1yZXR1cm5be3R5cGU6IlJBVyIsdmFsdWU6dH0sQS5nZXQodCl8fFtdXX1mdW5jdGlvbiBmKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2UiSEFORExFUiI6cmV0dXJuIFMuZ2V0KHQubmFtZSkuZGVzZXJpYWxpemUodC52YWx1ZSk7Y2FzZSJSQVciOnJldHVybiB0LnZhbHVlfX1mdW5jdGlvbiBtKHQsZSxuKXtyZXR1cm4gbmV3IFByb21pc2Uocj0+e2NvbnN0IHU9eigpO3QuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsZnVuY3Rpb24gcChhKXshYS5kYXRhfHwhYS5kYXRhLmlkfHxhLmRhdGEuaWQhPT11fHwodC5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIixwKSxyKGEuZGF0YSkpfSksdC5zdGFydCYmdC5zdGFydCgpLHQucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7aWQ6dX0sZSksbil9KX1mdW5jdGlvbiB6KCl7cmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKT0+TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpLmpvaW4oIi0iKX1FKHtmb3JtYXRDb2RlOmFzeW5jKHQsZT0idHlwZXNjcmlwdCIpPT57Y29uc3Qgbj0oYXdhaXQgaW1wb3J0KCJodHRwczovL3VucGtnLmNvbS9wcmV0dGllci9lc20vc3RhbmRhbG9uZS5tanMiKSkuZGVmYXVsdCxyPShhd2FpdCBpbXBvcnQoImh0dHBzOi8vdW5wa2cuY29tL3ByZXR0aWVyL2VzbS9wYXJzZXItdHlwZXNjcmlwdC5tanMiKSkuZGVmYXVsdCx1PShhd2FpdCBpbXBvcnQoImh0dHBzOi8vdW5wa2cuY29tL3ByZXR0aWVyL2VzbS9wYXJzZXItZ3JhcGhxbC5tanMiKSkuZGVmYXVsdDtyZXR1cm4gbi5mb3JtYXQodCx7cGFyc2VyOmUscGx1Z2luczpbcix1XSxzZW1pOiExLHRhYldpZHRoOjIsc2luZ2xlUXVvdGU6ITB9KX19KX0pfSkoKTsK";
const blob$1 = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs$1)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper$1() {
  const objURL = blob$1 && (window.URL || window.webkitURL).createObjectURL(blob$1);
  try {
    return objURL ? new Worker(objURL, {}) : new Worker("data:application/javascript;base64," + encodedJs$1, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const bundlerWorker = new WorkerWrapper$2();
const prettierWorker = new WorkerWrapper$1();
const iteriaBundlerWorker = wrap$3(bundlerWorker);
const iteriaPrettierWorker = wrap$3(prettierWorker);
const encodeEmptyLines$1 = (code2) => code2.replace(/\n\n/g, "\n/** THIS_IS_A_NEWLINE **/\n");
const decodeEmptyLines$1 = (code2) => code2.replace(/\/\*\* THIS_IS_A_NEWLINE \*\*\//g, "");
const printFormattedSourceFile$1 = async (sourceFile) => {
  const printer = ts.createPrinter();
  const code2 = printer.printFile(sourceFile);
  const decoded = decodeEmptyLines$1(code2);
  const formattedCode = await iteriaPrettierWorker.formatCode(decoded);
  return formattedCode;
};
const encodedJs = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBLdD1PYmplY3QuZGVmaW5lUHJvcGVydHksUGU9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxKdD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFl0PU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsamU9KEUsYix1KT0+YiBpbiBFP0t0KEUsYix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dX0pOkVbYl09dSxHdD0oRSxiKT0+e2Zvcih2YXIgdSBpbiBifHwoYj17fSkpSnQuY2FsbChiLHUpJiZqZShFLHUsYlt1XSk7aWYoUGUpZm9yKHZhciB1IG9mIFBlKGIpKVl0LmNhbGwoYix1KSYmamUoRSx1LGJbdV0pO3JldHVybiBFfTsoZnVuY3Rpb24oRSxiKXt0eXBlb2YgZXhwb3J0cz09Im9iamVjdCImJnR5cGVvZiBtb2R1bGUhPSJ1bmRlZmluZWQiP2IocmVxdWlyZSgiaHR0cHM6Ly9lc20uc2gvdHlwZXNjcmlwdCIpKTp0eXBlb2YgZGVmaW5lPT0iZnVuY3Rpb24iJiZkZWZpbmUuYW1kP2RlZmluZShbImh0dHBzOi8vZXNtLnNoL3R5cGVzY3JpcHQiXSxiKTooRT10eXBlb2YgZ2xvYmFsVGhpcyE9InVuZGVmaW5lZCI/Z2xvYmFsVGhpczpFfHxzZWxmLGIoRS50cykpfSkodm9pZCAwLGZ1bmN0aW9uKEUpe2Z1bmN0aW9uIGIoZSl7cmV0dXJuIGUmJnR5cGVvZiBlPT0ib2JqZWN0IiYmImRlZmF1bHQiaW4gZT9lOntkZWZhdWx0OmV9fXZhciB1PWIoRSk7Y29uc3QgQmU9U3ltYm9sKCJDb21saW5rLnByb3h5IiksenQ9U3ltYm9sKCJDb21saW5rLmVuZHBvaW50IikscXQ9U3ltYm9sKCJDb21saW5rLnJlbGVhc2VQcm94eSIpLEVlPVN5bWJvbCgiQ29tbGluay50aHJvd24iKSxNZT1lPT50eXBlb2YgZT09Im9iamVjdCImJmUhPT1udWxsfHx0eXBlb2YgZT09ImZ1bmN0aW9uIixYdD17Y2FuSGFuZGxlOmU9Pk1lKGUpJiZlW0JlXSxzZXJpYWxpemUoZSl7Y29uc3R7cG9ydDE6dCxwb3J0MjpufT1uZXcgTWVzc2FnZUNoYW5uZWw7cmV0dXJuIFRlKGUsdCksW24sW25dXX0sZGVzZXJpYWxpemUoZSl7cmV0dXJuIGUuc3RhcnQoKSxXdChlKX19LEh0PXtjYW5IYW5kbGU6ZT0+TWUoZSkmJkVlIGluIGUsc2VyaWFsaXplKHt2YWx1ZTplfSl7bGV0IHQ7cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvcj90PXtpc0Vycm9yOiEwLHZhbHVlOnttZXNzYWdlOmUubWVzc2FnZSxuYW1lOmUubmFtZSxzdGFjazplLnN0YWNrfX06dD17aXNFcnJvcjohMSx2YWx1ZTplfSxbdCxbXV19LGRlc2VyaWFsaXplKGUpe3Rocm93IGUuaXNFcnJvcj9PYmplY3QuYXNzaWduKG5ldyBFcnJvcihlLnZhbHVlLm1lc3NhZ2UpLGUudmFsdWUpOmUudmFsdWV9fSxWZT1uZXcgTWFwKFtbInByb3h5IixYdF0sWyJ0aHJvdyIsSHRdXSk7ZnVuY3Rpb24gVGUoZSx0PXNlbGYpe3QuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsZnVuY3Rpb24gbihpKXtpZighaXx8IWkuZGF0YSlyZXR1cm47Y29uc3R7aWQ6cix0eXBlOmEscGF0aDpvfT1PYmplY3QuYXNzaWduKHtwYXRoOltdfSxpLmRhdGEpLGw9KGkuZGF0YS5hcmd1bWVudExpc3R8fFtdKS5tYXAoSyk7bGV0IHM7dHJ5e2NvbnN0IGM9by5zbGljZSgwLC0xKS5yZWR1Y2UoKGQsdik9PmRbdl0sZSksZj1vLnJlZHVjZSgoZCx2KT0+ZFt2XSxlKTtzd2l0Y2goYSl7Y2FzZSJHRVQiOnM9ZjticmVhaztjYXNlIlNFVCI6Y1tvLnNsaWNlKC0xKVswXV09SyhpLmRhdGEudmFsdWUpLHM9ITA7YnJlYWs7Y2FzZSJBUFBMWSI6cz1mLmFwcGx5KGMsbCk7YnJlYWs7Y2FzZSJDT05TVFJVQ1QiOntjb25zdCBkPW5ldyBmKC4uLmwpO3M9dG4oZCl9YnJlYWs7Y2FzZSJFTkRQT0lOVCI6e2NvbnN0e3BvcnQxOmQscG9ydDI6dn09bmV3IE1lc3NhZ2VDaGFubmVsO1RlKGUsdikscz1lbihkLFtkXSl9YnJlYWs7Y2FzZSJSRUxFQVNFIjpzPXZvaWQgMDticmVhaztkZWZhdWx0OnJldHVybn19Y2F0Y2goYyl7cz17dmFsdWU6YyxbRWVdOjB9fVByb21pc2UucmVzb2x2ZShzKS5jYXRjaChjPT4oe3ZhbHVlOmMsW0VlXTowfSkpLnRoZW4oYz0+e2NvbnN0W2YsZF09TmUoYyk7dC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZikse2lkOnJ9KSxkKSxhPT09IlJFTEVBU0UiJiYodC5yZW1vdmVFdmVudExpc3RlbmVyKCJtZXNzYWdlIixuKSwkZSh0KSl9KX0pLHQuc3RhcnQmJnQuc3RhcnQoKX1mdW5jdGlvbiBRdChlKXtyZXR1cm4gZS5jb25zdHJ1Y3Rvci5uYW1lPT09Ik1lc3NhZ2VQb3J0In1mdW5jdGlvbiAkZShlKXtRdChlKSYmZS5jbG9zZSgpfWZ1bmN0aW9uIFd0KGUsdCl7cmV0dXJuIGdlKGUsW10sdCl9ZnVuY3Rpb24gcmUoZSl7aWYoZSl0aHJvdyBuZXcgRXJyb3IoIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZSIpfWZ1bmN0aW9uIGdlKGUsdD1bXSxuPWZ1bmN0aW9uKCl7fSl7bGV0IGk9ITE7Y29uc3Qgcj1uZXcgUHJveHkobix7Z2V0KGEsbyl7aWYocmUoaSksbz09PXF0KXJldHVybigpPT5YKGUse3R5cGU6IlJFTEVBU0UiLHBhdGg6dC5tYXAobD0+bC50b1N0cmluZygpKX0pLnRoZW4oKCk9PnskZShlKSxpPSEwfSk7aWYobz09PSJ0aGVuIil7aWYodC5sZW5ndGg9PT0wKXJldHVybnt0aGVuOigpPT5yfTtjb25zdCBsPVgoZSx7dHlwZToiR0VUIixwYXRoOnQubWFwKHM9PnMudG9TdHJpbmcoKSl9KS50aGVuKEspO3JldHVybiBsLnRoZW4uYmluZChsKX1yZXR1cm4gZ2UoZSxbLi4udCxvXSl9LHNldChhLG8sbCl7cmUoaSk7Y29uc3RbcyxjXT1OZShsKTtyZXR1cm4gWChlLHt0eXBlOiJTRVQiLHBhdGg6Wy4uLnQsb10ubWFwKGY9PmYudG9TdHJpbmcoKSksdmFsdWU6c30sYykudGhlbihLKX0sYXBwbHkoYSxvLGwpe3JlKGkpO2NvbnN0IHM9dFt0Lmxlbmd0aC0xXTtpZihzPT09enQpcmV0dXJuIFgoZSx7dHlwZToiRU5EUE9JTlQifSkudGhlbihLKTtpZihzPT09ImJpbmQiKXJldHVybiBnZShlLHQuc2xpY2UoMCwtMSkpO2NvbnN0W2MsZl09VWUobCk7cmV0dXJuIFgoZSx7dHlwZToiQVBQTFkiLHBhdGg6dC5tYXAoZD0+ZC50b1N0cmluZygpKSxhcmd1bWVudExpc3Q6Y30sZikudGhlbihLKX0sY29uc3RydWN0KGEsbyl7cmUoaSk7Y29uc3RbbCxzXT1VZShvKTtyZXR1cm4gWChlLHt0eXBlOiJDT05TVFJVQ1QiLHBhdGg6dC5tYXAoYz0+Yy50b1N0cmluZygpKSxhcmd1bWVudExpc3Q6bH0scykudGhlbihLKX19KTtyZXR1cm4gcn1mdW5jdGlvbiBadChlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSxlKX1mdW5jdGlvbiBVZShlKXtjb25zdCB0PWUubWFwKE5lKTtyZXR1cm5bdC5tYXAobj0+blswXSksWnQodC5tYXAobj0+blsxXSkpXX1jb25zdCBLZT1uZXcgV2Vha01hcDtmdW5jdGlvbiBlbihlLHQpe3JldHVybiBLZS5zZXQoZSx0KSxlfWZ1bmN0aW9uIHRuKGUpe3JldHVybiBPYmplY3QuYXNzaWduKGUse1tCZV06ITB9KX1mdW5jdGlvbiBOZShlKXtmb3IoY29uc3RbdCxuXW9mIFZlKWlmKG4uY2FuSGFuZGxlKGUpKXtjb25zdFtpLHJdPW4uc2VyaWFsaXplKGUpO3JldHVyblt7dHlwZToiSEFORExFUiIsbmFtZTp0LHZhbHVlOml9LHJdfXJldHVyblt7dHlwZToiUkFXIix2YWx1ZTplfSxLZS5nZXQoZSl8fFtdXX1mdW5jdGlvbiBLKGUpe3N3aXRjaChlLnR5cGUpe2Nhc2UiSEFORExFUiI6cmV0dXJuIFZlLmdldChlLm5hbWUpLmRlc2VyaWFsaXplKGUudmFsdWUpO2Nhc2UiUkFXIjpyZXR1cm4gZS52YWx1ZX19ZnVuY3Rpb24gWChlLHQsbil7cmV0dXJuIG5ldyBQcm9taXNlKGk9Pntjb25zdCByPW5uKCk7ZS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixmdW5jdGlvbiBhKG8peyFvLmRhdGF8fCFvLmRhdGEuaWR8fG8uZGF0YS5pZCE9PXJ8fChlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGEpLGkoby5kYXRhKSl9KSxlLnN0YXJ0JiZlLnN0YXJ0KCksZS5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHtpZDpyfSx0KSxuKX0pfWZ1bmN0aW9uIG5uKCl7cmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKT0+TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpLmpvaW4oIi0iKX1mdW5jdGlvbiBhZShlKXtyZXR1cm4gdHlwZW9mIFN5bWJvbD09ImZ1bmN0aW9uIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09InN5bWJvbCI/YWU9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTphZT1mdW5jdGlvbih0KXtyZXR1cm4gdCYmdHlwZW9mIFN5bWJvbD09ImZ1bmN0aW9uIiYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/InN5bWJvbCI6dHlwZW9mIHR9LGFlKGUpfWZ1bmN0aW9uIHJuKGUpe3JldHVybiBhZShlKT09Im9iamVjdCImJmUhPT1udWxsfXZhciBKZT10eXBlb2YgU3ltYm9sPT0iZnVuY3Rpb24iJiZTeW1ib2wudG9TdHJpbmdUYWchPW51bGw/U3ltYm9sLnRvU3RyaW5nVGFnOiJAQHRvU3RyaW5nVGFnIjtmdW5jdGlvbiB4ZShlLHQpe2Zvcih2YXIgbj0vXHJcbnxbXG5ccl0vZyxpPTEscj10KzEsYTsoYT1uLmV4ZWMoZS5ib2R5KSkmJmEuaW5kZXg8dDspaSs9MSxyPXQrMS0oYS5pbmRleCthWzBdLmxlbmd0aCk7cmV0dXJue2xpbmU6aSxjb2x1bW46cn19ZnVuY3Rpb24gYW4oZSl7cmV0dXJuIFllKGUuc291cmNlLHhlKGUuc291cmNlLGUuc3RhcnQpKX1mdW5jdGlvbiBZZShlLHQpe3ZhciBuPWUubG9jYXRpb25PZmZzZXQuY29sdW1uLTEsaT1vZShuKStlLmJvZHkscj10LmxpbmUtMSxhPWUubG9jYXRpb25PZmZzZXQubGluZS0xLG89dC5saW5lK2EsbD10LmxpbmU9PT0xP246MCxzPXQuY29sdW1uK2wsYz0iIi5jb25jYXQoZS5uYW1lLCI6IikuY29uY2F0KG8sIjoiKS5jb25jYXQocyxgCmApLGY9aS5zcGxpdCgvXHJcbnxbXG5ccl0vZyksZD1mW3JdO2lmKGQubGVuZ3RoPjEyMCl7Zm9yKHZhciB2PU1hdGguZmxvb3Iocy84MCksbT1zJTgwLGg9W10sTj0wO048ZC5sZW5ndGg7Tis9ODApaC5wdXNoKGQuc2xpY2UoTixOKzgwKSk7cmV0dXJuIGMrR2UoW1siIi5jb25jYXQobyksaFswXV1dLmNvbmNhdChoLnNsaWNlKDEsdisxKS5tYXAoZnVuY3Rpb24oZyl7cmV0dXJuWyIiLGddfSksW1siICIsb2UobS0xKSsiXiJdLFsiIixoW3YrMV1dXSkpfXJldHVybiBjK0dlKFtbIiIuY29uY2F0KG8tMSksZltyLTFdXSxbIiIuY29uY2F0KG8pLGRdLFsiIixvZShzLTEpKyJeIl0sWyIiLmNvbmNhdChvKzEpLGZbcisxXV1dKX1mdW5jdGlvbiBHZShlKXt2YXIgdD1lLmZpbHRlcihmdW5jdGlvbihpKXtpWzBdO3ZhciByPWlbMV07cmV0dXJuIHIhPT12b2lkIDB9KSxuPU1hdGgubWF4LmFwcGx5KE1hdGgsdC5tYXAoZnVuY3Rpb24oaSl7dmFyIHI9aVswXTtyZXR1cm4gci5sZW5ndGh9KSk7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKGkpe3ZhciByPWlbMF0sYT1pWzFdO3JldHVybiBvbihuLHIpKyhhPyIgfCAiK2E6IiB8Iil9KS5qb2luKGAKYCl9ZnVuY3Rpb24gb2UoZSl7cmV0dXJuIEFycmF5KGUrMSkuam9pbigiICIpfWZ1bmN0aW9uIG9uKGUsdCl7cmV0dXJuIG9lKGUtdC5sZW5ndGgpK3R9ZnVuY3Rpb24gc2UoZSl7cmV0dXJuIHR5cGVvZiBTeW1ib2w9PSJmdW5jdGlvbiImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PSJzeW1ib2wiP3NlPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06c2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnR5cGVvZiBTeW1ib2w9PSJmdW5jdGlvbiImJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiB0fSxzZShlKX1mdW5jdGlvbiB6ZShlLHQpe3ZhciBuPU9iamVjdC5rZXlzKGUpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7dCYmKGk9aS5maWx0ZXIoZnVuY3Rpb24ocil7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKS5lbnVtZXJhYmxlfSkpLG4ucHVzaC5hcHBseShuLGkpfXJldHVybiBufWZ1bmN0aW9uIHNuKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPWFyZ3VtZW50c1t0XSE9bnVsbD9hcmd1bWVudHNbdF06e307dCUyP3plKE9iamVjdChuKSwhMCkuZm9yRWFjaChmdW5jdGlvbihpKXtsbihlLGksbltpXSl9KTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKTp6ZShPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24oaSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4saSkpfSl9cmV0dXJuIGV9ZnVuY3Rpb24gbG4oZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfWZ1bmN0aW9uIGNuKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIil9ZnVuY3Rpb24gcWUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCwidmFsdWUiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1mdW5jdGlvbiB1bihlLHQsbil7cmV0dXJuIHQmJnFlKGUucHJvdG90eXBlLHQpLG4mJnFlKGUsbiksZX1mdW5jdGlvbiBmbihlLHQpe2lmKHR5cGVvZiB0IT0iZnVuY3Rpb24iJiZ0IT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZaKGUsdCl9ZnVuY3Rpb24gcG4oZSl7dmFyIHQ9SGUoKTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgbj1lZShlKSxpO2lmKHQpe3ZhciByPWVlKHRoaXMpLmNvbnN0cnVjdG9yO2k9UmVmbGVjdC5jb25zdHJ1Y3Qobixhcmd1bWVudHMscil9ZWxzZSBpPW4uYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBYZSh0aGlzLGkpfX1mdW5jdGlvbiBYZShlLHQpe3JldHVybiB0JiYoc2UodCk9PT0ib2JqZWN0Inx8dHlwZW9mIHQ9PSJmdW5jdGlvbiIpP3Q6VyhlKX1mdW5jdGlvbiBXKGUpe2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiKTtyZXR1cm4gZX1mdW5jdGlvbiBJZShlKXt2YXIgdD10eXBlb2YgTWFwPT0iZnVuY3Rpb24iP25ldyBNYXA6dm9pZCAwO3JldHVybiBJZT1mdW5jdGlvbihuKXtpZihuPT09bnVsbHx8IWRuKG4pKXJldHVybiBuO2lmKHR5cGVvZiBuIT0iZnVuY3Rpb24iKXRocm93IG5ldyBUeXBlRXJyb3IoIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uIik7aWYodHlwZW9mIHQhPSJ1bmRlZmluZWQiKXtpZih0LmhhcyhuKSlyZXR1cm4gdC5nZXQobik7dC5zZXQobixpKX1mdW5jdGlvbiBpKCl7cmV0dXJuIGxlKG4sYXJndW1lbnRzLGVlKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShuLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmksZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksWihpLG4pfSxJZShlKX1mdW5jdGlvbiBsZShlLHQsbil7cmV0dXJuIEhlKCk/bGU9UmVmbGVjdC5jb25zdHJ1Y3Q6bGU9ZnVuY3Rpb24oaSxyLGEpe3ZhciBvPVtudWxsXTtvLnB1c2guYXBwbHkobyxyKTt2YXIgbD1GdW5jdGlvbi5iaW5kLmFwcGx5KGksbykscz1uZXcgbDtyZXR1cm4gYSYmWihzLGEucHJvdG90eXBlKSxzfSxsZS5hcHBseShudWxsLGFyZ3VtZW50cyl9ZnVuY3Rpb24gSGUoKXtpZih0eXBlb2YgUmVmbGVjdD09InVuZGVmaW5lZCJ8fCFSZWZsZWN0LmNvbnN0cnVjdHx8UmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZih0eXBlb2YgUHJveHk9PSJmdW5jdGlvbiIpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2h7cmV0dXJuITF9fWZ1bmN0aW9uIGRuKGUpe3JldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGUpLmluZGV4T2YoIltuYXRpdmUgY29kZV0iKSE9PS0xfWZ1bmN0aW9uIFooZSx0KXtyZXR1cm4gWj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKG4saSl7cmV0dXJuIG4uX19wcm90b19fPWksbn0sWihlLHQpfWZ1bmN0aW9uIGVlKGUpe3JldHVybiBlZT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSxlZShlKX12YXIgbW49ZnVuY3Rpb24oZSl7Zm4obixlKTt2YXIgdD1wbihuKTtmdW5jdGlvbiBuKGkscixhLG8sbCxzLGMpe3ZhciBmLGQsdixtO2NuKHRoaXMsbiksbT10LmNhbGwodGhpcyxpKSxtLm5hbWU9IkdyYXBoUUxFcnJvciIsbS5vcmlnaW5hbEVycm9yPXMhPW51bGw/czp2b2lkIDAsbS5ub2Rlcz1RZShBcnJheS5pc0FycmF5KHIpP3I6cj9bcl06dm9pZCAwKTtmb3IodmFyIGg9W10sTj0wLGc9KEE9bS5ub2RlcykhPT1udWxsJiZBIT09dm9pZCAwP0E6W107TjxnLmxlbmd0aDtOKyspe3ZhciBBLHg9Z1tOXSxPPXgubG9jO08hPW51bGwmJmgucHVzaChPKX1oPVFlKGgpLG0uc291cmNlPWEhPW51bGw/YTooZj1oKT09PW51bGx8fGY9PT12b2lkIDA/dm9pZCAwOmZbMF0uc291cmNlLG0ucG9zaXRpb25zPW8hPW51bGw/bzooZD1oKT09PW51bGx8fGQ9PT12b2lkIDA/dm9pZCAwOmQubWFwKGZ1bmN0aW9uKGspe3JldHVybiBrLnN0YXJ0fSksbS5sb2NhdGlvbnM9byYmYT9vLm1hcChmdW5jdGlvbihrKXtyZXR1cm4geGUoYSxrKX0pOih2PWgpPT09bnVsbHx8dj09PXZvaWQgMD92b2lkIDA6di5tYXAoZnVuY3Rpb24oayl7cmV0dXJuIHhlKGsuc291cmNlLGsuc3RhcnQpfSksbS5wYXRoPWwhPW51bGw/bDp2b2lkIDA7dmFyIHE9cz09bnVsbD92b2lkIDA6cy5leHRlbnNpb25zO3JldHVybiBjPT1udWxsJiZybihxKT9tLmV4dGVuc2lvbnM9c24oe30scSk6bS5leHRlbnNpb25zPWMhPW51bGw/Yzp7fSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXKG0pLHttZXNzYWdlOntlbnVtZXJhYmxlOiEwfSxsb2NhdGlvbnM6e2VudW1lcmFibGU6bS5sb2NhdGlvbnMhPW51bGx9LHBhdGg6e2VudW1lcmFibGU6bS5wYXRoIT1udWxsfSxleHRlbnNpb25zOntlbnVtZXJhYmxlOm0uZXh0ZW5zaW9ucyE9bnVsbCYmT2JqZWN0LmtleXMobS5leHRlbnNpb25zKS5sZW5ndGg+MH0sbmFtZTp7ZW51bWVyYWJsZTohMX0sbm9kZXM6e2VudW1lcmFibGU6ITF9LHNvdXJjZTp7ZW51bWVyYWJsZTohMX0scG9zaXRpb25zOntlbnVtZXJhYmxlOiExfSxvcmlnaW5hbEVycm9yOntlbnVtZXJhYmxlOiExfX0pLHMhPW51bGwmJnMuc3RhY2s/KE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXKG0pLCJzdGFjayIse3ZhbHVlOnMuc3RhY2ssd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksWGUobSkpOihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZShXKG0pLG4pOk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXKG0pLCJzdGFjayIse3ZhbHVlOkVycm9yKCkuc3RhY2ssd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksbSl9cmV0dXJuIHVuKG4sW3trZXk6InRvU3RyaW5nIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBobih0aGlzKX19LHtrZXk6SmUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIk9iamVjdCJ9fV0pLG59KEllKEVycm9yKSk7ZnVuY3Rpb24gUWUoZSl7cmV0dXJuIGU9PT12b2lkIDB8fGUubGVuZ3RoPT09MD92b2lkIDA6ZX1mdW5jdGlvbiBobihlKXt2YXIgdD1lLm1lc3NhZ2U7aWYoZS5ub2Rlcylmb3IodmFyIG49MCxpPWUubm9kZXM7bjxpLmxlbmd0aDtuKyspe3ZhciByPWlbbl07ci5sb2MmJih0Kz1gCgpgK2FuKHIubG9jKSl9ZWxzZSBpZihlLnNvdXJjZSYmZS5sb2NhdGlvbnMpZm9yKHZhciBhPTAsbz1lLmxvY2F0aW9uczthPG8ubGVuZ3RoO2ErKyl7dmFyIGw9b1thXTt0Kz1gCgpgK1llKGUuc291cmNlLGwpfXJldHVybiB0fWZ1bmN0aW9uIF8oZSx0LG4pe3JldHVybiBuZXcgbW4oIlN5bnRheCBFcnJvcjogIi5jb25jYXQobiksdm9pZCAwLGUsW3RdKX12YXIgVD1PYmplY3QuZnJlZXplKHtOQU1FOiJOYW1lIixET0NVTUVOVDoiRG9jdW1lbnQiLE9QRVJBVElPTl9ERUZJTklUSU9OOiJPcGVyYXRpb25EZWZpbml0aW9uIixWQVJJQUJMRV9ERUZJTklUSU9OOiJWYXJpYWJsZURlZmluaXRpb24iLFNFTEVDVElPTl9TRVQ6IlNlbGVjdGlvblNldCIsRklFTEQ6IkZpZWxkIixBUkdVTUVOVDoiQXJndW1lbnQiLEZSQUdNRU5UX1NQUkVBRDoiRnJhZ21lbnRTcHJlYWQiLElOTElORV9GUkFHTUVOVDoiSW5saW5lRnJhZ21lbnQiLEZSQUdNRU5UX0RFRklOSVRJT046IkZyYWdtZW50RGVmaW5pdGlvbiIsVkFSSUFCTEU6IlZhcmlhYmxlIixJTlQ6IkludFZhbHVlIixGTE9BVDoiRmxvYXRWYWx1ZSIsU1RSSU5HOiJTdHJpbmdWYWx1ZSIsQk9PTEVBTjoiQm9vbGVhblZhbHVlIixOVUxMOiJOdWxsVmFsdWUiLEVOVU06IkVudW1WYWx1ZSIsTElTVDoiTGlzdFZhbHVlIixPQkpFQ1Q6Ik9iamVjdFZhbHVlIixPQkpFQ1RfRklFTEQ6Ik9iamVjdEZpZWxkIixESVJFQ1RJVkU6IkRpcmVjdGl2ZSIsTkFNRURfVFlQRToiTmFtZWRUeXBlIixMSVNUX1RZUEU6Ikxpc3RUeXBlIixOT05fTlVMTF9UWVBFOiJOb25OdWxsVHlwZSIsU0NIRU1BX0RFRklOSVRJT046IlNjaGVtYURlZmluaXRpb24iLE9QRVJBVElPTl9UWVBFX0RFRklOSVRJT046Ik9wZXJhdGlvblR5cGVEZWZpbml0aW9uIixTQ0FMQVJfVFlQRV9ERUZJTklUSU9OOiJTY2FsYXJUeXBlRGVmaW5pdGlvbiIsT0JKRUNUX1RZUEVfREVGSU5JVElPTjoiT2JqZWN0VHlwZURlZmluaXRpb24iLEZJRUxEX0RFRklOSVRJT046IkZpZWxkRGVmaW5pdGlvbiIsSU5QVVRfVkFMVUVfREVGSU5JVElPTjoiSW5wdXRWYWx1ZURlZmluaXRpb24iLElOVEVSRkFDRV9UWVBFX0RFRklOSVRJT046IkludGVyZmFjZVR5cGVEZWZpbml0aW9uIixVTklPTl9UWVBFX0RFRklOSVRJT046IlVuaW9uVHlwZURlZmluaXRpb24iLEVOVU1fVFlQRV9ERUZJTklUSU9OOiJFbnVtVHlwZURlZmluaXRpb24iLEVOVU1fVkFMVUVfREVGSU5JVElPTjoiRW51bVZhbHVlRGVmaW5pdGlvbiIsSU5QVVRfT0JKRUNUX1RZUEVfREVGSU5JVElPTjoiSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbiIsRElSRUNUSVZFX0RFRklOSVRJT046IkRpcmVjdGl2ZURlZmluaXRpb24iLFNDSEVNQV9FWFRFTlNJT046IlNjaGVtYUV4dGVuc2lvbiIsU0NBTEFSX1RZUEVfRVhURU5TSU9OOiJTY2FsYXJUeXBlRXh0ZW5zaW9uIixPQkpFQ1RfVFlQRV9FWFRFTlNJT046Ik9iamVjdFR5cGVFeHRlbnNpb24iLElOVEVSRkFDRV9UWVBFX0VYVEVOU0lPTjoiSW50ZXJmYWNlVHlwZUV4dGVuc2lvbiIsVU5JT05fVFlQRV9FWFRFTlNJT046IlVuaW9uVHlwZUV4dGVuc2lvbiIsRU5VTV9UWVBFX0VYVEVOU0lPTjoiRW51bVR5cGVFeHRlbnNpb24iLElOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTjoiSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uIn0pO2Z1bmN0aW9uIHZuKGUsdCl7dmFyIG49Qm9vbGVhbihlKTtpZighbil0aHJvdyBuZXcgRXJyb3IodCE9bnVsbD90OiJVbmV4cGVjdGVkIGludmFyaWFudCB0cmlnZ2VyZWQuIil9dmFyIHluPXR5cGVvZiBTeW1ib2w9PSJmdW5jdGlvbiImJnR5cGVvZiBTeW1ib2wuZm9yPT0iZnVuY3Rpb24iP1N5bWJvbC5mb3IoIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tIik6dm9pZCAwLFNlPXluO2Z1bmN0aW9uIFdlKGUpe3ZhciB0PWUucHJvdG90eXBlLnRvSlNPTjt0eXBlb2YgdD09ImZ1bmN0aW9uInx8dm4oMCksZS5wcm90b3R5cGUuaW5zcGVjdD10LFNlJiYoZS5wcm90b3R5cGVbU2VdPXQpfXZhciBaZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixpLHIpe3RoaXMuc3RhcnQ9bi5zdGFydCx0aGlzLmVuZD1pLmVuZCx0aGlzLnN0YXJ0VG9rZW49bix0aGlzLmVuZFRva2VuPWksdGhpcy5zb3VyY2U9cn12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57c3RhcnQ6dGhpcy5zdGFydCxlbmQ6dGhpcy5lbmR9fSxlfSgpO1dlKFplKTt2YXIgUz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixpLHIsYSxvLGwscyl7dGhpcy5raW5kPW4sdGhpcy5zdGFydD1pLHRoaXMuZW5kPXIsdGhpcy5saW5lPWEsdGhpcy5jb2x1bW49byx0aGlzLnZhbHVlPXMsdGhpcy5wcmV2PWwsdGhpcy5uZXh0PW51bGx9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue2tpbmQ6dGhpcy5raW5kLHZhbHVlOnRoaXMudmFsdWUsbGluZTp0aGlzLmxpbmUsY29sdW1uOnRoaXMuY29sdW1ufX0sZX0oKTtXZShTKTtmdW5jdGlvbiBldChlKXtyZXR1cm4gZSE9bnVsbCYmdHlwZW9mIGUua2luZD09InN0cmluZyJ9dmFyIHA9T2JqZWN0LmZyZWV6ZSh7U09GOiI8U09GPiIsRU9GOiI8RU9GPiIsQkFORzoiISIsRE9MTEFSOiIkIixBTVA6IiYiLFBBUkVOX0w6IigiLFBBUkVOX1I6IikiLFNQUkVBRDoiLi4uIixDT0xPTjoiOiIsRVFVQUxTOiI9IixBVDoiQCIsQlJBQ0tFVF9MOiJbIixCUkFDS0VUX1I6Il0iLEJSQUNFX0w6InsiLFBJUEU6InwiLEJSQUNFX1I6In0iLE5BTUU6Ik5hbWUiLElOVDoiSW50IixGTE9BVDoiRmxvYXQiLFNUUklORzoiU3RyaW5nIixCTE9DS19TVFJJTkc6IkJsb2NrU3RyaW5nIixDT01NRU5UOiJDb21tZW50In0pO2Z1bmN0aW9uIGNlKGUpe3JldHVybiB0eXBlb2YgU3ltYm9sPT0iZnVuY3Rpb24iJiZ0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT0ic3ltYm9sIj9jZT1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmNlPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0eXBlb2YgU3ltYm9sPT0iZnVuY3Rpb24iJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT8ic3ltYm9sIjp0eXBlb2YgdH0sY2UoZSl9dmFyIEVuPTEwLHR0PTI7ZnVuY3Rpb24gbnQoZSl7cmV0dXJuIHVlKGUsW10pfWZ1bmN0aW9uIHVlKGUsdCl7c3dpdGNoKGNlKGUpKXtjYXNlInN0cmluZyI6cmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpO2Nhc2UiZnVuY3Rpb24iOnJldHVybiBlLm5hbWU/IltmdW5jdGlvbiAiLmNvbmNhdChlLm5hbWUsIl0iKToiW2Z1bmN0aW9uXSI7Y2FzZSJvYmplY3QiOnJldHVybiBlPT09bnVsbD8ibnVsbCI6VG4oZSx0KTtkZWZhdWx0OnJldHVybiBTdHJpbmcoZSl9fWZ1bmN0aW9uIFRuKGUsdCl7aWYodC5pbmRleE9mKGUpIT09LTEpcmV0dXJuIltDaXJjdWxhcl0iO3ZhciBuPVtdLmNvbmNhdCh0LFtlXSksaT14bihlKTtpZihpIT09dm9pZCAwKXt2YXIgcj1pLmNhbGwoZSk7aWYociE9PWUpcmV0dXJuIHR5cGVvZiByPT0ic3RyaW5nIj9yOnVlKHIsbil9ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBObihlLG4pO3JldHVybiBnbihlLG4pfWZ1bmN0aW9uIGduKGUsdCl7dmFyIG49T2JqZWN0LmtleXMoZSk7aWYobi5sZW5ndGg9PT0wKXJldHVybiJ7fSI7aWYodC5sZW5ndGg+dHQpcmV0dXJuIlsiK0luKGUpKyJdIjt2YXIgaT1uLm1hcChmdW5jdGlvbihyKXt2YXIgYT11ZShlW3JdLHQpO3JldHVybiByKyI6ICIrYX0pO3JldHVybiJ7ICIraS5qb2luKCIsICIpKyIgfSJ9ZnVuY3Rpb24gTm4oZSx0KXtpZihlLmxlbmd0aD09PTApcmV0dXJuIltdIjtpZih0Lmxlbmd0aD50dClyZXR1cm4iW0FycmF5XSI7Zm9yKHZhciBuPU1hdGgubWluKEVuLGUubGVuZ3RoKSxpPWUubGVuZ3RoLW4scj1bXSxhPTA7YTxuOysrYSlyLnB1c2godWUoZVthXSx0KSk7cmV0dXJuIGk9PT0xP3IucHVzaCgiLi4uIDEgbW9yZSBpdGVtIik6aT4xJiZyLnB1c2goIi4uLiAiLmNvbmNhdChpLCIgbW9yZSBpdGVtcyIpKSwiWyIrci5qb2luKCIsICIpKyJdIn1mdW5jdGlvbiB4bihlKXt2YXIgdD1lW1N0cmluZyhTZSldO2lmKHR5cGVvZiB0PT0iZnVuY3Rpb24iKXJldHVybiB0O2lmKHR5cGVvZiBlLmluc3BlY3Q9PSJmdW5jdGlvbiIpcmV0dXJuIGUuaW5zcGVjdH1mdW5jdGlvbiBJbihlKXt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkucmVwbGFjZSgvXlxbb2JqZWN0IC8sIiIpLnJlcGxhY2UoL10kLywiIik7aWYodD09PSJPYmplY3QiJiZ0eXBlb2YgZS5jb25zdHJ1Y3Rvcj09ImZ1bmN0aW9uIil7dmFyIG49ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKHR5cGVvZiBuPT0ic3RyaW5nIiYmbiE9PSIiKXJldHVybiBufXJldHVybiB0fWZ1bmN0aW9uIE9lKGUsdCl7dmFyIG49Qm9vbGVhbihlKTtpZighbil0aHJvdyBuZXcgRXJyb3IodCl9dmFyIFNuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0fTtmdW5jdGlvbiBpdChlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLCJ2YWx1ZSJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsaS5rZXksaSl9fWZ1bmN0aW9uIE9uKGUsdCxuKXtyZXR1cm4gdCYmaXQoZS5wcm90b3R5cGUsdCksbiYmaXQoZSxuKSxlfXZhciBydD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiJHcmFwaFFMIHJlcXVlc3QiLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOntsaW5lOjEsY29sdW1uOjF9O3R5cGVvZiB0PT0ic3RyaW5nInx8T2UoMCwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZDogIi5jb25jYXQobnQodCksIi4iKSksdGhpcy5ib2R5PXQsdGhpcy5uYW1lPW4sdGhpcy5sb2NhdGlvbk9mZnNldD1pLHRoaXMubG9jYXRpb25PZmZzZXQubGluZT4wfHxPZSgwLCJsaW5lIGluIGxvY2F0aW9uT2Zmc2V0IGlzIDEtaW5kZXhlZCBhbmQgbXVzdCBiZSBwb3NpdGl2ZS4iKSx0aGlzLmxvY2F0aW9uT2Zmc2V0LmNvbHVtbj4wfHxPZSgwLCJjb2x1bW4gaW4gbG9jYXRpb25PZmZzZXQgaXMgMS1pbmRleGVkIGFuZCBtdXN0IGJlIHBvc2l0aXZlLiIpfXJldHVybiBPbihlLFt7a2V5OkplLGdldDpmdW5jdGlvbigpe3JldHVybiJTb3VyY2UifX1dKSxlfSgpO2Z1bmN0aW9uIEFuKGUpe3JldHVybiBTbihlLHJ0KX12YXIgYm49T2JqZWN0LmZyZWV6ZSh7UVVFUlk6IlFVRVJZIixNVVRBVElPTjoiTVVUQVRJT04iLFNVQlNDUklQVElPTjoiU1VCU0NSSVBUSU9OIixGSUVMRDoiRklFTEQiLEZSQUdNRU5UX0RFRklOSVRJT046IkZSQUdNRU5UX0RFRklOSVRJT04iLEZSQUdNRU5UX1NQUkVBRDoiRlJBR01FTlRfU1BSRUFEIixJTkxJTkVfRlJBR01FTlQ6IklOTElORV9GUkFHTUVOVCIsVkFSSUFCTEVfREVGSU5JVElPTjoiVkFSSUFCTEVfREVGSU5JVElPTiIsU0NIRU1BOiJTQ0hFTUEiLFNDQUxBUjoiU0NBTEFSIixPQkpFQ1Q6Ik9CSkVDVCIsRklFTERfREVGSU5JVElPTjoiRklFTERfREVGSU5JVElPTiIsQVJHVU1FTlRfREVGSU5JVElPTjoiQVJHVU1FTlRfREVGSU5JVElPTiIsSU5URVJGQUNFOiJJTlRFUkZBQ0UiLFVOSU9OOiJVTklPTiIsRU5VTToiRU5VTSIsRU5VTV9WQUxVRToiRU5VTV9WQUxVRSIsSU5QVVRfT0JKRUNUOiJJTlBVVF9PQkpFQ1QiLElOUFVUX0ZJRUxEX0RFRklOSVRJT046IklOUFVUX0ZJRUxEX0RFRklOSVRJT04ifSk7ZnVuY3Rpb24ga24oZSl7dmFyIHQ9ZS5zcGxpdCgvXHJcbnxbXG5ccl0vZyksbj1EbihlKTtpZihuIT09MClmb3IodmFyIGk9MTtpPHQubGVuZ3RoO2krKyl0W2ldPXRbaV0uc2xpY2Uobik7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aCYmYXQodFtyXSk7KSsrcjtmb3IodmFyIGE9dC5sZW5ndGg7YT5yJiZhdCh0W2EtMV0pOyktLWE7cmV0dXJuIHQuc2xpY2UocixhKS5qb2luKGAKYCl9ZnVuY3Rpb24gYXQoZSl7Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3QpaWYoZVt0XSE9PSIgIiYmZVt0XSE9PSIJIilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBEbihlKXtmb3IodmFyIHQsbj0hMCxpPSEwLHI9MCxhPW51bGwsbz0wO288ZS5sZW5ndGg7KytvKXN3aXRjaChlLmNoYXJDb2RlQXQobykpe2Nhc2UgMTM6ZS5jaGFyQ29kZUF0KG8rMSk9PT0xMCYmKytvO2Nhc2UgMTA6bj0hMSxpPSEwLHI9MDticmVhaztjYXNlIDk6Y2FzZSAzMjorK3I7YnJlYWs7ZGVmYXVsdDppJiYhbiYmKGE9PT1udWxsfHxyPGEpJiYoYT1yKSxpPSExfXJldHVybih0PWEpIT09bnVsbCYmdCE9PXZvaWQgMD90OjB9ZnVuY3Rpb24gX24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiIiLG49YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOiExLGk9ZS5pbmRleE9mKGAKYCk9PT0tMSxyPWVbMF09PT0iICJ8fGVbMF09PT0iCSIsYT1lW2UubGVuZ3RoLTFdPT09JyInLG89ZVtlLmxlbmd0aC0xXT09PSJcXCIsbD0haXx8YXx8b3x8bixzPSIiO3JldHVybiBsJiYhKGkmJnIpJiYocys9YApgK3QpLHMrPXQ/ZS5yZXBsYWNlKC9cbi9nLGAKYCt0KTplLGwmJihzKz1gCmApLCciIiInK3MucmVwbGFjZSgvIiIiL2csJ1xcIiIiJykrJyIiIid9dmFyIExuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShuKXt2YXIgaT1uZXcgUyhwLlNPRiwwLDAsMCwwLG51bGwpO3RoaXMuc291cmNlPW4sdGhpcy5sYXN0VG9rZW49aSx0aGlzLnRva2VuPWksdGhpcy5saW5lPTEsdGhpcy5saW5lU3RhcnQ9MH12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5hZHZhbmNlPWZ1bmN0aW9uKCl7dGhpcy5sYXN0VG9rZW49dGhpcy50b2tlbjt2YXIgbj10aGlzLnRva2VuPXRoaXMubG9va2FoZWFkKCk7cmV0dXJuIG59LHQubG9va2FoZWFkPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy50b2tlbjtpZihuLmtpbmQhPT1wLkVPRilkb3t2YXIgaTtuPShpPW4ubmV4dCkhPT1udWxsJiZpIT09dm9pZCAwP2k6bi5uZXh0PXduKHRoaXMsbil9d2hpbGUobi5raW5kPT09cC5DT01NRU5UKTtyZXR1cm4gbn0sZX0oKTtmdW5jdGlvbiBDbihlKXtyZXR1cm4gZT09PXAuQkFOR3x8ZT09PXAuRE9MTEFSfHxlPT09cC5BTVB8fGU9PT1wLlBBUkVOX0x8fGU9PT1wLlBBUkVOX1J8fGU9PT1wLlNQUkVBRHx8ZT09PXAuQ09MT058fGU9PT1wLkVRVUFMU3x8ZT09PXAuQVR8fGU9PT1wLkJSQUNLRVRfTHx8ZT09PXAuQlJBQ0tFVF9SfHxlPT09cC5CUkFDRV9MfHxlPT09cC5QSVBFfHxlPT09cC5CUkFDRV9SfWZ1bmN0aW9uIEooZSl7cmV0dXJuIGlzTmFOKGUpP3AuRU9GOmU8MTI3P0pTT04uc3RyaW5naWZ5KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpOiciXFx1Jy5jb25jYXQoKCIwMCIrZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTQpLCciJyl9ZnVuY3Rpb24gd24oZSx0KXtmb3IodmFyIG49ZS5zb3VyY2UsaT1uLmJvZHkscj1pLmxlbmd0aCxhPXQuZW5kO2E8cjspe3ZhciBvPWkuY2hhckNvZGVBdChhKSxsPWUubGluZSxzPTErYS1lLmxpbmVTdGFydDtzd2l0Y2gobyl7Y2FzZSA2NTI3OTpjYXNlIDk6Y2FzZSAzMjpjYXNlIDQ0OisrYTtjb250aW51ZTtjYXNlIDEwOisrYSwrK2UubGluZSxlLmxpbmVTdGFydD1hO2NvbnRpbnVlO2Nhc2UgMTM6aS5jaGFyQ29kZUF0KGErMSk9PT0xMD9hKz0yOisrYSwrK2UubGluZSxlLmxpbmVTdGFydD1hO2NvbnRpbnVlO2Nhc2UgMzM6cmV0dXJuIG5ldyBTKHAuQkFORyxhLGErMSxsLHMsdCk7Y2FzZSAzNTpyZXR1cm4gUm4obixhLGwscyx0KTtjYXNlIDM2OnJldHVybiBuZXcgUyhwLkRPTExBUixhLGErMSxsLHMsdCk7Y2FzZSAzODpyZXR1cm4gbmV3IFMocC5BTVAsYSxhKzEsbCxzLHQpO2Nhc2UgNDA6cmV0dXJuIG5ldyBTKHAuUEFSRU5fTCxhLGErMSxsLHMsdCk7Y2FzZSA0MTpyZXR1cm4gbmV3IFMocC5QQVJFTl9SLGEsYSsxLGwscyx0KTtjYXNlIDQ2OmlmKGkuY2hhckNvZGVBdChhKzEpPT09NDYmJmkuY2hhckNvZGVBdChhKzIpPT09NDYpcmV0dXJuIG5ldyBTKHAuU1BSRUFELGEsYSszLGwscyx0KTticmVhaztjYXNlIDU4OnJldHVybiBuZXcgUyhwLkNPTE9OLGEsYSsxLGwscyx0KTtjYXNlIDYxOnJldHVybiBuZXcgUyhwLkVRVUFMUyxhLGErMSxsLHMsdCk7Y2FzZSA2NDpyZXR1cm4gbmV3IFMocC5BVCxhLGErMSxsLHMsdCk7Y2FzZSA5MTpyZXR1cm4gbmV3IFMocC5CUkFDS0VUX0wsYSxhKzEsbCxzLHQpO2Nhc2UgOTM6cmV0dXJuIG5ldyBTKHAuQlJBQ0tFVF9SLGEsYSsxLGwscyx0KTtjYXNlIDEyMzpyZXR1cm4gbmV3IFMocC5CUkFDRV9MLGEsYSsxLGwscyx0KTtjYXNlIDEyNDpyZXR1cm4gbmV3IFMocC5QSVBFLGEsYSsxLGwscyx0KTtjYXNlIDEyNTpyZXR1cm4gbmV3IFMocC5CUkFDRV9SLGEsYSsxLGwscyx0KTtjYXNlIDM0OnJldHVybiBpLmNoYXJDb2RlQXQoYSsxKT09PTM0JiZpLmNoYXJDb2RlQXQoYSsyKT09PTM0P0JuKG4sYSxsLHMsdCxlKTpqbihuLGEsbCxzLHQpO2Nhc2UgNDU6Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpyZXR1cm4gUG4obixhLG8sbCxzLHQpO2Nhc2UgNjU6Y2FzZSA2NjpjYXNlIDY3OmNhc2UgNjg6Y2FzZSA2OTpjYXNlIDcwOmNhc2UgNzE6Y2FzZSA3MjpjYXNlIDczOmNhc2UgNzQ6Y2FzZSA3NTpjYXNlIDc2OmNhc2UgNzc6Y2FzZSA3ODpjYXNlIDc5OmNhc2UgODA6Y2FzZSA4MTpjYXNlIDgyOmNhc2UgODM6Y2FzZSA4NDpjYXNlIDg1OmNhc2UgODY6Y2FzZSA4NzpjYXNlIDg4OmNhc2UgODk6Y2FzZSA5MDpjYXNlIDk1OmNhc2UgOTc6Y2FzZSA5ODpjYXNlIDk5OmNhc2UgMTAwOmNhc2UgMTAxOmNhc2UgMTAyOmNhc2UgMTAzOmNhc2UgMTA0OmNhc2UgMTA1OmNhc2UgMTA2OmNhc2UgMTA3OmNhc2UgMTA4OmNhc2UgMTA5OmNhc2UgMTEwOmNhc2UgMTExOmNhc2UgMTEyOmNhc2UgMTEzOmNhc2UgMTE0OmNhc2UgMTE1OmNhc2UgMTE2OmNhc2UgMTE3OmNhc2UgMTE4OmNhc2UgMTE5OmNhc2UgMTIwOmNhc2UgMTIxOmNhc2UgMTIyOnJldHVybiBWbihuLGEsbCxzLHQpfXRocm93IF8obixhLEZuKG8pKX12YXIgYz1lLmxpbmUsZj0xK2EtZS5saW5lU3RhcnQ7cmV0dXJuIG5ldyBTKHAuRU9GLHIscixjLGYsdCl9ZnVuY3Rpb24gRm4oZSl7cmV0dXJuIGU8MzImJmUhPT05JiZlIT09MTAmJmUhPT0xMz8iQ2Fubm90IGNvbnRhaW4gdGhlIGludmFsaWQgY2hhcmFjdGVyICIuY29uY2F0KEooZSksIi4iKTplPT09Mzk/YFVuZXhwZWN0ZWQgc2luZ2xlIHF1b3RlIGNoYXJhY3RlciAoJyksIGRpZCB5b3UgbWVhbiB0byB1c2UgYSBkb3VibGUgcXVvdGUgKCIpP2A6IkNhbm5vdCBwYXJzZSB0aGUgdW5leHBlY3RlZCBjaGFyYWN0ZXIgIi5jb25jYXQoSihlKSwiLiIpfWZ1bmN0aW9uIFJuKGUsdCxuLGkscil7dmFyIGE9ZS5ib2R5LG8sbD10O2RvIG89YS5jaGFyQ29kZUF0KCsrbCk7d2hpbGUoIWlzTmFOKG8pJiYobz4zMXx8bz09PTkpKTtyZXR1cm4gbmV3IFMocC5DT01NRU5ULHQsbCxuLGkscixhLnNsaWNlKHQrMSxsKSl9ZnVuY3Rpb24gUG4oZSx0LG4saSxyLGEpe3ZhciBvPWUuYm9keSxsPW4scz10LGM9ITE7aWYobD09PTQ1JiYobD1vLmNoYXJDb2RlQXQoKytzKSksbD09PTQ4KXtpZihsPW8uY2hhckNvZGVBdCgrK3MpLGw+PTQ4JiZsPD01Nyl0aHJvdyBfKGUscywiSW52YWxpZCBudW1iZXIsIHVuZXhwZWN0ZWQgZGlnaXQgYWZ0ZXIgMDogIi5jb25jYXQoSihsKSwiLiIpKX1lbHNlIHM9QWUoZSxzLGwpLGw9by5jaGFyQ29kZUF0KHMpO2lmKGw9PT00NiYmKGM9ITAsbD1vLmNoYXJDb2RlQXQoKytzKSxzPUFlKGUscyxsKSxsPW8uY2hhckNvZGVBdChzKSksKGw9PT02OXx8bD09PTEwMSkmJihjPSEwLGw9by5jaGFyQ29kZUF0KCsrcyksKGw9PT00M3x8bD09PTQ1KSYmKGw9by5jaGFyQ29kZUF0KCsrcykpLHM9QWUoZSxzLGwpLGw9by5jaGFyQ29kZUF0KHMpKSxsPT09NDZ8fCRuKGwpKXRocm93IF8oZSxzLCJJbnZhbGlkIG51bWJlciwgZXhwZWN0ZWQgZGlnaXQgYnV0IGdvdDogIi5jb25jYXQoSihsKSwiLiIpKTtyZXR1cm4gbmV3IFMoYz9wLkZMT0FUOnAuSU5ULHQscyxpLHIsYSxvLnNsaWNlKHQscykpfWZ1bmN0aW9uIEFlKGUsdCxuKXt2YXIgaT1lLmJvZHkscj10LGE9bjtpZihhPj00OCYmYTw9NTcpe2RvIGE9aS5jaGFyQ29kZUF0KCsrcik7d2hpbGUoYT49NDgmJmE8PTU3KTtyZXR1cm4gcn10aHJvdyBfKGUsciwiSW52YWxpZCBudW1iZXIsIGV4cGVjdGVkIGRpZ2l0IGJ1dCBnb3Q6ICIuY29uY2F0KEooYSksIi4iKSl9ZnVuY3Rpb24gam4oZSx0LG4saSxyKXtmb3IodmFyIGE9ZS5ib2R5LG89dCsxLGw9byxzPTAsYz0iIjtvPGEubGVuZ3RoJiYhaXNOYU4ocz1hLmNoYXJDb2RlQXQobykpJiZzIT09MTAmJnMhPT0xMzspe2lmKHM9PT0zNClyZXR1cm4gYys9YS5zbGljZShsLG8pLG5ldyBTKHAuU1RSSU5HLHQsbysxLG4saSxyLGMpO2lmKHM8MzImJnMhPT05KXRocm93IF8oZSxvLCJJbnZhbGlkIGNoYXJhY3RlciB3aXRoaW4gU3RyaW5nOiAiLmNvbmNhdChKKHMpLCIuIikpO2lmKCsrbyxzPT09OTIpe3N3aXRjaChjKz1hLnNsaWNlKGwsby0xKSxzPWEuY2hhckNvZGVBdChvKSxzKXtjYXNlIDM0OmMrPSciJzticmVhaztjYXNlIDQ3OmMrPSIvIjticmVhaztjYXNlIDkyOmMrPSJcXCI7YnJlYWs7Y2FzZSA5ODpjKz0iXGIiO2JyZWFrO2Nhc2UgMTAyOmMrPSJcZiI7YnJlYWs7Y2FzZSAxMTA6Yys9YApgO2JyZWFrO2Nhc2UgMTE0OmMrPSJcciI7YnJlYWs7Y2FzZSAxMTY6Yys9IgkiO2JyZWFrO2Nhc2UgMTE3Ont2YXIgZj1NbihhLmNoYXJDb2RlQXQobysxKSxhLmNoYXJDb2RlQXQobysyKSxhLmNoYXJDb2RlQXQobyszKSxhLmNoYXJDb2RlQXQobys0KSk7aWYoZjwwKXt2YXIgZD1hLnNsaWNlKG8rMSxvKzUpO3Rocm93IF8oZSxvLCJJbnZhbGlkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2U6IFxcdSIuY29uY2F0KGQsIi4iKSl9Yys9U3RyaW5nLmZyb21DaGFyQ29kZShmKSxvKz00O2JyZWFrfWRlZmF1bHQ6dGhyb3cgXyhlLG8sIkludmFsaWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZTogXFwiLmNvbmNhdChTdHJpbmcuZnJvbUNoYXJDb2RlKHMpLCIuIikpfSsrbyxsPW99fXRocm93IF8oZSxvLCJVbnRlcm1pbmF0ZWQgc3RyaW5nLiIpfWZ1bmN0aW9uIEJuKGUsdCxuLGkscixhKXtmb3IodmFyIG89ZS5ib2R5LGw9dCszLHM9bCxjPTAsZj0iIjtsPG8ubGVuZ3RoJiYhaXNOYU4oYz1vLmNoYXJDb2RlQXQobCkpOyl7aWYoYz09PTM0JiZvLmNoYXJDb2RlQXQobCsxKT09PTM0JiZvLmNoYXJDb2RlQXQobCsyKT09PTM0KXJldHVybiBmKz1vLnNsaWNlKHMsbCksbmV3IFMocC5CTE9DS19TVFJJTkcsdCxsKzMsbixpLHIsa24oZikpO2lmKGM8MzImJmMhPT05JiZjIT09MTAmJmMhPT0xMyl0aHJvdyBfKGUsbCwiSW52YWxpZCBjaGFyYWN0ZXIgd2l0aGluIFN0cmluZzogIi5jb25jYXQoSihjKSwiLiIpKTtjPT09MTA/KCsrbCwrK2EubGluZSxhLmxpbmVTdGFydD1sKTpjPT09MTM/KG8uY2hhckNvZGVBdChsKzEpPT09MTA/bCs9MjorK2wsKythLmxpbmUsYS5saW5lU3RhcnQ9bCk6Yz09PTkyJiZvLmNoYXJDb2RlQXQobCsxKT09PTM0JiZvLmNoYXJDb2RlQXQobCsyKT09PTM0JiZvLmNoYXJDb2RlQXQobCszKT09PTM0PyhmKz1vLnNsaWNlKHMsbCkrJyIiIicsbCs9NCxzPWwpOisrbH10aHJvdyBfKGUsbCwiVW50ZXJtaW5hdGVkIHN0cmluZy4iKX1mdW5jdGlvbiBNbihlLHQsbixpKXtyZXR1cm4gZmUoZSk8PDEyfGZlKHQpPDw4fGZlKG4pPDw0fGZlKGkpfWZ1bmN0aW9uIGZlKGUpe3JldHVybiBlPj00OCYmZTw9NTc/ZS00ODplPj02NSYmZTw9NzA/ZS01NTplPj05NyYmZTw9MTAyP2UtODc6LTF9ZnVuY3Rpb24gVm4oZSx0LG4saSxyKXtmb3IodmFyIGE9ZS5ib2R5LG89YS5sZW5ndGgsbD10KzEscz0wO2whPT1vJiYhaXNOYU4ocz1hLmNoYXJDb2RlQXQobCkpJiYocz09PTk1fHxzPj00OCYmczw9NTd8fHM+PTY1JiZzPD05MHx8cz49OTcmJnM8PTEyMik7KSsrbDtyZXR1cm4gbmV3IFMocC5OQU1FLHQsbCxuLGkscixhLnNsaWNlKHQsbCkpfWZ1bmN0aW9uICRuKGUpe3JldHVybiBlPT09OTV8fGU+PTY1JiZlPD05MHx8ZT49OTcmJmU8PTEyMn1mdW5jdGlvbiBQKGUsdCl7dmFyIG49bmV3IFVuKGUsdCk7cmV0dXJuIG4ucGFyc2VEb2N1bWVudCgpfXZhciBVbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUobixpKXt2YXIgcj1BbihuKT9uOm5ldyBydChuKTt0aGlzLl9sZXhlcj1uZXcgTG4ociksdGhpcy5fb3B0aW9ucz1pfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LnBhcnNlTmFtZT1mdW5jdGlvbigpe3ZhciBuPXRoaXMuZXhwZWN0VG9rZW4ocC5OQU1FKTtyZXR1cm57a2luZDpULk5BTUUsdmFsdWU6bi52YWx1ZSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlRG9jdW1lbnQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjtyZXR1cm57a2luZDpULkRPQ1VNRU5ULGRlZmluaXRpb25zOnRoaXMubWFueShwLlNPRix0aGlzLnBhcnNlRGVmaW5pdGlvbixwLkVPRiksbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZURlZmluaXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLnBlZWsocC5OQU1FKSlzd2l0Y2godGhpcy5fbGV4ZXIudG9rZW4udmFsdWUpe2Nhc2UicXVlcnkiOmNhc2UibXV0YXRpb24iOmNhc2Uic3Vic2NyaXB0aW9uIjpyZXR1cm4gdGhpcy5wYXJzZU9wZXJhdGlvbkRlZmluaXRpb24oKTtjYXNlImZyYWdtZW50IjpyZXR1cm4gdGhpcy5wYXJzZUZyYWdtZW50RGVmaW5pdGlvbigpO2Nhc2Uic2NoZW1hIjpjYXNlInNjYWxhciI6Y2FzZSJ0eXBlIjpjYXNlImludGVyZmFjZSI6Y2FzZSJ1bmlvbiI6Y2FzZSJlbnVtIjpjYXNlImlucHV0IjpjYXNlImRpcmVjdGl2ZSI6cmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbigpO2Nhc2UiZXh0ZW5kIjpyZXR1cm4gdGhpcy5wYXJzZVR5cGVTeXN0ZW1FeHRlbnNpb24oKX1lbHNle2lmKHRoaXMucGVlayhwLkJSQUNFX0wpKXJldHVybiB0aGlzLnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbigpO2lmKHRoaXMucGVla0Rlc2NyaXB0aW9uKCkpcmV0dXJuIHRoaXMucGFyc2VUeXBlU3lzdGVtRGVmaW5pdGlvbigpfXRocm93IHRoaXMudW5leHBlY3RlZCgpfSx0LnBhcnNlT3BlcmF0aW9uRGVmaW5pdGlvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuO2lmKHRoaXMucGVlayhwLkJSQUNFX0wpKXJldHVybntraW5kOlQuT1BFUkFUSU9OX0RFRklOSVRJT04sb3BlcmF0aW9uOiJxdWVyeSIsbmFtZTp2b2lkIDAsdmFyaWFibGVEZWZpbml0aW9uczpbXSxkaXJlY3RpdmVzOltdLHNlbGVjdGlvblNldDp0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksbG9jOnRoaXMubG9jKG4pfTt2YXIgaT10aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpLHI7cmV0dXJuIHRoaXMucGVlayhwLk5BTUUpJiYocj10aGlzLnBhcnNlTmFtZSgpKSx7a2luZDpULk9QRVJBVElPTl9ERUZJTklUSU9OLG9wZXJhdGlvbjppLG5hbWU6cix2YXJpYWJsZURlZmluaXRpb25zOnRoaXMucGFyc2VWYXJpYWJsZURlZmluaXRpb25zKCksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlT3BlcmF0aW9uVHlwZT1mdW5jdGlvbigpe3ZhciBuPXRoaXMuZXhwZWN0VG9rZW4ocC5OQU1FKTtzd2l0Y2gobi52YWx1ZSl7Y2FzZSJxdWVyeSI6cmV0dXJuInF1ZXJ5IjtjYXNlIm11dGF0aW9uIjpyZXR1cm4ibXV0YXRpb24iO2Nhc2Uic3Vic2NyaXB0aW9uIjpyZXR1cm4ic3Vic2NyaXB0aW9uIn10aHJvdyB0aGlzLnVuZXhwZWN0ZWQobil9LHQucGFyc2VWYXJpYWJsZURlZmluaXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KHAuUEFSRU5fTCx0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9uLHAuUEFSRU5fUil9LHQucGFyc2VWYXJpYWJsZURlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjtyZXR1cm57a2luZDpULlZBUklBQkxFX0RFRklOSVRJT04sdmFyaWFibGU6dGhpcy5wYXJzZVZhcmlhYmxlKCksdHlwZToodGhpcy5leHBlY3RUb2tlbihwLkNPTE9OKSx0aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpKSxkZWZhdWx0VmFsdWU6dGhpcy5leHBlY3RPcHRpb25hbFRva2VuKHAuRVFVQUxTKT90aGlzLnBhcnNlVmFsdWVMaXRlcmFsKCEwKTp2b2lkIDAsZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMCksbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZVZhcmlhYmxlPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4ocC5ET0xMQVIpLHtraW5kOlQuVkFSSUFCTEUsbmFtZTp0aGlzLnBhcnNlTmFtZSgpLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VTZWxlY3Rpb25TZXQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjtyZXR1cm57a2luZDpULlNFTEVDVElPTl9TRVQsc2VsZWN0aW9uczp0aGlzLm1hbnkocC5CUkFDRV9MLHRoaXMucGFyc2VTZWxlY3Rpb24scC5CUkFDRV9SKSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlU2VsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGVlayhwLlNQUkVBRCk/dGhpcy5wYXJzZUZyYWdtZW50KCk6dGhpcy5wYXJzZUZpZWxkKCl9LHQucGFyc2VGaWVsZD1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKSxyLGE7cmV0dXJuIHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihwLkNPTE9OKT8ocj1pLGE9dGhpcy5wYXJzZU5hbWUoKSk6YT1pLHtraW5kOlQuRklFTEQsYWxpYXM6cixuYW1lOmEsYXJndW1lbnRzOnRoaXMucGFyc2VBcmd1bWVudHMoITEpLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZURpcmVjdGl2ZXMoITEpLHNlbGVjdGlvblNldDp0aGlzLnBlZWsocC5CUkFDRV9MKT90aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCk6dm9pZCAwLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VBcmd1bWVudHM9ZnVuY3Rpb24obil7dmFyIGk9bj90aGlzLnBhcnNlQ29uc3RBcmd1bWVudDp0aGlzLnBhcnNlQXJndW1lbnQ7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KHAuUEFSRU5fTCxpLHAuUEFSRU5fUil9LHQucGFyc2VBcmd1bWVudD1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihwLkNPTE9OKSx7a2luZDpULkFSR1VNRU5ULG5hbWU6aSx2YWx1ZTp0aGlzLnBhcnNlVmFsdWVMaXRlcmFsKCExKSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlQ29uc3RBcmd1bWVudD1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuO3JldHVybntraW5kOlQuQVJHVU1FTlQsbmFtZTp0aGlzLnBhcnNlTmFtZSgpLHZhbHVlOih0aGlzLmV4cGVjdFRva2VuKHAuQ09MT04pLHRoaXMucGFyc2VWYWx1ZUxpdGVyYWwoITApKSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlRnJhZ21lbnQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdFRva2VuKHAuU1BSRUFEKTt2YXIgaT10aGlzLmV4cGVjdE9wdGlvbmFsS2V5d29yZCgib24iKTtyZXR1cm4haSYmdGhpcy5wZWVrKHAuTkFNRSk/e2tpbmQ6VC5GUkFHTUVOVF9TUFJFQUQsbmFtZTp0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksbG9jOnRoaXMubG9jKG4pfTp7a2luZDpULklOTElORV9GUkFHTUVOVCx0eXBlQ29uZGl0aW9uOmk/dGhpcy5wYXJzZU5hbWVkVHlwZSgpOnZvaWQgMCxkaXJlY3RpdmVzOnRoaXMucGFyc2VEaXJlY3RpdmVzKCExKSxzZWxlY3Rpb25TZXQ6dGhpcy5wYXJzZVNlbGVjdGlvblNldCgpLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VGcmFnbWVudERlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbixpPXRoaXMuX2xleGVyLnRva2VuO3JldHVybiB0aGlzLmV4cGVjdEtleXdvcmQoImZyYWdtZW50IiksKChuPXRoaXMuX29wdGlvbnMpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5leHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyk9PT0hMD97a2luZDpULkZSQUdNRU5UX0RFRklOSVRJT04sbmFtZTp0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksdmFyaWFibGVEZWZpbml0aW9uczp0aGlzLnBhcnNlVmFyaWFibGVEZWZpbml0aW9ucygpLHR5cGVDb25kaXRpb246KHRoaXMuZXhwZWN0S2V5d29yZCgib24iKSx0aGlzLnBhcnNlTmFtZWRUeXBlKCkpLGRpcmVjdGl2ZXM6dGhpcy5wYXJzZURpcmVjdGl2ZXMoITEpLHNlbGVjdGlvblNldDp0aGlzLnBhcnNlU2VsZWN0aW9uU2V0KCksbG9jOnRoaXMubG9jKGkpfTp7a2luZDpULkZSQUdNRU5UX0RFRklOSVRJT04sbmFtZTp0aGlzLnBhcnNlRnJhZ21lbnROYW1lKCksdHlwZUNvbmRpdGlvbjoodGhpcy5leHBlY3RLZXl3b3JkKCJvbiIpLHRoaXMucGFyc2VOYW1lZFR5cGUoKSksZGlyZWN0aXZlczp0aGlzLnBhcnNlRGlyZWN0aXZlcyghMSksc2VsZWN0aW9uU2V0OnRoaXMucGFyc2VTZWxlY3Rpb25TZXQoKSxsb2M6dGhpcy5sb2MoaSl9fSx0LnBhcnNlRnJhZ21lbnROYW1lPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGV4ZXIudG9rZW4udmFsdWU9PT0ib24iKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiB0aGlzLnBhcnNlTmFtZSgpfSx0LnBhcnNlVmFsdWVMaXRlcmFsPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXMuX2xleGVyLnRva2VuO3N3aXRjaChpLmtpbmQpe2Nhc2UgcC5CUkFDS0VUX0w6cmV0dXJuIHRoaXMucGFyc2VMaXN0KG4pO2Nhc2UgcC5CUkFDRV9MOnJldHVybiB0aGlzLnBhcnNlT2JqZWN0KG4pO2Nhc2UgcC5JTlQ6cmV0dXJuIHRoaXMuX2xleGVyLmFkdmFuY2UoKSx7a2luZDpULklOVCx2YWx1ZTppLnZhbHVlLGxvYzp0aGlzLmxvYyhpKX07Y2FzZSBwLkZMT0FUOnJldHVybiB0aGlzLl9sZXhlci5hZHZhbmNlKCkse2tpbmQ6VC5GTE9BVCx2YWx1ZTppLnZhbHVlLGxvYzp0aGlzLmxvYyhpKX07Y2FzZSBwLlNUUklORzpjYXNlIHAuQkxPQ0tfU1RSSU5HOnJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCgpO2Nhc2UgcC5OQU1FOnN3aXRjaCh0aGlzLl9sZXhlci5hZHZhbmNlKCksaS52YWx1ZSl7Y2FzZSJ0cnVlIjpyZXR1cm57a2luZDpULkJPT0xFQU4sdmFsdWU6ITAsbG9jOnRoaXMubG9jKGkpfTtjYXNlImZhbHNlIjpyZXR1cm57a2luZDpULkJPT0xFQU4sdmFsdWU6ITEsbG9jOnRoaXMubG9jKGkpfTtjYXNlIm51bGwiOnJldHVybntraW5kOlQuTlVMTCxsb2M6dGhpcy5sb2MoaSl9O2RlZmF1bHQ6cmV0dXJue2tpbmQ6VC5FTlVNLHZhbHVlOmkudmFsdWUsbG9jOnRoaXMubG9jKGkpfX1jYXNlIHAuRE9MTEFSOmlmKCFuKXJldHVybiB0aGlzLnBhcnNlVmFyaWFibGUoKTticmVha310aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKX0sdC5wYXJzZVN0cmluZ0xpdGVyYWw9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjtyZXR1cm4gdGhpcy5fbGV4ZXIuYWR2YW5jZSgpLHtraW5kOlQuU1RSSU5HLHZhbHVlOm4udmFsdWUsYmxvY2s6bi5raW5kPT09cC5CTE9DS19TVFJJTkcsbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZUxpc3Q9ZnVuY3Rpb24obil7dmFyIGk9dGhpcyxyPXRoaXMuX2xleGVyLnRva2VuLGE9ZnVuY3Rpb24oKXtyZXR1cm4gaS5wYXJzZVZhbHVlTGl0ZXJhbChuKX07cmV0dXJue2tpbmQ6VC5MSVNULHZhbHVlczp0aGlzLmFueShwLkJSQUNLRVRfTCxhLHAuQlJBQ0tFVF9SKSxsb2M6dGhpcy5sb2Mocil9fSx0LnBhcnNlT2JqZWN0PWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXMscj10aGlzLl9sZXhlci50b2tlbixhPWZ1bmN0aW9uKCl7cmV0dXJuIGkucGFyc2VPYmplY3RGaWVsZChuKX07cmV0dXJue2tpbmQ6VC5PQkpFQ1QsZmllbGRzOnRoaXMuYW55KHAuQlJBQ0VfTCxhLHAuQlJBQ0VfUiksbG9jOnRoaXMubG9jKHIpfX0sdC5wYXJzZU9iamVjdEZpZWxkPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXMuX2xleGVyLnRva2VuLHI9dGhpcy5wYXJzZU5hbWUoKTtyZXR1cm4gdGhpcy5leHBlY3RUb2tlbihwLkNPTE9OKSx7a2luZDpULk9CSkVDVF9GSUVMRCxuYW1lOnIsdmFsdWU6dGhpcy5wYXJzZVZhbHVlTGl0ZXJhbChuKSxsb2M6dGhpcy5sb2MoaSl9fSx0LnBhcnNlRGlyZWN0aXZlcz1mdW5jdGlvbihuKXtmb3IodmFyIGk9W107dGhpcy5wZWVrKHAuQVQpOylpLnB1c2godGhpcy5wYXJzZURpcmVjdGl2ZShuKSk7cmV0dXJuIGl9LHQucGFyc2VEaXJlY3RpdmU9ZnVuY3Rpb24obil7dmFyIGk9dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIHRoaXMuZXhwZWN0VG9rZW4ocC5BVCkse2tpbmQ6VC5ESVJFQ1RJVkUsbmFtZTp0aGlzLnBhcnNlTmFtZSgpLGFyZ3VtZW50czp0aGlzLnBhcnNlQXJndW1lbnRzKG4pLGxvYzp0aGlzLmxvYyhpKX19LHQucGFyc2VUeXBlUmVmZXJlbmNlPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saTtyZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKHAuQlJBQ0tFVF9MKT8oaT10aGlzLnBhcnNlVHlwZVJlZmVyZW5jZSgpLHRoaXMuZXhwZWN0VG9rZW4ocC5CUkFDS0VUX1IpLGk9e2tpbmQ6VC5MSVNUX1RZUEUsdHlwZTppLGxvYzp0aGlzLmxvYyhuKX0pOmk9dGhpcy5wYXJzZU5hbWVkVHlwZSgpLHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihwLkJBTkcpP3traW5kOlQuTk9OX05VTExfVFlQRSx0eXBlOmksbG9jOnRoaXMubG9jKG4pfTppfSx0LnBhcnNlTmFtZWRUeXBlPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJue2tpbmQ6VC5OQU1FRF9UWVBFLG5hbWU6dGhpcy5wYXJzZU5hbWUoKSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlVHlwZVN5c3RlbURlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLnBlZWtEZXNjcmlwdGlvbigpP3RoaXMuX2xleGVyLmxvb2thaGVhZCgpOnRoaXMuX2xleGVyLnRva2VuO2lmKG4ua2luZD09PXAuTkFNRSlzd2l0Y2gobi52YWx1ZSl7Y2FzZSJzY2hlbWEiOnJldHVybiB0aGlzLnBhcnNlU2NoZW1hRGVmaW5pdGlvbigpO2Nhc2Uic2NhbGFyIjpyZXR1cm4gdGhpcy5wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uKCk7Y2FzZSJ0eXBlIjpyZXR1cm4gdGhpcy5wYXJzZU9iamVjdFR5cGVEZWZpbml0aW9uKCk7Y2FzZSJpbnRlcmZhY2UiOnJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZURlZmluaXRpb24oKTtjYXNlInVuaW9uIjpyZXR1cm4gdGhpcy5wYXJzZVVuaW9uVHlwZURlZmluaXRpb24oKTtjYXNlImVudW0iOnJldHVybiB0aGlzLnBhcnNlRW51bVR5cGVEZWZpbml0aW9uKCk7Y2FzZSJpbnB1dCI6cmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uKCk7Y2FzZSJkaXJlY3RpdmUiOnJldHVybiB0aGlzLnBhcnNlRGlyZWN0aXZlRGVmaW5pdGlvbigpfXRocm93IHRoaXMudW5leHBlY3RlZChuKX0sdC5wZWVrRGVzY3JpcHRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wZWVrKHAuU1RSSU5HKXx8dGhpcy5wZWVrKHAuQkxPQ0tfU1RSSU5HKX0sdC5wYXJzZURlc2NyaXB0aW9uPWZ1bmN0aW9uKCl7aWYodGhpcy5wZWVrRGVzY3JpcHRpb24oKSlyZXR1cm4gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoKX0sdC5wYXJzZVNjaGVtYURlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgic2NoZW1hIik7dmFyIHI9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApLGE9dGhpcy5tYW55KHAuQlJBQ0VfTCx0aGlzLnBhcnNlT3BlcmF0aW9uVHlwZURlZmluaXRpb24scC5CUkFDRV9SKTtyZXR1cm57a2luZDpULlNDSEVNQV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksZGlyZWN0aXZlczpyLG9wZXJhdGlvblR5cGVzOmEsbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZU9wZXJhdGlvblR5cGVEZWZpbml0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlT3BlcmF0aW9uVHlwZSgpO3RoaXMuZXhwZWN0VG9rZW4ocC5DT0xPTik7dmFyIHI9dGhpcy5wYXJzZU5hbWVkVHlwZSgpO3JldHVybntraW5kOlQuT1BFUkFUSU9OX1RZUEVfREVGSU5JVElPTixvcGVyYXRpb246aSx0eXBlOnIsbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZVNjYWxhclR5cGVEZWZpbml0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInNjYWxhciIpO3ZhciByPXRoaXMucGFyc2VOYW1lKCksYT10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCk7cmV0dXJue2tpbmQ6VC5TQ0FMQVJfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGRpcmVjdGl2ZXM6YSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlT2JqZWN0VHlwZURlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpO3RoaXMuZXhwZWN0S2V5d29yZCgidHlwZSIpO3ZhciByPXRoaXMucGFyc2VOYW1lKCksYT10aGlzLnBhcnNlSW1wbGVtZW50c0ludGVyZmFjZXMoKSxvPXRoaXMucGFyc2VEaXJlY3RpdmVzKCEwKSxsPXRoaXMucGFyc2VGaWVsZHNEZWZpbml0aW9uKCk7cmV0dXJue2tpbmQ6VC5PQkpFQ1RfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGludGVyZmFjZXM6YSxkaXJlY3RpdmVzOm8sZmllbGRzOmwsbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzPWZ1bmN0aW9uKCl7dmFyIG47aWYoIXRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKCJpbXBsZW1lbnRzIikpcmV0dXJuW107aWYoKChuPXRoaXMuX29wdGlvbnMpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5hbGxvd0xlZ2FjeVNETEltcGxlbWVudHNJbnRlcmZhY2VzKT09PSEwKXt2YXIgaT1bXTt0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4ocC5BTVApO2RvIGkucHVzaCh0aGlzLnBhcnNlTmFtZWRUeXBlKCkpO3doaWxlKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihwLkFNUCl8fHRoaXMucGVlayhwLk5BTUUpKTtyZXR1cm4gaX1yZXR1cm4gdGhpcy5kZWxpbWl0ZWRNYW55KHAuQU1QLHRoaXMucGFyc2VOYW1lZFR5cGUpfSx0LnBhcnNlRmllbGRzRGVmaW5pdGlvbj1mdW5jdGlvbigpe3ZhciBuO3JldHVybigobj10aGlzLl9vcHRpb25zKT09PW51bGx8fG49PT12b2lkIDA/dm9pZCAwOm4uYWxsb3dMZWdhY3lTRExFbXB0eUZpZWxkcyk9PT0hMCYmdGhpcy5wZWVrKHAuQlJBQ0VfTCkmJnRoaXMuX2xleGVyLmxvb2thaGVhZCgpLmtpbmQ9PT1wLkJSQUNFX1I/KHRoaXMuX2xleGVyLmFkdmFuY2UoKSx0aGlzLl9sZXhlci5hZHZhbmNlKCksW10pOnRoaXMub3B0aW9uYWxNYW55KHAuQlJBQ0VfTCx0aGlzLnBhcnNlRmllbGREZWZpbml0aW9uLHAuQlJBQ0VfUil9LHQucGFyc2VGaWVsZERlZmluaXRpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpLHI9dGhpcy5wYXJzZU5hbWUoKSxhPXRoaXMucGFyc2VBcmd1bWVudERlZnMoKTt0aGlzLmV4cGVjdFRva2VuKHAuQ09MT04pO3ZhciBvPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCksbD10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCk7cmV0dXJue2tpbmQ6VC5GSUVMRF9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGFyZ3VtZW50czphLHR5cGU6byxkaXJlY3RpdmVzOmwsbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZUFyZ3VtZW50RGVmcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9wdGlvbmFsTWFueShwLlBBUkVOX0wsdGhpcy5wYXJzZUlucHV0VmFsdWVEZWYscC5QQVJFTl9SKX0sdC5wYXJzZUlucHV0VmFsdWVEZWY9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbixpPXRoaXMucGFyc2VEZXNjcmlwdGlvbigpLHI9dGhpcy5wYXJzZU5hbWUoKTt0aGlzLmV4cGVjdFRva2VuKHAuQ09MT04pO3ZhciBhPXRoaXMucGFyc2VUeXBlUmVmZXJlbmNlKCksbzt0aGlzLmV4cGVjdE9wdGlvbmFsVG9rZW4ocC5FUVVBTFMpJiYobz10aGlzLnBhcnNlVmFsdWVMaXRlcmFsKCEwKSk7dmFyIGw9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApO3JldHVybntraW5kOlQuSU5QVVRfVkFMVUVfREVGSU5JVElPTixkZXNjcmlwdGlvbjppLG5hbWU6cix0eXBlOmEsZGVmYXVsdFZhbHVlOm8sZGlyZWN0aXZlczpsLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJpbnRlcmZhY2UiKTt2YXIgcj10aGlzLnBhcnNlTmFtZSgpLGE9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCksbz10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCksbD10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO3JldHVybntraW5kOlQuSU5URVJGQUNFX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjppLG5hbWU6cixpbnRlcmZhY2VzOmEsZGlyZWN0aXZlczpvLGZpZWxkczpsLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VVbmlvblR5cGVEZWZpbml0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoInVuaW9uIik7dmFyIHI9dGhpcy5wYXJzZU5hbWUoKSxhPXRoaXMucGFyc2VEaXJlY3RpdmVzKCEwKSxvPXRoaXMucGFyc2VVbmlvbk1lbWJlclR5cGVzKCk7cmV0dXJue2tpbmQ6VC5VTklPTl9UWVBFX0RFRklOSVRJT04sZGVzY3JpcHRpb246aSxuYW1lOnIsZGlyZWN0aXZlczphLHR5cGVzOm8sbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZVVuaW9uTWVtYmVyVHlwZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKHAuRVFVQUxTKT90aGlzLmRlbGltaXRlZE1hbnkocC5QSVBFLHRoaXMucGFyc2VOYW1lZFR5cGUpOltdfSx0LnBhcnNlRW51bVR5cGVEZWZpbml0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImVudW0iKTt2YXIgcj10aGlzLnBhcnNlTmFtZSgpLGE9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApLG89dGhpcy5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uKCk7cmV0dXJue2tpbmQ6VC5FTlVNX1RZUEVfREVGSU5JVElPTixkZXNjcmlwdGlvbjppLG5hbWU6cixkaXJlY3RpdmVzOmEsdmFsdWVzOm8sbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZUVudW1WYWx1ZXNEZWZpbml0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KHAuQlJBQ0VfTCx0aGlzLnBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbixwLkJSQUNFX1IpfSx0LnBhcnNlRW51bVZhbHVlRGVmaW5pdGlvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZURlc2NyaXB0aW9uKCkscj10aGlzLnBhcnNlTmFtZSgpLGE9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApO3JldHVybntraW5kOlQuRU5VTV9WQUxVRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGRpcmVjdGl2ZXM6YSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuLGk9dGhpcy5wYXJzZURlc2NyaXB0aW9uKCk7dGhpcy5leHBlY3RLZXl3b3JkKCJpbnB1dCIpO3ZhciByPXRoaXMucGFyc2VOYW1lKCksYT10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCksbz10aGlzLnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uKCk7cmV0dXJue2tpbmQ6VC5JTlBVVF9PQkpFQ1RfVFlQRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGRpcmVjdGl2ZXM6YSxmaWVsZHM6byxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlSW5wdXRGaWVsZHNEZWZpbml0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0aW9uYWxNYW55KHAuQlJBQ0VfTCx0aGlzLnBhcnNlSW5wdXRWYWx1ZURlZixwLkJSQUNFX1IpfSx0LnBhcnNlVHlwZVN5c3RlbUV4dGVuc2lvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLmxvb2thaGVhZCgpO2lmKG4ua2luZD09PXAuTkFNRSlzd2l0Y2gobi52YWx1ZSl7Y2FzZSJzY2hlbWEiOnJldHVybiB0aGlzLnBhcnNlU2NoZW1hRXh0ZW5zaW9uKCk7Y2FzZSJzY2FsYXIiOnJldHVybiB0aGlzLnBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbigpO2Nhc2UidHlwZSI6cmV0dXJuIHRoaXMucGFyc2VPYmplY3RUeXBlRXh0ZW5zaW9uKCk7Y2FzZSJpbnRlcmZhY2UiOnJldHVybiB0aGlzLnBhcnNlSW50ZXJmYWNlVHlwZUV4dGVuc2lvbigpO2Nhc2UidW5pb24iOnJldHVybiB0aGlzLnBhcnNlVW5pb25UeXBlRXh0ZW5zaW9uKCk7Y2FzZSJlbnVtIjpyZXR1cm4gdGhpcy5wYXJzZUVudW1UeXBlRXh0ZW5zaW9uKCk7Y2FzZSJpbnB1dCI6cmV0dXJuIHRoaXMucGFyc2VJbnB1dE9iamVjdFR5cGVFeHRlbnNpb24oKX10aHJvdyB0aGlzLnVuZXhwZWN0ZWQobil9LHQucGFyc2VTY2hlbWFFeHRlbnNpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgic2NoZW1hIik7dmFyIGk9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApLHI9dGhpcy5vcHRpb25hbE1hbnkocC5CUkFDRV9MLHRoaXMucGFyc2VPcGVyYXRpb25UeXBlRGVmaW5pdGlvbixwLkJSQUNFX1IpO2lmKGkubGVuZ3RoPT09MCYmci5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybntraW5kOlQuU0NIRU1BX0VYVEVOU0lPTixkaXJlY3RpdmVzOmksb3BlcmF0aW9uVHlwZXM6cixsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlU2NhbGFyVHlwZUV4dGVuc2lvbj1mdW5jdGlvbigpe3ZhciBuPXRoaXMuX2xleGVyLnRva2VuO3RoaXMuZXhwZWN0S2V5d29yZCgiZXh0ZW5kIiksdGhpcy5leHBlY3RLZXl3b3JkKCJzY2FsYXIiKTt2YXIgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApO2lmKHIubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm57a2luZDpULlNDQUxBUl9UWVBFX0VYVEVOU0lPTixuYW1lOmksZGlyZWN0aXZlczpyLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VPYmplY3RUeXBlRXh0ZW5zaW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoInR5cGUiKTt2YXIgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZUltcGxlbWVudHNJbnRlcmZhY2VzKCksYT10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCksbz10aGlzLnBhcnNlRmllbGRzRGVmaW5pdGlvbigpO2lmKHIubGVuZ3RoPT09MCYmYS5sZW5ndGg9PT0wJiZvLmxlbmd0aD09PTApdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJue2tpbmQ6VC5PQkpFQ1RfVFlQRV9FWFRFTlNJT04sbmFtZTppLGludGVyZmFjZXM6cixkaXJlY3RpdmVzOmEsZmllbGRzOm8sbG9jOnRoaXMubG9jKG4pfX0sdC5wYXJzZUludGVyZmFjZVR5cGVFeHRlbnNpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgiaW50ZXJmYWNlIik7dmFyIGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VJbXBsZW1lbnRzSW50ZXJmYWNlcygpLGE9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApLG89dGhpcy5wYXJzZUZpZWxkc0RlZmluaXRpb24oKTtpZihyLmxlbmd0aD09PTAmJmEubGVuZ3RoPT09MCYmby5sZW5ndGg9PT0wKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybntraW5kOlQuSU5URVJGQUNFX1RZUEVfRVhURU5TSU9OLG5hbWU6aSxpbnRlcmZhY2VzOnIsZGlyZWN0aXZlczphLGZpZWxkczpvLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VVbmlvblR5cGVFeHRlbnNpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgidW5pb24iKTt2YXIgaT10aGlzLnBhcnNlTmFtZSgpLHI9dGhpcy5wYXJzZURpcmVjdGl2ZXMoITApLGE9dGhpcy5wYXJzZVVuaW9uTWVtYmVyVHlwZXMoKTtpZihyLmxlbmd0aD09PTAmJmEubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm57a2luZDpULlVOSU9OX1RZUEVfRVhURU5TSU9OLG5hbWU6aSxkaXJlY3RpdmVzOnIsdHlwZXM6YSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlRW51bVR5cGVFeHRlbnNpb249ZnVuY3Rpb24oKXt2YXIgbj10aGlzLl9sZXhlci50b2tlbjt0aGlzLmV4cGVjdEtleXdvcmQoImV4dGVuZCIpLHRoaXMuZXhwZWN0S2V5d29yZCgiZW51bSIpO3ZhciBpPXRoaXMucGFyc2VOYW1lKCkscj10aGlzLnBhcnNlRGlyZWN0aXZlcyghMCksYT10aGlzLnBhcnNlRW51bVZhbHVlc0RlZmluaXRpb24oKTtpZihyLmxlbmd0aD09PTAmJmEubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm57a2luZDpULkVOVU1fVFlQRV9FWFRFTlNJT04sbmFtZTppLGRpcmVjdGl2ZXM6cix2YWx1ZXM6YSxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW47dGhpcy5leHBlY3RLZXl3b3JkKCJleHRlbmQiKSx0aGlzLmV4cGVjdEtleXdvcmQoImlucHV0Iik7dmFyIGk9dGhpcy5wYXJzZU5hbWUoKSxyPXRoaXMucGFyc2VEaXJlY3RpdmVzKCEwKSxhPXRoaXMucGFyc2VJbnB1dEZpZWxkc0RlZmluaXRpb24oKTtpZihyLmxlbmd0aD09PTAmJmEubGVuZ3RoPT09MCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm57a2luZDpULklOUFVUX09CSkVDVF9UWVBFX0VYVEVOU0lPTixuYW1lOmksZGlyZWN0aXZlczpyLGZpZWxkczphLGxvYzp0aGlzLmxvYyhuKX19LHQucGFyc2VEaXJlY3RpdmVEZWZpbml0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlRGVzY3JpcHRpb24oKTt0aGlzLmV4cGVjdEtleXdvcmQoImRpcmVjdGl2ZSIpLHRoaXMuZXhwZWN0VG9rZW4ocC5BVCk7dmFyIHI9dGhpcy5wYXJzZU5hbWUoKSxhPXRoaXMucGFyc2VBcmd1bWVudERlZnMoKSxvPXRoaXMuZXhwZWN0T3B0aW9uYWxLZXl3b3JkKCJyZXBlYXRhYmxlIik7dGhpcy5leHBlY3RLZXl3b3JkKCJvbiIpO3ZhciBsPXRoaXMucGFyc2VEaXJlY3RpdmVMb2NhdGlvbnMoKTtyZXR1cm57a2luZDpULkRJUkVDVElWRV9ERUZJTklUSU9OLGRlc2NyaXB0aW9uOmksbmFtZTpyLGFyZ3VtZW50czphLHJlcGVhdGFibGU6byxsb2NhdGlvbnM6bCxsb2M6dGhpcy5sb2Mobil9fSx0LnBhcnNlRGlyZWN0aXZlTG9jYXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsaW1pdGVkTWFueShwLlBJUEUsdGhpcy5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uKX0sdC5wYXJzZURpcmVjdGl2ZUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fbGV4ZXIudG9rZW4saT10aGlzLnBhcnNlTmFtZSgpO2lmKGJuW2kudmFsdWVdIT09dm9pZCAwKXJldHVybiBpO3Rocm93IHRoaXMudW5leHBlY3RlZChuKX0sdC5sb2M9ZnVuY3Rpb24obil7dmFyIGk7aWYoKChpPXRoaXMuX29wdGlvbnMpPT09bnVsbHx8aT09PXZvaWQgMD92b2lkIDA6aS5ub0xvY2F0aW9uKSE9PSEwKXJldHVybiBuZXcgWmUobix0aGlzLl9sZXhlci5sYXN0VG9rZW4sdGhpcy5fbGV4ZXIuc291cmNlKX0sdC5wZWVrPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLl9sZXhlci50b2tlbi5raW5kPT09bn0sdC5leHBlY3RUb2tlbj1mdW5jdGlvbihuKXt2YXIgaT10aGlzLl9sZXhlci50b2tlbjtpZihpLmtpbmQ9PT1uKXJldHVybiB0aGlzLl9sZXhlci5hZHZhbmNlKCksaTt0aHJvdyBfKHRoaXMuX2xleGVyLnNvdXJjZSxpLnN0YXJ0LCJFeHBlY3RlZCAiLmNvbmNhdChvdChuKSwiLCBmb3VuZCAiKS5jb25jYXQoYmUoaSksIi4iKSl9LHQuZXhwZWN0T3B0aW9uYWxUb2tlbj1mdW5jdGlvbihuKXt2YXIgaT10aGlzLl9sZXhlci50b2tlbjtpZihpLmtpbmQ9PT1uKXJldHVybiB0aGlzLl9sZXhlci5hZHZhbmNlKCksaX0sdC5leHBlY3RLZXl3b3JkPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXMuX2xleGVyLnRva2VuO2lmKGkua2luZD09PXAuTkFNRSYmaS52YWx1ZT09PW4pdGhpcy5fbGV4ZXIuYWR2YW5jZSgpO2Vsc2UgdGhyb3cgXyh0aGlzLl9sZXhlci5zb3VyY2UsaS5zdGFydCwnRXhwZWN0ZWQgIicuY29uY2F0KG4sJyIsIGZvdW5kICcpLmNvbmNhdChiZShpKSwiLiIpKX0sdC5leHBlY3RPcHRpb25hbEtleXdvcmQ9ZnVuY3Rpb24obil7dmFyIGk9dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIGkua2luZD09PXAuTkFNRSYmaS52YWx1ZT09PW4/KHRoaXMuX2xleGVyLmFkdmFuY2UoKSwhMCk6ITF9LHQudW5leHBlY3RlZD1mdW5jdGlvbihuKXt2YXIgaT1uIT1udWxsP246dGhpcy5fbGV4ZXIudG9rZW47cmV0dXJuIF8odGhpcy5fbGV4ZXIuc291cmNlLGkuc3RhcnQsIlVuZXhwZWN0ZWQgIi5jb25jYXQoYmUoaSksIi4iKSl9LHQuYW55PWZ1bmN0aW9uKG4saSxyKXt0aGlzLmV4cGVjdFRva2VuKG4pO2Zvcih2YXIgYT1bXTshdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKHIpOylhLnB1c2goaS5jYWxsKHRoaXMpKTtyZXR1cm4gYX0sdC5vcHRpb25hbE1hbnk9ZnVuY3Rpb24obixpLHIpe2lmKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihuKSl7dmFyIGE9W107ZG8gYS5wdXNoKGkuY2FsbCh0aGlzKSk7d2hpbGUoIXRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihyKSk7cmV0dXJuIGF9cmV0dXJuW119LHQubWFueT1mdW5jdGlvbihuLGkscil7dGhpcy5leHBlY3RUb2tlbihuKTt2YXIgYT1bXTtkbyBhLnB1c2goaS5jYWxsKHRoaXMpKTt3aGlsZSghdGhpcy5leHBlY3RPcHRpb25hbFRva2VuKHIpKTtyZXR1cm4gYX0sdC5kZWxpbWl0ZWRNYW55PWZ1bmN0aW9uKG4saSl7dGhpcy5leHBlY3RPcHRpb25hbFRva2VuKG4pO3ZhciByPVtdO2RvIHIucHVzaChpLmNhbGwodGhpcykpO3doaWxlKHRoaXMuZXhwZWN0T3B0aW9uYWxUb2tlbihuKSk7cmV0dXJuIHJ9LGV9KCk7ZnVuY3Rpb24gYmUoZSl7dmFyIHQ9ZS52YWx1ZTtyZXR1cm4gb3QoZS5raW5kKSsodCE9bnVsbD8nICInLmNvbmNhdCh0LCciJyk6IiIpfWZ1bmN0aW9uIG90KGUpe3JldHVybiBDbihlKT8nIicuY29uY2F0KGUsJyInKTplfXZhciBLbj17TmFtZTpbXSxEb2N1bWVudDpbImRlZmluaXRpb25zIl0sT3BlcmF0aW9uRGVmaW5pdGlvbjpbIm5hbWUiLCJ2YXJpYWJsZURlZmluaXRpb25zIiwiZGlyZWN0aXZlcyIsInNlbGVjdGlvblNldCJdLFZhcmlhYmxlRGVmaW5pdGlvbjpbInZhcmlhYmxlIiwidHlwZSIsImRlZmF1bHRWYWx1ZSIsImRpcmVjdGl2ZXMiXSxWYXJpYWJsZTpbIm5hbWUiXSxTZWxlY3Rpb25TZXQ6WyJzZWxlY3Rpb25zIl0sRmllbGQ6WyJhbGlhcyIsIm5hbWUiLCJhcmd1bWVudHMiLCJkaXJlY3RpdmVzIiwic2VsZWN0aW9uU2V0Il0sQXJndW1lbnQ6WyJuYW1lIiwidmFsdWUiXSxGcmFnbWVudFNwcmVhZDpbIm5hbWUiLCJkaXJlY3RpdmVzIl0sSW5saW5lRnJhZ21lbnQ6WyJ0eXBlQ29uZGl0aW9uIiwiZGlyZWN0aXZlcyIsInNlbGVjdGlvblNldCJdLEZyYWdtZW50RGVmaW5pdGlvbjpbIm5hbWUiLCJ2YXJpYWJsZURlZmluaXRpb25zIiwidHlwZUNvbmRpdGlvbiIsImRpcmVjdGl2ZXMiLCJzZWxlY3Rpb25TZXQiXSxJbnRWYWx1ZTpbXSxGbG9hdFZhbHVlOltdLFN0cmluZ1ZhbHVlOltdLEJvb2xlYW5WYWx1ZTpbXSxOdWxsVmFsdWU6W10sRW51bVZhbHVlOltdLExpc3RWYWx1ZTpbInZhbHVlcyJdLE9iamVjdFZhbHVlOlsiZmllbGRzIl0sT2JqZWN0RmllbGQ6WyJuYW1lIiwidmFsdWUiXSxEaXJlY3RpdmU6WyJuYW1lIiwiYXJndW1lbnRzIl0sTmFtZWRUeXBlOlsibmFtZSJdLExpc3RUeXBlOlsidHlwZSJdLE5vbk51bGxUeXBlOlsidHlwZSJdLFNjaGVtYURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsImRpcmVjdGl2ZXMiLCJvcGVyYXRpb25UeXBlcyJdLE9wZXJhdGlvblR5cGVEZWZpbml0aW9uOlsidHlwZSJdLFNjYWxhclR5cGVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiZGlyZWN0aXZlcyJdLE9iamVjdFR5cGVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiaW50ZXJmYWNlcyIsImRpcmVjdGl2ZXMiLCJmaWVsZHMiXSxGaWVsZERlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJhcmd1bWVudHMiLCJ0eXBlIiwiZGlyZWN0aXZlcyJdLElucHV0VmFsdWVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwidHlwZSIsImRlZmF1bHRWYWx1ZSIsImRpcmVjdGl2ZXMiXSxJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sVW5pb25UeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiLCJ0eXBlcyJdLEVudW1UeXBlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImRpcmVjdGl2ZXMiLCJ2YWx1ZXMiXSxFbnVtVmFsdWVEZWZpbml0aW9uOlsiZGVzY3JpcHRpb24iLCJuYW1lIiwiZGlyZWN0aXZlcyJdLElucHV0T2JqZWN0VHlwZURlZmluaXRpb246WyJkZXNjcmlwdGlvbiIsIm5hbWUiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sRGlyZWN0aXZlRGVmaW5pdGlvbjpbImRlc2NyaXB0aW9uIiwibmFtZSIsImFyZ3VtZW50cyIsImxvY2F0aW9ucyJdLFNjaGVtYUV4dGVuc2lvbjpbImRpcmVjdGl2ZXMiLCJvcGVyYXRpb25UeXBlcyJdLFNjYWxhclR5cGVFeHRlbnNpb246WyJuYW1lIiwiZGlyZWN0aXZlcyJdLE9iamVjdFR5cGVFeHRlbnNpb246WyJuYW1lIiwiaW50ZXJmYWNlcyIsImRpcmVjdGl2ZXMiLCJmaWVsZHMiXSxJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOlsibmFtZSIsImludGVyZmFjZXMiLCJkaXJlY3RpdmVzIiwiZmllbGRzIl0sVW5pb25UeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiLCJ0eXBlcyJdLEVudW1UeXBlRXh0ZW5zaW9uOlsibmFtZSIsImRpcmVjdGl2ZXMiLCJ2YWx1ZXMiXSxJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246WyJuYW1lIiwiZGlyZWN0aXZlcyIsImZpZWxkcyJdfSxMPU9iamVjdC5mcmVlemUoe30pO2Z1bmN0aW9uIEMoZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06S24saT12b2lkIDAscj1BcnJheS5pc0FycmF5KGUpLGE9W2VdLG89LTEsbD1bXSxzPXZvaWQgMCxjPXZvaWQgMCxmPXZvaWQgMCxkPVtdLHY9W10sbT1lO2Rve28rKzt2YXIgaD1vPT09YS5sZW5ndGgsTj1oJiZsLmxlbmd0aCE9PTA7aWYoaCl7aWYoYz12Lmxlbmd0aD09PTA/dm9pZCAwOmRbZC5sZW5ndGgtMV0scz1mLGY9di5wb3AoKSxOKXtpZihyKXM9cy5zbGljZSgpO2Vsc2V7Zm9yKHZhciBnPXt9LEE9MCx4PU9iamVjdC5rZXlzKHMpO0E8eC5sZW5ndGg7QSsrKXt2YXIgTz14W0FdO2dbT109c1tPXX1zPWd9Zm9yKHZhciBxPTAsaz0wO2s8bC5sZW5ndGg7aysrKXt2YXIgUT1sW2tdWzBdLCR0PWxba11bMV07ciYmKFEtPXEpLHImJiR0PT09bnVsbD8ocy5zcGxpY2UoUSwxKSxxKyspOnNbUV09JHR9fW89aS5pbmRleCxhPWkua2V5cyxsPWkuZWRpdHMscj1pLmluQXJyYXksaT1pLnByZXZ9ZWxzZXtpZihjPWY/cj9vOmFbb106dm9pZCAwLHM9Zj9mW2NdOm0scz09bnVsbCljb250aW51ZTtmJiZkLnB1c2goYyl9dmFyIFU9dm9pZCAwO2lmKCFBcnJheS5pc0FycmF5KHMpKXtpZighZXQocykpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIEFTVCBOb2RlOiAiLmNvbmNhdChudChzKSwiLiIpKTt2YXIgVXQ9Sm4odCxzLmtpbmQsaCk7aWYoVXQpe2lmKFU9VXQuY2FsbCh0LHMsYyxmLGQsdiksVT09PUwpYnJlYWs7aWYoVT09PSExKXtpZighaCl7ZC5wb3AoKTtjb250aW51ZX19ZWxzZSBpZihVIT09dm9pZCAwJiYobC5wdXNoKFtjLFVdKSwhaCkpaWYoZXQoVSkpcz1VO2Vsc2V7ZC5wb3AoKTtjb250aW51ZX19fWlmKFU9PT12b2lkIDAmJk4mJmwucHVzaChbYyxzXSksaClkLnBvcCgpO2Vsc2V7dmFyIFJlO2k9e2luQXJyYXk6cixpbmRleDpvLGtleXM6YSxlZGl0czpsLHByZXY6aX0scj1BcnJheS5pc0FycmF5KHMpLGE9cj9zOihSZT1uW3Mua2luZF0pIT09bnVsbCYmUmUhPT12b2lkIDA/UmU6W10sbz0tMSxsPVtdLGYmJnYucHVzaChmKSxmPXN9fXdoaWxlKGkhPT12b2lkIDApO3JldHVybiBsLmxlbmd0aCE9PTAmJihtPWxbbC5sZW5ndGgtMV1bMV0pLG19ZnVuY3Rpb24gSm4oZSx0LG4pe3ZhciBpPWVbdF07aWYoaSl7aWYoIW4mJnR5cGVvZiBpPT0iZnVuY3Rpb24iKXJldHVybiBpO3ZhciByPW4/aS5sZWF2ZTppLmVudGVyO2lmKHR5cGVvZiByPT0iZnVuY3Rpb24iKXJldHVybiByfWVsc2V7dmFyIGE9bj9lLmxlYXZlOmUuZW50ZXI7aWYoYSl7aWYodHlwZW9mIGE9PSJmdW5jdGlvbiIpcmV0dXJuIGE7dmFyIG89YVt0XTtpZih0eXBlb2Ygbz09ImZ1bmN0aW9uIilyZXR1cm4gb319fWZ1bmN0aW9uIFluKGUpe3JldHVybiBDKGUse2xlYXZlOnpufSl9dmFyIEduPTgwLHpuPXtOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiBlLnZhbHVlfSxWYXJpYWJsZTpmdW5jdGlvbihlKXtyZXR1cm4iJCIrZS5uYW1lfSxEb2N1bWVudDpmdW5jdGlvbihlKXtyZXR1cm4geShlLmRlZmluaXRpb25zLGAKCmApK2AKYH0sT3BlcmF0aW9uRGVmaW5pdGlvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm9wZXJhdGlvbixuPWUubmFtZSxpPUkoIigiLHkoZS52YXJpYWJsZURlZmluaXRpb25zLCIsICIpLCIpIikscj15KGUuZGlyZWN0aXZlcywiICIpLGE9ZS5zZWxlY3Rpb25TZXQ7cmV0dXJuIW4mJiFyJiYhaSYmdD09PSJxdWVyeSI/YTp5KFt0LHkoW24saV0pLHIsYV0sIiAiKX0sVmFyaWFibGVEZWZpbml0aW9uOmZ1bmN0aW9uKGUpe3ZhciB0PWUudmFyaWFibGUsbj1lLnR5cGUsaT1lLmRlZmF1bHRWYWx1ZSxyPWUuZGlyZWN0aXZlcztyZXR1cm4gdCsiOiAiK24rSSgiID0gIixpKStJKCIgIix5KHIsIiAiKSl9LFNlbGVjdGlvblNldDpmdW5jdGlvbihlKXt2YXIgdD1lLnNlbGVjdGlvbnM7cmV0dXJuIEYodCl9LEZpZWxkOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYWxpYXMsbj1lLm5hbWUsaT1lLmFyZ3VtZW50cyxyPWUuZGlyZWN0aXZlcyxhPWUuc2VsZWN0aW9uU2V0LG89SSgiIix0LCI6ICIpK24sbD1vK0koIigiLHkoaSwiLCAiKSwiKSIpO3JldHVybiBsLmxlbmd0aD5HbiYmKGw9bytJKGAoCmAscGUoeShpLGAKYCkpLGAKKWApKSx5KFtsLHkociwiICIpLGFdLCIgIil9LEFyZ3VtZW50OmZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUudmFsdWU7cmV0dXJuIHQrIjogIitufSxGcmFnbWVudFNwcmVhZDpmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWUsbj1lLmRpcmVjdGl2ZXM7cmV0dXJuIi4uLiIrdCtJKCIgIix5KG4sIiAiKSl9LElubGluZUZyYWdtZW50OmZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZUNvbmRpdGlvbixuPWUuZGlyZWN0aXZlcyxpPWUuc2VsZWN0aW9uU2V0O3JldHVybiB5KFsiLi4uIixJKCJvbiAiLHQpLHkobiwiICIpLGldLCIgIil9LEZyYWdtZW50RGVmaW5pdGlvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWUsbj1lLnR5cGVDb25kaXRpb24saT1lLnZhcmlhYmxlRGVmaW5pdGlvbnMscj1lLmRpcmVjdGl2ZXMsYT1lLnNlbGVjdGlvblNldDtyZXR1cm4iZnJhZ21lbnQgIi5jb25jYXQodCkuY29uY2F0KEkoIigiLHkoaSwiLCAiKSwiKSIpLCIgIikrIm9uICIuY29uY2F0KG4sIiAiKS5jb25jYXQoSSgiIix5KHIsIiAiKSwiICIpKSthfSxJbnRWYWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnZhbHVlO3JldHVybiB0fSxGbG9hdFZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWU7cmV0dXJuIHR9LFN0cmluZ1ZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS52YWx1ZSxpPWUuYmxvY2s7cmV0dXJuIGk/X24obix0PT09ImRlc2NyaXB0aW9uIj8iIjoiICAiKTpKU09OLnN0cmluZ2lmeShuKX0sQm9vbGVhblZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWU7cmV0dXJuIHQ/InRydWUiOiJmYWxzZSJ9LE51bGxWYWx1ZTpmdW5jdGlvbigpe3JldHVybiJudWxsIn0sRW51bVZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudmFsdWU7cmV0dXJuIHR9LExpc3RWYWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnZhbHVlcztyZXR1cm4iWyIreSh0LCIsICIpKyJdIn0sT2JqZWN0VmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5maWVsZHM7cmV0dXJuInsiK3kodCwiLCAiKSsifSJ9LE9iamVjdEZpZWxkOmZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUudmFsdWU7cmV0dXJuIHQrIjogIitufSxEaXJlY3RpdmU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5hcmd1bWVudHM7cmV0dXJuIkAiK3QrSSgiKCIseShuLCIsICIpLCIpIil9LE5hbWVkVHlwZTpmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWU7cmV0dXJuIHR9LExpc3RUeXBlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZTtyZXR1cm4iWyIrdCsiXSJ9LE5vbk51bGxUeXBlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudHlwZTtyZXR1cm4gdCsiISJ9LFNjaGVtYURlZmluaXRpb246dyhmdW5jdGlvbihlKXt2YXIgdD1lLmRpcmVjdGl2ZXMsbj1lLm9wZXJhdGlvblR5cGVzO3JldHVybiB5KFsic2NoZW1hIix5KHQsIiAiKSxGKG4pXSwiICIpfSksT3BlcmF0aW9uVHlwZURlZmluaXRpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vcGVyYXRpb24sbj1lLnR5cGU7cmV0dXJuIHQrIjogIitufSxTY2FsYXJUeXBlRGVmaW5pdGlvbjp3KGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuZGlyZWN0aXZlcztyZXR1cm4geShbInNjYWxhciIsdCx5KG4sIiAiKV0sIiAiKX0pLE9iamVjdFR5cGVEZWZpbml0aW9uOncoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5pbnRlcmZhY2VzLGk9ZS5kaXJlY3RpdmVzLHI9ZS5maWVsZHM7cmV0dXJuIHkoWyJ0eXBlIix0LEkoImltcGxlbWVudHMgIix5KG4sIiAmICIpKSx5KGksIiAiKSxGKHIpXSwiICIpfSksRmllbGREZWZpbml0aW9uOncoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5hcmd1bWVudHMsaT1lLnR5cGUscj1lLmRpcmVjdGl2ZXM7cmV0dXJuIHQrKHN0KG4pP0koYCgKYCxwZSh5KG4sYApgKSksYAopYCk6SSgiKCIseShuLCIsICIpLCIpIikpKyI6ICIraStJKCIgIix5KHIsIiAiKSl9KSxJbnB1dFZhbHVlRGVmaW5pdGlvbjp3KGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUudHlwZSxpPWUuZGVmYXVsdFZhbHVlLHI9ZS5kaXJlY3RpdmVzO3JldHVybiB5KFt0KyI6ICIrbixJKCI9ICIsaSkseShyLCIgIildLCIgIil9KSxJbnRlcmZhY2VUeXBlRGVmaW5pdGlvbjp3KGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuaW50ZXJmYWNlcyxpPWUuZGlyZWN0aXZlcyxyPWUuZmllbGRzO3JldHVybiB5KFsiaW50ZXJmYWNlIix0LEkoImltcGxlbWVudHMgIix5KG4sIiAmICIpKSx5KGksIiAiKSxGKHIpXSwiICIpfSksVW5pb25UeXBlRGVmaW5pdGlvbjp3KGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuZGlyZWN0aXZlcyxpPWUudHlwZXM7cmV0dXJuIHkoWyJ1bmlvbiIsdCx5KG4sIiAiKSxpJiZpLmxlbmd0aCE9PTA/Ij0gIit5KGksIiB8ICIpOiIiXSwiICIpfSksRW51bVR5cGVEZWZpbml0aW9uOncoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5kaXJlY3RpdmVzLGk9ZS52YWx1ZXM7cmV0dXJuIHkoWyJlbnVtIix0LHkobiwiICIpLEYoaSldLCIgIil9KSxFbnVtVmFsdWVEZWZpbml0aW9uOncoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5kaXJlY3RpdmVzO3JldHVybiB5KFt0LHkobiwiICIpXSwiICIpfSksSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvbjp3KGZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuZGlyZWN0aXZlcyxpPWUuZmllbGRzO3JldHVybiB5KFsiaW5wdXQiLHQseShuLCIgIiksRihpKV0sIiAiKX0pLERpcmVjdGl2ZURlZmluaXRpb246dyhmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWUsbj1lLmFyZ3VtZW50cyxpPWUucmVwZWF0YWJsZSxyPWUubG9jYXRpb25zO3JldHVybiJkaXJlY3RpdmUgQCIrdCsoc3Qobik/SShgKApgLHBlKHkobixgCmApKSxgCilgKTpJKCIoIix5KG4sIiwgIiksIikiKSkrKGk/IiByZXBlYXRhYmxlIjoiIikrIiBvbiAiK3kociwiIHwgIil9KSxTY2hlbWFFeHRlbnNpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5kaXJlY3RpdmVzLG49ZS5vcGVyYXRpb25UeXBlcztyZXR1cm4geShbImV4dGVuZCBzY2hlbWEiLHkodCwiICIpLEYobildLCIgIil9LFNjYWxhclR5cGVFeHRlbnNpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5kaXJlY3RpdmVzO3JldHVybiB5KFsiZXh0ZW5kIHNjYWxhciIsdCx5KG4sIiAiKV0sIiAiKX0sT2JqZWN0VHlwZUV4dGVuc2lvbjpmdW5jdGlvbihlKXt2YXIgdD1lLm5hbWUsbj1lLmludGVyZmFjZXMsaT1lLmRpcmVjdGl2ZXMscj1lLmZpZWxkcztyZXR1cm4geShbImV4dGVuZCB0eXBlIix0LEkoImltcGxlbWVudHMgIix5KG4sIiAmICIpKSx5KGksIiAiKSxGKHIpXSwiICIpfSxJbnRlcmZhY2VUeXBlRXh0ZW5zaW9uOmZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuaW50ZXJmYWNlcyxpPWUuZGlyZWN0aXZlcyxyPWUuZmllbGRzO3JldHVybiB5KFsiZXh0ZW5kIGludGVyZmFjZSIsdCxJKCJpbXBsZW1lbnRzICIseShuLCIgJiAiKSkseShpLCIgIiksRihyKV0sIiAiKX0sVW5pb25UeXBlRXh0ZW5zaW9uOmZ1bmN0aW9uKGUpe3ZhciB0PWUubmFtZSxuPWUuZGlyZWN0aXZlcyxpPWUudHlwZXM7cmV0dXJuIHkoWyJleHRlbmQgdW5pb24iLHQseShuLCIgIiksaSYmaS5sZW5ndGghPT0wPyI9ICIreShpLCIgfCAiKToiIl0sIiAiKX0sRW51bVR5cGVFeHRlbnNpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5kaXJlY3RpdmVzLGk9ZS52YWx1ZXM7cmV0dXJuIHkoWyJleHRlbmQgZW51bSIsdCx5KG4sIiAiKSxGKGkpXSwiICIpfSxJbnB1dE9iamVjdFR5cGVFeHRlbnNpb246ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5uYW1lLG49ZS5kaXJlY3RpdmVzLGk9ZS5maWVsZHM7cmV0dXJuIHkoWyJleHRlbmQgaW5wdXQiLHQseShuLCIgIiksRihpKV0sIiAiKX19O2Z1bmN0aW9uIHcoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB5KFt0LmRlc2NyaXB0aW9uLGUodCldLGAKYCl9fWZ1bmN0aW9uIHkoZSl7dmFyIHQsbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06IiI7cmV0dXJuKHQ9ZT09bnVsbD92b2lkIDA6ZS5maWx0ZXIoZnVuY3Rpb24oaSl7cmV0dXJuIGl9KS5qb2luKG4pKSE9PW51bGwmJnQhPT12b2lkIDA/dDoiIn1mdW5jdGlvbiBGKGUpe3JldHVybiBJKGB7CmAscGUoeShlLGAKYCkpLGAKfWApfWZ1bmN0aW9uIEkoZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06IiI7cmV0dXJuIHQhPW51bGwmJnQhPT0iIj9lK3QrbjoiIn1mdW5jdGlvbiBwZShlKXtyZXR1cm4gSSgiICAiLGUucmVwbGFjZSgvXG4vZyxgCiAgYCkpfWZ1bmN0aW9uIHFuKGUpe3JldHVybiBlLmluZGV4T2YoYApgKSE9PS0xfWZ1bmN0aW9uIHN0KGUpe3JldHVybiBlIT1udWxsJiZlLnNvbWUocW4pfXZhciBIPShlPT4oZVtlLkxJU1Q9MF09IkxJU1QiLGVbZS5ERVRBSUw9MV09IkRFVEFJTCIsZSkpKEh8fHt9KSxSPShlPT4oZVtlLkJFRk9SRT0wXT0iQkVGT1JFIixlW2UuQUZURVI9MV09IkFGVEVSIixlW2UuRklSU1Q9Ml09IkZJUlNUIixlW2UuTEFTVD0zXT0iTEFTVCIsZSkpKFJ8fHt9KSxZPShlPT4oZVtlLk9CSkVDVD0wXT0iT0JKRUNUIixlW2UuQVJSQVk9MV09IkFSUkFZIixlKSkoWXx8e30pO2NvbnN0IGx0PShlLHQsbixpLHIsYSk9Pnt0cnl7Y29uc3Qgbz1QKGUpO0Mobyx7RnJhZ21lbnREZWZpbml0aW9uKGwpe3ZhciBzLGM7aWYobC5uYW1lLnZhbHVlPT09dCl7bGV0IGY9bC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucztpZihuPVduKGYsbiksbi5sZW5ndGg9PT0wKXJldHVybiBMO2NvbnN0IGQ9WG4oZixpLHIpO2E9YS5maWx0ZXIoaD0+IWYuZmluZChOPT5OLmtpbmQ9PT0iRmllbGQiJiZOLm5hbWUudmFsdWU9PT1oKSk7Y29uc3Qgdj1rZShuLGEpLG09cj09PVIuQkVGT1JFfHxyPT09Ui5GSVJTVD8oKHM9ZC5sb2MpPT1udWxsP3ZvaWQgMDpzLnN0YXJ0KS0xOihjPWQubG9jKT09bnVsbD92b2lkIDA6Yy5lbmQ7cmV0dXJuIGU9ZS5zdWJzdHJpbmcoMCxtKStgCiAgJHt2fWArZS5zdWJzdHJpbmcobSxlLmxlbmd0aCksTH19fSl9Y2F0Y2gobyl7Y29uc29sZS5lcnJvcihvKX1yZXR1cm4gZX0sWG49KGUsdCxuKT0+e3N3aXRjaChuKXtjYXNlIFIuQUZURVI6Y2FzZSBSLkJFRk9SRTpjb25zdCBpPWUuZmlsdGVyKHI9Pntjb25zdCBhPXIubmFtZS52YWx1ZTtyZXR1cm4gYT09PSh0PT1udWxsP3ZvaWQgMDp0LnN1YnN0cmluZyh0Lmxlbmd0aC1hLmxlbmd0aCx0Lmxlbmd0aCkpfSk7cmV0dXJuIGkubGVuZ3RoIT09MD9pWzBdOmVbZS5sZW5ndGgtMV07Y2FzZSBSLkZJUlNUOnJldHVybiBlWzBdO2Nhc2UgUi5MQVNUOnJldHVybiBlW2UubGVuZ3RoLTFdfX0sa2U9KGUsdCk9PntsZXQgbj1bLi4udF07ZS5sZW5ndGgmJihuPVtlLnBvcCgpLC4uLm5dKTtjb25zdCBpPUhuKG4pO2U9ZS5yZXZlcnNlKCk7bGV0IHI9aTtyZXR1cm4gZS5mb3JFYWNoKChhLG8pPT57bz09PTA/cj1gJHthfSB7CiAgJHtEZShyKX0KfWA6cj1gJHthfSB7CiAgJHtEZShyKX0KfWB9KSxyfSxIbj1lPT57bGV0IHQ9IiI7cmV0dXJuIGUuZm9yRWFjaCgobixpKT0+e2k9PT0wP3Q9bjp0PWAke3R9CiAgJHtufWB9KSx0fSxEZT1lPT5lLnJlcGxhY2VBbGwoL1xuICAvZyxgCiAgICBgKS5yZXBsYWNlQWxsKC9cbn0vZyxgCiAgfWApLGN0PShlLHQpPT57Y29uc3Qgbj1NYXRoLmZsb29yKHQvMik7Zm9yKGxldCBpPTA7aTxuO2krKyllPURlKGUpO3JldHVybiBlPWAke0FycmF5KHQpLmZpbGwoIiAiKS5qb2luKCIiKX0ke2V9YCxlfSxRbj0oZSx0KT0+e2NvbnN0IG49UChlKTtsZXQgaT0hMTtyZXR1cm4gQyhuLHtGcmFnbWVudERlZmluaXRpb24ocil7aWYoci5uYW1lLnZhbHVlPT09dClyZXR1cm4gaT0hMCxMfX0pLGl9LFduPShlLHQpPT57Y29uc3Qgbj1lLm1hcChpPT57dmFyIHI7cmV0dXJuKHI9aT09bnVsbD92b2lkIDA6aS5uYW1lKT09bnVsbD92b2lkIDA6ci52YWx1ZX0pLmZpbHRlcihpPT5pKTtyZXR1cm4gdC5maWx0ZXIoaT0+IW4uaW5jbHVkZXMoaSkpfSxabj0oZSx0LG4saSk9Pntjb25zdCByPVAoZSksYT1kZShbdCwuLi5pXSksbz1gJHt0fV8ke259YDtyZXR1cm4gQyhyLHtGcmFnbWVudERlZmluaXRpb24obCl7dmFyIHMsYyxmO2lmKGwubmFtZS52YWx1ZT09PW8pe2xldCBkPVsuLi5pXSx2PWwuc2VsZWN0aW9uU2V0O2Zvcihjb25zdCBBIG9mIGkpe2NvbnN0IHg9di5zZWxlY3Rpb25zLmZpbmQoTz0+Ty5raW5kPT09IkZpZWxkIiYmTy5uYW1lLnZhbHVlPT09QSk7aWYoeCYmeC5zZWxlY3Rpb25TZXQpdj14LnNlbGVjdGlvblNldCxkLnNoaWZ0KCk7ZWxzZSBicmVha31pZihpLmxlbmd0aD09PWQubGVuZ3RoKXJldHVybiBlPSIiLEw7Y29uc3QgbT12LnNlbGVjdGlvbnNbdi5zZWxlY3Rpb25zLmxlbmd0aC0xXSxoPWtlKFsuLi5kLGAuLi4ke2F9YF0sW10pLHtsZWZ0U3BhY2VzOk59PXRlKGUsKHM9bS5sb2MpPT1udWxsP3ZvaWQgMDpzLnN0YXJ0KSxnPWN0KGgsTik7cmV0dXJuIGU9ZS5zdWJzdHJpbmcoMCwoYz1tLmxvYyk9PW51bGw/dm9pZCAwOmMuZW5kKStgCiR7Z31gK2Uuc3Vic3RyaW5nKChmPW0ubG9jKT09bnVsbD92b2lkIDA6Zi5lbmQsZS5sZW5ndGgpLEx9fX0pLGV9LGVpPShlLHQsbik9Pntjb25zdCBpPVAoZSk7bGV0IHI9W107cmV0dXJuIEMoaSx7RnJhZ21lbnREZWZpbml0aW9uKGEpe2lmKGEubmFtZS52YWx1ZT09PW4pe2xldCBvPWEuc2VsZWN0aW9uU2V0O3JldHVybiB0LmZvckVhY2gobD0+e2NvbnN0IHM9bz09bnVsbD92b2lkIDA6by5zZWxlY3Rpb25zLmZpbmQoYz0+Yy5raW5kPT09IkZpZWxkIiYmYy5uYW1lLnZhbHVlPT09bCk7bz1zPT1udWxsP3ZvaWQgMDpzLnNlbGVjdGlvblNldH0pLG89PW51bGx8fG8uc2VsZWN0aW9ucy5mb3JFYWNoKGw9PntsLmtpbmQ9PT0iRmllbGQiJiYhbC5zZWxlY3Rpb25TZXQmJihyPVsuLi5yLGwubmFtZS52YWx1ZV0pfSksTH19fSkscn0sdXQ9KGUsdCxuLGkpPT4obi5mb3JFYWNoKHI9Pntjb25zdCBhPVAoZSk7QyhhLHtGcmFnbWVudERlZmluaXRpb24obyl7dmFyIGwscyxjO2lmKG8ubmFtZS52YWx1ZT09PWkpe2xldCBmPW8uc2VsZWN0aW9uU2V0O3QuZm9yRWFjaCh2PT57Y29uc3QgbT1mPT1udWxsP3ZvaWQgMDpmLnNlbGVjdGlvbnMuZmluZChoPT5oLmtpbmQ9PT0iRmllbGQiJiZoLm5hbWUudmFsdWU9PT12KTtmPW09PW51bGw/dm9pZCAwOm0uc2VsZWN0aW9uU2V0fSk7Y29uc3QgZD1mPT1udWxsP3ZvaWQgMDpmLnNlbGVjdGlvbnMuZmluZCh2PT52LmtpbmQ9PT0iRmllbGQiJiZ2Lm5hbWUudmFsdWU9PT1yKTtpZihkKXtmdChkKS5mb3JFYWNoKGg9Pntjb25zdHtvcmlnaW5hbEZpbGVDb250ZW50Ok59PXB0KGUsaCk7ZT1OfSk7Y29uc3R7bGVmdFNwYWNlczp2LGxlZnROZXdMaW5lczptfT10ZShlLChsPWQubG9jKT09bnVsbD92b2lkIDA6bC5zdGFydCk7ZT1lLnN1YnN0cmluZygwLCgocz1kLmxvYyk9PW51bGw/dm9pZCAwOnMuc3RhcnQpLXYtbSkrZS5zdWJzdHJpbmcoKGM9ZC5sb2MpPT1udWxsP3ZvaWQgMDpjLmVuZCxlLmxlbmd0aCl9cmV0dXJuIEx9fX0pfSksZSksdGk9KGUsdCxuKT0+KHQuZm9yRWFjaChpPT57Y29uc3Qgcj1QKGUpO0Mocix7T3BlcmF0aW9uRGVmaW5pdGlvbihhKXt2YXIgbyxsLHMsYyxmO2lmKCgobz1hLm5hbWUpPT1udWxsP3ZvaWQgMDpvLnZhbHVlKT09PW4pe2NvbnN0IGQ9YS5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5maW5kKG09Pm0ua2luZD09PSJGaWVsZCImJm0ubmFtZS52YWx1ZT09PW4pLHY9KGw9ZD09bnVsbD92b2lkIDA6ZC5zZWxlY3Rpb25TZXQpPT1udWxsP3ZvaWQgMDpsLnNlbGVjdGlvbnMuZmluZChtPT5tLmtpbmQ9PT0iRmllbGQiJiZtLm5hbWUudmFsdWU9PT1pKTtpZih2KXtmdCh2KS5mb3JFYWNoKE49Pntjb25zdHtvcmlnaW5hbEZpbGVDb250ZW50Omd9PXB0KGUsTik7ZT1nfSk7Y29uc3R7bGVmdFNwYWNlczptLGxlZnROZXdMaW5lczpofT10ZShlLChzPXYubG9jKT09bnVsbD92b2lkIDA6cy5zdGFydCk7ZT1lLnN1YnN0cmluZygwLCgoYz12LmxvYyk9PW51bGw/dm9pZCAwOmMuc3RhcnQpLW0taCkrZS5zdWJzdHJpbmcoKGY9di5sb2MpPT1udWxsP3ZvaWQgMDpmLmVuZCxlLmxlbmd0aCl9cmV0dXJuIEx9fX0pfSksZSksZnQ9ZT0+e2xldCB0PVtdO3JldHVybiBDKGUse0ZyYWdtZW50U3ByZWFkKG4pe3Q9Wy4uLnQsbi5uYW1lLnZhbHVlXX19KSx0fTtmdW5jdGlvbiB0ZShlLHQpe2xldCBuPTAsaT0wO2Zvcig7ZS5jaGFyQXQodC0xKT09PSIgInx8ZS5jaGFyQXQodC0xKT09PWAKYDspZS5jaGFyQXQodC0xKT09PSIgIiYmbisrLGUuY2hhckF0KHQtMSk9PT1gCmAmJmkrKyx0LS07cmV0dXJue2xlZnRTcGFjZXM6bixsZWZ0TmV3TGluZXM6aX19ZnVuY3Rpb24gbmkoZSx0KXtsZXQgbj0wLGk9MDtmb3IoO2UuY2hhckF0KHQrMSk9PT0iICJ8fGUuY2hhckF0KHQrMSk9PT1gCmA7KWUuY2hhckF0KHQrMSk9PT0iICImJm4rKyxlLmNoYXJBdCh0KzEpPT09YApgJiZpKyssdCsrO3JldHVybntyaWdodFNwYWNlczpuLHJpZ2h0TmV3TGluZXM6aX19ZnVuY3Rpb24gcHQoZSx0KXtjb25zdCBuPVAoZSk7bGV0IGk9IiIscj0iIjtyZXR1cm4gQyhuLHtGcmFnbWVudERlZmluaXRpb24oYSl7dmFyIG8sbCxzLGMsZjtpZihhLm5hbWUudmFsdWU9PT10JiZhLmxvYyl7aT1lLnN1YnN0cigobz1hLmxvYyk9PW51bGw/dm9pZCAwOm8uc3RhcnQsKChsPWEubG9jKT09bnVsbD92b2lkIDA6bC5lbmQpLSgocz1hLmxvYyk9PW51bGw/dm9pZCAwOnMuc3RhcnQpKTtjb25zdHtsZWZ0U3BhY2VzOmQsbGVmdE5ld0xpbmVzOnZ9PXRlKGUsYS5sb2Muc3RhcnQpLHtyaWdodFNwYWNlczptLHJpZ2h0TmV3TGluZXM6aH09bmkoZSxhLmxvYy5lbmQpO3JldHVybiByPWUuc3Vic3RyKDAsKChjPWEubG9jKT09bnVsbD92b2lkIDA6Yy5zdGFydCktKGQrdikpK2Uuc3Vic3RyKCgoZj1hLmxvYyk9PW51bGw/dm9pZCAwOmYuZW5kKSsobStoKSxlLmxlbmd0aC0xKSxMfX19KSx7b3JpZ2luYWxGaWxlQ29udGVudDpyLHJlbW92ZWRGcmFnbWVudDppfX1jb25zdCBpaT0oZSx0LG4saSk9Pntjb25zdCByPVAoZSksYT1kZShbdCwuLi5pXSk7cmV0dXJuIEMocix7T3BlcmF0aW9uRGVmaW5pdGlvbihvKXt2YXIgbCxzLGMsZjtpZigoKGw9bz09bnVsbD92b2lkIDA6by5uYW1lKT09bnVsbD92b2lkIDA6bC52YWx1ZSk9PT10KXtsZXQgZD1bLi4uaV0sdj1vLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZpbmQoQT0+QS5raW5kPT09IkZpZWxkIiYmQS5uYW1lLnZhbHVlPT09dCkuc2VsZWN0aW9uU2V0O2kuZm9yRWFjaChBPT57Y29uc3QgeD12LnNlbGVjdGlvbnMuZmluZChPPT5PLmtpbmQ9PT0iRmllbGQiJiZPLm5hbWUudmFsdWU9PT1BKTt4JiYodj14LnNlbGVjdGlvblNldCxkLnNoaWZ0KCkpfSk7Y29uc3QgbT1rZShbLi4uZCxgLi4uJHthfWBdLFtdKSxoPXYuc2VsZWN0aW9uc1t2LnNlbGVjdGlvbnMubGVuZ3RoLTFdLHtsZWZ0U3BhY2VzOk59PXRlKGUsKHM9aC5sb2MpPT1udWxsP3ZvaWQgMDpzLnN0YXJ0KSxnPWN0KG0sTik7cmV0dXJuIGU9ZS5zdWJzdHJpbmcoMCwoYz1oLmxvYyk9PW51bGw/dm9pZCAwOmMuZW5kKStgCiR7Z31gK2Uuc3Vic3RyaW5nKChmPWgubG9jKT09bnVsbD92b2lkIDA6Zi5lbmQsZS5sZW5ndGgpLEx9fX0pLGV9LHJpPShlLHQsbixpKT0+e2NvbnN0IHI9W24ucG9wKCksLi4uaV0uam9pbihgCiAgYCk7cmV0dXJuYGZyYWdtZW50ICR7ZGUoW2UsLi4ubl0pfSBvbiAke3R9IHsKICAke3J9Cn1gfSxkZT1lPT5lLmpvaW4oIl8iKTtmdW5jdGlvbiBkdChlLHQsbil7bGV0IGk9W10scj1bXTtyZXR1cm4gZS5hcmdzLmZvckVhY2goYT0+e3ZhciBvO2NvbnN0e25ld1BhcmFtZXRlcjpsLG5ld1ZhcmlhYmxlOnN9PShvPWxpKGEsdCxuKSkhPW51bGw/bzp7bmV3UGFyYW1ldGVyOmAke2EubmFtZX06ICQke2EubmFtZX1gLG5ld1ZhcmlhYmxlOmAkJHthLm5hbWV9OiAke210KGEsbil9YH07aT1bLi4uaSxsXSxyPVsuLi5yLHNdfSkse3BhcmFtczppLmxlbmd0aD9gKCR7aS5qb2luKCIsICIpfSlgOiIiLHZhcmlhYmxlczpyLmxlbmd0aD9gKCR7ci5qb2luKCIsICIpfSlgOiIifX1mdW5jdGlvbiBtdChlLHQpe2NvbnN0IG49YWkoZSkucmV2ZXJzZSgpO2xldCBpPSIiO3JldHVybiBuLmZvckVhY2gocj0+e3ZhciBhLG87aWYoci5raW5kPT09Ik5PTl9OVUxMIiYmKGk9YCR7aX0hYCksci5raW5kPT09IkxJU1QiJiYoaT1gWyR7aX1dYCxlLm5hbWU9PT0ib3JkZXJfYnkiKSl7Y29uc3QgbD0oYT1uWzBdLm5hbWUpIT1udWxsP2E6IiIscz1tZSh0LGwpLGM9KG89cz09bnVsbD92b2lkIDA6cy5pbnB1dEZpZWxkcyk9PW51bGw/dm9pZCAwOm8uZmluZChmPT5mLm5hbWU9PT0idXBkYXRlZF9hdCIpO2MmJihpPWAke2l9ID0geyAke2MubmFtZX06IGRlc2MgfWApfXIubmFtZSYmKGk9YCR7ci5uYW1lfWApfSksaX1mdW5jdGlvbiBhaShlKXtsZXQgdD1bXSxuPWUudHlwZTtmb3IoO247KXQ9Wy4uLnQsbl0sbj1uLm9mVHlwZTtyZXR1cm4gdH1mdW5jdGlvbiBvaShlLHQpe3ZhciBuO2NvbnN0IGk9ZS5maW5kKG89Pm8ubmFtZT09PXQpLHI9KG49aT09bnVsbD92b2lkIDA6aS5maWVsZHMpPT1udWxsP3ZvaWQgMDpuLmZpbHRlcihvPT57dmFyIGw7cmV0dXJuIGoobykua2luZD09PSJTQ0FMQVIifHwoKGw9ZS5maW5kKHM9PnMubmFtZT09PW8udHlwZSkpPT1udWxsP3ZvaWQgMDpsLmtpbmQpPT09IlNDQUxBUiJ9KSxhPXI9PW51bGw/dm9pZCAwOnIubWFwKG89Pm8ubmFtZSk7cmV0dXJuIGE/YHJldHVybmluZyB7CiAgICAke2Euam9pbihgCiAgICBgKX0KICB9YDoiIn1mdW5jdGlvbiBzaShlKXtsZXQgdD1lLnR5cGU7Zm9yKDt0Lm9mVHlwZTspdD10Lm9mVHlwZTtyZXR1cm4gdC5uYW1lP3QubmFtZTp0fWZ1bmN0aW9uIGxpKGUsdCxuKXtjb25zdCBpPW10KGUsbik7aWYoZS5uYW1lPT09Il9zZXQiKXJldHVybntuZXdQYXJhbWV0ZXI6YCR7ZS5uYW1lfTogJCR7dCE9IiI/dDoiX3NldCJ9YCxuZXdWYXJpYWJsZTpgJCR7dCE9IiI/dDoiX3NldCJ9OiAke2l9YH07aWYoZS5uYW1lPT09Im9iamVjdCIpcmV0dXJue25ld1BhcmFtZXRlcjpgJHtlLm5hbWV9OiAkJHt0IT0iIj90OiJvYmplY3QifWAsbmV3VmFyaWFibGU6YCQke3QhPSIiP3Q6Im9iamVjdCJ9OiAke2l9YH07aWYoZS5uYW1lPT09Im9iamVjdHMiKXJldHVybntuZXdQYXJhbWV0ZXI6YCR7ZS5uYW1lfTogJCR7dCE9IiI/dDoib2JqZWN0cyJ9YCxuZXdWYXJpYWJsZTpgJCR7dCE9IiI/dDoib2JqZWN0cyJ9OiAke2l9YH19Y29uc3QgY2k9KGUsdCxuKT0+e3ZhciBpO2xldCByPVtdLGE9W10sbz1bXTtyZXR1cm4gdC5mb3JFYWNoKGw9PntsZXQgcz1bXSxjPVtdLGY9W10sZD1bXSx2PVtdLG09W10saD0iIjtsLmZpZWxkcy5mb3JFYWNoKGc9Pnt2YXIgQTtpZihnLm5hbWU9PT0icmV0dXJuaW5nIil7Y29uc3QgeD1zaShnKTtoPW9pKG4seCl9ZWxzZSBpZihnLm5hbWUhPSJjcmVhdGVkX2F0IiYmZy5uYW1lIT0idXBkYXRlZF9hdCIpe2NvbnN0IHg9ZGkoZyxlLnR5cGVzKTtpZigoeD09bnVsbD92b2lkIDA6eC5raW5kKT09PSJTQ0FMQVIiKXtjb25zdCBPPShBPXg9PW51bGw/dm9pZCAwOngubmFtZSk9PW51bGw/dm9pZCAwOkEudG9Mb2NhbGVMb3dlckNhc2UoKTtnLm5hbWU9PT0iaWQiP3M9Wy4uLnMsZy5uYW1lXTpnLm5hbWU9PT0iY3JlYXRlZF9hdCJ8fGcubmFtZT09PSJ1cGRhdGVkX2F0Ij9kPVsuLi5kLGcubmFtZV06Tz09PSJzdHJpbmciP2cubmFtZT09InRpdGxlInx8Zy5uYW1lPT0ibmFtZSI/Yz1bLi4uYyxnLm5hbWVdOmY9Wy4uLmYsZy5uYW1lXTpPIT1udWxsJiZPLmluY2x1ZGVzKCJkYXRlIik/dj1bLi4udixnLm5hbWVdOk8hPW51bGwmJk8uaW5jbHVkZXMoInRpbWUiKT92PVsuLi52LGcubmFtZV06bT1bLi4ubSxnLm5hbWVdfX19KSxhPVsuLi5zLC4uLmMsLi4uZiwuLi52XSxvLnB1c2goYSk7Y29uc3QgTj1gZnJhZ21lbnQgJHtsLnF1ZXJ5TmFtZX1fJHtsLmVudGl0eU5hbWV9IG9uICR7bC5lbnRpdHlOYW1lfSB7CiAgJHsoaD9bLi4uYSxoXTphKS5qb2luKGAKICBgKX0KfWA7cj1bLi4ucixOXX0pLHtmcmFnbWVudFN0cmluZzpyLmpvaW4oYAoKYCksZnJhZ21lbnRzOihpPW9bMF0pIT1udWxsP2k6W119fSxuZT1lPT57Y29uc3QgdD1lLnR5cGVzLG49ZS5xdWVyeVR5cGUsaT1lLm11dGF0aW9uVHlwZSxyPWUuc3Vic2NyaXB0aW9uVHlwZSxhPXQuZmlsdGVyKGM9PmMubmFtZT09PShuPT1udWxsP3ZvaWQgMDpuLm5hbWUpfHxjLm5hbWU9PT0oaT09bnVsbD92b2lkIDA6aS5uYW1lKXx8Yy5uYW1lPT09KHI9PW51bGw/dm9pZCAwOnIubmFtZSkpLm1hcChjPT57dmFyIGY7cmV0dXJue2ZpZWxkczooZj1jLmZpZWxkcykhPW51bGw/ZjpbXSxraW5kOmMua2luZCxuYW1lOmMubmFtZSx0eXBlOmMudHlwZSxhcmdzOmMuYXJnc319KSxvPWEuZmluZChjPT5jLm5hbWU9PT0obj09bnVsbD92b2lkIDA6bi5uYW1lKSksbD1hLmZpbmQoYz0+Yy5uYW1lPT09KGk9PW51bGw/dm9pZCAwOmkubmFtZSkpLHM9YS5maW5kKGM9PmMubmFtZT09PShyPT1udWxsP3ZvaWQgMDpyLm5hbWUpKTtyZXR1cm5bbyxsLHNdfTtmdW5jdGlvbiB1aShlLHQpe2NvbnN0IG49ZS50eXBlcyxbaSxyLGFdPW5lKGUpLG89ZmkoW2kscl0sbikse2ZyYWdtZW50U3RyaW5nOmwsZnJhZ21lbnRzOnN9PWNpKGUsbyxuKSxjPWk/bWkoaSx0LG4pOiIiLGY9cj9oaShyLHQsbik6IiI7cmV0dXJue3F1ZXJ5OnlpKFtjLGYsbF0pLGZyYWdtZW50RmllbGRzOnN9fWZ1bmN0aW9uIGZpKGUsdCxuKXtjb25zdCBpPWUubWFwKHI9Pnt2YXIgYTtsZXQgbz1bXTtpZihyIT1udWxsJiZyLm5hbWUpZm9yKGNvbnN0IGwgb2Ygci5maWVsZHMpe2NvbnN0IHM9bC5uYW1lLGM9KGE9aihsKS5uYW1lKSE9bnVsbD9hOiIiO2xldCBmPXBpKGMsdCk7aWYobiYmIWYuc29tZShkPT5qKGQpLmtpbmQ9PT1uKSl7ci5maWVsZHM9ci5maWVsZHMuZmlsdGVyKGQ9PmQhPT1sKTtjb250aW51ZX1vPVsuLi5vLHtxdWVyeU5hbWU6cyxlbnRpdHlOYW1lOmMsZmllbGRzOmZ9XX1yZXR1cm4gb30pO3JldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLGkpfWZ1bmN0aW9uIHBpKGUsdCl7Y29uc3Qgbj10LmZpbmQoaT0+aS5uYW1lPT09ZSk7cmV0dXJuIG4mJm4uZmllbGRzP24uZmllbGRzOltdfWZ1bmN0aW9uIGooZSl7dmFyIHQ7bGV0IG49KHQ9ZS50eXBlKSE9bnVsbD90OmUub2ZUeXBlO2Zvcig7bi5vZlR5cGU7KW49bi5vZlR5cGU7cmV0dXJuIG4ubmFtZT9uOntuYW1lOmUudHlwZSxraW5kOiIifX1mdW5jdGlvbiBtZShlLHQpe3JldHVybiBlLmZpbmQobj0+bi5uYW1lPT09dCl9ZnVuY3Rpb24gZGkoZSx0KXtjb25zdCBuPWooZSk7aWYobi5raW5kPT09IlNDQUxBUiIpcmV0dXJuIG47aWYobi5raW5kPT0iIil7Y29uc3QgaT1tZSh0LG4ubmFtZSk7aWYoKGk9PW51bGw/dm9pZCAwOmkua2luZCk9PT0iU0NBTEFSIilyZXR1cm4gaX19ZnVuY3Rpb24gbWkoZSx0LG4pe2xldCBpPVtdO3JldHVybiBlLmZpZWxkcy5mb3JFYWNoKHI9Pntjb25zdCBhPWAke3IubmFtZX1fJHtqKHIpLm5hbWV9YCx7cGFyYW1zOm8sdmFyaWFibGVzOmx9PWR0KHIsdCxuKSxzPWBxdWVyeSAke3IubmFtZX0ke2x9IHsKICAke3IubmFtZX0ke299IHsKICAgIC4uLiR7YX0KICB9Cn1gO2k9Wy4uLmksc119KSxpLmpvaW4oYAoKYCl9ZnVuY3Rpb24gaGkoZSx0LG4pe2xldCBpPVtdO3JldHVybiBlLmZpZWxkcy5mb3JFYWNoKHI9Pntjb25zdCBhPWAke3IubmFtZX1fJHtqKHIpLm5hbWV9YDtpPVsuLi5pLHZpKHIsYSx0LG4pXX0pLGkuam9pbihgCgpgKX1mdW5jdGlvbiB2aShlLHQsbixpKXtjb25zdHtwYXJhbXM6cix2YXJpYWJsZXM6YX09ZHQoZSxuLGkpO3JldHVybmBtdXRhdGlvbiAke2UubmFtZX0ke2F9IHsKICAke2UubmFtZX0ke3J9IHsKICAgIC4uLiR7dH0KICB9Cn1gfWZ1bmN0aW9uIHlpKGUpe3JldHVybiBlPWUuZmlsdGVyKHQ9PnQhPSIiKSxgJHtlLmpvaW4oYAoKYCl9YH1jb25zdCBFaT1lPT5lLmFyZ3Muc29tZSh0PT50Lm5hbWU9PT0iaWQiKTtmdW5jdGlvbiBUaShlLHQpe2NvbnN0IG49bmUoZSk7bGV0IGk9W107cmV0dXJuIHQubWFwKHI9Pnt2YXIgYSxvO2NvbnN0IGw9TmkobixlLnR5cGVzLHIsaSk7bC5mb3JFYWNoKG09Pm09PW51bGw/dm9pZCAwOm0uZmllbGRzLmZvckVhY2goaD0+aT1bLi4uaSxoLm5hbWVdKSk7Y29uc3Qgcz1naShsLGUpLGM9KG89KGE9bWUocy50eXBlcyxyKSk9PW51bGw/dm9pZCAwOmEuZmllbGRzKT09bnVsbD92b2lkIDA6by5maWx0ZXIobT0+e2NvbnN0IGg9aihtKTtpZihoLmtpbmQmJmgua2luZCE9IiImJmgua2luZD09PSJTQ0FMQVIiKXJldHVybiEwO2NvbnN0IE49bWUocy50eXBlcyxoLm5hbWUpO3JldHVybihOPT1udWxsP3ZvaWQgMDpOLmtpbmQpPT09IlNDQUxBUiJ9KSxmPWM9PW51bGw/dm9pZCAwOmMubWFwKG09Pih7bmFtZTptLm5hbWUsdHlwZTpqKG0pLm5hbWV9KSkse3F1ZXJ5OmQsZnJhZ21lbnRGaWVsZHM6dn09dWkocyxyKTtyZXR1cm57cXVlcmllczpkLGVudGl0eU5hbWU6cixwcm9wZXJ0aWVzOmYhPW51bGw/ZjpbXSxmcmFnbWVudHM6dn19KX1mdW5jdGlvbiBnaShlLHQpe2NvbnN0IG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0KSk7cmV0dXJuIGUuZm9yRWFjaChpPT57aWYoaSl7Y29uc3Qgcj1uLnR5cGVzLmZpbmQoYT0+YS5uYW1lPT09aS5uYW1lKTtyJiYoci5maWVsZHM9Wy4uLmkuZmllbGRzXSl9fSksbn1mdW5jdGlvbiBOaShlLHQsbixpKXtyZXR1cm4gZS5tYXAocj0+e2lmKHIpe2NvbnN0IGE9R3Qoe30scik7cmV0dXJuIGEuZmllbGRzPWEuZmllbGRzLmZpbHRlcihvPT54aShvLHQsbikmJiFpLmluY2x1ZGVzKG8ubmFtZSkpLGF9cmV0dXJuIHJ9KX1mdW5jdGlvbiB4aShlLHQsbil7cmV0dXJuISEoU2koZSxuKXx8SWkoZSx0LG4pKX1mdW5jdGlvbiBJaShlLHQsbil7dmFyIGk7Y29uc3Qgcj10eXBlb2YgZS50eXBlPT0ic3RyaW5nIj9lLnR5cGU6aihlKS5uYW1lLGE9dC5maW5kKGw9PmwubmFtZT09PXIpO2lmKCFhKXJldHVybiExO2NvbnN0IG89KGk9YS5maWVsZHMpPT1udWxsP3ZvaWQgMDppLmZpbmQobD0+bC5uYW1lPT09InJldHVybmluZyIpO3JldHVybiBvP2oobykubmFtZT09PW46ITF9ZnVuY3Rpb24gU2koZSx0KXt2YXIgbjtsZXQgaT1lLnR5cGU7aWYodHlwZW9mIGkhPSJzdHJpbmciKXtmb3IoO0QoaSkmJmkub2ZUeXBlOylpPWkub2ZUeXBlO2lmKEQoaSkmJigobj1pLm5hbWUpPT1udWxsP3ZvaWQgMDpuLnRvTG93ZXJDYXNlKCkpPT09KHQ9PW51bGw/dm9pZCAwOnQudG9Mb3dlckNhc2UoKSkpcmV0dXJuITB9ZWxzZSBpZih0eXBlb2YgaT09InN0cmluZyImJmk9PT0odD09bnVsbD92b2lkIDA6dC50b0xvd2VyQ2FzZSgpKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBfZShlLHQsbil7dmFyIGkscjtsZXQgYT1lLnR5cGU7aWYobj09PUguREVUQUlMJiZFaShlKSl7aWYodHlwZW9mIGEhPSJzdHJpbmciKXtmb3IoO0QoYSkmJmEub2ZUeXBlOylhPWEub2ZUeXBlO2lmKEQoYSkmJigoaT1hLm5hbWUpPT1udWxsP3ZvaWQgMDppLnRvTG93ZXJDYXNlKCkpPT09KHQ9PW51bGw/dm9pZCAwOnQudG9Mb3dlckNhc2UoKSkpcmV0dXJuITB9ZWxzZSBpZih0eXBlb2YgYT09InN0cmluZyImJmE9PT0odD09bnVsbD92b2lkIDA6dC50b0xvd2VyQ2FzZSgpKSlyZXR1cm4hMH1lbHNlIGlmKG49PT1ILkxJU1QmJihhPT1udWxsP3ZvaWQgMDphLmtpbmQpIT09Ik9CSkVDVCIpe2lmKHR5cGVvZiBhIT0ic3RyaW5nIil7Zm9yKDtEKGEpJiZhLm9mVHlwZTspYT1hLm9mVHlwZTtpZihEKGEpJiYoKHI9YS5uYW1lKT09bnVsbD92b2lkIDA6ci50b0xvd2VyQ2FzZSgpKT09PSh0PT1udWxsP3ZvaWQgMDp0LnRvTG93ZXJDYXNlKCkpKXJldHVybiEwfWVsc2UgaWYodHlwZW9mIGE9PSJzdHJpbmciJiZhPT09KHQ9PW51bGw/dm9pZCAwOnQudG9Mb3dlckNhc2UoKSkpcmV0dXJuITB9cmV0dXJuITF9Y29uc3QgT2k9KGUsdCk9PihlLmZvckVhY2goKG4saSk9Pnt0LmV2ZXJ5KHI9Pnt2YXIgYTtpZigoKGE9ci5uYW1lKT09bnVsbD92b2lkIDA6YS50b0xvd2VyQ2FzZSgpKT09PShuPT1udWxsP3ZvaWQgMDpuLnRvTG93ZXJDYXNlKCkpKXtsZXQgbz1yLnR5cGUsbD0hMTtmb3IoO0QobykmJm8ub2ZUeXBlOykobz09bnVsbD92b2lkIDA6by5raW5kKT09PSJMSVNUIiYmKGw9ITApLG89by5vZlR5cGU7aWYoRChvKSYmKG89PW51bGw/dm9pZCAwOm8ua2luZCk9PT0iT0JKRUNUIilyZXR1cm4gbHx8KGVbaV09by5uYW1lKSwhMX1yZXR1cm4hMH0pfSksZSksQWk9KGUsdCxuKT0+e2xldCBpPSIiO3JldHVybiBlLmZvckVhY2goKHIsYSk9PntpZihhPT09ZS5sZW5ndGgtMSlyZXR1cm4hMTt0LmV2ZXJ5KG89Pnt2YXIgbDtpZigoKGw9by5uYW1lKT09bnVsbD92b2lkIDA6bC50b0xvd2VyQ2FzZSgpKT09PShyPT1udWxsP3ZvaWQgMDpyLnRvTG93ZXJDYXNlKCkpKXtsZXQgcz1vLnR5cGU7Zm9yKDtEKHMpJiZzLm9mVHlwZTspcz1zLm9mVHlwZTtpZihEKHMpJiYocz09bnVsbD92b2lkIDA6cy5raW5kKT09PSJPQkpFQ1QiKXJldHVybiBpPXMubmFtZSwhMX1yZXR1cm4hMH0pfSksbi50eXBlcy5maW5kKHI9Pnt2YXIgYTtyZXR1cm4oKGE9cj09bnVsbD92b2lkIDA6ci5uYW1lKT09bnVsbD92b2lkIDA6YS50b0xvd2VyQ2FzZSgpKT09PShpPT1udWxsP3ZvaWQgMDppLnRvTG93ZXJDYXNlKCkpfSl9LGh0PShlLHQsbik9PntsZXQgaSxyPVkuT0JKRUNUO3JldHVybiBlLmZvckVhY2goYT0+e2xldCBvPSEwO3QuZXZlcnkobD0+e3ZhciBzO2lmKCgocz1sLm5hbWUpPT1udWxsP3ZvaWQgMDpzLnRvTG93ZXJDYXNlKCkpPT09KGE9PW51bGw/dm9pZCAwOmEudG9Mb3dlckNhc2UoKSkpe289ITE7bGV0IGM9bC50eXBlLGY9ITE7Zm9yKDtEKGMpJiZjLm9mVHlwZTspKGM9PW51bGw/dm9pZCAwOmMua2luZCk9PT0iTElTVCImJihmPSEwLHI9WS5BUlJBWSksYz1jLm9mVHlwZTtpZihEKGMpJiYoYz09bnVsbD92b2lkIDA6Yy5raW5kKT09PSJPQkpFQ1QiKXJldHVybiBmfHwocj1ZLk9CSkVDVCksaT1jLm5hbWUsITF9cmV0dXJuITB9KSxvJiZuLnR5cGVzLmZpbHRlcihsPT57dmFyIHM7cmV0dXJuKChzPWw9PW51bGw/dm9pZCAwOmwubmFtZSk9PW51bGw/dm9pZCAwOnMudG9Mb3dlckNhc2UoKSk9PT0oaT09bnVsbD92b2lkIDA6aS50b0xvd2VyQ2FzZSgpKX0pWzBdLmZpZWxkcy5ldmVyeShsPT57dmFyIHM7aWYoKChzPWwubmFtZSk9PW51bGw/dm9pZCAwOnMudG9Mb3dlckNhc2UoKSk9PT0oYT09bnVsbD92b2lkIDA6YS50b0xvd2VyQ2FzZSgpKSl7bGV0IGM9bC50eXBlLGY9ITE7Zm9yKDtEKGMpJiZjLm9mVHlwZTspYy5raW5kPT09IkxJU1QiJiYoZj0hMCxyPVkuQVJSQVkpLGM9Yy5vZlR5cGU7aWYoRChjKSYmKGM9PW51bGw/dm9pZCAwOmMua2luZCk9PT0iT0JKRUNUIilyZXR1cm4gZnx8KHI9WS5PQkpFQ1QpLGk9Yy5uYW1lLCExfXJldHVybiEwfSl9KSx7cmVsYXRpb25zaGlwTmFtZTppLHJlbGF0aW9uc2hpcFR5cGU6cn19O2Z1bmN0aW9uIEQoZSl7cmV0dXJuIm5hbWUiaW4gZSYmIm9mVHlwZSJpbiBlJiYia2luZCJpbiBlfWNvbnN0IGJpPWFzeW5jKGUsdCxuLGkscixhLG89Ui5CRUZPUkUpPT57Y29uc3RbbF09bmUodCkscz1sLmZpZWxkcy5maW5kKG09Pl9lKG0sbixyKSksYz1zPT1udWxsP3ZvaWQgMDpzLm5hbWUsZj1jIT1udWxsP2M6bjtsZXQgZD1lO2NvbnN0IHY9dC50eXBlcy5maW5kKG09Pm0ubmFtZS50b0xvd2VyQ2FzZSgpPT09bi50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gaS5mb3JFYWNoKG09PntsZXQgaD1tLnNwbGl0KCIuIikuc2xpY2UoMSk7aD1PaShoLHYuZmllbGRzKTtsZXR7cmVsYXRpb25zaGlwTmFtZTpOfT1odChoLHYuZmllbGRzLHQpO2NvbnN0IGc9QWkoaCx2LmZpZWxkcyx0KSxBPWhbaC5sZW5ndGgtMV0hPSJpZCImJihnPT1udWxsP3ZvaWQgMDpnLmZpZWxkcy5maW5kKGs9PmsubmFtZT09PSJpZCIpKT9bImlkIl06W10seD1oLnNsaWNlKDAsLTEpLE89dnQoW2YsLi4ueF0sZCkscT1baFtoLmxlbmd0aC0xXV07aWYoUW4oZCxPKSlkPWx0KGQsTyxxLGEsbyxBKTtlbHNle2QrPWAKCiR7cmkoZixOIT1udWxsP046ZixoLEEpfWA7Y29uc3Qgaz1abihkLGYsbix4KTtpZihrPT09IiIpZD1paShkLGYsbix4KTtlbHNle2NvbnN0IFE9ZWkoayx4LGAke2Z9XyR7bn1gKTtkPXV0KGsseCxRLGAke2Z9XyR7bn1gKSxkPWx0KGQsTyxbXSxhLG8sUSl9fX0pLGQ9WW4oUChkKSksZH0sa2k9YXN5bmMoZSx0LG4saSxyLGEpPT57dmFyIG87Y29uc3RbbF09bmUodCkscz1sLmZpZWxkcy5maW5kKGc9Pl9lKGcsbixyKSksYz0obz1zPT1udWxsP3ZvaWQgMDpzLm5hbWUpIT1udWxsP286bixmPXQudHlwZXMuZmluZChnPT5nLm5hbWUudG9Mb3dlckNhc2UoKT09PW4udG9Mb3dlckNhc2UoKSksZD1pLnNwbGl0KCIuIik7bGV0e3JlbGF0aW9uc2hpcE5hbWU6dixyZWxhdGlvbnNoaXBUeXBlOm19PWh0KGQsZi5maWVsZHMsdCk7Y29uc3QgaD12PT09dm9pZCAwP1tjXTptPT09WS5PQkpFQ1Q/W2Msdl06W2MsLi4uZC5zbGljZSgwLC0xKV0sTj12dChoLGUpO3JldHVybiBlPXRpKGUsW2RbZC5sZW5ndGgtMV1dLG4pLGU9dXQoZSxbXSxbZFtkLmxlbmd0aC0xXV0sTiksZX0sdnQ9KGUsdCk9PntpZihlLmxlbmd0aD09MSl0cnl7Y29uc3Qgbj1QKHQpLGk9ZVswXTtsZXQgcj0iIjtyZXR1cm4gQyhuLHtPcGVyYXRpb25EZWZpbml0aW9uKGEpe3ZhciBvLGw7KChvPWEubmFtZSk9PW51bGw/dm9pZCAwOm8udmFsdWUpPT09aSYmKHI9KChsPWEuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnNbMF0uc2VsZWN0aW9uU2V0KT09bnVsbD92b2lkIDA6bC5zZWxlY3Rpb25zWzBdKS5uYW1lLnZhbHVlKX19KSxyfWNhdGNoKG4pe2NvbnNvbGUuZXJyb3Iobil9cmV0dXJuIGRlKGUpfSx5dD0oZSx0LG4pPT5FLmZhY3RvcnkuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24odm9pZCAwLHZvaWQgMCxFLmZhY3RvcnkuY3JlYXRlSW1wb3J0Q2xhdXNlKCExLG4hPW51bGw/bjp2b2lkIDAsRS5mYWN0b3J5LmNyZWF0ZU5hbWVkSW1wb3J0cyhlKSksRS5mYWN0b3J5LmNyZWF0ZUlkZW50aWZpZXIodCkpLERpPShlLHQpPT5FLmZhY3RvcnkuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24odm9pZCAwLHZvaWQgMCxFLmZhY3RvcnkuY3JlYXRlSW1wb3J0Q2xhdXNlKCExLHZvaWQgMCxFLmZhY3RvcnkuY3JlYXRlTmFtZXNwYWNlSW1wb3J0KEUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKGUpKSksRS5mYWN0b3J5LmNyZWF0ZUlkZW50aWZpZXIodCkpLF9pPShlLHQpPT5FLmZhY3RvcnkuY3JlYXRlSW1wb3J0RGVjbGFyYXRpb24odm9pZCAwLHZvaWQgMCxFLmZhY3RvcnkuY3JlYXRlSW1wb3J0Q2xhdXNlKCExLEUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKGUpLHZvaWQgMCksRS5mYWN0b3J5LmNyZWF0ZUlkZW50aWZpZXIodCkpLExpPShlLHQpPT5FLmZhY3RvcnkuY3JlYXRlSnN4U2VsZkNsb3NpbmdFbGVtZW50KEUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKGUpLHZvaWQgMCxFLmZhY3RvcnkuY3JlYXRlSnN4QXR0cmlidXRlcyh0Lm1hcChuPT5FLmZhY3RvcnkuY3JlYXRlSnN4QXR0cmlidXRlKEUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKG4ubmFtZSksRS5mYWN0b3J5LmNyZWF0ZUpzeEV4cHJlc3Npb24odm9pZCAwLEUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKG4uaW5pdGlhbGl6ZXIpKSkpKSksRXQ9ZT0+ZS5yZXBsYWNlKC9bJyJdKy9nLCIiKSxCPShlLHQpPT50KGUpP2U6ZS5mb3JFYWNoQ2hpbGQobj0+QihuLHQpKSxUdD0oZSx0LG4pPT50KGUsbik/ZTplLmZvckVhY2hDaGlsZChpPT5UdChpLHQsbikpLE09KGUsdCk9Pntjb25zdCBuPVtdLGk9KHIsYSk9PihhKHIpJiZuLnB1c2gociksci5mb3JFYWNoQ2hpbGQobz0+aShvLGEpKSk7cmV0dXJuIGkoZSx0KSxufSxndD0oZSx0LG4pPT57Y29uc3QgaT1bXSxyPShhLG8sbCk9PihvKGEsbCkmJmkucHVzaChhKSxhLmZvckVhY2hDaGlsZChzPT5yKHMsbyxsKSkpO3JldHVybiByKGUsdCxuKSxpfSxDaT1lPT57Y29uc3QgdD1CKGUsbj0+dS5kZWZhdWx0LmlzSW1wb3J0RGVjbGFyYXRpb24obikmJm4ucG9zPjApO3JldHVybiB0IT09dm9pZCAwP3twb3M6dC5wb3MsZW5kOnQuZW5kfTp7cG9zOjAsZW5kOjB9fSxHPShlLHQ9dS5kZWZhdWx0LlNjcmlwdFRhcmdldC5FU05leHQsbj11LmRlZmF1bHQuU2NyaXB0S2luZC5UU1gsaT0iL3RzLWFzdC12aWV3ZXIudHN4Iik9Pntjb25zdCByPXUuZGVmYXVsdC5jcmVhdGVTb3VyY2VGaWxlKGksZSx0LCEwLG4pO3JldHVybiB3aShpLHIsdCkuZ2V0U291cmNlRmlsZShpKX0sd2k9KGUsdCxuKT0+e2NvbnN0IGk9e3N0cmljdDohMCx0YXJnZXQ6bixhbGxvd0pzOiEwLG1vZHVsZTp1LmRlZmF1bHQuTW9kdWxlS2luZC5FU05leHQsanN4OnUuZGVmYXVsdC5Kc3hFbWl0LlJlYWN0fSxyPXtbZV06dH0sYT17Z2V0U291cmNlRmlsZTpvPT5yW29dLGdldERlZmF1bHRMaWJGaWxlTmFtZTooKT0+Ii9saWIiLHdyaXRlRmlsZTooKT0+e30sZ2V0Q3VycmVudERpcmVjdG9yeTooKT0+Ii8iLGdldERpcmVjdG9yaWVzOigpPT5bXSxmaWxlRXhpc3RzOm89PnJbb10hPW51bGwscmVhZEZpbGU6bz0+cltvXSE9bnVsbD9yW29dLmdldEZ1bGxUZXh0KCk6dm9pZCAwLGdldENhbm9uaWNhbEZpbGVOYW1lOm89Pm8sdXNlQ2FzZVNlbnNpdGl2ZUZpbGVOYW1lczooKT0+ITAsZ2V0TmV3TGluZTooKT0+YApgLGdldEVudmlyb25tZW50VmFyaWFibGU6KCk9PiIifTtyZXR1cm4gdS5kZWZhdWx0LmNyZWF0ZVByb2dyYW0oWy4uLk9iamVjdC5rZXlzKHIpXSxpLGEpfSxGaT1lPT5lLnJlcGxhY2UoL1wvXCpcKiBUSElTX0lTX0FfTkVXTElORSBcKlwqXC8vZywiIiksTGU9YXN5bmMgZT0+e2NvbnN0IHQ9dS5kZWZhdWx0LmNyZWF0ZVByaW50ZXIoKS5wcmludEZpbGUoZSksbj1GaSh0KTtyZXR1cm4gYXdhaXQgUmkobil9LFJpPWFzeW5jKGUsdD0idHlwZXNjcmlwdCIpPT57Y29uc3Qgbj0oYXdhaXQgaW1wb3J0KCJodHRwczovL3VucGtnLmNvbS9wcmV0dGllci9lc20vc3RhbmRhbG9uZS5tanMiKSkuZGVmYXVsdCxpPShhd2FpdCBpbXBvcnQoImh0dHBzOi8vdW5wa2cuY29tL3ByZXR0aWVyL2VzbS9wYXJzZXItdHlwZXNjcmlwdC5tanMiKSkuZGVmYXVsdCxyPShhd2FpdCBpbXBvcnQoImh0dHBzOi8vdW5wa2cuY29tL3ByZXR0aWVyL2VzbS9wYXJzZXItZ3JhcGhxbC5tanMiKSkuZGVmYXVsdDtyZXR1cm4gbi5mb3JtYXQoZSx7cGFyc2VyOnQscGx1Z2luczpbaSxyXSxzZW1pOiExLHRhYldpZHRoOjIsc2luZ2xlUXVvdGU6ITB9KX0sUGk9KHtwb3M6ZSxlbmQ6dH0sbixpKT0+cj0+e2NvbnN0IGE9bz0+by5wb3M9PT1lJiZvLmVuZD09PXQ/aT09PSJiZWZvcmUiP0FycmF5LmlzQXJyYXkobik/Wy4uLm4sb106W24sb106QXJyYXkuaXNBcnJheShuKT9bbywuLi5uXTpbbyxuXTp1LmRlZmF1bHQudmlzaXRFYWNoQ2hpbGQobyxsPT5hKGwpLHIpO3JldHVybiBvPT51LmRlZmF1bHQudmlzaXROb2RlKG8sYSl9LGppPSh7cG9zOmUsZW5kOnR9LG4pPT5pPT57Y29uc3Qgcj1hPT5hLnBvcz09PWUmJmEuZW5kPT09dD9uOnUuZGVmYXVsdC52aXNpdEVhY2hDaGlsZChhLG89PnIobyksaSk7cmV0dXJuIGE9PnUuZGVmYXVsdC52aXNpdE5vZGUoYSxyKX0sQmk9KGUsdCk9Pm49Pntjb25zdCBpPXI9PmUocik/dDp1LmRlZmF1bHQudmlzaXRFYWNoQ2hpbGQocixhPT5pKGEpLG4pO3JldHVybiByPT51LmRlZmF1bHQudmlzaXROb2RlKHIsaSl9LE1pPShlLHQpPT5uPT57Y29uc3QgaT1yPT57aWYoIWUocix0KSlyZXR1cm4gdS5kZWZhdWx0LnZpc2l0RWFjaENoaWxkKHIsYT0+aShhKSxuKX07cmV0dXJuIHI9PnUuZGVmYXVsdC52aXNpdE5vZGUocixpKX0sVmk9KGUsdCxuKT0+aT0+e2NvbnN0IHI9YT0+ZShhLHQpP246dS5kZWZhdWx0LnZpc2l0RWFjaENoaWxkKGEsbz0+cihvKSxpKTtyZXR1cm4gYT0+dS5kZWZhdWx0LnZpc2l0Tm9kZShhLHIpfSwkaT0oe3BvczplLGVuZDp0fSk9Pm49Pntjb25zdCBpPXI9PntpZighKHIucG9zPT09ZSYmci5lbmQ9PT10KSlyZXR1cm4gdS5kZWZhdWx0LnZpc2l0RWFjaENoaWxkKHIsYT0+aShhKSxuKX07cmV0dXJuIHI9PnUuZGVmYXVsdC52aXNpdE5vZGUocixpKX0saGU9KGUsdCxuLGkpPT51LmRlZmF1bHQudHJhbnNmb3JtKGUsW1BpKHQsbixpKV0pLnRyYW5zZm9ybWVkWzBdLFVpPShlLHQpPT51LmRlZmF1bHQudHJhbnNmb3JtKGUsWyRpKHQpXSkudHJhbnNmb3JtZWRbMF0sVj0oZSx0LG4pPT51LmRlZmF1bHQudHJhbnNmb3JtKGUsW2ppKHQsbildKS50cmFuc2Zvcm1lZFswXSxOdD0oZSx0LG4pPT51LmRlZmF1bHQudHJhbnNmb3JtKGUsW0JpKHQsbildKS50cmFuc2Zvcm1lZFswXSxDZT0oZSx0LG4saSk9PnUuZGVmYXVsdC50cmFuc2Zvcm0oZSxbVmkodCxuLGkpXSkudHJhbnNmb3JtZWRbMF0sS2k9KGUsdCxuKT0+dS5kZWZhdWx0LnRyYW5zZm9ybShlLFtNaSh0LG4pXSkudHJhbnNmb3JtZWRbMF0sej1lPT57ZS5wb3M9LTEsZS5lbmQ9LTEsdS5kZWZhdWx0LmZvckVhY2hDaGlsZChlLHopfSwkPWFzeW5jIGU9Pntjb25zdCB0PWF3YWl0IExlKGUpO3JldHVybiBHKHQpfSxKaT0oZSx0KT0+e2NvbnN0IG49WWkoZSx0KTtpZihuKXtjb25zdCBpPUNpKGUpO3JldHVybiBoZShlLGksbil9ZWxzZSByZXR1cm4gZX0sWWk9KGUsdCk9Pntjb25zdCBuPWUuc3RhdGVtZW50cy5maWx0ZXIoYT0+dS5kZWZhdWx0LmlzSW1wb3J0RGVjbGFyYXRpb24oYSkpLGk9dC5zdGF0ZW1lbnRzLmZpbHRlcihhPT51LmRlZmF1bHQuaXNJbXBvcnREZWNsYXJhdGlvbihhKSkscj1HaShuKTtyZXR1cm4gemkoaSxyKX0seHQ9ZT0+e2NvbnN0IHQ9bmV3IFNldCx7aW1wb3J0Q2xhdXNlOm59PWU7cmV0dXJuIG4/KG4ubmFtZSYmdC5hZGQobi5uYW1lLmdldFRleHQoKSksbi5uYW1lZEJpbmRpbmdzJiZ1LmRlZmF1bHQuaXNOYW1lZEltcG9ydHMobi5uYW1lZEJpbmRpbmdzKSYmbi5uYW1lZEJpbmRpbmdzLmVsZW1lbnRzLmZvckVhY2goaT0+dC5hZGQoaS5uYW1lLmdldFRleHQoKSkpLG4ubmFtZWRCaW5kaW5ncyYmdS5kZWZhdWx0LmlzTmFtZXNwYWNlSW1wb3J0KG4ubmFtZWRCaW5kaW5ncykmJnQuYWRkKG4ubmFtZWRCaW5kaW5ncy5uYW1lLmdldFRleHQoKSksQXJyYXkuZnJvbSh0KSk6bnVsbH0sR2k9ZT0+e2NvbnN0IHQ9bmV3IE1hcDtyZXR1cm4gZS5mb3JFYWNoKG49Pntjb25zdCBpPUV0KG4ubW9kdWxlU3BlY2lmaWVyLmdldFRleHQoKSkscj14dChuKTtpZighcilyZXR1cm47Y29uc3QgYT10LmdldChpKTthP3Quc2V0KGksWy4uLmEsLi4ucl0pOnQuc2V0KGkscil9KSx0fSx6aT0oZSx0KT0+e2NvbnN0IG49W107cmV0dXJuIGUuZm9yRWFjaChpPT57dmFyIHI7Y29uc3QgYT1FdChpLm1vZHVsZVNwZWNpZmllci5nZXRUZXh0KCkpLHtpbXBvcnRDbGF1c2U6b309aTtpZighbylyZXR1cm47aWYoIXQuaGFzKGEpKXtuLnB1c2goaSk7cmV0dXJufWNvbnN0IGw9eHQoaSkscz10LmdldChhKTtpZighbHx8IXMpcmV0dXJuO2NvbnN0IGM9bC5maWx0ZXIoZD0+IXMuaW5jbHVkZXMoZCkpO2lmKGMubGVuZ3RoPT09MClyZXR1cm47aWYoYy5sZW5ndGg9PT0xJiYoKHI9by5uYW1lKT09bnVsbD92b2lkIDA6ci5nZXRUZXh0KCkpPT09Y1swXSl7Y29uc3QgZD1faShjWzBdLGkubW9kdWxlU3BlY2lmaWVyLmdldFRleHQoKSk7bi5wdXNoKGQpO3JldHVybn1pZihjLmxlbmd0aD09PTEmJm8ubmFtZWRCaW5kaW5ncyYmdS5kZWZhdWx0LmlzTmFtZXNwYWNlSW1wb3J0KG8ubmFtZWRCaW5kaW5ncykmJm8ubmFtZWRCaW5kaW5ncy5uYW1lLmdldFRleHQoKT09PWNbMF0pe2NvbnN0IGQ9RGkoY1swXSxpLm1vZHVsZVNwZWNpZmllci5nZXRUZXh0KCkpO24ucHVzaChkKTtyZXR1cm59Y29uc3QgZj1YaShpLGMpO2YmJm4ucHVzaChmKX0pLG4ubWFwKGk9Pnt6KGkpfSksbn0scWk9KGUsdCk9PntpZihlLm5hbWVkQmluZGluZ3MmJnUuZGVmYXVsdC5pc05hbWVkSW1wb3J0cyhlLm5hbWVkQmluZGluZ3MpKXtjb25zdCBuPWUubmFtZWRCaW5kaW5ncy5lbGVtZW50cy5maWx0ZXIoaT0+dC5pbmNsdWRlcyhpLm5hbWUuZ2V0VGV4dCgpKSk7cmV0dXJuIG4ubGVuZ3RoPjA/bjpudWxsfXJldHVybiBudWxsfSxYaT0oZSx0KT0+e3ZhciBuO2NvbnN0e2ltcG9ydENsYXVzZTppfT1lO2lmKCFpKXJldHVybiBudWxsO2NvbnN0IHI9cWkoaSx0KTtpZighcilyZXR1cm4gbnVsbDtjb25zdCBhPShuPWkubmFtZSk9PW51bGw/dm9pZCAwOm4uZ2V0VGV4dCgpLG89ZS5tb2R1bGVTcGVjaWZpZXIuZ2V0VGV4dCgpO3JldHVybiBhJiZ0LmluY2x1ZGVzKGEpP3l0KHIsbyxpLm5hbWUpOnl0KHIsbyl9LEl0PShlLHQpPT5LaShlLEhpLHQpLEhpPShlLHQpPT57dmFyIG4saTtyZXR1cm4gdS5kZWZhdWx0LmlzSW1wb3J0RGVjbGFyYXRpb24oZSkmJmUucGFyZW50JiZ1LmRlZmF1bHQuaXNTb3VyY2VGaWxlKGUucGFyZW50KSYmKChpPShuPWUuaW1wb3J0Q2xhdXNlKT09bnVsbD92b2lkIDA6bi5uYW1lKT09bnVsbD92b2lkIDA6aS5nZXRUZXh0KCkpPT09dH0sUWk9KGUsdCk9PnUuZGVmYXVsdC5pc0lkZW50aWZpZXIoZSkmJmUudGV4dD09PXQsV2k9KGUsdCk9PnUuZGVmYXVsdC5pc1N0cmluZ0xpdGVyYWxMaWtlKGUpJiZlLnRleHQ9PT10LHdlPShlLHQsbixpKT0+e2NvbnN0IHI9Wy4uLk0oZSx1LmRlZmF1bHQuaXNJZGVudGlmaWVyKSwuLi5NKGUsdS5kZWZhdWx0LmlzU3RyaW5nTGl0ZXJhbCldLnJlZHVjZSgocyxjKT0+KGMuZ2V0VGV4dCgpLmluZGV4T2YodCkhPT0tMSYmcy5wdXNoKGMuZ2V0VGV4dCgpLnJlcGxhY2VBbGwoLyJ8Jy9nLCIiKSkscyksW10pLGE9Wy4uLm5ldyBTZXQocildLG89YS5tYXAocz0+aT9zLnJlcGxhY2VBbGwoLyd8Ii9nLCIiKS5zcGxpdCgiLiIpOltzLnJlcGxhY2VBbGwoLyd8Ii9nLCIiKV0pLm1hcChzPT5zLm1hcChjPT5jPT09dD9uOmMpKS5tYXAocz0+aT9zLmpvaW4oIi4iKTpzLmpvaW4oIiIpKTtsZXQgbDtpZihvLmZvckVhY2goKHMsYyk9Pntjb25zdCBmPUUuZmFjdG9yeS5jcmVhdGVJZGVudGlmaWVyKHMpO3ooZiksbD1DZShlLFFpLGFbY10sZil9KSxvLmZvckVhY2goKHMsYyk9Pntjb25zdCBmPUUuZmFjdG9yeS5jcmVhdGVTdHJpbmdMaXRlcmFsKHMpO3ooZiksbD1DZShsLFdpLGFbY10sZil9KSwhIWwpcmV0dXJuIHoobCksbH0sWmk9KGUsdCk9Pntjb25zdCBuPW5yKGUsdCk7aWYoIW4pcmV0dXJuIG51bGw7Y29uc3QgaT1PdChlLG4pO2lmKCFpKXJldHVybiBudWxsO2lmKHUuZGVmYXVsdC5pc0pzeFNlbGZDbG9zaW5nRWxlbWVudChpLnBhcmVudCkpcmV0dXJuIGkucGFyZW50LnBvcztpZih1LmRlZmF1bHQuaXNKc3hPcGVuaW5nRWxlbWVudChpLnBhcmVudCkpcmV0dXJuIGkucGFyZW50LnBhcmVudC5wb3N9LGVyPShlLHQpPT57Y29uc3Qgbj1HKGUpLGk9U3QoZSx0KTtpZighaXx8IW4pcmV0dXJuIG51bGw7Y29uc3Qgcj11LmRlZmF1bHQuaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihpKT9pLmV4cHJlc3Npb246aTtyZXR1cm4gaGUobix7cG9zOnIucG9zLGVuZDpyLmVuZH0sW3JdKX0sdHI9KGUsdCxuLGkpPT57Y29uc3Qgcj1HKGUpLGE9U3QoZSx0KTtpZighYXx8IXIpcmV0dXJuIG51bGw7Y29uc3Qgbz13ZShhLG4saSwhMCk7cmV0dXJuIG8/aGUocix7cG9zOmEucG9zLGVuZDphLmVuZH0sW29dKTpudWxsfTtmdW5jdGlvbiBTdChlLHQpe2NvbnN0IG49WmkoZSx0KTtyZXR1cm4gbj9PdChlLG4pOm51bGx9ZnVuY3Rpb24gbnIoZSx0KXtpZih0eXBlb2YgZSE9InN0cmluZyIpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLnNwbGl0KGAKYCk7aWYodC5saW5lTnVtYmVyPjAmJnQubGluZU51bWJlcjxuLmxlbmd0aCl7Y29uc3QgaT10LmxpbmVOdW1iZXItMTtsZXQgcj0wO2ZvcihsZXQgYT0wO2E8aTsrK2Epcis9blthXS5sZW5ndGgrMTtyZXR1cm4gcis9dC5jb2x1bW5OdW1iZXItMSxyKz0xLHJ9cmV0dXJuIG51bGx9ZnVuY3Rpb24gT3QoZSx0KXtjb25zdCBuPUcoZSksaT1yPT57Y29uc3QgYT1yLnBvcztyZXR1cm4gYTw9dCYmdDw9ci5lbmQ/YT09PXQ/cjp1LmRlZmF1bHQuZm9yRWFjaENoaWxkKHIsaSk6bnVsbH07cmV0dXJuIG4/dS5kZWZhdWx0LmZvckVhY2hDaGlsZChuLGkpOm51bGx9Y29uc3QgQXQ9KGUsdCxuLGkpPT57Y29uc3Qgcj13ZSh0LG4saSwhMSk7cmV0dXJuIHImJihlPVYoZSx7cG9zOnQucG9zLGVuZDp0LmVuZH0scikpLGV9O3R5cGVvZiBUZXh0RGVjb2Rlcj09ImZ1bmN0aW9uIiYmbmV3IFRleHREZWNvZGVyLHR5cGVvZiBUZXh0RW5jb2Rlcj09ImZ1bmN0aW9uIiYmbmV3IFRleHRFbmNvZGVyO2NvbnN0IGlyPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSIscnI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaXIpOyhlPT57bGV0IHQ9e307cmV0dXJuIGUuZm9yRWFjaCgobixpKT0+dFtuXT1pKSx0fSkocnIpLFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpLHR5cGVvZiBVaW50OEFycmF5LmZyb209PSJmdW5jdGlvbiImJlVpbnQ4QXJyYXkuZnJvbS5iaW5kKFVpbnQ4QXJyYXkpO2NvbnN0IGJ0PShlLHQpPT5lLnN0YXJ0c1dpdGgodCk/ZS5zcGxpdCh0KVsxXTplLGt0PShlLHQpPT57aWYodD09PSIuIilyZXR1cm4gaWUoZSwiLi9pbmRleCIpO2lmKHQuc3RhcnRzV2l0aCgiLi8iKSlyZXR1cm4gaWUoZSx0KTtpZih0PT09Ii4uIil7Y29uc3QgYT1lLnN1YnN0cmluZygwLGUubGFzdEluZGV4T2YoIi8iKSk7cmV0dXJuIGllKGEsIi4vaW5kZXgiKX1jb25zdCBuPXQuc3BsaXQoIi8iKS5maWx0ZXIoYT0+YT09PSIuLiIpLGk9dC5zcGxpdCgiLyIpLmZpbHRlcihhPT5hIT09Ii4uIikuam9pbigiLyIpLHI9aWUoZSwiIikuc3BsaXQoIi8iKS5maWx0ZXIoQm9vbGVhbik7cmV0dXJuIG4uZm9yRWFjaCgoKT0+ci5wb3AoKSksaWUoIi8iK3Iuam9pbigiLyIpKyIvIixpKX0saWU9KGUsdCk9Pntjb25zdCBuPWUuZW5kc1dpdGgoIi8iKT9lOmUuc3Vic3RyaW5nKDAsZS5sYXN0SW5kZXhPZigiLyIpKSsiLyI7bGV0IGk9YnQodCwiLi8iKTtyZXR1cm4gaT1idChpLCIvIiksbitpfSxEdD0oZSx0KT0+e2NvbnN0IG49VHQoZSxzcix0KTtyZXR1cm4gbiE9bnVsbD9uOm51bGx9LGFyPWU9Pntjb25zdCB0PWUuYm9keTtyZXR1cm4hdHx8dS5kZWZhdWx0LmlzSnN4T3BlbmluZ0xpa2VFbGVtZW50KHQpfHx1LmRlZmF1bHQuaXNKc3hFbGVtZW50KHQpP251bGw6dS5kZWZhdWx0LmlzQmxvY2sodCk/dC5zdGF0ZW1lbnRzLmZpbHRlcihuPT4hdS5kZWZhdWx0LmlzUmV0dXJuU3RhdGVtZW50KG4pKTpudWxsfSxvcj1lPT57Y29uc3QgdD1lLmJvZHk7aWYoIXQpcmV0dXJuIG51bGw7aWYodS5kZWZhdWx0LmlzSnN4T3BlbmluZ0xpa2VFbGVtZW50KHQpfHx1LmRlZmF1bHQuaXNKc3hFbGVtZW50KHQpKXJldHVybiB0O2lmKHUuZGVmYXVsdC5pc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKHQpKXJldHVybiB0LmV4cHJlc3Npb247aWYodS5kZWZhdWx0LmlzQmxvY2sodCkpe2NvbnN0IG49dC5zdGF0ZW1lbnRzLmZpbHRlcihpPT51LmRlZmF1bHQuaXNSZXR1cm5TdGF0ZW1lbnQoaSkpO2lmKG4ubGVuZ3RoPT09MSl7Y29uc3QgaT1uWzBdLmV4cHJlc3Npb247cmV0dXJuIGk/dS5kZWZhdWx0LmlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24oaSk/aS5leHByZXNzaW9uOmk6bnVsbH19cmV0dXJuIG51bGx9LHNyPShlLHQpPT57dmFyIG47cmV0dXJuIHUuZGVmYXVsdC5pc0Fycm93RnVuY3Rpb24oZSkmJmUucGFyZW50JiZ1LmRlZmF1bHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGUucGFyZW50KSYmZS5wYXJlbnQubmFtZS5nZXRUZXh0KCk9PT10JiZlLnBhcmVudC5wYXJlbnQmJnUuZGVmYXVsdC5pc1ZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KGUucGFyZW50LnBhcmVudCkmJmUucGFyZW50LnBhcmVudC5wYXJlbnQmJnUuZGVmYXVsdC5pc1ZhcmlhYmxlU3RhdGVtZW50KGUucGFyZW50LnBhcmVudC5wYXJlbnQpJiZlLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudCYmdS5kZWZhdWx0LmlzU291cmNlRmlsZShlLnBhcmVudC5wYXJlbnQucGFyZW50LnBhcmVudCl8fHUuZGVmYXVsdC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oZSkmJigobj1lLm5hbWUpPT1udWxsP3ZvaWQgMDpuLmdldFRleHQoKSk9PT10JiZlLnBhcmVudCYmdS5kZWZhdWx0LmlzU291cmNlRmlsZShlLnBhcmVudCl9LGxyPWU9PnUuZGVmYXVsdC5pc0Fycm93RnVuY3Rpb24oZSkmJmUucGFyZW50JiZ1LmRlZmF1bHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGUucGFyZW50KSYmZS5wYXJlbnQucGFyZW50JiZ1LmRlZmF1bHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChlLnBhcmVudC5wYXJlbnQpJiZlLnBhcmVudC5wYXJlbnQucGFyZW50JiZ1LmRlZmF1bHQuaXNWYXJpYWJsZVN0YXRlbWVudChlLnBhcmVudC5wYXJlbnQucGFyZW50KSYmZS5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQmJnUuZGVmYXVsdC5pc1NvdXJjZUZpbGUoZS5wYXJlbnQucGFyZW50LnBhcmVudC5wYXJlbnQpfHx1LmRlZmF1bHQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKGUpJiZlLnBhcmVudCYmdS5kZWZhdWx0LmlzU291cmNlRmlsZShlLnBhcmVudCksY3I9ZT0+X3QoZSl8fEx0KGUpLF90PWU9PmUua2luZD09PXUuZGVmYXVsdC5TeW50YXhLaW5kLlRydWVLZXl3b3JkLEx0PWU9PmUua2luZD09PXUuZGVmYXVsdC5TeW50YXhLaW5kLkZhbHNlS2V5d29yZCxDdD1lPT5lLmtpbmQ9PT11LmRlZmF1bHQuU3ludGF4S2luZC5OdWxsS2V5d29yZCx1cj1lPT5lLmtpbmQ9PT11LmRlZmF1bHQuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsfHxlLmtpbmQ9PT11LmRlZmF1bHQuU3ludGF4S2luZC5UcnVlS2V5d29yZHx8ZS5raW5kPT09dS5kZWZhdWx0LlN5bnRheEtpbmQuRmFsc2VLZXl3b3JkfHxlLmtpbmQ9PT11LmRlZmF1bHQuU3ludGF4S2luZC5OdWxsS2V5d29yZHx8ZS5raW5kPT09dS5kZWZhdWx0LlN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWx8fGUua2luZD09PXUuZGVmYXVsdC5TeW50YXhLaW5kLklkZW50aWZpZXImJmUuZ2V0VGV4dCgpPT09InVuZGVmaW5lZCJ8fGUua2luZD09PXUuZGVmYXVsdC5TeW50YXhLaW5kLk5vU3Vic3RpdHV0aW9uVGVtcGxhdGVMaXRlcmFsLGZyPShlLHQpPT57Y29uc3Qgbj1NKGUsZHIpLGk9bmV3IE1hcDtuLmZvckVhY2goYT0+e2NvbnN0IG89dS5kZWZhdWx0LmlzSnN4QXR0cmlidXRlKGEucGFyZW50LnBhcmVudCk/YS5wYXJlbnQucGFyZW50Lm5hbWUuZ2V0VGV4dCgpOmEucGFyZW50Lm5hbWUuZ2V0VGV4dCgpO2kuc2V0KG8sYSl9KTtsZXQgcj10O3JldHVybiBpLmZvckVhY2goKGEsbyk9Pntjb25zdCBsPWd0KHIsbXIsbykscz1wcihhKTshc3x8bC5mb3JFYWNoKGM9Pntjb25zdCBmPXtwb3M6Yy5wb3MsZW5kOmMuZW5kfTt1LmRlZmF1bHQuaXNKc3hBdHRyaWJ1dGUoYy5wYXJlbnQpfHwocj1WKHIsZixzKSl9KX0pLHJ9LHByPWU9PntsZXQgdD1udWxsO3JldHVybiB1LmRlZmF1bHQuaXNTdHJpbmdMaXRlcmFsKGUpJiYodD1FLmZhY3RvcnkuY3JlYXRlTm9TdWJzdGl0dXRpb25UZW1wbGF0ZUxpdGVyYWwoZS50ZXh0KSksdS5kZWZhdWx0LmlzTnVtZXJpY0xpdGVyYWwoZSkmJih0PUUuZmFjdG9yeS5jcmVhdGVOdW1lcmljTGl0ZXJhbChlLnRleHQpKSx1LmRlZmF1bHQuaXNJZGVudGlmaWVyKGUpJiZlLmdldFRleHQoKSE9PSJ1bmRlZmluZWQiJiYodD1FLmZhY3RvcnkuY3JlYXRlSWRlbnRpZmllcihlLmdldFRleHQoKSkpLEN0KGUpJiYodD1FLmZhY3RvcnkuY3JlYXRlTnVsbCgpKSxfdChlKSYmKHQ9RS5mYWN0b3J5LmNyZWF0ZVRydWUoKSksTHQoZSkmJih0PUUuZmFjdG9yeS5jcmVhdGVGYWxzZSgpKSx0fSxkcj1lPT4odS5kZWZhdWx0LmlzTnVtZXJpY0xpdGVyYWwoZSl8fHUuZGVmYXVsdC5pc1N0cmluZ0xpdGVyYWwoZSl8fGNyKGUpfHxDdChlKXx8dS5kZWZhdWx0LmlzSWRlbnRpZmllcihlKSYmZS5nZXRUZXh0KCkhPT0idW5kZWZpbmVkIikmJmUucGFyZW50JiZ1LmRlZmF1bHQuaXNKc3hFeHByZXNzaW9uKGUucGFyZW50KXx8dS5kZWZhdWx0LmlzU3RyaW5nTGl0ZXJhbChlKSYmZS5wYXJlbnQmJnUuZGVmYXVsdC5pc0pzeEF0dHJpYnV0ZShlLnBhcmVudCksbXI9KGUsdCk9PnUuZGVmYXVsdC5pc0lkZW50aWZpZXIoZSkmJmUudGV4dD09PXQsd3Q9ZT0+e2NvbnN0IHQ9TShlLHUuZGVmYXVsdC5pc1RlbXBsYXRlRXhwcmVzc2lvbik7bGV0IG49ZTtyZXR1cm4gdC5mb3JFYWNoKGk9Pntjb25zdCByPVtdO2xldCBhPWkuaGVhZDtpZihpLnRlbXBsYXRlU3BhbnMuZm9yRWFjaCgobyxsKT0+e2lmKHVyKG8uZXhwcmVzc2lvbikpe2xldCBzPXUuZGVmYXVsdC5pc1N0cmluZ0xpdGVyYWwoby5leHByZXNzaW9uKXx8dS5kZWZhdWx0LmlzTm9TdWJzdGl0dXRpb25UZW1wbGF0ZUxpdGVyYWwoby5leHByZXNzaW9uKT9vLmV4cHJlc3Npb24udGV4dCtvLmxpdGVyYWwudGV4dDpvLmV4cHJlc3Npb24uZ2V0VGV4dCgpK28ubGl0ZXJhbC50ZXh0O2NvbnN0IGM9ci5wb3AoKTtpZighYyl7YT1FLmZhY3RvcnkuY3JlYXRlVGVtcGxhdGVIZWFkKGEudGV4dCtzKTtyZXR1cm59cz1jLmxpdGVyYWwudGV4dCtzO2NvbnN0IGY9RS5mYWN0b3J5LmNyZWF0ZVRlbXBsYXRlU3BhbihjLmV4cHJlc3Npb24sbD09PWkudGVtcGxhdGVTcGFucy5sZW5ndGgtMT9FLmZhY3RvcnkuY3JlYXRlVGVtcGxhdGVUYWlsKHMpOkUuZmFjdG9yeS5jcmVhdGVUZW1wbGF0ZU1pZGRsZShzKSk7ci5wdXNoKGYpfWVsc2Ugci5wdXNoKG8pfSksci5sZW5ndGg9PT0wKXtjb25zdCBvPXtwb3M6aS5wYXJlbnQucG9zLGVuZDppLnBhcmVudC5lbmR9O249VihuLG8sRS5mYWN0b3J5LmNyZWF0ZVN0cmluZ0xpdGVyYWwoYS50ZXh0KSk7cmV0dXJufW49VihuLHtwb3M6aS5wb3MsZW5kOmkuZW5kfSxFLmZhY3RvcnkuY3JlYXRlVGVtcGxhdGVFeHByZXNzaW9uKGEscikpfSksbj1ocihuKSxufSxocj1lPT57Y29uc3QgdD1NKGUseXIpO2xldCBuPWU7cmV0dXJuIHQuZm9yRWFjaChpPT57bj1WKG4se3BvczppLnBhcmVudC5wb3MsZW5kOmkucGFyZW50LmVuZH0sRS5mYWN0b3J5LmNyZWF0ZVN0cmluZ0xpdGVyYWwoaS50ZXh0KSl9KSxNKG4sdnIpLmZvckVhY2goaT0+e249VihuLHtwb3M6aS5wYXJlbnQucG9zLGVuZDppLnBhcmVudC5lbmR9LEUuZmFjdG9yeS5jcmVhdGVTdHJpbmdMaXRlcmFsKGkudGV4dCkpfSksbn0sdnI9ZT0+RnQoZSkmJmUucGFyZW50JiZ1LmRlZmF1bHQuaXNKc3hFeHByZXNzaW9uKGUucGFyZW50KSx5cj1lPT5GdChlKSYmZS5wYXJlbnQmJnUuZGVmYXVsdC5pc0JpbmFyeUV4cHJlc3Npb24oZS5wYXJlbnQpLEZ0PWU9PnUuZGVmYXVsdC5pc1N0cmluZ0xpdGVyYWwoZSl8fHUuZGVmYXVsdC5pc05vU3Vic3RpdHV0aW9uVGVtcGxhdGVMaXRlcmFsKGUpLEVyPWFzeW5jKGUsdCxuKT0+e2NvbnN0IGk9RHQodCxuKTtpZighaSlyZXR1cm4gZTtjb25zdCByPWFyKGkpO2lmKCFyKXJldHVybiBlO2NvbnN0IGE9QihlLFJ0KTtpZighYSlyZXR1cm4gZTtjb25zdCBvPXIubWFwKGY9PmYuZ2V0VGV4dCgpKSxsPVsuLi5yLC4uLkFycmF5LmZyb20oYS5zdGF0ZW1lbnRzKS5maWx0ZXIoZj0+IW8uaW5jbHVkZXMoZi5nZXRUZXh0KCkpKV0scz1FLmZhY3RvcnkuY3JlYXRlQmxvY2sobCk7eihzKTtjb25zdCBjPU50KGUsUnQscyk7cmV0dXJuIGF3YWl0ICQoYyl9LFRyPShlLHQpPT57Y29uc3Qgbj10LmZpbHRlcihyPT4hdS5kZWZhdWx0LmlzSnN4VGV4dChyKSkubGVuZ3RoO2xldCBpPUNlKGUsSXIsImNoaWxkcmVuIix0KTtyZXR1cm4gaT1OdChpLFNyLEUuZmFjdG9yeS5jcmVhdGVOdW1lcmljTGl0ZXJhbChuKSksaX0sZ3I9YXN5bmMoZSx0LG4pPT57Y29uc3QgaT1EdCh0LG4pO2lmKCFpKXJldHVybiBudWxsO2NvbnN0IHI9b3IoaSk7aWYoIXIpcmV0dXJuIG51bGw7Y29uc3QgYT1ndChlLHhyLG4pO2lmKGEubGVuZ3RoPT0wKXJldHVybiBudWxsO2xldCBvPWU7cmV0dXJuIGEuZm9yRWFjaChsPT57bGV0IHM9ZnIobCxyKTtpZih1LmRlZmF1bHQuaXNKc3hPcGVuaW5nRWxlbWVudChsKSl7Y29uc3QgYz1BcnJheS5mcm9tKGwucGFyZW50LmNoaWxkcmVuKTtzPVRyKHMsYyl9eihzKSxvPVYobyx7cG9zOmwucG9zLGVuZDpsLmVuZH0scyl9KSxhd2FpdCAkKG8pfSxOcj1hc3luYyhlLHQsbik9PntsZXQgaT1hd2FpdCBFcihlLHQsbik7cmV0dXJuIGk9YXdhaXQgZ3IoaSx0LG4pLGk/KGk9SmkoaSx0KSxpPUl0KGksbiksaT13dChpKSxpKTplfSx4cj0oZSx0KT0+dS5kZWZhdWx0LmlzSnN4T3BlbmluZ0xpa2VFbGVtZW50KGUpJiZlLnRhZ05hbWUudGV4dD09PXQsUnQ9ZT0+dS5kZWZhdWx0LmlzQmxvY2soZSkmJmUucGFyZW50JiZscihlLnBhcmVudCksSXI9KGUsdCk9PnUuZGVmYXVsdC5pc0pzeEV4cHJlc3Npb24oZSkmJmUuZXhwcmVzc2lvbiYmKHUuZGVmYXVsdC5pc0lkZW50aWZpZXIoZS5leHByZXNzaW9uKSYmZS5leHByZXNzaW9uLmdldFRleHQoKT09PXR8fHUuZGVmYXVsdC5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihlLmV4cHJlc3Npb24pJiZlLmV4cHJlc3Npb24ubmFtZS5nZXRUZXh0KCk9PT10KSxTcj1lPT51LmRlZmF1bHQuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24oZSkmJnUuZGVmYXVsdC5pc1Byb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihlLmV4cHJlc3Npb24pJiZlLm5hbWUuZ2V0VGV4dCgpPT09Imxlbmd0aCImJmUuZXhwcmVzc2lvbi5uYW1lLmdldFRleHQoKT09PSJjaGlsZHJlbiIsT3I9Ii4vbm9kZV9tb2R1bGVzL0BpdGVyaWEtYXBwL2NvbXBvbmVudC10ZW1wbGF0ZXMvc3JjL2NvbXBvbmVudHMvcmVhZG9ubHkiLEFyPSIuL25vZGVfbW9kdWxlcy9AaXRlcmlhLWFwcC9jb21wb25lbnQtdGVtcGxhdGVzL3NyYy9jb21wb25lbnRzL2VudGl0eS9saXN0L0VudGl0eSIsYnI9InRlbXBsYXRlcy9yZWFkb25seSIsa3I9InRlbXBsYXRlcy9saXN0L0VudGl0eSIsRHI9IkVudGl0eSIsRmU9ImZpZWxkIixQdD0iY29sdW1ucyIsX3I9ImhlYWRlck5hbWUiLExyPSJyZW5kZXJDZWxsIixDcj0idmFsdWUiLHZlPSJEZWZhdWx0Rm9ybWF0Iix3cj0iQm9vbGVhbkZvcm1hdCIsRnI9IkRhdGVGb3JtYXQiLFJyPSJEYXRlVGltZUZvcm1hdCIsUHI9IlRpbWVGb3JtYXQiLGp0PWU9PmUucmVwbGFjZSgvXlx3Lyx0PT50LnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoLyhffFwuKS9nLCIgIiksanI9KGUsdCk9Pnt2YXIgbj1lLmluZGV4T2YodCk7cmV0dXJuIG4hPT0tMSYmZS5zcGxpY2UobiwxKSxlfTthc3luYyBmdW5jdGlvbiBCdChlKXtjb25zdHtpbzp0LGVudGl0eTpuLGZpZWxkOmksZmllbGRzOnIscGFnZTphLHNlbGVjdGVkQ29sdW1uOm8saW5zZXJ0VHlwZTpsfT1lO2xldCBzPWUuYXN0O2NvbnN0IGM9dHlwZW9mIHM7aWYoYz09PSJzdHJpbmciJiYocz1HKHMpKSwkcihzLGAke259LiR7aS5uYW1lfWApfHxpLm5hbWU9PT0iaWQiKXJldHVybiBhd2FpdCB5ZShzLGMpO2xldCBmLGQsdjtpZihhPT09SC5MSVNUKXtjb25zdCBoPWF3YWl0IEJyKHMsbyxuLGkscixsKTtpZighaHx8IWgub2JqZWN0TGl0ZXJhbHx8IWgubGFzdE9iamVjdExpdGVyYWx8fCFoLmZvcm1hdENvbXBvbmVudE5hbWUpcmV0dXJuIGF3YWl0IHllKHMsYyk7Zj1oLm9iamVjdExpdGVyYWwsZD1oLmxhc3RPYmplY3RMaXRlcmFsLHY9aC5mb3JtYXRDb21wb25lbnROYW1lfWVsc2UgcmV0dXJuIGF3YWl0IHllKHMsYyk7cz1oZShzLHtwb3M6ZC5wb3MsZW5kOmQuZW5kfSxbZl0sbD09PVIuQkVGT1JFfHxsPT09Ui5GSVJTVD8iYmVmb3JlIjoiYWZ0ZXIiKSxzPWF3YWl0ICQocyk7Y29uc3QgbT10LmluamVjdE1vZGU9PT0iamFtc3RhY2siP2JyOk9yO3JldHVybiBzPWF3YWl0IHFyKHQscyx2LG0saS5uYW1lKSxhd2FpdCB5ZShzLGMpfWNvbnN0IEJyPWFzeW5jKGUsdCxuLGkscixhKT0+e3ZhciBvLGwscyxjO2xldCBmLGQsdjtpZih0KXtpZihkPUIoZSxoPT5oLmdldFRleHQoKT09PXQuZ2V0VGV4dCgpKSwhZClyZXR1cm47Y29uc3QgbT1NdChkLG4saSxyKTt2PW0ub2JqZWN0TGl0ZXJhbCxmPW0uZm9ybWF0Q29tcG9uZW50TmFtZX1lbHNle2NvbnN0IG09QihlLE49PnUuZGVmYXVsdC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oTikmJk4ubmFtZS50ZXh0PT09UHQpO2lmKCFtfHwodj0obD0obz1tLmluaXRpYWxpemVyKT09bnVsbD92b2lkIDA6by5lbGVtZW50cyk9PW51bGw/dm9pZCAwOmxbMF0sIXYpKXJldHVybjtjb25zdCBoPU10KHYsbixpLHIpO3Y9aC5vYmplY3RMaXRlcmFsLGY9aC5mb3JtYXRDb21wb25lbnROYW1lLGEmJmE9PT1SLkZJUlNUP2Q9KHM9bS5pbml0aWFsaXplcik9PW51bGw/dm9pZCAwOnMuZWxlbWVudHNbMF06ZD0oYz1tLmluaXRpYWxpemVyKT09bnVsbD92b2lkIDA6Yy5lbGVtZW50cy5zbGljZSgtMSlbMF19cmV0dXJue29iamVjdExpdGVyYWw6dixsYXN0T2JqZWN0TGl0ZXJhbDpkLGZvcm1hdENvbXBvbmVudE5hbWU6Zn19LE1yPWU9PntpZighZSlyZXR1cm4gdmU7c3dpdGNoKGUudG9Mb3dlckNhc2UoKSl7Y2FzZSJzdHJpbmciOmNhc2UibnVtYmVyIjpjYXNlImludCI6Y2FzZSJqc29uYiI6Y2FzZSJ1dWlkIjpyZXR1cm4gdmU7Y2FzZSJib29sZWFuIjpyZXR1cm4gd3I7Y2FzZSJkYXRlIjpyZXR1cm4gRnI7Y2FzZSJkYXRldGltZSI6Y2FzZSJ0aW1lc3RhbXAiOmNhc2UidGltZXN0YW1wdHoiOnJldHVybiBScjtjYXNlInRpbWUiOmNhc2UidGltZXoiOnJldHVybiBQcjtkZWZhdWx0OnJldHVybiB2ZX19LFZyPShlLHQpPT5NKGUsbj0+dC5pbmNsdWRlcyhuLnRleHQpKSwkcj0oZSx0KT0+ISFCKGUsbj0+bi50ZXh0PT09dCkseWU9YXN5bmMoZSx0KT0+dD09PSJzdHJpbmciP2F3YWl0IExlKGUpOmUsTXQ9KGUsdCxuLGkpPT57bGV0IHI7Zm9yKGNvbnN0IGEgb2YgZS5wcm9wZXJ0aWVzKXtjb25zdCBvPWEuaW5pdGlhbGl6ZXI7aS5tYXAobD0+bC5uYW1lKS51bnNoaWZ0KEZlKSxlPVVyKGUsbyx0LG4saSksKHUuZGVmYXVsdC5pc0Fycm93RnVuY3Rpb24obyl8fHUuZGVmYXVsdC5pc0Z1bmN0aW9uRXhwcmVzc2lvbihvKSkmJihyPU1yKG4udHlwZSksZT1KcihlLG8scikpfXJldHVybntvYmplY3RMaXRlcmFsOmUsZm9ybWF0Q29tcG9uZW50TmFtZTpyfX0sVXI9KGUsdCxuLGkscik9Pntjb25zdCBhPWpyKHIubWFwKHM9PnMubmFtZSksImlkIiksbz1hLm1hcChzPT5gJHtufS4ke3N9YCksbD1yLm1hcChzPT5qdChzLm5hbWUpKTtyZXR1cm4gYS51bnNoaWZ0KEZlKSxsLnVuc2hpZnQoX3IpLFZyKHQsWy4uLmEsLi4ubCwuLi5vXSkuZm9yRWFjaChzPT57ZT1LcihlLHMsbixpLm5hbWUse2VudGl0eUZpZWxkczphLGhlYWRlck5hbWVzOmwsbmV3RW50aXR5RmllbGRzOm99KX0pLGV9LEtyPShlLHQsbixpLHIpPT57bGV0IGE7cmV0dXJuIHIuZW50aXR5RmllbGRzLmluY2x1ZGVzKHQudGV4dCk/dC5wYXJlbnQmJnUuZGVmYXVsdC5pc0pzeEF0dHJpYnV0ZSh0LnBhcmVudCkmJnUuZGVmYXVsdC5pc0lkZW50aWZpZXIodCkmJnQucGFyZW50Lm5hbWUuZ2V0VGV4dCgpPT10LmdldFRleHQoKXx8KHUuZGVmYXVsdC5pc1Byb3BlcnR5QXNzaWdubWVudCh0LnBhcmVudCk/YT1gJHtufS4ke2l9YDphPWkpOnIuaGVhZGVyTmFtZXMuaW5jbHVkZXModC50ZXh0KT9hPWp0KGkpOmE9YCR7bn0uJHtpfWAsQXQoZSx0LHQudGV4dCxhKX0sSnI9KGUsdCxuKT0+e3ZhciBpLHI7Y29uc3QgYT0ocj0oaT10LnBhcmVudCk9PW51bGw/dm9pZCAwOmkubmFtZSk9PW51bGw/dm9pZCAwOnIudGV4dDtpZihhJiZhPT09THIpe2NvbnN0IG89dC5wYXJhbWV0ZXJzWzBdLm5hbWUudGV4dCxsPUxpKG4sW3tuYW1lOkNyLGluaXRpYWxpemVyOm99XSk7bGV0IHM7aWYodS5kZWZhdWx0LmlzRnVuY3Rpb25FeHByZXNzaW9uKHQpKXtjb25zdCBjPUIoZSx1LmRlZmF1bHQuaXNSZXR1cm5TdGF0ZW1lbnQpO2lmKCFjKXJldHVybntvYmplY3RMaXRlcmFsOmUsZm9ybWF0Q29tcG9uZW50TmFtZTp2ZX07cz1jLmV4cHJlc3Npb259ZWxzZSBzPXQuYm9keTtlPVYoZSx7cG9zOnMucG9zLGVuZDpzLmVuZH0sbCl9cmV0dXJuIGV9LFlyPWU9PmUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxHcj1hc3luYyhlLHQsbixpLHIsYSk9PntsZXQgbz1HKHQpO2NvbnN0IGw9VnQobik7bz1hd2FpdCBXcihvLGwsaSxhLEguTElTVCk7Zm9yKGNvbnN0IHMgb2Ygcil7aWYoSHIocy5uYW1lKSljb250aW51ZTtjb25zdCBjPXtpbzplLGFzdDpvLGVudGl0eTpuLGZpZWxkOnMsZmllbGRzOnIscGFnZTpILkxJU1Qsc2VsZWN0ZWRDb2x1bW46dm9pZCAwfTtvPWF3YWl0IEJ0KGMpfXJldHVybiBvPWF3YWl0IFhyKG8pLG89SXQobyxgRm9ybWF0JHtsfUZpZWxkYCksbz1hd2FpdCAkKG8pLG89d3Qobyksbz1hd2FpdCAkKG8pLG99LHpyPWFzeW5jKGUsdCxuLGkpPT57Y29uc3Qgcj1WdCh0KSxhPVtdO2Zvcihjb25zdCBvIG9mIG4pe2NvbnN0IGw9ZS5pbmplY3RNb2RlPT09ImphbXN0YWNrIj9rcjpBcixzPWF3YWl0IGUucmVhZEZpbGUoYCR7bH0ke299LnRzeGApLGM9YXdhaXQgR3IoZSxzLHQsRHIsaSxlLmludHJvc3BlY3Rpb24pLGY9YXdhaXQgTGUoYyksZD1rdChgL3NyYy9wYWdlcy8ke3R9L2AsYC4vJHtyfSR7b30udHN4YCk7YS5wdXNoKHtwYXRoOmUuY3dkK2QsZGF0YTpmfSl9cmV0dXJuIGF9LHFyPWFzeW5jKGUsdCxuLGkscik9Pntjb25zdCBhPWF3YWl0IGUucmVhZEZpbGUoYCR7aX0vJHtufS50c3hgKTtsZXQgbz1hd2FpdCBHKGEpO3ImJihyPVFyKHIpLG89d2UobyxGZSxyLCExKSxvPWF3YWl0ICQobykpO2NvbnN0IGw9YXdhaXQgTnIodCxvLG4pO3JldHVybiBhd2FpdCAkKGwpfSxYcj1hc3luYyBlPT57dmFyIHQsbjtjb25zdCBpPUIoZSxhPT51LmRlZmF1bHQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKGEpJiZhLm5hbWUudGV4dD09PVB0KTtpZighaSlyZXR1cm4gZTtjb25zdCByPShuPSh0PWkuaW5pdGlhbGl6ZXIpPT1udWxsP3ZvaWQgMDp0LmVsZW1lbnRzKT09bnVsbD92b2lkIDA6blswXTtyZXR1cm4gZT1VaShlLHtwb3M6ci5wb3MsZW5kOnIuZW5kfSksZX0sSHI9ZT0+ZT09PSJpZCJ8fGUubWF0Y2goLy4qUGF0aCQvaSkhPT1udWxsLFFyPWU9PntpZihlLmluY2x1ZGVzKCIuIikpe2NvbnN0IHQ9ZS5zcGxpdCgiLiIpLm1hcChpPT5pKyI/Iiksbj10LnBvcCgpO3QucHVzaChuLnJlcGxhY2VBbGwoIj8iLCIiKSksZT10LmpvaW4oIi4iKX1yZXR1cm4gZX0sVnQ9ZT0+ZS5zcGxpdCgiXyIpLm1hcCh0PT5Zcih0KSkuam9pbigiIiksV3I9YXN5bmMoZSx0LG4saSxyKT0+e2NvbnN0IGE9TShlLHM9Pntjb25zdCBjPXMuZ2V0VGV4dCgpO3JldHVybih1LmRlZmF1bHQuaXNTdHJpbmdMaXRlcmFsKHMpfHx1LmRlZmF1bHQuaXNJZGVudGlmaWVyKHMpKSYmYyYmYy50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKG4udG9VcHBlckNhc2UoKSl9KSxbb109bmUoaSksbD1vLmZpZWxkcy5maW5kKHM9Pl9lKHMsdCxyKSk7cmV0dXJuIGEuZm9yRWFjaChzPT57Y29uc3QgYz1zLnRleHQ7bGV0IGY7Yy50b0xvd2VyQ2FzZSgpPT09bi50b0xvd2VyQ2FzZSgpP2Y9bC5uYW1lOmY9Yy5yZXBsYWNlKG4sdCksZT1BdChlLHMsYyxmKX0pLGF3YWl0ICQoZSl9O2FzeW5jIGZ1bmN0aW9uIFpyKGUsdCxuKXtjb25zdCBpPW4uZW50aXRpZXMscj1UaShlLGkpLGE9bmV3IE1hcCxvPVtdO2Zvcihjb25zdCBsIG9mIHIpe2NvbnN0IHM9a3QoYC9zcmMvcGFnZXMvJHtsLmVudGl0eU5hbWV9L2AsIi4vaW5kZXguZ3JhcGhxbCIpO2lmKGEuc2V0KHMsbC5xdWVyaWVzKSxuLmdlbmVyYXRlUmVhY3Qpe2NvbnN0IGM9WyJMaXN0VmlldyIsIkxpc3RDb250YWluZXIiXSxmPWwuZnJhZ21lbnRzLm1hcChkPT5sLnByb3BlcnRpZXMuZmluZCh2PT52Lm5hbWU9PT1kKSkuZmlsdGVyKGQ9PmQpO28ucHVzaCguLi5hd2FpdCB6cih0LGwuZW50aXR5TmFtZSxjLGYpKX19cmV0dXJue3BhZ2VzOmEsZmlsZXM6b319VGUoe2FkZENvbHVtbjpiaSxyZW1vdmVDb2x1bW46a2ksZ2VuZXJhdGVQYWdlczpacixjbG9uZUVsZW1lbnRJbkFzdDplcixjbG9uZUFuZFJlbmFtZUVsZW1lbnRJbkFzdDp0cixnZW5lcmF0ZUNvbHVtbjpCdH0pfSl9KSgpOwo=";
const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper() {
  const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
  try {
    return objURL ? new Worker(objURL, {}) : new Worker("data:application/javascript;base64," + encodedJs, { type: "module" });
  } finally {
    objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
  }
}
const createAst = (code2, scriptTarget = ts.ScriptTarget.ESNext, scriptKind = ts.ScriptKind.TSX, filePath = `/ts-ast-viewer.tsx`) => {
  const sourceFile = ts.createSourceFile(filePath, code2, scriptTarget, true, scriptKind);
  const program = getBindingResult(filePath, sourceFile, scriptTarget);
  return program.getSourceFile(filePath);
};
const getBindingResult = (filePath, sourceFile, scriptTarget) => {
  const options2 = {
    strict: true,
    target: scriptTarget,
    allowJs: true,
    module: ts.ModuleKind.ESNext,
    jsx: ts.JsxEmit.React
  };
  const files = {
    [filePath]: sourceFile
  };
  const compilerHost = {
    getSourceFile: (fileName) => {
      return files[fileName];
    },
    getDefaultLibFileName: () => "/lib",
    writeFile: () => {
    },
    getCurrentDirectory: () => "/",
    getDirectories: () => [],
    fileExists: (fileName) => files[fileName] != null,
    readFile: (fileName) => files[fileName] != null ? files[fileName].getFullText() : void 0,
    getCanonicalFileName: (fileName) => fileName,
    useCaseSensitiveFileNames: () => true,
    getNewLine: () => "\n",
    getEnvironmentVariable: () => ""
  };
  const program = ts.createProgram([...Object.keys(files)], options2, compilerHost);
  return program;
};
const decodeEmptyLines = (code2) => code2.replace(/\/\*\* THIS_IS_A_NEWLINE \*\*\//g, "");
const printFormattedSourceFile = async (sourceFile) => {
  const printer = ts.createPrinter();
  const code2 = printer.printFile(sourceFile);
  const decoded = decodeEmptyLines(code2);
  const formattedCode = await formatCode(decoded);
  return formattedCode;
};
const formatCode = async (code2, parser2 = "typescript") => {
  const prettier = (await import(
    //@ts-ignore
    "https://unpkg.com/prettier/esm/standalone.mjs"
  )).default;
  const typescriptParser = (await import(
    //@ts-ignore
    "https://unpkg.com/prettier/esm/parser-typescript.mjs"
  )).default;
  const graphqlParser = (await import(
    //@ts-ignore
    "https://unpkg.com/prettier/esm/parser-graphql.mjs"
  )).default;
  return prettier.format(code2, {
    parser: parser2,
    plugins: [typescriptParser, graphqlParser],
    semi: false,
    tabWidth: 2,
    singleQuote: true
  });
};
const appendTransformer = ({ pos, end }, newNode, position2) => {
  return (context) => {
    const visit2 = (node) => {
      if (node.pos === pos && node.end === end) {
        if (position2 === "before") {
          return Array.isArray(newNode) ? [...newNode, node] : [newNode, node];
        } else {
          return Array.isArray(newNode) ? [node, ...newNode] : [node, newNode];
        }
      }
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const replaceTransformer = ({ pos, end }, newNode) => {
  return (context) => {
    const visit2 = (node) => {
      if (node.pos === pos && node.end === end)
        return newNode;
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const conditionalReplaceTransformer = (condition2, newNode) => {
  return (context) => {
    const visit2 = (node) => {
      if (condition2(node))
        return newNode;
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const conditionalyWithParamRemoveTransformer = (condition2, identifier) => {
  return (context) => {
    const visit2 = (node) => {
      if (condition2(node, identifier))
        return;
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const conditionalyWithParamReplaceTransformer = (condition2, identifier, newNode) => {
  return (context) => {
    const visit2 = (node) => {
      if (condition2(node, identifier))
        return newNode;
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const removeTransformer = ({
  pos,
  end
}) => {
  return (context) => {
    const visit2 = (node) => {
      if (node.pos === pos && node.end === end) {
        return;
      }
      return ts.visitEachChild(node, (child) => visit2(child), context);
    };
    return (node) => ts.visitNode(node, visit2);
  };
};
const appendElementsToAst = (ast, nodePosition, newNodes, position2) => {
  const result2 = ts.transform(ast, [appendTransformer(nodePosition, newNodes, position2)]);
  return result2.transformed[0];
};
const removeElementFromAst = (ast, nodePosition) => {
  const result2 = ts.transform(ast, [removeTransformer(nodePosition)]);
  return result2.transformed[0];
};
const replaceElementsInAst = (ast, nodePosition, newNode) => {
  const result2 = ts.transform(ast, [replaceTransformer(nodePosition, newNode)]);
  return result2.transformed[0];
};
const conditionalyReplaceNodeInAst = (ast, condition2, newNode) => {
  const result2 = ts.transform(ast, [
    conditionalReplaceTransformer(condition2, newNode)
  ]);
  return result2.transformed[0];
};
const conditionalyWithParamReplaceNodeInAst = (ast, condition2, identifier, newNode) => {
  const result2 = ts.transform(ast, [
    conditionalyWithParamReplaceTransformer(condition2, identifier, newNode)
  ]);
  return result2.transformed[0];
};
const conditionalyWithParamRemoveNodeInAst = (ast, condition2, identifier) => {
  const result2 = ts.transform(ast, [
    conditionalyWithParamRemoveTransformer(condition2, identifier)
  ]);
  return result2.transformed[0];
};
const stripRanges = (node) => {
  node.pos = -1;
  node.end = -1;
  ts.forEachChild(node, stripRanges);
};
const regenerateAst = async (ast) => {
  const stringFile = await printFormattedSourceFile(ast);
  return createAst(stringFile);
};
typeof TextDecoder === "function" ? new TextDecoder() : void 0;
typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
((a) => {
  let tab = {};
  a.forEach((c2, i2) => tab[c2] = i2);
  return tab;
})(b64chs);
String.fromCharCode.bind(String);
typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn2 = (x2) => x2) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn2));
const stripPrefix = (str2, prefix) => str2.startsWith(prefix) ? str2.split(prefix)[1] : str2;
const findRelativePath = (basePath, relativePath) => {
  if (relativePath === ".")
    return mergePaths(basePath, "./index");
  if (relativePath.startsWith("./"))
    return mergePaths(basePath, relativePath);
  if (relativePath === "..") {
    const parentFolder = basePath.substring(0, basePath.lastIndexOf("/"));
    return mergePaths(parentFolder, "./index");
  }
  const parentDir = relativePath.split("/").filter((rP) => rP === "..");
  const path2 = relativePath.split("/").filter((rP) => rP !== "..").join("/");
  const currDirPathParts = mergePaths(basePath, "").split("/").filter(Boolean);
  parentDir.forEach(() => currDirPathParts.pop());
  return mergePaths("/" + currDirPathParts.join("/") + "/", path2);
};
const mergePaths = (basePath, relativePath) => {
  const currFolder = basePath.endsWith("/") ? basePath : basePath.substring(0, basePath.lastIndexOf("/")) + "/";
  let path2 = stripPrefix(relativePath, "./");
  path2 = stripPrefix(path2, "/");
  return currFolder + path2;
};
const findByCondition = (node, condition2) => {
  if (condition2(node)) {
    return node;
  }
  return node.forEachChild((child) => {
    return findByCondition(child, condition2);
  });
};
const findByConditionWithParam = (node, condition2, text2) => {
  if (condition2(node, text2)) {
    return node;
  }
  return node.forEachChild((child) => {
    return findByConditionWithParam(child, condition2, text2);
  });
};
const findAllByCondition = (node, condition2) => {
  const nodeOccurences = [];
  const findAll = (node2, condition22) => {
    if (condition22(node2))
      nodeOccurences.push(node2);
    return node2.forEachChild((child) => findAll(child, condition22));
  };
  findAll(node, condition2);
  return nodeOccurences;
};
const findAllByConditionWithParam = (node, condition2, identifier) => {
  const nodeOccurences = [];
  const findAll = (node2, condition22, identifier2) => {
    if (condition22(node2, identifier2))
      nodeOccurences.push(node2);
    return node2.forEachChild((child) => findAll(child, condition22, identifier2));
  };
  findAll(node, condition2, identifier);
  return nodeOccurences;
};
const findPositionOfFirstImport = (ast) => {
  const firstImport = findByCondition(ast, (node) => ts.isImportDeclaration(node) && node.pos > 0);
  return firstImport !== void 0 ? { pos: firstImport.pos, end: firstImport.end } : { pos: 0, end: 0 };
};
var version = "15.7.2";
var versionInfo = Object.freeze({
  major: 15,
  minor: 7,
  patch: 2,
  preReleaseTag: null
});
function _typeof$5(obj2) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj3) {
      return typeof obj3;
    };
  } else {
    _typeof$5 = function _typeof2(obj3) {
      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    };
  }
  return _typeof$5(obj2);
}
function isObjectLike$8(value2) {
  return _typeof$5(value2) == "object" && value2 !== null;
}
var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
function getLocation(source, position2) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position2 + 1;
  var match;
  while ((match = lineRegexp.exec(source.body)) && match.index < position2) {
    line += 1;
    column = position2 + 1 - (match.index + match[0].length);
  }
  return {
    line,
    column
  };
}
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body2 = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body2.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref2) {
    _ref2[0];
    var line = _ref2[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str2) {
  return whitespace(len - str2.length) + str2;
}
function _typeof$4(obj2) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj3) {
      return typeof obj3;
    };
  } else {
    _typeof$4 = function _typeof2(obj3) {
      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    };
  }
  return _typeof$4(obj2);
}
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$6(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result2;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result2 = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result2 = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result2);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args2, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args3, Class2) {
      var a = [null];
      a.push.apply(a, args3);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance2 = new Constructor();
      if (Class2)
        _setPrototypeOf(instance2, Class2.prototype);
      return instance2;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var GraphQLError = /* @__PURE__ */ function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path2, originalError, extensions) {
    var _nodeLocations, _nodeLocations2, _nodeLocations3;
    var _this;
    _classCallCheck(this, GraphQLError2);
    _this = _super.call(this, message);
    _this.name = "GraphQLError";
    _this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    var nodeLocations = [];
    for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {
      var _this$nodes;
      var _ref4 = _ref3[_i2];
      var loc = _ref4.loc;
      if (loc != null) {
        nodeLocations.push(loc);
      }
    }
    nodeLocations = undefinedIfEmpty(nodeLocations);
    _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;
    _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function(loc2) {
      return loc2.start;
    });
    _this.locations = positions && source ? positions.map(function(pos) {
      return getLocation(source, pos);
    }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function(loc2) {
      return getLocation(loc2.source, loc2.start);
    });
    _this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;
    if (extensions == null && isObjectLike$8(originalExtensions)) {
      _this.extensions = _objectSpread$4({}, originalExtensions);
    } else {
      _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      message: {
        enumerable: true
      },
      locations: {
        enumerable: _this.locations != null
      },
      path: {
        enumerable: _this.path != null
      },
      extensions: {
        enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass$4(GraphQLError2, [{
    key: "toString",
    value: function toString5() {
      return printError(this);
    }
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error2) {
  var output = error2.message;
  if (error2.nodes) {
    for (var _i4 = 0, _error$nodes2 = error2.nodes; _i4 < _error$nodes2.length; _i4++) {
      var node = _error$nodes2[_i4];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error2.source && error2.locations) {
    for (var _i6 = 0, _error$locations2 = error2.locations; _i6 < _error$locations2.length; _i6++) {
      var location2 = _error$locations2[_i6];
      output += "\n\n" + printSourceLocation(error2.source, location2);
    }
  }
  return output;
}
function syntaxError$1(source, position2, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position2]);
}
var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});
function invariant(condition2, message) {
  var booleanCondition = Boolean(condition2);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
var nodejsCustomInspectSymbol$1 = nodejsCustomInspectSymbol;
function defineInspect(classObject) {
  var fn2 = classObject.prototype.toJSON;
  typeof fn2 === "function" || invariant(0);
  classObject.prototype.inspect = fn2;
  if (nodejsCustomInspectSymbol$1) {
    classObject.prototype[nodejsCustomInspectSymbol$1] = fn2;
  }
}
var Location = /* @__PURE__ */ function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON3() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = /* @__PURE__ */ function() {
  function Token2(kind, start, end, line, column, prev, value2) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value2;
    this.prev = prev;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON3() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode$1(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});
function _typeof$3(obj2) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj3) {
      return typeof obj3;
    };
  } else {
    _typeof$3 = function _typeof2(obj3) {
      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    };
  }
  return _typeof$3(obj2);
}
var MAX_ARRAY_LENGTH$1 = 10;
var MAX_RECURSIVE_DEPTH$1 = 2;
function inspect$1(value2) {
  return formatValue$1(value2, []);
}
function formatValue$1(value2, seenValues) {
  switch (_typeof$3(value2)) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? "[function ".concat(value2.name, "]") : "[function]";
    case "object":
      if (value2 === null) {
        return "null";
      }
      return formatObjectValue$1(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue$1(value2, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value2) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value2]);
  var customInspectFn = getCustomFn(value2);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value2);
    if (customValue !== value2) {
      return typeof customValue === "string" ? customValue : formatValue$1(customValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray$1(value2, seenValues);
  }
  return formatObject$1(value2, seenValues);
}
function formatObject$1(object, seenValues) {
  var keys2 = Object.keys(object);
  if (keys2.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[" + getObjectTag$1(object) + "]";
  }
  var properties = keys2.map(function(key) {
    var value2 = formatValue$1(object[key], seenValues);
    return key + ": " + value2;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray$1(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH$1, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i2 = 0; i2 < len; ++i2) {
    items.push(formatValue$1(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol$1)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag$1(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
function devAssert(condition2, message) {
  var booleanCondition = Boolean(condition2);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var instanceOf = function instanceOf2(value2, constructor) {
  return value2 instanceof constructor;
};
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
var Source = /* @__PURE__ */ function() {
  function Source2(body2) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body2 === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect$1(body2), "."));
    this.body = body2;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass$3(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf(source, Source);
}
var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});
function dedentBlockStringValue$1(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation$1(rawString);
  if (commonIndent !== 0) {
    for (var i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank$1(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank$1(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank$1(str2) {
  for (var i2 = 0; i2 < str2.length; ++i2) {
    if (str2[i2] !== " " && str2[i2] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation$1(value2) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent2 = 0;
  var commonIndent = null;
  for (var i2 = 0; i2 < value2.length; ++i2) {
    switch (value2.charCodeAt(i2)) {
      case 13:
        if (value2.charCodeAt(i2 + 1) === 10) {
          ++i2;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent2 = 0;
        break;
      case 9:
      case 32:
        ++indent2;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent2 < commonIndent)) {
          commonIndent = indent2;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
function printBlockString$1(value2) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value2.indexOf("\n") === -1;
  var hasLeadingSpace = value2[0] === " " || value2[0] === "	";
  var hasTrailingQuote = value2[value2.length - 1] === '"';
  var hasTrailingSlash = value2[value2.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result2 = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result2 += "\n" + indentation;
  }
  result2 += indentation ? value2.replace(/\n/g, "\n" + indentation) : value2;
  if (printAsMultipleLines) {
    result2 += "\n";
  }
  return '"""' + result2.replace(/"""/g, '\\"""') + '"""';
}
var Lexer = /* @__PURE__ */ function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code2) {
  return isNaN(code2) ? TokenKind.EOF : code2 < 127 ? JSON.stringify(String.fromCharCode(code2)) : '"\\u'.concat(("00" + code2.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body2 = source.body;
  var bodyLength = body2.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code2 = body2.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code2) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body2.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body2.charCodeAt(pos + 1) === 46 && body2.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body2.charCodeAt(pos + 1) === 34 && body2.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code2, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError$1(source, pos, unexpectedCharacterMessage(code2));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code2) {
  if (code2 < 32 && code2 !== 9 && code2 !== 10 && code2 !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code2), ".");
  }
  if (code2 === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code2), ".");
}
function readComment(source, start, line, col, prev) {
  var body2 = source.body;
  var code2;
  var position2 = start;
  do {
    code2 = body2.charCodeAt(++position2);
  } while (!isNaN(code2) && (code2 > 31 || code2 === 9));
  return new Token(TokenKind.COMMENT, start, position2, line, col, prev, body2.slice(start + 1, position2));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body2 = source.body;
  var code2 = firstCode;
  var position2 = start;
  var isFloat2 = false;
  if (code2 === 45) {
    code2 = body2.charCodeAt(++position2);
  }
  if (code2 === 48) {
    code2 = body2.charCodeAt(++position2);
    if (code2 >= 48 && code2 <= 57) {
      throw syntaxError$1(source, position2, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code2), "."));
    }
  } else {
    position2 = readDigits(source, position2, code2);
    code2 = body2.charCodeAt(position2);
  }
  if (code2 === 46) {
    isFloat2 = true;
    code2 = body2.charCodeAt(++position2);
    position2 = readDigits(source, position2, code2);
    code2 = body2.charCodeAt(position2);
  }
  if (code2 === 69 || code2 === 101) {
    isFloat2 = true;
    code2 = body2.charCodeAt(++position2);
    if (code2 === 43 || code2 === 45) {
      code2 = body2.charCodeAt(++position2);
    }
    position2 = readDigits(source, position2, code2);
    code2 = body2.charCodeAt(position2);
  }
  if (code2 === 46 || isNameStart(code2)) {
    throw syntaxError$1(source, position2, "Invalid number, expected digit but got: ".concat(printCharCode(code2), "."));
  }
  return new Token(isFloat2 ? TokenKind.FLOAT : TokenKind.INT, start, position2, line, col, prev, body2.slice(start, position2));
}
function readDigits(source, start, firstCode) {
  var body2 = source.body;
  var position2 = start;
  var code2 = firstCode;
  if (code2 >= 48 && code2 <= 57) {
    do {
      code2 = body2.charCodeAt(++position2);
    } while (code2 >= 48 && code2 <= 57);
    return position2;
  }
  throw syntaxError$1(source, position2, "Invalid number, expected digit but got: ".concat(printCharCode(code2), "."));
}
function readString(source, start, line, col, prev) {
  var body2 = source.body;
  var position2 = start + 1;
  var chunkStart = position2;
  var code2 = 0;
  var value2 = "";
  while (position2 < body2.length && !isNaN(code2 = body2.charCodeAt(position2)) && code2 !== 10 && code2 !== 13) {
    if (code2 === 34) {
      value2 += body2.slice(chunkStart, position2);
      return new Token(TokenKind.STRING, start, position2 + 1, line, col, prev, value2);
    }
    if (code2 < 32 && code2 !== 9) {
      throw syntaxError$1(source, position2, "Invalid character within String: ".concat(printCharCode(code2), "."));
    }
    ++position2;
    if (code2 === 92) {
      value2 += body2.slice(chunkStart, position2 - 1);
      code2 = body2.charCodeAt(position2);
      switch (code2) {
        case 34:
          value2 += '"';
          break;
        case 47:
          value2 += "/";
          break;
        case 92:
          value2 += "\\";
          break;
        case 98:
          value2 += "\b";
          break;
        case 102:
          value2 += "\f";
          break;
        case 110:
          value2 += "\n";
          break;
        case 114:
          value2 += "\r";
          break;
        case 116:
          value2 += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body2.charCodeAt(position2 + 1), body2.charCodeAt(position2 + 2), body2.charCodeAt(position2 + 3), body2.charCodeAt(position2 + 4));
          if (charCode < 0) {
            var invalidSequence = body2.slice(position2 + 1, position2 + 5);
            throw syntaxError$1(source, position2, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value2 += String.fromCharCode(charCode);
          position2 += 4;
          break;
        }
        default:
          throw syntaxError$1(source, position2, "Invalid character escape sequence: \\".concat(String.fromCharCode(code2), "."));
      }
      ++position2;
      chunkStart = position2;
    }
  }
  throw syntaxError$1(source, position2, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body2 = source.body;
  var position2 = start + 3;
  var chunkStart = position2;
  var code2 = 0;
  var rawValue = "";
  while (position2 < body2.length && !isNaN(code2 = body2.charCodeAt(position2))) {
    if (code2 === 34 && body2.charCodeAt(position2 + 1) === 34 && body2.charCodeAt(position2 + 2) === 34) {
      rawValue += body2.slice(chunkStart, position2);
      return new Token(TokenKind.BLOCK_STRING, start, position2 + 3, line, col, prev, dedentBlockStringValue$1(rawValue));
    }
    if (code2 < 32 && code2 !== 9 && code2 !== 10 && code2 !== 13) {
      throw syntaxError$1(source, position2, "Invalid character within String: ".concat(printCharCode(code2), "."));
    }
    if (code2 === 10) {
      ++position2;
      ++lexer.line;
      lexer.lineStart = position2;
    } else if (code2 === 13) {
      if (body2.charCodeAt(position2 + 1) === 10) {
        position2 += 2;
      } else {
        ++position2;
      }
      ++lexer.line;
      lexer.lineStart = position2;
    } else if (code2 === 92 && body2.charCodeAt(position2 + 1) === 34 && body2.charCodeAt(position2 + 2) === 34 && body2.charCodeAt(position2 + 3) === 34) {
      rawValue += body2.slice(chunkStart, position2) + '"""';
      position2 += 4;
      chunkStart = position2;
    } else {
      ++position2;
    }
  }
  throw syntaxError$1(source, position2, "Unterminated string.");
}
function uniCharCode(a, b, c2, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c2) << 4 | char2hex(d);
}
function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body2 = source.body;
  var bodyLength = body2.length;
  var position2 = start + 1;
  var code2 = 0;
  while (position2 !== bodyLength && !isNaN(code2 = body2.charCodeAt(position2)) && (code2 === 95 || code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122)) {
    ++position2;
  }
  return new Token(TokenKind.NAME, start, position2, line, col, prev, body2.slice(start, position2));
}
function isNameStart(code2) {
  return code2 === 95 || code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122;
}
function parse$6(source, options2) {
  var parser2 = new Parser$1(source, options2);
  return parser2.parseDocument();
}
function parseValue(source, options2) {
  var parser2 = new Parser$1(source, options2);
  parser2.expectToken(TokenKind.SOF);
  var value2 = parser2.parseValueLiteral(false);
  parser2.expectToken(TokenKind.EOF);
  return value2;
}
function parseType(source, options2) {
  var parser2 = new Parser$1(source, options2);
  parser2.expectToken(TokenKind.SOF);
  var type2 = parser2.parseTypeReference();
  parser2.expectToken(TokenKind.EOF);
  return type2;
}
var Parser$1 = /* @__PURE__ */ function() {
  function Parser2(source, options2) {
    var sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options2;
  }
  var _proto = Parser2.prototype;
  _proto.parseName = function parseName() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    var operation = this.parseOperationType();
    var name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;
    var start = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return {
          kind: Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.FLOAT:
        this._lexer.advance();
        return {
          kind: Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return {
              kind: Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };
          case "false":
            return {
              kind: Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };
          case "null":
            return {
              kind: Kind.NULL,
              loc: this.loc(token)
            };
          default:
            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }
      case TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }
        break;
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this.parseValueLiteral(isConst);
    };
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this2.parseObjectField(isConst);
    };
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives2 = [];
    while (this.peek(TokenKind.AT)) {
      directives2.push(this.parseDirective(isConst));
    }
    return directives2;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type2 = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = {
        kind: Kind.LIST_TYPE,
        type: type2,
        loc: this.loc(start)
      };
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type: type2,
        loc: this.loc(start)
      };
    }
    return type2;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("schema");
    var directives2 = this.parseDirectives(true);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives: directives2,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var _this$_options2;
    if (!this.expectOptionalKeyword("implements")) {
      return [];
    }
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
      var types = [];
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
      return types;
    }
    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args2 = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseTypeReference();
    var directives2 = this.parseDirectives(true);
    return {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args2,
      type: type2,
      directives: directives2,
      loc: this.loc(start)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type2 = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }
    var directives2 = this.parseDirectives(true);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type: type2,
      defaultValue,
      directives: directives2,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives: directives2,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives2 = this.parseDirectives(true);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives2.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives: directives2,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    if (directives2.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives: directives2,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields8.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives2.length === 0 && fields8.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    if (directives2.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives: directives2,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    if (directives2.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives: directives2,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name = this.parseName();
    var directives2 = this.parseDirectives(true);
    var fields8 = this.parseInputFieldsDefinition();
    if (directives2.length === 0 && fields8.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives: directives2,
      fields: fields8,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name = this.parseName();
    var args2 = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args2,
      repeatable,
      locations,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();
    if (DirectiveLocation[name.value] !== void 0) {
      return name;
    }
    throw this.unexpected(start);
  };
  _proto.loc = function loc(startToken) {
    var _this$_options4;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError$1(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return void 0;
  };
  _proto.expectKeyword = function expectKeyword(value2) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value2) {
      this._lexer.advance();
    } else {
      throw syntaxError$1(this._lexer.source, token.start, 'Expected "'.concat(value2, '", found ').concat(getTokenDesc(token), "."));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value2) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value2) {
      this._lexer.advance();
      return true;
    }
    return false;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError$1(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  };
  return Parser2;
}();
function getTokenDesc(token) {
  var value2 = token.value;
  return getTokenKindDesc(token.kind) + (value2 != null ? ' "'.concat(value2, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit(root2, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root2);
  var keys2 = [root2];
  var index2 = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent = void 0;
  var path2 = [];
  var ancestors = [];
  var newRoot = root2;
  do {
    index2++;
    var isLeaving = index2 === keys2.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone2 = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k2 = _Object$keys2[_i2];
            clone2[k2] = node[k2];
          }
          node = clone2;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index2 : keys2[index2] : void 0;
      node = parent ? parent[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent) {
        path2.push(key);
      }
    }
    var result2 = void 0;
    if (!Array.isArray(node)) {
      if (!isNode$1(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect$1(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result2 = visitFn.call(visitor, node, key, parent, path2, ancestors);
        if (result2 === BREAK) {
          break;
        }
        if (result2 === false) {
          if (!isLeaving) {
            path2.pop();
            continue;
          }
        } else if (result2 !== void 0) {
          edits.push([key, result2]);
          if (!isLeaving) {
            if (isNode$1(result2)) {
              node = result2;
            } else {
              path2.pop();
              continue;
            }
          }
        }
      }
    }
    if (result2 === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index: index2,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys2 = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i2 = 0; i2 < visitors.length; i2++) {
        if (skipping[i2] == null) {
          var fn2 = getVisitFn(visitors[i2], node.kind, false);
          if (fn2) {
            var result2 = fn2.apply(visitors[i2], arguments);
            if (result2 === false) {
              skipping[i2] = node;
            } else if (result2 === BREAK) {
              skipping[i2] = BREAK;
            } else if (result2 !== void 0) {
              return result2;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i2 = 0; i2 < visitors.length; i2++) {
        if (skipping[i2] == null) {
          var fn2 = getVisitFn(visitors[i2], node.kind, true);
          if (fn2) {
            var result2 = fn2.apply(visitors[i2], arguments);
            if (result2 === BREAK) {
              skipping[i2] = BREAK;
            } else if (result2 !== void 0 && result2 !== false) {
              return result2;
            }
          }
        } else if (skipping[i2] === node) {
          skipping[i2] = null;
        }
      }
    }
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}
var find = Array.prototype.find ? function(list, predicate) {
  return Array.prototype.find.call(list, predicate);
} : function(list, predicate) {
  for (var _i2 = 0; _i2 < list.length; _i2++) {
    var value2 = list[_i2];
    if (predicate(value2)) {
      return value2;
    }
  }
};
var find$1 = find;
var objectValues = Object.values || function(obj2) {
  return Object.keys(obj2).map(function(key) {
    return obj2[key];
  });
};
var objectValues$1 = objectValues;
function locatedError(rawOriginalError, nodes, path2) {
  var _nodes;
  var originalError = rawOriginalError instanceof Error ? rawOriginalError : new Error("Unexpected error value: " + inspect$1(rawOriginalError));
  if (Array.isArray(originalError.path)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path2, originalError);
}
var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
function assertValidName(name) {
  var error2 = isValidNameError(name);
  if (error2) {
    throw error2;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert(0, "Expected name to be a string.");
  if (name.length > 1 && name[0] === "_" && name[1] === "_") {
    return new GraphQLError('Name "'.concat(name, '" must not begin with "__", which is reserved by GraphQL introspection.'));
  }
  if (!NAME_RX.test(name)) {
    return new GraphQLError('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(name, '" does not.'));
  }
}
var objectEntries = Object.entries || function(obj2) {
  return Object.keys(obj2).map(function(key) {
    return [key, obj2[key]];
  });
};
var objectEntries$1 = objectEntries;
function keyMap(list, keyFn) {
  return list.reduce(function(map2, item) {
    map2[keyFn(item)] = item;
    return map2;
  }, /* @__PURE__ */ Object.create(null));
}
function mapValue(map2, fn2) {
  var result2 = /* @__PURE__ */ Object.create(null);
  for (var _i2 = 0, _objectEntries2 = objectEntries$1(map2); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var _key = _ref2[0];
    var _value = _ref2[1];
    result2[_key] = fn2(_value, _key);
  }
  return result2;
}
function toObjMap(obj2) {
  if (Object.getPrototypeOf(obj2) === null) {
    return obj2;
  }
  var map2 = /* @__PURE__ */ Object.create(null);
  for (var _i2 = 0, _objectEntries2 = objectEntries$1(obj2); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var key = _ref2[0];
    var value2 = _ref2[1];
    map2[key] = value2;
  }
  return map2;
}
function keyValMap(list, keyFn, valFn) {
  return list.reduce(function(map2, item) {
    map2[keyFn(item)] = valFn(item);
    return map2;
  }, /* @__PURE__ */ Object.create(null));
}
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  var _ref2 = typeof firstArg === "string" ? [firstArg, secondArg] : [void 0, firstArg], subMessage = _ref2[0], suggestionsArg = _ref2[1];
  var message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  var suggestions = suggestionsArg.map(function(x2) {
    return '"'.concat(x2, '"');
  });
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  var selected = suggestions.slice(0, MAX_SUGGESTIONS);
  var lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
function identityFunc(x2) {
  return x2;
}
function naturalCompare(aStr, bStr) {
  var aIdx = 0;
  var bIdx = 0;
  while (aIdx < aStr.length && bIdx < bStr.length) {
    var aChar = aStr.charCodeAt(aIdx);
    var bChar = bStr.charCodeAt(bIdx);
    if (isDigit(aChar) && isDigit(bChar)) {
      var aNum = 0;
      do {
        ++aIdx;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIdx);
      } while (isDigit(aChar) && aNum > 0);
      var bNum = 0;
      do {
        ++bIdx;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIdx);
      } while (isDigit(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIdx;
      ++bIdx;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit(code2) {
  return !isNaN(code2) && DIGIT_0 <= code2 && code2 <= DIGIT_9;
}
function suggestionList(input, options2) {
  var optionsByDistance = /* @__PURE__ */ Object.create(null);
  var lexicalDistance = new LexicalDistance(input);
  var threshold = Math.floor(input.length * 0.4) + 1;
  for (var _i2 = 0; _i2 < options2.length; _i2++) {
    var option2 = options2[_i2];
    var distance = lexicalDistance.measure(option2, threshold);
    if (distance !== void 0) {
      optionsByDistance[option2] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort(function(a, b) {
    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var LexicalDistance = /* @__PURE__ */ function() {
  function LexicalDistance2(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];
  }
  var _proto = LexicalDistance2.prototype;
  _proto.measure = function measure(option2, threshold) {
    if (this._input === option2) {
      return 0;
    }
    var optionLowerCase = option2.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    var a = stringToArray(optionLowerCase);
    var b = this._inputArray;
    if (a.length < b.length) {
      var tmp2 = a;
      a = b;
      b = tmp2;
    }
    var aLength = a.length;
    var bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    var rows = this._rows;
    for (var j2 = 0; j2 <= bLength; j2++) {
      rows[0][j2] = j2;
    }
    for (var i2 = 1; i2 <= aLength; i2++) {
      var upRow = rows[(i2 - 1) % 3];
      var currentRow = rows[i2 % 3];
      var smallestCell = currentRow[0] = i2;
      for (var _j = 1; _j <= bLength; _j++) {
        var cost = a[i2 - 1] === b[_j - 1] ? 0 : 1;
        var currentCell = Math.min(upRow[_j] + 1, currentRow[_j - 1] + 1, upRow[_j - 1] + cost);
        if (i2 > 1 && _j > 1 && a[i2 - 1] === b[_j - 2] && a[i2 - 2] === b[_j - 1]) {
          var doubleDiagonalCell = rows[(i2 - 2) % 3][_j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[_j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    var distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  };
  return LexicalDistance2;
}();
function stringToArray(str2) {
  var strLength = str2.length;
  var array = new Array(strLength);
  for (var i2 = 0; i2 < strLength; ++i2) {
    array[i2] = str2.charCodeAt(i2);
  }
  return array;
}
function print(ast) {
  return visit(ast, {
    leave: printDocASTReducer$1
  });
}
var MAX_LINE_LENGTH$1 = 80;
var printDocASTReducer$1 = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return "$" + node.name;
  },
  Document: function Document2(node) {
    return join$1(node.definitions, "\n\n") + "\n";
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap$2("(", join$1(node.variableDefinitions, ", "), ")");
    var directives2 = join$1(node.directives, " ");
    var selectionSet = node.selectionSet;
    return !name && !directives2 && !varDefs && op === "query" ? selectionSet : join$1([op, join$1([name, varDefs]), directives2, selectionSet], " ");
  },
  VariableDefinition: function VariableDefinition(_ref2) {
    var variable = _ref2.variable, type2 = _ref2.type, defaultValue = _ref2.defaultValue, directives2 = _ref2.directives;
    return variable + ": " + type2 + wrap$2(" = ", defaultValue) + wrap$2(" ", join$1(directives2, " "));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block$1(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias, name = _ref3.name, args2 = _ref3.arguments, directives2 = _ref3.directives, selectionSet = _ref3.selectionSet;
    var prefix = wrap$2("", alias, ": ") + name;
    var argsLine = prefix + wrap$2("(", join$1(args2, ", "), ")");
    if (argsLine.length > MAX_LINE_LENGTH$1) {
      argsLine = prefix + wrap$2("(\n", indent$1(join$1(args2, "\n")), "\n)");
    }
    return join$1([argsLine, join$1(directives2, " "), selectionSet], " ");
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name, value2 = _ref4.value;
    return name + ": " + value2;
  },
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name, directives2 = _ref5.directives;
    return "..." + name + wrap$2(" ", join$1(directives2, " "));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition, directives2 = _ref6.directives, selectionSet = _ref6.selectionSet;
    return join$1(["...", wrap$2("on ", typeCondition), join$1(directives2, " "), selectionSet], " ");
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives2 = _ref7.directives, selectionSet = _ref7.selectionSet;
    return "fragment ".concat(name).concat(wrap$2("(", join$1(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap$2("", join$1(directives2, " "), " ")) + selectionSet;
  },
  IntValue: function IntValue(_ref8) {
    var value2 = _ref8.value;
    return value2;
  },
  FloatValue: function FloatValue(_ref9) {
    var value2 = _ref9.value;
    return value2;
  },
  StringValue: function StringValue(_ref10, key) {
    var value2 = _ref10.value, isBlockString = _ref10.block;
    return isBlockString ? printBlockString$1(value2, key === "description" ? "" : "  ") : JSON.stringify(value2);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value2 = _ref11.value;
    return value2 ? "true" : "false";
  },
  NullValue: function NullValue() {
    return "null";
  },
  EnumValue: function EnumValue(_ref12) {
    var value2 = _ref12.value;
    return value2;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return "[" + join$1(values, ", ") + "]";
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields8 = _ref14.fields;
    return "{" + join$1(fields8, ", ") + "}";
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name, value2 = _ref15.value;
    return name + ": " + value2;
  },
  Directive: function Directive2(_ref16) {
    var name = _ref16.name, args2 = _ref16.arguments;
    return "@" + name + wrap$2("(", join$1(args2, ", "), ")");
  },
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type2 = _ref18.type;
    return "[" + type2 + "]";
  },
  NonNullType: function NonNullType(_ref19) {
    var type2 = _ref19.type;
    return type2 + "!";
  },
  SchemaDefinition: addDescription$1(function(_ref20) {
    var directives2 = _ref20.directives, operationTypes = _ref20.operationTypes;
    return join$1(["schema", join$1(directives2, " "), block$1(operationTypes)], " ");
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation, type2 = _ref21.type;
    return operation + ": " + type2;
  },
  ScalarTypeDefinition: addDescription$1(function(_ref22) {
    var name = _ref22.name, directives2 = _ref22.directives;
    return join$1(["scalar", name, join$1(directives2, " ")], " ");
  }),
  ObjectTypeDefinition: addDescription$1(function(_ref23) {
    var name = _ref23.name, interfaces = _ref23.interfaces, directives2 = _ref23.directives, fields8 = _ref23.fields;
    return join$1(["type", name, wrap$2("implements ", join$1(interfaces, " & ")), join$1(directives2, " "), block$1(fields8)], " ");
  }),
  FieldDefinition: addDescription$1(function(_ref24) {
    var name = _ref24.name, args2 = _ref24.arguments, type2 = _ref24.type, directives2 = _ref24.directives;
    return name + (hasMultilineItems$1(args2) ? wrap$2("(\n", indent$1(join$1(args2, "\n")), "\n)") : wrap$2("(", join$1(args2, ", "), ")")) + ": " + type2 + wrap$2(" ", join$1(directives2, " "));
  }),
  InputValueDefinition: addDescription$1(function(_ref25) {
    var name = _ref25.name, type2 = _ref25.type, defaultValue = _ref25.defaultValue, directives2 = _ref25.directives;
    return join$1([name + ": " + type2, wrap$2("= ", defaultValue), join$1(directives2, " ")], " ");
  }),
  InterfaceTypeDefinition: addDescription$1(function(_ref26) {
    var name = _ref26.name, interfaces = _ref26.interfaces, directives2 = _ref26.directives, fields8 = _ref26.fields;
    return join$1(["interface", name, wrap$2("implements ", join$1(interfaces, " & ")), join$1(directives2, " "), block$1(fields8)], " ");
  }),
  UnionTypeDefinition: addDescription$1(function(_ref27) {
    var name = _ref27.name, directives2 = _ref27.directives, types = _ref27.types;
    return join$1(["union", name, join$1(directives2, " "), types && types.length !== 0 ? "= " + join$1(types, " | ") : ""], " ");
  }),
  EnumTypeDefinition: addDescription$1(function(_ref28) {
    var name = _ref28.name, directives2 = _ref28.directives, values = _ref28.values;
    return join$1(["enum", name, join$1(directives2, " "), block$1(values)], " ");
  }),
  EnumValueDefinition: addDescription$1(function(_ref29) {
    var name = _ref29.name, directives2 = _ref29.directives;
    return join$1([name, join$1(directives2, " ")], " ");
  }),
  InputObjectTypeDefinition: addDescription$1(function(_ref30) {
    var name = _ref30.name, directives2 = _ref30.directives, fields8 = _ref30.fields;
    return join$1(["input", name, join$1(directives2, " "), block$1(fields8)], " ");
  }),
  DirectiveDefinition: addDescription$1(function(_ref31) {
    var name = _ref31.name, args2 = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
    return "directive @" + name + (hasMultilineItems$1(args2) ? wrap$2("(\n", indent$1(join$1(args2, "\n")), "\n)") : wrap$2("(", join$1(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join$1(locations, " | ");
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives2 = _ref32.directives, operationTypes = _ref32.operationTypes;
    return join$1(["extend schema", join$1(directives2, " "), block$1(operationTypes)], " ");
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name, directives2 = _ref33.directives;
    return join$1(["extend scalar", name, join$1(directives2, " ")], " ");
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name, interfaces = _ref34.interfaces, directives2 = _ref34.directives, fields8 = _ref34.fields;
    return join$1(["extend type", name, wrap$2("implements ", join$1(interfaces, " & ")), join$1(directives2, " "), block$1(fields8)], " ");
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name, interfaces = _ref35.interfaces, directives2 = _ref35.directives, fields8 = _ref35.fields;
    return join$1(["extend interface", name, wrap$2("implements ", join$1(interfaces, " & ")), join$1(directives2, " "), block$1(fields8)], " ");
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name, directives2 = _ref36.directives, types = _ref36.types;
    return join$1(["extend union", name, join$1(directives2, " "), types && types.length !== 0 ? "= " + join$1(types, " | ") : ""], " ");
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name, directives2 = _ref37.directives, values = _ref37.values;
    return join$1(["extend enum", name, join$1(directives2, " "), block$1(values)], " ");
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name, directives2 = _ref38.directives, fields8 = _ref38.fields;
    return join$1(["extend input", name, join$1(directives2, " "), block$1(fields8)], " ");
  }
};
function addDescription$1(cb) {
  return function(node) {
    return join$1([node.description, cb(node)], "\n");
  };
}
function join$1(maybeArray) {
  var _maybeArray$filter$jo;
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x2) {
    return x2;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block$1(array) {
  return wrap$2("{\n", indent$1(join$1(array, "\n")), "\n}");
}
function wrap$2(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent$1(str2) {
  return wrap$2("  ", str2.replace(/\n/g, "\n  "));
}
function isMultiline(str2) {
  return str2.indexOf("\n") !== -1;
}
function hasMultilineItems$1(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(function(node) {
        return valueFromASTUntyped(node, variables);
      });
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, function(field) {
        return field.name.value;
      }, function(field) {
        return valueFromASTUntyped(field.value, variables);
      });
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
  invariant(0, "Unexpected value node: " + inspect$1(valueNode));
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function assertType(type2) {
  if (!isType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL type."));
  }
  return type2;
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function assertScalarType(type2) {
  if (!isScalarType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Scalar type."));
  }
  return type2;
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function assertObjectType(type2) {
  if (!isObjectType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Object type."));
  }
  return type2;
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function assertInterfaceType(type2) {
  if (!isInterfaceType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Interface type."));
  }
  return type2;
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function assertUnionType(type2) {
  if (!isUnionType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Union type."));
  }
  return type2;
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function assertEnumType(type2) {
  if (!isEnumType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Enum type."));
  }
  return type2;
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function assertInputObjectType(type2) {
  if (!isInputObjectType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Input Object type."));
  }
  return type2;
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function assertListType(type2) {
  if (!isListType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL List type."));
  }
  return type2;
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function assertNonNullType(type2) {
  if (!isNonNullType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL Non-Null type."));
  }
  return type2;
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function assertInputType(type2) {
  if (!isInputType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL input type."));
  }
  return type2;
}
function isOutputType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
}
function assertOutputType(type2) {
  if (!isOutputType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL output type."));
  }
  return type2;
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function assertLeafType(type2) {
  if (!isLeafType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL leaf type."));
  }
  return type2;
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function assertCompositeType(type2) {
  if (!isCompositeType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL composite type."));
  }
  return type2;
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
function assertAbstractType(type2) {
  if (!isAbstractType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL abstract type."));
  }
  return type2;
}
function GraphQLList(ofType) {
  if (this instanceof GraphQLList) {
    this.ofType = assertType(ofType);
  } else {
    return new GraphQLList(ofType);
  }
}
GraphQLList.prototype.toString = function toString2() {
  return "[" + String(this.ofType) + "]";
};
GraphQLList.prototype.toJSON = function toJSON() {
  return this.toString();
};
Object.defineProperty(GraphQLList.prototype, SYMBOL_TO_STRING_TAG, {
  get: function get() {
    return "GraphQLList";
  }
});
defineInspect(GraphQLList);
function GraphQLNonNull(ofType) {
  if (this instanceof GraphQLNonNull) {
    this.ofType = assertNullableType(ofType);
  } else {
    return new GraphQLNonNull(ofType);
  }
}
GraphQLNonNull.prototype.toString = function toString3() {
  return String(this.ofType) + "!";
};
GraphQLNonNull.prototype.toJSON = function toJSON2() {
  return this.toString();
};
Object.defineProperty(GraphQLNonNull.prototype, SYMBOL_TO_STRING_TAG, {
  get: function get2() {
    return "GraphQLNonNull";
  }
});
defineInspect(GraphQLNonNull);
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function assertWrappingType(type2) {
  if (!isWrappingType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL wrapping type."));
  }
  return type2;
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function assertNullableType(type2) {
  if (!isNullableType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL nullable type."));
  }
  return type2;
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function isNamedType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
}
function assertNamedType(type2) {
  if (!isNamedType(type2)) {
    throw new Error("Expected ".concat(inspect$1(type2), " to be a GraphQL named type."));
  }
  return type2;
}
function getNamedType(type2) {
  if (type2) {
    var unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function undefineIfEmpty(arr) {
  return arr && arr.length > 0 ? arr : void 0;
}
var GraphQLScalarType = /* @__PURE__ */ function() {
  function GraphQLScalarType2(config2) {
    var _config$parseValue, _config$serialize, _config$parseLiteral;
    var parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = config2.name;
    this.description = config2.description;
    this.specifiedByUrl = config2.specifiedByUrl;
    this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function(node, variables) {
      return parseValue2(valueFromASTUntyped(node, variables));
    };
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
    config2.specifiedByUrl == null || typeof config2.specifiedByUrl === "string" || devAssert(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat(inspect$1(config2.specifiedByUrl), "."));
    config2.serialize == null || typeof config2.serialize === "function" || devAssert(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'));
    if (config2.parseLiteral) {
      typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.'));
    }
  }
  var _proto = GraphQLScalarType2.prototype;
  _proto.toConfig = function toConfig() {
    var _this$extensionASTNod;
    return {
      name: this.name,
      description: this.description,
      specifiedByUrl: this.specifiedByUrl,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []
    };
  };
  _proto.toString = function toString5() {
    return this.name;
  };
  _proto.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLScalarType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLScalarType";
    }
  }]);
  return GraphQLScalarType2;
}();
defineInspect(GraphQLScalarType);
var GraphQLObjectType = /* @__PURE__ */ function() {
  function GraphQLObjectType2(config2) {
    this.name = config2.name;
    this.description = config2.description;
    this.isTypeOf = config2.isTypeOf;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    this._fields = defineFieldMap.bind(void 0, config2);
    this._interfaces = defineInterfaces.bind(void 0, config2);
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
    config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat(inspect$1(config2.isTypeOf), "."));
  }
  var _proto2 = GraphQLObjectType2.prototype;
  _proto2.getFields = function getFields2() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  };
  _proto2.getInterfaces = function getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  };
  _proto2.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };
  _proto2.toString = function toString5() {
    return this.name;
  };
  _proto2.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLObjectType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLObjectType";
    }
  }]);
  return GraphQLObjectType2;
}();
defineInspect(GraphQLObjectType);
function defineInterfaces(config2) {
  var _resolveThunk;
  var interfaces = (_resolveThunk = resolveThunk(config2.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];
  Array.isArray(interfaces) || devAssert(0, "".concat(config2.name, " interfaces must be an Array or a function which returns an Array."));
  return interfaces;
}
function defineFieldMap(config2) {
  var fieldMap = resolveThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(0, "".concat(config2.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function(fieldConfig, fieldName) {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(0, "".concat(config2.name, ".").concat(fieldName, " field config must be an object."));
    !("isDeprecated" in fieldConfig) || devAssert(0, "".concat(config2.name, ".").concat(fieldName, ' should provide "deprecationReason" instead of "isDeprecated".'));
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(0, "".concat(config2.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(inspect$1(fieldConfig.resolve), "."));
    var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(0, "".concat(config2.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
    var args2 = objectEntries$1(argsConfig).map(function(_ref2) {
      var argName = _ref2[0], argConfig = _ref2[1];
      return {
        name: argName,
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: argConfig.extensions && toObjMap(argConfig.extensions),
        astNode: argConfig.astNode
      };
    });
    return {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: args2,
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      isDeprecated: fieldConfig.deprecationReason != null,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isPlainObj(obj2) {
  return isObjectLike$8(obj2) && !Array.isArray(obj2);
}
function fieldsToFieldsConfig(fields8) {
  return mapValue(fields8, function(field) {
    return {
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    };
  });
}
function argsToArgsConfig(args2) {
  return keyValMap(args2, function(arg) {
    return arg.name;
  }, function(arg) {
    return {
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    };
  });
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = /* @__PURE__ */ function() {
  function GraphQLInterfaceType2(config2) {
    this.name = config2.name;
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    this._fields = defineFieldMap.bind(void 0, config2);
    this._interfaces = defineInterfaces.bind(void 0, config2);
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(inspect$1(config2.resolveType), "."));
  }
  var _proto3 = GraphQLInterfaceType2.prototype;
  _proto3.getFields = function getFields2() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  };
  _proto3.getInterfaces = function getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  };
  _proto3.toConfig = function toConfig() {
    var _this$extensionASTNod2;
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []
    };
  };
  _proto3.toString = function toString5() {
    return this.name;
  };
  _proto3.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLInterfaceType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLInterfaceType";
    }
  }]);
  return GraphQLInterfaceType2;
}();
defineInspect(GraphQLInterfaceType);
var GraphQLUnionType = /* @__PURE__ */ function() {
  function GraphQLUnionType2(config2) {
    this.name = config2.name;
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    this._types = defineTypes.bind(void 0, config2);
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(inspect$1(config2.resolveType), "."));
  }
  var _proto4 = GraphQLUnionType2.prototype;
  _proto4.getTypes = function getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  };
  _proto4.toConfig = function toConfig() {
    var _this$extensionASTNod3;
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []
    };
  };
  _proto4.toString = function toString5() {
    return this.name;
  };
  _proto4.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLUnionType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLUnionType";
    }
  }]);
  return GraphQLUnionType2;
}();
defineInspect(GraphQLUnionType);
function defineTypes(config2) {
  var types = resolveThunk(config2.types);
  Array.isArray(types) || devAssert(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config2.name, "."));
  return types;
}
var GraphQLEnumType = /* @__PURE__ */ function() {
  function GraphQLEnumType2(config2) {
    this.name = config2.name;
    this.description = config2.description;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    this._values = defineEnumValues(this.name, config2.values);
    this._valueLookup = new Map(this._values.map(function(enumValue) {
      return [enumValue.value, enumValue];
    }));
    this._nameLookup = keyMap(this._values, function(value2) {
      return value2.name;
    });
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
  }
  var _proto5 = GraphQLEnumType2.prototype;
  _proto5.getValues = function getValues() {
    return this._values;
  };
  _proto5.getValue = function getValue2(name) {
    return this._nameLookup[name];
  };
  _proto5.serialize = function serialize(outputValue) {
    var enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent value: ').concat(inspect$1(outputValue)));
    }
    return enumValue.name;
  };
  _proto5.parseValue = function parseValue2(inputValue) {
    if (typeof inputValue !== "string") {
      var valueStr = inspect$1(inputValue);
      throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr));
    }
    var enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError('Value "'.concat(inputValue, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  };
  _proto5.parseLiteral = function parseLiteral6(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      var valueStr = print(valueNode);
      throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr), valueNode);
    }
    var enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      var _valueStr = print(valueNode);
      throw new GraphQLError('Value "'.concat(_valueStr, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, _valueStr), valueNode);
    }
    return enumValue.value;
  };
  _proto5.toConfig = function toConfig() {
    var _this$extensionASTNod4;
    var values = keyValMap(this.getValues(), function(value2) {
      return value2.name;
    }, function(value2) {
      return {
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []
    };
  };
  _proto5.toString = function toString5() {
    return this.name;
  };
  _proto5.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLEnumType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLEnumType";
    }
  }]);
  return GraphQLEnumType2;
}();
defineInspect(GraphQLEnumType);
function didYouMeanEnumValue(enumType, unknownValueStr) {
  var allNames = enumType.getValues().map(function(value2) {
    return value2.name;
  });
  var suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(0, "".concat(typeName, " values must be an object with value names as keys."));
  return objectEntries$1(valueMap).map(function(_ref2) {
    var valueName = _ref2[0], valueConfig = _ref2[1];
    isPlainObj(valueConfig) || devAssert(0, "".concat(typeName, ".").concat(valueName, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat(inspect$1(valueConfig), "."));
    !("isDeprecated" in valueConfig) || devAssert(0, "".concat(typeName, ".").concat(valueName, ' should provide "deprecationReason" instead of "isDeprecated".'));
    return {
      name: valueName,
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      isDeprecated: valueConfig.deprecationReason != null,
      deprecationReason: valueConfig.deprecationReason,
      extensions: valueConfig.extensions && toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = /* @__PURE__ */ function() {
  function GraphQLInputObjectType2(config2) {
    this.name = config2.name;
    this.description = config2.description;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = undefineIfEmpty(config2.extensionASTNodes);
    this._fields = defineInputFieldMap.bind(void 0, config2);
    typeof config2.name === "string" || devAssert(0, "Must provide name.");
  }
  var _proto6 = GraphQLInputObjectType2.prototype;
  _proto6.getFields = function getFields2() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  };
  _proto6.toConfig = function toConfig() {
    var _this$extensionASTNod5;
    var fields8 = mapValue(this.getFields(), function(field) {
      return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        deprecationReason: field.deprecationReason,
        extensions: field.extensions,
        astNode: field.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      fields: fields8,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []
    };
  };
  _proto6.toString = function toString5() {
    return this.name;
  };
  _proto6.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$2(GraphQLInputObjectType2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLInputObjectType";
    }
  }]);
  return GraphQLInputObjectType2;
}();
defineInspect(GraphQLInputObjectType);
function defineInputFieldMap(config2) {
  var fieldMap = resolveThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(0, "".concat(config2.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function(fieldConfig, fieldName) {
    !("resolve" in fieldConfig) || devAssert(0, "".concat(config2.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
    return {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema2, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema2, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema2.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema2, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema2.getPossibleTypes(typeA).some(function(type2) {
        return schema2.isSubType(typeB, type2);
      });
    }
    return schema2.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema2.isSubType(typeB, typeA);
  }
  return false;
}
var arrayFrom = Array.from || function(obj2, mapFn, thisArg) {
  if (obj2 == null) {
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  }
  var iteratorMethod = obj2[SYMBOL_ITERATOR];
  if (typeof iteratorMethod === "function") {
    var iterator = iteratorMethod.call(obj2);
    var result2 = [];
    var step;
    for (var i2 = 0; !(step = iterator.next()).done; ++i2) {
      result2.push(mapFn.call(thisArg, step.value, i2));
      if (i2 > 9999999) {
        throw new TypeError("Near-infinite iteration.");
      }
    }
    return result2;
  }
  var length = obj2.length;
  if (typeof length === "number" && length >= 0 && length % 1 === 0) {
    var _result = [];
    for (var _i = 0; _i < length; ++_i) {
      if (Object.prototype.hasOwnProperty.call(obj2, _i)) {
        _result.push(mapFn.call(thisArg, obj2[_i], _i));
      }
    }
    return _result;
  }
  return [];
};
var arrayFrom$1 = arrayFrom;
var isFinitePolyfill = Number.isFinite || function(value2) {
  return typeof value2 === "number" && isFinite(value2);
};
var isFinite$1 = isFinitePolyfill;
function _typeof$2(obj2) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj3) {
      return typeof obj3;
    };
  } else {
    _typeof$2 = function _typeof2(obj3) {
      return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
    };
  }
  return _typeof$2(obj2);
}
function safeArrayFrom(collection) {
  var mapFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(item) {
    return item;
  };
  if (collection == null || _typeof$2(collection) !== "object") {
    return null;
  }
  if (Array.isArray(collection)) {
    return collection.map(mapFn);
  }
  var iteratorMethod = collection[SYMBOL_ITERATOR];
  if (typeof iteratorMethod === "function") {
    var iterator = iteratorMethod.call(collection);
    var result2 = [];
    var step;
    for (var i2 = 0; !(step = iterator.next()).done; ++i2) {
      result2.push(mapFn(step.value, i2));
    }
    return result2;
  }
  var length = collection.length;
  if (typeof length === "number" && length >= 0 && length % 1 === 0) {
    var _result = [];
    for (var _i = 0; _i < length; ++_i) {
      if (!Object.prototype.hasOwnProperty.call(collection, _i)) {
        return null;
      }
      _result.push(mapFn(collection[String(_i)], _i));
    }
    return _result;
  }
  return null;
}
var isInteger$1 = Number.isInteger || function(value2) {
  return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
};
var isInteger$2 = isInteger$1;
var MAX_INT = 2147483647;
var MIN_INT = -2147483648;
function serializeInt(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue ? 1 : 0;
  }
  var num = coercedValue;
  if (typeof coercedValue === "string" && coercedValue !== "") {
    num = Number(coercedValue);
  }
  if (!isInteger$2(num)) {
    throw new GraphQLError("Int cannot represent non-integer value: ".concat(inspect$1(coercedValue)));
  }
  if (num > MAX_INT || num < MIN_INT) {
    throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect$1(coercedValue));
  }
  return num;
}
function coerceInt(inputValue) {
  if (!isInteger$2(inputValue)) {
    throw new GraphQLError("Int cannot represent non-integer value: ".concat(inspect$1(inputValue)));
  }
  if (inputValue > MAX_INT || inputValue < MIN_INT) {
    throw new GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(inputValue));
  }
  return inputValue;
}
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize: serializeInt,
  parseValue: coerceInt,
  parseLiteral: function parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError("Int cannot represent non-integer value: ".concat(print(valueNode)), valueNode);
    }
    var num = parseInt(valueNode.value, 10);
    if (num > MAX_INT || num < MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(valueNode.value), valueNode);
    }
    return num;
  }
});
function serializeFloat(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue ? 1 : 0;
  }
  var num = coercedValue;
  if (typeof coercedValue === "string" && coercedValue !== "") {
    num = Number(coercedValue);
  }
  if (!isFinite$1(num)) {
    throw new GraphQLError("Float cannot represent non numeric value: ".concat(inspect$1(coercedValue)));
  }
  return num;
}
function coerceFloat(inputValue) {
  if (!isFinite$1(inputValue)) {
    throw new GraphQLError("Float cannot represent non numeric value: ".concat(inspect$1(inputValue)));
  }
  return inputValue;
}
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize: serializeFloat,
  parseValue: coerceFloat,
  parseLiteral: function parseLiteral2(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("Float cannot represent non numeric value: ".concat(print(valueNode)), valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
function serializeObject(outputValue) {
  if (isObjectLike$8(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      var valueOfResult = outputValue.valueOf();
      if (!isObjectLike$8(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
function serializeString(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "string") {
    return coercedValue;
  }
  if (typeof coercedValue === "boolean") {
    return coercedValue ? "true" : "false";
  }
  if (isFinite$1(coercedValue)) {
    return coercedValue.toString();
  }
  throw new GraphQLError("String cannot represent value: ".concat(inspect$1(outputValue)));
}
function coerceString(inputValue) {
  if (typeof inputValue !== "string") {
    throw new GraphQLError("String cannot represent a non string value: ".concat(inspect$1(inputValue)));
  }
  return inputValue;
}
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize: serializeString,
  parseValue: coerceString,
  parseLiteral: function parseLiteral3(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError("String cannot represent a non string value: ".concat(print(valueNode)), valueNode);
    }
    return valueNode.value;
  }
});
function serializeBoolean(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue;
  }
  if (isFinite$1(coercedValue)) {
    return coercedValue !== 0;
  }
  throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(inspect$1(coercedValue)));
}
function coerceBoolean(inputValue) {
  if (typeof inputValue !== "boolean") {
    throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(inspect$1(inputValue)));
  }
  return inputValue;
}
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize: serializeBoolean,
  parseValue: coerceBoolean,
  parseLiteral: function parseLiteral4(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(print(valueNode)), valueNode);
    }
    return valueNode.value;
  }
});
function serializeID(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "string") {
    return coercedValue;
  }
  if (isInteger$2(coercedValue)) {
    return String(coercedValue);
  }
  throw new GraphQLError("ID cannot represent value: ".concat(inspect$1(outputValue)));
}
function coerceID(inputValue) {
  if (typeof inputValue === "string") {
    return inputValue;
  }
  if (isInteger$2(inputValue)) {
    return inputValue.toString();
  }
  throw new GraphQLError("ID cannot represent value: ".concat(inspect$1(inputValue)));
}
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize: serializeID,
  parseValue: coerceID,
  parseLiteral: function parseLiteral5(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), valueNode);
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
function isSpecifiedScalarType(type2) {
  return specifiedScalarTypes.some(function(_ref2) {
    var name = _ref2.name;
    return type2.name === name;
  });
}
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    var astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    var items = safeArrayFrom(value2);
    if (items != null) {
      var valuesNodes = [];
      for (var _i2 = 0; _i2 < items.length; _i2++) {
        var item = items[_i2];
        var itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike$8(value2)) {
      return null;
    }
    var fieldNodes = [];
    for (var _i4 = 0, _objectValues2 = objectValues$1(type2.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    var serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && isFinite$1(serialized)) {
      var stringNum = String(serialized);
      return integerStringRegExp$1.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp$1.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError("Cannot convert value to AST: ".concat(inspect$1(serialized), "."));
  }
  invariant(0, "Unexpected input type: " + inspect$1(type2));
}
var integerStringRegExp$1 = /^-?(?:0|[1-9][0-9]*)$/;
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: function fields2() {
    return {
      description: {
        type: GraphQLString,
        resolve: function resolve5(schema2) {
          return schema2.description;
        }
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
        resolve: function resolve5(schema2) {
          return objectValues$1(schema2.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new GraphQLNonNull(__Type),
        resolve: function resolve5(schema2) {
          return schema2.getQueryType();
        }
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: __Type,
        resolve: function resolve5(schema2) {
          return schema2.getMutationType();
        }
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: __Type,
        resolve: function resolve5(schema2) {
          return schema2.getSubscriptionType();
        }
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
        resolve: function resolve5(schema2) {
          return schema2.getDirectives();
        }
      }
    };
  }
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: function fields3() {
    return {
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: function resolve5(directive2) {
          return directive2.name;
        }
      },
      description: {
        type: GraphQLString,
        resolve: function resolve5(directive2) {
          return directive2.description;
        }
      },
      isRepeatable: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: function resolve5(directive2) {
          return directive2.isRepeatable;
        }
      },
      locations: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
        resolve: function resolve5(directive2) {
          return directive2.locations;
        }
      },
      args: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve: function resolve5(field, _ref2) {
          var includeDeprecated = _ref2.includeDeprecated;
          return includeDeprecated ? field.args : field.args.filter(function(arg) {
            return arg.deprecationReason == null;
          });
        }
      }
    };
  }
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: function fields4() {
    return {
      kind: {
        type: new GraphQLNonNull(__TypeKind),
        resolve: function resolve5(type2) {
          if (isScalarType(type2)) {
            return TypeKind.SCALAR;
          }
          if (isObjectType(type2)) {
            return TypeKind.OBJECT;
          }
          if (isInterfaceType(type2)) {
            return TypeKind.INTERFACE;
          }
          if (isUnionType(type2)) {
            return TypeKind.UNION;
          }
          if (isEnumType(type2)) {
            return TypeKind.ENUM;
          }
          if (isInputObjectType(type2)) {
            return TypeKind.INPUT_OBJECT;
          }
          if (isListType(type2)) {
            return TypeKind.LIST;
          }
          if (isNonNullType(type2)) {
            return TypeKind.NON_NULL;
          }
          invariant(0, 'Unexpected type: "'.concat(inspect$1(type2), '".'));
        }
      },
      name: {
        type: GraphQLString,
        resolve: function resolve5(type2) {
          return type2.name !== void 0 ? type2.name : void 0;
        }
      },
      description: {
        type: GraphQLString,
        resolve: function resolve5(type2) {
          return type2.description !== void 0 ? type2.description : void 0;
        }
      },
      specifiedByUrl: {
        type: GraphQLString,
        resolve: function resolve5(obj2) {
          return obj2.specifiedByUrl !== void 0 ? obj2.specifiedByUrl : void 0;
        }
      },
      fields: {
        type: new GraphQLList(new GraphQLNonNull(__Field)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve: function resolve5(type2, _ref2) {
          var includeDeprecated = _ref2.includeDeprecated;
          if (isObjectType(type2) || isInterfaceType(type2)) {
            var fields8 = objectValues$1(type2.getFields());
            return includeDeprecated ? fields8 : fields8.filter(function(field) {
              return field.deprecationReason == null;
            });
          }
        }
      },
      interfaces: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve: function resolve5(type2) {
          if (isObjectType(type2) || isInterfaceType(type2)) {
            return type2.getInterfaces();
          }
        }
      },
      possibleTypes: {
        type: new GraphQLList(new GraphQLNonNull(__Type)),
        resolve: function resolve5(type2, _args, _context, _ref3) {
          var schema2 = _ref3.schema;
          if (isAbstractType(type2)) {
            return schema2.getPossibleTypes(type2);
          }
        }
      },
      enumValues: {
        type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve: function resolve5(type2, _ref4) {
          var includeDeprecated = _ref4.includeDeprecated;
          if (isEnumType(type2)) {
            var values = type2.getValues();
            return includeDeprecated ? values : values.filter(function(field) {
              return field.deprecationReason == null;
            });
          }
        }
      },
      inputFields: {
        type: new GraphQLList(new GraphQLNonNull(__InputValue)),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve: function resolve5(type2, _ref5) {
          var includeDeprecated = _ref5.includeDeprecated;
          if (isInputObjectType(type2)) {
            var values = objectValues$1(type2.getFields());
            return includeDeprecated ? values : values.filter(function(field) {
              return field.deprecationReason == null;
            });
          }
        }
      },
      ofType: {
        type: __Type,
        resolve: function resolve5(type2) {
          return type2.ofType !== void 0 ? type2.ofType : void 0;
        }
      }
    };
  }
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: function fields5() {
    return {
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: function resolve5(field) {
          return field.name;
        }
      },
      description: {
        type: GraphQLString,
        resolve: function resolve5(field) {
          return field.description;
        }
      },
      args: {
        type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
        args: {
          includeDeprecated: {
            type: GraphQLBoolean,
            defaultValue: false
          }
        },
        resolve: function resolve5(field, _ref6) {
          var includeDeprecated = _ref6.includeDeprecated;
          return includeDeprecated ? field.args : field.args.filter(function(arg) {
            return arg.deprecationReason == null;
          });
        }
      },
      type: {
        type: new GraphQLNonNull(__Type),
        resolve: function resolve5(field) {
          return field.type;
        }
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: function resolve5(field) {
          return field.deprecationReason != null;
        }
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: function resolve5(field) {
          return field.deprecationReason;
        }
      }
    };
  }
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: function fields6() {
    return {
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: function resolve5(inputValue) {
          return inputValue.name;
        }
      },
      description: {
        type: GraphQLString,
        resolve: function resolve5(inputValue) {
          return inputValue.description;
        }
      },
      type: {
        type: new GraphQLNonNull(__Type),
        resolve: function resolve5(inputValue) {
          return inputValue.type;
        }
      },
      defaultValue: {
        type: GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve: function resolve5(inputValue) {
          var type2 = inputValue.type, defaultValue = inputValue.defaultValue;
          var valueAST = astFromValue(defaultValue, type2);
          return valueAST ? print(valueAST) : null;
        }
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: function resolve5(field) {
          return field.deprecationReason != null;
        }
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: function resolve5(obj2) {
          return obj2.deprecationReason;
        }
      }
    };
  }
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: function fields7() {
    return {
      name: {
        type: new GraphQLNonNull(GraphQLString),
        resolve: function resolve5(enumValue) {
          return enumValue.name;
        }
      },
      description: {
        type: GraphQLString,
        resolve: function resolve5(enumValue) {
          return enumValue.description;
        }
      },
      isDeprecated: {
        type: new GraphQLNonNull(GraphQLBoolean),
        resolve: function resolve5(enumValue) {
          return enumValue.deprecationReason != null;
        }
      },
      deprecationReason: {
        type: GraphQLString,
        resolve: function resolve5(enumValue) {
          return enumValue.deprecationReason;
        }
      }
    };
  }
});
var TypeKind = Object.freeze({
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  INPUT_OBJECT: "INPUT_OBJECT",
  LIST: "LIST",
  NON_NULL: "NON_NULL"
});
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: function resolve(_source, _args, _context, _ref7) {
    var schema2 = _ref7.schema;
    return schema2;
  },
  isDeprecated: false,
  deprecationReason: void 0,
  extensions: void 0,
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [{
    name: "name",
    description: void 0,
    type: new GraphQLNonNull(GraphQLString),
    defaultValue: void 0,
    deprecationReason: void 0,
    extensions: void 0,
    astNode: void 0
  }],
  resolve: function resolve2(_source, _ref8, _context, _ref9) {
    var name = _ref8.name;
    var schema2 = _ref9.schema;
    return schema2.getType(name);
  },
  isDeprecated: false,
  deprecationReason: void 0,
  extensions: void 0,
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: function resolve3(_source, _args, _context, _ref10) {
    var parentType = _ref10.parentType;
    return parentType.name;
  },
  isDeprecated: false,
  deprecationReason: void 0,
  extensions: void 0,
  astNode: void 0
};
var introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
function isIntrospectionType(type2) {
  return introspectionTypes.some(function(_ref11) {
    var name = _ref11.name;
    return type2.name === name;
  });
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function isDirective(directive2) {
  return instanceOf(directive2, GraphQLDirective);
}
function assertDirective(directive2) {
  if (!isDirective(directive2)) {
    throw new Error("Expected ".concat(inspect$1(directive2), " to be a GraphQL directive."));
  }
  return directive2;
}
var GraphQLDirective = /* @__PURE__ */ function() {
  function GraphQLDirective2(config2) {
    var _config$isRepeatable, _config$args;
    this.name = config2.name;
    this.description = config2.description;
    this.locations = config2.locations;
    this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    config2.name || devAssert(0, "Directive must be named.");
    Array.isArray(config2.locations) || devAssert(0, "@".concat(config2.name, " locations must be an Array."));
    var args2 = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike$8(args2) && !Array.isArray(args2) || devAssert(0, "@".concat(config2.name, " args must be an object with argument names as keys."));
    this.args = objectEntries$1(args2).map(function(_ref2) {
      var argName = _ref2[0], argConfig = _ref2[1];
      return {
        name: argName,
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: argConfig.extensions && toObjMap(argConfig.extensions),
        astNode: argConfig.astNode
      };
    });
  }
  var _proto = GraphQLDirective2.prototype;
  _proto.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  };
  _proto.toString = function toString5() {
    return "@" + this.name;
  };
  _proto.toJSON = function toJSON3() {
    return this.toString();
  };
  _createClass$1(GraphQLDirective2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLDirective";
    }
  }]);
  return GraphQLDirective2;
}();
defineInspect(GraphQLDirective);
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ARGUMENT_DEFINITION, DirectiveLocation.INPUT_FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behaviour of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behaviour of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective]);
function isSpecifiedDirective(directive2) {
  return specifiedDirectives.some(function(_ref2) {
    var name = _ref2.name;
    return name === directive2.name;
  });
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function isSchema(schema2) {
  return instanceOf(schema2, GraphQLSchema);
}
function assertSchema(schema2) {
  if (!isSchema(schema2)) {
    throw new Error("Expected ".concat(inspect$1(schema2), " to be a GraphQL schema."));
  }
  return schema2;
}
var GraphQLSchema = /* @__PURE__ */ function() {
  function GraphQLSchema2(config2) {
    var _config$directives;
    this.__validationErrors = config2.assumeValid === true ? [] : void 0;
    isObjectLike$8(config2) || devAssert(0, "Must provide configuration object.");
    !config2.types || Array.isArray(config2.types) || devAssert(0, '"types" must be Array if provided but got: '.concat(inspect$1(config2.types), "."));
    !config2.directives || Array.isArray(config2.directives) || devAssert(0, '"directives" must be Array if provided but got: ' + "".concat(inspect$1(config2.directives), "."));
    this.description = config2.description;
    this.extensions = config2.extensions && toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = config2.extensionASTNodes;
    this._queryType = config2.query;
    this._mutationType = config2.mutation;
    this._subscriptionType = config2.subscription;
    this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    var allReferencedTypes = new Set(config2.types);
    if (config2.types != null) {
      for (var _i2 = 0, _config$types2 = config2.types; _i2 < _config$types2.length; _i2++) {
        var type2 = _config$types2[_i2];
        allReferencedTypes.delete(type2);
        collectReferencedTypes(type2, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {
      var directive2 = _this$_directives2[_i4];
      if (isDirective(directive2)) {
        for (var _i6 = 0, _directive$args2 = directive2.args; _i6 < _directive$args2.length; _i6++) {
          var arg = _directive$args2[_i6];
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (var _i8 = 0, _arrayFrom2 = arrayFrom$1(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {
      var namedType = _arrayFrom2[_i8];
      if (namedType == null) {
        continue;
      }
      var typeName = namedType.name;
      typeName || devAssert(0, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== void 0) {
        throw new Error('Schema must contain uniquely named types but contains multiple types named "'.concat(typeName, '".'));
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {
          var iface = _namedType$getInterfa2[_i10];
          if (isInterfaceType(iface)) {
            var implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {
          var _iface = _namedType$getInterfa4[_i12];
          if (isInterfaceType(_iface)) {
            var _implementations = this._implementationsMap[_iface.name];
            if (_implementations === void 0) {
              _implementations = this._implementationsMap[_iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            _implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  var _proto = GraphQLSchema2.prototype;
  _proto.getQueryType = function getQueryType() {
    return this._queryType;
  };
  _proto.getMutationType = function getMutationType() {
    return this._mutationType;
  };
  _proto.getSubscriptionType = function getSubscriptionType() {
    return this._subscriptionType;
  };
  _proto.getTypeMap = function getTypeMap() {
    return this._typeMap;
  };
  _proto.getType = function getType(name) {
    return this.getTypeMap()[name];
  };
  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  };
  _proto.getImplementations = function getImplementations2(interfaceType) {
    var implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  };
  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
    return this.isSubType(abstractType, possibleType);
  };
  _proto.isSubType = function isSubType(abstractType, maybeSubType) {
    var map2 = this._subTypeMap[abstractType.name];
    if (map2 === void 0) {
      map2 = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {
          var type2 = _abstractType$getType2[_i14];
          map2[type2.name] = true;
        }
      } else {
        var implementations = this.getImplementations(abstractType);
        for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {
          var _type = _implementations$obje2[_i16];
          map2[_type.name] = true;
        }
        for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {
          var _type2 = _implementations$inte2[_i18];
          map2[_type2.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map2;
    }
    return map2[maybeSubType.name] !== void 0;
  };
  _proto.getDirectives = function getDirectives() {
    return this._directives;
  };
  _proto.getDirective = function getDirective(name) {
    return find$1(this.getDirectives(), function(directive2) {
      return directive2.name === name;
    });
  };
  _proto.toConfig = function toConfig() {
    var _this$extensionASTNod;
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: objectValues$1(this.getTypeMap()),
      directives: this.getDirectives().slice(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],
      assumeValid: this.__validationErrors !== void 0
    };
  };
  _createClass(GraphQLSchema2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get3() {
      return "GraphQLSchema";
    }
  }]);
  return GraphQLSchema2;
}();
function collectReferencedTypes(type2, typeSet) {
  var namedType = getNamedType(type2);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {
        var memberType = _namedType$getTypes2[_i20];
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {
        var interfaceType = _namedType$getInterfa6[_i22];
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (var _i24 = 0, _objectValues2 = objectValues$1(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {
        var field = _objectValues2[_i24];
        collectReferencedTypes(field.type, typeSet);
        for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {
          var arg = _field$args2[_i26];
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (var _i28 = 0, _objectValues4 = objectValues$1(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {
        var _field = _objectValues4[_i28];
        collectReferencedTypes(_field.type, typeSet);
      }
    }
  }
  return typeSet;
}
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  var context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  var errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  var errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
var SchemaValidationContext = /* @__PURE__ */ function() {
  function SchemaValidationContext2(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  var _proto = SchemaValidationContext2.prototype;
  _proto.reportError = function reportError(message, nodes) {
    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this.addError(new GraphQLError(message, _nodes));
  };
  _proto.addError = function addError(error2) {
    this._errors.push(error2);
  };
  _proto.getErrors = function getErrors() {
    return this._errors;
  };
  return SchemaValidationContext2;
}();
function validateRootTypes(context) {
  var schema2 = context.schema;
  var queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError("Query root type must be Object type, it cannot be ".concat(inspect$1(queryType), "."), (_getOperationTypeNode = getOperationTypeNode(schema2, "query")) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
  }
  var mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + "".concat(inspect$1(mutationType), "."), (_getOperationTypeNode2 = getOperationTypeNode(schema2, "mutation")) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
  }
  var subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + "".concat(inspect$1(subscriptionType), "."), (_getOperationTypeNode3 = getOperationTypeNode(schema2, "subscription")) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
}
function getOperationTypeNode(schema2, operation) {
  var operationNodes = getAllSubNodes(schema2, function(node2) {
    return node2.operationTypes;
  });
  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {
    var node = operationNodes[_i2];
    if (node.operation === operation) {
      return node.type;
    }
  }
  return void 0;
}
function validateDirectives(context) {
  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {
    var directive2 = _context$schema$getDi2[_i4];
    if (!isDirective(directive2)) {
      context.reportError("Expected directive but got: ".concat(inspect$1(directive2), "."), directive2 === null || directive2 === void 0 ? void 0 : directive2.astNode);
      continue;
    }
    validateName(context, directive2);
    for (var _i6 = 0, _directive$args2 = directive2.args; _i6 < _directive$args2.length; _i6++) {
      var arg = _directive$args2[_i6];
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError("The type of @".concat(directive2.name, "(").concat(arg.name, ":) must be Input Type ") + "but got: ".concat(inspect$1(arg.type), "."), arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError("Required argument @".concat(directive2.name, "(").concat(arg.name, ":) cannot be deprecated."), [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
        ]);
      }
    }
  }
}
function validateName(context, node) {
  var error2 = isValidNameError(node.name);
  if (error2) {
    context.addError(locatedError(error2, node.astNode));
  }
}
function validateTypes(context) {
  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  var typeMap = context.schema.getTypeMap();
  for (var _i8 = 0, _objectValues2 = objectValues$1(typeMap); _i8 < _objectValues2.length; _i8++) {
    var type2 = _objectValues2[_i8];
    if (!isNamedType(type2)) {
      context.reportError("Expected GraphQL named type but got: ".concat(inspect$1(type2), "."), type2.astNode);
      continue;
    }
    if (!isIntrospectionType(type2)) {
      validateName(context, type2);
    }
    if (isObjectType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isInterfaceType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isUnionType(type2)) {
      validateUnionMembers(context, type2);
    } else if (isEnumType(type2)) {
      validateEnumValues(context, type2);
    } else if (isInputObjectType(type2)) {
      validateInputFields(context, type2);
      validateInputObjectCircularRefs(type2);
    }
  }
}
function validateFields(context, type2) {
  var fields8 = objectValues$1(type2.getFields());
  if (fields8.length === 0) {
    context.reportError("Type ".concat(type2.name, " must define one or more fields."), getAllNodes(type2));
  }
  for (var _i10 = 0; _i10 < fields8.length; _i10++) {
    var field = fields8[_i10];
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError("The type of ".concat(type2.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat(inspect$1(field.type), "."), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
    }
    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {
      var arg = _field$args2[_i12];
      var argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError("The type of ".concat(type2.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat(inspect$1(arg.type), "."), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError("Required argument ".concat(type2.name, ".").concat(field.name, "(").concat(argName, ":) cannot be deprecated."), [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
        ]);
      }
    }
  }
}
function validateInterfaces(context, type2) {
  var ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (var _i14 = 0, _type$getInterfaces2 = type2.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {
    var iface = _type$getInterfaces2[_i14];
    if (!isInterfaceType(iface)) {
      context.reportError("Type ".concat(inspect$1(type2), " must only implement Interface types, ") + "it cannot implement ".concat(inspect$1(iface), "."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (type2 === iface) {
      context.reportError("Type ".concat(type2.name, " cannot implement itself because it would create a circular reference."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError("Type ".concat(type2.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type2, iface);
    validateTypeImplementsInterface(context, type2, iface);
  }
}
function validateTypeImplementsInterface(context, type2, iface) {
  var typeFieldMap = type2.getFields();
  for (var _i16 = 0, _objectValues4 = objectValues$1(iface.getFields()); _i16 < _objectValues4.length; _i16++) {
    var ifaceField = _objectValues4[_i16];
    var fieldName = ifaceField.name;
    var typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(type2.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(type2)));
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat(inspect$1(ifaceField.type), " but ").concat(type2.name, ".").concat(fieldName, " ") + "is type ".concat(inspect$1(typeField.type), "."), [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
      ]);
    }
    var _loop = function _loop3(_i182, _ifaceField$args22) {
      var ifaceArg = _ifaceField$args22[_i182];
      var argName = ifaceArg.name;
      var typeArg = find$1(typeField.args, function(arg) {
        return arg.name === argName;
      });
      if (!typeArg) {
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(type2.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, typeField.astNode]);
        return "continue";
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat(inspect$1(ifaceArg.type), " but ") + "".concat(type2.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat(inspect$1(typeArg.type), "."), [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
        ]);
      }
    };
    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {
      var _ret = _loop(_i18, _ifaceField$args2);
      if (_ret === "continue")
        continue;
    }
    var _loop2 = function _loop22(_i202, _typeField$args22) {
      var typeArg = _typeField$args22[_i202];
      var argName = typeArg.name;
      var ifaceArg = find$1(ifaceField.args, function(arg) {
        return arg.name === argName;
      });
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError("Object field ".concat(type2.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [typeArg.astNode, ifaceField.astNode]);
      }
    };
    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {
      _loop2(_i20, _typeField$args2);
    }
  }
}
function validateTypeImplementsAncestors(context, type2, iface) {
  var ifaceInterfaces = type2.getInterfaces();
  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {
    var transitive = _iface$getInterfaces2[_i22];
    if (ifaceInterfaces.indexOf(transitive) === -1) {
      context.reportError(transitive === type2 ? "Type ".concat(type2.name, " cannot implement ").concat(iface.name, " because it would create a circular reference.") : "Type ".concat(type2.name, " must implement ").concat(transitive.name, " because it is implemented by ").concat(iface.name, "."), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type2, iface)));
    }
  }
}
function validateUnionMembers(context, union) {
  var memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
  }
  var includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {
    var memberType = memberTypes[_i24];
    if (includedTypeNames[memberType.name]) {
      context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat(inspect$1(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
}
function validateEnumValues(context, enumType) {
  var enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
  }
  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {
    var enumValue = enumValues[_i26];
    var valueName = enumValue.name;
    validateName(context, enumValue);
    if (valueName === "true" || valueName === "false" || valueName === "null") {
      context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
    }
  }
}
function validateInputFields(context, inputObj) {
  var fields8 = objectValues$1(inputObj.getFields());
  if (fields8.length === 0) {
    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
  }
  for (var _i28 = 0; _i28 < fields8.length; _i28++) {
    var field = fields8[_i28];
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat(inspect$1(field.type), "."), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError("Required input field ".concat(inputObj.name, ".").concat(field.name, " cannot be deprecated."), [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
      ]);
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  var visitedTypes = /* @__PURE__ */ Object.create(null);
  var fieldPath = [];
  var fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    var fields8 = objectValues$1(inputObj.getFields());
    for (var _i30 = 0; _i30 < fields8.length; _i30++) {
      var field = fields8[_i30];
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        var fieldType = field.type.ofType;
        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          var cyclePath = fieldPath.slice(cycleIndex);
          var pathStr = cyclePath.map(function(fieldObj) {
            return fieldObj.name;
          }).join(".");
          context.reportError('Cannot reference Input Object "'.concat(fieldType.name, '" within itself through a series of non-null fields: "').concat(pathStr, '".'), cyclePath.map(function(fieldObj) {
            return fieldObj.astNode;
          }));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllNodes(object) {
  var astNode = object.astNode, extensionASTNodes = object.extensionASTNodes;
  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];
}
function getAllSubNodes(object, getter) {
  var subNodes = [];
  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {
    var _getter;
    var node = _getAllNodes2[_i32];
    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);
  }
  return subNodes;
}
function getAllImplementsInterfaceNodes(type2, iface) {
  return getAllSubNodes(type2, function(typeNode) {
    return typeNode.interfaces;
  }).filter(function(ifaceNode) {
    return ifaceNode.name.value === iface.name;
  });
}
function getUnionMemberTypeNodes(union, typeName) {
  return getAllSubNodes(union, function(unionNode) {
    return unionNode.types;
  }).filter(function(typeNode) {
    return typeNode.name.value === typeName;
  });
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function(node) {
    return node.name.value === GraphQLDeprecatedDirective.name;
  });
}
function typeFromAST(schema2, typeNode) {
  var innerType;
  if (typeNode.kind === Kind.LIST_TYPE) {
    innerType = typeFromAST(schema2, typeNode.type);
    return innerType && new GraphQLList(innerType);
  }
  if (typeNode.kind === Kind.NON_NULL_TYPE) {
    innerType = typeFromAST(schema2, typeNode.type);
    return innerType && new GraphQLNonNull(innerType);
  }
  if (typeNode.kind === Kind.NAMED_TYPE) {
    return schema2.getType(typeNode.name.value);
  }
  invariant(0, "Unexpected type node: " + inspect$1(typeNode));
}
var TypeInfo = /* @__PURE__ */ function() {
  function TypeInfo2(schema2, getFieldDefFn, initialType) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  var _proto = TypeInfo2.prototype;
  _proto.getType = function getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  };
  _proto.getParentType = function getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  };
  _proto.getInputType = function getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  };
  _proto.getParentInputType = function getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  };
  _proto.getFieldDef = function getFieldDef2() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  };
  _proto.getDefaultValue = function getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  };
  _proto.getDirective = function getDirective() {
    return this._directive;
  };
  _proto.getArgument = function getArgument() {
    return this._argument;
  };
  _proto.getEnumValue = function getEnumValue() {
    return this._enumValue;
  };
  _proto.enter = function enter(node) {
    var schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        var namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : void 0);
        break;
      }
      case Kind.FIELD: {
        var parentType = this.getParentType();
        var fieldDef;
        var fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        var type2;
        switch (node.operation) {
          case "query":
            type2 = schema2.getQueryType();
            break;
          case "mutation":
            type2 = schema2.getMutationType();
            break;
          case "subscription":
            type2 = schema2.getSubscriptionType();
            break;
        }
        this._typeStack.push(isObjectType(type2) ? type2 : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        var typeConditionAST = node.typeCondition;
        var outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        var inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : void 0);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        var argDef;
        var argType;
        var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = find$1(fieldOrDirective.args, function(arg) {
            return arg.name === node.name.value;
          });
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        var listType = getNullableType(this.getInputType());
        var itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        var objectType = getNamedType(this.getInputType());
        var inputFieldType;
        var inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : void 0);
        break;
      }
      case Kind.ENUM: {
        var enumType = getNamedType(this.getInputType());
        var enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
    }
  };
  _proto.leave = function leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
    }
  };
  return TypeInfo2;
}();
function getFieldDef(schema2, parentType, fieldNode) {
  var name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn2 = getVisitFn(visitor, node.kind, false);
      if (fn2) {
        var result2 = fn2.apply(visitor, arguments);
        if (result2 !== void 0) {
          typeInfo.leave(node);
          if (isNode$1(result2)) {
            typeInfo.enter(result2);
          }
        }
        return result2;
      }
    },
    leave: function leave(node) {
      var fn2 = getVisitFn(visitor, node.kind, true);
      var result2;
      if (fn2) {
        result2 = fn2.apply(visitor, arguments);
      }
      typeInfo.leave(node);
      return result2;
    }
  };
}
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
function ExecutableDefinitionsRule(context) {
  return {
    Document: function Document3(node) {
      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {
        var definition = _node$definitions2[_i2];
        if (!isExecutableDefinitionNode(definition)) {
          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(new GraphQLError("The ".concat(defName, " definition is not executable."), definition));
        }
      }
      return false;
    }
  };
}
function UniqueOperationNamesRule(context) {
  var knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2(node) {
      var operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError('There can be only one operation named "'.concat(operationName.value, '".'), [knownOperationNames[operationName.value], operationName]));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: function FragmentDefinition2() {
      return false;
    }
  };
}
function LoneAnonymousOperationRule(context) {
  var operationCount = 0;
  return {
    Document: function Document3(node) {
      operationCount = node.definitions.filter(function(definition) {
        return definition.kind === Kind.OPERATION_DEFINITION;
      }).length;
    },
    OperationDefinition: function OperationDefinition2(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", node));
      }
    }
  };
}
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition: function OperationDefinition2(node) {
      if (node.operation === "subscription") {
        if (node.selectionSet.selections.length !== 1) {
          context.reportError(new GraphQLError(node.name ? 'Subscription "'.concat(node.name.value, '" must select only one top level field.') : "Anonymous Subscription must select only one top level field.", node.selectionSet.selections.slice(1)));
        }
      }
    }
  };
}
function KnownTypeNamesRule(context) {
  var schema2 = context.getSchema();
  var existingTypesMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  var definedTypes = /* @__PURE__ */ Object.create(null);
  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
  return {
    NamedType: function NamedType2(node, _1, parent, _2, ancestors) {
      var typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        var isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && isStandardTypeName(typeName)) {
          return;
        }
        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError('Unknown type "'.concat(typeName, '".') + didYouMean(suggestedTypes), node));
      }
    }
  };
}
var standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function(type2) {
  return type2.name;
});
function isStandardTypeName(typeName) {
  return standardTypeNames.indexOf(typeName) !== -1;
}
function isSDLNode(value2) {
  return !Array.isArray(value2) && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment: function InlineFragment2(node) {
      var typeCondition = node.typeCondition;
      if (typeCondition) {
        var type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          var typeStr = print(typeCondition);
          context.reportError(new GraphQLError('Fragment cannot condition on non composite type "'.concat(typeStr, '".'), typeCondition));
        }
      }
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      var type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        var typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError('Fragment "'.concat(node.name.value, '" cannot condition on non composite type "').concat(typeStr, '".'), node.typeCondition));
      }
    }
  };
}
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition: function VariableDefinition2(node) {
      var type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 && !isInputType(type2)) {
        var variableName = node.variable.name.value;
        var typeName = print(node.type);
        context.reportError(new GraphQLError('Variable "$'.concat(variableName, '" cannot be non-input type "').concat(typeName, '".'), node.type));
      }
    }
  };
}
function ScalarLeafsRule(context) {
  return {
    Field: function Field2(node) {
      var type2 = context.getType();
      var selectionSet = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet) {
            var fieldName = node.name.value;
            var typeStr = inspect$1(type2);
            context.reportError(new GraphQLError('Field "'.concat(fieldName, '" must not have a selection since type "').concat(typeStr, '" has no subfields.'), selectionSet));
          }
        } else if (!selectionSet) {
          var _fieldName = node.name.value;
          var _typeStr = inspect$1(type2);
          context.reportError(new GraphQLError('Field "'.concat(_fieldName, '" of type "').concat(_typeStr, '" must have a selection of subfields. Did you mean "').concat(_fieldName, ' { ... }"?'), node));
        }
      }
    }
  };
}
function FieldsOnCorrectTypeRule(context) {
  return {
    Field: function Field2(node) {
      var type2 = context.getParentType();
      if (type2) {
        var fieldDef = context.getFieldDef();
        if (!fieldDef) {
          var schema2 = context.getSchema();
          var fieldName = node.name.value;
          var suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type2, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(new GraphQLError('Cannot query field "'.concat(fieldName, '" on type "').concat(type2.name, '".') + suggestion, node));
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema2, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  var suggestedTypes = /* @__PURE__ */ new Set();
  var usageCount = /* @__PURE__ */ Object.create(null);
  for (var _i2 = 0, _schema$getPossibleTy2 = schema2.getPossibleTypes(type2); _i2 < _schema$getPossibleTy2.length; _i2++) {
    var possibleType = _schema$getPossibleTy2[_i2];
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {
      var _usageCount$possibleI;
      var possibleInterface = _possibleType$getInte2[_i4];
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return arrayFrom$1(suggestedTypes).sort(function(typeA, typeB) {
    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map(function(x2) {
    return x2.name;
  });
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    var possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
function UniqueFragmentNamesRule(context) {
  var knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      var fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError('There can be only one fragment named "'.concat(fragmentName, '".'), [knownFragmentNames[fragmentName], node.name]));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread: function FragmentSpread2(node) {
      var fragmentName = node.name.value;
      var fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError('Unknown fragment "'.concat(fragmentName, '".'), node.name));
      }
    }
  };
}
function NoUnusedFragmentsRule(context) {
  var operationDefs = [];
  var fragmentDefs = [];
  return {
    OperationDefinition: function OperationDefinition2(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave: function leave() {
        var fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {
          var operation = operationDefs[_i2];
          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {
            var fragment = _context$getRecursive2[_i4];
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {
          var fragmentDef = fragmentDefs[_i6];
          var fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError('Fragment "'.concat(fragName, '" is never used.'), fragmentDef));
          }
        }
      }
    }
  };
}
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment: function InlineFragment2(node) {
      var fragType = context.getType();
      var parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        var parentTypeStr = inspect$1(parentType);
        var fragTypeStr = inspect$1(fragType);
        context.reportError(new GraphQLError('Fragment cannot be spread here as objects of type "'.concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
      }
    },
    FragmentSpread: function FragmentSpread2(node) {
      var fragName = node.name.value;
      var fragType = getFragmentType(context, fragName);
      var parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        var parentTypeStr = inspect$1(parentType);
        var fragTypeStr = inspect$1(fragType);
        context.reportError(new GraphQLError('Fragment "'.concat(fragName, '" cannot be spread here as objects of type "').concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
      }
    }
  };
}
function getFragmentType(context, name) {
  var frag = context.getFragment(name);
  if (frag) {
    var type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}
function NoFragmentCyclesRule(context) {
  var visitedFrags = /* @__PURE__ */ Object.create(null);
  var spreadPath = [];
  var spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    var fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {
      var spreadNode = spreadNodes[_i2];
      var spreadName = spreadNode.name.value;
      var cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        var spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        var cyclePath = spreadPath.slice(cycleIndex);
        var viaPath = cyclePath.slice(0, -1).map(function(s) {
          return '"' + s.name.value + '"';
        }).join(", ");
        context.reportError(new GraphQLError('Cannot spread fragment "'.concat(spreadName, '" within itself') + (viaPath !== "" ? " via ".concat(viaPath, ".") : "."), cyclePath));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
function UniqueVariableNamesRule(context) {
  var knownVariableNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      knownVariableNames = /* @__PURE__ */ Object.create(null);
    },
    VariableDefinition: function VariableDefinition2(node) {
      var variableName = node.variable.name.value;
      if (knownVariableNames[variableName]) {
        context.reportError(new GraphQLError('There can be only one variable named "$'.concat(variableName, '".'), [knownVariableNames[variableName], node.variable.name]));
      } else {
        knownVariableNames[variableName] = node.variable.name;
      }
    }
  };
}
function NoUndefinedVariablesRule(context) {
  var variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? 'Variable "$'.concat(varName, '" is not defined by operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(varName, '" is not defined.'), [node, operation]));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
function NoUnusedVariablesRule(context) {
  var variableDefs = [];
  return {
    OperationDefinition: {
      enter: function enter() {
        variableDefs = [];
      },
      leave: function leave(operation) {
        var variableNameUsed = /* @__PURE__ */ Object.create(null);
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          variableNameUsed[node.name.value] = true;
        }
        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {
          var variableDef = _variableDefs2[_i4];
          var variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? 'Variable "$'.concat(variableName, '" is never used in operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(variableName, '" is never used.'), variableDef));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(def) {
      variableDefs.push(def);
    }
  };
}
function KnownDirectivesRule(context) {
  var locationsMap = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  var definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive2 = definedDirectives[_i2];
    locationsMap[directive2.name] = directive2.locations;
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map(function(name) {
        return name.value;
      });
    }
  }
  return {
    Directive: function Directive3(node, _key, _parent, _path, ancestors) {
      var name = node.name.value;
      var locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError('Unknown directive "@'.concat(name, '".'), node));
        return;
      }
      var candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
        context.reportError(new GraphQLError('Directive "@'.concat(name, '" may not be used on ').concat(candidateLocation, "."), node));
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  var appliedTo = ancestors[ancestors.length - 1];
  !Array.isArray(appliedTo) || invariant(0);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      var parentNode = ancestors[ancestors.length - 3];
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case "query":
      return DirectiveLocation.QUERY;
    case "mutation":
      return DirectiveLocation.MUTATION;
    case "subscription":
      return DirectiveLocation.SUBSCRIPTION;
  }
  invariant(0, "Unexpected operation: " + inspect$1(operation));
}
function UniqueDirectivesPerLocationRule(context) {
  var uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  var definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive2 = definedDirectives[_i2];
    uniqueDirectiveMap[directive2.name] = !directive2.isRepeatable;
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  var schemaDirectives = /* @__PURE__ */ Object.create(null);
  var typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    enter: function enter(node) {
      if (node.directives == null) {
        return;
      }
      var seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        var typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {
        var _directive = _node$directives2[_i6];
        var directiveName = _directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError('The directive "@'.concat(directiveName, '" can only be used once at this location.'), [seenDirectives[directiveName], _directive]));
          } else {
            seenDirectives[directiveName] = _directive;
          }
        }
      }
    }
  };
}
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$5(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$5(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function KnownArgumentNamesRule(context) {
  return _objectSpread$3(_objectSpread$3({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
    Argument: function Argument2(argNode) {
      var argDef = context.getArgument();
      var fieldDef = context.getFieldDef();
      var parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        var argName = argNode.name.value;
        var knownArgsNames = fieldDef.args.map(function(arg) {
          return arg.name;
        });
        var suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError('Unknown argument "'.concat(argName, '" on field "').concat(parentType.name, ".").concat(fieldDef.name, '".') + didYouMean(suggestions), argNode));
      }
    }
  });
}
function KnownArgumentNamesOnDirectivesRule(context) {
  var directiveArgs = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  var definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive2 = definedDirectives[_i2];
    directiveArgs[directive2.name] = directive2.args.map(function(arg) {
      return arg.name;
    });
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map(function(arg) {
        return arg.name.value;
      });
    }
  }
  return {
    Directive: function Directive3(directiveNode) {
      var directiveName = directiveNode.name.value;
      var knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {
          var argNode = _directiveNode$argume2[_i6];
          var argName = argNode.name.value;
          if (knownArgs.indexOf(argName) === -1) {
            var suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError('Unknown argument "'.concat(argName, '" on directive "@').concat(directiveName, '".') + didYouMean(suggestions), argNode));
          }
        }
      }
      return false;
    }
  };
}
function UniqueArgumentNamesRule(context) {
  var knownArgNames = /* @__PURE__ */ Object.create(null);
  return {
    Field: function Field2() {
      knownArgNames = /* @__PURE__ */ Object.create(null);
    },
    Directive: function Directive3() {
      knownArgNames = /* @__PURE__ */ Object.create(null);
    },
    Argument: function Argument2(node) {
      var argName = node.name.value;
      if (knownArgNames[argName]) {
        context.reportError(new GraphQLError('There can be only one argument named "'.concat(argName, '".'), [knownArgNames[argName], node.name]));
      } else {
        knownArgNames[argName] = node.name;
      }
      return false;
    }
  };
}
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue: function ListValue2(node) {
      var type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue: function ObjectValue2(node) {
      var type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      var fieldNodeMap = keyMap(node.fields, function(field) {
        return field.name.value;
      });
      for (var _i2 = 0, _objectValues2 = objectValues$1(type2.getFields()); _i2 < _objectValues2.length; _i2++) {
        var fieldDef = _objectValues2[_i2];
        var fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          var typeStr = inspect$1(fieldDef.type);
          context.reportError(new GraphQLError('Field "'.concat(type2.name, ".").concat(fieldDef.name, '" of required type "').concat(typeStr, '" was not provided.'), node));
        }
      }
    },
    ObjectField: function ObjectField2(node) {
      var parentType = getNamedType(context.getParentInputType());
      var fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError('Field "'.concat(node.name.value, '" is not defined by type "').concat(parentType.name, '".') + didYouMean(suggestions), node));
      }
    },
    NullValue: function NullValue2(node) {
      var type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(new GraphQLError('Expected value of type "'.concat(inspect$1(type2), '", found ').concat(print(node), "."), node));
      }
    },
    EnumValue: function EnumValue2(node) {
      return isValidValueNode(context, node);
    },
    IntValue: function IntValue2(node) {
      return isValidValueNode(context, node);
    },
    FloatValue: function FloatValue2(node) {
      return isValidValueNode(context, node);
    },
    StringValue: function StringValue2(node) {
      return isValidValueNode(context, node);
    },
    BooleanValue: function BooleanValue2(node) {
      return isValidValueNode(context, node);
    }
  };
}
function isValidValueNode(context, node) {
  var locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  var type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    var typeStr = inspect$1(locationType);
    context.reportError(new GraphQLError('Expected value of type "'.concat(typeStr, '", found ').concat(print(node), "."), node));
    return;
  }
  try {
    var parseResult = type2.parseLiteral(node, void 0);
    if (parseResult === void 0) {
      var _typeStr = inspect$1(locationType);
      context.reportError(new GraphQLError('Expected value of type "'.concat(_typeStr, '", found ').concat(print(node), "."), node));
    }
  } catch (error2) {
    var _typeStr2 = inspect$1(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(new GraphQLError('Expected value of type "'.concat(_typeStr2, '", found ').concat(print(node), "; ") + error2.message, node, void 0, void 0, void 0, error2));
    }
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$4(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function ProvidedRequiredArgumentsRule(context) {
  return _objectSpread$2(_objectSpread$2({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
    Field: {
      leave: function leave(fieldNode) {
        var _fieldNode$arguments;
        var fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
        var argNodeMap = keyMap(argNodes, function(arg) {
          return arg.name.value;
        });
        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {
          var argDef = _fieldDef$args2[_i2];
          var argNode = argNodeMap[argDef.name];
          if (!argNode && isRequiredArgument(argDef)) {
            var argTypeStr = inspect$1(argDef.type);
            context.reportError(new GraphQLError('Field "'.concat(fieldDef.name, '" argument "').concat(argDef.name, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), fieldNode));
          }
        }
      }
    }
  });
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var requiredArgsMap = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  var definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {
    var directive2 = definedDirectives[_i4];
    requiredArgsMap[directive2.name] = keyMap(directive2.args.filter(isRequiredArgument), function(arg) {
      return arg.name;
    });
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {
    var def = astDefinitions[_i6];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function(arg) {
        return arg.name.value;
      });
    }
  }
  return {
    Directive: {
      leave: function leave(directiveNode) {
        var directiveName = directiveNode.name.value;
        var requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          var argNodeMap = keyMap(_argNodes, function(arg) {
            return arg.name.value;
          });
          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {
            var argName = _Object$keys2[_i8];
            if (!argNodeMap[argName]) {
              var argType = requiredArgs[argName].type;
              var argTypeStr = isType(argType) ? inspect$1(argType) : print(argType);
              context.reportError(new GraphQLError('Directive "@'.concat(directiveName, '" argument "').concat(argName, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), directiveNode));
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
function VariablesInAllowedPositionRule(context) {
  var varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var type2 = _ref2.type;
          var defaultValue = _ref2.defaultValue;
          var varName = node.name.value;
          var varDef = varDefMap[varName];
          if (varDef && type2) {
            var schema2 = context.getSchema();
            var varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type2, defaultValue)) {
              var varTypeStr = inspect$1(varType);
              var typeStr = inspect$1(type2);
              context.reportError(new GraphQLError('Variable "$'.concat(varName, '" of type "').concat(varTypeStr, '" used in position expecting type "').concat(typeStr, '".'), [varDef, node]));
            }
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    var hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    var nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
}
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(function(_ref2) {
      var responseName = _ref2[0], subReason = _ref2[1];
      return 'subfields "'.concat(responseName, '" conflict because ') + reasonMessage(subReason);
    }).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  var comparedFragmentPairs = new PairSet();
  var cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet: function SelectionSet2(selectionSet) {
      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {
        var _ref3 = conflicts[_i2];
        var _ref2$ = _ref3[0];
        var responseName = _ref2$[0];
        var reason = _ref2$[1];
        var fields1 = _ref3[1];
        var fields22 = _ref3[2];
        var reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError('Fields "'.concat(responseName, '" conflict because ').concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields22)));
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  var conflicts = [];
  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (var i2 = 0; i2 < fragmentNames.length; i2++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i2]);
      for (var j2 = i2 + 1; j2 < fragmentNames.length; j2++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i2], fragmentNames[j2]);
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  var fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (var i2 = 0; i2 < fragmentNames2.length; i2++) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i2]);
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  var fragment1 = context.getFragment(fragmentName1);
  var fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (var j2 = 0; j2 < fragmentNames2.length; j2++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j2]);
  }
  for (var i2 = 0; i2 < fragmentNames1.length; i2++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i2], fragmentName2);
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  var conflicts = [];
  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  if (fragmentNames2.length !== 0) {
    for (var j2 = 0; j2 < fragmentNames2.length; j2++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j2]);
    }
  }
  if (fragmentNames1.length !== 0) {
    for (var i2 = 0; i2 < fragmentNames1.length; i2++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i2]);
    }
  }
  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {
    for (var _j = 0; _j < fragmentNames2.length; _j++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (var _i5 = 0, _objectEntries2 = objectEntries$1(fieldMap); _i5 < _objectEntries2.length; _i5++) {
    var _ref5 = _objectEntries2[_i5];
    var responseName = _ref5[0];
    var fields8 = _ref5[1];
    if (fields8.length > 1) {
      for (var i2 = 0; i2 < fields8.length; i2++) {
        for (var j2 = i2 + 1; j2 < fields8.length; j2++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields8[i2], fields8[j2]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {
    var responseName = _Object$keys2[_i7];
    var fields22 = fieldMap2[responseName];
    if (fields22) {
      var fields1 = fieldMap1[responseName];
      for (var i2 = 0; i2 < fields1.length; i2++) {
        for (var j2 = 0; j2 < fields22.length; j2++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i2], fields22[j2]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
  var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    var _node1$arguments, _node2$arguments;
    var name1 = node1.name.value;
    var name2 = node2.name.value;
    if (name1 !== name2) {
      return [[responseName, '"'.concat(name1, '" and "').concat(name2, '" are different fields')], [node1], [node2]];
    }
    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : [];
    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : [];
    if (!sameArguments(args1, args2)) {
      return [[responseName, "they have differing arguments"], [node1], [node2]];
    }
  }
  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [[responseName, 'they return conflicting types "'.concat(inspect$1(type1), '" and "').concat(inspect$1(type2), '"')], [node1], [node2]];
  }
  var selectionSet1 = node1.selectionSet;
  var selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(arguments1, arguments2) {
  if (arguments1.length !== arguments2.length) {
    return false;
  }
  return arguments1.every(function(argument1) {
    var argument2 = find$1(arguments2, function(argument) {
      return argument.name.value === argument1.name.value;
    });
    if (!argument2) {
      return false;
    }
    return sameValue(argument1.value, argument2.value);
  });
}
function sameValue(value1, value2) {
  return print(value1) === print(value2);
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  var cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (!cached) {
    var nodeAndDefs = /* @__PURE__ */ Object.create(null);
    var fragmentNames = /* @__PURE__ */ Object.create(null);
    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
    cached = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, cached);
  }
  return cached;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {
    var selection = _selectionSet$selecti2[_i9];
    switch (selection.kind) {
      case Kind.FIELD: {
        var fieldName = selection.name.value;
        var fieldDef = void 0;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        var responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        var typeCondition = selection.typeCondition;
        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [[responseName, conflicts.map(function(_ref6) {
      var reason = _ref6[0];
      return reason;
    })], conflicts.reduce(function(allFields, _ref7) {
      var fields1 = _ref7[1];
      return allFields.concat(fields1);
    }, [node1]), conflicts.reduce(function(allFields, _ref8) {
      var fields22 = _ref8[2];
      return allFields.concat(fields22);
    }, [node2])];
  }
}
var PairSet = /* @__PURE__ */ function() {
  function PairSet2() {
    this._data = /* @__PURE__ */ Object.create(null);
  }
  var _proto = PairSet2.prototype;
  _proto.has = function has(a, b, areMutuallyExclusive) {
    var first = this._data[a];
    var result2 = first && first[b];
    if (result2 === void 0) {
      return false;
    }
    if (areMutuallyExclusive === false) {
      return result2 === false;
    }
    return true;
  };
  _proto.add = function add2(a, b, areMutuallyExclusive) {
    this._pairSetAdd(a, b, areMutuallyExclusive);
    this._pairSetAdd(b, a, areMutuallyExclusive);
  };
  _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {
    var map2 = this._data[a];
    if (!map2) {
      map2 = /* @__PURE__ */ Object.create(null);
      this._data[a] = map2;
    }
    map2[b] = areMutuallyExclusive;
  };
  return PairSet2;
}();
function UniqueInputFieldNamesRule(context) {
  var knownNameStack = [];
  var knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter: function enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave: function leave() {
        knownNames = knownNameStack.pop();
      }
    },
    ObjectField: function ObjectField2(node) {
      var fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError('There can be only one input field named "'.concat(fieldName, '".'), [knownNames[fieldName], node.name]));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
function LoneSchemaDefinitionRule(context) {
  var _ref2, _ref22, _oldSchema$astNode;
  var oldSchema = context.getSchema();
  var alreadyDefined = (_ref2 = (_ref22 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref22 !== void 0 ? _ref22 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  var schemaDefinitionsCount = 0;
  return {
    SchemaDefinition: function SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", node));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", node));
      }
      ++schemaDefinitionsCount;
    }
  };
}
function UniqueOperationTypesRule(context) {
  var schema2 = context.getSchema();
  var definedOperationTypes = /* @__PURE__ */ Object.create(null);
  var existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {
      var operationType = operationTypesNodes[_i2];
      var operation = operationType.operation;
      var alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError("There can be only one ".concat(operation, " type in schema."), [alreadyDefinedOperationType, operationType]));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
function UniqueTypeNamesRule(context) {
  var knownTypeNames = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    var typeName = node.name.value;
    if (schema2 !== null && schema2 !== void 0 && schema2.getType(typeName)) {
      context.reportError(new GraphQLError('Type "'.concat(typeName, '" already exists in the schema. It cannot also be defined in this type definition.'), node.name));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError('There can be only one type named "'.concat(typeName, '".'), [knownTypeNames[typeName], node.name]));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
function UniqueEnumValueNamesRule(context) {
  var schema2 = context.getSchema();
  var existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  var knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    var typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    var valueNames = knownValueNames[typeName];
    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {
      var valueDef = valueNodes[_i2];
      var valueName = valueDef.name.value;
      var existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" already exists in the schema. It cannot also be defined in this type extension.'), valueDef.name));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" can only be defined once.'), [valueNames[valueName], valueDef.name]));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
function UniqueFieldDefinitionNamesRule(context) {
  var schema2 = context.getSchema();
  var existingTypeMap = schema2 ? schema2.getTypeMap() : /* @__PURE__ */ Object.create(null);
  var knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    var typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    var fieldNames = knownFieldNames[typeName];
    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {
      var fieldDef = fieldNodes[_i2];
      var fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" already exists in the schema. It cannot also be defined in this type extension.'), fieldDef.name));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" can only be defined once.'), [fieldNames[fieldName], fieldDef.name]));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}
function UniqueDirectiveNamesRule(context) {
  var knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  var schema2 = context.getSchema();
  return {
    DirectiveDefinition: function DirectiveDefinition(node) {
      var directiveName = node.name.value;
      if (schema2 !== null && schema2 !== void 0 && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError('Directive "@'.concat(directiveName, '" already exists in the schema. It cannot be redefined.'), node.name));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError('There can be only one directive named "@'.concat(directiveName, '".'), [knownDirectiveNames[directiveName], node.name]));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var _defKindToExtKind;
function _defineProperty$3(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function PossibleTypeExtensionsRule(context) {
  var schema2 = context.getSchema();
  var definedTypes = /* @__PURE__ */ Object.create(null);
  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    var typeName = node.name.value;
    var defNode = definedTypes[typeName];
    var existingType = schema2 === null || schema2 === void 0 ? void 0 : schema2.getType(typeName);
    var expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        var kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError("Cannot extend non-".concat(kindStr, ' type "').concat(typeName, '".'), defNode ? [defNode, node] : node));
      }
    } else {
      var allTypeNames = Object.keys(definedTypes);
      if (schema2) {
        allTypeNames = allTypeNames.concat(Object.keys(schema2.getTypeMap()));
      }
      var suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError('Cannot extend type "'.concat(typeName, '" because it is not defined.') + didYouMean(suggestedTypes), node.name));
    }
  }
}
var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty$3(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty$3(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty$3(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty$3(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty$3(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty$3(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(0, "Unexpected type: " + inspect$1(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
  }
  invariant(0, "Unexpected kind: " + inspect$1(kind));
}
var specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule]);
var specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ASTValidationContext = /* @__PURE__ */ function() {
  function ASTValidationContext2(ast, onError) {
    this._ast = ast;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  var _proto = ASTValidationContext2.prototype;
  _proto.reportError = function reportError(error2) {
    this._onError(error2);
  };
  _proto.getDocument = function getDocument() {
    return this._ast;
  };
  _proto.getFragment = function getFragment(name) {
    var fragments = this._fragments;
    if (!fragments) {
      this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
        if (statement.kind === Kind.FRAGMENT_DEFINITION) {
          frags[statement.name.value] = statement;
        }
        return frags;
      }, /* @__PURE__ */ Object.create(null));
    }
    return fragments[name];
  };
  _proto.getFragmentSpreads = function getFragmentSpreads(node) {
    var spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      var setsToVisit = [node];
      while (setsToVisit.length !== 0) {
        var set2 = setsToVisit.pop();
        for (var _i2 = 0, _set$selections2 = set2.selections; _i2 < _set$selections2.length; _i2++) {
          var selection = _set$selections2[_i2];
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  };
  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
    var fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      var collectedNames = /* @__PURE__ */ Object.create(null);
      var nodesToVisit = [operation.selectionSet];
      while (nodesToVisit.length !== 0) {
        var node = nodesToVisit.pop();
        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {
          var spread = _this$getFragmentSpre2[_i4];
          var fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            var fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  };
  return ASTValidationContext2;
}();
var SDLValidationContext = /* @__PURE__ */ function(_ASTValidationContext) {
  _inheritsLoose(SDLValidationContext2, _ASTValidationContext);
  function SDLValidationContext2(ast, schema2, onError) {
    var _this;
    _this = _ASTValidationContext.call(this, ast, onError) || this;
    _this._schema = schema2;
    return _this;
  }
  var _proto2 = SDLValidationContext2.prototype;
  _proto2.getSchema = function getSchema() {
    return this._schema;
  };
  return SDLValidationContext2;
}(ASTValidationContext);
var ValidationContext = /* @__PURE__ */ function(_ASTValidationContext2) {
  _inheritsLoose(ValidationContext2, _ASTValidationContext2);
  function ValidationContext2(schema2, ast, typeInfo, onError) {
    var _this2;
    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
    _this2._schema = schema2;
    _this2._typeInfo = typeInfo;
    _this2._variableUsages = /* @__PURE__ */ new Map();
    _this2._recursiveVariableUsages = /* @__PURE__ */ new Map();
    return _this2;
  }
  var _proto3 = ValidationContext2.prototype;
  _proto3.getSchema = function getSchema() {
    return this._schema;
  };
  _proto3.getVariableUsages = function getVariableUsages(node) {
    var usages = this._variableUsages.get(node);
    if (!usages) {
      var newUsages = [];
      var typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: function VariableDefinition2() {
          return false;
        },
        Variable: function Variable2(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  };
  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
    var usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {
        var frag = _this$getRecursivelyR2[_i6];
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  };
  _proto3.getType = function getType() {
    return this._typeInfo.getType();
  };
  _proto3.getParentType = function getParentType() {
    return this._typeInfo.getParentType();
  };
  _proto3.getInputType = function getInputType() {
    return this._typeInfo.getInputType();
  };
  _proto3.getParentInputType = function getParentInputType() {
    return this._typeInfo.getParentInputType();
  };
  _proto3.getFieldDef = function getFieldDef2() {
    return this._typeInfo.getFieldDef();
  };
  _proto3.getDirective = function getDirective() {
    return this._typeInfo.getDirective();
  };
  _proto3.getArgument = function getArgument() {
    return this._typeInfo.getArgument();
  };
  _proto3.getEnumValue = function getEnumValue() {
    return this._typeInfo.getEnumValue();
  };
  return ValidationContext2;
}(ASTValidationContext);
function validate(schema2, documentAST) {
  var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : specifiedRules;
  var typeInfo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new TypeInfo(schema2);
  var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
    maxErrors: void 0
  };
  documentAST || devAssert(0, "Must provide document.");
  assertValidSchema(schema2);
  var abortObj = Object.freeze({});
  var errors = [];
  var context = new ValidationContext(schema2, documentAST, typeInfo, function(error2) {
    if (options2.maxErrors != null && errors.length >= options2.maxErrors) {
      errors.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors.push(error2);
  });
  var visitor = visitInParallel(rules.map(function(rule) {
    return rule(context);
  }));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend) {
  var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : specifiedSDLRules;
  var errors = [];
  var context = new SDLValidationContext(documentAST, schemaToExtend, function(error2) {
    errors.push(error2);
  });
  var visitors = rules.map(function(rule) {
    return rule(context);
  });
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  var errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema2) {
  var errors = validateSDL(documentAST, schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path2) {
  var flattened = [];
  var curr = path2;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray(path2) {
  return path2.map(function(key) {
    return typeof key === "number" ? "[" + key.toString() + "]" : "." + key;
  }).join("");
}
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    var variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    var variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      var coercedValues = [];
      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
        var itemNode = _valueNode$values2[_i2];
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          var itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    var coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    var coercedObj = /* @__PURE__ */ Object.create(null);
    var fieldNodes = keyMap(valueNode.fields, function(field2) {
      return field2.name.value;
    });
    for (var _i4 = 0, _objectValues2 = objectValues$1(type2.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    var result2;
    try {
      result2 = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result2 === void 0) {
      return;
    }
    return result2;
  }
  invariant(0, "Unexpected input type: " + inspect$1(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
function coerceInputValue(inputValue, type2) {
  var onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOnError;
  return coerceInputValueImpl(inputValue, type2, onError);
}
function defaultOnError(path2, invalidValue, error2) {
  var errorPrefix = "Invalid value " + inspect$1(invalidValue);
  if (path2.length > 0) {
    errorPrefix += ' at "value'.concat(printPathArray(path2), '"');
  }
  error2.message = errorPrefix + ": " + error2.message;
  throw error2;
}
function coerceInputValueImpl(inputValue, type2, onError, path2) {
  if (isNonNullType(type2)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type2.ofType, onError, path2);
    }
    onError(pathToArray(path2), inputValue, new GraphQLError('Expected non-nullable type "'.concat(inspect$1(type2), '" not to be null.')));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    var coercedList = safeArrayFrom(inputValue, function(itemValue, index2) {
      var itemPath = addPath(path2, index2, void 0);
      return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
    });
    if (coercedList != null) {
      return coercedList;
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path2)];
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike$8(inputValue)) {
      onError(pathToArray(path2), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '" to be an object.')));
      return;
    }
    var coercedValue = {};
    var fieldDefs = type2.getFields();
    for (var _i2 = 0, _objectValues2 = objectValues$1(fieldDefs); _i2 < _objectValues2.length; _i2++) {
      var field = _objectValues2[_i2];
      var fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          var typeStr = inspect$1(field.type);
          onError(pathToArray(path2), inputValue, new GraphQLError('Field "'.concat(field.name, '" of required type "').concat(typeStr, '" was not provided.')));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path2, field.name, type2.name));
    }
    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {
      var fieldName = _Object$keys2[_i4];
      if (!fieldDefs[fieldName]) {
        var suggestions = suggestionList(fieldName, Object.keys(type2.getFields()));
        onError(pathToArray(path2), inputValue, new GraphQLError('Field "'.concat(fieldName, '" is not defined by type "').concat(type2.name, '".') + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type2)) {
    var parseResult;
    try {
      parseResult = type2.parseValue(inputValue);
    } catch (error2) {
      if (error2 instanceof GraphQLError) {
        onError(pathToArray(path2), inputValue, error2);
      } else {
        onError(pathToArray(path2), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '". ') + error2.message, void 0, void 0, void 0, void 0, error2));
      }
      return;
    }
    if (parseResult === void 0) {
      onError(pathToArray(path2), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '".')));
    }
    return parseResult;
  }
  invariant(0, "Unexpected input type: " + inspect$1(type2));
}
function getVariableValues(schema2, varDefNodes, inputs, options2) {
  var errors = [];
  var maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors;
  try {
    var coerced = coerceVariableValues(schema2, varDefNodes, inputs, function(error2) {
      if (maxErrors != null && errors.length >= maxErrors) {
        throw new GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors.push(error2);
    });
    if (errors.length === 0) {
      return {
        coerced
      };
    }
  } catch (error2) {
    errors.push(error2);
  }
  return {
    errors
  };
}
function coerceVariableValues(schema2, varDefNodes, inputs, onError) {
  var coercedValues = {};
  var _loop = function _loop2(_i22) {
    var varDefNode = varDefNodes[_i22];
    var varName = varDefNode.variable.name.value;
    var varType = typeFromAST(schema2, varDefNode.type);
    if (!isInputType(varType)) {
      var varTypeStr = print(varDefNode.type);
      onError(new GraphQLError('Variable "$'.concat(varName, '" expected value of type "').concat(varTypeStr, '" which cannot be used as an input type.'), varDefNode.type));
      return "continue";
    }
    if (!hasOwnProperty$j(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        var _varTypeStr = inspect$1(varType);
        onError(new GraphQLError('Variable "$'.concat(varName, '" of required type "').concat(_varTypeStr, '" was not provided.'), varDefNode));
      }
      return "continue";
    }
    var value2 = inputs[varName];
    if (value2 === null && isNonNullType(varType)) {
      var _varTypeStr2 = inspect$1(varType);
      onError(new GraphQLError('Variable "$'.concat(varName, '" of non-null type "').concat(_varTypeStr2, '" must not be null.'), varDefNode));
      return "continue";
    }
    coercedValues[varName] = coerceInputValue(value2, varType, function(path2, invalidValue, error2) {
      var prefix = 'Variable "$'.concat(varName, '" got invalid value ') + inspect$1(invalidValue);
      if (path2.length > 0) {
        prefix += ' at "'.concat(varName).concat(printPathArray(path2), '"');
      }
      onError(new GraphQLError(prefix + "; " + error2.message, varDefNode, void 0, void 0, void 0, error2.originalError));
    });
  };
  for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {
    var _ret = _loop(_i2);
    if (_ret === "continue")
      continue;
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  var coercedValues = {};
  var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  var argNodeMap = keyMap(argumentNodes, function(arg) {
    return arg.name.value;
  });
  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
    var argDef = _def$args2[_i4];
    var name = argDef.name;
    var argType = argDef.type;
    var argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError('Argument "'.concat(name, '" of required type "').concat(inspect$1(argType), '" ') + "was not provided.", node);
      }
      continue;
    }
    var valueNode = argumentNode.value;
    var isNull2 = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      var variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty$j(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError('Argument "'.concat(name, '" of required type "').concat(inspect$1(argType), '" ') + 'was provided the variable "$'.concat(variableName, '" which was not provided a runtime value.'), valueNode);
        }
        continue;
      }
      isNull2 = variableValues[variableName] == null;
    }
    if (isNull2 && isNonNullType(argType)) {
      throw new GraphQLError('Argument "'.concat(name, '" of non-null type "').concat(inspect$1(argType), '" ') + "must not be null.", valueNode);
    }
    var coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError('Argument "'.concat(name, '" has invalid value ').concat(print(valueNode), "."), valueNode);
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var directiveNode = node.directives && find$1(node.directives, function(directive2) {
    return directive2.name.value === directiveDef.name;
  });
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty$j(obj2, prop) {
  return Object.prototype.hasOwnProperty.call(obj2, prop);
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$2(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function getIntrospectionQuery(options2) {
  var optionsWithDefault = _objectSpread$1({
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false
  }, options2);
  var descriptions = optionsWithDefault.descriptions ? "description" : "";
  var specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByUrl" : "";
  var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str2) {
    return optionsWithDefault.inputValueDeprecation ? str2 : "";
  }
  return "\n    query IntrospectionQuery {\n      __schema {\n        ".concat(schemaDescription, "\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ").concat(descriptions, "\n          ").concat(directiveIsRepeatable, "\n          locations\n          args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions, "\n      ").concat(specifiedByUrl, "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields").concat(inputDeprecation("(includeDeprecated: true)"), " {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions, "\n      type { ...TypeRef }\n      defaultValue\n      ").concat(inputDeprecation("isDeprecated"), "\n      ").concat(inputDeprecation("deprecationReason"), "\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
}
function buildClientSchema(introspection, options2) {
  isObjectLike$8(introspection) && isObjectLike$8(introspection.__schema) || devAssert(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat(inspect$1(introspection), "."));
  var schemaIntrospection = introspection.__schema;
  var typeMap = keyValMap(schemaIntrospection.types, function(typeIntrospection) {
    return typeIntrospection.name;
  }, function(typeIntrospection) {
    return buildType(typeIntrospection);
  });
  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {
    var stdType = _ref2[_i2];
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  var directives2 = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: objectValues$1(typeMap),
    directives: directives2,
    assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      var itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      var nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      var nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    var typeName = typeRef.name;
    if (!typeName) {
      throw new Error("Unknown type reference: ".concat(inspect$1(typeRef), "."));
    }
    var type2 = typeMap[typeName];
    if (!type2) {
      throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
    }
    return type2;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type2) {
    if (type2 != null && type2.name != null && type2.kind != null) {
      switch (type2.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type2);
        case TypeKind.OBJECT:
          return buildObjectDef(type2);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type2);
        case TypeKind.UNION:
          return buildUnionDef(type2);
        case TypeKind.ENUM:
          return buildEnumDef(type2);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type2);
      }
    }
    var typeStr = inspect$1(type2);
    throw new Error("Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(typeStr, "."));
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByUrl: scalarIntrospection.specifiedByUrl
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      var implementingIntrospectionStr = inspect$1(implementingIntrospection);
      throw new Error("Introspection result missing interfaces: ".concat(implementingIntrospectionStr, "."));
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: function interfaces() {
        return buildImplementationsList(objectIntrospection);
      },
      fields: function fields8() {
        return buildFieldDefMap(objectIntrospection);
      }
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: function interfaces() {
        return buildImplementationsList(interfaceIntrospection);
      },
      fields: function fields8() {
        return buildFieldDefMap(interfaceIntrospection);
      }
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      var unionIntrospectionStr = inspect$1(unionIntrospection);
      throw new Error("Introspection result missing possibleTypes: ".concat(unionIntrospectionStr, "."));
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: function types() {
        return unionIntrospection.possibleTypes.map(getObjectType);
      }
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      var enumIntrospectionStr = inspect$1(enumIntrospection);
      throw new Error("Introspection result missing enumValues: ".concat(enumIntrospectionStr, "."));
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(enumIntrospection.enumValues, function(valueIntrospection) {
        return valueIntrospection.name;
      }, function(valueIntrospection) {
        return {
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        };
      })
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      var inputObjectIntrospectionStr = inspect$1(inputObjectIntrospection);
      throw new Error("Introspection result missing inputFields: ".concat(inputObjectIntrospectionStr, "."));
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: function fields8() {
        return buildInputValueDefMap(inputObjectIntrospection.inputFields);
      }
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error("Introspection result missing fields: ".concat(inspect$1(typeIntrospection), "."));
    }
    return keyValMap(typeIntrospection.fields, function(fieldIntrospection) {
      return fieldIntrospection.name;
    }, buildField);
  }
  function buildField(fieldIntrospection) {
    var type2 = getType(fieldIntrospection.type);
    if (!isOutputType(type2)) {
      var typeStr = inspect$1(type2);
      throw new Error("Introspection must provide output type for fields, but received: ".concat(typeStr, "."));
    }
    if (!fieldIntrospection.args) {
      var fieldIntrospectionStr = inspect$1(fieldIntrospection);
      throw new Error("Introspection result missing field args: ".concat(fieldIntrospectionStr, "."));
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type: type2,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(inputValueIntrospections, function(inputValue) {
      return inputValue.name;
    }, buildInputValue);
  }
  function buildInputValue(inputValueIntrospection) {
    var type2 = getType(inputValueIntrospection.type);
    if (!isInputType(type2)) {
      var typeStr = inspect$1(type2);
      throw new Error("Introspection must provide input type for arguments, but received: ".concat(typeStr, "."));
    }
    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type2) : void 0;
    return {
      description: inputValueIntrospection.description,
      type: type2,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      var directiveIntrospectionStr = inspect$1(directiveIntrospection);
      throw new Error("Introspection result missing directive args: ".concat(directiveIntrospectionStr, "."));
    }
    if (!directiveIntrospection.locations) {
      var _directiveIntrospectionStr = inspect$1(directiveIntrospection);
      throw new Error("Introspection result missing directive locations: ".concat(_directiveIntrospectionStr, "."));
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj2, key, value2) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj2[key] = value2;
  }
  return obj2;
}
function extendSchema(schema2, documentAST, options2) {
  assertSchema(schema2);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, "Must provide valid Document AST.");
  if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema2);
  }
  var schemaConfig = schema2.toConfig();
  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options2);
  return schemaConfig === extendedConfig ? schema2 : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options2) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  var typeDefs = [];
  var typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  var directiveDefs = [];
  var schemaDef;
  var schemaExtensions = [];
  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var def = _documentAST$definiti2[_i2];
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      var extendedTypeName = def.name.value;
      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  var typeMap = /* @__PURE__ */ Object.create(null);
  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {
    var existingType = _schemaConfig$types2[_i4];
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {
    var _stdTypeMap$name;
    var typeNode = typeDefs[_i6];
    var name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  var operationTypes = _objectSpread(_objectSpread({
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
  return _objectSpread(_objectSpread({
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
  }, operationTypes), {}, {
    types: objectValues$1(typeMap),
    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),
    extensions: void 0,
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  });
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    }
    if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceDirective(directive2) {
    var config2 = directive2.toConfig();
    return new GraphQLDirective(_objectSpread(_objectSpread({}, config2), {}, {
      args: mapValue(config2.args, extendArg)
    }));
  }
  function extendNamedType(type2) {
    if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {
      return type2;
    }
    if (isScalarType(type2)) {
      return extendScalarType(type2);
    }
    if (isObjectType(type2)) {
      return extendObjectType(type2);
    }
    if (isInterfaceType(type2)) {
      return extendInterfaceType(type2);
    }
    if (isUnionType(type2)) {
      return extendUnionType(type2);
    }
    if (isEnumType(type2)) {
      return extendEnumType(type2);
    }
    if (isInputObjectType(type2)) {
      return extendInputObjectType(type2);
    }
    invariant(0, "Unexpected type: " + inspect$1(type2));
  }
  function extendInputObjectType(type2) {
    var _typeExtensionsMap$co;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config2), {}, {
      fields: function fields8() {
        return _objectSpread(_objectSpread({}, mapValue(config2.fields, function(field) {
          return _objectSpread(_objectSpread({}, field), {}, {
            type: replaceType(field.type)
          });
        })), buildInputFieldMap(extensions));
      },
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendEnumType(type2) {
    var _typeExtensionsMap$ty;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config2), {}, {
      values: _objectSpread(_objectSpread({}, config2.values), buildEnumValueMap(extensions)),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendScalarType(type2) {
    var _typeExtensionsMap$co2;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    var specifiedByUrl = config2.specifiedByUrl;
    for (var _i8 = 0; _i8 < extensions.length; _i8++) {
      var _getSpecifiedByUrl;
      var extensionNode = extensions[_i8];
      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;
    }
    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config2), {}, {
      specifiedByUrl,
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendObjectType(type2) {
    var _typeExtensionsMap$co3;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config2), {}, {
      interfaces: function interfaces() {
        return [].concat(type2.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
      },
      fields: function fields8() {
        return _objectSpread(_objectSpread({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions));
      },
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendInterfaceType(type2) {
    var _typeExtensionsMap$co4;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config2), {}, {
      interfaces: function interfaces() {
        return [].concat(type2.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
      },
      fields: function fields8() {
        return _objectSpread(_objectSpread({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions));
      },
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendUnionType(type2) {
    var _typeExtensionsMap$co5;
    var config2 = type2.toConfig();
    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config2), {}, {
      types: function types() {
        return [].concat(type2.getTypes().map(replaceNamedType), buildUnionTypes(extensions));
      },
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendField(field) {
    return _objectSpread(_objectSpread({}, field), {}, {
      type: replaceType(field.type),
      args: mapValue(field.args, extendArg)
    });
  }
  function extendArg(arg) {
    return _objectSpread(_objectSpread({}, arg), {}, {
      type: replaceType(arg.type)
    });
  }
  function getOperationTypes(nodes) {
    var opTypes = {};
    for (var _i10 = 0; _i10 < nodes.length; _i10++) {
      var _node$operationTypes;
      var node = nodes[_i10];
      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {
        var operationType = operationTypesNodes[_i12];
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    var name2 = node.name.value;
    var type2 = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
    if (type2 === void 0) {
      throw new Error('Unknown type: "'.concat(name2, '".'));
    }
    return type2;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var locations = node.locations.map(function(_ref2) {
      var value2 = _ref2.value;
      return value2;
    });
    return new GraphQLDirective({
      name: node.name.value,
      description: getDescription(node, options2),
      locations,
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    var fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (var _i14 = 0; _i14 < nodes.length; _i14++) {
      var _node$fields;
      var node = nodes[_i14];
      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {
        var field = nodeFields[_i16];
        fieldConfigMap[field.name.value] = {
          type: getWrappedType(field.type),
          description: getDescription(field, options2),
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args2) {
    var argsNodes = args2 !== null && args2 !== void 0 ? args2 : [];
    var argConfigMap = /* @__PURE__ */ Object.create(null);
    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {
      var arg = argsNodes[_i18];
      var type2 = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type: type2,
        description: getDescription(arg, options2),
        defaultValue: valueFromAST(arg.defaultValue, type2),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    var inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (var _i20 = 0; _i20 < nodes.length; _i20++) {
      var _node$fields2;
      var node = nodes[_i20];
      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {
        var field = fieldsNodes[_i22];
        var type2 = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type: type2,
          description: getDescription(field, options2),
          defaultValue: valueFromAST(field.defaultValue, type2),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    var enumValueMap = /* @__PURE__ */ Object.create(null);
    for (var _i24 = 0; _i24 < nodes.length; _i24++) {
      var _node$values;
      var node = nodes[_i24];
      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {
        var value2 = valuesNodes[_i26];
        enumValueMap[value2.name.value] = {
          description: getDescription(value2, options2),
          deprecationReason: getDeprecationReason(value2),
          astNode: value2
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    var interfaces = [];
    for (var _i28 = 0; _i28 < nodes.length; _i28++) {
      var _node$interfaces;
      var node = nodes[_i28];
      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];
      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {
        var type2 = interfacesNodes[_i30];
        interfaces.push(getNamedType2(type2));
      }
    }
    return interfaces;
  }
  function buildUnionTypes(nodes) {
    var types = [];
    for (var _i32 = 0; _i32 < nodes.length; _i32++) {
      var _node$types;
      var node = nodes[_i32];
      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];
      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {
        var type2 = typeNodes[_i34];
        types.push(getNamedType2(type2));
      }
    }
    return types;
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    var name2 = astNode.name.value;
    var description = getDescription(astNode, options2);
    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var extensionASTNodes = extensionNodes;
        var allNodes = [astNode].concat(extensionASTNodes);
        return new GraphQLObjectType({
          name: name2,
          description,
          interfaces: function interfaces() {
            return buildInterfaces(allNodes);
          },
          fields: function fields8() {
            return buildFieldMap(allNodes);
          },
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _extensionASTNodes = extensionNodes;
        var _allNodes = [astNode].concat(_extensionASTNodes);
        return new GraphQLInterfaceType({
          name: name2,
          description,
          interfaces: function interfaces() {
            return buildInterfaces(_allNodes);
          },
          fields: function fields8() {
            return buildFieldMap(_allNodes);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _extensionASTNodes2 = extensionNodes;
        var _allNodes2 = [astNode].concat(_extensionASTNodes2);
        return new GraphQLEnumType({
          name: name2,
          description,
          values: buildEnumValueMap(_allNodes2),
          astNode,
          extensionASTNodes: _extensionASTNodes2
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _extensionASTNodes3 = extensionNodes;
        var _allNodes3 = [astNode].concat(_extensionASTNodes3);
        return new GraphQLUnionType({
          name: name2,
          description,
          types: function types() {
            return buildUnionTypes(_allNodes3);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes3
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _extensionASTNodes4 = extensionNodes;
        return new GraphQLScalarType({
          name: name2,
          description,
          specifiedByUrl: getSpecifiedByUrl(astNode),
          astNode,
          extensionASTNodes: _extensionASTNodes4
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _extensionASTNodes5 = extensionNodes;
        var _allNodes4 = [astNode].concat(_extensionASTNodes5);
        return new GraphQLInputObjectType({
          name: name2,
          description,
          fields: function fields8() {
            return buildInputFieldMap(_allNodes4);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes5
        });
      }
    }
    invariant(0, "Unexpected type definition node: " + inspect$1(astNode));
  }
}
var stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function(type2) {
  return type2.name;
});
function getDeprecationReason(node) {
  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByUrl(node) {
  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function getDescription(node, options2) {
  if (node.description) {
    return node.description.value;
  }
  if ((options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions) === true) {
    var rawValue = getLeadingCommentBlock$1(node);
    if (rawValue !== void 0) {
      return dedentBlockStringValue$1("\n" + rawValue);
    }
  }
}
function getLeadingCommentBlock$1(node) {
  var loc = node.loc;
  if (!loc) {
    return;
  }
  var comments = [];
  var token = loc.startToken.prev;
  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    var value2 = String(token.value);
    comments.push(value2);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function buildASTSchema(documentAST, options2) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, "Must provide valid Document AST.");
  if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  var emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: void 0,
    extensionASTNodes: [],
    assumeValid: false
  };
  var config2 = extendSchemaImpl(emptySchemaConfig, documentAST, options2);
  if (config2.astNode == null) {
    for (var _i2 = 0, _config$types2 = config2.types; _i2 < _config$types2.length; _i2++) {
      var type2 = _config$types2[_i2];
      switch (type2.name) {
        case "Query":
          config2.query = type2;
          break;
        case "Mutation":
          config2.mutation = type2;
          break;
        case "Subscription":
          config2.subscription = type2;
          break;
      }
    }
  }
  var directives2 = config2.directives;
  var _loop = function _loop2(_i42) {
    var stdDirective = specifiedDirectives[_i42];
    if (directives2.every(function(directive2) {
      return directive2.name !== stdDirective.name;
    })) {
      directives2.push(stdDirective);
    }
  };
  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {
    _loop(_i4);
  }
  return new GraphQLSchema(config2);
}
function buildSchema(source, options2) {
  var document2 = parse$6(source, {
    noLocation: options2 === null || options2 === void 0 ? void 0 : options2.noLocation,
    allowLegacySDLEmptyFields: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacySDLEmptyFields,
    allowLegacySDLImplementsInterfaces: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacySDLImplementsInterfaces,
    experimentalFragmentVariables: options2 === null || options2 === void 0 ? void 0 : options2.experimentalFragmentVariables
  });
  return buildASTSchema(document2, {
    commentDescriptions: options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions,
    assumeValidSDL: options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL,
    assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
  });
}
function printSchema(schema2, options2) {
  return printFilteredSchema(schema2, function(n2) {
    return !isSpecifiedDirective(n2);
  }, isDefinedType, options2);
}
function printIntrospectionSchema(schema2, options2) {
  return printFilteredSchema(schema2, isSpecifiedDirective, isIntrospectionType, options2);
}
function isDefinedType(type2) {
  return !isSpecifiedScalarType(type2) && !isIntrospectionType(type2);
}
function printFilteredSchema(schema2, directiveFilter, typeFilter, options2) {
  var directives2 = schema2.getDirectives().filter(directiveFilter);
  var types = objectValues$1(schema2.getTypeMap()).filter(typeFilter);
  return [printSchemaDefinition(schema2)].concat(directives2.map(function(directive2) {
    return printDirective(directive2, options2);
  }), types.map(function(type2) {
    return printType(type2, options2);
  })).filter(Boolean).join("\n\n") + "\n";
}
function printSchemaDefinition(schema2) {
  if (schema2.description == null && isSchemaOfCommonNames(schema2)) {
    return;
  }
  var operationTypes = [];
  var queryType = schema2.getQueryType();
  if (queryType) {
    operationTypes.push("  query: ".concat(queryType.name));
  }
  var mutationType = schema2.getMutationType();
  if (mutationType) {
    operationTypes.push("  mutation: ".concat(mutationType.name));
  }
  var subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push("  subscription: ".concat(subscriptionType.name));
  }
  return printDescription({}, schema2) + "schema {\n".concat(operationTypes.join("\n"), "\n}");
}
function isSchemaOfCommonNames(schema2) {
  var queryType = schema2.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  var mutationType = schema2.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  var subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type2, options2) {
  if (isScalarType(type2)) {
    return printScalar(type2, options2);
  }
  if (isObjectType(type2)) {
    return printObject(type2, options2);
  }
  if (isInterfaceType(type2)) {
    return printInterface(type2, options2);
  }
  if (isUnionType(type2)) {
    return printUnion(type2, options2);
  }
  if (isEnumType(type2)) {
    return printEnum(type2, options2);
  }
  if (isInputObjectType(type2)) {
    return printInputObject(type2, options2);
  }
  invariant(0, "Unexpected type: " + inspect$1(type2));
}
function printScalar(type2, options2) {
  return printDescription(options2, type2) + "scalar ".concat(type2.name) + printSpecifiedByUrl(type2);
}
function printImplementedInterfaces(type2) {
  var interfaces = type2.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map(function(i2) {
    return i2.name;
  }).join(" & ") : "";
}
function printObject(type2, options2) {
  return printDescription(options2, type2) + "type ".concat(type2.name) + printImplementedInterfaces(type2) + printFields(options2, type2);
}
function printInterface(type2, options2) {
  return printDescription(options2, type2) + "interface ".concat(type2.name) + printImplementedInterfaces(type2) + printFields(options2, type2);
}
function printUnion(type2, options2) {
  var types = type2.getTypes();
  var possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(options2, type2) + "union " + type2.name + possibleTypes;
}
function printEnum(type2, options2) {
  var values = type2.getValues().map(function(value2, i2) {
    return printDescription(options2, value2, "  ", !i2) + "  " + value2.name + printDeprecated(value2.deprecationReason);
  });
  return printDescription(options2, type2) + "enum ".concat(type2.name) + printBlock(values);
}
function printInputObject(type2, options2) {
  var fields8 = objectValues$1(type2.getFields()).map(function(f, i2) {
    return printDescription(options2, f, "  ", !i2) + "  " + printInputValue(f);
  });
  return printDescription(options2, type2) + "input ".concat(type2.name) + printBlock(fields8);
}
function printFields(options2, type2) {
  var fields8 = objectValues$1(type2.getFields()).map(function(f, i2) {
    return printDescription(options2, f, "  ", !i2) + "  " + f.name + printArgs(options2, f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason);
  });
  return printBlock(fields8);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(options2, args2) {
  var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (args2.length === 0) {
    return "";
  }
  if (args2.every(function(arg) {
    return !arg.description;
  })) {
    return "(" + args2.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args2.map(function(arg, i2) {
    return printDescription(options2, arg, "  " + indentation, !i2) + "  " + indentation + printInputValue(arg);
  }).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  var defaultAST = astFromValue(arg.defaultValue, arg.type);
  var argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += " = ".concat(print(defaultAST));
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive2, options2) {
  return printDescription(options2, directive2) + "directive @" + directive2.name + printArgs(options2, directive2.args) + (directive2.isRepeatable ? " repeatable" : "") + " on " + directive2.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  var reasonAST = astFromValue(reason, GraphQLString);
  if (reasonAST && reason !== DEFAULT_DEPRECATION_REASON) {
    return " @deprecated(reason: " + print(reasonAST) + ")";
  }
  return " @deprecated";
}
function printSpecifiedByUrl(scalar) {
  if (scalar.specifiedByUrl == null) {
    return "";
  }
  var url = scalar.specifiedByUrl;
  var urlAST = astFromValue(url, GraphQLString);
  urlAST || invariant(0, "Unexpected null value returned from `astFromValue` for specifiedByUrl");
  return " @specifiedBy(url: " + print(urlAST) + ")";
}
function printDescription(options2, def) {
  var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  var firstInBlock = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var description = def.description;
  if (description == null) {
    return "";
  }
  if ((options2 === null || options2 === void 0 ? void 0 : options2.commentDescriptions) === true) {
    return printDescriptionWithComments(description, indentation, firstInBlock);
  }
  var preferMultipleLines = description.length > 70;
  var blockString = printBlockString$1(description, "", preferMultipleLines);
  var prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
function printDescriptionWithComments(description, indentation, firstInBlock) {
  var prefix = indentation && !firstInBlock ? "\n" : "";
  var comment = description.split("\n").map(function(line) {
    return indentation + (line !== "" ? "# " + line : "#");
  }).join("\n");
  return prefix + comment + "\n";
}
function concatAST(documents) {
  var definitions = [];
  for (var _i2 = 0; _i2 < documents.length; _i2++) {
    var doc = documents[_i2];
    definitions = definitions.concat(doc.definitions);
  }
  return {
    kind: "Document",
    definitions
  };
}
var PageType = /* @__PURE__ */ ((PageType2) => {
  PageType2[PageType2["LIST"] = 0] = "LIST";
  PageType2[PageType2["DETAIL"] = 1] = "DETAIL";
  return PageType2;
})(PageType || {});
var InsertType = /* @__PURE__ */ ((InsertType2) => {
  InsertType2[InsertType2["BEFORE"] = 0] = "BEFORE";
  InsertType2[InsertType2["AFTER"] = 1] = "AFTER";
  InsertType2[InsertType2["FIRST"] = 2] = "FIRST";
  InsertType2[InsertType2["LAST"] = 3] = "LAST";
  return InsertType2;
})(InsertType || {});
var RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {
  RelationshipType2[RelationshipType2["OBJECT"] = 0] = "OBJECT";
  RelationshipType2[RelationshipType2["ARRAY"] = 1] = "ARRAY";
  return RelationshipType2;
})(RelationshipType || {});
const addFieldToFragment = (file, fragmentName, fieldTreeArray, referenceField, insertType, additionalFields) => {
  try {
    const ast = parse$6(file);
    visit(ast, {
      FragmentDefinition(node) {
        var _a2, _b;
        if (node.name.value === fragmentName) {
          let fragmentFields = node.selectionSet.selections;
          fieldTreeArray = fieldExistsInFragment(fragmentFields, fieldTreeArray);
          if (fieldTreeArray.length === 0)
            return BREAK;
          const lastSelection = getLastSelection(fragmentFields, referenceField, insertType);
          additionalFields = additionalFields.filter((field) => !fragmentFields.find((fragmentField) => fragmentField.kind === "Field" && fragmentField.name.value === field));
          const newFragmentField = createFragmentField(fieldTreeArray, additionalFields);
          const endPosition = insertType === InsertType.BEFORE || insertType === InsertType.FIRST ? ((_a2 = lastSelection.loc) == null ? void 0 : _a2.start) - 1 : (_b = lastSelection.loc) == null ? void 0 : _b.end;
          file = file.substring(0, endPosition) + `
  ${newFragmentField}` + file.substring(endPosition, file.length);
          return BREAK;
        }
      }
    });
  } catch (error2) {
    console.error(error2);
  }
  return file;
};
const getLastSelection = (fragmentFields, referenceField, insertType) => {
  switch (insertType) {
    case InsertType.AFTER:
    case InsertType.BEFORE:
      const lastSelection = fragmentFields.filter((fragmentField) => {
        const name = fragmentField.name.value;
        return name === (referenceField == null ? void 0 : referenceField.substring(referenceField.length - name.length, referenceField.length));
      });
      if (lastSelection.length !== 0)
        return lastSelection[0];
      return fragmentFields[fragmentFields.length - 1];
    case InsertType.FIRST:
      return fragmentFields[0];
    case InsertType.LAST:
      return fragmentFields[fragmentFields.length - 1];
  }
};
const createFragmentField = (fieldsTree, additionalFields) => {
  let scalarFields = [...additionalFields];
  if (fieldsTree.length)
    scalarFields = [fieldsTree.pop(), ...scalarFields];
  const scalarFieldsString = createScalarFieldsString(scalarFields);
  fieldsTree = fieldsTree.reverse();
  let fragmentField = scalarFieldsString;
  fieldsTree.forEach((field, i2) => {
    if (i2 === 0)
      fragmentField = `${field} {
  ${indentField(fragmentField)}
}`;
    else
      fragmentField = `${field} {
  ${indentField(fragmentField)}
}`;
  });
  return fragmentField;
};
const createScalarFieldsString = (fields8) => {
  let scalarFields = "";
  fields8.forEach((field, i2) => {
    if (i2 === 0)
      scalarFields = field;
    else
      scalarFields = `${scalarFields}
  ${field}`;
  });
  return scalarFields;
};
const indentField = (field) => field.replaceAll(/\n  /g, "\n    ").replaceAll(/\n}/g, "\n  }");
const indentEveryLineByNSpaces = (input, n2) => {
  const tabs = Math.floor(n2 / 2);
  for (let i2 = 0; i2 < tabs; i2++) {
    input = indentField(input);
  }
  input = `${Array(n2).fill(" ").join("")}${input}`;
  return input;
};
const fragmentExists = (file, fragmentName) => {
  const ast = parse$6(file);
  let exists = false;
  visit(ast, {
    FragmentDefinition(node) {
      if (node.name.value === fragmentName) {
        exists = true;
        return BREAK;
      }
    }
  });
  return exists;
};
const fieldExistsInFragment = (fragmentFields, fieldNames) => {
  const filtredFragmentFields = fragmentFields.map((fragmentField) => {
    var _a2;
    return (_a2 = fragmentField == null ? void 0 : fragmentField.name) == null ? void 0 : _a2.value;
  }).filter((fragmentField) => fragmentField);
  const filtredFieldNames = fieldNames.filter((field) => !filtredFragmentFields.includes(field));
  return filtredFieldNames;
};
const insertFragmentSpreadIntoFragment = (file, queryName, entityName, fieldTree) => {
  const ast = parse$6(file);
  const fragmentSpreadName = buildFragmentNameFromFieldsTree([
    queryName,
    ...fieldTree
  ]);
  const fragmentName = `${queryName}_${entityName}`;
  visit(ast, {
    FragmentDefinition(node) {
      var _a2, _b, _c;
      if (node.name.value === fragmentName) {
        let modifiedFieldTree = [...fieldTree];
        let selectionSet = node.selectionSet;
        for (const field of fieldTree) {
          const actualSelection = selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === field);
          if (actualSelection && actualSelection.selectionSet) {
            selectionSet = actualSelection.selectionSet;
            modifiedFieldTree.shift();
          } else
            break;
        }
        if (fieldTree.length === modifiedFieldTree.length) {
          file = "";
          return BREAK;
        }
        const nestedField = selectionSet.selections[selectionSet.selections.length - 1];
        const fragmentParentTree = createFragmentField([...modifiedFieldTree, `...${fragmentSpreadName}`], []);
        const { leftSpaces } = countWhitespacesAndNewLinesToLeft(file, (_a2 = nestedField.loc) == null ? void 0 : _a2.start);
        const indentedfragmentParentTree = indentEveryLineByNSpaces(fragmentParentTree, leftSpaces);
        file = file.substring(0, (_b = nestedField.loc) == null ? void 0 : _b.end) + `
${indentedfragmentParentTree}` + file.substring((_c = nestedField.loc) == null ? void 0 : _c.end, file.length);
        return BREAK;
      }
    }
  });
  return file;
};
const getScalarFieldsFromFragment = (file, fieldTree, fragmentName) => {
  const ast = parse$6(file);
  let scalarFields = [];
  visit(ast, {
    FragmentDefinition(node) {
      if (node.name.value === fragmentName) {
        let selectionSet = node.selectionSet;
        fieldTree.forEach((field) => {
          const actualSelection = selectionSet == null ? void 0 : selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === field);
          selectionSet = actualSelection == null ? void 0 : actualSelection.selectionSet;
        });
        selectionSet == null ? void 0 : selectionSet.selections.forEach((field) => {
          if (field.kind === "Field" && !field.selectionSet)
            scalarFields = [...scalarFields, field.name.value];
        });
        return BREAK;
      }
    }
  });
  return scalarFields;
};
const removeFieldsFromFragment = (file, fieldTree, fieldsToDelete, fragmentName) => {
  fieldsToDelete.forEach((field) => {
    const ast = parse$6(file);
    visit(ast, {
      FragmentDefinition(node) {
        var _a2, _b, _c;
        if (node.name.value === fragmentName) {
          let selectionSet = node.selectionSet;
          fieldTree.forEach((field2) => {
            const actualSelection = selectionSet == null ? void 0 : selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === field2);
            selectionSet = actualSelection == null ? void 0 : actualSelection.selectionSet;
          });
          const nodeToBeDeleted = selectionSet == null ? void 0 : selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === field);
          if (nodeToBeDeleted) {
            const fragmentsToBeDeleted = getAllFragmentSpreadsFromField(nodeToBeDeleted);
            fragmentsToBeDeleted.forEach((fragment) => {
              const { originalFileContent } = removeFragment(file, fragment);
              file = originalFileContent;
            });
            const { leftSpaces, leftNewLines } = countWhitespacesAndNewLinesToLeft(file, (_a2 = nodeToBeDeleted.loc) == null ? void 0 : _a2.start);
            file = file.substring(0, ((_b = nodeToBeDeleted.loc) == null ? void 0 : _b.start) - leftSpaces - leftNewLines) + file.substring((_c = nodeToBeDeleted.loc) == null ? void 0 : _c.end, file.length);
          }
          return BREAK;
        }
      }
    });
  });
  return file;
};
const getAllFragmentSpreadsFromField = (fieldNode) => {
  let fragmentSpreadNames = [];
  visit(fieldNode, {
    FragmentSpread(node) {
      fragmentSpreadNames = [...fragmentSpreadNames, node.name.value];
    }
  });
  return fragmentSpreadNames;
};
function countWhitespacesAndNewLinesToLeft(file, pos) {
  let spaces = 0;
  let newLines = 0;
  while (file.charAt(pos - 1) === " " || file.charAt(pos - 1) === "\n") {
    if (file.charAt(pos - 1) === " ")
      spaces++;
    if (file.charAt(pos - 1) === "\n")
      newLines++;
    pos--;
  }
  return { leftSpaces: spaces, leftNewLines: newLines };
}
function countWhitespacesAndNewLinesToRight(file, pos) {
  let spaces = 0;
  let newLines = 0;
  while (file.charAt(pos + 1) === " " || file.charAt(pos + 1) === "\n") {
    if (file.charAt(pos + 1) === " ")
      spaces++;
    if (file.charAt(pos + 1) === "\n")
      newLines++;
    pos++;
  }
  return { rightSpaces: spaces, rightNewLines: newLines };
}
function removeFragment(file, fragmentName) {
  const ast = parse$6(file);
  let removedFragment = "";
  let originalFileContent = "";
  visit(ast, {
    FragmentDefinition(node) {
      var _a2, _b, _c, _d, _e;
      if (node.name.value === fragmentName && node.loc) {
        removedFragment = file.substr((_a2 = node.loc) == null ? void 0 : _a2.start, ((_b = node.loc) == null ? void 0 : _b.end) - ((_c = node.loc) == null ? void 0 : _c.start));
        const { leftSpaces, leftNewLines } = countWhitespacesAndNewLinesToLeft(file, node.loc.start);
        const { rightSpaces, rightNewLines } = countWhitespacesAndNewLinesToRight(file, node.loc.end);
        originalFileContent = file.substr(0, ((_d = node.loc) == null ? void 0 : _d.start) - (leftSpaces + leftNewLines)) + file.substr(((_e = node.loc) == null ? void 0 : _e.end) + (rightSpaces + rightNewLines), file.length - 1);
        return BREAK;
      }
    }
  });
  return { originalFileContent, removedFragment };
}
const buildFieldTreeInQuery = (file, queryName, entityName, fieldTree) => {
  const ast = parse$6(file);
  const fragmentName = buildFragmentNameFromFieldsTree([
    queryName,
    ...fieldTree
  ]);
  visit(ast, {
    OperationDefinition(node) {
      var _a2, _b, _c, _d;
      if (((_a2 = node == null ? void 0 : node.name) == null ? void 0 : _a2.value) === queryName) {
        let modifiedFieldTree = [...fieldTree];
        const queryField = node.selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === queryName);
        let selectionSet = queryField.selectionSet;
        fieldTree.forEach((field) => {
          const fieldExists2 = selectionSet.selections.find((selection) => selection.kind === "Field" && selection.name.value === field);
          if (fieldExists2) {
            selectionSet = fieldExists2.selectionSet;
            modifiedFieldTree.shift();
          }
        });
        const fragmentParentTree = createFragmentField([...modifiedFieldTree, `...${fragmentName}`], []);
        const lastSelection = selectionSet.selections[selectionSet.selections.length - 1];
        const { leftSpaces } = countWhitespacesAndNewLinesToLeft(file, (_b = lastSelection.loc) == null ? void 0 : _b.start);
        const indentedfragmentParentTree = indentEveryLineByNSpaces(fragmentParentTree, leftSpaces);
        file = file.substring(0, (_c = lastSelection.loc) == null ? void 0 : _c.end) + `
${indentedfragmentParentTree}` + file.substring((_d = lastSelection.loc) == null ? void 0 : _d.end, file.length);
        return BREAK;
      }
    }
  });
  return file;
};
const buildFragmentFromFieldsTree = (queryName, entityName, fieldTree, additionalFields) => {
  const scalarFields = [fieldTree.pop(), ...additionalFields];
  const scalarFieldsString = scalarFields.join("\n  ");
  const fragmentName = buildFragmentNameFromFieldsTree([
    queryName,
    ...fieldTree
  ]);
  return `fragment ${fragmentName} on ${entityName} {
  ${scalarFieldsString}
}`;
};
const buildFragmentNameFromFieldsTree = (fieldTree) => fieldTree.join("_");
const changeGraphQLEndpoint = async (envFile, endpointEnvName, newEndpointURL, secretEnvName, newSecret) => {
  const variables = envFile.split("\n");
  let urlExists = false;
  let secretExists = false;
  const modifiedVariables = variables.map((variable) => {
    const variableValueStart = variable == null ? void 0 : variable.indexOf("=");
    const variableName = variable.substring(0, variableValueStart).replace(" ", "");
    if (variableName === endpointEnvName) {
      urlExists = true;
      return `${variableName} = "${newEndpointURL}"`;
    }
    if (variableName === secretEnvName) {
      secretExists = true;
      return `${variableName} = "${newSecret}"`;
    }
    return variable;
  });
  if (!secretExists)
    modifiedVariables.unshift(`${secretEnvName} = "${newSecret}"`);
  if (!urlExists)
    modifiedVariables.unshift(`${endpointEnvName} = "${newEndpointURL}"`);
  const modifiedEnvFile = modifiedVariables.join("\n");
  return modifiedEnvFile;
};
function buildParametersAndVariablesString(field, name, types) {
  let queryParams = [];
  let variables = [];
  field.args.forEach((arg) => {
    var _a2;
    const { newParameter, newVariable } = (_a2 = changeInputFieldsNames(arg, name, types)) != null ? _a2 : {
      newParameter: `${arg.name}: $${arg.name}`,
      newVariable: `$${arg.name}: ${buildVariableString(arg, types)}`
    };
    queryParams = [...queryParams, newParameter];
    variables = [...variables, newVariable];
  });
  return {
    params: queryParams.length ? `(${queryParams.join(", ")})` : "",
    variables: variables.length ? `(${variables.join(", ")})` : ""
  };
}
function buildVariableString(arg, types) {
  const typeArray = getOfTypeArray(arg).reverse();
  let variableString = "";
  typeArray.forEach((type2) => {
    var _a2, _b;
    if (type2.kind === "NON_NULL")
      variableString = `${variableString}!`;
    if (type2.kind === "LIST") {
      variableString = `[${variableString}]`;
      if (arg.name === "order_by") {
        const orderTypeName = (_a2 = typeArray[0].name) != null ? _a2 : "";
        const order_by = getEntity(types, orderTypeName);
        const hasUpdated_at = (_b = order_by == null ? void 0 : order_by.inputFields) == null ? void 0 : _b.find((field) => field.name === "updated_at");
        if (hasUpdated_at)
          variableString = `${variableString} = { ${hasUpdated_at.name}: desc }`;
      }
    }
    if (type2.name)
      variableString = `${type2.name}`;
  });
  return variableString;
}
function getOfTypeArray(arg) {
  let ofTypeArray = [];
  let actualType = arg.type;
  while (actualType) {
    ofTypeArray = [...ofTypeArray, actualType];
    actualType = actualType.ofType;
  }
  return ofTypeArray;
}
function buildReturningString(types, returningType) {
  var _a2;
  const type2 = types.find((type22) => type22.name === returningType);
  const scalarFields = (_a2 = type2 == null ? void 0 : type2.fields) == null ? void 0 : _a2.filter((field) => {
    var _a3;
    return getNestedOfType(field).kind === "SCALAR" || ((_a3 = types.find((type22) => type22.name === field.type)) == null ? void 0 : _a3.kind) === "SCALAR";
  });
  const returningFields = scalarFields == null ? void 0 : scalarFields.map((field) => field.name);
  if (returningFields)
    return `returning {
    ${returningFields.join("\n    ")}
  }`;
  return "";
}
function getReturningType(field) {
  let actualType = field.type;
  while (actualType.ofType) {
    actualType = actualType.ofType;
  }
  if (actualType.name)
    return actualType.name;
  return actualType;
}
function changeInputFieldsNames(arg, entityName, types) {
  const variableTypeString = buildVariableString(arg, types);
  if (arg.name === "_set")
    return {
      newParameter: `${arg.name}: $${entityName != "" ? entityName : "_set"}`,
      newVariable: `$${entityName != "" ? entityName : "_set"}: ${variableTypeString}`
    };
  else if (arg.name === "object")
    return {
      newParameter: `${arg.name}: $${entityName != "" ? entityName : "object"}`,
      newVariable: `$${entityName != "" ? entityName : "object"}: ${variableTypeString}`
    };
  else if (arg.name === "objects")
    return {
      newParameter: `${arg.name}: $${entityName != "" ? entityName : "objects"}`,
      newVariable: `$${entityName != "" ? entityName : "objects"}: ${variableTypeString}`
    };
}
const buildFragments = (introspection, entities, types) => {
  var _a2;
  let fragmentsStrings = [];
  let fragmentFields = [];
  let fragmentFieldsList = [];
  entities.forEach((entity) => {
    let fragmentFieldIds = [];
    let fragmentFieldNameTitle = [];
    let fragmentFieldOtherStrings = [];
    let fragmentFieldCreatedUpdateAt = [];
    let fragmentFieldOtherDateTimes = [];
    let fragmentFieldOther = [];
    let returningString = "";
    entity.fields.forEach((field) => {
      var _a3;
      if (field.name === "returning") {
        const returningType = getReturningType(field);
        returningString = buildReturningString(types, returningType);
      } else if (field.name != "created_at" && field.name != "updated_at") {
        const fieldType = getFieldType(field, introspection.types);
        if ((fieldType == null ? void 0 : fieldType.kind) === "SCALAR") {
          const typeLowercase = (_a3 = fieldType == null ? void 0 : fieldType.name) == null ? void 0 : _a3.toLocaleLowerCase();
          if (field.name === "id") {
            fragmentFieldIds = [...fragmentFieldIds, field.name];
          } else if (field.name === "created_at" || field.name === "updated_at") {
            fragmentFieldCreatedUpdateAt = [
              ...fragmentFieldCreatedUpdateAt,
              field.name
            ];
          } else if (typeLowercase === "string") {
            if (field.name == "title" || field.name == "name") {
              fragmentFieldNameTitle = [...fragmentFieldNameTitle, field.name];
            } else {
              fragmentFieldOtherStrings = [
                ...fragmentFieldOtherStrings,
                field.name
              ];
            }
          } else if (typeLowercase == null ? void 0 : typeLowercase.includes("date")) {
            fragmentFieldOtherDateTimes = [
              ...fragmentFieldOtherDateTimes,
              field.name
            ];
          } else if (typeLowercase == null ? void 0 : typeLowercase.includes("time")) {
            fragmentFieldOtherDateTimes = [
              ...fragmentFieldOtherDateTimes,
              field.name
            ];
          } else {
            fragmentFieldOther = [...fragmentFieldOther, field.name];
          }
        }
      }
    });
    fragmentFields = [
      ...fragmentFieldIds,
      ...fragmentFieldNameTitle,
      ...fragmentFieldOtherStrings,
      ...fragmentFieldOtherDateTimes
    ];
    fragmentFieldsList.push(fragmentFields);
    const newFragmentString = `fragment ${entity.queryName}_${entity.entityName} on ${entity.entityName} {
  ${(returningString ? [...fragmentFields, returningString] : fragmentFields).join("\n  ")}
}`;
    fragmentsStrings = [...fragmentsStrings, newFragmentString];
  });
  return {
    fragmentString: fragmentsStrings.join("\n\n"),
    fragments: (_a2 = fragmentFieldsList[0]) != null ? _a2 : []
  };
};
const getRoots = (introspection) => {
  const types = introspection.types;
  const query2 = introspection.queryType;
  const mutation = introspection.mutationType;
  const subscription = introspection.subscriptionType;
  const roots = types.filter((type2) => type2.name === (query2 == null ? void 0 : query2.name) || type2.name === (mutation == null ? void 0 : mutation.name) || type2.name === (subscription == null ? void 0 : subscription.name)).map((filteredType) => {
    var _a2;
    return {
      fields: (_a2 = filteredType.fields) != null ? _a2 : [],
      kind: filteredType.kind,
      name: filteredType.name,
      type: filteredType.type,
      args: filteredType.args
    };
  });
  const queryRoot = roots.find((root2) => root2.name === (query2 == null ? void 0 : query2.name));
  const mutationRoot = roots.find((root2) => root2.name === (mutation == null ? void 0 : mutation.name));
  const subscriptionRoot = roots.find((root2) => root2.name === (subscription == null ? void 0 : subscription.name));
  return [queryRoot, mutationRoot, subscriptionRoot];
};
function generateGraphqlQueries(introspection, name) {
  const types = introspection.types;
  const [queryRoot, mutationRoot, subscriptionRoot] = getRoots(introspection);
  const entities = getEntities([queryRoot, mutationRoot], types);
  const { fragmentString, fragments } = buildFragments(introspection, entities, types);
  const selectQuery = queryRoot ? buildSelectQuery(queryRoot, name, types) : "";
  const mutationQuery = mutationRoot ? buildMutationQuery(mutationRoot, name, types) : "";
  const queries = [selectQuery, mutationQuery, fragmentString];
  const finalQuery = buildGraphqlQuery(queries);
  return {
    query: finalQuery,
    fragmentFields: fragments
  };
}
function getEntities(roots, types, filterOnlyFields) {
  const entities = roots.map((root2) => {
    var _a2;
    let rootEntities = [];
    if (root2 == null ? void 0 : root2.name) {
      for (const field of root2.fields) {
        const queryName = field.name;
        const entityName = (_a2 = getNestedOfType(field).name) != null ? _a2 : "";
        let entityFields = getEntityFields(entityName, types);
        if (filterOnlyFields && !entityFields.some((field2) => getNestedOfType(field2).kind === filterOnlyFields)) {
          root2.fields = root2.fields.filter((fieldToBeDelete) => fieldToBeDelete !== field);
          continue;
        }
        rootEntities = [
          ...rootEntities,
          { queryName, entityName, fields: entityFields }
        ];
      }
    }
    return rootEntities;
  });
  return Array.prototype.concat.apply([], entities);
}
function getEntityFields(entityName, types) {
  const entity = types.find((type2) => type2.name === entityName);
  if (entity && entity.fields)
    return entity.fields;
  return [];
}
function getNestedOfType(field) {
  var _a2;
  let actualType = (_a2 = field.type) != null ? _a2 : field.ofType;
  while (actualType.ofType)
    actualType = actualType.ofType;
  if (actualType.name)
    return actualType;
  else
    return { name: field.type, kind: "" };
}
function getEntity(types, entityName) {
  return types.find((type2) => type2.name === entityName);
}
function getFieldType(field, types) {
  const fieldType = getNestedOfType(field);
  if (fieldType.kind === "SCALAR")
    return fieldType;
  if (fieldType.kind == "") {
    const nestedFieldType = getEntity(types, fieldType.name);
    if ((nestedFieldType == null ? void 0 : nestedFieldType.kind) === "SCALAR")
      return nestedFieldType;
  }
}
function buildSelectQuery(queryRoot, name, types) {
  let selectQueries = [];
  queryRoot.fields.forEach((query2) => {
    const fragmentName = `${query2.name}_${getNestedOfType(query2).name}`;
    const { params, variables } = buildParametersAndVariablesString(query2, name, types);
    const newSelectQuery = `query ${query2.name}${variables} {
  ${query2.name}${params} {
    ...${fragmentName}
  }
}`;
    selectQueries = [...selectQueries, newSelectQuery];
  });
  return selectQueries.join("\n\n");
}
function buildMutationQuery(mutationRoot, name, types) {
  let mutationQueries = [];
  mutationRoot.fields.forEach((field) => {
    const fragmentName = `${field.name}_${getNestedOfType(field).name}`;
    mutationQueries = [
      ...mutationQueries,
      buildMutationString(field, fragmentName, name, types)
    ];
  });
  return mutationQueries.join("\n\n");
}
function buildMutationString(field, fragmentName, name, types) {
  const { params, variables } = buildParametersAndVariablesString(field, name, types);
  return `mutation ${field.name}${variables} {
  ${field.name}${params} {
    ...${fragmentName}
  }
}`;
}
function buildGraphqlQuery(queries) {
  queries = queries.filter((query2) => query2 != "");
  return `${queries.join("\n\n")}`;
}
const isByPkQuery = (field) => field.args.some((arg) => arg.name === "id");
const isAggregateField = (field) => {
  var _a2, _b, _c;
  return ((_a2 = field.type) == null ? void 0 : _a2.kind) === "NON_NULL" && ((_c = (_b = field.type) == null ? void 0 : _b.ofType) == null ? void 0 : _c.kind) === "OBJECT";
};
function generateGraphqlFile(introspection, names) {
  const roots = getRoots(introspection);
  let usedQueryNames = [];
  const generatedQueries = names.map((name) => {
    var _a2, _b;
    const modifiedRoots = filterRootQueries(roots, introspection.types, name, usedQueryNames);
    modifiedRoots.forEach((modifiedRoot) => modifiedRoot == null ? void 0 : modifiedRoot.fields.forEach((field) => usedQueryNames = [...usedQueryNames, field.name]));
    const modifiedIntrospection = replaceRootFields(modifiedRoots, introspection);
    const entityFields = (_b = (_a2 = getEntity(modifiedIntrospection.types, name)) == null ? void 0 : _a2.fields) == null ? void 0 : _b.filter((field) => {
      const fieldType = getNestedOfType(field);
      if (fieldType.kind && fieldType.kind != "" && fieldType.kind === "SCALAR")
        return true;
      const nestedFieldType = getEntity(modifiedIntrospection.types, fieldType.name);
      if ((nestedFieldType == null ? void 0 : nestedFieldType.kind) === "SCALAR")
        return true;
      return false;
    });
    const queryFragmentFields = entityFields == null ? void 0 : entityFields.map((field) => {
      return { name: field.name, type: getNestedOfType(field).name };
    });
    const { query: query2, fragmentFields } = generateGraphqlQueries(modifiedIntrospection, name);
    return {
      queries: query2,
      entityName: name,
      properties: queryFragmentFields != null ? queryFragmentFields : [],
      fragments: fragmentFields
    };
  });
  return generatedQueries;
}
function replaceRootFields(roots, introspection) {
  const modifiedIntrospection = JSON.parse(JSON.stringify(introspection));
  roots.forEach((root2) => {
    if (root2) {
      const modifiedType = modifiedIntrospection.types.find((type2) => type2.name === root2.name);
      if (modifiedType)
        modifiedType.fields = [...root2.fields];
    }
  });
  return modifiedIntrospection;
}
function filterRootQueries(roots, types, entityName, usedQueryNames) {
  const modifiedRoots = roots.map((root2) => {
    if (root2) {
      const modifiedRoot = __spreadValues2({}, root2);
      modifiedRoot.fields = modifiedRoot.fields.filter((field) => isReturningEntity(field, types, entityName) && !usedQueryNames.includes(field.name));
      return modifiedRoot;
    }
    return root2;
  });
  return modifiedRoots;
}
function isReturningEntity(field, allTypes, entityName) {
  const ofType = isOfType(field, entityName) || isMutationType(field, allTypes, entityName);
  if (ofType)
    return true;
  return false;
}
function isMutationType(field, allTypes, entityName) {
  var _a2;
  const fieldName = typeof field.type === "string" ? field.type : getNestedOfType(field).name;
  const type2 = allTypes.find((type22) => type22.name === fieldName);
  if (!type2)
    return false;
  const returning = (_a2 = type2.fields) == null ? void 0 : _a2.find((field2) => field2.name === "returning");
  if (!returning)
    return false;
  const nestedOfType = getNestedOfType(returning);
  if (nestedOfType.name === entityName)
    return true;
  else
    return false;
}
function isOfType(field, entityName) {
  var _a2;
  let actualType = field.type;
  if (typeof actualType !== "string") {
    while (isInstanceOfType(actualType) && actualType.ofType)
      actualType = actualType.ofType;
    if (isInstanceOfType(actualType) && ((_a2 = actualType.name) == null ? void 0 : _a2.toLowerCase()) === (entityName == null ? void 0 : entityName.toLowerCase()))
      return true;
  } else if (typeof actualType === "string" && actualType === (entityName == null ? void 0 : entityName.toLowerCase())) {
    return true;
  }
  return false;
}
function isOfTypePage(field, entityName, pageType) {
  var _a2, _b;
  let actualType = field.type;
  if (pageType === PageType.DETAIL && isByPkQuery(field)) {
    if (typeof actualType !== "string") {
      while (isInstanceOfType(actualType) && actualType.ofType)
        actualType = actualType.ofType;
      if (isInstanceOfType(actualType) && ((_a2 = actualType.name) == null ? void 0 : _a2.toLowerCase()) === (entityName == null ? void 0 : entityName.toLowerCase()))
        return true;
    } else if (typeof actualType === "string" && actualType === (entityName == null ? void 0 : entityName.toLowerCase())) {
      return true;
    }
  } else if (pageType === PageType.LIST && (actualType == null ? void 0 : actualType.kind) !== "OBJECT") {
    if (typeof actualType !== "string") {
      while (isInstanceOfType(actualType) && actualType.ofType)
        actualType = actualType.ofType;
      if (isInstanceOfType(actualType) && ((_b = actualType.name) == null ? void 0 : _b.toLowerCase()) === (entityName == null ? void 0 : entityName.toLowerCase()))
        return true;
    } else if (typeof actualType === "string" && actualType === (entityName == null ? void 0 : entityName.toLowerCase())) {
      return true;
    }
  }
  return false;
}
const correctTypeNames = (typeNames, fields8) => {
  typeNames.forEach((typeName, index2) => {
    fields8.every((field) => {
      var _a2;
      if (((_a2 = field.name) == null ? void 0 : _a2.toLowerCase()) === (typeName == null ? void 0 : typeName.toLowerCase())) {
        let actualType = field.type;
        let arrayType = false;
        while (isInstanceOfType(actualType) && actualType.ofType) {
          if ((actualType == null ? void 0 : actualType.kind) === "LIST")
            arrayType = true;
          actualType = actualType.ofType;
        }
        if (isInstanceOfType(actualType) && (actualType == null ? void 0 : actualType.kind) === "OBJECT") {
          if (!arrayType)
            typeNames[index2] = actualType.name;
          return false;
        }
      }
      return true;
    });
  });
  return typeNames;
};
const lastFieldParent = (typeNames, fields8, introspection) => {
  let actualTypeName = "";
  typeNames.forEach((typeName, index2) => {
    if (index2 === typeNames.length - 1)
      return false;
    fields8.every((field) => {
      var _a2;
      if (((_a2 = field.name) == null ? void 0 : _a2.toLowerCase()) === (typeName == null ? void 0 : typeName.toLowerCase())) {
        let actualType = field.type;
        while (isInstanceOfType(actualType) && actualType.ofType)
          actualType = actualType.ofType;
        if (isInstanceOfType(actualType) && (actualType == null ? void 0 : actualType.kind) === "OBJECT") {
          actualTypeName = actualType.name;
          return false;
        }
      }
      return true;
    });
  });
  const parent = introspection.types.find((type2) => {
    var _a2;
    return ((_a2 = type2 == null ? void 0 : type2.name) == null ? void 0 : _a2.toLowerCase()) === (actualTypeName == null ? void 0 : actualTypeName.toLowerCase());
  });
  return parent;
};
const findRelationshipType = (typeNames, fields8, introspection) => {
  let relationshipName = void 0;
  let relationshipType = RelationshipType.OBJECT;
  typeNames.forEach((typeName) => {
    let fieldOutsideOfTable = true;
    fields8.every((field) => {
      var _a2;
      if (((_a2 = field.name) == null ? void 0 : _a2.toLowerCase()) === (typeName == null ? void 0 : typeName.toLowerCase())) {
        fieldOutsideOfTable = false;
        let actualType = field.type;
        let arrayType = false;
        while (isInstanceOfType(actualType) && actualType.ofType) {
          if ((actualType == null ? void 0 : actualType.kind) === "LIST") {
            arrayType = true;
            relationshipType = RelationshipType.ARRAY;
          }
          actualType = actualType.ofType;
        }
        if (isInstanceOfType(actualType) && (actualType == null ? void 0 : actualType.kind) === "OBJECT") {
          if (!arrayType)
            relationshipType = RelationshipType.OBJECT;
          relationshipName = actualType.name;
          return false;
        }
      }
      return true;
    });
    if (fieldOutsideOfTable) {
      const outsideQueryWithFields = introspection.types.filter((type2) => {
        var _a2;
        return ((_a2 = type2 == null ? void 0 : type2.name) == null ? void 0 : _a2.toLowerCase()) === (relationshipName == null ? void 0 : relationshipName.toLowerCase());
      })[0];
      outsideQueryWithFields == null ? void 0 : outsideQueryWithFields.fields.every((field) => {
        var _a2;
        if (((_a2 = field.name) == null ? void 0 : _a2.toLowerCase()) === (typeName == null ? void 0 : typeName.toLowerCase())) {
          let actualType = field.type;
          let arrayType = false;
          while (isInstanceOfType(actualType) && actualType.ofType) {
            if (actualType.kind === "LIST") {
              arrayType = true;
              relationshipType = RelationshipType.ARRAY;
            }
            actualType = actualType.ofType;
          }
          if (isInstanceOfType(actualType) && (actualType == null ? void 0 : actualType.kind) === "OBJECT") {
            if (!arrayType)
              relationshipType = RelationshipType.OBJECT;
            relationshipName = actualType.name;
            return false;
          }
        }
        return true;
      });
    }
  });
  return { relationshipName, relationshipType };
};
function isInstanceOfType(object) {
  return "name" in object && "ofType" in object && "kind" in object;
}
async function fetchGraphqlIntrospectionSchema(schema2, secret) {
  try {
    const headers = { "Content-Type": "application/json" };
    if (secret) {
      headers["x-hasura-admin-secret"] = secret;
    }
    const response = await fetch(`${schema2}`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        variables: {},
        query: getIntrospectionQuery()
      })
    });
    const { data } = await response.json();
    return data.__schema;
  } catch (e) {
    throw e;
  }
}
async function fetchHasuraQuery(body2, name, migrations, workbench2) {
  const endpoint = workbench2.graphQLEndpoint.replace("/v1/graphql", "/v2/query");
  if (migrations) {
    const cwd = workbench2.injectMode === "jamstack" ? "" : workbench2.cwd;
    const directoryName = cwd + `/hasura/migrations/default/${Date.now()}_${name}`;
    await workbench2.writeFile(directoryName + "/up.sql", body2.args.sql);
  }
  const response = await fetch(endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Hasura-Role": "admin",
      "x-hasura-admin-secret": workbench2.graphQLSecret
    },
    body: JSON.stringify(body2)
  });
  return response;
}
async function fetchHasuraMetadata(body2, workbench2) {
  const endpoint = workbench2.graphQLEndpoint.replace("/graphql", "/metadata");
  const response = await fetch(endpoint, {
    headers: {
      "Content-Type": "application/json",
      "X-Hasura-Role": "admin",
      "x-hasura-admin-secret": workbench2.graphQLSecret
    },
    method: "POST",
    body: JSON.stringify(body2)
  });
  return response;
}
const capitalize$1 = (text2) => {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
};
const lowerFirstLetter = (text2) => {
  return text2.charAt(0).toLowerCase() + text2.slice(1);
};
const capitalizeFirstLetters = (name) => {
  return name.split("_").map((element2) => {
    return capitalize$1(element2);
  }).join("");
};
const runSQLQuery = (sqlQuery) => {
  return {
    type: "run_sql",
    args: {
      source: "default",
      sql: sqlQuery
    }
  };
};
const createTable$1 = (table) => {
  return runSQLQuery(`
    CREATE TABLE "${table.schema}"."${table.name}"
    (id uuid NOT NULL DEFAULT gen_random_uuid(), 
    name text NOT NULL, 
    is_deleted boolean NOT NULL DEFAULT false, 
    created_at timestamptz NOT NULL DEFAULT now(), 
    updated_at timestamptz NOT NULL DEFAULT now(), 
    PRIMARY KEY (id));


    CREATE OR REPLACE FUNCTION "${table.schema}"."set_current_timestamp_updated_at"()
    RETURNS TRIGGER AS $$
    DECLARE
      _new record;
    BEGIN
      _new := NEW;
      _new."updated_at" = NOW();
      RETURN _new;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER "set_${table.schema}_${table.name}_updated_at"
    BEFORE UPDATE ON "${table.schema}"."${table.name}"
    FOR EACH ROW
    EXECUTE PROCEDURE "${table.schema}"."set_current_timestamp_updated_at"();
    `);
};
const addColumn$1 = (props) => {
  let nullable = props.nullable ? " NULL" : " NOT NULL";
  let unique = props.unique ? " UNIQUE" : "";
  let defaultValue = props.defaultValue === "" ? " " : " default '" + props.defaultValue + "' ";
  let foreignKey = checkForeignKey(props.foreignKey) ? addForeignKey(props) : ";";
  return runSQLQuery('ALTER TABLE "' + props.schema + '"."' + props.tableName + '" ADD COLUMN "' + props.columnName + '" ' + props.type + nullable + unique + defaultValue + foreignKey);
};
const changeColumnName = (table, columnNames) => {
  let newColumnNames = columnNames.map((element2) => {
    return capitalizeFirstLetters(element2);
  });
  let newTableName = capitalizeFirstLetters(table.name);
  let customName = lowerFirstLetter(newTableName);
  let query2 = {
    type: "pg_set_table_customization",
    args: {
      table,
      configuration: {
        custom_column_names: {},
        custom_name: customName,
        custom_root_fields: returnCutomRootFields(table.name)
      }
    }
  };
  newColumnNames.forEach((element2, index2) => {
    query2.args.configuration.custom_column_names[columnNames[index2]] = lowerFirstLetter(element2);
  });
  return query2;
};
const trackTable = (table) => {
  let newTableName = capitalizeFirstLetters(table.name);
  let customName = lowerFirstLetter(newTableName);
  return {
    type: "pg_track_table",
    args: {
      table,
      configuration: {
        custom_name: customName,
        custom_root_fields: returnCutomRootFields(table.name)
      }
    }
  };
};
const returnCutomRootFields = (tableName) => {
  let newTableName = capitalizeFirstLetters(tableName);
  let customName = lowerFirstLetter(newTableName);
  let byPK = capitalizeFirstLetters(tableName).slice(0, -1);
  return {
    select: customName,
    select_by_pk: customName.slice(0, -1),
    select_aggregate: customName + "Aggregate",
    insert: "insert" + newTableName,
    insert_one: "insert" + byPK,
    update: "update" + newTableName,
    update_by_pk: "update" + byPK,
    delete: "delete" + newTableName,
    delete_by_pk: "delete" + byPK
  };
};
const getColumnNames = (table) => {
  return runSQLQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME= N'" + table.name + "' AND TABLE_SCHEMA='" + table.schema + "'");
};
const addForeignKey = (props) => {
  let foreignKeyName = props.tableName + "_" + props.columnName + "_fkey";
  return ', ADD CONSTRAINT "' + foreignKeyName + '" FOREIGN KEY ("' + props.columnName + '") REFERENCES "' + props.foreignKey.referenceSchema + '"."' + props.foreignKey.referenceTable + '" ("' + props.foreignKey.referenceColumn + '") ON UPDATE ' + props.foreignKey.updateConstraints + " ON DELETE " + props.foreignKey.deleteConstraints + ";";
};
const createObjectRelationship = (props) => {
  return {
    type: "pg_create_object_relationship",
    args: {
      name: lowerFirstLetter(capitalizeFirstLetters(props.foreignKey.referenceTable)).slice(0, -1),
      source: "default",
      table: {
        name: props.tableName,
        schema: props.schema
      },
      using: {
        foreign_key_constraint_on: props.columnName
      }
    }
  };
};
const createArrayRelationship = (props) => {
  return {
    type: "pg_create_array_relationship",
    args: {
      name: lowerFirstLetter(capitalizeFirstLetters(props.tableName)),
      source: "default",
      table: {
        name: props.foreignKey.referenceTable,
        schema: props.foreignKey.referenceSchema
      },
      using: {
        foreign_key_constraint_on: {
          column: props.columnName,
          table: {
            name: props.tableName,
            schema: props.schema
          }
        }
      }
    }
  };
};
const createSelectPermission = (table) => {
  return {
    type: "pg_create_select_permission",
    args: {
      role: "anonymous",
      source: "default",
      table,
      permission: {
        allow_aggregations: false,
        backend_only: false,
        columns: "*",
        computed_fields: [],
        filter: {},
        limit: null
      }
    }
  };
};
const createInsertPermission = (table) => {
  return {
    type: "pg_create_insert_permission",
    args: {
      role: "anonymous",
      source: "default",
      table,
      permission: {
        allow_upsert: true,
        backend_only: false,
        check: {},
        columns: "*",
        set: {}
      }
    }
  };
};
const createUpdatePermission = (table) => {
  return {
    type: "pg_create_update_permission",
    args: {
      role: "anonymous",
      source: "default",
      table,
      permission: {
        backend_only: false,
        filter: {},
        columns: "*",
        set: {}
      }
    }
  };
};
const dropPermission = (table, type2) => {
  return {
    type: type2,
    args: {
      role: "anonymous",
      source: "default",
      table
    }
  };
};
const checkForeignKey = (foreignKeyProps) => {
  if (foreignKeyProps.referenceSchema === "" || foreignKeyProps.referenceTable === "" || foreignKeyProps.referenceColumn === "")
    return false;
  return true;
};
const getTablesInfo = () => {
  return runSQLQuery("SELECT * FROM INFORMATION_SCHEMA.COLUMNS");
};
const getConstraintInfo = () => {
  return runSQLQuery("SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE");
};
async function createPermissions(table, workbench2) {
  fetchHasuraMetadata(createInsertPermission(table), workbench2).catch((res2) => console.error(res2));
  fetchHasuraMetadata(createUpdatePermission(table), workbench2).catch((res2) => console.error(res2));
  return await fetchHasuraMetadata(createSelectPermission(table), workbench2).catch((err2) => {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: {
        type: `CREATE_TABLE_ERROR`
      }
    });
    return Promise.reject(err2);
  });
}
function dropAndCreatePermissions(columnProps, workbench2, showSuccessSnackBar) {
  fetchHasuraMetadata(dropPermission({ name: columnProps.tableName, schema: columnProps.schema }, "pg_drop_insert_permission"), workbench2).then(() => fetchHasuraMetadata(createInsertPermission({
    name: columnProps.tableName,
    schema: columnProps.schema
  }), workbench2).catch((res2) => console.error(res2)));
  fetchHasuraMetadata(dropPermission({ name: columnProps.tableName, schema: columnProps.schema }, "pg_drop_select_permission"), workbench2).then(() => fetchHasuraMetadata(createSelectPermission({
    name: columnProps.tableName,
    schema: columnProps.schema
  }), workbench2).then(() => {
    if (showSuccessSnackBar)
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `ADD_COLUMN_SUCCESS`
        }
      });
  }).catch((res2) => console.error(res2))).catch((res2) => console.error(res2));
  fetchHasuraMetadata(dropPermission({ name: columnProps.tableName, schema: columnProps.schema }, "pg_drop_update_permission"), workbench2).then(() => fetchHasuraMetadata(createUpdatePermission({
    name: columnProps.tableName,
    schema: columnProps.schema
  }), workbench2).catch((res2) => console.error(res2)));
}
const getColumns = (data, newColumnName) => {
  const COLUMN_NAME_INDEX = 3;
  let columnNames = [];
  data.result.forEach((element2) => {
    columnNames.push(element2[COLUMN_NAME_INDEX]);
  });
  columnNames.shift();
  if (newColumnName) {
    columnNames.push(newColumnName);
  }
  return columnNames;
};
function handleErrors(res2) {
  if (!res2.ok) {
    throw new Error(res2.statusText);
  }
  return res2.json();
}
function createColumn(columnProps, migration, workbench2) {
  let columnNames;
  let promise2 = fetchHasuraQuery(getColumnNames({ name: columnProps.tableName, schema: columnProps.schema }), "get_columns", false, workbench2).then(handleErrors);
  promise2 = promise2.then((res2) => {
    columnNames = getColumns(res2, columnProps.columnName);
    return fetchHasuraQuery(addColumn$1(columnProps), "add_column_" + columnProps.columnName, migration, workbench2).then(handleErrors);
  }).catch((error2) => {
    return Promise.reject(error2);
  });
  return promise2.then(() => {
    return fetchHasuraMetadata(changeColumnName({ name: columnProps.tableName, schema: columnProps.schema }, columnNames), workbench2).then(handleErrors);
  }).catch((error2) => {
    return Promise.reject(error2);
  });
}
function resolveForeignKey(columnProps, workbench2, errorType, showSuccessSnackBar) {
  let promise2;
  if (checkForeignKey(columnProps.foreignKey)) {
    promise2 = fetchHasuraMetadata(createObjectRelationship(columnProps), workbench2).then(handleErrors);
    promise2 = promise2.then(() => {
      return fetchHasuraMetadata(createArrayRelationship(columnProps), workbench2).then(handleErrors);
    }).catch((error2) => {
      return Promise.reject(error2);
    });
    promise2.then(() => dropAndCreatePermissions(columnProps, workbench2, showSuccessSnackBar)).catch(() => {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: errorType
        }
      });
    });
  } else {
    dropAndCreatePermissions(columnProps, workbench2, showSuccessSnackBar);
  }
}
const TABLE_SCHEMA = 1;
const TABLE_NAME = 2;
const COLUMN_NAME = 3;
const COLUMN_DEFAULT = 5;
const IS_NULLABLE = 6;
const DATA_TYPE = 7;
const USER_DEFINED_TYPE = 27;
const CONSTRAINT_SCHEMA = 1;
const CONSTRAINT_NAME = 2;
const CONSTRAINT_TABLE_NAME = 5;
const CONSTRAINT_TABLE_SCHEMA = 4;
const CONSTRAINT_COLUMN = 6;
const PRIMARY_KEY = "pkey";
const FOREIGN_KEY = "fkey";
const OBJECT_RELATIONSHIP = "object relationship";
const dataTypes = [
  {
    name: "Column Type",
    type: void 0
  },
  {
    name: "bigint",
    type: "bigint"
  },
  {
    name: "bigserial",
    type: "bigserial"
  },
  {
    name: "bit",
    type: "bit"
  },
  {
    name: "bit varying",
    type: "varbit"
  },
  {
    name: "boolean",
    type: "boolean"
  },
  {
    name: "box",
    type: "box"
  },
  {
    name: "box2d",
    type: "box2d"
  },
  {
    name: "box2df",
    type: "box2df"
  },
  {
    name: "box3d",
    type: "box3d"
  },
  {
    name: "bytea",
    type: "bytea"
  },
  {
    name: "character",
    type: "bpchar"
  },
  {
    name: "character varying",
    type: "varchar"
  },
  {
    name: "cidr",
    type: "cidr"
  },
  {
    name: "circle",
    type: "circle"
  },
  {
    name: "date",
    type: "date"
  },
  {
    name: "double precision",
    type: "float8"
  },
  {
    name: "geography",
    type: "geography"
  },
  {
    name: "geometry",
    type: "geometry"
  },
  {
    name: "geometry-dump",
    type: "geometry_dump"
  },
  {
    name: "geomval",
    type: "geomval"
  },
  {
    name: "gidx",
    type: "gidx"
  },
  {
    name: "inet",
    type: "inet"
  },
  {
    name: "integer",
    type: "integer"
  },
  {
    name: "interval",
    type: "interval"
  },
  {
    name: "json",
    type: "json"
  },
  {
    name: "jsonb",
    type: "jsonb"
  },
  {
    name: "line",
    type: "line"
  },
  {
    name: "lseg",
    type: "lseg"
  },
  {
    name: "ltree",
    type: "ltree"
  },
  {
    name: "macaddr",
    type: "macaddr"
  },
  {
    name: "macaddr8",
    type: "macaddr8"
  },
  {
    name: "money",
    type: "money"
  },
  {
    name: "numeric",
    type: "numeric"
  },
  {
    name: "path",
    type: "path"
  },
  {
    name: "pg_lsn",
    type: "pg_lsn"
  },
  {
    name: "point",
    type: "point"
  },
  {
    name: "polygon",
    type: "polygon"
  },
  {
    name: "real",
    type: "float4"
  },
  {
    name: "smallint",
    type: "int2"
  },
  {
    name: "serial",
    type: "serial"
  },
  {
    name: "text",
    type: "text"
  },
  {
    name: "time without time zone",
    type: "time"
  },
  {
    name: "time with time zone",
    type: "timetz"
  },
  {
    name: "timestamp without time zone",
    type: "timestamp"
  },
  {
    name: "timestamp with time zone",
    type: "timestamptz"
  },
  {
    name: "tsquery",
    type: "tsquery"
  },
  {
    name: "tsvector",
    type: "tsvector"
  },
  {
    name: "txid_snapshot",
    type: "txid_snapshot"
  },
  {
    name: "uuid",
    type: "uuid"
  },
  {
    name: "xid8",
    type: "xid8"
  },
  {
    name: "xml",
    type: "xml"
  }
];
const resolveTableName = (tableName) => {
  let newName = "";
  tableName = lowerFirstLetter(tableName);
  for (let letter of tableName) {
    if (letter.toUpperCase() !== letter.toLowerCase() && letter.toUpperCase() === letter) {
      newName += "_" + letter.toLowerCase();
    } else {
      newName += letter;
    }
  }
  return newName;
};
const returnType$1 = (dataType) => {
  var _a2;
  return (_a2 = dataTypes.filter((el2) => el2.name === dataType || el2.type === dataType)[0]) == null ? void 0 : _a2.type;
};
const createTables = (tableName, tablesInfo, constraintMap) => {
  let tables = tablesInfo.get(tableName);
  const unique = [...new Set(tables == null ? void 0 : tables.map((item) => item.tableSchema))];
  let result2 = [];
  let newTablesInfo;
  let newTables;
  unique.forEach((schema2) => {
    newTablesInfo = new Map(tablesInfo);
    newTables = tables == null ? void 0 : tables.filter((item) => item.tableSchema === schema2);
    if (newTables) {
      newTablesInfo.set(tableName, newTables);
      result2.push(createTable(schema2, tableName, newTablesInfo, constraintMap));
    }
  });
  return result2;
};
const createTable = (schema2, tableName, tablesInfo, constraintMap) => {
  var _a2, _b;
  let tables = tablesInfo.get(tableName);
  let resultTable = {
    schema: schema2,
    name: (_b = (_a2 = tables == null ? void 0 : tables[0]) == null ? void 0 : _a2.tableName) != null ? _b : tableName,
    primaryKey: "",
    columns: []
  };
  if (!tables) {
    return resultTable;
  }
  let constraints = constraintMap.get(tableName);
  if (!constraints)
    return resultTable;
  constraints = constraints.filter((element2) => element2.constraintName.includes(PRIMARY_KEY));
  resultTable.primaryKey = constraints[0].column;
  tables.forEach((column) => {
    resultTable.columns.push({
      name: column.columnName,
      type: returnType$1(column.type === "USER-DEFINED" ? column.udtType : column.type),
      nullable: column.isNullable,
      default: column.columnDefault
    });
  });
  return resultTable;
};
const alterTable = (constraint, referenceTable, referenceColumn, schema2) => {
  return {
    tableName: constraint.tableName,
    constraintName: constraint.constraintName,
    constraintColumn: constraint.column,
    referenceTable,
    referenceColumn,
    tableSchema: constraint.tableSchema,
    referenceSchema: schema2
  };
};
const getConstraints = (constraint, typesCollection2, constraintMap, tables) => {
  let foriengKeys = [];
  let table = typesCollection2.get(resolveTableName(constraint.tableName));
  if (table) {
    table.fields.forEach((element2) => {
      if (element2.description && element2.description.includes(OBJECT_RELATIONSHIP)) {
        let tableName = resolveConstraintName(resolveTableName(element2.name), tables);
        let constraints = constraintMap.get(tableName);
        if (!constraints) {
          return "";
        }
        constraints = constraints.filter((element22) => element22.constraintName.includes(PRIMARY_KEY));
        foriengKeys.push(alterTable(constraint, constraints[0].tableName, constraints[0].column, constraints[0].tableSchema));
      }
    });
  }
  return foriengKeys;
};
const resolveConstraintName = (tableName, tables) => {
  const re = new RegExp(tableName + ".$");
  if (!tables)
    return tableName;
  const result2 = tables.filter((table) => re.test(table));
  return result2.length > 0 ? result2[0] : tableName;
};
const removeByPK = (fields8) => {
  return fields8.filter((word) => word.description === null || word.description && !word.description.includes("primary key"));
};
const getTables = (typesCollection2) => {
  let tableNames = new Array();
  let tables = typesCollection2.get("query_root");
  if (!tables)
    return tableNames;
  removeByPK(tables.fields).forEach((element2) => {
    tableNames.push(resolveTableName(element2.name));
  });
  return tableNames;
};
const setTypes = (es) => {
  const typesCollection2 = /* @__PURE__ */ new Map();
  for (const e of es) {
    e.fields = (e.fields || []).map((f) => {
      let type2 = f.name;
      return __spreadProps2(__spreadValues2({}, f), { type: type2 });
    });
    typesCollection2.set(resolveTableName(e.name), e);
  }
  return typesCollection2;
};
const setTableInfo = (info) => {
  const collection = /* @__PURE__ */ new Map();
  for (const e of info) {
    let isNullable = e[IS_NULLABLE] == "YES" ? true : false;
    let table = {
      tableSchema: e[TABLE_SCHEMA],
      tableName: e[TABLE_NAME],
      columnName: e[COLUMN_NAME],
      columnDefault: e[COLUMN_DEFAULT],
      isNullable,
      type: e[DATA_TYPE],
      udtType: e[USER_DEFINED_TYPE]
    };
    let tables = collection.get(resolveTableName(table.tableName));
    if (tables) {
      tables.push(table);
    } else {
      tables = new Array(table);
    }
    collection.set(resolveTableName(table.tableName), tables);
  }
  return collection;
};
const setConstraintInfo = (info) => {
  const collection = /* @__PURE__ */ new Map();
  for (const e of info) {
    let constraint = {
      constraintSchema: e[CONSTRAINT_SCHEMA],
      constraintName: e[CONSTRAINT_NAME],
      tableSchema: e[CONSTRAINT_TABLE_SCHEMA],
      tableName: e[CONSTRAINT_TABLE_NAME],
      column: e[CONSTRAINT_COLUMN]
    };
    let constraints = collection.get(resolveTableName(constraint.tableName));
    if (constraints) {
      constraints.push(constraint);
    } else {
      constraints = new Array(constraint);
    }
    collection.set(resolveTableName(constraint.tableName), constraints);
  }
  return collection;
};
function generateSQLData(introspection, tablesInfo, constraints) {
  const sqlData = {
    tables: [],
    foreignKeys: []
  };
  tablesInfo.shift();
  constraints.shift();
  const typesCollection2 = setTypes(introspection.types);
  const tables = getTables(typesCollection2);
  const tablesMap = setTableInfo(tablesInfo);
  const constraintMap = setConstraintInfo(constraints);
  tables.forEach((table) => {
    sqlData.tables.push(...createTables(table, tablesMap, constraintMap));
  });
  constraintMap.forEach((constraints2) => {
    constraints2.filter((constraint) => constraint.constraintName.includes(FOREIGN_KEY)).forEach((constraint) => {
      sqlData.foreignKeys.push(...getConstraints(constraint, typesCollection2, constraintMap, tables));
    });
  });
  return sqlData;
}
const filterIntrospection = (introspection, entityName) => {
  const introspectionInstance = JSON.parse(JSON.stringify(introspection));
  const queryRoot = introspectionInstance.types.find((type2) => {
    var _a2;
    return type2.name === ((_a2 = introspectionInstance.queryType) == null ? void 0 : _a2.name);
  });
  if (queryRoot && queryRoot.fields) {
    queryRoot.fields = queryRoot.fields.filter((field) => isOfTypePage(field, entityName, 0));
    return introspectionInstance;
  }
};
const entityExists = (types, entityName) => types.some((type2) => type2.name === entityName);
const addColumn = async (graphQLFile, introspection, entityName, fieldTrees, pageType, referenceField, insertType = InsertType.BEFORE) => {
  const [queryRoot] = getRoots(introspection);
  const field = queryRoot.fields.find((field2) => isOfTypePage(field2, entityName, pageType));
  const fieldName = field == null ? void 0 : field.name;
  const queryName = fieldName != null ? fieldName : entityName;
  let modifiedGraphQLFile = graphQLFile;
  const queryWithFields = introspection.types.find((type2) => type2.name.toLowerCase() === entityName.toLowerCase());
  fieldTrees.forEach((tree) => {
    const fieldTreeArray = tree.split(".");
    let typeNames = fieldTreeArray.slice(1);
    typeNames = correctTypeNames(typeNames, queryWithFields.fields);
    let { relationshipName } = findRelationshipType(typeNames, queryWithFields.fields, introspection);
    const lastParent = lastFieldParent(typeNames, queryWithFields.fields, introspection);
    const idField = typeNames[typeNames.length - 1] != "id" ? lastParent == null ? void 0 : lastParent.fields.find((field2) => field2.name === "id") : void 0;
    const additionalFields = idField ? ["id"] : [];
    const typeNamesSlice = typeNames.slice(0, -1);
    const newFragmentName = getFragmentName$1([queryName, ...typeNamesSlice], modifiedGraphQLFile);
    const insertedField = [typeNames[typeNames.length - 1]];
    if (fragmentExists(modifiedGraphQLFile, newFragmentName)) {
      modifiedGraphQLFile = addFieldToFragment(modifiedGraphQLFile, newFragmentName, insertedField, referenceField, insertType, additionalFields);
    } else {
      modifiedGraphQLFile += `

${buildFragmentFromFieldsTree(queryName, relationshipName != null ? relationshipName : queryName, typeNames, additionalFields)}`;
      const modifiedFile = insertFragmentSpreadIntoFragment(modifiedGraphQLFile, queryName, entityName, typeNamesSlice);
      if (modifiedFile === "")
        modifiedGraphQLFile = buildFieldTreeInQuery(modifiedGraphQLFile, queryName, entityName, typeNamesSlice);
      else {
        const scalarFieldsToBeMoved = getScalarFieldsFromFragment(modifiedFile, typeNamesSlice, `${queryName}_${entityName}`);
        modifiedGraphQLFile = removeFieldsFromFragment(modifiedFile, typeNamesSlice, scalarFieldsToBeMoved, `${queryName}_${entityName}`);
        modifiedGraphQLFile = addFieldToFragment(modifiedGraphQLFile, newFragmentName, [], referenceField, insertType, scalarFieldsToBeMoved);
      }
    }
  });
  modifiedGraphQLFile = print(parse$6(modifiedGraphQLFile));
  return modifiedGraphQLFile;
};
const getFragmentName$1 = (fieldTree, graphqlFile) => {
  if (fieldTree.length == 1) {
    try {
      const ast = parse$6(graphqlFile);
      const entityName = fieldTree[0];
      let fragmentSpreadName = "";
      visit(ast, {
        OperationDefinition(node) {
          var _a2, _b;
          if (((_a2 = node.name) == null ? void 0 : _a2.value) === entityName) {
            const field = node.selectionSet.selections[0];
            const fragmentSpread = (_b = field.selectionSet) == null ? void 0 : _b.selections[0];
            fragmentSpreadName = fragmentSpread.name.value;
          }
        }
      });
      return fragmentSpreadName;
    } catch (err2) {
      console.error(err2);
    }
  }
  return buildFragmentNameFromFieldsTree(fieldTree);
};
const createMixedImport = (namedImports, moduleSpecifier, defaultImport) => factory.createImportDeclaration(void 0, void 0, factory.createImportClause(false, defaultImport != null ? defaultImport : void 0, factory.createNamedImports(namedImports)), factory.createIdentifier(moduleSpecifier));
const createNameSpaceImport = (namespace, module2) => {
  return factory.createImportDeclaration(void 0, void 0, factory.createImportClause(false, void 0, factory.createNamespaceImport(factory.createIdentifier(namespace))), factory.createIdentifier(module2));
};
const createDefaultImport = (identifier, module2) => factory.createImportDeclaration(void 0, void 0, factory.createImportClause(false, factory.createIdentifier(identifier), void 0), factory.createIdentifier(module2));
const createJsxSelfClosingElement = (name, atributes) => factory.createJsxSelfClosingElement(factory.createIdentifier(name), void 0, factory.createJsxAttributes(atributes.map((atribute) => factory.createJsxAttribute(factory.createIdentifier(atribute.name), factory.createJsxExpression(void 0, factory.createIdentifier(atribute.initializer))))));
const stripQuotes = (str2) => str2.replace(/['"]+/g, "");
const mergeImports = (parentAst, childAst) => {
  const importsArray = getMergeImports(parentAst, childAst);
  if (importsArray) {
    const importPosition = findPositionOfFirstImport(parentAst);
    const finalAst = appendElementsToAst(parentAst, importPosition, importsArray);
    return finalAst;
  } else {
    return parentAst;
  }
};
const getMergeImports = (parentAst, childAst) => {
  const parentAstImports = parentAst.statements.filter((s) => ts.isImportDeclaration(s));
  const childAstImports = childAst.statements.filter((s) => ts.isImportDeclaration(s));
  const importMap = createImportMap(parentAstImports);
  const importsArray = getNewImportsArray(childAstImports, importMap);
  return importsArray;
};
const getImportIdentifiers = (importDeclaration) => {
  const identifiers = /* @__PURE__ */ new Set();
  const { importClause } = importDeclaration;
  if (!importClause)
    return null;
  if (importClause.name)
    identifiers.add(importClause.name.getText());
  if (importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {
    importClause.namedBindings.elements.forEach((e) => identifiers.add(e.name.getText()));
  }
  if (importClause.namedBindings && ts.isNamespaceImport(importClause.namedBindings)) {
    identifiers.add(importClause.namedBindings.name.getText());
  }
  return Array.from(identifiers);
};
const createImportMap = (importDeclarations) => {
  const importMap = /* @__PURE__ */ new Map();
  importDeclarations.forEach((iD) => {
    const moduleSpecifier = stripQuotes(iD.moduleSpecifier.getText());
    const importIdentifiers = getImportIdentifiers(iD);
    if (!importIdentifiers)
      return;
    const currEntry = importMap.get(moduleSpecifier);
    if (currEntry) {
      importMap.set(moduleSpecifier, [...currEntry, ...importIdentifiers]);
    } else {
      importMap.set(moduleSpecifier, importIdentifiers);
    }
  });
  return importMap;
};
const getNewImportsArray = (childImports, importMap) => {
  const newImports = [];
  childImports.forEach((importDeclaration) => {
    var _a2;
    const moduleSpecifier = stripQuotes(importDeclaration.moduleSpecifier.getText());
    const { importClause } = importDeclaration;
    if (!importClause)
      return;
    if (!importMap.has(moduleSpecifier)) {
      newImports.push(importDeclaration);
      return;
    }
    const importIdentifiers = getImportIdentifiers(importDeclaration);
    const currIdentifiers = importMap.get(moduleSpecifier);
    if (!importIdentifiers || !currIdentifiers)
      return;
    const uniqueIdentifiers = importIdentifiers.filter((iI) => !currIdentifiers.includes(iI));
    if (uniqueIdentifiers.length === 0)
      return;
    if (uniqueIdentifiers.length === 1 && ((_a2 = importClause.name) == null ? void 0 : _a2.getText()) === uniqueIdentifiers[0]) {
      const newImport2 = createDefaultImport(uniqueIdentifiers[0], importDeclaration.moduleSpecifier.getText());
      newImports.push(newImport2);
      return;
    }
    if (uniqueIdentifiers.length === 1 && importClause.namedBindings && ts.isNamespaceImport(importClause.namedBindings) && importClause.namedBindings.name.getText() === uniqueIdentifiers[0]) {
      const newImport2 = createNameSpaceImport(uniqueIdentifiers[0], importDeclaration.moduleSpecifier.getText());
      newImports.push(newImport2);
      return;
    }
    const newImport = stripNonUniqueIdentifiersFromImport(importDeclaration, uniqueIdentifiers);
    if (newImport)
      newImports.push(newImport);
  });
  newImports.map((value2) => {
    stripRanges(value2);
  });
  return newImports;
};
const getFilteredNamedImports = (importClause, uniqueIdentifiers) => {
  if (importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {
    const uniqueNamedImports = importClause.namedBindings.elements.filter((namedImport) => uniqueIdentifiers.includes(namedImport.name.getText()));
    return uniqueNamedImports.length > 0 ? uniqueNamedImports : null;
  }
  return null;
};
const stripNonUniqueIdentifiersFromImport = (importDeclaration, uniqueIdentifiers) => {
  var _a2;
  const { importClause } = importDeclaration;
  if (!importClause)
    return null;
  const filteredNamedImports = getFilteredNamedImports(importClause, uniqueIdentifiers);
  if (!filteredNamedImports)
    return null;
  const defaultImport = (_a2 = importClause.name) == null ? void 0 : _a2.getText();
  const moduleSpecifier = importDeclaration.moduleSpecifier.getText();
  if (defaultImport && uniqueIdentifiers.includes(defaultImport)) {
    const finalImport2 = createMixedImport(filteredNamedImports, moduleSpecifier, importClause.name);
    return finalImport2;
  }
  const finalImport = createMixedImport(filteredNamedImports, moduleSpecifier);
  return finalImport;
};
const removeUnusedDefaultImport = (ast, importName) => {
  const newAst = conditionalyWithParamRemoveNodeInAst(ast, isDefaultImport, importName);
  return newAst;
};
const isDefaultImport = (node, text2) => {
  var _a2, _b;
  return ts.isImportDeclaration(node) && node.parent && ts.isSourceFile(node.parent) && ((_b = (_a2 = node.importClause) == null ? void 0 : _a2.name) == null ? void 0 : _b.getText()) === text2;
};
const findFields = (node, fieldNames) => {
  var _a2;
  if (!node)
    return [];
  const foundFields = (_a2 = fieldNames == null ? void 0 : fieldNames.map((name) => {
    if (fieldExists(node, name))
      return name;
  })) == null ? void 0 : _a2.filter(Boolean);
  return foundFields;
};
const fieldExists = (ast, fieldName) => {
  const nodeOccurences = findAllByConditionWithParam(ast, isStringLiteralOrIdentifier, fieldName);
  return nodeOccurences.length !== 0;
};
const isStringLiteralOrIdentifier = (node, param) => (ts.isStringLiteral(node) || ts.isIdentifier(node)) && node.text.includes(param);
const isIdentifierWithName = (node, param) => ts.isIdentifier(node) && node.text === param;
const isStringLiteralWithNameLike = (node, param) => ts.isStringLiteralLike(node) && node.text === param;
const renameFields = (node, oldField, newField, split) => {
  const found = [
    ...findAllByCondition(node, ts.isIdentifier),
    ...findAllByCondition(node, ts.isStringLiteral)
  ];
  const foundOccurences = found.reduce((arr, el2) => {
    if (el2.getText().indexOf(oldField) !== -1)
      arr.push(el2.getText().replaceAll(/"|'/g, ""));
    return arr;
  }, []);
  const foundOccurencesUnique = [...new Set(foundOccurences)];
  let foundOccurencesSplited = foundOccurencesUnique.map((el2) => {
    if (split) {
      return el2.replaceAll(/'|"/g, "").split(".");
    }
    return [el2.replaceAll(/'|"/g, "")];
  });
  const occurencesReplaceOldField = foundOccurencesSplited.map((el2) => el2.map((subEl) => {
    if (subEl === oldField)
      return newField;
    return subEl;
  }));
  const finalNewFields = occurencesReplaceOldField.map((el2) => {
    if (split) {
      return el2.join(".");
    }
    return el2.join("");
  });
  let finalAst;
  finalNewFields.forEach((el2, i2) => {
    const newIdentifier = factory.createIdentifier(el2);
    stripRanges(newIdentifier);
    finalAst = conditionalyWithParamReplaceNodeInAst(node, isIdentifierWithName, foundOccurencesUnique[i2], newIdentifier);
  });
  finalNewFields.forEach((el2, i2) => {
    const newStringLiteral = factory.createStringLiteral(el2);
    stripRanges(newStringLiteral);
    finalAst = conditionalyWithParamReplaceNodeInAst(finalAst, isStringLiteralWithNameLike, foundOccurencesUnique[i2], newStringLiteral);
  });
  if (!finalAst)
    return;
  stripRanges(finalAst);
  return finalAst;
};
const codeStart = (code2, source) => {
  const identifierStart = startOfJsxIdentifier(code2, source);
  if (!identifierStart)
    return null;
  const identifierNode = astFindStart(code2, identifierStart);
  if (!identifierNode)
    return null;
  if (ts.isJsxSelfClosingElement(identifierNode.parent))
    return identifierNode.parent.pos;
  if (ts.isJsxOpeningElement(identifierNode.parent))
    return identifierNode.parent.parent.pos;
};
const cloneElementInAst = (code2, source) => {
  const ast = createAst(code2);
  const node = astFindSource(code2, source);
  if (!node || !ast)
    return null;
  const finalNode = ts.isParenthesizedExpression(node) ? node.expression : node;
  const alteredAst = appendElementsToAst(ast, { pos: finalNode.pos, end: finalNode.end }, [finalNode]);
  return alteredAst;
};
const cloneAndRenameElementInAst = (code2, source, oldField, newField) => {
  const ast = createAst(code2);
  const node = astFindSource(code2, source);
  if (!node || !ast)
    return null;
  const finalNode = renameFields(node, oldField, newField, true);
  if (!finalNode)
    return null;
  const alteredAst = appendElementsToAst(ast, { pos: node.pos, end: node.end }, [finalNode]);
  return alteredAst;
};
function astFindSource(code2, source) {
  const start = codeStart(code2, source);
  if (start) {
    const found = astFindStart(code2, start);
    return found;
  }
  return null;
}
function startOfJsxIdentifier(code2, source) {
  if (typeof code2 != "string")
    return null;
  const sourceLines = code2.split("\n");
  if (source.lineNumber > 0 && source.lineNumber < sourceLines.length) {
    const lineIndex = source.lineNumber - 1;
    let start = 0;
    for (let i2 = 0; i2 < lineIndex; ++i2) {
      const line = sourceLines[i2];
      start += line.length + 1;
    }
    start += source.columnNumber - 1;
    start += 1;
    return start;
  }
  return null;
}
function astFindStart(code2, start) {
  const ast = createAst(code2);
  const callback = (node) => {
    const nodeStart = node.pos;
    if (nodeStart <= start && start <= node.end) {
      if (nodeStart === start) {
        return node;
      }
      return ts.forEachChild(node, callback);
    }
    return null;
  };
  if (ast) {
    const found = ts.forEachChild(ast, callback);
    return found;
  }
  return null;
}
const removeElementInAst = (code2, source) => {
  const ast = createAst(code2);
  const { pos, end } = astFindSource(code2, source);
  if (!pos || !end || !ast)
    return null;
  const alteredAst = removeElementFromAst(ast, { pos, end });
  return alteredAst;
};
const renameAndReplaceElementInAst = (ast, node, oldText, newText) => {
  const finalNode = renameFields(node, oldText, newText, false);
  if (!finalNode)
    return ast;
  ast = replaceElementsInAst(ast, {
    pos: node.pos,
    end: node.end
  }, finalNode);
  return ast;
};
function parseLocaleJSON(localeSourceCode, languageLocale = "en") {
  const localeAst = createAst(localeSourceCode, ts.ScriptTarget.ESNext, ts.ScriptKind.JSON);
  if (localeAst) {
    return parseLocaleAST(localeAst, languageLocale);
  }
}
function parseLocaleAST(ast, languageLocale = "en") {
  let localeMessages = [];
  ast == null ? void 0 : ast.forEachChild((child) => {
    var _a2, _b;
    (_b = (_a2 = child == null ? void 0 : child.expression) == null ? void 0 : _a2.properties) == null ? void 0 : _b.forEach((property2) => {
      var _a3, _b2, _c;
      let locale = {
        id: property2.name.text,
        value: (_a3 = property2.initializer) == null ? void 0 : _a3.text,
        locale: languageLocale,
        position: {
          pos: (_b2 = property2.initializer) == null ? void 0 : _b2.pos,
          end: (_c = property2.initializer) == null ? void 0 : _c.end
        }
      };
      localeMessages = [...localeMessages, locale];
    });
  });
  return localeMessages;
}
const reorderElementsInAst = async (code2, data) => {
  const ast = createAst(code2);
  if (!ast)
    return null;
  let alteredAst = ast;
  Object.keys(data.chained_changes).forEach((key) => {
    let tmpNode = astFindStart(code2, data.elementsPosEnd[key].pos);
    stripRanges(tmpNode);
    alteredAst = replaceElementsInAst(alteredAst, {
      pos: data.elementsPosEnd[data.chained_changes[key]].pos,
      end: data.elementsPosEnd[data.chained_changes[key]].end
    }, tmpNode);
  });
  return await regenerateAst(alteredAst);
};
const findColumn = (code2, source) => {
  const node = astFindSource(code2, source);
  let parent = node;
  while (parent && !ts.isObjectLiteralExpression(parent)) {
    parent = parent.parent;
  }
  return parent;
};
const getReactComponentNode = (ast, componentName) => {
  const reactComponent = findByConditionWithParam(ast, isNamedReactComponentFunction, componentName);
  return reactComponent != null ? reactComponent : null;
};
const getComponentBodyFromReactComponent = (componentFunction) => {
  const body2 = componentFunction.body;
  if (!body2)
    return null;
  if (ts.isJsxOpeningLikeElement(body2) || ts.isJsxElement(body2))
    return null;
  if (ts.isBlock(body2)) {
    const componentBodyStatements = body2.statements.filter((s) => !ts.isReturnStatement(s));
    return componentBodyStatements;
  }
  return null;
};
const getReturnedJsxFromReactComponent = (componentFunction) => {
  const body2 = componentFunction.body;
  if (!body2)
    return null;
  if (ts.isJsxOpeningLikeElement(body2) || ts.isJsxElement(body2))
    return body2;
  if (ts.isParenthesizedExpression(body2))
    return body2.expression;
  if (ts.isBlock(body2)) {
    const returnStatement = body2.statements.filter((s) => ts.isReturnStatement(s));
    if (returnStatement.length === 1) {
      const node = returnStatement[0].expression;
      if (!node)
        return null;
      if (ts.isParenthesizedExpression(node))
        return node.expression;
      else
        return node;
    }
  }
  return null;
};
const isNamedReactComponentFunction = (node, name) => {
  var _a2;
  return ts.isArrowFunction(node) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.name.getText() === name && node.parent.parent && ts.isVariableDeclarationList(node.parent.parent) && node.parent.parent.parent && ts.isVariableStatement(node.parent.parent.parent) && node.parent.parent.parent.parent && ts.isSourceFile(node.parent.parent.parent.parent) || ts.isFunctionDeclaration(node) && ((_a2 = node.name) == null ? void 0 : _a2.getText()) === name && node.parent && ts.isSourceFile(node.parent);
};
const isReactComponentFunction = (node) => ts.isArrowFunction(node) && node.parent && ts.isVariableDeclaration(node.parent) && node.parent.parent && ts.isVariableDeclarationList(node.parent.parent) && node.parent.parent.parent && ts.isVariableStatement(node.parent.parent.parent) && node.parent.parent.parent.parent && ts.isSourceFile(node.parent.parent.parent.parent) || ts.isFunctionDeclaration(node) && node.parent && ts.isSourceFile(node.parent);
const isBooleanLiteral = (node) => isTrueKeyword(node) || isFalseKeyword(node);
const isTrueKeyword = (node) => node.kind === ts.SyntaxKind.TrueKeyword;
const isFalseKeyword = (node) => node.kind === ts.SyntaxKind.FalseKeyword;
const isNullKeyword = (node) => node.kind === ts.SyntaxKind.NullKeyword;
const isPrimitiveProp$1 = (node) => node.kind === ts.SyntaxKind.StringLiteral || node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword || node.kind === ts.SyntaxKind.NullKeyword || node.kind === ts.SyntaxKind.NumericLiteral || node.kind === ts.SyntaxKind.Identifier && node.getText() === "undefined" || node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral;
const copyPrimitiveProps = (parentJsx, childJsx) => {
  const nodes = findAllByCondition(parentJsx, isPrimitivePropOnParent);
  const primitivePropsMap = /* @__PURE__ */ new Map();
  nodes.forEach((n2) => {
    const propName = ts.isJsxAttribute(n2.parent.parent) ? n2.parent.parent.name.getText() : n2.parent.name.getText();
    primitivePropsMap.set(propName, n2);
  });
  let finalChildJsx = childJsx;
  primitivePropsMap.forEach((node, key) => {
    const propOccurences = findAllByConditionWithParam(finalChildJsx, isPrimitiveProp, key);
    const newNode = createNewNodeForPrimitiveProp(node);
    if (!newNode)
      return;
    propOccurences.forEach((pO) => {
      const nodePosition = { pos: pO.pos, end: pO.end };
      if (!ts.isJsxAttribute(pO.parent))
        finalChildJsx = replaceElementsInAst(finalChildJsx, nodePosition, newNode);
    });
  });
  return finalChildJsx;
};
const createNewNodeForPrimitiveProp = (node) => {
  let newNode = null;
  if (ts.isStringLiteral(node)) {
    newNode = factory.createNoSubstitutionTemplateLiteral(node.text);
  }
  if (ts.isNumericLiteral(node)) {
    newNode = factory.createNumericLiteral(node.text);
  }
  if (ts.isIdentifier(node) && node.getText() !== "undefined") {
    newNode = factory.createIdentifier(node.getText());
  }
  if (isNullKeyword(node))
    newNode = factory.createNull();
  if (isTrueKeyword(node))
    newNode = factory.createTrue();
  if (isFalseKeyword(node))
    newNode = factory.createFalse();
  return newNode;
};
const isPrimitivePropOnParent = (node) => (ts.isNumericLiteral(node) || ts.isStringLiteral(node) || isBooleanLiteral(node) || isNullKeyword(node) || ts.isIdentifier(node) && node.getText() !== "undefined") && node.parent && ts.isJsxExpression(node.parent) || ts.isStringLiteral(node) && node.parent && ts.isJsxAttribute(node.parent);
const isPrimitiveProp = (node, text2) => ts.isIdentifier(node) && node.text === text2;
const flattenStringLiterals = (node) => {
  const templateExpressions = findAllByCondition(node, ts.isTemplateExpression);
  let finalNode = node;
  templateExpressions.forEach((tE) => {
    const newTemplateSpans = [];
    let newTemplateHead = tE.head;
    tE.templateSpans.forEach((tS, i2) => {
      if (isPrimitiveProp$1(tS.expression)) {
        let newText = ts.isStringLiteral(tS.expression) || ts.isNoSubstitutionTemplateLiteral(tS.expression) ? tS.expression.text + tS.literal.text : tS.expression.getText() + tS.literal.text;
        const lastTemplateSpan = newTemplateSpans.pop();
        if (!lastTemplateSpan) {
          newTemplateHead = factory.createTemplateHead(newTemplateHead.text + newText);
          return;
        }
        newText = lastTemplateSpan.literal.text + newText;
        const newTemplateSpan = factory.createTemplateSpan(lastTemplateSpan.expression, i2 === tE.templateSpans.length - 1 ? factory.createTemplateTail(newText) : factory.createTemplateMiddle(newText));
        newTemplateSpans.push(newTemplateSpan);
      } else
        newTemplateSpans.push(tS);
    });
    if (newTemplateSpans.length === 0) {
      const nodePos = { pos: tE.parent.pos, end: tE.parent.end };
      finalNode = replaceElementsInAst(finalNode, nodePos, factory.createStringLiteral(newTemplateHead.text));
      return;
    }
    finalNode = replaceElementsInAst(finalNode, { pos: tE.pos, end: tE.end }, factory.createTemplateExpression(newTemplateHead, newTemplateSpans));
  });
  finalNode = stripUnnecessaryLiterals(finalNode);
  return finalNode;
};
const stripUnnecessaryLiterals = (node) => {
  const binaryNodes = findAllByCondition(node, isUnnecessaryBinaryExpression);
  let finalNode = node;
  binaryNodes.forEach((bN) => {
    finalNode = replaceElementsInAst(finalNode, { pos: bN.parent.pos, end: bN.parent.end }, factory.createStringLiteral(bN.text));
  });
  const stringNodes = findAllByCondition(finalNode, isStringLiteralInJsxExpression);
  stringNodes.forEach((sN) => {
    finalNode = replaceElementsInAst(finalNode, { pos: sN.parent.pos, end: sN.parent.end }, factory.createStringLiteral(sN.text));
  });
  return finalNode;
};
const isStringLiteralInJsxExpression = (node) => isString$1(node) && node.parent && ts.isJsxExpression(node.parent);
const isUnnecessaryBinaryExpression = (node) => isString$1(node) && node.parent && ts.isBinaryExpression(node.parent);
const isString$1 = (node) => ts.isStringLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node);
const mergeReactComponentBody = async (parentAst, childAst, componentName) => {
  const childReactComponent = getReactComponentNode(childAst, componentName);
  if (!childReactComponent)
    return parentAst;
  const componentBodyStatements = getComponentBodyFromReactComponent(childReactComponent);
  if (!componentBodyStatements)
    return parentAst;
  const block2 = findByCondition(parentAst, isBlockInsideReactComponentFunction);
  if (!block2)
    return parentAst;
  const newBlockNames = componentBodyStatements.map((statement) => statement.getText());
  const newBlock = [
    ...componentBodyStatements,
    ...Array.from(block2.statements).filter((statement) => !newBlockNames.includes(statement.getText()))
  ];
  const newNode = factory.createBlock(newBlock);
  stripRanges(newNode);
  const finalSourceFile = conditionalyReplaceNodeInAst(parentAst, isBlockInsideReactComponentFunction, newNode);
  return await regenerateAst(finalSourceFile);
};
const copyJsxChildren = (node, copyJsx) => {
  const numberOfNodes = copyJsx.filter((n2) => !ts.isJsxText(n2)).length;
  let finalNode = conditionalyWithParamReplaceNodeInAst(node, isJsxExpressionWithIdentifierInside, "children", copyJsx);
  finalNode = conditionalyReplaceNodeInAst(finalNode, isPropertyAccessExpressionWithChildrenLengthInside, factory.createNumericLiteral(numberOfNodes));
  return finalNode;
};
const mergeReturnedJsx = async (parentAst, childAst, componentName) => {
  const reactComponent = getReactComponentNode(childAst, componentName);
  if (!reactComponent)
    return null;
  const returnedJsx = getReturnedJsxFromReactComponent(reactComponent);
  if (!returnedJsx)
    return null;
  const nodeOccurences = findAllByConditionWithParam(parentAst, isJsxOpeningLikeElementWithName, componentName);
  if (nodeOccurences.length == 0)
    return null;
  let finalAst = parentAst;
  nodeOccurences.forEach((nO) => {
    let newNode = copyPrimitiveProps(nO, returnedJsx);
    if (ts.isJsxOpeningElement(nO)) {
      const copyJsx = Array.from(nO.parent.children);
      newNode = copyJsxChildren(newNode, copyJsx);
    }
    stripRanges(newNode);
    finalAst = replaceElementsInAst(finalAst, { pos: nO.pos, end: nO.end }, newNode);
  });
  return await regenerateAst(finalAst);
};
const inlineReactComponent = async (parentAst, childAst, componentName) => {
  let sourceFile = await mergeReactComponentBody(parentAst, childAst, componentName);
  sourceFile = await mergeReturnedJsx(sourceFile, childAst, componentName);
  if (!sourceFile)
    return parentAst;
  sourceFile = mergeImports(sourceFile, childAst);
  sourceFile = removeUnusedDefaultImport(sourceFile, componentName);
  sourceFile = flattenStringLiterals(sourceFile);
  return sourceFile;
};
const isJsxOpeningLikeElementWithName = (node, text2) => ts.isJsxOpeningLikeElement(node) && node.tagName.text === text2;
const isBlockInsideReactComponentFunction = (node) => ts.isBlock(node) && node.parent && isReactComponentFunction(node.parent);
const isJsxExpressionWithIdentifierInside = (node, text2) => ts.isJsxExpression(node) && node.expression && (ts.isIdentifier(node.expression) && node.expression.getText() === text2 || ts.isPropertyAccessExpression(node.expression) && node.expression.name.getText() === text2);
const isPropertyAccessExpressionWithChildrenLengthInside = (node) => ts.isPropertyAccessExpression(node) && ts.isPropertyAccessExpression(node.expression) && node.name.getText() === "length" && node.expression.name.getText() === "children";
const TEMPLATE_PATH = "./node_modules/@iteria-app/component-templates/src/components/readonly";
const ENTITY_PATH = "./node_modules/@iteria-app/component-templates/src/components/entity/list/Entity";
const TEMPLATE_PATH_JAMSTACK = "templates/readonly";
const ENTITY_PATH_JAMSTACK = "templates/list/Entity";
const ENTITY = "Entity";
const FIELD = "field";
const COLUMNS = "columns";
const HEADER_NAME = "headerName";
const RENDER_CELL = "renderCell";
const VALUE = "value";
const DEFAULT_FORMAT = "DefaultFormat";
const BOOLEAN_FORMAT = "BooleanFormat";
const DATE_FORMAT = "DateFormat";
const DATE_TIME_FORMAT = "DateTimeFormat";
const TIME_FORMAT = "TimeFormat";
const stringPrettyCapitalize = (inputString) => inputString.replace(/^\w/, (c2) => c2.toUpperCase()).replace(/(_|\.)/g, " ");
const removeElementFromArray = (array, element2) => {
  var index2 = array.indexOf(element2);
  if (index2 !== -1) {
    array.splice(index2, 1);
  }
  return array;
};
async function generateColumn(columnInfo) {
  const { io, entity, field, fields: fields8, page, selectedColumn, insertType } = columnInfo;
  let ast = columnInfo.ast;
  const astType = typeof ast;
  if (astType === "string") {
    ast = createAst(ast);
  }
  if (checkIfExist(ast, `${entity}.${field.name}`) || field.name === "id") {
    return await returnValue(ast, astType);
  }
  let objectLiteral;
  let lastObjectLiteral;
  let formatComponentName;
  if (page === PageType.LIST) {
    const newColumn = await addColumnToList(ast, selectedColumn, entity, field, fields8, insertType);
    if (!newColumn || !newColumn.objectLiteral || !newColumn.lastObjectLiteral || !newColumn.formatComponentName)
      return await returnValue(ast, astType);
    objectLiteral = newColumn.objectLiteral;
    lastObjectLiteral = newColumn.lastObjectLiteral;
    formatComponentName = newColumn.formatComponentName;
  } else {
    return await returnValue(ast, astType);
  }
  ast = appendElementsToAst(ast, {
    pos: lastObjectLiteral.pos,
    end: lastObjectLiteral.end
  }, [objectLiteral], insertType === InsertType.BEFORE || insertType === InsertType.FIRST ? "before" : "after");
  ast = await regenerateAst(ast);
  const templatePath = io.injectMode === "jamstack" ? TEMPLATE_PATH_JAMSTACK : TEMPLATE_PATH;
  ast = await addFormatting(io, ast, formatComponentName, templatePath, field.name);
  return await returnValue(ast, astType);
}
const addColumnToList = async (ast, selectedColumn, entity, field, fields8, insertType) => {
  var _a2, _b, _c, _d;
  let formatComponentName;
  let lastObjectLiteral;
  let objectLiteral;
  if (!selectedColumn) {
    const columnsNode = findByCondition(ast, (node) => {
      return ts.isVariableDeclaration(node) && node.name.text === COLUMNS;
    });
    if (!columnsNode)
      return void 0;
    objectLiteral = (_b = (_a2 = columnsNode.initializer) == null ? void 0 : _a2.elements) == null ? void 0 : _b[0];
    if (!objectLiteral)
      return void 0;
    const newColumn = renameColumn(objectLiteral, entity, field, fields8);
    objectLiteral = newColumn.objectLiteral;
    formatComponentName = newColumn.formatComponentName;
    if (insertType && insertType === InsertType.FIRST) {
      lastObjectLiteral = (_c = columnsNode.initializer) == null ? void 0 : _c.elements[0];
    } else {
      lastObjectLiteral = (_d = columnsNode.initializer) == null ? void 0 : _d.elements.slice(-1)[0];
    }
  } else {
    lastObjectLiteral = findByCondition(ast, (node) => node.getText() === selectedColumn.getText());
    if (!lastObjectLiteral)
      return void 0;
    const newColumn = renameColumn(lastObjectLiteral, entity, field, fields8);
    objectLiteral = newColumn.objectLiteral;
    formatComponentName = newColumn.formatComponentName;
  }
  return {
    objectLiteral,
    lastObjectLiteral,
    formatComponentName
  };
};
const getFormatComponent = (type2) => {
  if (!type2)
    return DEFAULT_FORMAT;
  switch (type2.toLowerCase()) {
    case "string":
    case "number":
    case "int":
    case "jsonb":
    case "uuid":
      return DEFAULT_FORMAT;
    case "boolean":
      return BOOLEAN_FORMAT;
    case "date":
      return DATE_FORMAT;
    case "datetime":
    case "timestamp":
    case "timestamptz":
      return DATE_TIME_FORMAT;
    case "time":
    case "timez":
      return TIME_FORMAT;
    default:
      return DEFAULT_FORMAT;
  }
};
const nodeIncludes = (ast, fields8) => {
  const found = findAllByCondition(ast, (node) => {
    return fields8.includes(node.text);
  });
  return found;
};
const checkIfExist = (ast, field) => {
  const found = findByCondition(ast, (node) => node.text === field);
  return found ? true : false;
};
const returnValue = async (ast, astType) => astType === "string" ? await printFormattedSourceFile(ast) : ast;
const renameColumn = (objectLiteral, entity, field, fields8) => {
  let formatComponentName = void 0;
  for (const objectProperty of objectLiteral.properties) {
    const initializer = objectProperty.initializer;
    const entityFields = fields8.map((field2) => field2.name);
    entityFields.unshift(FIELD);
    objectLiteral = replaceNames(objectLiteral, initializer, entity, field, fields8);
    if (ts.isArrowFunction(initializer) || ts.isFunctionExpression(initializer)) {
      formatComponentName = getFormatComponent(field.type);
      objectLiteral = handleRenderCell(objectLiteral, initializer, formatComponentName);
    }
  }
  return {
    objectLiteral,
    formatComponentName
  };
};
const replaceNames = (objectLiteral, initializer, entity, field, fields8) => {
  const entityFields = removeElementFromArray(fields8.map((field2) => field2.name), "id");
  const newEntityFields = entityFields.map((field2) => {
    return `${entity}.${field2}`;
  });
  const headerNames = fields8.map((field2) => {
    return stringPrettyCapitalize(field2.name);
  });
  entityFields.unshift(FIELD);
  headerNames.unshift(HEADER_NAME);
  const foundReplace = nodeIncludes(initializer, [...entityFields, ...headerNames, ...newEntityFields]);
  foundReplace.forEach((found) => {
    objectLiteral = handleReplaceName(objectLiteral, found, entity, field.name, {
      entityFields,
      headerNames,
      newEntityFields
    });
  });
  return objectLiteral;
};
const handleReplaceName = (objectLiteral, found, entity, fieldName, arrays) => {
  let newName;
  if (arrays.entityFields.includes(found.text)) {
    if (!(found.parent && ts.isJsxAttribute(found.parent) && ts.isIdentifier(found) && found.parent.name.getText() == found.getText())) {
      if (ts.isPropertyAssignment(found.parent)) {
        newName = `${entity}.${fieldName}`;
      } else {
        newName = fieldName;
      }
    }
  } else if (arrays.headerNames.includes(found.text)) {
    newName = stringPrettyCapitalize(fieldName);
  } else {
    newName = `${entity}.${fieldName}`;
  }
  return renameAndReplaceElementInAst(objectLiteral, found, found.text, newName);
};
const handleRenderCell = (objectLiteral, initializer, formatComponentName) => {
  var _a2, _b;
  const propertyName = (_b = (_a2 = initializer.parent) == null ? void 0 : _a2.name) == null ? void 0 : _b.text;
  if (propertyName && propertyName === RENDER_CELL) {
    const atributeName = initializer.parameters[0].name.text;
    const newElement = createJsxSelfClosingElement(formatComponentName, [
      {
        name: VALUE,
        initializer: atributeName
      }
    ]);
    let elementToReplace;
    if (ts.isFunctionExpression(initializer)) {
      const returnStatement = findByCondition(objectLiteral, ts.isReturnStatement);
      if (!returnStatement)
        return {
          objectLiteral,
          formatComponentName: DEFAULT_FORMAT
        };
      elementToReplace = returnStatement.expression;
    } else {
      elementToReplace = initializer.body;
    }
    objectLiteral = replaceElementsInAst(objectLiteral, {
      pos: elementToReplace.pos,
      end: elementToReplace.end
    }, newElement);
  }
  return objectLiteral;
};
const capitalize = (name) => {
  return name.charAt(0).toUpperCase() + name.slice(1);
};
const updateAst = async (io, code2, entity, findString, fields8, introspection) => {
  let alteredAst = createAst(code2);
  const entityName = getEntityName(entity);
  alteredAst = await renameEntityInCode(alteredAst, entityName, findString, introspection, PageType.LIST);
  for (const field of fields8) {
    if (isHidden(field.name))
      continue;
    const columnInfo = {
      io,
      ast: alteredAst,
      entity,
      field,
      fields: fields8,
      page: PageType.LIST,
      selectedColumn: void 0
    };
    alteredAst = await generateColumn(columnInfo);
  }
  alteredAst = await removeFirst(alteredAst);
  alteredAst = removeUnusedDefaultImport(alteredAst, `Format${entityName}Field`);
  alteredAst = await regenerateAst(alteredAst);
  alteredAst = flattenStringLiterals(alteredAst);
  alteredAst = await regenerateAst(alteredAst);
  return alteredAst;
};
const generateTsxFiles = async (io, entity, components, fields8) => {
  const entityName = getEntityName(entity);
  const files = [];
  for (const component of components) {
    const entityPath = io.injectMode === "jamstack" ? ENTITY_PATH_JAMSTACK : ENTITY_PATH;
    const dataTableTemplate = await io.readFile(`${entityPath}${component}.tsx`);
    const ast = await updateAst(io, dataTableTemplate, entity, ENTITY, fields8, io.introspection);
    const sourceCode = await printFormattedSourceFile(ast);
    const sourceCodePath = findRelativePath(`/src/pages/${entity}/`, `./${entityName}${component}.tsx`);
    files.push({ path: io.cwd + sourceCodePath, data: sourceCode });
  }
  return files;
};
const addFormatting = async (io, ast, component, path2, field) => {
  const code2 = await io.readFile(`${path2}/${component}.tsx`);
  let childAst = await createAst(code2);
  if (field) {
    field = addOptionalChaining(field);
    childAst = renameFields(childAst, FIELD, field, false);
    childAst = await regenerateAst(childAst);
  }
  const inlineReact = await inlineReactComponent(ast, childAst, component);
  return await regenerateAst(inlineReact);
};
const removeFirst = async (ast) => {
  var _a2, _b;
  const node = findByCondition(ast, (node2) => {
    return ts.isVariableDeclaration(node2) && node2.name.text === COLUMNS;
  });
  if (!node)
    return ast;
  const objectLiteral = (_b = (_a2 = node.initializer) == null ? void 0 : _a2.elements) == null ? void 0 : _b[0];
  ast = removeElementFromAst(ast, {
    pos: objectLiteral.pos,
    end: objectLiteral.end
  });
  return ast;
};
const isHidden = (fieldName) => {
  if (fieldName === "id" || fieldName.match(/.*Path$/i) !== null)
    return true;
  return false;
};
const addOptionalChaining = (field) => {
  if (field.includes(".")) {
    const newFields = field.split(".").map((newField) => {
      return newField + "?";
    });
    const lastField = newFields.pop();
    newFields.push(lastField.replaceAll("?", ""));
    field = newFields.join(".");
  }
  return field;
};
const getEntityName = (entity) => {
  return entity.split("_").map((string) => capitalize(string)).join("");
};
const renameEntityInCode = async (ast, entityName, findString, introspection, pageType) => {
  const nodes = findAllByCondition(ast, (node) => {
    const text2 = node.getText();
    return (ts.isStringLiteral(node) || ts.isIdentifier(node)) && text2 && text2.toUpperCase().includes(findString.toUpperCase());
  });
  const [queryRoot] = getRoots(introspection);
  const field = queryRoot.fields.find((field2) => isOfTypePage(field2, entityName, pageType));
  nodes.forEach((node) => {
    const oldText = node.text;
    let newText;
    if (oldText.toLowerCase() === findString.toLowerCase()) {
      newText = field.name;
    } else {
      newText = oldText.replace(findString, entityName);
    }
    ast = renameAndReplaceElementInAst(ast, node, oldText, newText);
  });
  return await regenerateAst(ast);
};
async function generatePages(introspection, io, options2) {
  const entities = options2.entities;
  const graphqlFiles = generateGraphqlFile(introspection, entities);
  const pages = /* @__PURE__ */ new Map();
  const files = [];
  for (const graphqlFile of graphqlFiles) {
    const path2 = findRelativePath(`/src/pages/${graphqlFile.entityName}/`, "./index.graphql");
    pages.set(path2, graphqlFile.queries);
    if (options2.generateReact) {
      const components = ["ListView", "ListContainer"];
      const fields8 = graphqlFile.fragments.map((field) => {
        const newField = graphqlFile.properties.find((value2) => value2.name === field);
        return newField;
      }).filter((field) => field);
      files.push(...await generateTsxFiles(io, graphqlFile.entityName, components, fields8));
    }
  }
  return {
    pages,
    files
  };
}
const removeColumnFromAst = (code2, source) => {
  const node = findColumn(code2, source);
  if (!node)
    return createAst(code2);
  const ast = createAst(code2);
  const alteredAst = removeElementFromAst(ast, { pos: node.pos, end: node.end });
  return alteredAst;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var lib = {};
Object.defineProperty(lib, "__esModule", {
  value: true
});
var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
  return typeof obj2;
} : function(obj2) {
  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
};
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var isJsDom = function isJsDom2() {
  return typeof window !== "undefined" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
};
var isBrowser_1 = lib.isBrowser = isBrowser;
lib.isWebWorker = isWebWorker;
var isNode_1 = lib.isNode = isNode;
lib.isJsDom = isJsDom;
const getCWDFromDevtools = () => {
  var _a2, _b, _c, _d;
  const rendererInterfaces = (_b = (_a2 = window.__REACT_DEVTOOLS_GLOBAL_HOOK__) == null ? void 0 : _a2.reactDevtoolsAgent) == null ? void 0 : _b._rendererInterfaces;
  if (!rendererInterfaces)
    return;
  for (const rendererInterface of Object.values(rendererInterfaces)) {
    for (let i2 = 1; i2 < 300; i2++) {
      const path2 = rendererInterface.getPathForElement(i2);
      const data = rendererInterface.inspectElement(`iteria-response${i2}`, i2, path2);
      const fileName = (_d = (_c = data.value) == null ? void 0 : _c.source) == null ? void 0 : _d.fileName;
      if (fileName)
        return fileName;
    }
  }
};
const transformPathToPosix = (path2) => path2.replaceAll("\\", "/");
const guessCurrentWorkingDirectory = () => {
  let cwd;
  if ({}.VITE_CWD) {
    return transformPathToPosix({}.VITE_CWD);
  }
  if (isBrowser_1)
    cwd = getCWDFromDevtools();
  else if (isNode_1 && typeof process != "undefined" && process.cwd) {
    cwd = process.cwd();
  } else {
    throw new Error("Unsuported environment. Supported environments: Browser, NodeJS");
  }
  if (!cwd) {
    console.error("Unable to find current working directory.");
    return null;
  }
  cwd = transformPathToPosix(cwd);
  const index2 = cwd.lastIndexOf("/src");
  return cwd.slice(0, index2 + 1);
};
const worker = new WorkerWrapper();
const iteriaGeneratorWorker = wrap$3(worker);
const cloneElement = async (code2, source) => {
  const encoded = encodeEmptyLines$1(code2);
  const alteredAst = await cloneElementInAst(encoded, source);
  if (!alteredAst)
    return console.error("Unable to clone Element in AST");
  const newCode = await printFormattedSourceFile$1(alteredAst);
  return newCode;
};
const cloneAndRenameElement = async (code2, source, oldField, newField) => {
  const encoded = encodeEmptyLines$1(code2);
  const alteredAst = await cloneAndRenameElementInAst(encoded, source, oldField, newField);
  if (!alteredAst)
    return console.error("Unable to clone Element in AST");
  const newCode = await printFormattedSourceFile$1(alteredAst);
  return newCode;
};
const removeElement = async (code2, source) => {
  const encoded = encodeEmptyLines$1(code2);
  const alteredAst = removeElementInAst(encoded, source);
  if (!alteredAst)
    return console.error("Unable to remove Element from AST");
  const newCode = await printFormattedSourceFile$1(alteredAst);
  return newCode;
};
const isUserFeedbackError = (type2) => type2 === "GENERATE_PAGE_ERROR" || type2 === "CLONE_FIELD_ERROR" || type2 === "CLONE_ELEMENT_ERROR" || type2 === "REMOVE_ELEMENT_ERROR" || type2 === "NAVIGATE_TO_SOURCE_CODE_ERROR" || type2 === "CHANGE_GRAPHQL_ENDPOINT_ERROR" || type2 === "GRAPHQL_CODEGEN_ERROR" || type2 === "LOAD_INTROSPECTION_ERROR" || type2 === "REORDER_ELEMENT_ERROR" || type2 === "TRANSLATE_ELEMENT_ERROR" || type2 === "CHANGE_THEME_ERROR" || type2 === "CREATE_TABLE_ERROR" || type2 === "ADD_COLUMN_ERROR" || type2 === "LOCAL_MESSAGE_TRANSLATE_ERROR" || type2 === "LOAD_INTROSPECTION_ERROR" || type2 === "COMMIT_ALL_CHANGES_ERROR" || type2 === "BUNDLER_ERROR" || type2 === "TRANSPILER_ERROR" || type2 === "LOGIN_ERROR" || type2 === "UPDATE_DATABASE_ERROR";
const isUserFeedbackSuccess = (type2) => type2 === "GENERATE_PAGE_SUCCESS" || type2 === "CLONE_FIELD_SUCCESS" || type2 === "CLONE_ELEMENT_SUCCESS" || type2 === "REMOVE_ELEMENT_SUCCESS" || type2 === "CHANGE_GRAPHQL_ENDPOINT_SUCESS" || type2 === "REORDER_ELEMENT_SUCESS" || type2 === "CHANGE_THEME_SUCESS" || type2 === "CREATE_TABLE_SUCCESS" || type2 === "ADD_COLUMN_SUCCESS" || type2 === "LOCAL_MESSAGE_TRANSLATE_SUCESS" || type2 === "LOAD_INTROSPECTION_SUCCESS" || type2 === "COMMIT_ALL_CHANGES_SUCCESS" || type2 === "LOGIN_SUCCESS" || type2 === "UPDATE_DATABASE_SUCCESS";
const isUserFeedbackInfo = (type2) => type2 === "GENERATE_PAGE_INFO" || type2 === "CLONE_FIELD_INFO" || type2 === "REORDER_ELEMENT_INFO" || type2 === "CREATE_TABLE_INFO" || type2 === "ADD_COLUMN_INFO" || type2 === "LOCAL_MESSAGE_TRANSLATE_INFO" || type2 === "ERD_VIEW_INFO" || type2 === "COMMIT_ALL_CHANGES_INFO" || type2 === "COMMIT_NOTHING_TO_CHANGE_INFO" || type2 === "UPDATE_DATABASE_INFO";
const showUserFeedback = (feedback) => {
  if (isUserFeedbackSuccess(feedback.type))
    showSuccess(feedback);
  if (isUserFeedbackError(feedback.type))
    showError(feedback);
  if (isUserFeedbackInfo(feedback.type))
    showInfo(feedback);
};
const showSuccess = (feedback) => {
  switch (feedback.type) {
    case "GENERATE_PAGE_SUCCESS":
      const entities = feedback.payload.entity;
      if (entities.length > 1)
        return showSuccessSnackbar(`New pages successfully generated.`);
      else
        return showSuccessSnackbar(`New page generated at /app/${entities[0]}.`);
    case "CLONE_FIELD_SUCCESS":
      showSuccessSnackbar("Fields added successfully.");
      break;
    case "CLONE_ELEMENT_SUCCESS":
      showSuccessSnackbar("Element cloned successfully.");
      break;
    case "REMOVE_ELEMENT_SUCCESS":
      showSuccessSnackbar("Element removed successfully.");
      break;
    case "CHANGE_GRAPHQL_ENDPOINT_SUCESS":
      showSuccessSnackbar("GraphQL endpoint changed successfully.");
      break;
    case "LOAD_INTROSPECTION_SUCCESS":
      showSuccessSnackbar("Introspection schema loaded successfully.");
      break;
    case "REORDER_ELEMENT_SUCCESS":
      showSuccessSnackbar("Element was moved successfully.");
    case "CHANGE_THEME_SUCESS":
      showSuccessSnackbar("Theme changed successfully.");
      break;
    case "CREATE_TABLE_SUCCESS":
      showSuccessSnackbar("Table created successfully.");
      break;
    case "ADD_COLUMN_SUCCESS":
      showSuccessSnackbar("New Column added successfully.");
      break;
    case "LOCAL_MESSAGE_TRANSLATE_SUCESS":
      showSuccessSnackbar("Element was successfully translated.");
      break;
    case "COMMIT_ALL_CHANGES_SUCCESS":
      showSuccessSnackbar("Changes were successfully committed.");
      break;
    case "LOGIN_SUCCESS":
      const login = feedback.payload.login;
      const provider = feedback.payload.provider;
      showSuccessSnackbar(`Successfully logged ${login ? "in to" : "out from"} ${provider}.`);
      break;
    case "UPDATE_DATABASE_SUCCESS":
      showSuccessSnackbar("Database updated successfully.");
      break;
    default:
      throw new Error(`Unhandled succes type: ${feedback.type}`);
  }
};
const showError = (feedback) => {
  switch (feedback.type) {
    case "GENERATE_PAGE_ERROR":
      showErrorSnackbar("Error while generating page. Check console for error and stacktrace.");
      break;
    case "CLONE_FIELD_ERROR":
      showErrorSnackbar("Error while adding fields. Check console for error and stacktrace.");
      break;
    case "CLONE_ELEMENT_ERROR":
      showErrorSnackbar("Error while cloning element. Check console for error and stacktrace.");
      break;
    case "REMOVE_ELEMENT_ERROR":
      showErrorSnackbar("Error while removing element. Check console for error and stacktrace.");
      break;
    case "NAVIGATE_TO_SOURCE_CODE_ERROR":
      showErrorSnackbar("Error while navigating to code. Check console for error and stacktrace.");
    case "CHANGE_GRAPHQL_ENDPOINT_ERROR":
      showErrorSnackbar("Error while changing GraphQL endpoint. Check console for error and stacktrace.");
      break;
    case "GRAPHQL_CODEGEN_ERROR":
      showErrorSnackbar("Error while generatig graphQL types. Check console for error and stacktrace.");
    case "LOCAL_MESSAGE_TRANSLATE_ERROR":
      showErrorSnackbar("Error with saving translation");
      break;
    case "LOAD_INTROSPECTION_ERROR":
      showErrorSnackbar("Error while loading Introspection schema. Check console for error and stacktrace.");
      break;
    case "CHANGE_THEME_ERROR":
      showErrorSnackbar("Error while changing theme. Check console for error and stacktrace.");
    case "CREATE_TABLE_ERROR":
      showErrorSnackbar("Error while creating table. Check console for error and stacktrace.");
      break;
    case "ADD_COLUMN_ERROR":
      showErrorSnackbar("Error while adding new column. Check console for error and stacktrace.");
      break;
    case "TRANSLATE_ELEMENT_ERROR":
      showErrorSnackbar("Error while translating element. Check console for error and stacktrace.");
      break;
    case "REORDER_ELEMENT_ERROR":
      showErrorSnackbar("Error while moving element. Check console for error and stacktrace.");
      break;
    case "COMMIT_ALL_CHANGES_ERROR":
      showErrorSnackbar("Error while committing changes. Check console for error and stacktrace.");
      break;
    case "BUNDLER_ERROR":
      showErrorSnackbar("Error while bundling files. Check console for error and stacktrace.");
      break;
    case "TRANSPILER_ERROR":
      showErrorSnackbar("Error while transpiling files. Check console for error and stacktrace.");
      break;
    case "LOGIN_ERROR":
      const login = feedback.payload.login;
      const provider = feedback.payload.provider;
      showErrorSnackbar(`Error while logging ${login ? "in to" : "out from"} ${provider}. Check console for error and stacktrace.`);
      break;
    case "UPDATE_DATABASE_ERROR":
      showErrorSnackbar("Error while updating database. Check console for error and stacktrace.");
      break;
    default:
      throw new Error(`Unhandled error type: ${feedback.type}`);
  }
};
const showInfo = (feedback) => {
  switch (feedback.type) {
    case "GENERATE_PAGE_INFO":
      const entities = feedback.payload.entity;
      if (entities.length > 1)
        return showLoadingSnackbar(`Generating new pages.`);
      else
        return showLoadingSnackbar(`Generating new page at /app/${entities[0]}.`);
    case "CLONE_FIELD_INFO":
      showLoadingSnackbar("Adding fields.");
      break;
    case "REORDER_ELEMENT_INFO":
      showInfoSnackbar("Moving element to position.");
    case "CREATE_TABLE_INFO":
      showLoadingSnackbar("Creating table.");
      break;
    case "ADD_COLUMN_INFO":
      showLoadingSnackbar("Adding new column.");
      break;
    case "LOCAL_MESSAGE_TRANSLATE_INFO":
      showInfoSnackbar("Translating element.");
      break;
    case "ERD_VIEW_INFO":
      showLoadingSnackbar("Loading Entity-Relationship Diagram.");
      break;
    case "COMMIT_ALL_CHANGES_INFO":
      showLoadingSnackbar("Committing changes to repository.");
      break;
    case "COMMIT_NOTHING_TO_CHANGE_INFO":
      showWarningSnackbar("Nothing to commit!");
      break;
    case "UPDATE_DATABASE_INFO":
      showLoadingSnackbar("Updating database.");
      break;
    default:
      throw new Error(`Unhandled info type: ${feedback.type}`);
  }
};
const delay = (ms) => new Promise((resolve5) => setTimeout(resolve5, ms));
const reorderElement = async (code2, data) => {
  const encoded = encodeEmptyLines$1(code2);
  Object.keys(data.elementsPosEnd).forEach((key) => {
    const { pos, end } = astFindSource(encoded, data.elementsPosEnd[key]);
    data.elementsPosEnd[key] = { pos, end };
  });
  const alteredAst = await reorderElementsInAst(encoded, data);
  if (!alteredAst)
    return console.error("Unable to remove Element from AST");
  const newCode = await printFormattedSourceFile$1(alteredAst);
  return newCode;
};
const reorderFields = async (introspection, io, data) => {
  var _a2;
  const cwd = guessCurrentWorkingDirectory();
  if (!cwd)
    return;
  let pathToGraphqlFile = findRelativePath(cwd, `./react-material-ui-vite/src/pages/${data.entityName}/index.graphql`);
  if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/")
    pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
  let graphqlFile = (_a2 = await io.readFile(pathToGraphqlFile)) != null ? _a2 : "";
  const [queryRoot] = getRoots(introspection);
  const field = queryRoot.fields.find((field2) => isOfTypePage(field2, data.entityName, 1));
  const fieldName = field == null ? void 0 : field.name;
  const queryName = fieldName != null ? fieldName : data.entityName;
  let file = graphqlFile;
  file = reorderFieldsInGraphqlFile(graphqlFile, queryName, data.chained_changes);
  return await io.writeFile(pathToGraphqlFile, file);
};
const reorderFieldsInGraphqlFile = (graphqlFile, queryName, chained_changes) => {
  const astGraphqlFile = parse$6(graphqlFile);
  let queryFileFragment = void 0;
  let fragmentSpreadName = void 0;
  visit(astGraphqlFile, {
    OperationDefinition(node) {
      var _a2, _b, _c;
      if (((_a2 = node.name) == null ? void 0 : _a2.value) === queryName) {
        const field = (_b = node.selectionSet) == null ? void 0 : _b.selections[0];
        const selections = (_c = field.selectionSet) == null ? void 0 : _c.selections.filter((selection) => selection.kind === "Field" || selection.kind === "FragmentSpread");
        if (selections.length === 1 && selections[0].kind === "FragmentSpread") {
          fragmentSpreadName = selections[0].name.value;
        } else {
          queryFileFragment = graphqlFile.substring(field.selectionSet.loc.start, field.selectionSet.loc.end);
        }
      }
    }
  });
  if (fragmentSpreadName) {
    visit(astGraphqlFile, {
      FragmentDefinition(node) {
        var _a2;
        if (((_a2 = node.name) == null ? void 0 : _a2.value) === fragmentSpreadName) {
          queryFileFragment = graphqlFile.substring(node == null ? void 0 : node.selectionSet.loc.start, node == null ? void 0 : node.selectionSet.loc.end);
        }
      }
    });
    const alteredAstOfQueryFileFragment = visit(parse$6(queryFileFragment), {
      Field: {
        leave: (node) => {
          if (node.name.value in chained_changes) {
            let tmpNode = JSON.parse(JSON.stringify(node));
            tmpNode.name.value = chained_changes[node.name.value];
            return tmpNode;
          }
        }
      }
    });
    queryFileFragment = print(alteredAstOfQueryFileFragment);
    let file = graphqlFile;
    let prevIndex = graphqlFile.length;
    visit(astGraphqlFile, {
      FragmentDefinition(node) {
        var _a2;
        if (((_a2 = node.name) == null ? void 0 : _a2.value) === fragmentSpreadName) {
          file = graphqlFile.substring(0, node.selectionSet.loc.start);
          prevIndex = node.selectionSet.loc.end;
        }
      }
    });
    file += queryFileFragment;
    file += graphqlFile.substring(prevIndex, graphqlFile.length);
    return file.length ? print(parse$6(file)) : graphqlFile;
  } else {
    const alteredAstOfQueryFileFragment = visit(parse$6(queryFileFragment), {
      Field: {
        leave: (node) => {
          if (node.name.value in chained_changes) {
            let tmpNode = JSON.parse(JSON.stringify(node));
            tmpNode.name.value = chained_changes[node.name.value];
            return tmpNode;
          }
        }
      }
    });
    queryFileFragment = print(alteredAstOfQueryFileFragment);
    let file = graphqlFile;
    let prevIndex = graphqlFile.length;
    visit(astGraphqlFile, {
      OperationDefinition(node) {
        var _a2, _b;
        if (((_a2 = node.name) == null ? void 0 : _a2.value) === queryName) {
          const field = (_b = node.selectionSet) == null ? void 0 : _b.selections[0];
          file = graphqlFile.substring(0, field.selectionSet.loc.start);
          prevIndex = field.selectionSet.loc.end;
        }
      }
    });
    file += queryFileFragment;
    file += graphqlFile.substring(prevIndex, graphqlFile.length);
    return file.length ? print(parse$6(file)) : graphqlFile;
  }
};
const encodeEmptyLines = (code2) => code2.replace(/\n\n/g, "\n/** THIS_IS_A_NEWLINE **/\n");
const reorderRoutes = async (io, data) => {
  var _a2;
  const cwd = guessCurrentWorkingDirectory();
  if (!cwd)
    return;
  let pathToGraphqlFile = findRelativePath(cwd, `./src/generated/graphql.ts`);
  if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/")
    pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
  let graphqlFile = (_a2 = await io.readFile(pathToGraphqlFile)) != null ? _a2 : "";
  const encoded = encodeEmptyLines(graphqlFile);
  let ast = createAst(encoded);
  if (!ast)
    return null;
  Object.keys(data.chained_changes).forEach((key) => {
  });
  const isDocument = new RegExp("^[A-Za-z]*Document$");
  let allRoutes = [];
  let allRoutesNodes = [];
  findAllByCondition(createAst(graphqlFile), (node) => {
    if (node.parent && node.parent.parent && node.parent.parent.parent && ts.isIdentifier(node) && isDocument.test(node.getText())) {
      allRoutes.push(node.getText());
      allRoutesNodes.push(node);
      return true;
    }
    return false;
  });
  let chained_changes = {};
  Object.keys(data.chained_changes).forEach((key) => {
    let a = key.length > data.chained_changes[key].length ? key : data.chained_changes[key];
    let b = a === key ? data.chained_changes[key] : key;
    let stopIndex = 0;
    let previousSlashIndex = 0;
    for (let index2 = 0; index2 < a.length; index2++) {
      if (index2 < b.length) {
        if (a[index2] === "/")
          previousSlashIndex = index2;
        if (a.substring(0, index2) === b.substring(0, index2)) {
          continue;
        } else {
          stopIndex = previousSlashIndex + 1;
          break;
        }
      }
    }
    chained_changes[key.substring(stopIndex, key.length)] = data.chained_changes[key].substring(stopIndex, data.chained_changes[key].length);
  });
  let chained_changes_node_names = {};
  Object.keys(chained_changes).forEach((key) => {
    const a = allRoutes.find((item) => item.toLowerCase().includes(key));
    const b = allRoutes.find((item) => item.toLowerCase().includes(chained_changes[key]));
    if (a && b) {
      chained_changes_node_names[a] = b;
    } else {
      return null;
    }
  });
  let file = "";
  let prev = 0;
  allRoutesNodes.forEach((node, index2) => {
    file += graphqlFile.substring(prev, node.pos);
    const toIndex = allRoutes.findIndex((item) => item === chained_changes_node_names[allRoutes[index2]]);
    if (toIndex !== -1) {
      const slice = graphqlFile.substring(allRoutesNodes[toIndex].pos, allRoutesNodes[toIndex].end);
      file += slice;
      prev = allRoutesNodes[toIndex].end;
    } else {
      file += graphqlFile.substring(node.pos, node.end);
      prev = node.end;
    }
  });
};
const reorderFieldsInFileFragment = (node, graphqlFile, chained_changes) => {
  let queryFileFragment = graphqlFile.substring(node.loc.start, node.loc.end);
  const alteredAstOfQueryFileFragment = visit(parse$6(queryFileFragment), {
    Field: {
      leave: (node2) => {
        if (node2.name.value in chained_changes) {
          let tmpNode = JSON.parse(JSON.stringify(node2));
          tmpNode.kind = "Field";
          tmpNode.name.value = chained_changes[node2.name.value];
          return tmpNode;
        }
      }
    }
  });
  queryFileFragment = print(alteredAstOfQueryFileFragment);
  return queryFileFragment;
};
const reorderFieldsInFragment = (graphqlFile, fragmentName, chained_changes) => {
  let prev = 0;
  let file = "";
  const ast = parse$6(graphqlFile);
  visit(ast, {
    FragmentDefinition(node) {
      if (node.name.value === fragmentName && node.loc) {
        node.selectionSet;
        file += graphqlFile.substring(prev, node.loc.start);
        file += reorderFieldsInFileFragment(node, graphqlFile, chained_changes);
        prev = node.loc.end;
      }
    }
  });
  file += graphqlFile.substring(prev, graphqlFile.length);
  return file;
};
const reorderFieldsInQueryDefinition = (graphqlFile, entityName, relationName, chained_changes) => {
  const ast = parse$6(graphqlFile);
  let prev = 0;
  let file = "";
  visit(ast, {
    OperationDefinition(node) {
      var _a2;
      if (((_a2 = node.name) == null ? void 0 : _a2.value) === entityName) {
        const field = node.selectionSet.selections[0];
        let selectionSet = field.selectionSet;
        if (selectionSet && field.loc && relationName === entityName) {
          file += graphqlFile.substring(prev, node.loc.start);
          file += reorderFieldsInFileFragment(node, graphqlFile, chained_changes);
          prev = node.loc.end;
        } else {
          const relationFieldNode = selectionSet == null ? void 0 : selectionSet.selections.find((field2) => field2.kind === "Field" && relationName === field2.name.value);
          if (relationFieldNode.selectionSet && relationFieldNode.loc) {
            file += graphqlFile.substring(prev, node.loc.start);
            file += reorderFieldsInFileFragment(node, graphqlFile, chained_changes);
            prev = node.loc.end;
          }
        }
      }
    }
  });
  file += graphqlFile.substring(prev, graphqlFile.length);
  return file;
};
const reorderColumns = async (introspection, io, data) => {
  var _a2, _b;
  const cwd = guessCurrentWorkingDirectory();
  if (!cwd)
    return;
  let pathToGraphqlFile = findRelativePath(cwd, `./react-material-ui-vite/src/pages/${data.entityName}/index.graphql`);
  if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/")
    pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
  let graphqlFile = (_a2 = await io.readFile(pathToGraphqlFile)) != null ? _a2 : "";
  const [queryRoot] = getRoots(introspection);
  const field = queryRoot.fields.find((field2) => isOfTypePage(field2, data.entityName, 0));
  const queryName = (_b = field == null ? void 0 : field.name) != null ? _b : data.entityName;
  const fragmentName = getFragmentName(queryName, data.relationName, graphqlFile);
  let file = graphqlFile;
  file = reorderFieldsInQueryDefinition(file, data.entityName, data.relationName, data.chained_changes);
  if (fragmentName) {
    file = reorderFieldsInFragment(file, fragmentName, data.chained_changes);
  }
  return await io.writeFile(pathToGraphqlFile, file);
};
const getFragmentName = (entityName, relationName, graphqlFile) => {
  try {
    const ast = parse$6(graphqlFile);
    let fragmentSpreadName = "";
    visit(ast, {
      OperationDefinition(node) {
        var _a2, _b;
        if (((_a2 = node.name) == null ? void 0 : _a2.value) === entityName) {
          const field = node.selectionSet.selections[0];
          const selections = (_b = field.selectionSet) == null ? void 0 : _b.selections.filter((selection) => selection.kind === "Field" || selection.kind === "FragmentSpread");
          selections.forEach((selection) => {
            var _a3, _b2, _c;
            if (selection.kind === "FragmentSpread") {
              fragmentSpreadName = (_a3 = selection == null ? void 0 : selection.name) == null ? void 0 : _a3.value;
              BREAK;
            }
            if (selection.name.value === relationName) {
              const fragmentSpread = (_b2 = selection.selectionSet) == null ? void 0 : _b2.selections.find((selection2) => selection2.kind === "FragmentSpread");
              fragmentSpreadName = (_c = fragmentSpread == null ? void 0 : fragmentSpread.name) == null ? void 0 : _c.value;
              BREAK;
            }
          });
        }
      }
    });
    return fragmentSpreadName;
  } catch (err2) {
    console.error(err2);
  }
};
const reorderRelations = async (introspection, io, data) => {
  var _a2, _b;
  const cwd = guessCurrentWorkingDirectory();
  if (!cwd)
    return;
  let pathToGraphqlFile = findRelativePath(cwd, `./react-material-ui-vite/src/pages/${data.entityName}/index.graphql`);
  if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/")
    pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
  let graphqlFile = (_a2 = await io.readFile(pathToGraphqlFile)) != null ? _a2 : "";
  const [queryRoot] = getRoots(introspection);
  const field = queryRoot.fields.find((field2) => isOfTypePage(field2, data.entityName, 0));
  const queryName = (_b = field == null ? void 0 : field.name) != null ? _b : data.entityName;
  let file = graphqlFile;
  file = reorderRelationsInQueryDefinition(graphqlFile, queryName, data.chained_changes);
  return await io.writeFile(pathToGraphqlFile, file);
};
const reorderRelationsInQueryDefinition = (graphqlFile, queryName, chained_changes) => {
  const astGraphqlFile = parse$6(graphqlFile);
  let queryFileFragment = "";
  let selectionsMappingToName = {};
  const queryNameField = `${queryName}_${queryName}`;
  visit(astGraphqlFile, {
    OperationDefinition(node) {
      var _a2, _b, _c;
      if (((_a2 = node.name) == null ? void 0 : _a2.value) === queryName) {
        const field = (_b = node.selectionSet) == null ? void 0 : _b.selections[0];
        queryFileFragment = graphqlFile.substring(field.selectionSet.loc.start, field.selectionSet.loc.end);
        const selections = (_c = field.selectionSet) == null ? void 0 : _c.selections.filter((selection) => selection.kind === "Field" || selection.kind === "FragmentSpread");
        selections.forEach((selection) => {
          if (queryNameField === selection.name.value) {
            selectionsMappingToName[queryName] = graphqlFile.substring(selection.loc.start, selection.loc.end);
          } else if (selection.name.value in chained_changes) {
            selectionsMappingToName[selection.name.value] = graphqlFile.substring(selection.loc.start, selection.loc.end);
          }
        });
      }
    }
  });
  const alteredAstOfQueryFileFragment = visit(parse$6(queryFileFragment), {
    FragmentSpread: {
      leave: (node) => {
        if (queryNameField === node.name.value && queryName in chained_changes) {
          let tmpNode = JSON.parse(JSON.stringify(node));
          tmpNode.kind = "Field";
          tmpNode.name.value = queryName;
          return tmpNode;
        }
      }
    },
    Field: {
      leave: (node) => {
        if (node.name.value in chained_changes) {
          let tmpNode = JSON.parse(JSON.stringify(node));
          tmpNode.kind = "Field";
          tmpNode.name.value = node.name.value;
          tmpNode.selectionSet.selections = [];
          return tmpNode;
        }
      }
    }
  });
  queryFileFragment = print(alteredAstOfQueryFileFragment);
  Object.keys(chained_changes).map((key) => {
    if (key in selectionsMappingToName) {
      queryFileFragment = queryFileFragment.replace(key, selectionsMappingToName[chained_changes[key]]);
    }
  });
  let file = graphqlFile;
  let prevIndex = graphqlFile.length;
  visit(astGraphqlFile, {
    OperationDefinition(node) {
      var _a2, _b;
      if (((_a2 = node.name) == null ? void 0 : _a2.value) === queryName) {
        const field = (_b = node.selectionSet) == null ? void 0 : _b.selections[0];
        file = graphqlFile.substring(0, field.selectionSet.loc.start);
        prevIndex = field.selectionSet.loc.end;
      }
    }
  });
  file += queryFileFragment;
  file += graphqlFile.substring(prevIndex, graphqlFile.length);
  return file.length ? print(parse$6(file)) : graphqlFile;
};
const introspectionDeepCopy = (data) => JSON.parse(JSON.stringify(data));
const getParentId = (id, devtoolsTree) => {
  const currNode = devtoolsTree == null ? void 0 : devtoolsTree.get(id);
  return currNode == null ? void 0 : currNode.parentID;
};
const getDevtoolsTree = () => window.devtoolsTree;
const isColumnTitle = (el2) => el2.classList.contains("MuiDataGrid-columnHeaderTitleContainer");
const getColIndex = (el2) => {
  let currElement = el2;
  while (currElement.parentElement) {
    if (currElement.classList.contains("MuiDataGrid-columnHeader")) {
      const attr2 = currElement.getAttribute("aria-colindex");
      if (attr2) {
        return parseInt(attr2);
      }
    }
    currElement = currElement.parentElement;
  }
};
const getFieldNameFromElement = (el2) => {
  let currElement = el2;
  while (currElement.parentElement) {
    if (currElement.classList.contains("MuiDataGrid-columnHeader")) {
      const attr2 = currElement.getAttribute("data-field");
      if (attr2)
        return attr2;
    }
    currElement = currElement.parentElement;
  }
};
const isDataGridCell = (el2) => el2.classList.contains("MuiDataGrid-columnHeaderTitleContainer") || el2.classList.contains("MuiDataGrid-columnHeaderTitleContainerContent") || el2.parentElement.classList.contains("MuiDataGrid-columnHeaderTitleContainer") || el2.parentElement.classList.contains("MuiDataGrid-columnHeaderTitleContainerContent");
const isFormInput = (el2) => {
  var _a2, _b, _c;
  const childElements = [...el2.children];
  if (childElements.some((element2) => (element2 == null ? void 0 : element2.classList.contains("MuiInput-root")) || (element2 == null ? void 0 : element2.classList.contains("MuiCheckbox-root")) || [...element2.children].some((e) => (e == null ? void 0 : e.classList.contains("MuiInput-root")) || (e == null ? void 0 : e.classList.contains("MuiCheckbox-root")))))
    return true;
  if (((_a2 = el2 == null ? void 0 : el2.parentElement) == null ? void 0 : _a2.classList.contains("MuiInput-root")) || ((_b = el2 == null ? void 0 : el2.parentElement) == null ? void 0 : _b.classList.contains("MuiCheckbox-root")))
    return true;
  if ((_c = el2 == null ? void 0 : el2.nextElementSibling) == null ? void 0 : _c.classList.contains("MuiInput-root"))
    return true;
  return el2.classList.contains("MuiTextField-root") || el2.classList.contains("MuiInput-input") || el2.classList.contains("MuiInputBase-input");
};
const getInputElement = (el2) => {
  if (el2.tagName === "INPUT")
    return el2;
  const childElements = [...el2.children];
  for (const element2 of childElements) {
    const result2 = getInputElement(element2);
    if (result2)
      return result2;
  }
  return void 0;
};
let requestId = 0;
const getSourceFromElement = (el2) => {
  const data = getDataFromElement(el2);
  const elementProps = data == null ? void 0 : data.props;
  if (elementProps) {
    const __typename = findPropInPropTree(elementProps, "__typename");
    if (__typename && data.source)
      data.source.__typename = __typename;
  }
  return data == null ? void 0 : data.source;
};
const getDataFromElement = (el2) => {
  var _a2;
  const devtoolsHook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  const id = (_a2 = devtoolsHook == null ? void 0 : devtoolsHook.reactDevtoolsAgent) == null ? void 0 : _a2.getIDForNode(el2);
  if (!id)
    return null;
  const rendererInterfaces = (devtoolsHook == null ? void 0 : devtoolsHook.reactDevtoolsAgent)._rendererInterfaces;
  if (!rendererInterfaces)
    return;
  let data = void 0;
  for (const rendererInterface of Object.values(rendererInterfaces)) {
    if (isColumnTitle(el2)) {
      data = getDataFromChild(id, rendererInterface);
    }
    if (!data)
      data = getDataFromParent(id, rendererInterface);
  }
  return data;
};
const getDataFromParent = (id, rendererInterface) => {
  var _a2;
  const devtoolsTree = getDevtoolsTree();
  let currId = id;
  for (let i2 = 0; i2 < 10; i2++) {
    const path2 = rendererInterface.getPathForElement(currId);
    const data = rendererInterface.inspectElement(`iteria-response${requestId++}`, currId, path2);
    if ((_a2 = data.value) == null ? void 0 : _a2.source)
      return data.value;
    currId = getParentId(currId, devtoolsTree);
  }
  console.warn("element source not found");
};
const findTypenameValue = () => {
  var _a2, _b, _c, _d;
  const devtoolsHook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
  const devtoolsTree = getDevtoolsTree();
  const rendererInterfaces = (_a2 = devtoolsHook == null ? void 0 : devtoolsHook.reactDevtoolsAgent) == null ? void 0 : _a2._rendererInterfaces;
  if (!rendererInterfaces)
    return;
  for (const rendererInferface of Object.values(rendererInterfaces)) {
    for (const [, element2] of devtoolsTree) {
      const path2 = rendererInferface.getPathForElement(element2.id);
      const data = rendererInferface.inspectElement(`iteria-response${requestId++}`, element2.id, path2);
      const elementProps = ((_b = data == null ? void 0 : data.value) == null ? void 0 : _b.source) ? (_d = (_c = data == null ? void 0 : data.value) == null ? void 0 : _c.props) == null ? void 0 : _d.data : void 0;
      if (elementProps) {
        const __typename = findPropInPropTree(elementProps, "__typename");
        if (__typename)
          return __typename;
      }
    }
  }
};
const findPropInPropTree = (props, propName) => {
  if (!props)
    return;
  for (const prop of Object.keys(props)) {
    if (prop === propName)
      return props[prop];
    else if (typeof props[prop] === "object") {
      const foundProp = findPropInPropTree(props[prop], propName);
      if (foundProp)
        return foundProp;
    }
  }
};
const getDataFromChild = (id, rendererInterface) => {
  var _a2;
  for (let i2 = id; i2 < id + 100; i2++) {
    const path2 = rendererInterface.getPathForElement(i2);
    const data = rendererInterface.inspectElement(`iteria-response${requestId++}`, i2, path2);
    if ((_a2 = data.value) == null ? void 0 : _a2.source)
      return data.value;
  }
};
const getColumnTitle = (el2) => {
  while (el2 && !isColumnTitle(el2)) {
    el2 = el2.parentElement;
  }
  return el2;
};
/*! @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasOwnProperty$i = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply$3 = _ref.apply, construct = _ref.construct;
if (!apply$3) {
  apply$3 = function apply2(fun, thisValue, args2) {
    return fun.apply(thisValue, args2);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct) {
  construct = function construct2(Func, args2) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args2))))();
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args2[_key - 1] = arguments[_key];
    }
    return apply$3(func, thisArg, args2);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args2 = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args2[_key2] = arguments[_key2];
    }
    return construct(func, args2);
  };
}
function addToSet(set2, array) {
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l2 = array.length;
  while (l2--) {
    var element2 = array[l2];
    if (typeof element2 === "string") {
      var lcElement = stringToLowerCase(element2);
      if (lcElement !== element2) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element2 = lcElement;
      }
    }
    set2[element2] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create(null);
  var property2 = void 0;
  for (property2 in object) {
    if (apply$3(hasOwnProperty$i, object, [property2])) {
      newObject[property2] = object[property2];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element2) {
    console.warn("fallback value for", element2);
    return null;
  }
  return fallbackValue;
}
var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var DOCTYPE_NAME = seal(/^html$/i);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj2) {
  return typeof obj2;
} : function(obj2) {
  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
};
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes2, document2) {
  if ((typeof trustedTypes2 === "undefined" ? "undefined" : _typeof(trustedTypes2)) !== "object" || typeof trustedTypes2.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes2.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root2) {
    return createDOMPurify(root2);
  };
  DOMPurify.version = "2.3.6";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement2 = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes2 = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template2 = document2.createElement("template");
    if (template2.content && template2.content.ownerDocument) {
      document2 = template2.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes2, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc = void 0;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element2) {
    var parent = getParentNode(element2);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element2.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element2.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element2.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element2.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc = void 0;
    var leadingWhitespace2 = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace2 = matches2 && matches2[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_) {
      }
    }
    var body2 = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace2) {
      body2.insertBefore(document2.createTextNode(leadingWhitespace2), body2.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body2;
  };
  var _createIterator = function _createIterator2(root2) {
    return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement2 && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node2 === "undefined" ? "undefined" : _typeof(Node2)) === "object" ? object instanceof Node2 : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content2 = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i2 = childCount - 1; i2 >= 0; --i2) {
            parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content2 = currentNode.textContent;
      content2 = stringReplace(content2, MUSTACHE_EXPR$$1, " ");
      content2 = stringReplace(content2, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content2;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value2) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value2 in document2 || value2 in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value2) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value2)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value2, ATTR_WHITESPACE$$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value2, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value2, ATTR_WHITESPACE$$1, "")))
      ;
    else if (!value2)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr2 = void 0;
    var value2 = void 0;
    var lcName = void 0;
    var l2 = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr2 = attributes[l2];
      var _attr = attr2, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value2 = stringTrim(attr2.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value2;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value2 = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value2)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value2 = stringReplace(value2, MUSTACHE_EXPR$$1, " ");
        value2 = stringReplace(value2, ERB_EXPR$$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value2)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value2);
        } else {
          currentNode.setAttribute(name, value2);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body2 = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body2 = _initDocument("<!---->");
      importedNode = body2.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body2 = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body2 = importedNode;
      } else {
        body2.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body2 = _initDocument(dirty);
      if (!body2) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body2 && FORCE_BODY) {
      _forceRemove(body2.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body2);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body2.ownerDocument);
        while (body2.firstChild) {
          returnNode.appendChild(body2.firstChild);
        }
      } else {
        returnNode = body2;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body2.outerHTML : body2.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body2.ownerDocument && body2.ownerDocument.doctype && body2.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body2.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body2.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr2, value2) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr2);
    return _isValidAttribute(lcTag, lcName, value2);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const escapeSpecialChars = (str2) => {
  return str2.replace(/[\n]+$/g, "").replace(/^[\n]+/g, "").replace(/[\n]/g, "\\n").replace(/[\']/g, "'").replace(/[\"]/g, '\\"').replace(/[\r]/g, "").replace(/[\t]/g, "").replace(/[\b]/g, "").replace(/[\f]/g, "");
};
const findSpanNode = (el2) => {
  if (el2.tagName === "SPAN" && el2.dataset.messageId) {
    return el2;
  }
  const MAX_DEPTH = 10;
  let depth2 = 0;
  while (el2.parentNode && depth2 < MAX_DEPTH) {
    el2.removeAttribute("data-editable");
    if (!el2.classList.length) {
      el2.removeAttribute("class");
    }
    el2 = el2.parentNode;
    if (el2.tagName === "SPAN" && el2.dataset.messageId) {
      return el2;
    }
    depth2++;
  }
  return null;
};
const forceSaveLocaleElement = (target, inspectedElement, event2, workbench2, onShowUserFeedback) => {
  var _a2, _b;
  const cwd = (_a2 = guessCurrentWorkingDirectory()) != null ? _a2 : workbench2 == null ? void 0 : workbench2.cwd;
  const LANGS_PATH = workbench2.injectMode === "devServer" ? cwd + "/src/compiled-lang" : "/src/compiled-lang";
  const langLocale = (_b = window.localStorage.getItem("langLocale")) != null ? _b : navigator.language.split("-")[0];
  const localeSourceUrl = LANGS_PATH + `/${langLocale}.json`;
  let data;
  workbench2.readFile(localeSourceUrl).then((originalLocaleStringJSON) => {
    var _a3, _b2, _c;
    const originalMessages = parseLocaleJSON(originalLocaleStringJSON);
    let newValue = "";
    const spanNode = findSpanNode(target);
    if (spanNode) {
      newValue = purify.sanitize(spanNode.innerHTML);
    }
    newValue = escapeSpecialChars(newValue);
    const messageId = ((_b2 = (_a3 = inspectedElement == null ? void 0 : inspectedElement.props) == null ? void 0 : _a3.data) == null ? void 0 : _b2.id) || ((_c = Object.values(spanNode == null ? void 0 : spanNode.attributes).find((att) => (att == null ? void 0 : att.name) === "data-message-id")) == null ? void 0 : _c.value);
    const found = originalMessages.find((message) => message.id === messageId);
    if (newValue === (found == null ? void 0 : found.value))
      return;
    if (onShowUserFeedback)
      onShowUserFeedback({ type: "LOCAL_MESSAGE_TRANSLATE_INFO" });
    if (found === void 0) {
      for (let i2 = originalMessages.length - 1; i2 >= 0; i2--) {
        if (originalMessages[i2].id === originalMessages[originalMessages.length - 1].id) {
          const before = originalLocaleStringJSON == null ? void 0 : originalLocaleStringJSON.substring(0, originalMessages[i2].position.end);
          const after = originalLocaleStringJSON == null ? void 0 : originalLocaleStringJSON.substring(originalMessages[i2].position.end);
          const newRow = `"${messageId}": "${newValue}"`;
          originalLocaleStringJSON = before + ",\n  " + newRow + after;
        }
      }
      data = originalLocaleStringJSON;
    }
    if (originalMessages && found) {
      for (let i2 = originalMessages.length - 1; i2 >= 0; i2--) {
        if (originalMessages[i2].id === messageId) {
          const before = originalLocaleStringJSON == null ? void 0 : originalLocaleStringJSON.substring(0, originalMessages[i2].position.pos + 2);
          const after = originalLocaleStringJSON == null ? void 0 : originalLocaleStringJSON.substring(originalMessages[i2].position.end - 1);
          originalLocaleStringJSON = before + newValue + after;
        }
      }
      data = originalLocaleStringJSON;
    }
    if (onShowUserFeedback) {
      onShowUserFeedback({ type: "LOCAL_MESSAGE_TRANSLATE_SUCESS" });
    }
    workbench2.writeFile(localeSourceUrl, data);
  });
};
class HoverInspector {
  constructor(workbench2) {
    __publicField2(this, "workbench");
    __publicField2(this, "cachedSource");
    __publicField2(this, "cachedFileContent");
    this.workbench = workbench2;
  }
  async getComponentName(el2) {
    const source = getSourceFromElement(el2);
    if (!source)
      return;
    const __typename = source == null ? void 0 : source.__typename;
    if (__typename)
      el2.__typename = __typename;
    const fileContent = await this.getCachedFileContent(source);
    if (!fileContent)
      return console.warn("File not found");
    const tooltipText = this.getParsedTagRegxp(fileContent, source);
    return tooltipText;
  }
  async getCachedFileContent(source) {
    if (!this.cachedSource)
      this.cachedSource = source;
    if (!this.cachedFileContent || source.fileName !== this.cachedSource.fileName) {
      const fileContent = await this.workbench.readFile(source.fileName);
      this.cachedFileContent = fileContent;
      this.cachedSource = source;
    }
    return this.cachedFileContent;
  }
  getParsedTagRegxp(fileContent, source) {
    var _a2, _b;
    const startOfJsxTag = startOfJsxIdentifier(fileContent, source);
    if (startOfJsxTag != null && fileContent.charAt(startOfJsxTag - 1) === "<") {
      return (_b = (_a2 = fileContent == null ? void 0 : fileContent.substring(startOfJsxTag)) == null ? void 0 : _a2.match(/\w+/)) == null ? void 0 : _b.pop();
    }
  }
}
const normalizePath = (path2) => {
  var _a2, _b, _c;
  if (!(path2 == null ? void 0 : path2.startsWith("/src/")) && (path2 == null ? void 0 : path2.includes("src"))) {
    const relativePath = (_c = (_a2 = path2.split("/src/")) == null ? void 0 : _a2[1]) != null ? _c : (_b = path2.split("src/")) == null ? void 0 : _b[1];
    return "/src/" + relativePath;
  }
  return path2;
};
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal$4 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
var root$7 = freeGlobal$4 || freeSelf$2 || Function("return this")();
var objectProto$m = Object.prototype;
var objectToString$3 = objectProto$m.toString;
var nativeMax$2 = Math.max, nativeMin = Math.min;
var now = function() {
  return root$7.Date.now();
};
function debounce(func, wait2, options2) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait2 = toNumber(wait2) || 0;
  if (isObject$d(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax$2(toNumber(options2.maxWait) || 0, wait2) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args2 = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args2);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait2);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait2 - timeSinceLastCall;
    return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush2() {
    return timerId === void 0 ? result2 : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait2);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait2);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush2;
  return debounced;
}
function isObject$d(value2) {
  var type2 = typeof value2;
  return !!value2 && (type2 == "object" || type2 == "function");
}
function isObjectLike$7(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike$7(value2) && objectToString$3.call(value2) == symbolTag;
}
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject$d(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$d(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = value2.replace(reTrim, "");
  var isBinary2 = reIsBinary.test(value2);
  return isBinary2 || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var lodash_debounce = debounce;
const stripExtension$1 = (fileName) => {
  const dot = fileName.lastIndexOf(".");
  const hasExtension = dot > 0 && dot < fileName.length;
  if (hasExtension) {
    return fileName.substring(0, dot);
  }
  return fileName;
};
const stripGitHubUrl = (url) => {
  return url.replace("https://github.com/", "").replace("git@github.com:", "");
};
const classNameBlacklist = [];
const tableRootClassNames = ["MuiDataGrid-main"];
const shouldDisplayElementHighlight = (el2) => !classNameBlacklist.some((className) => el2.closest(`.${className}`));
const isInsideTable = (el2) => tableRootClassNames.some((className) => el2.closest(`.${className}`));
const detailPageRegex = /^-?\d+$/;
const detailPageFullRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
const getEntityNameFromUrl = () => {
  const url = window.location.href;
  const urlParts = url.split("/").filter(Boolean);
  if (detailPageRegex.test(urlParts[urlParts.length - 1]) || detailPageFullRegex.test(urlParts[urlParts.length - 1]) || urlParts[urlParts.length - 1] === "create") {
    return urlParts[urlParts.length - 2];
  } else
    return urlParts[urlParts.length - 1];
};
var rangyCore = { exports: {} };
(function(module2, exports2) {
  (function(factory2, root2) {
    {
      module2.exports = factory2();
    }
  })(function() {
    var OBJECT = "object", FUNCTION = "function", UNDEFINED = "undefined";
    var domRangeProperties = [
      "startContainer",
      "startOffset",
      "endContainer",
      "endOffset",
      "collapsed",
      "commonAncestorContainer"
    ];
    var domRangeMethods = [
      "setStart",
      "setStartBefore",
      "setStartAfter",
      "setEnd",
      "setEndBefore",
      "setEndAfter",
      "collapse",
      "selectNode",
      "selectNodeContents",
      "compareBoundaryPoints",
      "deleteContents",
      "extractContents",
      "cloneContents",
      "insertNode",
      "surroundContents",
      "cloneRange",
      "toString",
      "detach"
    ];
    var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];
    var textRangeMethods = [
      "collapse",
      "compareEndPoints",
      "duplicate",
      "moveToElementText",
      "parentElement",
      "select",
      "setEndPoint",
      "getBoundingClientRect"
    ];
    function isHostMethod(o, p2) {
      var t = typeof o[p2];
      return t == FUNCTION || !!(t == OBJECT && o[p2]) || t == "unknown";
    }
    function isHostObject(o, p2) {
      return !!(typeof o[p2] == OBJECT && o[p2]);
    }
    function isHostProperty(o, p2) {
      return typeof o[p2] != UNDEFINED;
    }
    function createMultiplePropertyTest(testFunc) {
      return function(o, props) {
        var i2 = props.length;
        while (i2--) {
          if (!testFunc(o, props[i2])) {
            return false;
          }
        }
        return true;
      };
    }
    var areHostMethods = createMultiplePropertyTest(isHostMethod);
    var areHostObjects = createMultiplePropertyTest(isHostObject);
    var areHostProperties = createMultiplePropertyTest(isHostProperty);
    function isTextRange(range2) {
      return range2 && areHostMethods(range2, textRangeMethods) && areHostProperties(range2, textRangeProperties);
    }
    function getBody(doc) {
      return isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];
    }
    var forEach = [].forEach ? function(arr, func) {
      arr.forEach(func);
    } : function(arr, func) {
      for (var i2 = 0, len = arr.length; i2 < len; ++i2) {
        func(arr[i2], i2);
      }
    };
    var modules = {};
    var isBrowser2 = typeof window != UNDEFINED && typeof document != UNDEFINED;
    var util2 = {
      isHostMethod,
      isHostObject,
      isHostProperty,
      areHostMethods,
      areHostObjects,
      areHostProperties,
      isTextRange,
      getBody,
      forEach
    };
    var api = {
      version: "1.3.0",
      initialized: false,
      isBrowser: isBrowser2,
      supported: true,
      util: util2,
      features: {},
      modules,
      config: {
        alertOnFail: false,
        alertOnWarn: false,
        preferTextRange: false,
        autoInitialize: typeof rangyAutoInitialize == UNDEFINED ? true : rangyAutoInitialize
      }
    };
    function consoleLog(msg) {
      if (typeof console != UNDEFINED && isHostMethod(console, "log")) {
        console.log(msg);
      }
    }
    function alertOrLog(msg, shouldAlert) {
      if (isBrowser2 && shouldAlert) {
        alert(msg);
      } else {
        consoleLog(msg);
      }
    }
    function fail(reason) {
      api.initialized = true;
      api.supported = false;
      alertOrLog("Rangy is not supported in this environment. Reason: " + reason, api.config.alertOnFail);
    }
    api.fail = fail;
    function warn(msg) {
      alertOrLog("Rangy warning: " + msg, api.config.alertOnWarn);
    }
    api.warn = warn;
    var extend3;
    if ({}.hasOwnProperty) {
      util2.extend = extend3 = function(obj2, props, deep) {
        var o, p2;
        for (var i2 in props) {
          if (props.hasOwnProperty(i2)) {
            o = obj2[i2];
            p2 = props[i2];
            if (deep && o !== null && typeof o == "object" && p2 !== null && typeof p2 == "object") {
              extend3(o, p2, true);
            }
            obj2[i2] = p2;
          }
        }
        if (props.hasOwnProperty("toString")) {
          obj2.toString = props.toString;
        }
        return obj2;
      };
      util2.createOptions = function(optionsParam, defaults2) {
        var options2 = {};
        extend3(options2, defaults2);
        if (optionsParam) {
          extend3(options2, optionsParam);
        }
        return options2;
      };
    } else {
      fail("hasOwnProperty not supported");
    }
    if (!isBrowser2) {
      fail("Rangy can only run in a browser");
    }
    (function() {
      var toArray3;
      if (isBrowser2) {
        var el2 = document.createElement("div");
        el2.appendChild(document.createElement("span"));
        var slice = [].slice;
        try {
          if (slice.call(el2.childNodes, 0)[0].nodeType == 1) {
            toArray3 = function(arrayLike) {
              return slice.call(arrayLike, 0);
            };
          }
        } catch (e) {
        }
      }
      if (!toArray3) {
        toArray3 = function(arrayLike) {
          var arr = [];
          for (var i2 = 0, len = arrayLike.length; i2 < len; ++i2) {
            arr[i2] = arrayLike[i2];
          }
          return arr;
        };
      }
      util2.toArray = toArray3;
    })();
    var addListener2;
    if (isBrowser2) {
      if (isHostMethod(document, "addEventListener")) {
        addListener2 = function(obj2, eventType, listener) {
          obj2.addEventListener(eventType, listener, false);
        };
      } else if (isHostMethod(document, "attachEvent")) {
        addListener2 = function(obj2, eventType, listener) {
          obj2.attachEvent("on" + eventType, listener);
        };
      } else {
        fail("Document does not have required addEventListener or attachEvent method");
      }
      util2.addListener = addListener2;
    }
    var initListeners = [];
    function getErrorDesc(ex) {
      return ex.message || ex.description || String(ex);
    }
    function init2() {
      if (!isBrowser2 || api.initialized) {
        return;
      }
      var testRange;
      var implementsDomRange = false, implementsTextRange = false;
      if (isHostMethod(document, "createRange")) {
        testRange = document.createRange();
        if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
          implementsDomRange = true;
        }
      }
      var body2 = getBody(document);
      if (!body2 || body2.nodeName.toLowerCase() != "body") {
        fail("No body element found");
        return;
      }
      if (body2 && isHostMethod(body2, "createTextRange")) {
        testRange = body2.createTextRange();
        if (isTextRange(testRange)) {
          implementsTextRange = true;
        }
      }
      if (!implementsDomRange && !implementsTextRange) {
        fail("Neither Range nor TextRange are available");
        return;
      }
      api.initialized = true;
      api.features = {
        implementsDomRange,
        implementsTextRange
      };
      var module3, errorMessage;
      for (var moduleName in modules) {
        if ((module3 = modules[moduleName]) instanceof Module) {
          module3.init(module3, api);
        }
      }
      for (var i2 = 0, len = initListeners.length; i2 < len; ++i2) {
        try {
          initListeners[i2](api);
        } catch (ex) {
          errorMessage = "Rangy init listener threw an exception. Continuing. Detail: " + getErrorDesc(ex);
          consoleLog(errorMessage);
        }
      }
    }
    function deprecationNotice(deprecated, replacement, module3) {
      if (module3) {
        deprecated += " in module " + module3.name;
      }
      api.warn("DEPRECATED: " + deprecated + " is deprecated. Please use " + replacement + " instead.");
    }
    function createAliasForDeprecatedMethod(owner, deprecated, replacement, module3) {
      owner[deprecated] = function() {
        deprecationNotice(deprecated, replacement, module3);
        return owner[replacement].apply(owner, util2.toArray(arguments));
      };
    }
    util2.deprecationNotice = deprecationNotice;
    util2.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;
    api.init = init2;
    api.addInitListener = function(listener) {
      if (api.initialized) {
        listener(api);
      } else {
        initListeners.push(listener);
      }
    };
    var shimListeners = [];
    api.addShimListener = function(listener) {
      shimListeners.push(listener);
    };
    function shim(win) {
      win = win || window;
      init2();
      for (var i2 = 0, len = shimListeners.length; i2 < len; ++i2) {
        shimListeners[i2](win);
      }
    }
    if (isBrowser2) {
      api.shim = api.createMissingNativeApi = shim;
      createAliasForDeprecatedMethod(api, "createMissingNativeApi", "shim");
    }
    function Module(name, dependencies, initializer) {
      this.name = name;
      this.dependencies = dependencies;
      this.initialized = false;
      this.supported = false;
      this.initializer = initializer;
    }
    Module.prototype = {
      init: function() {
        var requiredModuleNames = this.dependencies || [];
        for (var i2 = 0, len = requiredModuleNames.length, requiredModule, moduleName; i2 < len; ++i2) {
          moduleName = requiredModuleNames[i2];
          requiredModule = modules[moduleName];
          if (!requiredModule || !(requiredModule instanceof Module)) {
            throw new Error("required module '" + moduleName + "' not found");
          }
          requiredModule.init();
          if (!requiredModule.supported) {
            throw new Error("required module '" + moduleName + "' not supported");
          }
        }
        this.initializer(this);
      },
      fail: function(reason) {
        this.initialized = true;
        this.supported = false;
        throw new Error(reason);
      },
      warn: function(msg) {
        api.warn("Module " + this.name + ": " + msg);
      },
      deprecationNotice: function(deprecated, replacement) {
        api.warn("DEPRECATED: " + deprecated + " in module " + this.name + " is deprecated. Please use " + replacement + " instead");
      },
      createError: function(msg) {
        return new Error("Error in Rangy " + this.name + " module: " + msg);
      }
    };
    function createModule(name, dependencies, initFunc) {
      var newModule = new Module(name, dependencies, function(module3) {
        if (!module3.initialized) {
          module3.initialized = true;
          try {
            initFunc(api, module3);
            module3.supported = true;
          } catch (ex) {
            var errorMessage = "Module '" + name + "' failed to load: " + getErrorDesc(ex);
            consoleLog(errorMessage);
            if (ex.stack) {
              consoleLog(ex.stack);
            }
          }
        }
      });
      modules[name] = newModule;
      return newModule;
    }
    api.createModule = function(name) {
      var initFunc, dependencies;
      if (arguments.length == 2) {
        initFunc = arguments[1];
        dependencies = [];
      } else {
        initFunc = arguments[2];
        dependencies = arguments[1];
      }
      var module3 = createModule(name, dependencies, initFunc);
      if (api.initialized && api.supported) {
        module3.init();
      }
    };
    api.createCoreModule = function(name, dependencies, initFunc) {
      createModule(name, dependencies, initFunc);
    };
    function RangePrototype() {
    }
    api.RangePrototype = RangePrototype;
    api.rangePrototype = new RangePrototype();
    function SelectionPrototype() {
    }
    api.selectionPrototype = new SelectionPrototype();
    api.createCoreModule("DomUtil", [], function(api2, module3) {
      var UNDEF = "undefined";
      var util3 = api2.util;
      var getBody2 = util3.getBody;
      if (!util3.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {
        module3.fail("document missing a Node creation method");
      }
      if (!util3.isHostMethod(document, "getElementsByTagName")) {
        module3.fail("document missing getElementsByTagName method");
      }
      var el2 = document.createElement("div");
      if (!util3.areHostMethods(el2, ["insertBefore", "appendChild", "cloneNode"])) {
        module3.fail("Incomplete Element implementation");
      }
      if (!util3.isHostProperty(el2, "innerHTML")) {
        module3.fail("Element is missing innerHTML property");
      }
      var textNode2 = document.createTextNode("test");
      if (!util3.areHostMethods(textNode2, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"])) {
        module3.fail("Incomplete Text Node implementation");
      }
      var arrayContains = function(arr, val) {
        var i2 = arr.length;
        while (i2--) {
          if (arr[i2] === val) {
            return true;
          }
        }
        return false;
      };
      function isHtmlNamespace(node) {
        var ns;
        return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml");
      }
      function parentElement(node) {
        var parent = node.parentNode;
        return parent.nodeType == 1 ? parent : null;
      }
      function getNodeIndex2(node) {
        var i2 = 0;
        while (node = node.previousSibling) {
          ++i2;
        }
        return i2;
      }
      function getNodeLength(node) {
        switch (node.nodeType) {
          case 7:
          case 10:
            return 0;
          case 3:
          case 8:
            return node.length;
          default:
            return node.childNodes.length;
        }
      }
      function getCommonAncestor(node1, node2) {
        var ancestors = [], n2;
        for (n2 = node1; n2; n2 = n2.parentNode) {
          ancestors.push(n2);
        }
        for (n2 = node2; n2; n2 = n2.parentNode) {
          if (arrayContains(ancestors, n2)) {
            return n2;
          }
        }
        return null;
      }
      function isAncestorOf(ancestor, descendant, selfIsAncestor) {
        var n2 = selfIsAncestor ? descendant : descendant.parentNode;
        while (n2) {
          if (n2 === ancestor) {
            return true;
          } else {
            n2 = n2.parentNode;
          }
        }
        return false;
      }
      function isOrIsAncestorOf(ancestor, descendant) {
        return isAncestorOf(ancestor, descendant, true);
      }
      function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
        var p2, n2 = selfIsAncestor ? node : node.parentNode;
        while (n2) {
          p2 = n2.parentNode;
          if (p2 === ancestor) {
            return n2;
          }
          n2 = p2;
        }
        return null;
      }
      function isCharacterDataNode(node) {
        var t = node.nodeType;
        return t == 3 || t == 4 || t == 8;
      }
      function isTextOrCommentNode(node) {
        if (!node) {
          return false;
        }
        var t = node.nodeType;
        return t == 3 || t == 8;
      }
      function insertAfter(node, precedingNode) {
        var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
        if (nextNode) {
          parent.insertBefore(node, nextNode);
        } else {
          parent.appendChild(node);
        }
        return node;
      }
      function splitDataNode(node, index2, positionsToPreserve) {
        var newNode = node.cloneNode(false);
        newNode.deleteData(0, index2);
        node.deleteData(index2, node.length - index2);
        insertAfter(newNode, node);
        if (positionsToPreserve) {
          for (var i2 = 0, position2; position2 = positionsToPreserve[i2++]; ) {
            if (position2.node == node && position2.offset > index2) {
              position2.node = newNode;
              position2.offset -= index2;
            } else if (position2.node == node.parentNode && position2.offset > getNodeIndex2(node)) {
              ++position2.offset;
            }
          }
        }
        return newNode;
      }
      function getDocument(node) {
        if (node.nodeType == 9) {
          return node;
        } else if (typeof node.ownerDocument != UNDEF) {
          return node.ownerDocument;
        } else if (typeof node.document != UNDEF) {
          return node.document;
        } else if (node.parentNode) {
          return getDocument(node.parentNode);
        } else {
          throw module3.createError("getDocument: no document found for node");
        }
      }
      function getWindow(node) {
        var doc = getDocument(node);
        if (typeof doc.defaultView != UNDEF) {
          return doc.defaultView;
        } else if (typeof doc.parentWindow != UNDEF) {
          return doc.parentWindow;
        } else {
          throw module3.createError("Cannot get a window object for node");
        }
      }
      function getIframeDocument(iframeEl) {
        if (typeof iframeEl.contentDocument != UNDEF) {
          return iframeEl.contentDocument;
        } else if (typeof iframeEl.contentWindow != UNDEF) {
          return iframeEl.contentWindow.document;
        } else {
          throw module3.createError("getIframeDocument: No Document object found for iframe element");
        }
      }
      function getIframeWindow(iframeEl) {
        if (typeof iframeEl.contentWindow != UNDEF) {
          return iframeEl.contentWindow;
        } else if (typeof iframeEl.contentDocument != UNDEF) {
          return iframeEl.contentDocument.defaultView;
        } else {
          throw module3.createError("getIframeWindow: No Window object found for iframe element");
        }
      }
      function isWindow(obj2) {
        return obj2 && util3.isHostMethod(obj2, "setTimeout") && util3.isHostObject(obj2, "document");
      }
      function getContentDocument(obj2, module4, methodName) {
        var doc;
        if (!obj2) {
          doc = document;
        } else if (util3.isHostProperty(obj2, "nodeType")) {
          doc = obj2.nodeType == 1 && obj2.tagName.toLowerCase() == "iframe" ? getIframeDocument(obj2) : getDocument(obj2);
        } else if (isWindow(obj2)) {
          doc = obj2.document;
        }
        if (!doc) {
          throw module4.createError(methodName + "(): Parameter must be a Window object or DOM node");
        }
        return doc;
      }
      function getRootContainer(node) {
        var parent;
        while (parent = node.parentNode) {
          node = parent;
        }
        return node;
      }
      function comparePoints(nodeA, offsetA, nodeB, offsetB) {
        var nodeC, root2, childA, childB, n2;
        if (nodeA == nodeB) {
          return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;
        } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {
          return offsetA <= getNodeIndex2(nodeC) ? -1 : 1;
        } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {
          return getNodeIndex2(nodeC) < offsetB ? -1 : 1;
        } else {
          root2 = getCommonAncestor(nodeA, nodeB);
          if (!root2) {
            throw new Error("comparePoints error: nodes have no common ancestor");
          }
          childA = nodeA === root2 ? root2 : getClosestAncestorIn(nodeA, root2, true);
          childB = nodeB === root2 ? root2 : getClosestAncestorIn(nodeB, root2, true);
          if (childA === childB) {
            throw module3.createError("comparePoints got to case 4 and childA and childB are the same!");
          } else {
            n2 = root2.firstChild;
            while (n2) {
              if (n2 === childA) {
                return -1;
              } else if (n2 === childB) {
                return 1;
              }
              n2 = n2.nextSibling;
            }
          }
        }
      }
      var crashyTextNodes = false;
      function isBrokenNode(node) {
        var n2;
        try {
          n2 = node.parentNode;
          return false;
        } catch (e) {
          return true;
        }
      }
      (function() {
        var el3 = document.createElement("b");
        el3.innerHTML = "1";
        var textNode3 = el3.firstChild;
        el3.innerHTML = "<br />";
        crashyTextNodes = isBrokenNode(textNode3);
        api2.features.crashyTextNodes = crashyTextNodes;
      })();
      function inspectNode(node) {
        if (!node) {
          return "[No node]";
        }
        if (crashyTextNodes && isBrokenNode(node)) {
          return "[Broken node]";
        }
        if (isCharacterDataNode(node)) {
          return '"' + node.data + '"';
        }
        if (node.nodeType == 1) {
          var idAttr = node.id ? ' id="' + node.id + '"' : "";
          return "<" + node.nodeName + idAttr + ">[index:" + getNodeIndex2(node) + ",length:" + node.childNodes.length + "][" + (node.innerHTML || "[innerHTML not supported]").slice(0, 25) + "]";
        }
        return node.nodeName;
      }
      function fragmentFromNodeChildren(node) {
        var fragment = getDocument(node).createDocumentFragment(), child;
        while (child = node.firstChild) {
          fragment.appendChild(child);
        }
        return fragment;
      }
      var getComputedStyleProperty;
      if (typeof window.getComputedStyle != UNDEF) {
        getComputedStyleProperty = function(el3, propName) {
          return getWindow(el3).getComputedStyle(el3, null)[propName];
        };
      } else if (typeof document.documentElement.currentStyle != UNDEF) {
        getComputedStyleProperty = function(el3, propName) {
          return el3.currentStyle ? el3.currentStyle[propName] : "";
        };
      } else {
        module3.fail("No means of obtaining computed style properties found");
      }
      function createTestElement(doc, html2, contentEditable) {
        var body2 = getBody2(doc);
        var el3 = doc.createElement("div");
        el3.contentEditable = "" + !!contentEditable;
        if (html2) {
          el3.innerHTML = html2;
        }
        var bodyFirstChild = body2.firstChild;
        if (bodyFirstChild) {
          body2.insertBefore(el3, bodyFirstChild);
        } else {
          body2.appendChild(el3);
        }
        return el3;
      }
      function removeNode(node) {
        return node.parentNode.removeChild(node);
      }
      function NodeIterator2(root2) {
        this.root = root2;
        this._next = root2;
      }
      NodeIterator2.prototype = {
        _current: null,
        hasNext: function() {
          return !!this._next;
        },
        next: function() {
          var n2 = this._current = this._next;
          var child, next2;
          if (this._current) {
            child = n2.firstChild;
            if (child) {
              this._next = child;
            } else {
              next2 = null;
              while (n2 !== this.root && !(next2 = n2.nextSibling)) {
                n2 = n2.parentNode;
              }
              this._next = next2;
            }
          }
          return this._current;
        },
        detach: function() {
          this._current = this._next = this.root = null;
        }
      };
      function createIterator(root2) {
        return new NodeIterator2(root2);
      }
      function DomPosition(node, offset) {
        this.node = node;
        this.offset = offset;
      }
      DomPosition.prototype = {
        equals: function(pos) {
          return !!pos && this.node === pos.node && this.offset == pos.offset;
        },
        inspect: function() {
          return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";
        },
        toString: function() {
          return this.inspect();
        }
      };
      function DOMException2(codeName) {
        this.code = this[codeName];
        this.codeName = codeName;
        this.message = "DOMException: " + this.codeName;
      }
      DOMException2.prototype = {
        INDEX_SIZE_ERR: 1,
        HIERARCHY_REQUEST_ERR: 3,
        WRONG_DOCUMENT_ERR: 4,
        NO_MODIFICATION_ALLOWED_ERR: 7,
        NOT_FOUND_ERR: 8,
        NOT_SUPPORTED_ERR: 9,
        INVALID_STATE_ERR: 11,
        INVALID_NODE_TYPE_ERR: 24
      };
      DOMException2.prototype.toString = function() {
        return this.message;
      };
      api2.dom = {
        arrayContains,
        isHtmlNamespace,
        parentElement,
        getNodeIndex: getNodeIndex2,
        getNodeLength,
        getCommonAncestor,
        isAncestorOf,
        isOrIsAncestorOf,
        getClosestAncestorIn,
        isCharacterDataNode,
        isTextOrCommentNode,
        insertAfter,
        splitDataNode,
        getDocument,
        getWindow,
        getIframeWindow,
        getIframeDocument,
        getBody: getBody2,
        isWindow,
        getContentDocument,
        getRootContainer,
        comparePoints,
        isBrokenNode,
        inspectNode,
        getComputedStyleProperty,
        createTestElement,
        removeNode,
        fragmentFromNodeChildren,
        createIterator,
        DomPosition
      };
      api2.DOMException = DOMException2;
    });
    api.createCoreModule("DomRange", ["DomUtil"], function(api2, module3) {
      var dom = api2.dom;
      var util3 = api2.util;
      var DomPosition = dom.DomPosition;
      var DOMException2 = api2.DOMException;
      var isCharacterDataNode = dom.isCharacterDataNode;
      var getNodeIndex2 = dom.getNodeIndex;
      var isOrIsAncestorOf = dom.isOrIsAncestorOf;
      var getDocument = dom.getDocument;
      var comparePoints = dom.comparePoints;
      var splitDataNode = dom.splitDataNode;
      var getClosestAncestorIn = dom.getClosestAncestorIn;
      var getNodeLength = dom.getNodeLength;
      var arrayContains = dom.arrayContains;
      var getRootContainer = dom.getRootContainer;
      var crashyTextNodes = api2.features.crashyTextNodes;
      var removeNode = dom.removeNode;
      function isNonTextPartiallySelected(node, range2) {
        return node.nodeType != 3 && (isOrIsAncestorOf(node, range2.startContainer) || isOrIsAncestorOf(node, range2.endContainer));
      }
      function getRangeDocument(range2) {
        return range2.document || getDocument(range2.startContainer);
      }
      function getRangeRoot(range2) {
        return getRootContainer(range2.startContainer);
      }
      function getBoundaryBeforeNode(node) {
        return new DomPosition(node.parentNode, getNodeIndex2(node));
      }
      function getBoundaryAfterNode(node) {
        return new DomPosition(node.parentNode, getNodeIndex2(node) + 1);
      }
      function insertNodeAtPosition(node, n2, o) {
        var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
        if (isCharacterDataNode(n2)) {
          if (o == n2.length) {
            dom.insertAfter(node, n2);
          } else {
            n2.parentNode.insertBefore(node, o == 0 ? n2 : splitDataNode(n2, o));
          }
        } else if (o >= n2.childNodes.length) {
          n2.appendChild(node);
        } else {
          n2.insertBefore(node, n2.childNodes[o]);
        }
        return firstNodeInserted;
      }
      function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
        assertRangeValid(rangeA);
        assertRangeValid(rangeB);
        if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
          throw new DOMException2("WRONG_DOCUMENT_ERR");
        }
        var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);
        return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
      }
      function cloneSubtree(iterator) {
        var partiallySelected;
        for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
          partiallySelected = iterator.isPartiallySelectedSubtree();
          node = node.cloneNode(!partiallySelected);
          if (partiallySelected) {
            subIterator = iterator.getSubtreeIterator();
            node.appendChild(cloneSubtree(subIterator));
            subIterator.detach();
          }
          if (node.nodeType == 10) {
            throw new DOMException2("HIERARCHY_REQUEST_ERR");
          }
          frag.appendChild(node);
        }
        return frag;
      }
      function iterateSubtree(rangeIterator, func, iteratorState) {
        var it, n2;
        iteratorState = iteratorState || { stop: false };
        for (var node, subRangeIterator; node = rangeIterator.next(); ) {
          if (rangeIterator.isPartiallySelectedSubtree()) {
            if (func(node) === false) {
              iteratorState.stop = true;
              return;
            } else {
              subRangeIterator = rangeIterator.getSubtreeIterator();
              iterateSubtree(subRangeIterator, func, iteratorState);
              subRangeIterator.detach();
              if (iteratorState.stop) {
                return;
              }
            }
          } else {
            it = dom.createIterator(node);
            while (n2 = it.next()) {
              if (func(n2) === false) {
                iteratorState.stop = true;
                return;
              }
            }
          }
        }
      }
      function deleteSubtree(iterator) {
        var subIterator;
        while (iterator.next()) {
          if (iterator.isPartiallySelectedSubtree()) {
            subIterator = iterator.getSubtreeIterator();
            deleteSubtree(subIterator);
            subIterator.detach();
          } else {
            iterator.remove();
          }
        }
      }
      function extractSubtree(iterator) {
        for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next(); ) {
          if (iterator.isPartiallySelectedSubtree()) {
            node = node.cloneNode(false);
            subIterator = iterator.getSubtreeIterator();
            node.appendChild(extractSubtree(subIterator));
            subIterator.detach();
          } else {
            iterator.remove();
          }
          if (node.nodeType == 10) {
            throw new DOMException2("HIERARCHY_REQUEST_ERR");
          }
          frag.appendChild(node);
        }
        return frag;
      }
      function getNodesInRange(range2, nodeTypes, filter) {
        var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
        var filterExists = !!filter;
        if (filterNodeTypes) {
          regex = new RegExp("^(" + nodeTypes.join("|") + ")$");
        }
        var nodes = [];
        iterateSubtree(new RangeIterator(range2, false), function(node) {
          if (filterNodeTypes && !regex.test(node.nodeType)) {
            return;
          }
          if (filterExists && !filter(node)) {
            return;
          }
          var sc = range2.startContainer;
          if (node == sc && isCharacterDataNode(sc) && range2.startOffset == sc.length) {
            return;
          }
          var ec = range2.endContainer;
          if (node == ec && isCharacterDataNode(ec) && range2.endOffset == 0) {
            return;
          }
          nodes.push(node);
        });
        return nodes;
      }
      function inspect2(range2) {
        var name = typeof range2.getName == "undefined" ? "Range" : range2.getName();
        return "[" + name + "(" + dom.inspectNode(range2.startContainer) + ":" + range2.startOffset + ", " + dom.inspectNode(range2.endContainer) + ":" + range2.endOffset + ")]";
      }
      function RangeIterator(range2, clonePartiallySelectedTextNodes) {
        this.range = range2;
        this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;
        if (!range2.collapsed) {
          this.sc = range2.startContainer;
          this.so = range2.startOffset;
          this.ec = range2.endContainer;
          this.eo = range2.endOffset;
          var root2 = range2.commonAncestorContainer;
          if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
            this.isSingleCharacterDataNode = true;
            this._first = this._last = this._next = this.sc;
          } else {
            this._first = this._next = this.sc === root2 && !isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root2, true);
            this._last = this.ec === root2 && !isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root2, true);
          }
        }
      }
      RangeIterator.prototype = {
        _current: null,
        _next: null,
        _first: null,
        _last: null,
        isSingleCharacterDataNode: false,
        reset: function() {
          this._current = null;
          this._next = this._first;
        },
        hasNext: function() {
          return !!this._next;
        },
        next: function() {
          var current = this._current = this._next;
          if (current) {
            this._next = current !== this._last ? current.nextSibling : null;
            if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
              if (current === this.ec) {
                (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
              }
              if (this._current === this.sc) {
                (current = current.cloneNode(true)).deleteData(0, this.so);
              }
            }
          }
          return current;
        },
        remove: function() {
          var current = this._current, start, end;
          if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
            start = current === this.sc ? this.so : 0;
            end = current === this.ec ? this.eo : current.length;
            if (start != end) {
              current.deleteData(start, end - start);
            }
          } else {
            if (current.parentNode) {
              removeNode(current);
            }
          }
        },
        isPartiallySelectedSubtree: function() {
          var current = this._current;
          return isNonTextPartiallySelected(current, this.range);
        },
        getSubtreeIterator: function() {
          var subRange;
          if (this.isSingleCharacterDataNode) {
            subRange = this.range.cloneRange();
            subRange.collapse(false);
          } else {
            subRange = new Range(getRangeDocument(this.range));
            var current = this._current;
            var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);
            if (isOrIsAncestorOf(current, this.sc)) {
              startContainer = this.sc;
              startOffset = this.so;
            }
            if (isOrIsAncestorOf(current, this.ec)) {
              endContainer = this.ec;
              endOffset = this.eo;
            }
            updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
          }
          return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
        },
        detach: function() {
          this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
        }
      };
      var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];
      var rootContainerNodeTypes = [2, 9, 11];
      var readonlyNodeTypes = [5, 6, 10, 12];
      var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];
      var surroundNodeTypes = [1, 3, 4, 5, 7, 8];
      function createAncestorFinder(nodeTypes) {
        return function(node, selfIsAncestor) {
          var t, n2 = selfIsAncestor ? node : node.parentNode;
          while (n2) {
            t = n2.nodeType;
            if (arrayContains(nodeTypes, t)) {
              return n2;
            }
            n2 = n2.parentNode;
          }
          return null;
        };
      }
      var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);
      var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
      var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);
      function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
        if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
          throw new DOMException2("INVALID_NODE_TYPE_ERR");
        }
      }
      function assertValidNodeType(node, invalidTypes) {
        if (!arrayContains(invalidTypes, node.nodeType)) {
          throw new DOMException2("INVALID_NODE_TYPE_ERR");
        }
      }
      function assertValidOffset(node, offset) {
        if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
          throw new DOMException2("INDEX_SIZE_ERR");
        }
      }
      function assertSameDocumentOrFragment(node1, node2) {
        if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
          throw new DOMException2("WRONG_DOCUMENT_ERR");
        }
      }
      function assertNodeNotReadOnly(node) {
        if (getReadonlyAncestor(node, true)) {
          throw new DOMException2("NO_MODIFICATION_ALLOWED_ERR");
        }
      }
      function assertNode(node, codeName) {
        if (!node) {
          throw new DOMException2(codeName);
        }
      }
      function isValidOffset(node, offset) {
        return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
      }
      function isRangeValid(range2) {
        return !!range2.startContainer && !!range2.endContainer && !(crashyTextNodes && (dom.isBrokenNode(range2.startContainer) || dom.isBrokenNode(range2.endContainer))) && getRootContainer(range2.startContainer) == getRootContainer(range2.endContainer) && isValidOffset(range2.startContainer, range2.startOffset) && isValidOffset(range2.endContainer, range2.endOffset);
      }
      function assertRangeValid(range2) {
        if (!isRangeValid(range2)) {
          throw new Error("Range error: Range is not valid. This usually happens after DOM mutation. Range: (" + range2.inspect() + ")");
        }
      }
      var styleEl = document.createElement("style");
      var htmlParsingConforms = false;
      try {
        styleEl.innerHTML = "<b>x</b>";
        htmlParsingConforms = styleEl.firstChild.nodeType == 3;
      } catch (e) {
      }
      api2.features.htmlParsingConforms = htmlParsingConforms;
      var createContextualFragment = htmlParsingConforms ? function(fragmentStr) {
        var node = this.startContainer;
        var doc = getDocument(node);
        if (!node) {
          throw new DOMException2("INVALID_STATE_ERR");
        }
        var el2 = null;
        if (node.nodeType == 1) {
          el2 = node;
        } else if (isCharacterDataNode(node)) {
          el2 = dom.parentElement(node);
        }
        if (el2 === null || el2.nodeName == "HTML" && dom.isHtmlNamespace(getDocument(el2).documentElement) && dom.isHtmlNamespace(el2)) {
          el2 = doc.createElement("body");
        } else {
          el2 = el2.cloneNode(false);
        }
        el2.innerHTML = fragmentStr;
        return dom.fragmentFromNodeChildren(el2);
      } : function(fragmentStr) {
        var doc = getRangeDocument(this);
        var el2 = doc.createElement("body");
        el2.innerHTML = fragmentStr;
        return dom.fragmentFromNodeChildren(el2);
      };
      function splitRangeBoundaries(range2, positionsToPreserve) {
        assertRangeValid(range2);
        var sc = range2.startContainer, so = range2.startOffset, ec = range2.endContainer, eo = range2.endOffset;
        var startEndSame = sc === ec;
        if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
          splitDataNode(ec, eo, positionsToPreserve);
        }
        if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
          sc = splitDataNode(sc, so, positionsToPreserve);
          if (startEndSame) {
            eo -= so;
            ec = sc;
          } else if (ec == sc.parentNode && eo >= getNodeIndex2(sc)) {
            eo++;
          }
          so = 0;
        }
        range2.setStartAndEnd(sc, so, ec, eo);
      }
      function rangeToHtml(range2) {
        assertRangeValid(range2);
        var container = range2.commonAncestorContainer.parentNode.cloneNode(false);
        container.appendChild(range2.cloneContents());
        return container.innerHTML;
      }
      var rangeProperties = [
        "startContainer",
        "startOffset",
        "endContainer",
        "endOffset",
        "collapsed",
        "commonAncestorContainer"
      ];
      var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
      var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;
      util3.extend(api2.rangePrototype, {
        compareBoundaryPoints: function(how, range2) {
          assertRangeValid(this);
          assertSameDocumentOrFragment(this.startContainer, range2.startContainer);
          var nodeA, offsetA, nodeB, offsetB;
          var prefixA = how == e2s || how == s2s ? "start" : "end";
          var prefixB = how == s2e || how == s2s ? "start" : "end";
          nodeA = this[prefixA + "Container"];
          offsetA = this[prefixA + "Offset"];
          nodeB = range2[prefixB + "Container"];
          offsetB = range2[prefixB + "Offset"];
          return comparePoints(nodeA, offsetA, nodeB, offsetB);
        },
        insertNode: function(node) {
          assertRangeValid(this);
          assertValidNodeType(node, insertableNodeTypes);
          assertNodeNotReadOnly(this.startContainer);
          if (isOrIsAncestorOf(node, this.startContainer)) {
            throw new DOMException2("HIERARCHY_REQUEST_ERR");
          }
          var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
          this.setStartBefore(firstNodeInserted);
        },
        cloneContents: function() {
          assertRangeValid(this);
          var clone2, frag;
          if (this.collapsed) {
            return getRangeDocument(this).createDocumentFragment();
          } else {
            if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
              clone2 = this.startContainer.cloneNode(true);
              clone2.data = clone2.data.slice(this.startOffset, this.endOffset);
              frag = getRangeDocument(this).createDocumentFragment();
              frag.appendChild(clone2);
              return frag;
            } else {
              var iterator = new RangeIterator(this, true);
              clone2 = cloneSubtree(iterator);
              iterator.detach();
            }
            return clone2;
          }
        },
        canSurroundContents: function() {
          assertRangeValid(this);
          assertNodeNotReadOnly(this.startContainer);
          assertNodeNotReadOnly(this.endContainer);
          var iterator = new RangeIterator(this, true);
          var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
          iterator.detach();
          return !boundariesInvalid;
        },
        surroundContents: function(node) {
          assertValidNodeType(node, surroundNodeTypes);
          if (!this.canSurroundContents()) {
            throw new DOMException2("INVALID_STATE_ERR");
          }
          var content2 = this.extractContents();
          if (node.hasChildNodes()) {
            while (node.lastChild) {
              node.removeChild(node.lastChild);
            }
          }
          insertNodeAtPosition(node, this.startContainer, this.startOffset);
          node.appendChild(content2);
          this.selectNode(node);
        },
        cloneRange: function() {
          assertRangeValid(this);
          var range2 = new Range(getRangeDocument(this));
          var i2 = rangeProperties.length, prop;
          while (i2--) {
            prop = rangeProperties[i2];
            range2[prop] = this[prop];
          }
          return range2;
        },
        toString: function() {
          assertRangeValid(this);
          var sc = this.startContainer;
          if (sc === this.endContainer && isCharacterDataNode(sc)) {
            return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : "";
          } else {
            var textParts = [], iterator = new RangeIterator(this, true);
            iterateSubtree(iterator, function(node) {
              if (node.nodeType == 3 || node.nodeType == 4) {
                textParts.push(node.data);
              }
            });
            iterator.detach();
            return textParts.join("");
          }
        },
        compareNode: function(node) {
          assertRangeValid(this);
          var parent = node.parentNode;
          var nodeIndex = getNodeIndex2(node);
          if (!parent) {
            throw new DOMException2("NOT_FOUND_ERR");
          }
          var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);
          if (startComparison < 0) {
            return endComparison > 0 ? n_b_a : n_b;
          } else {
            return endComparison > 0 ? n_a : n_i;
          }
        },
        comparePoint: function(node, offset) {
          assertRangeValid(this);
          assertNode(node, "HIERARCHY_REQUEST_ERR");
          assertSameDocumentOrFragment(node, this.startContainer);
          if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
            return -1;
          } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
            return 1;
          }
          return 0;
        },
        createContextualFragment,
        toHtml: function() {
          return rangeToHtml(this);
        },
        intersectsNode: function(node, touchingIsIntersecting) {
          assertRangeValid(this);
          if (getRootContainer(node) != getRangeRoot(this)) {
            return false;
          }
          var parent = node.parentNode, offset = getNodeIndex2(node);
          if (!parent) {
            return true;
          }
          var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset), endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);
          return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        },
        isPointInRange: function(node, offset) {
          assertRangeValid(this);
          assertNode(node, "HIERARCHY_REQUEST_ERR");
          assertSameDocumentOrFragment(node, this.startContainer);
          return comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;
        },
        intersectsRange: function(range2) {
          return rangesIntersect(this, range2, false);
        },
        intersectsOrTouchesRange: function(range2) {
          return rangesIntersect(this, range2, true);
        },
        intersection: function(range2) {
          if (this.intersectsRange(range2)) {
            var startComparison = comparePoints(this.startContainer, this.startOffset, range2.startContainer, range2.startOffset), endComparison = comparePoints(this.endContainer, this.endOffset, range2.endContainer, range2.endOffset);
            var intersectionRange = this.cloneRange();
            if (startComparison == -1) {
              intersectionRange.setStart(range2.startContainer, range2.startOffset);
            }
            if (endComparison == 1) {
              intersectionRange.setEnd(range2.endContainer, range2.endOffset);
            }
            return intersectionRange;
          }
          return null;
        },
        union: function(range2) {
          if (this.intersectsOrTouchesRange(range2)) {
            var unionRange = this.cloneRange();
            if (comparePoints(range2.startContainer, range2.startOffset, this.startContainer, this.startOffset) == -1) {
              unionRange.setStart(range2.startContainer, range2.startOffset);
            }
            if (comparePoints(range2.endContainer, range2.endOffset, this.endContainer, this.endOffset) == 1) {
              unionRange.setEnd(range2.endContainer, range2.endOffset);
            }
            return unionRange;
          } else {
            throw new DOMException2("Ranges do not intersect");
          }
        },
        containsNode: function(node, allowPartial) {
          if (allowPartial) {
            return this.intersectsNode(node, false);
          } else {
            return this.compareNode(node) == n_i;
          }
        },
        containsNodeContents: function(node) {
          return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
        },
        containsRange: function(range2) {
          var intersection = this.intersection(range2);
          return intersection !== null && range2.equals(intersection);
        },
        containsNodeText: function(node) {
          var nodeRange = this.cloneRange();
          nodeRange.selectNode(node);
          var textNodes = nodeRange.getNodes([3]);
          if (textNodes.length > 0) {
            nodeRange.setStart(textNodes[0], 0);
            var lastTextNode = textNodes.pop();
            nodeRange.setEnd(lastTextNode, lastTextNode.length);
            return this.containsRange(nodeRange);
          } else {
            return this.containsNodeContents(node);
          }
        },
        getNodes: function(nodeTypes, filter) {
          assertRangeValid(this);
          return getNodesInRange(this, nodeTypes, filter);
        },
        getDocument: function() {
          return getRangeDocument(this);
        },
        collapseBefore: function(node) {
          this.setEndBefore(node);
          this.collapse(false);
        },
        collapseAfter: function(node) {
          this.setStartAfter(node);
          this.collapse(true);
        },
        getBookmark: function(containerNode) {
          var doc = getRangeDocument(this);
          var preSelectionRange = api2.createRange(doc);
          containerNode = containerNode || dom.getBody(doc);
          preSelectionRange.selectNodeContents(containerNode);
          var range2 = this.intersection(preSelectionRange);
          var start = 0, end = 0;
          if (range2) {
            preSelectionRange.setEnd(range2.startContainer, range2.startOffset);
            start = preSelectionRange.toString().length;
            end = start + range2.toString().length;
          }
          return {
            start,
            end,
            containerNode
          };
        },
        moveToBookmark: function(bookmark) {
          var containerNode = bookmark.containerNode;
          var charIndex = 0;
          this.setStart(containerNode, 0);
          this.collapse(true);
          var nodeStack = [containerNode], node, foundStart = false, stop = false;
          var nextCharIndex, i2, childNodes;
          while (!stop && (node = nodeStack.pop())) {
            if (node.nodeType == 3) {
              nextCharIndex = charIndex + node.length;
              if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                this.setStart(node, bookmark.start - charIndex);
                foundStart = true;
              }
              if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                this.setEnd(node, bookmark.end - charIndex);
                stop = true;
              }
              charIndex = nextCharIndex;
            } else {
              childNodes = node.childNodes;
              i2 = childNodes.length;
              while (i2--) {
                nodeStack.push(childNodes[i2]);
              }
            }
          }
        },
        getName: function() {
          return "DomRange";
        },
        equals: function(range2) {
          return Range.rangesEqual(this, range2);
        },
        isValid: function() {
          return isRangeValid(this);
        },
        inspect: function() {
          return inspect2(this);
        },
        detach: function() {
        }
      });
      function copyComparisonConstantsToObject(obj2) {
        obj2.START_TO_START = s2s;
        obj2.START_TO_END = s2e;
        obj2.END_TO_END = e2e;
        obj2.END_TO_START = e2s;
        obj2.NODE_BEFORE = n_b;
        obj2.NODE_AFTER = n_a;
        obj2.NODE_BEFORE_AND_AFTER = n_b_a;
        obj2.NODE_INSIDE = n_i;
      }
      function copyComparisonConstants(constructor) {
        copyComparisonConstantsToObject(constructor);
        copyComparisonConstantsToObject(constructor.prototype);
      }
      function createRangeContentRemover(remover, boundaryUpdater) {
        return function() {
          assertRangeValid(this);
          var sc = this.startContainer, so = this.startOffset, root2 = this.commonAncestorContainer;
          var iterator = new RangeIterator(this, true);
          var node, boundary;
          if (sc !== root2) {
            node = getClosestAncestorIn(sc, root2, true);
            boundary = getBoundaryAfterNode(node);
            sc = boundary.node;
            so = boundary.offset;
          }
          iterateSubtree(iterator, assertNodeNotReadOnly);
          iterator.reset();
          var returnValue2 = remover(iterator);
          iterator.detach();
          boundaryUpdater(this, sc, so, sc, so);
          return returnValue2;
        };
      }
      function createPrototypeRange(constructor, boundaryUpdater) {
        function createBeforeAfterNodeSetter(isBefore, isStart) {
          return function(node) {
            assertValidNodeType(node, beforeAfterNodeTypes);
            assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);
            var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
            (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
          };
        }
        function setRangeStart(range2, node, offset) {
          var ec = range2.endContainer, eo = range2.endOffset;
          if (node !== range2.startContainer || offset !== range2.startOffset) {
            if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
              ec = node;
              eo = offset;
            }
            boundaryUpdater(range2, node, offset, ec, eo);
          }
        }
        function setRangeEnd(range2, node, offset) {
          var sc = range2.startContainer, so = range2.startOffset;
          if (node !== range2.endContainer || offset !== range2.endOffset) {
            if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
              sc = node;
              so = offset;
            }
            boundaryUpdater(range2, sc, so, node, offset);
          }
        }
        var F2 = function() {
        };
        F2.prototype = api2.rangePrototype;
        constructor.prototype = new F2();
        util3.extend(constructor.prototype, {
          setStart: function(node, offset) {
            assertNoDocTypeNotationEntityAncestor(node, true);
            assertValidOffset(node, offset);
            setRangeStart(this, node, offset);
          },
          setEnd: function(node, offset) {
            assertNoDocTypeNotationEntityAncestor(node, true);
            assertValidOffset(node, offset);
            setRangeEnd(this, node, offset);
          },
          setStartAndEnd: function() {
            var args2 = arguments;
            var sc = args2[0], so = args2[1], ec = sc, eo = so;
            switch (args2.length) {
              case 3:
                eo = args2[2];
                break;
              case 4:
                ec = args2[2];
                eo = args2[3];
                break;
            }
            boundaryUpdater(this, sc, so, ec, eo);
          },
          setBoundary: function(node, offset, isStart) {
            this["set" + (isStart ? "Start" : "End")](node, offset);
          },
          setStartBefore: createBeforeAfterNodeSetter(true, true),
          setStartAfter: createBeforeAfterNodeSetter(false, true),
          setEndBefore: createBeforeAfterNodeSetter(true, false),
          setEndAfter: createBeforeAfterNodeSetter(false, false),
          collapse: function(isStart) {
            assertRangeValid(this);
            if (isStart) {
              boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
            } else {
              boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
            }
          },
          selectNodeContents: function(node) {
            assertNoDocTypeNotationEntityAncestor(node, true);
            boundaryUpdater(this, node, 0, node, getNodeLength(node));
          },
          selectNode: function(node) {
            assertNoDocTypeNotationEntityAncestor(node, false);
            assertValidNodeType(node, beforeAfterNodeTypes);
            var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
            boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
          },
          extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),
          deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),
          canSurroundContents: function() {
            assertRangeValid(this);
            assertNodeNotReadOnly(this.startContainer);
            assertNodeNotReadOnly(this.endContainer);
            var iterator = new RangeIterator(this, true);
            var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
            iterator.detach();
            return !boundariesInvalid;
          },
          splitBoundaries: function() {
            splitRangeBoundaries(this);
          },
          splitBoundariesPreservingPositions: function(positionsToPreserve) {
            splitRangeBoundaries(this, positionsToPreserve);
          },
          normalizeBoundaries: function() {
            assertRangeValid(this);
            var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;
            var mergeForward = function(node) {
              var sibling2 = node.nextSibling;
              if (sibling2 && sibling2.nodeType == node.nodeType) {
                ec = node;
                eo = node.length;
                node.appendData(sibling2.data);
                removeNode(sibling2);
              }
            };
            var mergeBackward = function(node) {
              var sibling2 = node.previousSibling;
              if (sibling2 && sibling2.nodeType == node.nodeType) {
                sc = node;
                var nodeLength = node.length;
                so = sibling2.length;
                node.insertData(0, sibling2.data);
                removeNode(sibling2);
                if (sc == ec) {
                  eo += so;
                  ec = sc;
                } else if (ec == node.parentNode) {
                  var nodeIndex = getNodeIndex2(node);
                  if (eo == nodeIndex) {
                    ec = node;
                    eo = nodeLength;
                  } else if (eo > nodeIndex) {
                    eo--;
                  }
                }
              }
            };
            var normalizeStart = true;
            var sibling;
            if (isCharacterDataNode(ec)) {
              if (eo == ec.length) {
                mergeForward(ec);
              } else if (eo == 0) {
                sibling = ec.previousSibling;
                if (sibling && sibling.nodeType == ec.nodeType) {
                  eo = sibling.length;
                  if (sc == ec) {
                    normalizeStart = false;
                  }
                  sibling.appendData(ec.data);
                  removeNode(ec);
                  ec = sibling;
                }
              }
            } else {
              if (eo > 0) {
                var endNode = ec.childNodes[eo - 1];
                if (endNode && isCharacterDataNode(endNode)) {
                  mergeForward(endNode);
                }
              }
              normalizeStart = !this.collapsed;
            }
            if (normalizeStart) {
              if (isCharacterDataNode(sc)) {
                if (so == 0) {
                  mergeBackward(sc);
                } else if (so == sc.length) {
                  sibling = sc.nextSibling;
                  if (sibling && sibling.nodeType == sc.nodeType) {
                    if (ec == sibling) {
                      ec = sc;
                      eo += sc.length;
                    }
                    sc.appendData(sibling.data);
                    removeNode(sibling);
                  }
                }
              } else {
                if (so < sc.childNodes.length) {
                  var startNode = sc.childNodes[so];
                  if (startNode && isCharacterDataNode(startNode)) {
                    mergeBackward(startNode);
                  }
                }
              }
            } else {
              sc = ec;
              so = eo;
            }
            boundaryUpdater(this, sc, so, ec, eo);
          },
          collapseToPoint: function(node, offset) {
            assertNoDocTypeNotationEntityAncestor(node, true);
            assertValidOffset(node, offset);
            this.setStartAndEnd(node, offset);
          }
        });
        copyComparisonConstants(constructor);
      }
      function updateCollapsedAndCommonAncestor(range2) {
        range2.collapsed = range2.startContainer === range2.endContainer && range2.startOffset === range2.endOffset;
        range2.commonAncestorContainer = range2.collapsed ? range2.startContainer : dom.getCommonAncestor(range2.startContainer, range2.endContainer);
      }
      function updateBoundaries(range2, startContainer, startOffset, endContainer, endOffset) {
        range2.startContainer = startContainer;
        range2.startOffset = startOffset;
        range2.endContainer = endContainer;
        range2.endOffset = endOffset;
        range2.document = dom.getDocument(startContainer);
        updateCollapsedAndCommonAncestor(range2);
      }
      function Range(doc) {
        this.startContainer = doc;
        this.startOffset = 0;
        this.endContainer = doc;
        this.endOffset = 0;
        this.document = doc;
        updateCollapsedAndCommonAncestor(this);
      }
      createPrototypeRange(Range, updateBoundaries);
      util3.extend(Range, {
        rangeProperties,
        RangeIterator,
        copyComparisonConstants,
        createPrototypeRange,
        inspect: inspect2,
        toHtml: rangeToHtml,
        getRangeDocument,
        rangesEqual: function(r1, r2) {
          return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;
        }
      });
      api2.DomRange = Range;
    });
    api.createCoreModule("WrappedRange", ["DomRange"], function(api2, module3) {
      var WrappedRange, WrappedTextRange;
      var dom = api2.dom;
      var util3 = api2.util;
      var DomPosition = dom.DomPosition;
      var DomRange = api2.DomRange;
      var getBody2 = dom.getBody;
      var getContentDocument = dom.getContentDocument;
      var isCharacterDataNode = dom.isCharacterDataNode;
      if (api2.features.implementsDomRange) {
        (function() {
          var rangeProto;
          var rangeProperties = DomRange.rangeProperties;
          function updateRangeProperties(range3) {
            var i2 = rangeProperties.length, prop;
            while (i2--) {
              prop = rangeProperties[i2];
              range3[prop] = range3.nativeRange[prop];
            }
            range3.collapsed = range3.startContainer === range3.endContainer && range3.startOffset === range3.endOffset;
          }
          function updateNativeRange(range3, startContainer, startOffset, endContainer, endOffset) {
            var startMoved = range3.startContainer !== startContainer || range3.startOffset != startOffset;
            var endMoved = range3.endContainer !== endContainer || range3.endOffset != endOffset;
            var nativeRangeDifferent = !range3.equals(range3.nativeRange);
            if (startMoved || endMoved || nativeRangeDifferent) {
              range3.setEnd(endContainer, endOffset);
              range3.setStart(startContainer, startOffset);
            }
          }
          var createBeforeAfterNodeSetter;
          WrappedRange = function(range3) {
            if (!range3) {
              throw module3.createError("WrappedRange: Range must be specified");
            }
            this.nativeRange = range3;
            updateRangeProperties(this);
          };
          DomRange.createPrototypeRange(WrappedRange, updateNativeRange);
          rangeProto = WrappedRange.prototype;
          rangeProto.selectNode = function(node) {
            this.nativeRange.selectNode(node);
            updateRangeProperties(this);
          };
          rangeProto.cloneContents = function() {
            return this.nativeRange.cloneContents();
          };
          rangeProto.surroundContents = function(node) {
            this.nativeRange.surroundContents(node);
            updateRangeProperties(this);
          };
          rangeProto.collapse = function(isStart) {
            this.nativeRange.collapse(isStart);
            updateRangeProperties(this);
          };
          rangeProto.cloneRange = function() {
            return new WrappedRange(this.nativeRange.cloneRange());
          };
          rangeProto.refresh = function() {
            updateRangeProperties(this);
          };
          rangeProto.toString = function() {
            return this.nativeRange.toString();
          };
          var testTextNode = document.createTextNode("test");
          getBody2(document).appendChild(testTextNode);
          var range2 = document.createRange();
          range2.setStart(testTextNode, 0);
          range2.setEnd(testTextNode, 0);
          try {
            range2.setStart(testTextNode, 1);
            rangeProto.setStart = function(node, offset) {
              this.nativeRange.setStart(node, offset);
              updateRangeProperties(this);
            };
            rangeProto.setEnd = function(node, offset) {
              this.nativeRange.setEnd(node, offset);
              updateRangeProperties(this);
            };
            createBeforeAfterNodeSetter = function(name) {
              return function(node) {
                this.nativeRange[name](node);
                updateRangeProperties(this);
              };
            };
          } catch (ex) {
            rangeProto.setStart = function(node, offset) {
              try {
                this.nativeRange.setStart(node, offset);
              } catch (ex2) {
                this.nativeRange.setEnd(node, offset);
                this.nativeRange.setStart(node, offset);
              }
              updateRangeProperties(this);
            };
            rangeProto.setEnd = function(node, offset) {
              try {
                this.nativeRange.setEnd(node, offset);
              } catch (ex2) {
                this.nativeRange.setStart(node, offset);
                this.nativeRange.setEnd(node, offset);
              }
              updateRangeProperties(this);
            };
            createBeforeAfterNodeSetter = function(name, oppositeName) {
              return function(node) {
                try {
                  this.nativeRange[name](node);
                } catch (ex2) {
                  this.nativeRange[oppositeName](node);
                  this.nativeRange[name](node);
                }
                updateRangeProperties(this);
              };
            };
          }
          rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");
          rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");
          rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");
          rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");
          rangeProto.selectNodeContents = function(node) {
            this.setStartAndEnd(node, 0, dom.getNodeLength(node));
          };
          range2.selectNodeContents(testTextNode);
          range2.setEnd(testTextNode, 3);
          var range22 = document.createRange();
          range22.selectNodeContents(testTextNode);
          range22.setEnd(testTextNode, 4);
          range22.setStart(testTextNode, 2);
          if (range2.compareBoundaryPoints(range2.START_TO_END, range22) == -1 && range2.compareBoundaryPoints(range2.END_TO_START, range22) == 1) {
            rangeProto.compareBoundaryPoints = function(type2, range3) {
              range3 = range3.nativeRange || range3;
              if (type2 == range3.START_TO_END) {
                type2 = range3.END_TO_START;
              } else if (type2 == range3.END_TO_START) {
                type2 = range3.START_TO_END;
              }
              return this.nativeRange.compareBoundaryPoints(type2, range3);
            };
          } else {
            rangeProto.compareBoundaryPoints = function(type2, range3) {
              return this.nativeRange.compareBoundaryPoints(type2, range3.nativeRange || range3);
            };
          }
          var el2 = document.createElement("div");
          el2.innerHTML = "123";
          var textNode2 = el2.firstChild;
          var body2 = getBody2(document);
          body2.appendChild(el2);
          range2.setStart(textNode2, 1);
          range2.setEnd(textNode2, 2);
          range2.deleteContents();
          if (textNode2.data == "13") {
            rangeProto.deleteContents = function() {
              this.nativeRange.deleteContents();
              updateRangeProperties(this);
            };
            rangeProto.extractContents = function() {
              var frag = this.nativeRange.extractContents();
              updateRangeProperties(this);
              return frag;
            };
          }
          body2.removeChild(el2);
          body2 = null;
          if (util3.isHostMethod(range2, "createContextualFragment")) {
            rangeProto.createContextualFragment = function(fragmentStr) {
              return this.nativeRange.createContextualFragment(fragmentStr);
            };
          }
          getBody2(document).removeChild(testTextNode);
          rangeProto.getName = function() {
            return "WrappedRange";
          };
          api2.WrappedRange = WrappedRange;
          api2.createNativeRange = function(doc) {
            doc = getContentDocument(doc, module3, "createNativeRange");
            return doc.createRange();
          };
        })();
      }
      if (api2.features.implementsTextRange) {
        var getTextRangeContainerElement = function(textRange) {
          var parentEl2 = textRange.parentElement();
          var range2 = textRange.duplicate();
          range2.collapse(true);
          var startEl = range2.parentElement();
          range2 = textRange.duplicate();
          range2.collapse(false);
          var endEl = range2.parentElement();
          var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);
          return startEndContainer == parentEl2 ? startEndContainer : dom.getCommonAncestor(parentEl2, startEndContainer);
        };
        var textRangeIsCollapsed = function(textRange) {
          return textRange.compareEndPoints("StartToEnd", textRange) == 0;
        };
        var getTextRangeBoundaryPosition = function(textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
          var workingRange = textRange.duplicate();
          workingRange.collapse(isStart);
          var containerElement = workingRange.parentElement();
          if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
            containerElement = wholeRangeContainerElement;
          }
          if (!containerElement.canHaveHTML) {
            var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
            return {
              boundaryPosition: pos,
              nodeInfo: {
                nodeIndex: pos.offset,
                containerElement: pos.node
              }
            };
          }
          var workingNode = dom.getDocument(containerElement).createElement("span");
          if (workingNode.parentNode) {
            dom.removeNode(workingNode);
          }
          var comparison, workingComparisonType = isStart ? "StartToStart" : "StartToEnd";
          var previousNode, nextNode, boundaryPosition, boundaryNode;
          var start = startInfo && startInfo.containerElement == containerElement ? startInfo.nodeIndex : 0;
          var childNodeCount = containerElement.childNodes.length;
          var end = childNodeCount;
          var nodeIndex = end;
          while (true) {
            if (nodeIndex == childNodeCount) {
              containerElement.appendChild(workingNode);
            } else {
              containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
            }
            workingRange.moveToElementText(workingNode);
            comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
            if (comparison == 0 || start == end) {
              break;
            } else if (comparison == -1) {
              if (end == start + 1) {
                break;
              } else {
                start = nodeIndex;
              }
            } else {
              end = end == start + 1 ? start : nodeIndex;
            }
            nodeIndex = Math.floor((start + end) / 2);
            containerElement.removeChild(workingNode);
          }
          boundaryNode = workingNode.nextSibling;
          if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
            workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);
            var offset;
            if (/[\r\n]/.test(boundaryNode.data)) {
              var tempRange = workingRange.duplicate();
              var rangeLength = tempRange.text.replace(/\r\n/g, "\r").length;
              offset = tempRange.moveStart("character", rangeLength);
              while ((comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {
                offset++;
                tempRange.moveStart("character", 1);
              }
            } else {
              offset = workingRange.text.length;
            }
            boundaryPosition = new DomPosition(boundaryNode, offset);
          } else {
            previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
            nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
            if (nextNode && isCharacterDataNode(nextNode)) {
              boundaryPosition = new DomPosition(nextNode, 0);
            } else if (previousNode && isCharacterDataNode(previousNode)) {
              boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
            } else {
              boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
            }
          }
          dom.removeNode(workingNode);
          return {
            boundaryPosition,
            nodeInfo: {
              nodeIndex,
              containerElement
            }
          };
        };
        var createBoundaryTextRange = function(boundaryPosition, isStart) {
          var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
          var doc = dom.getDocument(boundaryPosition.node);
          var workingNode, childNodes, workingRange = getBody2(doc).createTextRange();
          var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);
          if (nodeIsDataNode) {
            boundaryNode = boundaryPosition.node;
            boundaryParent = boundaryNode.parentNode;
          } else {
            childNodes = boundaryPosition.node.childNodes;
            boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;
            boundaryParent = boundaryPosition.node;
          }
          workingNode = doc.createElement("span");
          workingNode.innerHTML = "&#feff;";
          if (boundaryNode) {
            boundaryParent.insertBefore(workingNode, boundaryNode);
          } else {
            boundaryParent.appendChild(workingNode);
          }
          workingRange.moveToElementText(workingNode);
          workingRange.collapse(!isStart);
          boundaryParent.removeChild(workingNode);
          if (nodeIsDataNode) {
            workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);
          }
          return workingRange;
        };
        WrappedTextRange = function(textRange) {
          this.textRange = textRange;
          this.refresh();
        };
        WrappedTextRange.prototype = new DomRange(document);
        WrappedTextRange.prototype.refresh = function() {
          var start, end, startBoundary;
          var rangeContainerElement = getTextRangeContainerElement(this.textRange);
          if (textRangeIsCollapsed(this.textRange)) {
            end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true).boundaryPosition;
          } else {
            startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
            start = startBoundary.boundaryPosition;
            end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false, startBoundary.nodeInfo).boundaryPosition;
          }
          this.setStart(start.node, start.offset);
          this.setEnd(end.node, end.offset);
        };
        WrappedTextRange.prototype.getName = function() {
          return "WrappedTextRange";
        };
        DomRange.copyComparisonConstants(WrappedTextRange);
        var rangeToTextRange = function(range2) {
          if (range2.collapsed) {
            return createBoundaryTextRange(new DomPosition(range2.startContainer, range2.startOffset), true);
          } else {
            var startRange = createBoundaryTextRange(new DomPosition(range2.startContainer, range2.startOffset), true);
            var endRange = createBoundaryTextRange(new DomPosition(range2.endContainer, range2.endOffset), false);
            var textRange = getBody2(DomRange.getRangeDocument(range2)).createTextRange();
            textRange.setEndPoint("StartToStart", startRange);
            textRange.setEndPoint("EndToEnd", endRange);
            return textRange;
          }
        };
        WrappedTextRange.rangeToTextRange = rangeToTextRange;
        WrappedTextRange.prototype.toTextRange = function() {
          return rangeToTextRange(this);
        };
        api2.WrappedTextRange = WrappedTextRange;
        if (!api2.features.implementsDomRange || api2.config.preferTextRange) {
          var globalObj = function(f) {
            return f("return this;")();
          }(Function);
          if (typeof globalObj.Range == "undefined") {
            globalObj.Range = WrappedTextRange;
          }
          api2.createNativeRange = function(doc) {
            doc = getContentDocument(doc, module3, "createNativeRange");
            return getBody2(doc).createTextRange();
          };
          api2.WrappedRange = WrappedTextRange;
        }
      }
      api2.createRange = function(doc) {
        doc = getContentDocument(doc, module3, "createRange");
        return new api2.WrappedRange(api2.createNativeRange(doc));
      };
      api2.createRangyRange = function(doc) {
        doc = getContentDocument(doc, module3, "createRangyRange");
        return new DomRange(doc);
      };
      util3.createAliasForDeprecatedMethod(api2, "createIframeRange", "createRange");
      util3.createAliasForDeprecatedMethod(api2, "createIframeRangyRange", "createRangyRange");
      api2.addShimListener(function(win) {
        var doc = win.document;
        if (typeof doc.createRange == "undefined") {
          doc.createRange = function() {
            return api2.createRange(doc);
          };
        }
        doc = win = null;
      });
    });
    api.createCoreModule("WrappedSelection", ["DomRange", "WrappedRange"], function(api2, module3) {
      api2.config.checkSelectionRanges = true;
      var BOOLEAN = "boolean";
      var NUMBER = "number";
      var dom = api2.dom;
      var util3 = api2.util;
      var isHostMethod2 = util3.isHostMethod;
      var DomRange = api2.DomRange;
      var WrappedRange = api2.WrappedRange;
      var DOMException2 = api2.DOMException;
      var DomPosition = dom.DomPosition;
      var getNativeSelection;
      var selectionIsCollapsed;
      var features = api2.features;
      var CONTROL = "Control";
      var getDocument = dom.getDocument;
      var getBody2 = dom.getBody;
      var rangesEqual = DomRange.rangesEqual;
      function isDirectionBackward(dir) {
        return typeof dir == "string" ? /^backward(s)?$/i.test(dir) : !!dir;
      }
      function getWindow(win, methodName) {
        if (!win) {
          return window;
        } else if (dom.isWindow(win)) {
          return win;
        } else if (win instanceof WrappedSelection) {
          return win.win;
        } else {
          var doc = dom.getContentDocument(win, module3, methodName);
          return dom.getWindow(doc);
        }
      }
      function getWinSelection(winParam) {
        return getWindow(winParam, "getWinSelection").getSelection();
      }
      function getDocSelection(winParam) {
        return getWindow(winParam, "getDocSelection").document.selection;
      }
      function winSelectionIsBackward(sel) {
        var backward = false;
        if (sel.anchorNode) {
          backward = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;
        }
        return backward;
      }
      var implementsWinGetSelection = isHostMethod2(window, "getSelection"), implementsDocSelection = util3.isHostObject(document, "selection");
      features.implementsWinGetSelection = implementsWinGetSelection;
      features.implementsDocSelection = implementsDocSelection;
      var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api2.config.preferTextRange);
      if (useDocumentSelection) {
        getNativeSelection = getDocSelection;
        api2.isSelectionValid = function(winParam) {
          var doc = getWindow(winParam, "isSelectionValid").document, nativeSel = doc.selection;
          return nativeSel.type != "None" || getDocument(nativeSel.createRange().parentElement()) == doc;
        };
      } else if (implementsWinGetSelection) {
        getNativeSelection = getWinSelection;
        api2.isSelectionValid = function() {
          return true;
        };
      } else {
        module3.fail("Neither document.selection or window.getSelection() detected.");
        return false;
      }
      api2.getNativeSelection = getNativeSelection;
      var testSelection = getNativeSelection();
      if (!testSelection) {
        module3.fail("Native selection was null (possibly issue 138?)");
        return false;
      }
      var testRange = api2.createNativeRange(document);
      var body2 = getBody2(document);
      var selectionHasAnchorAndFocus = util3.areHostProperties(testSelection, ["anchorNode", "focusNode", "anchorOffset", "focusOffset"]);
      features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;
      var selectionHasExtend = isHostMethod2(testSelection, "extend");
      features.selectionHasExtend = selectionHasExtend;
      var selectionHasRangeCount = typeof testSelection.rangeCount == NUMBER;
      features.selectionHasRangeCount = selectionHasRangeCount;
      var selectionSupportsMultipleRanges = false;
      var collapsedNonEditableSelectionsSupported = true;
      var addRangeBackwardToNative = selectionHasExtend ? function(nativeSelection, range2) {
        var doc = DomRange.getRangeDocument(range2);
        var endRange = api2.createRange(doc);
        endRange.collapseToPoint(range2.endContainer, range2.endOffset);
        nativeSelection.addRange(getNativeRange(endRange));
        nativeSelection.extend(range2.startContainer, range2.startOffset);
      } : null;
      if (util3.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) && typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {
        (function() {
          var sel = window.getSelection();
          if (sel) {
            var originalSelectionRangeCount = sel.rangeCount;
            var selectionHasMultipleRanges = originalSelectionRangeCount > 1;
            var originalSelectionRanges = [];
            var originalSelectionBackward = winSelectionIsBackward(sel);
            for (var i2 = 0; i2 < originalSelectionRangeCount; ++i2) {
              originalSelectionRanges[i2] = sel.getRangeAt(i2);
            }
            var testEl = dom.createTestElement(document, "", false);
            var textNode2 = testEl.appendChild(document.createTextNode("\xA0\xA0\xA0"));
            var r1 = document.createRange();
            r1.setStart(textNode2, 1);
            r1.collapse(true);
            sel.removeAllRanges();
            sel.addRange(r1);
            collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;
            sel.removeAllRanges();
            if (!selectionHasMultipleRanges) {
              var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
              if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                selectionSupportsMultipleRanges = false;
              } else {
                var r2 = r1.cloneRange();
                r1.setStart(textNode2, 0);
                r2.setEnd(textNode2, 3);
                r2.setStart(textNode2, 2);
                sel.addRange(r1);
                sel.addRange(r2);
                selectionSupportsMultipleRanges = sel.rangeCount == 2;
              }
            }
            dom.removeNode(testEl);
            sel.removeAllRanges();
            for (i2 = 0; i2 < originalSelectionRangeCount; ++i2) {
              if (i2 == 0 && originalSelectionBackward) {
                if (addRangeBackwardToNative) {
                  addRangeBackwardToNative(sel, originalSelectionRanges[i2]);
                } else {
                  api2.warn("Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend");
                  sel.addRange(originalSelectionRanges[i2]);
                }
              } else {
                sel.addRange(originalSelectionRanges[i2]);
              }
            }
          }
        })();
      }
      features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
      features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;
      var implementsControlRange = false, testControlRange;
      if (body2 && isHostMethod2(body2, "createControlRange")) {
        testControlRange = body2.createControlRange();
        if (util3.areHostProperties(testControlRange, ["item", "add"])) {
          implementsControlRange = true;
        }
      }
      features.implementsControlRange = implementsControlRange;
      if (selectionHasAnchorAndFocus) {
        selectionIsCollapsed = function(sel) {
          return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
        };
      } else {
        selectionIsCollapsed = function(sel) {
          return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
        };
      }
      function updateAnchorAndFocusFromRange(sel, range2, backward) {
        var anchorPrefix = backward ? "end" : "start", focusPrefix = backward ? "start" : "end";
        sel.anchorNode = range2[anchorPrefix + "Container"];
        sel.anchorOffset = range2[anchorPrefix + "Offset"];
        sel.focusNode = range2[focusPrefix + "Container"];
        sel.focusOffset = range2[focusPrefix + "Offset"];
      }
      function updateAnchorAndFocusFromNativeSelection(sel) {
        var nativeSel = sel.nativeSelection;
        sel.anchorNode = nativeSel.anchorNode;
        sel.anchorOffset = nativeSel.anchorOffset;
        sel.focusNode = nativeSel.focusNode;
        sel.focusOffset = nativeSel.focusOffset;
      }
      function updateEmptySelection(sel) {
        sel.anchorNode = sel.focusNode = null;
        sel.anchorOffset = sel.focusOffset = 0;
        sel.rangeCount = 0;
        sel.isCollapsed = true;
        sel._ranges.length = 0;
      }
      function getNativeRange(range2) {
        var nativeRange;
        if (range2 instanceof DomRange) {
          nativeRange = api2.createNativeRange(range2.getDocument());
          nativeRange.setEnd(range2.endContainer, range2.endOffset);
          nativeRange.setStart(range2.startContainer, range2.startOffset);
        } else if (range2 instanceof WrappedRange) {
          nativeRange = range2.nativeRange;
        } else if (features.implementsDomRange && range2 instanceof dom.getWindow(range2.startContainer).Range) {
          nativeRange = range2;
        }
        return nativeRange;
      }
      function rangeContainsSingleElement(rangeNodes) {
        if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
          return false;
        }
        for (var i2 = 1, len = rangeNodes.length; i2 < len; ++i2) {
          if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i2])) {
            return false;
          }
        }
        return true;
      }
      function getSingleElementFromRange(range2) {
        var nodes = range2.getNodes();
        if (!rangeContainsSingleElement(nodes)) {
          throw module3.createError("getSingleElementFromRange: range " + range2.inspect() + " did not consist of a single element");
        }
        return nodes[0];
      }
      function isTextRange2(range2) {
        return !!range2 && typeof range2.text != "undefined";
      }
      function updateFromTextRange(sel, range2) {
        var wrappedRange = new WrappedRange(range2);
        sel._ranges = [wrappedRange];
        updateAnchorAndFocusFromRange(sel, wrappedRange, false);
        sel.rangeCount = 1;
        sel.isCollapsed = wrappedRange.collapsed;
      }
      function updateControlSelection(sel) {
        sel._ranges.length = 0;
        if (sel.docSelection.type == "None") {
          updateEmptySelection(sel);
        } else {
          var controlRange = sel.docSelection.createRange();
          if (isTextRange2(controlRange)) {
            updateFromTextRange(sel, controlRange);
          } else {
            sel.rangeCount = controlRange.length;
            var range2, doc = getDocument(controlRange.item(0));
            for (var i2 = 0; i2 < sel.rangeCount; ++i2) {
              range2 = api2.createRange(doc);
              range2.selectNode(controlRange.item(i2));
              sel._ranges.push(range2);
            }
            sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
            updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
          }
        }
      }
      function addRangeToControlSelection(sel, range2) {
        var controlRange = sel.docSelection.createRange();
        var rangeElement = getSingleElementFromRange(range2);
        var doc = getDocument(controlRange.item(0));
        var newControlRange = getBody2(doc).createControlRange();
        for (var i2 = 0, len = controlRange.length; i2 < len; ++i2) {
          newControlRange.add(controlRange.item(i2));
        }
        try {
          newControlRange.add(rangeElement);
        } catch (ex) {
          throw module3.createError("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");
        }
        newControlRange.select();
        updateControlSelection(sel);
      }
      var getSelectionRangeAt;
      if (isHostMethod2(testSelection, "getRangeAt")) {
        getSelectionRangeAt = function(sel, index2) {
          try {
            return sel.getRangeAt(index2);
          } catch (ex) {
            return null;
          }
        };
      } else if (selectionHasAnchorAndFocus) {
        getSelectionRangeAt = function(sel) {
          var doc = getDocument(sel.anchorNode);
          var range2 = api2.createRange(doc);
          range2.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);
          if (range2.collapsed !== this.isCollapsed) {
            range2.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
          }
          return range2;
        };
      }
      function WrappedSelection(selection, docSelection, win) {
        this.nativeSelection = selection;
        this.docSelection = docSelection;
        this._ranges = [];
        this.win = win;
        this.refresh();
      }
      WrappedSelection.prototype = api2.selectionPrototype;
      function deleteProperties(sel) {
        sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
        sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
        sel.detached = true;
      }
      var cachedRangySelections = [];
      function actOnCachedSelection(win, action) {
        var i2 = cachedRangySelections.length, cached, sel;
        while (i2--) {
          cached = cachedRangySelections[i2];
          sel = cached.selection;
          if (action == "deleteAll") {
            deleteProperties(sel);
          } else if (cached.win == win) {
            if (action == "delete") {
              cachedRangySelections.splice(i2, 1);
              return true;
            } else {
              return sel;
            }
          }
        }
        if (action == "deleteAll") {
          cachedRangySelections.length = 0;
        }
        return null;
      }
      var getSelection = function(win) {
        if (win && win instanceof WrappedSelection) {
          win.refresh();
          return win;
        }
        win = getWindow(win, "getNativeSelection");
        var sel = actOnCachedSelection(win);
        var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
        if (sel) {
          sel.nativeSelection = nativeSel;
          sel.docSelection = docSel;
          sel.refresh();
        } else {
          sel = new WrappedSelection(nativeSel, docSel, win);
          cachedRangySelections.push({ win, selection: sel });
        }
        return sel;
      };
      api2.getSelection = getSelection;
      util3.createAliasForDeprecatedMethod(api2, "getIframeSelection", "getSelection");
      var selProto = WrappedSelection.prototype;
      function createControlSelection(sel, ranges) {
        var doc = getDocument(ranges[0].startContainer);
        var controlRange = getBody2(doc).createControlRange();
        for (var i2 = 0, el2, len = ranges.length; i2 < len; ++i2) {
          el2 = getSingleElementFromRange(ranges[i2]);
          try {
            controlRange.add(el2);
          } catch (ex) {
            throw module3.createError("setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)");
          }
        }
        controlRange.select();
        updateControlSelection(sel);
      }
      if (!useDocumentSelection && selectionHasAnchorAndFocus && util3.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {
        selProto.removeAllRanges = function() {
          this.nativeSelection.removeAllRanges();
          updateEmptySelection(this);
        };
        var addRangeBackward = function(sel, range2) {
          addRangeBackwardToNative(sel.nativeSelection, range2);
          sel.refresh();
        };
        if (selectionHasRangeCount) {
          selProto.addRange = function(range2, direction) {
            if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
              addRangeToControlSelection(this, range2);
            } else {
              if (isDirectionBackward(direction) && selectionHasExtend) {
                addRangeBackward(this, range2);
              } else {
                var previousRangeCount;
                if (selectionSupportsMultipleRanges) {
                  previousRangeCount = this.rangeCount;
                } else {
                  this.removeAllRanges();
                  previousRangeCount = 0;
                }
                var clonedNativeRange = getNativeRange(range2).cloneRange();
                try {
                  this.nativeSelection.addRange(clonedNativeRange);
                } catch (ex) {
                }
                this.rangeCount = this.nativeSelection.rangeCount;
                if (this.rangeCount == previousRangeCount + 1) {
                  if (api2.config.checkSelectionRanges) {
                    var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                    if (nativeRange && !rangesEqual(nativeRange, range2)) {
                      range2 = new WrappedRange(nativeRange);
                    }
                  }
                  this._ranges[this.rangeCount - 1] = range2;
                  updateAnchorAndFocusFromRange(this, range2, selectionIsBackward(this.nativeSelection));
                  this.isCollapsed = selectionIsCollapsed(this);
                } else {
                  this.refresh();
                }
              }
            }
          };
        } else {
          selProto.addRange = function(range2, direction) {
            if (isDirectionBackward(direction) && selectionHasExtend) {
              addRangeBackward(this, range2);
            } else {
              this.nativeSelection.addRange(getNativeRange(range2));
              this.refresh();
            }
          };
        }
        selProto.setRanges = function(ranges) {
          if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
            createControlSelection(this, ranges);
          } else {
            this.removeAllRanges();
            for (var i2 = 0, len = ranges.length; i2 < len; ++i2) {
              this.addRange(ranges[i2]);
            }
          }
        };
      } else if (isHostMethod2(testSelection, "empty") && isHostMethod2(testRange, "select") && implementsControlRange && useDocumentSelection) {
        selProto.removeAllRanges = function() {
          try {
            this.docSelection.empty();
            if (this.docSelection.type != "None") {
              var doc;
              if (this.anchorNode) {
                doc = getDocument(this.anchorNode);
              } else if (this.docSelection.type == CONTROL) {
                var controlRange = this.docSelection.createRange();
                if (controlRange.length) {
                  doc = getDocument(controlRange.item(0));
                }
              }
              if (doc) {
                var textRange = getBody2(doc).createTextRange();
                textRange.select();
                this.docSelection.empty();
              }
            }
          } catch (ex) {
          }
          updateEmptySelection(this);
        };
        selProto.addRange = function(range2) {
          if (this.docSelection.type == CONTROL) {
            addRangeToControlSelection(this, range2);
          } else {
            api2.WrappedTextRange.rangeToTextRange(range2).select();
            this._ranges[0] = range2;
            this.rangeCount = 1;
            this.isCollapsed = this._ranges[0].collapsed;
            updateAnchorAndFocusFromRange(this, range2, false);
          }
        };
        selProto.setRanges = function(ranges) {
          this.removeAllRanges();
          var rangeCount = ranges.length;
          if (rangeCount > 1) {
            createControlSelection(this, ranges);
          } else if (rangeCount) {
            this.addRange(ranges[0]);
          }
        };
      } else {
        module3.fail("No means of selecting a Range or TextRange was found");
        return false;
      }
      selProto.getRangeAt = function(index2) {
        if (index2 < 0 || index2 >= this.rangeCount) {
          throw new DOMException2("INDEX_SIZE_ERR");
        } else {
          return this._ranges[index2].cloneRange();
        }
      };
      var refreshSelection;
      if (useDocumentSelection) {
        refreshSelection = function(sel) {
          var range2;
          if (api2.isSelectionValid(sel.win)) {
            range2 = sel.docSelection.createRange();
          } else {
            range2 = getBody2(sel.win.document).createTextRange();
            range2.collapse(true);
          }
          if (sel.docSelection.type == CONTROL) {
            updateControlSelection(sel);
          } else if (isTextRange2(range2)) {
            updateFromTextRange(sel, range2);
          } else {
            updateEmptySelection(sel);
          }
        };
      } else if (isHostMethod2(testSelection, "getRangeAt") && typeof testSelection.rangeCount == NUMBER) {
        refreshSelection = function(sel) {
          if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
            updateControlSelection(sel);
          } else {
            sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
            if (sel.rangeCount) {
              for (var i2 = 0, len = sel.rangeCount; i2 < len; ++i2) {
                sel._ranges[i2] = new api2.WrappedRange(sel.nativeSelection.getRangeAt(i2));
              }
              updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
              sel.isCollapsed = selectionIsCollapsed(sel);
            } else {
              updateEmptySelection(sel);
            }
          }
        };
      } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
        refreshSelection = function(sel) {
          var range2, nativeSel = sel.nativeSelection;
          if (nativeSel.anchorNode) {
            range2 = getSelectionRangeAt(nativeSel, 0);
            sel._ranges = [range2];
            sel.rangeCount = 1;
            updateAnchorAndFocusFromNativeSelection(sel);
            sel.isCollapsed = selectionIsCollapsed(sel);
          } else {
            updateEmptySelection(sel);
          }
        };
      } else {
        module3.fail("No means of obtaining a Range or TextRange from the user's selection was found");
        return false;
      }
      selProto.refresh = function(checkForChanges) {
        var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
        var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;
        refreshSelection(this);
        if (checkForChanges) {
          var i2 = oldRanges.length;
          if (i2 != this._ranges.length) {
            return true;
          }
          if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
            return true;
          }
          while (i2--) {
            if (!rangesEqual(oldRanges[i2], this._ranges[i2])) {
              return true;
            }
          }
          return false;
        }
      };
      var removeRangeManually = function(sel, range2) {
        var ranges = sel.getAllRanges();
        sel.removeAllRanges();
        for (var i2 = 0, len = ranges.length; i2 < len; ++i2) {
          if (!rangesEqual(range2, ranges[i2])) {
            sel.addRange(ranges[i2]);
          }
        }
        if (!sel.rangeCount) {
          updateEmptySelection(sel);
        }
      };
      if (implementsControlRange && implementsDocSelection) {
        selProto.removeRange = function(range2) {
          if (this.docSelection.type == CONTROL) {
            var controlRange = this.docSelection.createRange();
            var rangeElement = getSingleElementFromRange(range2);
            var doc = getDocument(controlRange.item(0));
            var newControlRange = getBody2(doc).createControlRange();
            var el2, removed = false;
            for (var i2 = 0, len = controlRange.length; i2 < len; ++i2) {
              el2 = controlRange.item(i2);
              if (el2 !== rangeElement || removed) {
                newControlRange.add(controlRange.item(i2));
              } else {
                removed = true;
              }
            }
            newControlRange.select();
            updateControlSelection(this);
          } else {
            removeRangeManually(this, range2);
          }
        };
      } else {
        selProto.removeRange = function(range2) {
          removeRangeManually(this, range2);
        };
      }
      var selectionIsBackward;
      if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
        selectionIsBackward = winSelectionIsBackward;
        selProto.isBackward = function() {
          return selectionIsBackward(this);
        };
      } else {
        selectionIsBackward = selProto.isBackward = function() {
          return false;
        };
      }
      selProto.isBackwards = selProto.isBackward;
      selProto.toString = function() {
        var rangeTexts = [];
        for (var i2 = 0, len = this.rangeCount; i2 < len; ++i2) {
          rangeTexts[i2] = "" + this._ranges[i2];
        }
        return rangeTexts.join("");
      };
      function assertNodeInSameDocument(sel, node) {
        if (sel.win.document != getDocument(node)) {
          throw new DOMException2("WRONG_DOCUMENT_ERR");
        }
      }
      selProto.collapse = function(node, offset) {
        assertNodeInSameDocument(this, node);
        var range2 = api2.createRange(node);
        range2.collapseToPoint(node, offset);
        this.setSingleRange(range2);
        this.isCollapsed = true;
      };
      selProto.collapseToStart = function() {
        if (this.rangeCount) {
          var range2 = this._ranges[0];
          this.collapse(range2.startContainer, range2.startOffset);
        } else {
          throw new DOMException2("INVALID_STATE_ERR");
        }
      };
      selProto.collapseToEnd = function() {
        if (this.rangeCount) {
          var range2 = this._ranges[this.rangeCount - 1];
          this.collapse(range2.endContainer, range2.endOffset);
        } else {
          throw new DOMException2("INVALID_STATE_ERR");
        }
      };
      selProto.selectAllChildren = function(node) {
        assertNodeInSameDocument(this, node);
        var range2 = api2.createRange(node);
        range2.selectNodeContents(node);
        this.setSingleRange(range2);
      };
      selProto.deleteFromDocument = function() {
        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
          var controlRange = this.docSelection.createRange();
          var element2;
          while (controlRange.length) {
            element2 = controlRange.item(0);
            controlRange.remove(element2);
            dom.removeNode(element2);
          }
          this.refresh();
        } else if (this.rangeCount) {
          var ranges = this.getAllRanges();
          if (ranges.length) {
            this.removeAllRanges();
            for (var i2 = 0, len = ranges.length; i2 < len; ++i2) {
              ranges[i2].deleteContents();
            }
            this.addRange(ranges[len - 1]);
          }
        }
      };
      selProto.eachRange = function(func, returnValue2) {
        for (var i2 = 0, len = this._ranges.length; i2 < len; ++i2) {
          if (func(this.getRangeAt(i2))) {
            return returnValue2;
          }
        }
      };
      selProto.getAllRanges = function() {
        var ranges = [];
        this.eachRange(function(range2) {
          ranges.push(range2);
        });
        return ranges;
      };
      selProto.setSingleRange = function(range2, direction) {
        this.removeAllRanges();
        this.addRange(range2, direction);
      };
      selProto.callMethodOnEachRange = function(methodName, params) {
        var results2 = [];
        this.eachRange(function(range2) {
          results2.push(range2[methodName].apply(range2, params || []));
        });
        return results2;
      };
      function createStartOrEndSetter(isStart) {
        return function(node, offset) {
          var range2;
          if (this.rangeCount) {
            range2 = this.getRangeAt(0);
            range2["set" + (isStart ? "Start" : "End")](node, offset);
          } else {
            range2 = api2.createRange(this.win.document);
            range2.setStartAndEnd(node, offset);
          }
          this.setSingleRange(range2, this.isBackward());
        };
      }
      selProto.setStart = createStartOrEndSetter(true);
      selProto.setEnd = createStartOrEndSetter(false);
      api2.rangePrototype.select = function(direction) {
        getSelection(this.getDocument()).setSingleRange(this, direction);
      };
      selProto.changeEachRange = function(func) {
        var ranges = [];
        var backward = this.isBackward();
        this.eachRange(function(range2) {
          func(range2);
          ranges.push(range2);
        });
        this.removeAllRanges();
        if (backward && ranges.length == 1) {
          this.addRange(ranges[0], "backward");
        } else {
          this.setRanges(ranges);
        }
      };
      selProto.containsNode = function(node, allowPartial) {
        return this.eachRange(function(range2) {
          return range2.containsNode(node, allowPartial);
        }, true) || false;
      };
      selProto.getBookmark = function(containerNode) {
        return {
          backward: this.isBackward(),
          rangeBookmarks: this.callMethodOnEachRange("getBookmark", [containerNode])
        };
      };
      selProto.moveToBookmark = function(bookmark) {
        var selRanges = [];
        for (var i2 = 0, rangeBookmark, range2; rangeBookmark = bookmark.rangeBookmarks[i2++]; ) {
          range2 = api2.createRange(this.win);
          range2.moveToBookmark(rangeBookmark);
          selRanges.push(range2);
        }
        if (bookmark.backward) {
          this.setSingleRange(selRanges[0], "backward");
        } else {
          this.setRanges(selRanges);
        }
      };
      selProto.saveRanges = function() {
        return {
          backward: this.isBackward(),
          ranges: this.callMethodOnEachRange("cloneRange")
        };
      };
      selProto.restoreRanges = function(selRanges) {
        this.removeAllRanges();
        for (var i2 = 0, range2; range2 = selRanges.ranges[i2]; ++i2) {
          this.addRange(range2, selRanges.backward && i2 == 0);
        }
      };
      selProto.toHtml = function() {
        var rangeHtmls = [];
        this.eachRange(function(range2) {
          rangeHtmls.push(DomRange.toHtml(range2));
        });
        return rangeHtmls.join("");
      };
      if (features.implementsTextRange) {
        selProto.getNativeTextRange = function() {
          var sel;
          if (sel = this.docSelection) {
            var range2 = sel.createRange();
            if (isTextRange2(range2)) {
              return range2;
            } else {
              throw module3.createError("getNativeTextRange: selection is a control selection");
            }
          } else if (this.rangeCount > 0) {
            return api2.WrappedTextRange.rangeToTextRange(this.getRangeAt(0));
          } else {
            throw module3.createError("getNativeTextRange: selection contains no range");
          }
        };
      }
      function inspect2(sel) {
        var rangeInspects = [];
        var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
        var focus = new DomPosition(sel.focusNode, sel.focusOffset);
        var name = typeof sel.getName == "function" ? sel.getName() : "Selection";
        if (typeof sel.rangeCount != "undefined") {
          for (var i2 = 0, len = sel.rangeCount; i2 < len; ++i2) {
            rangeInspects[i2] = DomRange.inspect(sel.getRangeAt(i2));
          }
        }
        return "[" + name + "(Ranges: " + rangeInspects.join(", ") + ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";
      }
      selProto.getName = function() {
        return "WrappedSelection";
      };
      selProto.inspect = function() {
        return inspect2(this);
      };
      selProto.detach = function() {
        actOnCachedSelection(this.win, "delete");
        deleteProperties(this);
      };
      WrappedSelection.detachAll = function() {
        actOnCachedSelection(null, "deleteAll");
      };
      WrappedSelection.inspect = inspect2;
      WrappedSelection.isDirectionBackward = isDirectionBackward;
      api2.Selection = WrappedSelection;
      api2.selectionPrototype = selProto;
      api2.addShimListener(function(win) {
        if (typeof win.getSelection == "undefined") {
          win.getSelection = function() {
            return getSelection(win);
          };
        }
        win = null;
      });
    });
    var docReady = false;
    var loadHandler = function(e) {
      if (!docReady) {
        docReady = true;
        if (!api.initialized && api.config.autoInitialize) {
          init2();
        }
      }
    };
    if (isBrowser2) {
      if (document.readyState == "complete") {
        loadHandler();
      } else {
        if (isHostMethod(document, "addEventListener")) {
          document.addEventListener("DOMContentLoaded", loadHandler, false);
        }
        addListener2(window, "load", loadHandler);
      }
    }
    return api;
  });
})(rangyCore);
var rangy = rangyCore.exports;
var config$1 = {
  log: false,
  logErrors: true,
  editableClass: "js-editable",
  editableDisabledClass: "js-editable-disabled",
  pastingAttribute: "data-editable-is-pasting",
  boldMarkup: {
    type: "tag",
    name: "strong",
    attribs: {},
    trim: true
  },
  italicMarkup: {
    type: "tag",
    name: "em",
    attribs: {},
    trim: true
  },
  underlineMarkup: {
    type: "tag",
    name: "u",
    attribs: {},
    trim: false
  },
  linkMarkup: {
    type: "tag",
    name: "a",
    attribs: {},
    trim: true
  },
  pastedHtmlRules: {
    allowedElements: {
      "a": {
        "href": true,
        "rel": true,
        "target": true
      },
      "strong": {},
      "em": {},
      "br": {}
    },
    requiredAttributes: {
      "a": ["href"]
    },
    transformElements: {
      "b": "strong",
      "i": "em"
    },
    splitIntoBlocks: ["h1", "h2", "h3", "h4", "h5", "h6", "p", "blockquote"],
    blockLevelElements: [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "div",
      "p",
      "pre",
      "hr",
      "blockquote",
      "article",
      "figure",
      "header",
      "footer",
      "ul",
      "ol",
      "li",
      "section",
      "table",
      "video"
    ],
    blacklistedElements: ["style", "script"],
    keepInternalRelativeLinks: false,
    replaceQuotes: {}
  }
};
function error() {
  if (config$1.logErrors === false)
    return;
  const args2 = arguments.length === 1 ? arguments[0] : Array.from(arguments);
  if (!global.console)
    return;
  if (typeof console.error === "function")
    return console.error(args2);
  console.log(args2);
}
const toString$3 = Object.prototype.toString;
const htmlCharacters = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function trimRight(text2) {
  return text2.replace(/\s+$/, "");
}
function trim(text2) {
  return text2.replace(/^\s+|\s+$/g, "");
}
function isString(obj2) {
  return toString$3.call(obj2) === "[object String]";
}
function regexp(str2, flags) {
  if (!flags)
    flags = "g";
  const escapedStr = str2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  return new RegExp(escapedStr, flags);
}
function escapeHtml(s, forAttribute) {
  return s.replace(forAttribute ? /[&<>'"]/g : /[&<>]/g, function(c2) {
    return htmlCharacters[c2];
  });
}
const elementNode = 1;
const textNode = 3;
const documentFragmentNode = 11;
const domArray = (target, document2) => {
  if (typeof target === "string")
    return Array.from(document2.querySelectorAll(target));
  if (target.tagName)
    return [target];
  if (Array.isArray(target))
    return target;
  return Array.from(target);
};
const domSelector = (target, document2) => {
  if (typeof target === "string")
    return document2.querySelector(target);
  if (target.tagName)
    return target;
  if (target[0])
    return target[0];
  return target;
};
const createElement = (html2, win = window) => {
  const el2 = win.document.createElement("div");
  el2.innerHTML = html2;
  return el2.firstElementChild;
};
const closest = (elem, selector) => {
  if (!elem.closest)
    elem = elem.parentNode;
  if (elem && elem.closest)
    return elem.closest(selector);
};
function getHost(node) {
  node = node.jquery ? node[0] : node;
  return closest(node, `.${config$1.editableClass}`);
}
function getNodeIndex(node) {
  let index2 = 0;
  while ((node = node.previousSibling) !== null)
    index2++;
  return index2;
}
function isVoid(node) {
  for (const child of node.childNodes) {
    if (child.nodeType === textNode && !isVoidTextNode(child)) {
      return false;
    }
    if (child.nodeType === elementNode) {
      return false;
    }
  }
  return true;
}
function isVoidTextNode(node) {
  return node.nodeType === textNode && !node.nodeValue;
}
function isWhitespaceOnly(node) {
  return node.nodeType === textNode && lastOffsetWithContent(node) === 0;
}
function isLinebreak(node) {
  return node.nodeType === elementNode && node.tagName === "BR";
}
function lastOffsetWithContent(elem) {
  if (elem.nodeType === textNode)
    return trimRight(elem.nodeValue).length;
  let lastOffset = 0;
  Array.from(elem.childNodes).reverse().every((node, index2, nodes) => {
    if (isWhitespaceOnly(node) || isLinebreak(node))
      return true;
    lastOffset = nodes.length - index2;
    return false;
  });
  return lastOffset;
}
function isBeginningOfHost(host, container, offset) {
  if (container === host)
    return isStartOffset(container, offset);
  if (isStartOffset(container, offset)) {
    const offsetInParent = getNodeIndex(container);
    return isBeginningOfHost(host, container.parentNode, offsetInParent);
  }
  return false;
}
function isEndOfHost(host, container, offset) {
  if (container === host)
    return isEndOffset(container, offset);
  if (isEndOffset(container, offset)) {
    const offsetInParent = getNodeIndex(container) + 1;
    return isEndOfHost(host, container.parentNode, offsetInParent);
  }
  return false;
}
function isStartOffset(container, offset) {
  if (container.nodeType === textNode)
    return offset === 0;
  if (container.childNodes.length === 0)
    return true;
  if (container.childNodes.length === 1 && container.firstChild.nodeType === elementNode && container.firstChild.getAttribute("data-editable") === "remove")
    return true;
  return container.childNodes[offset] === container.firstChild;
}
function isEndOffset(container, offset) {
  if (container.nodeType === textNode)
    return offset === container.length;
  if (container.childNodes.length === 0)
    return true;
  if (offset > 0)
    return container.childNodes[offset - 1] === container.lastChild;
  return false;
}
function isTextEndOfHost(host, container, offset) {
  if (container === host)
    return isTextEndOffset(container, offset);
  if (isTextEndOffset(container, offset)) {
    const offsetInParent = getNodeIndex(container) + 1;
    return isTextEndOfHost(host, container.parentNode, offsetInParent);
  }
  return false;
}
function isTextEndOffset(container, offset) {
  if (container.nodeType === textNode) {
    const text2 = trimRight(container.nodeValue);
    return offset >= text2.length;
  }
  if (container.childNodes.length === 0)
    return true;
  return offset >= lastOffsetWithContent(container);
}
function isSameNode(target, source) {
  let i2, len, attr2;
  if (target.nodeType !== source.nodeType)
    return false;
  if (target.nodeName !== source.nodeName)
    return false;
  for (i2 = 0, len = target.attributes.length; i2 < len; i2++) {
    attr2 = target.attributes[i2];
    if (source.getAttribute(attr2.name) !== attr2.value)
      return false;
  }
  return true;
}
function lastChild(container) {
  return container.lastChild ? lastChild(container.lastChild) : container;
}
function latestChild(container) {
  console.warn("Editable.js: Using obsolete function parser.latestCild(), use lastChild() instead");
  return lastChild(container);
}
function isDocumentFragmentWithoutChildren(fragment) {
  return fragment && fragment.nodeType === documentFragmentNode && fragment.childNodes.length === 0;
}
function isInlineElement(window2, element2) {
  const styles2 = element2.currentStyle || window2.getComputedStyle(element2, "");
  const display2 = styles2.display;
  switch (display2) {
    case "inline":
    case "inline-block":
      return true;
    default:
      return false;
  }
}
var parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getHost,
  getNodeIndex,
  isVoid,
  isVoidTextNode,
  isWhitespaceOnly,
  isLinebreak,
  lastOffsetWithContent,
  isBeginningOfHost,
  isEndOfHost,
  isStartOffset,
  isEndOffset,
  isTextEndOfHost,
  isTextEndOffset,
  isSameNode,
  lastChild,
  latestChild,
  isDocumentFragmentWithoutChildren,
  isInlineElement
}, Symbol.toStringTag, { value: "Module" }));
let boundaryMarkerId = 0;
const markerTextChar = "\uFEFF";
function isChildOf(parent, possibleChild) {
  for (let i2 = 0; i2 < parent.children.length; i2++) {
    if (parent.children[i2] === possibleChild)
      return true;
  }
  return false;
}
function startContainerIsChild(range2) {
  const parent = range2.commonAncestorContainer;
  if (parent.nodeType === 3)
    return false;
  const possibleChild = range2.startContainer.parentElement;
  return isChildOf(parent, possibleChild);
}
function endContainerIsChild(range2) {
  const parent = range2.commonAncestorContainer;
  if (parent.nodeType === 3)
    return false;
  const possibleChild = range2.endContainer.parentElement;
  return isChildOf(parent, possibleChild);
}
function insertRangeBoundaryMarker(range2, atStart) {
  const container = range2.commonAncestorContainer;
  const directlyBeforeFormatTag = startContainerIsChild(range2) && atStart;
  const directlyAfterFormatTag = endContainerIsChild(range2) && !atStart;
  if (container.ownerDocument === null || container.ownerDocument === void 0) {
    error("Cannot save range: range is emtpy");
  }
  const doc = container.ownerDocument.defaultView.document;
  const markerEl = doc.createElement("span");
  markerEl.id = `editable-range-boundary-${++boundaryMarkerId}`;
  markerEl.setAttribute("data-editable", "remove");
  markerEl.style.lineHeight = "0";
  markerEl.style.display = "none";
  markerEl.appendChild(doc.createTextNode(markerTextChar));
  if (directlyBeforeFormatTag) {
    range2.endContainer.parentElement.insertBefore(markerEl, range2.startContainer.parentElement);
  } else if (directlyAfterFormatTag) {
    range2.startContainer.parentElement.insertBefore(markerEl, range2.endContainer.parentElement.nextSibling);
  } else {
    const boundaryRange = range2.cloneRange();
    boundaryRange.collapse(atStart);
    boundaryRange.insertNode(markerEl);
  }
  return markerEl;
}
function setRangeBoundary(host, range2, markerId, atStart) {
  const markerEl = getMarker(host, markerId);
  if (!markerEl)
    return console.log("Marker element has been removed. Cannot restore selection.");
  range2[atStart ? "setStartBefore" : "setEndBefore"](markerEl);
  markerEl.remove();
}
function save(range2) {
  let rangeInfo, startEl, endEl;
  if (range2.collapsed) {
    endEl = insertRangeBoundaryMarker(range2, false);
    rangeInfo = {
      markerId: endEl.id,
      collapsed: true
    };
  } else {
    endEl = insertRangeBoundaryMarker(range2, false);
    startEl = insertRangeBoundaryMarker(range2, true);
    rangeInfo = {
      startMarkerId: startEl.id,
      endMarkerId: endEl.id,
      collapsed: false
    };
  }
  if (range2.collapsed) {
    range2.collapseBefore(endEl);
  } else {
    range2.setEndBefore(endEl);
    range2.setStartAfter(startEl);
  }
  return rangeInfo;
}
function restore(host, rangeInfo) {
  if (rangeInfo.restored)
    return;
  const range2 = rangy.createRange();
  if (rangeInfo.collapsed) {
    const markerEl = getMarker(host, rangeInfo.markerId);
    if (markerEl) {
      markerEl.style.display = "inline";
      const previousNode = markerEl.previousSibling;
      if (previousNode && previousNode.nodeType === textNode) {
        markerEl.remove();
        range2.collapseToPoint(previousNode, previousNode.length);
      } else {
        range2.collapseBefore(markerEl);
        markerEl.remove();
      }
    } else {
      console.log("Marker element has been removed. Cannot restore selection.");
    }
  } else {
    setRangeBoundary(host, range2, rangeInfo.startMarkerId, true);
    setRangeBoundary(host, range2, rangeInfo.endMarkerId, false);
  }
  range2.normalizeBoundaries();
  return range2;
}
function getMarker(host, id) {
  return host.querySelector(`#${id}`);
}
function restoreRange(host, range2, func) {
  range2 = save(range2);
  func();
  return restore(host, range2);
}
const zeroWidthSpace = /\u200B/g;
const zeroWidthNonBreakingSpace = /\uFEFF/g;
const whitespaceExceptSpace = /[^\S ]/g;
function tidyHtml(element2) {
  normalizeTags(element2);
}
function normalizeTags(element2) {
  const fragment = document.createDocumentFragment();
  removeWhitespaces(element2, "firstChild");
  removeWhitespaces(element2, "lastChild");
  for (const node of element2.childNodes) {
    if (node.nodeName !== "BR" && !node.textContent)
      continue;
    if (node.nodeType === elementNode && node.nodeName !== "BR") {
      let sibling = node;
      while ((sibling = sibling.nextSibling) !== null) {
        if (!isSameNode(sibling, node))
          break;
        for (const siblingChild of sibling.childNodes) {
          node.appendChild(siblingChild.cloneNode(true));
        }
        sibling.remove();
      }
      normalizeTags(node);
    }
    fragment.appendChild(node.cloneNode(true));
  }
  while (element2.firstChild)
    element2.removeChild(element2.firstChild);
  element2.appendChild(fragment);
}
function normalizeWhitespace(text2) {
  return text2.replace(whitespaceExceptSpace, " ");
}
function cleanInternals(element2) {
  element2.innerHTML = extractContent(element2, true);
}
function extractContent(element2, keepUiElements) {
  const innerHtml = (element2.nodeType === documentFragmentNode ? getInnerHtmlOfFragment(element2) : element2.innerHTML).replace(zeroWidthNonBreakingSpace, "").replace(zeroWidthSpace, "<br>");
  const clone2 = document.createElement("div");
  clone2.innerHTML = innerHtml;
  unwrapInternalNodes(clone2, keepUiElements);
  removeWhitespaces(clone2, "firstChild");
  removeWhitespaces(clone2, "lastChild");
  return clone2.innerHTML;
}
function getInnerHtmlOfFragment(documentFragment) {
  const div2 = document.createElement("div");
  div2.appendChild(documentFragment);
  return div2.innerHTML;
}
function createFragmentFromString(htmlString) {
  const wrapper = document.createElement("div");
  wrapper.innerHTML = htmlString;
  const fragment = document.createDocumentFragment();
  while (wrapper.firstChild)
    fragment.appendChild(wrapper.firstChild);
  return fragment;
}
function adoptElement(node, doc) {
  return node.ownerDocument !== doc ? doc.adoptNode(node) : node;
}
function cloneRangeContents(range2) {
  const rangeFragment = range2.cloneContents();
  const parent = rangeFragment.childNodes[0];
  const fragment = document.createDocumentFragment();
  while (parent.childNodes.length)
    fragment.appendChild(parent.childNodes[0]);
  return fragment;
}
function removeWhitespaces(node, type2, firstCall = true) {
  let elem;
  while (elem = node[type2]) {
    if (elem.nodeType === textNode) {
      if (/^\s+$/.test(elem.textContent))
        node.removeChild(elem);
      else
        break;
    } else if (elem.nodeName === "BR") {
      elem.remove();
    } else {
      if (elem[type2])
        removeWhitespaces(elem, type2, false);
      break;
    }
  }
  if (!firstCall)
    return;
  elem = node[type2];
  if ((elem == null ? void 0 : elem.nodeType) !== textNode)
    return;
  elem.textContent = elem.textContent.replace(type2.startsWith("last") ? /\s+$/ : /^\s+/, "");
}
function unwrapInternalNodes(sibling, keepUiElements) {
  while (sibling) {
    const nextSibling = sibling.nextSibling;
    if (sibling.nodeType !== elementNode) {
      sibling = nextSibling;
      continue;
    }
    const attr2 = sibling.getAttribute("data-editable");
    if (sibling.firstChild)
      unwrapInternalNodes(sibling.firstChild, keepUiElements);
    if (attr2 === "remove" || attr2 === "ui-remove" && !keepUiElements) {
      sibling.remove();
    }
    if (attr2 === "unwrap" || attr2 === "ui-unwrap" && !keepUiElements) {
      unwrap(sibling);
    }
    sibling = nextSibling;
  }
}
function getTags(host, range2, filterFunc) {
  const innerTags = getInnerTags(range2, filterFunc);
  const ancestorTags = getAncestorTags(host, range2, filterFunc);
  return innerTags.concat(ancestorTags);
}
function getAncestorTags(host, range2, filterFunc) {
  const tags = [];
  let node = range2.commonAncestorContainer;
  while (node !== host) {
    if (!filterFunc || filterFunc(node))
      tags.push(node);
    node = node.parentNode;
  }
  return tags;
}
function getTagsByName(host, range2, tagName) {
  return getTags(host, range2, (node) => {
    return node.nodeName.toUpperCase() === tagName.toUpperCase();
  });
}
function getTagsByNameAndAttributes(host, range2, elem) {
  return getTags(host, range2, (node) => {
    return node.nodeName.toUpperCase() === elem.nodeName.toUpperCase() && areSameAttributes(node.attributes, elem.attributes);
  });
}
function areSameAttributes(attrs1, attrs2) {
  if (attrs1.length !== attrs2.length)
    return false;
  for (let i2 = 0; i2 < attrs1.length; i2++) {
    const attr2 = attrs2[attrs1[i2].name];
    if (!(attr2 && attr2.value === attrs1[i2].value))
      return false;
  }
  return true;
}
function getInnerTags(range2, filterFunc) {
  return range2.getNodes([elementNode], filterFunc);
}
function getTagNames(elements2 = []) {
  return elements2.map((element2) => element2.nodeName);
}
function isAffectedBy(host, range2, tagName) {
  return getTags(host, range2).some((elem) => elem.nodeName === tagName.toUpperCase());
}
function selectNodeContents(element2) {
  const range2 = rangy.createRange();
  range2.selectNodeContents(element2);
  return range2;
}
function isExactSelection(range2, elem, visible) {
  const elemRange = rangy.createRange();
  elemRange.selectNodeContents(elem);
  if (!range2.intersectsRange(elemRange))
    return false;
  let rangeText = range2.toString();
  let elemText = (elem.jquery ? elem[0] : elem).textContent;
  if (visible) {
    rangeText = trim(rangeText);
    elemText = trim(elemText);
  }
  return rangeText !== "" && rangeText === elemText;
}
function expandTo(host, range2, elem) {
  range2.selectNodeContents(elem);
  return range2;
}
function toggleTag(host, range2, elem) {
  const elems = getTagsByNameAndAttributes(host, range2, elem);
  if (elems.length === 1 && isExactSelection(range2, elems[0], "visible")) {
    return removeFormattingElem(host, range2, elem);
  }
  return forceWrap(host, range2, elem);
}
function isWrappable(range2) {
  return range2.canSurroundContents();
}
function forceWrap(host, range2, elem) {
  let restoredRange = restoreRange(host, range2, () => {
    nukeElem(host, range2, elem);
  });
  if (!isWrappable(restoredRange)) {
    restoredRange = restoreRange(host, restoredRange, () => {
      nuke(host, restoredRange);
    });
  }
  wrap$1(restoredRange, elem);
  return restoredRange;
}
function wrap$1(range2, elem) {
  if (!isWrappable(range2)) {
    console.log("content.wrap(): can not surround range");
    return;
  }
  if (typeof elem === "string")
    elem = createElement(elem);
  range2.surroundContents(elem);
}
function unwrap(elem) {
  elem = elem.jquery ? elem[0] : elem;
  const parent = elem.parentNode;
  while (elem.firstChild)
    parent.insertBefore(elem.firstChild, elem);
  parent.removeChild(elem);
}
function removeFormattingElem(host, range2, elem) {
  return restoreRange(host, range2, () => {
    nukeElem(host, range2, elem);
  });
}
function removeFormatting(host, range2, selector) {
  return restoreRange(host, range2, () => {
    nuke(host, range2, selector);
  });
}
function nuke(host, range2, selector) {
  getTags(host, range2).forEach((elem) => {
    if (elem.nodeName.toUpperCase() !== "BR" && (!selector || elem.matches(selector))) {
      unwrap(elem);
    }
  });
}
function nukeElem(host, range2, node) {
  getTags(host, range2).forEach((elem) => {
    if (elem.nodeName.toUpperCase() !== "BR" && (!node || elem.nodeName.toUpperCase() === node.nodeName.toUpperCase() && areSameAttributes(elem.attributes, node.attributes))) {
      unwrap(elem);
    }
  });
}
function insertCharacter(range2, character, atStart) {
  const insertEl = document.createTextNode(character);
  const boundaryRange = range2.cloneRange();
  boundaryRange.collapse(atStart);
  boundaryRange.insertNode(insertEl);
  range2[atStart ? "setStartBefore" : "setEndAfter"](insertEl);
  range2.normalizeBoundaries();
}
function surround(host, range2, startCharacter, endCharacter) {
  insertCharacter(range2, endCharacter || startCharacter, false);
  insertCharacter(range2, startCharacter, true);
  return range2;
}
function deleteCharacter(host, range2, character) {
  if (!containsString(range2, character))
    return range2;
  range2.splitBoundaries();
  const restoredRange = restoreRange(host, range2, () => {
    const charRegexp = regexp(character);
    range2.getNodes([textNode], (node) => {
      return node.nodeValue.search(charRegexp) >= 0;
    }).forEach((node) => {
      node.nodeValue = node.nodeValue.replace(charRegexp, "");
    });
  });
  restoredRange.normalizeBoundaries();
  return restoredRange;
}
function containsString(range2, str2) {
  return range2.toString().indexOf(str2) >= 0;
}
function nukeTag(host, range2, tagName) {
  getTags(host, range2).forEach((elem) => {
    if (elem.nodeName.toUpperCase() === tagName.toUpperCase())
      unwrap(elem);
  });
}
var content = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  tidyHtml,
  normalizeTags,
  normalizeWhitespace,
  cleanInternals,
  extractContent,
  getInnerHtmlOfFragment,
  createFragmentFromString,
  adoptElement,
  cloneRangeContents,
  unwrapInternalNodes,
  getTags,
  getAncestorTags,
  getTagsByName,
  getTagsByNameAndAttributes,
  areSameAttributes,
  getInnerTags,
  getTagNames,
  isAffectedBy,
  selectNodeContents,
  isExactSelection,
  expandTo,
  toggleTag,
  isWrappable,
  forceWrap,
  wrap: wrap$1,
  unwrap,
  removeFormattingElem,
  removeFormatting,
  nuke,
  nukeElem,
  insertCharacter,
  surround,
  deleteCharacter,
  containsString,
  nukeTag
}, Symbol.toStringTag, { value: "Module" }));
let nextBlockId = 1;
const next = getSibling("nextElementSibling");
const previous = getSibling("previousElementSibling");
function init(elem, { normalize: normalize3, shouldSpellcheck }) {
  setBlockId(elem);
  elem.setAttribute("contenteditable", true);
  elem.setAttribute("spellcheck", Boolean(shouldSpellcheck));
  elem.classList.remove(config$1.editableDisabledClass);
  elem.classList.add(config$1.editableClass);
  if (normalize3)
    tidyHtml(elem);
}
function disable(elem) {
  elem.removeAttribute("contenteditable");
  elem.removeAttribute("spellcheck");
  setState(elem);
  elem.classList.remove(config$1.editableClass);
  elem.classList.add(config$1.editableDisabledClass);
}
function setBlockId(elem) {
  if (!elem.hasAttribute("data-editable")) {
    elem.setAttribute("data-editable", `id-${nextBlockId}`);
    nextBlockId += 1;
  }
}
function setState(elem, data) {
  if (elem.hasAttribute("data-editable")) {
    elem.getAttribute("data-editable");
  }
}
function getSibling(type2) {
  return function(element2) {
    const sibling = element2[type2];
    return sibling && sibling.getAttribute("contenteditable") ? sibling : null;
  };
}
const doubleQuotePairs = [
  ["\xAB", "\xBB"],
  ["\xBB", "\xAB"],
  ['"', '"'],
  ["\u201C", "\u201D"],
  ["\u201D", "\u201D"],
  ["\u201C", "\u201C"],
  ["\u201E", "\u201C"]
];
const singleQuotePairs = [
  ["\u2018", "\u2019"],
  ["\u2039", "\u203A"],
  ["\u201A", "\u2018"],
  ["\u2019", "\u2019"],
  ["\u203A", "\u2039"],
  [`'`, `'`],
  [`\u2018`, `\u2019`]
];
const apostrophe = [
  "\u2019",
  `'`
];
const quotesRegex = /([‘’‹›‚'«»"“”„])(?![^<]*?>)/g;
const beforeOpeningQuote = /\s|[>\-–—«»”"“„]/;
const afterClosingQuote = /\s|[<\-–—«»”"“‘’‹›'.;?:,]/;
let replacements;
function replaceAllQuotes$1(str2, replaceQuotesRules) {
  replacements = replaceQuotesRules || {};
  replacements.quotes = replacements.quotes || [void 0, void 0];
  replacements.singleQuotes = replacements.singleQuotes || [void 0, void 0];
  const matches2 = getAllQuotes(str2);
  if (matches2.length > 0) {
    replaceMatchedQuotes(matches2, 0);
    return replaceExistingQuotes(str2, matches2);
  }
  return str2;
}
function replaceMatchedQuotes(matches2, position2) {
  while (position2 < matches2.length) {
    const closingTag = findClosingQuote(matches2, position2);
    if (closingTag) {
      matches2[position2].replace = closingTag.type === "double" ? replacements.quotes[0] : replacements.singleQuotes[0];
      matches2[closingTag.position].replace = closingTag.type === "double" ? replacements.quotes[1] : replacements.singleQuotes[1];
      if (closingTag.position !== position2 + 1) {
        const nestedMatches = matches2.slice(position2 + 1, closingTag.position);
        if (nestedMatches) {
          replaceMatchedQuotes(nestedMatches, 0);
        }
      }
      position2 = closingTag.position + 1;
    } else {
      matches2[position2].replace = replaceApostrophe(matches2[position2].char);
      position2 += 1;
    }
  }
}
function findClosingQuote(matches2, position2) {
  if (position2 === matches2.length - 1)
    return;
  const current = matches2[position2];
  const openingQuote = current.char;
  if (current.before && !beforeOpeningQuote.test(current.before))
    return;
  const possibleClosingSingleQuotes = getPossibleClosingQuotes(openingQuote, singleQuotePairs);
  const possibleClosingDoubleQuotes = getPossibleClosingQuotes(openingQuote, doubleQuotePairs);
  for (let i2 = position2 + 1; i2 < matches2.length; i2++) {
    if (matches2[i2].after && afterClosingQuote.test(matches2[i2].after) || !matches2[i2].after) {
      if (possibleClosingSingleQuotes.includes(matches2[i2].char)) {
        return { position: i2, type: "single" };
      }
      if (possibleClosingDoubleQuotes.includes(matches2[i2].char)) {
        return { position: i2, type: "double" };
      }
    }
  }
}
function getPossibleClosingQuotes(openingQuote, pairs2) {
  return pairs2.filter((quotePair) => quotePair[0] === openingQuote).map((quotePair) => quotePair[1]);
}
function replaceApostrophe(quote) {
  if (apostrophe.includes(quote)) {
    return replacements.apostrophe;
  }
}
function getAllQuotes(str2) {
  return [...str2.matchAll(quotesRegex)].map((match) => {
    const index2 = match.index;
    return {
      char: match[1],
      before: index2 > 0 ? str2[index2 - 1] : "",
      after: index2 + 1 < str2.length ? str2[index2 + 1] : ""
    };
  });
}
function replaceExistingQuotes(str2, matches2) {
  let index2 = 0;
  return str2.replace(quotesRegex, (match) => {
    const replacement = matches2[index2].replace || matches2[index2].char;
    index2 += 1;
    return replacement;
  });
}
let allowedElements, requiredAttributes, transformElements, blockLevelElements, replaceQuotes;
let splitIntoBlocks, blacklistedElements;
const whitespaceOnly = /^\s*$/;
const blockPlaceholder = "<!-- BLOCK -->";
let keepInternalRelativeLinks;
updateConfig(config$1);
function updateConfig(conf) {
  const rules = conf.pastedHtmlRules;
  allowedElements = rules.allowedElements || {};
  requiredAttributes = rules.requiredAttributes || {};
  transformElements = rules.transformElements || {};
  blacklistedElements = rules.blacklistedElements || [];
  keepInternalRelativeLinks = rules.keepInternalRelativeLinks || false;
  replaceQuotes = rules.replaceQuotes || {};
  blockLevelElements = {};
  rules.blockLevelElements.forEach((name) => {
    blockLevelElements[name] = true;
  });
  splitIntoBlocks = {};
  rules.splitIntoBlocks.forEach((name) => {
    splitIntoBlocks[name] = true;
  });
}
function paste(element2, cursor, clipboardContent) {
  const document2 = element2.ownerDocument;
  element2.setAttribute(config$1.pastingAttribute, true);
  if (cursor.isSelection)
    cursor = cursor.deleteContent();
  const pasteHolder = document2.createElement("div");
  pasteHolder.innerHTML = clipboardContent;
  const blocks = parseContent(pasteHolder);
  element2.removeAttribute(config$1.pastingAttribute);
  return { blocks, cursor };
}
function parseContent(element2) {
  return filterHtmlElements(element2).split(blockPlaceholder).map((entry) => trim(cleanWhitespace(replaceAllQuotes(entry)))).filter((entry) => !whitespaceOnly.test(entry));
}
function filterHtmlElements(elem) {
  return Array.from(elem.childNodes).reduce((content2, child) => {
    if (blacklistedElements.indexOf(child.nodeName.toLowerCase()) !== -1) {
      return "";
    }
    if (keepInternalRelativeLinks && child.nodeName === "A" && child.href) {
      const stripInternalHost = child.getAttribute("href").replace(window.location.origin, "");
      child.setAttribute("href", stripInternalHost);
    }
    if (child.nodeType === elementNode) {
      const childContent = filterHtmlElements(child);
      return content2 + conditionalNodeWrap(child, childContent);
    }
    if (child.nodeType === textNode)
      return content2 + escapeHtml(child.nodeValue);
    return content2;
  }, "");
}
function conditionalNodeWrap(child, content2) {
  let nodeName = child.nodeName.toLowerCase();
  nodeName = transformNodeName(nodeName);
  if (shouldKeepNode(nodeName, child)) {
    const attributes = filterAttributes(nodeName, child);
    if (nodeName === "br")
      return `<${nodeName + attributes}>`;
    if (!whitespaceOnly.test(content2)) {
      return `<${nodeName + attributes}>${content2}</${nodeName}>`;
    }
    return content2;
  }
  if (splitIntoBlocks[nodeName]) {
    return blockPlaceholder + content2 + blockPlaceholder;
  }
  if (blockLevelElements[nodeName])
    return `${content2} `;
  return content2;
}
function filterAttributes(nodeName, node) {
  return Array.from(node.attributes).reduce((attributes, { name, value: value2 }) => {
    if (allowedElements[nodeName][name] && value2) {
      return `${attributes} ${name}="${value2}"`;
    }
    return attributes;
  }, "");
}
function transformNodeName(nodeName) {
  return transformElements[nodeName] || nodeName;
}
function hasRequiredAttributes(nodeName, node) {
  const requiredAttrs = requiredAttributes[nodeName];
  if (!requiredAttrs)
    return true;
  return !requiredAttrs.some((name) => !node.getAttribute(name));
}
function shouldKeepNode(nodeName, node) {
  return allowedElements[nodeName] && hasRequiredAttributes(nodeName, node);
}
function cleanWhitespace(str2) {
  return str2.replace(/\n/g, " ").replace(/ {2,}/g, " ").replace(/(.)\u00A0/g, (match, group) => group + (/[\u0020]/.test(group) ? "\xA0" : " "));
}
function replaceAllQuotes(str2) {
  if (replaceQuotes.quotes || replaceQuotes.singleQuotes || replaceQuotes.apostrophe) {
    return replaceAllQuotes$1(str2, replaceQuotes);
  }
  return str2;
}
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
const BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
const PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
const OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
const ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils$1 {
  static getFirstMatch(regexp2, ua) {
    const match = ua.match(regexp2);
    return match && match.length > 0 && match[1] || "";
  }
  static getSecondMatch(regexp2, ua) {
    const match = ua.match(regexp2);
    return match && match.length > 1 && match[2] || "";
  }
  static matchAndReturnConst(regexp2, ua, _const) {
    if (regexp2.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version2) {
    switch (version2) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  static getMacOSVersionName(version2) {
    const v = version2.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] !== 10)
      return void 0;
    switch (v[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  static getAndroidVersionName(version2) {
    const v = version2.split(".").splice(0, 2).map((s) => parseInt(s, 10) || 0);
    v.push(0);
    if (v[0] === 1 && v[1] < 5)
      return void 0;
    if (v[0] === 1 && v[1] < 6)
      return "Cupcake";
    if (v[0] === 1 && v[1] >= 6)
      return "Donut";
    if (v[0] === 2 && v[1] < 2)
      return "Eclair";
    if (v[0] === 2 && v[1] === 2)
      return "Froyo";
    if (v[0] === 2 && v[1] > 2)
      return "Gingerbread";
    if (v[0] === 3)
      return "Honeycomb";
    if (v[0] === 4 && v[1] < 1)
      return "Ice Cream Sandwich";
    if (v[0] === 4 && v[1] < 4)
      return "Jelly Bean";
    if (v[0] === 4 && v[1] >= 4)
      return "KitKat";
    if (v[0] === 5)
      return "Lollipop";
    if (v[0] === 6)
      return "Marshmallow";
    if (v[0] === 7)
      return "Nougat";
    if (v[0] === 8)
      return "Oreo";
    if (v[0] === 9)
      return "Pie";
    return void 0;
  }
  static getVersionPrecision(version2) {
    return version2.split(".").length;
  }
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils$1.getVersionPrecision(versionA);
    const versionBPrecision = Utils$1.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils$1.map([versionA, versionB], (version2) => {
      const delta = precision - Utils$1.getVersionPrecision(version2);
      const _version = version2 + new Array(delta + 1).join(".0");
      return Utils$1.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  static map(arr, iterator) {
    const result2 = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result2.push(iterator(arr[i2]));
    }
    return result2;
  }
  static find(arr, predicate) {
    let i2;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value2 = arr[i2];
      if (predicate(value2, i2)) {
        return value2;
      }
    }
    return void 0;
  }
  static assign(obj2, ...assigners) {
    const result2 = obj2;
    let i2;
    let l2;
    if (Object.assign) {
      return Object.assign(obj2, ...assigners);
    }
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys2 = Object.keys(assigner);
        keys2.forEach((key) => {
          result2[key] = assigner[key];
        });
      }
    }
    return obj2;
  }
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
const browsersList = [
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser2 = {
        name: "Googlebot"
      };
      const version2 = Utils$1.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opera/i],
    describe(ua) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils$1.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Samsung Internet for Android"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser2 = {
        name: "NAVER Whale Browser"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "MZ Browser"
      };
      const version2 = Utils$1.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser2 = {
        name: "Focus"
      };
      const version2 = Utils$1.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser2 = {
        name: "Swing"
      };
      const version2 = Utils$1.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser2 = {
        name: "Opera Coast"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser2 = {
        name: "Opera Touch"
      };
      const version2 = Utils$1.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Yandex Browser"
      };
      const version2 = Utils$1.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser2 = {
        name: "UC Browser"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser2 = {
        name: "Maxthon"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser2 = {
        name: "Epiphany"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser2 = {
        name: "Puffin"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser2 = {
        name: "Sleipnir"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser2 = {
        name: "K-Meleon"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser2 = {
        name: "WeChat"
      };
      const version2 = Utils$1.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser2 = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version2 = Utils$1.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser2 = {
        name: "Internet Explorer"
      };
      const version2 = Utils$1.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils$1.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils$1.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser2 = {
        name: "Vivaldi"
      };
      const version2 = Utils$1.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser2 = {
        name: "SeaMonkey"
      };
      const version2 = Utils$1.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser2 = {
        name: "Sailfish"
      };
      const version2 = Utils$1.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser2 = {
        name: "Amazon Silk"
      };
      const version2 = Utils$1.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser2 = {
        name: "PhantomJS"
      };
      const version2 = Utils$1.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser2 = {
        name: "SlimerJS"
      };
      const version2 = Utils$1.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser2 = {
        name: "BlackBerry"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser2 = {
        name: "WebOS Browser"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua) || Utils$1.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser2 = {
        name: "Bada"
      };
      const version2 = Utils$1.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser2 = {
        name: "Tizen"
      };
      const version2 = Utils$1.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser2 = {
        name: "QupZilla"
      };
      const version2 = Utils$1.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser2 = {
        name: "Firefox"
      };
      const version2 = Utils$1.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser2 = {
        name: "Electron"
      };
      const version2 = Utils$1.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Miui"
      };
      const version2 = Utils$1.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser2 = {
        name: "Chromium"
      };
      const version2 = Utils$1.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser2 = {
        name: "Chrome"
      };
      const version2 = Utils$1.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser2 = {
        name: "Google Search"
      };
      const version2 = Utils$1.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test(parser2) {
      const notLikeAndroid = !parser2.test(/like android/i);
      const butAndroid = parser2.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser2 = {
        name: "Android Browser"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser2 = {
        name: "PlayStation 4"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser2 = {
        name: "Safari"
      };
      const version2 = Utils$1.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp2 = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils$1.getFirstMatch(regexp2, ua),
        version: Utils$1.getSecondMatch(regexp2, ua)
      };
    }
  }
];
var osParsersList = [
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version: version2
      };
    }
  },
  {
    test: [/windows phone/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version: version2
      };
    }
  },
  {
    test: [/windows /i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils$1.getWindowsVersionName(version2);
      return {
        name: OS_MAP.Windows,
        version: version2,
        versionName
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result2 = {
        name: OS_MAP.iOS
      };
      const version2 = Utils$1.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version2) {
        result2.version = version2;
      }
      return result2;
    }
  },
  {
    test: [/macintosh/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils$1.getMacOSVersionName(version2);
      const os = {
        name: OS_MAP.MacOS,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version2
      };
    }
  },
  {
    test(parser2) {
      const notLikeAndroid = !parser2.test(/like android/i);
      const butAndroid = parser2.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils$1.getAndroidVersionName(version2);
      const os = {
        name: OS_MAP.Android,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version2 && version2.length) {
        os.version = version2;
      }
      return os;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils$1.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils$1.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version: version2
      };
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version: version2
      };
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version: version2
      };
    }
  },
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version2 = Utils$1.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version: version2
      };
    }
  }
];
var platformParsersList = [
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils$1.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser2) {
      const iDevice = parser2.test(/ipod|iphone/i);
      const likeIDevice = parser2.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils$1.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  {
    test(parser2) {
      const osMajorVersion = Number(String(parser2.getOSVersion()).split(".")[0]);
      return parser2.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  {
    test(parser2) {
      return parser2.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
var enginesParsersList = [
  {
    test(parser2) {
      return parser2.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version2 = Utils$1.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version2
      };
    }
  },
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version2 = Utils$1.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test(parser2) {
      return parser2.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version2 = Utils$1.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test(parser2) {
      const isGecko = parser2.test(/gecko/i);
      const likeGecko = parser2.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version2 = Utils$1.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version2 = Utils$1.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  }
];
class Parser {
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  getUA() {
    return this._ua;
  }
  test(regex) {
    return regex.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils$1.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition2) => this.test(condition2));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils$1.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition2) => this.test(condition2));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  getPlatformType(toLowerCase = false) {
    const { type: type2 } = this.getPlatform();
    if (toLowerCase) {
      return String(type2).toLowerCase() || "";
    }
    return type2 || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils$1.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition2) => this.test(condition2));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils$1.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition2) => this.test(condition2));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  getResult() {
    return Utils$1.assign({}, this.parsedResult);
  }
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils$1.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils$1.find(platformsAndOSNames, (name) => this.isPlatform(name));
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils$1.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils$1.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version2) {
    let expectedResults = [0];
    let comparableVersion = version2;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version2[0] === ">" || version2[0] === "<") {
      comparableVersion = version2.substr(1);
      if (version2[1] === "=") {
        isLoose = true;
        comparableVersion = version2.substr(2);
      } else {
        expectedResults = [];
      }
      if (version2[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version2[0] === "=") {
      comparableVersion = version2.substr(1);
    } else if (version2[0] === "~") {
      isLoose = true;
      comparableVersion = version2.substr(1);
    }
    return expectedResults.indexOf(Utils$1.compareVersions(currentBrowserVersion, comparableVersion, isLoose)) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser(UA, skipParsing);
  }
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
typeof document.documentElement.contentEditable !== "undefined";
const parser = Bowser.getParser(window.navigator.userAgent);
const browserEngine = parser.getEngineName();
const webKit = browserEngine === "WebKit";
const hasNativeSelectionchangeSupport = (document2) => {
  const doc = document2;
  const osc = doc.onselectionchange;
  if (osc !== void 0) {
    try {
      doc.onselectionchange = 0;
      return doc.onselectionchange === null;
    } catch (e) {
    } finally {
      doc.onselectionchange = osc;
    }
  }
  return false;
};
const selectionchange = hasNativeSelectionchangeSupport(document);
const contenteditableSpanBug = !!webKit;
function eventable(obj2, notifyContext) {
  const events = getEventableModule(notifyContext);
  obj2.on = events.on;
  obj2.off = events.off;
  obj2.notify = events.notify;
}
function getEventableModule(notifyContext) {
  let listeners = {};
  function addListener2(events, listener) {
    events.split(" ").forEach((event2) => {
      listeners[event2] = listeners[event2] || [];
      listeners[event2].unshift(listener);
    });
  }
  function removeListener2(event2, listener) {
    const eventListeners = listeners[event2];
    if (!eventListeners)
      return;
    const index2 = eventListeners.indexOf(listener);
    if (index2 < 0)
      return;
    eventListeners.splice(index2, 1);
  }
  return {
    on(event2, listener) {
      if (arguments.length === 2) {
        addListener2(event2, listener);
      } else if (arguments.length === 1) {
        for (const eventType in event2)
          addListener2(eventType, event2[eventType]);
      }
      return this;
    },
    off(event2, listener) {
      if (arguments.length === 2) {
        removeListener2(event2, listener);
      } else if (arguments.length === 1) {
        listeners[event2] = [];
      } else {
        listeners = {};
      }
    },
    notify(context, event2) {
      const args2 = Array.from(arguments);
      if (notifyContext) {
        event2 = context;
        context = notifyContext;
        args2.splice(0, 1);
      } else {
        args2.splice(0, 2);
      }
      if (this.switchContext) {
        const nextEvent = this.switchContext.events.shift();
        if (event2 !== nextEvent)
          this.switchContext = void 0;
      }
      const eventListeners = listeners[event2];
      if (!eventListeners)
        return;
      eventListeners.every((listener) => listener.apply(context, args2) !== false);
    }
  };
}
function getScrollPosition(win) {
  const x2 = win.pageXOffset !== void 0 ? win.pageXOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollLeft;
  const y2 = win.pageYOffset !== void 0 ? win.pageYOffset : (win.document.documentElement || win.document.body.parentNode || win.document.body).scrollTop;
  return { x: x2, y: y2 };
}
class Cursor {
  static findHost(elem, selector) {
    return closest(elem, selector);
  }
  constructor(editableHost, rangyRange) {
    this.setHost(editableHost);
    this.range = rangyRange;
    this.isCursor = true;
  }
  getTags(filterFunc) {
    return getTags(this.host, this.range, filterFunc);
  }
  getTagNames(filterFunc) {
    return getTagNames(this.getTags(filterFunc));
  }
  getTagsByName(tagName) {
    return getTagsByName(this.host, this.range, tagName);
  }
  getInnerTags(filterFunc) {
    return getInnerTags(this.range, filterFunc);
  }
  getAncestorTags(filterFunc) {
    return getAncestorTags(this.host, this.range, filterFunc);
  }
  isAtEnd() {
    return isEndOfHost(this.host, this.range.endContainer, this.range.endOffset);
  }
  isAtTextEnd() {
    return isTextEndOfHost(this.host, this.range.endContainer, this.range.endOffset);
  }
  isAtLastLine() {
    const hostRange = this.win.document.createRange();
    hostRange.selectNodeContents(this.host);
    hostRange.collapse(false);
    const hostCoords = getRangeBoundingClientRect(hostRange, this.win);
    const cursorCoords = getRangeBoundingClientRect(this.range.nativeRange, this.win);
    return isCloseTo(hostCoords.bottom, cursorCoords.bottom);
  }
  isAtFirstLine() {
    const hostRange = this.win.document.createRange();
    hostRange.selectNodeContents(this.host);
    hostRange.collapse(true);
    const hostCoords = getRangeBoundingClientRect(hostRange, this.win);
    const cursorCoords = getRangeBoundingClientRect(this.range.nativeRange, this.win);
    return isCloseTo(hostCoords.top, cursorCoords.top);
  }
  isAtBeginning() {
    return isBeginningOfHost(this.host, this.range.startContainer, this.range.startOffset);
  }
  insertBefore(element2) {
    if (isString(element2))
      element2 = createFragmentFromString(element2);
    if (isDocumentFragmentWithoutChildren(element2))
      return;
    element2 = this.adoptElement(element2);
    let preceedingElement = element2;
    if (element2.nodeType === documentFragmentNode) {
      const lastIndex = element2.childNodes.length - 1;
      preceedingElement = element2.childNodes[lastIndex];
    }
    this.range.insertNode(element2);
    this.range.setStartAfter(preceedingElement);
    this.range.setEndAfter(preceedingElement);
  }
  insertAfter(element2) {
    if (isString(element2))
      element2 = createFragmentFromString(element2);
    if (isDocumentFragmentWithoutChildren(element2))
      return;
    element2 = this.adoptElement(element2);
    this.range.insertNode(element2);
  }
  setSelection() {
    this.setVisibleSelection();
  }
  setVisibleSelection() {
    if (this.win.document.activeElement !== this.host) {
      const { x: x2, y: y2 } = getScrollPosition(this.win);
      this.win.scrollTo(x2, y2);
    }
    rangy.getSelection(this.win).setSingleRange(this.range);
  }
  before() {
    const range2 = this.range.cloneRange();
    range2.collapse(true);
    range2.setStartBefore(this.host);
    return cloneRangeContents(range2);
  }
  textBefore() {
    const range2 = this.range.cloneRange();
    range2.collapse(true);
    range2.setStartBefore(this.host);
    return range2.toString();
  }
  beforeHtml() {
    return getInnerHtmlOfFragment(this.before());
  }
  after() {
    const range2 = this.range.cloneRange();
    range2.collapse(false);
    range2.setEndAfter(this.host);
    return cloneRangeContents(range2);
  }
  textAfter() {
    const range2 = this.range.cloneRange();
    range2.collapse(false);
    range2.setEndAfter(this.host);
    return range2.toString();
  }
  afterHtml() {
    return getInnerHtmlOfFragment(this.after());
  }
  getBoundingClientRect() {
    return this.range.nativeRange.getBoundingClientRect();
  }
  getCoordinates(positioning = "absolute") {
    const coords = this.range.nativeRange.getBoundingClientRect();
    if (positioning === "fixed")
      return coords;
    const { x: x2, y: y2 } = getScrollPosition(this.win);
    return {
      top: coords.top + y2,
      bottom: coords.bottom + y2,
      left: coords.left + x2,
      right: coords.right + x2,
      height: coords.height,
      width: coords.width
    };
  }
  moveBefore(element2) {
    this.updateHost(element2);
    this.range.setStartBefore(element2);
    this.range.setEndBefore(element2);
    if (this.isSelection)
      return new Cursor(this.host, this.range);
  }
  moveAfter(element2) {
    this.updateHost(element2);
    this.range.setStartAfter(element2);
    this.range.setEndAfter(element2);
    if (this.isSelection)
      return new Cursor(this.host, this.range);
  }
  moveAtBeginning(element2 = this.host) {
    this.updateHost(element2);
    this.range.selectNodeContents(element2);
    this.range.collapse(true);
    if (this.isSelection)
      return new Cursor(this.host, this.range);
  }
  moveAtEnd(element2 = this.host) {
    this.updateHost(element2);
    this.range.selectNodeContents(element2);
    this.range.collapse(false);
    if (this.isSelection)
      return new Cursor(this.host, this.range);
  }
  moveAtTextEnd(element2) {
    return this.moveAtEnd(lastChild(element2));
  }
  setHost(element2) {
    if (element2.jquery)
      element2 = element2[0];
    this.host = element2;
    this.win = element2 === void 0 || element2 === null ? window : element2.ownerDocument.defaultView;
  }
  updateHost(element2) {
    const host = getHost(element2);
    if (!host)
      error("Can not set cursor outside of an editable block");
    this.setHost(host);
  }
  retainVisibleSelection(callback) {
    this.save();
    callback();
    this.restore();
    this.setVisibleSelection();
  }
  save() {
    this.savedRangeInfo = save(this.range);
    this.savedRangeInfo.host = this.host;
  }
  restore() {
    if (!this.savedRangeInfo)
      error("Could not restore selection");
    this.host = this.savedRangeInfo.host;
    this.range = restore(this.host, this.savedRangeInfo);
    this.savedRangeInfo = void 0;
  }
  equals(cursor) {
    if (!cursor)
      return false;
    if (!cursor.host)
      return false;
    if (!cursor.host.isEqualNode(this.host))
      return false;
    if (!cursor.range)
      return false;
    if (!cursor.range.equals(this.range))
      return false;
    return true;
  }
  createElement(tagName, attributes = {}) {
    const element2 = this.win.document.createElement(tagName);
    for (const attributeName in attributes) {
      const attributeValue = attributes[attributeName];
      element2.setAttribute(attributeName, attributeValue);
    }
    return element2;
  }
  createTextNode(text2) {
    return this.win.document.createTextNode(text2);
  }
  adoptElement(node) {
    return adoptElement(node, this.win.document);
  }
  triggerChange() {
    const event2 = document.createEvent("HTMLEvents");
    event2.initEvent("formatEditable", true, false);
    this.host.dispatchEvent(event2);
  }
}
function getRangeBoundingClientRect(range2, win) {
  if (range2.startContainer.nodeType !== elementNode)
    return range2.getBoundingClientRect();
  const el2 = win.document.createElement("span");
  el2.setAttribute("doc-editable", "unwrap");
  range2.insertNode(el2);
  const coords = el2.getBoundingClientRect();
  el2.remove();
  return coords;
}
function isCloseTo(a, b) {
  if (a === b)
    return true;
  if (Math.abs(a - b) <= 2)
    return true;
  return false;
}
var rangyTextrange = { exports: {} };
(function(module2, exports2) {
  (function(factory2, root2) {
    {
      module2.exports = factory2(rangyCore.exports);
    }
  })(function(rangy2) {
    rangy2.createModule("TextRange", ["WrappedSelection"], function(api, module3) {
      var UNDEF = "undefined";
      var CHARACTER = "character", WORD = "word";
      var dom = api.dom, util2 = api.util;
      var extend3 = util2.extend;
      var createOptions = util2.createOptions;
      var getBody = dom.getBody;
      var spacesRegex = /^[ \t\f\r\n]+$/;
      var spacesMinusLineBreaksRegex = /^[ \t\f\r]+$/;
      var allWhiteSpaceRegex = /^[\t-\r \u0085\u00A0\u1680\u180E\u2000-\u200B\u2028\u2029\u202F\u205F\u3000]+$/;
      var nonLineBreakWhiteSpaceRegex = /^[\t \u00A0\u1680\u180E\u2000-\u200B\u202F\u205F\u3000]+$/;
      var defaultLanguage = "en";
      var isDirectionBackward = api.Selection.isDirectionBackward;
      var trailingSpaceBeforeBrCollapses = false;
      var trailingSpaceBeforeBlockCollapses = false;
      var trailingSpaceBeforeLineBreakInPreLineCollapses = true;
      (function() {
        var el2 = dom.createTestElement(document, "<p>1 </p><p></p>", true);
        var p2 = el2.firstChild;
        var sel = api.getSelection();
        sel.collapse(p2.lastChild, 2);
        sel.setStart(p2.firstChild, 0);
        el2.innerHTML = "1 <br />";
        sel.collapse(el2, 2);
        sel.setStart(el2.firstChild, 0);
        trailingSpaceBeforeBrCollapses = ("" + sel).length == 1;
        el2.innerHTML = "1 <p>1</p>";
        sel.collapse(el2, 2);
        sel.setStart(el2.firstChild, 0);
        trailingSpaceBeforeBlockCollapses = ("" + sel).length == 1;
        dom.removeNode(el2);
        sel.removeAllRanges();
      })();
      function defaultTokenizer(chars, wordOptions) {
        var word = chars.join(""), result2, tokenRanges = [];
        function createTokenRange(start, end, isWord) {
          tokenRanges.push({ start, end, isWord });
        }
        var lastWordEnd = 0, wordStart, wordEnd;
        while (result2 = wordOptions.wordRegex.exec(word)) {
          wordStart = result2.index;
          wordEnd = wordStart + result2[0].length;
          if (wordStart > lastWordEnd) {
            createTokenRange(lastWordEnd, wordStart, false);
          }
          if (wordOptions.includeTrailingSpace) {
            while (nonLineBreakWhiteSpaceRegex.test(chars[wordEnd])) {
              ++wordEnd;
            }
          }
          createTokenRange(wordStart, wordEnd, true);
          lastWordEnd = wordEnd;
        }
        if (lastWordEnd < chars.length) {
          createTokenRange(lastWordEnd, chars.length, false);
        }
        return tokenRanges;
      }
      function convertCharRangeToToken(chars, tokenRange) {
        var tokenChars = chars.slice(tokenRange.start, tokenRange.end);
        var token = {
          isWord: tokenRange.isWord,
          chars: tokenChars,
          toString: function() {
            return tokenChars.join("");
          }
        };
        for (var i2 = 0, len = tokenChars.length; i2 < len; ++i2) {
          tokenChars[i2].token = token;
        }
        return token;
      }
      function tokenize(chars, wordOptions, tokenizer) {
        var tokenRanges = tokenizer(chars, wordOptions);
        var tokens2 = [];
        for (var i2 = 0, tokenRange; tokenRange = tokenRanges[i2++]; ) {
          tokens2.push(convertCharRangeToToken(chars, tokenRange));
        }
        return tokens2;
      }
      var defaultCharacterOptions = {
        includeBlockContentTrailingSpace: true,
        includeSpaceBeforeBr: true,
        includeSpaceBeforeBlock: true,
        includePreLineTrailingSpace: true,
        ignoreCharacters: ""
      };
      function normalizeIgnoredCharacters(ignoredCharacters) {
        var ignoredChars = ignoredCharacters || "";
        var ignoredCharsArray = typeof ignoredChars == "string" ? ignoredChars.split("") : ignoredChars;
        ignoredCharsArray.sort(function(char1, char2) {
          return char1.charCodeAt(0) - char2.charCodeAt(0);
        });
        return ignoredCharsArray.join("").replace(/(.)\1+/g, "$1");
      }
      var defaultCaretCharacterOptions = {
        includeBlockContentTrailingSpace: !trailingSpaceBeforeLineBreakInPreLineCollapses,
        includeSpaceBeforeBr: !trailingSpaceBeforeBrCollapses,
        includeSpaceBeforeBlock: !trailingSpaceBeforeBlockCollapses,
        includePreLineTrailingSpace: true
      };
      var defaultWordOptions = {
        "en": {
          wordRegex: /[a-z0-9]+('[a-z0-9]+)*/gi,
          includeTrailingSpace: false,
          tokenizer: defaultTokenizer
        }
      };
      var defaultFindOptions = {
        caseSensitive: false,
        withinRange: null,
        wholeWordsOnly: false,
        wrap: false,
        direction: "forward",
        wordOptions: null,
        characterOptions: null
      };
      var defaultMoveOptions = {
        wordOptions: null,
        characterOptions: null
      };
      var defaultExpandOptions = {
        wordOptions: null,
        characterOptions: null,
        trim: false,
        trimStart: true,
        trimEnd: true
      };
      var defaultWordIteratorOptions = {
        wordOptions: null,
        characterOptions: null,
        direction: "forward"
      };
      function createWordOptions(options2) {
        var lang, defaults2;
        if (!options2) {
          return defaultWordOptions[defaultLanguage];
        } else {
          lang = options2.language || defaultLanguage;
          defaults2 = {};
          extend3(defaults2, defaultWordOptions[lang] || defaultWordOptions[defaultLanguage]);
          extend3(defaults2, options2);
          return defaults2;
        }
      }
      function createNestedOptions(optionsParam, defaults2) {
        var options2 = createOptions(optionsParam, defaults2);
        if (defaults2.hasOwnProperty("wordOptions")) {
          options2.wordOptions = createWordOptions(options2.wordOptions);
        }
        if (defaults2.hasOwnProperty("characterOptions")) {
          options2.characterOptions = createOptions(options2.characterOptions, defaultCharacterOptions);
        }
        return options2;
      }
      var getComputedStyleProperty = dom.getComputedStyleProperty;
      var tableCssDisplayBlock;
      (function() {
        var table = document.createElement("table");
        var body2 = getBody(document);
        body2.appendChild(table);
        tableCssDisplayBlock = getComputedStyleProperty(table, "display") == "block";
        body2.removeChild(table);
      })();
      var defaultDisplayValueForTag = {
        table: "table",
        caption: "table-caption",
        colgroup: "table-column-group",
        col: "table-column",
        thead: "table-header-group",
        tbody: "table-row-group",
        tfoot: "table-footer-group",
        tr: "table-row",
        td: "table-cell",
        th: "table-cell"
      };
      function getComputedDisplay(el2, win) {
        var display2 = getComputedStyleProperty(el2, "display", win);
        var tagName = el2.tagName.toLowerCase();
        return display2 == "block" && tableCssDisplayBlock && defaultDisplayValueForTag.hasOwnProperty(tagName) ? defaultDisplayValueForTag[tagName] : display2;
      }
      function isHidden2(node) {
        var ancestors = getAncestorsAndSelf(node);
        for (var i2 = 0, len = ancestors.length; i2 < len; ++i2) {
          if (ancestors[i2].nodeType == 1 && getComputedDisplay(ancestors[i2]) == "none") {
            return true;
          }
        }
        return false;
      }
      function isVisibilityHiddenTextNode(textNode2) {
        var el2;
        return textNode2.nodeType == 3 && (el2 = textNode2.parentNode) && getComputedStyleProperty(el2, "visibility") == "hidden";
      }
      function isBlockNode(node) {
        return node && (node.nodeType == 1 && !/^(inline(-block|-table)?|none)$/.test(getComputedDisplay(node)) || node.nodeType == 9 || node.nodeType == 11);
      }
      function containsPositions(node) {
        return dom.isCharacterDataNode(node) || !/^(area|base|basefont|br|col|frame|hr|img|input|isindex|link|meta|param)$/i.test(node.nodeName);
      }
      function getAncestors(node) {
        var ancestors = [];
        while (node.parentNode) {
          ancestors.unshift(node.parentNode);
          node = node.parentNode;
        }
        return ancestors;
      }
      function getAncestorsAndSelf(node) {
        return getAncestors(node).concat([node]);
      }
      function nextNodeDescendants(node) {
        while (node && !node.nextSibling) {
          node = node.parentNode;
        }
        if (!node) {
          return null;
        }
        return node.nextSibling;
      }
      function nextNode(node, excludeChildren) {
        if (!excludeChildren && node.hasChildNodes()) {
          return node.firstChild;
        }
        return nextNodeDescendants(node);
      }
      function previousNode(node) {
        var previous2 = node.previousSibling;
        if (previous2) {
          node = previous2;
          while (node.hasChildNodes()) {
            node = node.lastChild;
          }
          return node;
        }
        var parent = node.parentNode;
        if (parent && parent.nodeType == 1) {
          return parent;
        }
        return null;
      }
      function isWhitespaceNode(node) {
        if (!node || node.nodeType != 3) {
          return false;
        }
        var text2 = node.data;
        if (text2 === "") {
          return true;
        }
        var parent = node.parentNode;
        if (!parent || parent.nodeType != 1) {
          return false;
        }
        var computedWhiteSpace = getComputedStyleProperty(node.parentNode, "whiteSpace");
        return /^[\t\n\r ]+$/.test(text2) && /^(normal|nowrap)$/.test(computedWhiteSpace) || /^[\t\r ]+$/.test(text2) && computedWhiteSpace == "pre-line";
      }
      function isCollapsedWhitespaceNode(node) {
        if (node.data === "") {
          return true;
        }
        if (!isWhitespaceNode(node)) {
          return false;
        }
        var ancestor = node.parentNode;
        if (!ancestor) {
          return true;
        }
        if (isHidden2(node)) {
          return true;
        }
        return false;
      }
      function isCollapsedNode(node) {
        var type2 = node.nodeType;
        return type2 == 7 || type2 == 8 || isHidden2(node) || /^(script|style)$/i.test(node.nodeName) || isVisibilityHiddenTextNode(node) || isCollapsedWhitespaceNode(node);
      }
      function isIgnoredNode(node, win) {
        var type2 = node.nodeType;
        return type2 == 7 || type2 == 8 || type2 == 1 && getComputedDisplay(node, win) == "none";
      }
      function Cache() {
        this.store = {};
      }
      Cache.prototype = {
        get: function(key) {
          return this.store.hasOwnProperty(key) ? this.store[key] : null;
        },
        set: function(key, value2) {
          return this.store[key] = value2;
        }
      };
      function createCachingGetter(methodName, func, objProperty) {
        return function(args2) {
          var cache2 = this.cache;
          if (cache2.hasOwnProperty(methodName)) {
            return cache2[methodName];
          } else {
            var value2 = func.call(this, objProperty ? this[objProperty] : this, args2);
            cache2[methodName] = value2;
            return value2;
          }
        };
      }
      function NodeWrapper(node, session) {
        this.node = node;
        this.session = session;
        this.cache = new Cache();
        this.positions = new Cache();
      }
      var nodeProto = {
        getPosition: function(offset) {
          var positions = this.positions;
          return positions.get(offset) || positions.set(offset, new Position(this, offset));
        },
        toString: function() {
          return "[NodeWrapper(" + dom.inspectNode(this.node) + ")]";
        }
      };
      NodeWrapper.prototype = nodeProto;
      var EMPTY = "EMPTY", NON_SPACE = "NON_SPACE", UNCOLLAPSIBLE_SPACE = "UNCOLLAPSIBLE_SPACE", COLLAPSIBLE_SPACE = "COLLAPSIBLE_SPACE", TRAILING_SPACE_BEFORE_BLOCK = "TRAILING_SPACE_BEFORE_BLOCK", TRAILING_SPACE_IN_BLOCK = "TRAILING_SPACE_IN_BLOCK", TRAILING_SPACE_BEFORE_BR = "TRAILING_SPACE_BEFORE_BR", PRE_LINE_TRAILING_SPACE_BEFORE_LINE_BREAK = "PRE_LINE_TRAILING_SPACE_BEFORE_LINE_BREAK", TRAILING_LINE_BREAK_AFTER_BR = "TRAILING_LINE_BREAK_AFTER_BR", INCLUDED_TRAILING_LINE_BREAK_AFTER_BR = "INCLUDED_TRAILING_LINE_BREAK_AFTER_BR";
      extend3(nodeProto, {
        isCharacterDataNode: createCachingGetter("isCharacterDataNode", dom.isCharacterDataNode, "node"),
        getNodeIndex: createCachingGetter("nodeIndex", dom.getNodeIndex, "node"),
        getLength: createCachingGetter("nodeLength", dom.getNodeLength, "node"),
        containsPositions: createCachingGetter("containsPositions", containsPositions, "node"),
        isWhitespace: createCachingGetter("isWhitespace", isWhitespaceNode, "node"),
        isCollapsedWhitespace: createCachingGetter("isCollapsedWhitespace", isCollapsedWhitespaceNode, "node"),
        getComputedDisplay: createCachingGetter("computedDisplay", getComputedDisplay, "node"),
        isCollapsed: createCachingGetter("collapsed", isCollapsedNode, "node"),
        isIgnored: createCachingGetter("ignored", isIgnoredNode, "node"),
        next: createCachingGetter("nextPos", nextNode, "node"),
        previous: createCachingGetter("previous", previousNode, "node"),
        getTextNodeInfo: createCachingGetter("textNodeInfo", function(textNode2) {
          var spaceRegex = null, collapseSpaces = false;
          var cssWhitespace = getComputedStyleProperty(textNode2.parentNode, "whiteSpace");
          var preLine = cssWhitespace == "pre-line";
          if (preLine) {
            spaceRegex = spacesMinusLineBreaksRegex;
            collapseSpaces = true;
          } else if (cssWhitespace == "normal" || cssWhitespace == "nowrap") {
            spaceRegex = spacesRegex;
            collapseSpaces = true;
          }
          return {
            node: textNode2,
            text: textNode2.data,
            spaceRegex,
            collapseSpaces,
            preLine
          };
        }, "node"),
        hasInnerText: createCachingGetter("hasInnerText", function(el2, backward) {
          var session = this.session;
          var posAfterEl = session.getPosition(el2.parentNode, this.getNodeIndex() + 1);
          var firstPosInEl = session.getPosition(el2, 0);
          var pos = backward ? posAfterEl : firstPosInEl;
          var endPos = backward ? firstPosInEl : posAfterEl;
          while (pos !== endPos) {
            pos.prepopulateChar();
            if (pos.isDefinitelyNonEmpty()) {
              return true;
            }
            pos = backward ? pos.previousVisible() : pos.nextVisible();
          }
          return false;
        }, "node"),
        isRenderedBlock: createCachingGetter("isRenderedBlock", function(el2) {
          var brs = el2.getElementsByTagName("br");
          for (var i2 = 0, len = brs.length; i2 < len; ++i2) {
            if (!isCollapsedNode(brs[i2])) {
              return true;
            }
          }
          return this.hasInnerText();
        }, "node"),
        getTrailingSpace: createCachingGetter("trailingSpace", function(el2) {
          if (el2.tagName.toLowerCase() == "br") {
            return "";
          } else {
            switch (this.getComputedDisplay()) {
              case "inline":
                var child = el2.lastChild;
                while (child) {
                  if (!isIgnoredNode(child)) {
                    return child.nodeType == 1 ? this.session.getNodeWrapper(child).getTrailingSpace() : "";
                  }
                  child = child.previousSibling;
                }
                break;
              case "inline-block":
              case "inline-table":
              case "none":
              case "table-column":
              case "table-column-group":
                break;
              case "table-cell":
                return "	";
              default:
                return this.isRenderedBlock(true) ? "\n" : "";
            }
          }
          return "";
        }, "node"),
        getLeadingSpace: createCachingGetter("leadingSpace", function(el2) {
          switch (this.getComputedDisplay()) {
            case "inline":
            case "inline-block":
            case "inline-table":
            case "none":
            case "table-column":
            case "table-column-group":
            case "table-cell":
              break;
            default:
              return this.isRenderedBlock(false) ? "\n" : "";
          }
          return "";
        }, "node")
      });
      function Position(nodeWrapper, offset) {
        this.offset = offset;
        this.nodeWrapper = nodeWrapper;
        this.node = nodeWrapper.node;
        this.session = nodeWrapper.session;
        this.cache = new Cache();
      }
      function inspectPosition() {
        return "[Position(" + dom.inspectNode(this.node) + ":" + this.offset + ")]";
      }
      var positionProto = {
        character: "",
        characterType: EMPTY,
        isBr: false,
        prepopulateChar: function() {
          var pos = this;
          if (!pos.prepopulatedChar) {
            var node = pos.node, offset = pos.offset;
            var visibleChar = "", charType = EMPTY;
            var finalizedChar = false;
            if (offset > 0) {
              if (node.nodeType == 3) {
                var text2 = node.data;
                var textChar = text2.charAt(offset - 1);
                var nodeInfo = pos.nodeWrapper.getTextNodeInfo();
                var spaceRegex = nodeInfo.spaceRegex;
                if (nodeInfo.collapseSpaces) {
                  if (spaceRegex.test(textChar)) {
                    if (offset > 1 && spaceRegex.test(text2.charAt(offset - 2)))
                      ;
                    else if (nodeInfo.preLine && text2.charAt(offset) === "\n") {
                      visibleChar = " ";
                      charType = PRE_LINE_TRAILING_SPACE_BEFORE_LINE_BREAK;
                    } else {
                      visibleChar = " ";
                      charType = COLLAPSIBLE_SPACE;
                    }
                  } else {
                    visibleChar = textChar;
                    charType = NON_SPACE;
                    finalizedChar = true;
                  }
                } else {
                  visibleChar = textChar;
                  charType = UNCOLLAPSIBLE_SPACE;
                  finalizedChar = true;
                }
              } else {
                var nodePassed = node.childNodes[offset - 1];
                if (nodePassed && nodePassed.nodeType == 1 && !isCollapsedNode(nodePassed)) {
                  if (nodePassed.tagName.toLowerCase() == "br") {
                    visibleChar = "\n";
                    pos.isBr = true;
                    charType = COLLAPSIBLE_SPACE;
                    finalizedChar = false;
                  } else {
                    pos.checkForTrailingSpace = true;
                  }
                }
                if (!visibleChar) {
                  var nextNode2 = node.childNodes[offset];
                  if (nextNode2 && nextNode2.nodeType == 1 && !isCollapsedNode(nextNode2)) {
                    pos.checkForLeadingSpace = true;
                  }
                }
              }
            }
            pos.prepopulatedChar = true;
            pos.character = visibleChar;
            pos.characterType = charType;
            pos.isCharInvariant = finalizedChar;
          }
        },
        isDefinitelyNonEmpty: function() {
          var charType = this.characterType;
          return charType == NON_SPACE || charType == UNCOLLAPSIBLE_SPACE;
        },
        resolveLeadingAndTrailingSpaces: function() {
          if (!this.prepopulatedChar) {
            this.prepopulateChar();
          }
          if (this.checkForTrailingSpace) {
            var trailingSpace = this.session.getNodeWrapper(this.node.childNodes[this.offset - 1]).getTrailingSpace();
            if (trailingSpace) {
              this.isTrailingSpace = true;
              this.character = trailingSpace;
              this.characterType = COLLAPSIBLE_SPACE;
            }
            this.checkForTrailingSpace = false;
          }
          if (this.checkForLeadingSpace) {
            var leadingSpace = this.session.getNodeWrapper(this.node.childNodes[this.offset]).getLeadingSpace();
            if (leadingSpace) {
              this.isLeadingSpace = true;
              this.character = leadingSpace;
              this.characterType = COLLAPSIBLE_SPACE;
            }
            this.checkForLeadingSpace = false;
          }
        },
        getPrecedingUncollapsedPosition: function(characterOptions) {
          var pos = this, character;
          while (pos = pos.previousVisible()) {
            character = pos.getCharacter(characterOptions);
            if (character !== "") {
              return pos;
            }
          }
          return null;
        },
        getCharacter: function(characterOptions) {
          this.resolveLeadingAndTrailingSpaces();
          var thisChar = this.character, returnChar;
          var ignoredChars = normalizeIgnoredCharacters(characterOptions.ignoreCharacters);
          var isIgnoredCharacter = thisChar !== "" && ignoredChars.indexOf(thisChar) > -1;
          if (this.isCharInvariant) {
            returnChar = isIgnoredCharacter ? "" : thisChar;
            return returnChar;
          }
          var cacheKey = ["character", characterOptions.includeSpaceBeforeBr, characterOptions.includeBlockContentTrailingSpace, characterOptions.includePreLineTrailingSpace, ignoredChars].join("_");
          var cachedChar = this.cache.get(cacheKey);
          if (cachedChar !== null) {
            return cachedChar;
          }
          var character = "";
          var collapsible = this.characterType == COLLAPSIBLE_SPACE;
          var nextPos, previousPos;
          var gotPreviousPos = false;
          var pos = this;
          function getPreviousPos() {
            if (!gotPreviousPos) {
              previousPos = pos.getPrecedingUncollapsedPosition(characterOptions);
              gotPreviousPos = true;
            }
            return previousPos;
          }
          if (collapsible) {
            if (this.type == INCLUDED_TRAILING_LINE_BREAK_AFTER_BR) {
              character = "\n";
            } else if (thisChar == " " && (!getPreviousPos() || previousPos.isTrailingSpace || previousPos.character == "\n" || previousPos.character == " " && previousPos.characterType == COLLAPSIBLE_SPACE))
              ;
            else if (thisChar == "\n" && this.isLeadingSpace) {
              if (getPreviousPos() && previousPos.character != "\n") {
                character = "\n";
              }
            } else {
              nextPos = this.nextUncollapsed();
              if (nextPos) {
                if (nextPos.isBr) {
                  this.type = TRAILING_SPACE_BEFORE_BR;
                } else if (nextPos.isTrailingSpace && nextPos.character == "\n") {
                  this.type = TRAILING_SPACE_IN_BLOCK;
                } else if (nextPos.isLeadingSpace && nextPos.character == "\n") {
                  this.type = TRAILING_SPACE_BEFORE_BLOCK;
                }
                if (nextPos.character == "\n") {
                  if (this.type == TRAILING_SPACE_BEFORE_BR && !characterOptions.includeSpaceBeforeBr)
                    ;
                  else if (this.type == TRAILING_SPACE_BEFORE_BLOCK && !characterOptions.includeSpaceBeforeBlock)
                    ;
                  else if (this.type == TRAILING_SPACE_IN_BLOCK && nextPos.isTrailingSpace && !characterOptions.includeBlockContentTrailingSpace)
                    ;
                  else if (this.type == PRE_LINE_TRAILING_SPACE_BEFORE_LINE_BREAK && nextPos.type == NON_SPACE && !characterOptions.includePreLineTrailingSpace)
                    ;
                  else if (thisChar == "\n") {
                    if (nextPos.isTrailingSpace) {
                      if (this.isTrailingSpace)
                        ;
                      else if (this.isBr) {
                        nextPos.type = TRAILING_LINE_BREAK_AFTER_BR;
                        if (getPreviousPos() && previousPos.isLeadingSpace && !previousPos.isTrailingSpace && previousPos.character == "\n") {
                          nextPos.character = "";
                        } else {
                          nextPos.type = INCLUDED_TRAILING_LINE_BREAK_AFTER_BR;
                        }
                      }
                    } else {
                      character = "\n";
                    }
                  } else if (thisChar == " ") {
                    character = " ";
                  } else
                    ;
                } else {
                  character = thisChar;
                }
              }
            }
          }
          if (ignoredChars.indexOf(character) > -1) {
            character = "";
          }
          this.cache.set(cacheKey, character);
          return character;
        },
        equals: function(pos) {
          return !!pos && this.node === pos.node && this.offset === pos.offset;
        },
        inspect: inspectPosition,
        toString: function() {
          return this.character;
        }
      };
      Position.prototype = positionProto;
      extend3(positionProto, {
        next: createCachingGetter("nextPos", function(pos) {
          var nodeWrapper = pos.nodeWrapper, node = pos.node, offset = pos.offset, session = nodeWrapper.session;
          if (!node) {
            return null;
          }
          var nextNode2, nextOffset, child;
          if (offset == nodeWrapper.getLength()) {
            nextNode2 = node.parentNode;
            nextOffset = nextNode2 ? nodeWrapper.getNodeIndex() + 1 : 0;
          } else {
            if (nodeWrapper.isCharacterDataNode()) {
              nextNode2 = node;
              nextOffset = offset + 1;
            } else {
              child = node.childNodes[offset];
              if (session.getNodeWrapper(child).containsPositions()) {
                nextNode2 = child;
                nextOffset = 0;
              } else {
                nextNode2 = node;
                nextOffset = offset + 1;
              }
            }
          }
          return nextNode2 ? session.getPosition(nextNode2, nextOffset) : null;
        }),
        previous: createCachingGetter("previous", function(pos) {
          var nodeWrapper = pos.nodeWrapper, node = pos.node, offset = pos.offset, session = nodeWrapper.session;
          var previousNode2, previousOffset, child;
          if (offset == 0) {
            previousNode2 = node.parentNode;
            previousOffset = previousNode2 ? nodeWrapper.getNodeIndex() : 0;
          } else {
            if (nodeWrapper.isCharacterDataNode()) {
              previousNode2 = node;
              previousOffset = offset - 1;
            } else {
              child = node.childNodes[offset - 1];
              if (session.getNodeWrapper(child).containsPositions()) {
                previousNode2 = child;
                previousOffset = dom.getNodeLength(child);
              } else {
                previousNode2 = node;
                previousOffset = offset - 1;
              }
            }
          }
          return previousNode2 ? session.getPosition(previousNode2, previousOffset) : null;
        }),
        nextVisible: createCachingGetter("nextVisible", function(pos) {
          var next2 = pos.next();
          if (!next2) {
            return null;
          }
          var nodeWrapper = next2.nodeWrapper, node = next2.node;
          var newPos = next2;
          if (nodeWrapper.isCollapsed()) {
            newPos = nodeWrapper.session.getPosition(node.parentNode, nodeWrapper.getNodeIndex() + 1);
          }
          return newPos;
        }),
        nextUncollapsed: createCachingGetter("nextUncollapsed", function(pos) {
          var nextPos = pos;
          while (nextPos = nextPos.nextVisible()) {
            nextPos.resolveLeadingAndTrailingSpaces();
            if (nextPos.character !== "") {
              return nextPos;
            }
          }
          return null;
        }),
        previousVisible: createCachingGetter("previousVisible", function(pos) {
          var previous2 = pos.previous();
          if (!previous2) {
            return null;
          }
          var nodeWrapper = previous2.nodeWrapper, node = previous2.node;
          var newPos = previous2;
          if (nodeWrapper.isCollapsed()) {
            newPos = nodeWrapper.session.getPosition(node.parentNode, nodeWrapper.getNodeIndex());
          }
          return newPos;
        })
      });
      var currentSession = null;
      var Session = function() {
        function createWrapperCache(nodeProperty) {
          var cache2 = new Cache();
          return {
            get: function(node) {
              var wrappersByProperty = cache2.get(node[nodeProperty]);
              if (wrappersByProperty) {
                for (var i2 = 0, wrapper; wrapper = wrappersByProperty[i2++]; ) {
                  if (wrapper.node === node) {
                    return wrapper;
                  }
                }
              }
              return null;
            },
            set: function(nodeWrapper) {
              var property2 = nodeWrapper.node[nodeProperty];
              var wrappersByProperty = cache2.get(property2) || cache2.set(property2, []);
              wrappersByProperty.push(nodeWrapper);
            }
          };
        }
        var uniqueIDSupported = util2.isHostProperty(document.documentElement, "uniqueID");
        function Session2() {
          this.initCaches();
        }
        Session2.prototype = {
          initCaches: function() {
            this.elementCache = uniqueIDSupported ? function() {
              var elementsCache = new Cache();
              return {
                get: function(el2) {
                  return elementsCache.get(el2.uniqueID);
                },
                set: function(elWrapper) {
                  elementsCache.set(elWrapper.node.uniqueID, elWrapper);
                }
              };
            }() : createWrapperCache("tagName");
            this.textNodeCache = createWrapperCache("data");
            this.otherNodeCache = createWrapperCache("nodeName");
          },
          getNodeWrapper: function(node) {
            var wrapperCache;
            switch (node.nodeType) {
              case 1:
                wrapperCache = this.elementCache;
                break;
              case 3:
                wrapperCache = this.textNodeCache;
                break;
              default:
                wrapperCache = this.otherNodeCache;
                break;
            }
            var wrapper = wrapperCache.get(node);
            if (!wrapper) {
              wrapper = new NodeWrapper(node, this);
              wrapperCache.set(wrapper);
            }
            return wrapper;
          },
          getPosition: function(node, offset) {
            return this.getNodeWrapper(node).getPosition(offset);
          },
          getRangeBoundaryPosition: function(range2, isStart) {
            var prefix = isStart ? "start" : "end";
            return this.getPosition(range2[prefix + "Container"], range2[prefix + "Offset"]);
          },
          detach: function() {
            this.elementCache = this.textNodeCache = this.otherNodeCache = null;
          }
        };
        return Session2;
      }();
      function startSession() {
        endSession();
        return currentSession = new Session();
      }
      function getSession() {
        return currentSession || startSession();
      }
      function endSession() {
        if (currentSession) {
          currentSession.detach();
        }
        currentSession = null;
      }
      extend3(dom, {
        nextNode,
        previousNode
      });
      function createCharacterIterator(startPos, backward, endPos, characterOptions) {
        if (endPos) {
          if (backward) {
            if (isCollapsedNode(endPos.node)) {
              endPos = startPos.previousVisible();
            }
          } else {
            if (isCollapsedNode(endPos.node)) {
              endPos = endPos.nextVisible();
            }
          }
        }
        var pos = startPos, finished = false;
        function next2() {
          var charPos = null;
          if (backward) {
            charPos = pos;
            if (!finished) {
              pos = pos.previousVisible();
              finished = !pos || endPos && pos.equals(endPos);
            }
          } else {
            if (!finished) {
              charPos = pos = pos.nextVisible();
              finished = !pos || endPos && pos.equals(endPos);
            }
          }
          if (finished) {
            pos = null;
          }
          return charPos;
        }
        var previousTextPos, returnPreviousTextPos = false;
        return {
          next: function() {
            if (returnPreviousTextPos) {
              returnPreviousTextPos = false;
              return previousTextPos;
            } else {
              var pos2, character;
              while (pos2 = next2()) {
                character = pos2.getCharacter(characterOptions);
                if (character) {
                  previousTextPos = pos2;
                  return pos2;
                }
              }
              return null;
            }
          },
          rewind: function() {
            if (previousTextPos) {
              returnPreviousTextPos = true;
            } else {
              throw module3.createError("createCharacterIterator: cannot rewind. Only one position can be rewound.");
            }
          },
          dispose: function() {
            startPos = endPos = null;
          }
        };
      }
      var arrayIndexOf = Array.prototype.indexOf ? function(arr, val) {
        return arr.indexOf(val);
      } : function(arr, val) {
        for (var i2 = 0, len = arr.length; i2 < len; ++i2) {
          if (arr[i2] === val) {
            return i2;
          }
        }
        return -1;
      };
      function createTokenizedTextProvider(pos, characterOptions, wordOptions) {
        var forwardIterator = createCharacterIterator(pos, false, null, characterOptions);
        var backwardIterator = createCharacterIterator(pos, true, null, characterOptions);
        var tokenizer = wordOptions.tokenizer;
        function consumeWord(forward) {
          var pos2, textChar;
          var newChars = [], it = forward ? forwardIterator : backwardIterator;
          var passedWordBoundary = false, insideWord = false;
          while (pos2 = it.next()) {
            textChar = pos2.character;
            if (allWhiteSpaceRegex.test(textChar)) {
              if (insideWord) {
                insideWord = false;
                passedWordBoundary = true;
              }
            } else {
              if (passedWordBoundary) {
                it.rewind();
                break;
              } else {
                insideWord = true;
              }
            }
            newChars.push(pos2);
          }
          return newChars;
        }
        var forwardChars = consumeWord(true);
        var backwardChars = consumeWord(false).reverse();
        var tokens2 = tokenize(backwardChars.concat(forwardChars), wordOptions, tokenizer);
        var forwardTokensBuffer = forwardChars.length ? tokens2.slice(arrayIndexOf(tokens2, forwardChars[0].token)) : [];
        var backwardTokensBuffer = backwardChars.length ? tokens2.slice(0, arrayIndexOf(tokens2, backwardChars.pop().token) + 1) : [];
        return {
          nextEndToken: function() {
            var lastToken, forwardChars2;
            while (forwardTokensBuffer.length == 1 && !(lastToken = forwardTokensBuffer[0]).isWord && (forwardChars2 = consumeWord(true)).length > 0) {
              forwardTokensBuffer = tokenize(lastToken.chars.concat(forwardChars2), wordOptions, tokenizer);
            }
            return forwardTokensBuffer.shift();
          },
          previousStartToken: function() {
            var lastToken, backwardChars2;
            while (backwardTokensBuffer.length == 1 && !(lastToken = backwardTokensBuffer[0]).isWord && (backwardChars2 = consumeWord(false)).length > 0) {
              backwardTokensBuffer = tokenize(backwardChars2.reverse().concat(lastToken.chars), wordOptions, tokenizer);
            }
            return backwardTokensBuffer.pop();
          },
          dispose: function() {
            forwardIterator.dispose();
            backwardIterator.dispose();
            forwardTokensBuffer = backwardTokensBuffer = null;
          }
        };
      }
      function movePositionBy(pos, unit, count, characterOptions, wordOptions) {
        var unitsMoved = 0, currentPos, newPos = pos, charIterator, nextPos, absCount = Math.abs(count), token;
        if (count !== 0) {
          var backward = count < 0;
          switch (unit) {
            case CHARACTER:
              charIterator = createCharacterIterator(pos, backward, null, characterOptions);
              while ((currentPos = charIterator.next()) && unitsMoved < absCount) {
                ++unitsMoved;
                newPos = currentPos;
              }
              nextPos = currentPos;
              charIterator.dispose();
              break;
            case WORD:
              var tokenizedTextProvider = createTokenizedTextProvider(pos, characterOptions, wordOptions);
              var next2 = backward ? tokenizedTextProvider.previousStartToken : tokenizedTextProvider.nextEndToken;
              while ((token = next2()) && unitsMoved < absCount) {
                if (token.isWord) {
                  ++unitsMoved;
                  newPos = backward ? token.chars[0] : token.chars[token.chars.length - 1];
                }
              }
              break;
            default:
              throw new Error("movePositionBy: unit '" + unit + "' not implemented");
          }
          if (backward) {
            newPos = newPos.previousVisible();
            unitsMoved = -unitsMoved;
          } else if (newPos && newPos.isLeadingSpace && !newPos.isTrailingSpace) {
            if (unit == WORD) {
              charIterator = createCharacterIterator(pos, false, null, characterOptions);
              nextPos = charIterator.next();
              charIterator.dispose();
            }
            if (nextPos) {
              newPos = nextPos.previousVisible();
            }
          }
        }
        return {
          position: newPos,
          unitsMoved
        };
      }
      function createRangeCharacterIterator(session, range2, characterOptions, backward) {
        var rangeStart = session.getRangeBoundaryPosition(range2, true);
        var rangeEnd = session.getRangeBoundaryPosition(range2, false);
        var itStart = backward ? rangeEnd : rangeStart;
        var itEnd = backward ? rangeStart : rangeEnd;
        return createCharacterIterator(itStart, !!backward, itEnd, characterOptions);
      }
      function getRangeCharacters(session, range2, characterOptions) {
        var chars = [], it = createRangeCharacterIterator(session, range2, characterOptions), pos;
        while (pos = it.next()) {
          chars.push(pos);
        }
        it.dispose();
        return chars;
      }
      function isWholeWord(startPos, endPos, wordOptions) {
        var range2 = api.createRange(startPos.node);
        range2.setStartAndEnd(startPos.node, startPos.offset, endPos.node, endPos.offset);
        return !range2.expand("word", { wordOptions });
      }
      function findTextFromPosition(initialPos, searchTerm, isRegex, searchScopeRange, findOptions) {
        var backward = isDirectionBackward(findOptions.direction);
        var it = createCharacterIterator(initialPos, backward, initialPos.session.getRangeBoundaryPosition(searchScopeRange, backward), findOptions.characterOptions);
        var text2 = "", chars = [], pos, currentChar, matchStartIndex, matchEndIndex;
        var result2, insideRegexMatch;
        var returnValue2 = null;
        function handleMatch(startIndex, endIndex) {
          var startPos = chars[startIndex].previousVisible();
          var endPos = chars[endIndex - 1];
          var valid = !findOptions.wholeWordsOnly || isWholeWord(startPos, endPos, findOptions.wordOptions);
          return {
            startPos,
            endPos,
            valid
          };
        }
        while (pos = it.next()) {
          currentChar = pos.character;
          if (!isRegex && !findOptions.caseSensitive) {
            currentChar = currentChar.toLowerCase();
          }
          if (backward) {
            chars.unshift(pos);
            text2 = currentChar + text2;
          } else {
            chars.push(pos);
            text2 += currentChar;
          }
          if (isRegex) {
            result2 = searchTerm.exec(text2);
            if (result2) {
              matchStartIndex = result2.index;
              matchEndIndex = matchStartIndex + result2[0].length;
              if (insideRegexMatch) {
                if (!backward && matchEndIndex < text2.length || backward && matchStartIndex > 0) {
                  returnValue2 = handleMatch(matchStartIndex, matchEndIndex);
                  break;
                }
              } else {
                insideRegexMatch = true;
              }
            }
          } else if ((matchStartIndex = text2.indexOf(searchTerm)) != -1) {
            returnValue2 = handleMatch(matchStartIndex, matchStartIndex + searchTerm.length);
            break;
          }
        }
        if (insideRegexMatch) {
          returnValue2 = handleMatch(matchStartIndex, matchEndIndex);
        }
        it.dispose();
        return returnValue2;
      }
      function createEntryPointFunction(func) {
        return function() {
          var sessionRunning = !!currentSession;
          var session = getSession();
          var args2 = [session].concat(util2.toArray(arguments));
          var returnValue2 = func.apply(this, args2);
          if (!sessionRunning) {
            endSession();
          }
          return returnValue2;
        };
      }
      function createRangeBoundaryMover(isStart, collapse) {
        return createEntryPointFunction(function(session, unit, count, moveOptions) {
          if (typeof count == UNDEF) {
            count = unit;
            unit = CHARACTER;
          }
          moveOptions = createNestedOptions(moveOptions, defaultMoveOptions);
          var boundaryIsStart = isStart;
          if (collapse) {
            boundaryIsStart = count >= 0;
            this.collapse(!boundaryIsStart);
          }
          var moveResult = movePositionBy(session.getRangeBoundaryPosition(this, boundaryIsStart), unit, count, moveOptions.characterOptions, moveOptions.wordOptions);
          var newPos = moveResult.position;
          this[boundaryIsStart ? "setStart" : "setEnd"](newPos.node, newPos.offset);
          return moveResult.unitsMoved;
        });
      }
      function createRangeTrimmer(isStart) {
        return createEntryPointFunction(function(session, characterOptions) {
          characterOptions = createOptions(characterOptions, defaultCharacterOptions);
          var pos;
          var it = createRangeCharacterIterator(session, this, characterOptions, !isStart);
          var trimCharCount = 0;
          while ((pos = it.next()) && allWhiteSpaceRegex.test(pos.character)) {
            ++trimCharCount;
          }
          it.dispose();
          var trimmed = trimCharCount > 0;
          if (trimmed) {
            this[isStart ? "moveStart" : "moveEnd"]("character", isStart ? trimCharCount : -trimCharCount, { characterOptions });
          }
          return trimmed;
        });
      }
      extend3(api.rangePrototype, {
        moveStart: createRangeBoundaryMover(true, false),
        moveEnd: createRangeBoundaryMover(false, false),
        move: createRangeBoundaryMover(true, true),
        trimStart: createRangeTrimmer(true),
        trimEnd: createRangeTrimmer(false),
        trim: createEntryPointFunction(function(session, characterOptions) {
          var startTrimmed = this.trimStart(characterOptions), endTrimmed = this.trimEnd(characterOptions);
          return startTrimmed || endTrimmed;
        }),
        expand: createEntryPointFunction(function(session, unit, expandOptions) {
          var moved2 = false;
          expandOptions = createNestedOptions(expandOptions, defaultExpandOptions);
          var characterOptions = expandOptions.characterOptions;
          if (!unit) {
            unit = CHARACTER;
          }
          if (unit == WORD) {
            var wordOptions = expandOptions.wordOptions;
            var startPos = session.getRangeBoundaryPosition(this, true);
            var endPos = session.getRangeBoundaryPosition(this, false);
            var startTokenizedTextProvider = createTokenizedTextProvider(startPos, characterOptions, wordOptions);
            var startToken = startTokenizedTextProvider.nextEndToken();
            var newStartPos = startToken.chars[0].previousVisible();
            var endToken, newEndPos;
            if (this.collapsed) {
              endToken = startToken;
            } else {
              var endTokenizedTextProvider = createTokenizedTextProvider(endPos, characterOptions, wordOptions);
              endToken = endTokenizedTextProvider.previousStartToken();
            }
            newEndPos = endToken.chars[endToken.chars.length - 1];
            if (!newStartPos.equals(startPos)) {
              this.setStart(newStartPos.node, newStartPos.offset);
              moved2 = true;
            }
            if (newEndPos && !newEndPos.equals(endPos)) {
              this.setEnd(newEndPos.node, newEndPos.offset);
              moved2 = true;
            }
            if (expandOptions.trim) {
              if (expandOptions.trimStart) {
                moved2 = this.trimStart(characterOptions) || moved2;
              }
              if (expandOptions.trimEnd) {
                moved2 = this.trimEnd(characterOptions) || moved2;
              }
            }
            return moved2;
          } else {
            return this.moveEnd(CHARACTER, 1, expandOptions);
          }
        }),
        text: createEntryPointFunction(function(session, characterOptions) {
          return this.collapsed ? "" : getRangeCharacters(session, this, createOptions(characterOptions, defaultCharacterOptions)).join("");
        }),
        selectCharacters: createEntryPointFunction(function(session, containerNode, startIndex, endIndex, characterOptions) {
          var moveOptions = { characterOptions };
          if (!containerNode) {
            containerNode = getBody(this.getDocument());
          }
          this.selectNodeContents(containerNode);
          this.collapse(true);
          this.moveStart("character", startIndex, moveOptions);
          this.collapse(true);
          this.moveEnd("character", endIndex - startIndex, moveOptions);
        }),
        toCharacterRange: createEntryPointFunction(function(session, containerNode, characterOptions) {
          if (!containerNode) {
            containerNode = getBody(this.getDocument());
          }
          var parent = containerNode.parentNode, nodeIndex = dom.getNodeIndex(containerNode);
          var rangeStartsBeforeNode = dom.comparePoints(this.startContainer, this.endContainer, parent, nodeIndex) == -1;
          var rangeBetween = this.cloneRange();
          var startIndex, endIndex;
          if (rangeStartsBeforeNode) {
            rangeBetween.setStartAndEnd(this.startContainer, this.startOffset, parent, nodeIndex);
            startIndex = -rangeBetween.text(characterOptions).length;
          } else {
            rangeBetween.setStartAndEnd(parent, nodeIndex, this.startContainer, this.startOffset);
            startIndex = rangeBetween.text(characterOptions).length;
          }
          endIndex = startIndex + this.text(characterOptions).length;
          return {
            start: startIndex,
            end: endIndex
          };
        }),
        findText: createEntryPointFunction(function(session, searchTermParam, findOptions) {
          findOptions = createNestedOptions(findOptions, defaultFindOptions);
          if (findOptions.wholeWordsOnly) {
            findOptions.wordOptions.includeTrailingSpace = false;
          }
          var backward = isDirectionBackward(findOptions.direction);
          var searchScopeRange = findOptions.withinRange;
          if (!searchScopeRange) {
            searchScopeRange = api.createRange();
            searchScopeRange.selectNodeContents(this.getDocument());
          }
          var searchTerm = searchTermParam, isRegex = false;
          if (typeof searchTerm == "string") {
            if (!findOptions.caseSensitive) {
              searchTerm = searchTerm.toLowerCase();
            }
          } else {
            isRegex = true;
          }
          var initialPos = session.getRangeBoundaryPosition(this, !backward);
          var comparison = searchScopeRange.comparePoint(initialPos.node, initialPos.offset);
          if (comparison === -1) {
            initialPos = session.getRangeBoundaryPosition(searchScopeRange, true);
          } else if (comparison === 1) {
            initialPos = session.getRangeBoundaryPosition(searchScopeRange, false);
          }
          var pos = initialPos;
          var wrappedAround = false;
          var findResult;
          while (true) {
            findResult = findTextFromPosition(pos, searchTerm, isRegex, searchScopeRange, findOptions);
            if (findResult) {
              if (findResult.valid) {
                this.setStartAndEnd(findResult.startPos.node, findResult.startPos.offset, findResult.endPos.node, findResult.endPos.offset);
                return true;
              } else {
                pos = backward ? findResult.startPos : findResult.endPos;
              }
            } else if (findOptions.wrap && !wrappedAround) {
              searchScopeRange = searchScopeRange.cloneRange();
              pos = session.getRangeBoundaryPosition(searchScopeRange, !backward);
              searchScopeRange.setBoundary(initialPos.node, initialPos.offset, backward);
              wrappedAround = true;
            } else {
              return false;
            }
          }
        }),
        pasteHtml: function(html2) {
          this.deleteContents();
          if (html2) {
            var frag = this.createContextualFragment(html2);
            var lastChild2 = frag.lastChild;
            this.insertNode(frag);
            this.collapseAfter(lastChild2);
          }
        }
      });
      function createSelectionTrimmer(methodName) {
        return createEntryPointFunction(function(session, characterOptions) {
          var trimmed = false;
          this.changeEachRange(function(range2) {
            trimmed = range2[methodName](characterOptions) || trimmed;
          });
          return trimmed;
        });
      }
      extend3(api.selectionPrototype, {
        expand: createEntryPointFunction(function(session, unit, expandOptions) {
          this.changeEachRange(function(range2) {
            range2.expand(unit, expandOptions);
          });
        }),
        move: createEntryPointFunction(function(session, unit, count, options2) {
          var unitsMoved = 0;
          if (this.focusNode) {
            this.collapse(this.focusNode, this.focusOffset);
            var range2 = this.getRangeAt(0);
            if (!options2) {
              options2 = {};
            }
            options2.characterOptions = createOptions(options2.characterOptions, defaultCaretCharacterOptions);
            unitsMoved = range2.move(unit, count, options2);
            this.setSingleRange(range2);
          }
          return unitsMoved;
        }),
        trimStart: createSelectionTrimmer("trimStart"),
        trimEnd: createSelectionTrimmer("trimEnd"),
        trim: createSelectionTrimmer("trim"),
        selectCharacters: createEntryPointFunction(function(session, containerNode, startIndex, endIndex, direction, characterOptions) {
          var range2 = api.createRange(containerNode);
          range2.selectCharacters(containerNode, startIndex, endIndex, characterOptions);
          this.setSingleRange(range2, direction);
        }),
        saveCharacterRanges: createEntryPointFunction(function(session, containerNode, characterOptions) {
          var ranges = this.getAllRanges(), rangeCount = ranges.length;
          var rangeInfos = [];
          var backward = rangeCount == 1 && this.isBackward();
          for (var i2 = 0, len = ranges.length; i2 < len; ++i2) {
            rangeInfos[i2] = {
              characterRange: ranges[i2].toCharacterRange(containerNode, characterOptions),
              backward,
              characterOptions
            };
          }
          return rangeInfos;
        }),
        restoreCharacterRanges: createEntryPointFunction(function(session, containerNode, saved) {
          this.removeAllRanges();
          for (var i2 = 0, len = saved.length, range2, rangeInfo, characterRange; i2 < len; ++i2) {
            rangeInfo = saved[i2];
            characterRange = rangeInfo.characterRange;
            range2 = api.createRange(containerNode);
            range2.selectCharacters(containerNode, characterRange.start, characterRange.end, rangeInfo.characterOptions);
            this.addRange(range2, rangeInfo.backward);
          }
        }),
        text: createEntryPointFunction(function(session, characterOptions) {
          var rangeTexts = [];
          for (var i2 = 0, len = this.rangeCount; i2 < len; ++i2) {
            rangeTexts[i2] = this.getRangeAt(i2).text(characterOptions);
          }
          return rangeTexts.join("");
        })
      });
      api.innerText = function(el2, characterOptions) {
        var range2 = api.createRange(el2);
        range2.selectNodeContents(el2);
        var text2 = range2.text(characterOptions);
        return text2;
      };
      api.createWordIterator = function(startNode, startOffset, iteratorOptions) {
        var session = getSession();
        iteratorOptions = createNestedOptions(iteratorOptions, defaultWordIteratorOptions);
        var startPos = session.getPosition(startNode, startOffset);
        var tokenizedTextProvider = createTokenizedTextProvider(startPos, iteratorOptions.characterOptions, iteratorOptions.wordOptions);
        var backward = isDirectionBackward(iteratorOptions.direction);
        return {
          next: function() {
            return backward ? tokenizedTextProvider.previousStartToken() : tokenizedTextProvider.nextEndToken();
          },
          dispose: function() {
            tokenizedTextProvider.dispose();
            this.next = function() {
            };
          }
        };
      };
      api.noMutation = function(func) {
        var session = getSession();
        func(session);
        endSession();
      };
      api.noMutation.createEntryPointFunction = createEntryPointFunction;
      api.textRange = {
        isBlockNode,
        isCollapsedWhitespaceNode,
        createPosition: createEntryPointFunction(function(session, node, offset) {
          return session.getPosition(node, offset);
        })
      };
    });
    return rangy2;
  });
})(rangyTextrange);
class NodeIterator {
  constructor(root2, method) {
    this.current = this.previous = this.nextNode = this.root = root2;
    this.iteratorFunc = this[method || "getNext"];
  }
  [Symbol.iterator]() {
    return this;
  }
  getNextTextNode() {
    let next2;
    while (next2 = this.getNext()) {
      if (next2.nodeType === textNode && next2.data !== "")
        return next2;
    }
  }
  getPreviousTextNode() {
    let prev;
    while (prev = this.getPrevious()) {
      if (prev.nodeType === textNode && prev.data !== "")
        return prev;
    }
  }
  next() {
    const value2 = this.iteratorFunc();
    return value2 ? { value: value2 } : { done: true };
  }
  getNext() {
    let n2 = this.current = this.nextNode;
    let child = this.nextNode = void 0;
    if (this.current) {
      child = n2.firstChild;
      if (child && n2.getAttribute("data-editable") !== "remove") {
        this.nextNode = child;
      } else {
        while (n2 !== this.root && !(this.nextNode = n2.nextSibling)) {
          n2 = n2.parentNode;
        }
      }
    }
    return this.current;
  }
  getPrevious() {
    let n2 = this.current = this.previous;
    let child = this.previous = void 0;
    if (this.current) {
      child = n2.lastChild;
      if (child && n2.getAttribute("data-editable") !== "remove") {
        this.previous = child;
      } else {
        while (n2 !== this.root && !(this.previous = n2.previousSibling)) {
          n2 = n2.parentNode;
        }
      }
    }
    return this.current;
  }
  replaceCurrent(replacement) {
    this.current = replacement;
    this.nextNode = void 0;
    this.previous = void 0;
    let n2 = this.current;
    while (n2 !== this.root && !(this.nextNode = n2.nextSibling)) {
      n2 = n2.parentNode;
    }
  }
}
var highlightText = {
  extractText(element2) {
    let text2 = "";
    getText(element2, (part) => {
      text2 += part;
    });
    return text2;
  },
  highlightMatches(element2, matches2) {
    if (!matches2 || matches2.length === 0) {
      return;
    }
    const iterator = new NodeIterator(element2);
    let currentMatchIndex = 0;
    let totalOffset = 0;
    let currentMatch = matches2[currentMatchIndex];
    let portions = [];
    let next2;
    let wordId;
    let textNode$1;
    while (next2 = iterator.getNext()) {
      if (next2.nodeType === textNode && next2.data !== "") {
        textNode$1 = next2;
      } else if (next2.nodeType === elementNode && next2.nodeName === "BR") {
        totalOffset += 1;
        continue;
      } else {
        continue;
      }
      const nodeText = textNode$1.data;
      let nodeEndOffset = totalOffset + nodeText.length;
      if (currentMatch.startIndex < nodeEndOffset && totalOffset < currentMatch.endIndex) {
        const isFirstPortion = totalOffset <= currentMatch.startIndex;
        const isLastPortion = nodeEndOffset >= currentMatch.endIndex;
        if (isFirstPortion) {
          wordId = currentMatch.id || currentMatch.startIndex;
        }
        let offset;
        if (isFirstPortion) {
          offset = currentMatch.startIndex - totalOffset;
        } else {
          offset = 0;
        }
        let length;
        if (isLastPortion) {
          length = currentMatch.endIndex - totalOffset - offset;
        } else {
          length = nodeText.length - offset;
        }
        const portion = {
          element: textNode$1,
          text: nodeText.substring(offset, offset + length),
          offset,
          length,
          isLastPortion,
          wordId
        };
        portions.push(portion);
        if (isLastPortion) {
          const lastNode = this.wrapMatch(portions, currentMatch.marker, currentMatch.title);
          iterator.replaceCurrent(lastNode);
          nodeEndOffset = totalOffset + portion.length + portion.offset;
          portions = [];
          currentMatchIndex += 1;
          if (currentMatchIndex < matches2.length) {
            currentMatch = matches2[currentMatchIndex];
          }
        }
      }
      totalOffset = nodeEndOffset;
    }
  },
  wrapMatch(portions, stencilElement, title) {
    return portions.map((portion) => this.wrapPortion(portion, stencilElement, title)).pop();
  },
  wrapPortion(portion, stencilElement, title) {
    const range2 = rangy.createRange();
    range2.setStart(portion.element, portion.offset);
    range2.setEnd(portion.element, portion.offset + portion.length);
    const node = stencilElement.cloneNode(true);
    node.setAttribute("data-word-id", portion.wordId);
    if (title)
      node.setAttribute("title", title);
    range2.surroundContents(node);
    if (node.nextSibling) {
      const next2 = node.nextSibling;
      if (next2.nodeType === textNode && next2.data === "") {
        next2.remove();
      }
    }
    return node;
  }
};
function getText(element2, callback) {
  const iterator = new NodeIterator(element2);
  let next2;
  while (next2 = iterator.getNext()) {
    if (next2.nodeType === textNode && next2.data !== "") {
      callback(next2.data);
    } else if (next2.nodeType === elementNode && next2.nodeName === "BR") {
      callback("\n");
    }
  }
}
class WordHighlighting {
  constructor(markerNode, matchMode = "word") {
    this.marker = markerNode;
    this.matchMode = matchMode;
  }
  isElement(obj2) {
    var _a2;
    try {
      if (!obj2)
        return false;
      return obj2 instanceof ((_a2 = obj2.ownerDocument) == null ? void 0 : _a2.defaultView.HTMLElement);
    } catch (e) {
      return typeof obj2 === "object" && obj2.nodeType === 1 && typeof obj2.style === "object" && typeof obj2.ownerDocument === "object";
    }
  }
  findMatches(text2, highlights) {
    if (!text2 || text2 === "" || !this.isElement(this.marker))
      return;
    if (highlights && highlights.length > 0) {
      return this.searchMatches(text2, highlights);
    }
  }
  searchMatches(text2, highlights) {
    const createRegex = this.matchMode === "word" ? createWordRegex : createHighlightRegex;
    const regex = createRegex(highlights);
    const matches2 = [...text2.matchAll(regex)];
    return matches2.map((entry) => this.prepareMatch(entry));
  }
  prepareMatch(match) {
    let startIndex;
    let matchedText;
    if (this.matchMode === "word") {
      startIndex = match.index + match[1].length;
      matchedText = match[2];
    } else {
      startIndex = match.index;
      matchedText = match[0];
    }
    return {
      startIndex,
      endIndex: startIndex + matchedText.length,
      match: matchedText,
      marker: this.marker
    };
  }
}
function createHighlightRegex(words) {
  const escapedWords = (words || []).map((word) => escapeRegEx(word));
  const regex = `(${escapedWords.join("|")})`;
  return new RegExp(regex, "g");
}
const letterChars = "\\u0041-\\u005A\\u0061-\\u007A\\u0030-\\u0039\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF\\u0100-\\u017F\\u0180-\\u024F";
function createWordRegex(words) {
  const escapedWords = (words || []).map((word) => escapeRegEx(word));
  const regex = `([^${letterChars}]|^)(${escapedWords.join("|")})(?=[^${letterChars}]|$)`;
  return new RegExp(regex, "g");
}
function escapeRegEx(s) {
  return String(s).replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
}
function isInHost(elem, host) {
  return closest(elem, "[data-editable]:not([data-word-id])") === host;
}
const highlightSupport = {
  highlightText(editableHost, text2, highlightId, type2) {
    if (this.hasHighlight(editableHost, highlightId))
      return;
    const blockText = highlightText.extractText(editableHost);
    const marker2 = `<span class="highlight-${type2}"></span>`;
    const markerNode = highlightSupport.createMarkerNode(marker2, type2, this.win);
    const textSearch = new WordHighlighting(markerNode, "text");
    const matches2 = textSearch.findMatches(blockText, [text2]);
    if (matches2 && matches2.length) {
      if (highlightId)
        matches2[0].id = highlightId;
      highlightText.highlightMatches(editableHost, matches2);
      return matches2[0].startIndex;
    }
  },
  highlightRange(editableHost, highlightId, startIndex, endIndex, dispatcher, type2 = "comment") {
    if (this.hasHighlight(editableHost, highlightId)) {
      this.removeHighlight(editableHost, highlightId);
    }
    const range2 = rangy.createRange();
    range2.selectCharacters(editableHost, startIndex, endIndex);
    if (!isInHost(range2.commonAncestorContainer, editableHost)) {
      return -1;
    }
    const marker2 = highlightSupport.createMarkerNode(`<span class="highlight-${type2}" data-word-id="${highlightId}"></span>`, type2, this.win);
    const fragment = range2.extractContents();
    marker2.appendChild(fragment);
    range2.deleteContents();
    range2.insertNode(marker2);
    highlightSupport.cleanupStaleMarkerNodes(editableHost, "comment");
    if (dispatcher) {
      dispatcher.notify("change", editableHost);
    }
    return startIndex;
  },
  updateHighlight(editableHost, highlightId, addCssClass, removeCssClass) {
    if (!document.documentElement.classList)
      return;
    const elems = editableHost.querySelectorAll(`[data-word-id="${highlightId}"]`);
    for (const elem of elems) {
      if (removeCssClass)
        elem.classList.remove(removeCssClass);
      if (addCssClass)
        elem.classList.add(addCssClass);
    }
  },
  removeHighlight(editableHost, highlightId, dispatcher) {
    const elems = editableHost.querySelectorAll(`[data-word-id="${highlightId}"]`);
    for (const elem of elems) {
      unwrap(elem);
      editableHost.normalize();
      if (dispatcher)
        dispatcher.notify("change", editableHost);
    }
  },
  hasHighlight(editableHost, highlightId) {
    const matches2 = editableHost.querySelectorAll(`[data-word-id="${highlightId}"]`);
    return !!matches2.length;
  },
  extractHighlightedRanges(editableHost, type2) {
    let findMarkersQuery = "[data-word-id]";
    if (type2)
      findMarkersQuery += `[data-highlight="${type2}"]`;
    const markers = editableHost.querySelectorAll(findMarkersQuery);
    if (!markers.length)
      return;
    const groups = {};
    for (const marker2 of markers) {
      const highlightId = marker2.getAttribute("data-word-id");
      if (!groups[highlightId]) {
        groups[highlightId] = editableHost.querySelectorAll(`[data-word-id="${highlightId}"]`);
      }
    }
    const res2 = {};
    for (const highlightId in groups) {
      const position2 = this.extractMarkerNodePosition(editableHost, groups[highlightId]);
      if (position2)
        res2[highlightId] = position2;
    }
    return res2;
  },
  extractMarkerNodePosition(editableHost, markers) {
    const range2 = rangy.createRange();
    if (markers.length > 1) {
      range2.setStartBefore(markers[0]);
      range2.setEndAfter(markers[markers.length - 1]);
    } else {
      range2.selectNode(markers[0]);
    }
    const textRange = range2.toCharacterRange(editableHost);
    return {
      start: textRange.start,
      end: textRange.end,
      text: range2.text(),
      nativeRange: range2.nativeRange
    };
  },
  cleanupStaleMarkerNodes(editableHost, highlightType) {
    const nodes = editableHost.querySelectorAll(`span[data-highlight="${highlightType}"]`);
    for (const node of nodes) {
      if (!node.textContent.length) {
        node.remove();
      }
    }
  },
  createMarkerNode(markerMarkup, highlightType, win) {
    const marker2 = createElement(markerMarkup, win);
    marker2.setAttribute("data-editable", "ui-unwrap");
    marker2.setAttribute("data-highlight", highlightType);
    return marker2;
  }
};
class Selection extends Cursor {
  constructor() {
    super(...arguments);
    delete this.isCursor;
    this.isSelection = true;
  }
  text() {
    return this.range.toString();
  }
  html() {
    return this.range.toHtml();
  }
  isAllSelected() {
    return isBeginningOfHost(this.host, this.range.startContainer, this.range.startOffset) && isTextEndOfHost(this.host, this.range.endContainer, this.range.endOffset);
  }
  getTextRange() {
    return this.range.toCharacterRange(this.host);
  }
  toString() {
    return this.range.toString();
  }
  isWrappable() {
    return isWrappable(this.range);
  }
  getRects() {
    return this.range.nativeRange.getClientRects();
  }
  link(href, attrs = {}) {
    if (href)
      attrs.href = href;
    const link = this.createElement(config$1.linkMarkup.name, config$1.linkMarkup.attribs);
    for (const key in attrs) {
      const value2 = attrs[key];
      if (value2 === void 0)
        continue;
      if (value2 === null) {
        link.removeAttribute(key);
      } else {
        link.setAttribute(key, value2);
      }
    }
    if (config$1.linkMarkup.trim)
      this.trimRange();
    this.forceWrap(link);
  }
  trimRange() {
    const textToTrim = this.range.toString();
    const whitespacesOnTheLeft = textToTrim.search(/\S|$/);
    const lastNonWhitespace = textToTrim.search(/\S[\s]+$/);
    const whitespacesOnTheRight = lastNonWhitespace === -1 ? 0 : textToTrim.length - (lastNonWhitespace + 1);
    this.range.setStart(this.range.startContainer, this.range.startOffset + whitespacesOnTheLeft);
    this.range.setEnd(this.range.endContainer, this.range.endOffset - whitespacesOnTheRight);
  }
  unlink() {
    this.removeFormatting(config$1.linkMarkup.name);
  }
  toggleLink(href, attrs) {
    const links = this.getTagsByName(config$1.linkMarkup.name);
    if (links.length >= 1) {
      const firstLink = links[0];
      if (this.isExactSelection(firstLink, "visible")) {
        this.unlink();
      } else {
        this.expandTo(firstLink);
      }
    } else {
      this.link(href, attrs);
    }
  }
  highlight({ highlightId }) {
    const textBefore = this.textBefore();
    const currentTextContent = this.text();
    const marker2 = '<span class="highlight-comment"></span>';
    const markerNode = highlightSupport.createMarkerNode(marker2, this.win);
    markerNode.setAttribute("data-match", currentTextContent);
    const match = {
      startIndex: textBefore.length,
      endIndex: textBefore.length + currentTextContent.length,
      match: currentTextContent,
      marker: markerNode
    };
    highlightText.highlightMatches(this.host, [match]);
  }
  toggle(elem) {
    elem = this.adoptElement(elem);
    this.range = toggleTag(this.host, this.range, elem);
    this.setSelection();
  }
  toggleCustom({ tagName, attributes, trim: trim2 = false }) {
    const customElem = this.createElement(tagName, attributes);
    if (trim2)
      this.trimRange();
    this.toggle(customElem);
  }
  makeCustom({ tagName, attributes, trim: trim2 = false }) {
    const customElem = this.createElement(tagName, attributes);
    if (trim2)
      this.trimRange();
    this.forceWrap(customElem);
  }
  makeBold() {
    const bold = this.createElement(config$1.boldMarkup.name, config$1.boldMarkup.attribs);
    if (config$1.boldMarkup.trim)
      this.trimRange();
    this.forceWrap(bold);
  }
  toggleBold() {
    const bold = this.createElement(config$1.boldMarkup.name, config$1.boldMarkup.attribs);
    if (config$1.boldMarkup.trim)
      this.trimRange();
    this.toggle(bold);
  }
  giveEmphasis() {
    const em = this.createElement(config$1.italicMarkup.name, config$1.italicMarkup.attribs);
    if (config$1.italicMarkup.trim)
      this.trimRange();
    this.forceWrap(em);
  }
  toggleEmphasis() {
    const em = this.createElement(config$1.italicMarkup.name, config$1.italicMarkup.attribs);
    if (config$1.italicMarkup.trim)
      this.trimRange();
    this.toggle(em);
  }
  makeUnderline() {
    const u = this.createElement(config$1.underlineMarkup.name, config$1.underlineMarkup.attribs);
    if (config$1.underlineMarkup.trim)
      this.trimRange();
    this.forceWrap(u);
  }
  toggleUnderline() {
    const u = this.createElement(config$1.underlineMarkup.name, config$1.underlineMarkup.attribs);
    if (config$1.underlineMarkup.trim)
      this.trimRange();
    this.toggle(u);
  }
  insertCharacter(character) {
    const cursor = this.deleteContent();
    const textNode2 = cursor.createTextNode(character);
    cursor.insertBefore(textNode2);
    cursor.setSelection();
    return cursor;
  }
  surround(startCharacter, endCharacter) {
    this.range = surround(this.host, this.range, startCharacter, endCharacter);
    this.setSelection();
  }
  removeSurround(startCharacter, endCharacter) {
    this.range = deleteCharacter(this.host, this.range, startCharacter);
    this.range = deleteCharacter(this.host, this.range, endCharacter);
    this.setSelection();
  }
  removeChars(chars = []) {
    for (let i2 = 0; i2 < chars.length; i2++) {
      const char = chars[i2];
      this.range = deleteCharacter(this.host, this.range, char);
    }
    this.setSelection();
  }
  toggleSurround(startCharacter, endCharacter) {
    if (this.containsString(startCharacter) && this.containsString(endCharacter)) {
      this.removeSurround(startCharacter, endCharacter);
    } else {
      this.surround(startCharacter, endCharacter);
    }
  }
  removeFormatting(selector) {
    this.range = removeFormatting(this.host, this.range, selector);
    this.setSelection();
  }
  deleteContent() {
    this.range.deleteContents();
    return new Cursor(this.host, this.range);
  }
  expandTo(elem) {
    this.range = expandTo(this.host, this.range, elem);
    this.setSelection();
  }
  collapseAtBeginning(elem) {
    this.range.collapse(true);
    this.setSelection();
    return new Cursor(this.host, this.range);
  }
  collapseAtEnd(elem) {
    this.range.collapse(false);
    this.setSelection();
    return new Cursor(this.host, this.range);
  }
  forceWrap(elem) {
    elem = this.adoptElement(elem);
    this.range = forceWrap(this.host, this.range, elem);
    this.setSelection();
  }
  isExactSelection(elem, onlyVisible) {
    return isExactSelection(this.range, elem, onlyVisible);
  }
  containsString(str2) {
    return containsString(this.range, str2);
  }
  deleteCharacter(character) {
    this.range = deleteCharacter(this.host, this.range, character);
    this.setSelection();
  }
}
class RangeContainer {
  constructor(editableHost, rangyRange) {
    this.host = editableHost && editableHost.jquery ? editableHost[0] : editableHost;
    this.range = rangyRange;
    this.isAnythingSelected = rangyRange !== void 0;
    this.isCursor = this.isAnythingSelected && rangyRange.collapsed;
    this.isSelection = this.isAnythingSelected && !this.isCursor;
  }
  getCursor() {
    if (this.isCursor)
      return new Cursor(this.host, this.range);
  }
  getSelection() {
    if (this.isSelection)
      return new Selection(this.host, this.range);
  }
  forceCursor() {
    if (!this.isSelection)
      return this.getCursor();
    return this.getSelection().deleteContent();
  }
  isDifferentFrom(otherRangeContainer = new RangeContainer()) {
    const self2 = this.range;
    const other = otherRangeContainer.range;
    if (self2 && other)
      return !self2.equals(other);
    if (!self2 && !other)
      return false;
    return true;
  }
}
class SelectionWatcher {
  constructor(dispatcher, win) {
    this.dispatcher = dispatcher;
    this.win = win || window;
    this.rangySelection = void 0;
    this.currentSelection = void 0;
    this.currentRange = void 0;
  }
  syncSelection() {
    try {
      this.rangySelection = rangy.getSelection(this.win);
    } catch (err2) {
      return false;
    }
    return true;
  }
  getRangeContainer() {
    const successfulSync = this.syncSelection();
    if (this.rangySelection.rangeCount && successfulSync) {
      const range2 = this.rangySelection.getRangeAt(0);
      const hostNode = getHost(range2.commonAncestorContainer);
      if (hostNode)
        return new RangeContainer(hostNode, range2);
    }
    return new RangeContainer();
  }
  getFreshRange() {
    return this.getRangeContainer();
  }
  getFreshSelection() {
    const range2 = this.getRangeContainer();
    return range2.isCursor ? range2.getCursor(this.win) : range2.getSelection(this.win);
  }
  getSelection() {
    return this.currentSelection;
  }
  forceCursor() {
    const range2 = this.getRangeContainer();
    return range2.forceCursor();
  }
  selectionChanged() {
    const newRange = this.getRangeContainer();
    if (newRange.isDifferentFrom(this.currentRange)) {
      const lastSelection = this.currentSelection;
      this.currentRange = newRange;
      if (lastSelection) {
        if (lastSelection.isCursor && !this.currentRange.isCursor) {
          this.dispatcher.notify("cursor", lastSelection.host);
        } else if (lastSelection.isSelection && !this.currentRange.isSelection) {
          this.dispatcher.notify("selection", lastSelection.host);
        }
      }
      if (this.currentRange.isCursor) {
        this.currentSelection = new Cursor(this.currentRange.host, this.currentRange.range);
        this.dispatcher.notify("cursor", this.currentSelection.host, this.currentSelection);
      } else if (this.currentRange.isSelection) {
        this.currentSelection = new Selection(this.currentRange.host, this.currentRange.range);
        this.dispatcher.notify("selection", this.currentSelection.host, this.currentSelection);
      } else {
        this.currentSelection = void 0;
      }
    }
  }
}
class Keyboard {
  constructor(selectionWatcher) {
    eventable(this);
    this.selectionWatcher = selectionWatcher;
  }
  dispatchKeyEvent(event2, target, notifyCharacterEvent) {
    switch (event2.keyCode) {
      case this.key.left:
        return this.notify(target, "left", event2);
      case this.key.right:
        return this.notify(target, "right", event2);
      case this.key.up:
        return this.notify(target, "up", event2);
      case this.key.down:
        return this.notify(target, "down", event2);
      case this.key.tab:
        if (event2.shiftKey)
          return this.notify(target, "shiftTab", event2);
        return this.notify(target, "tab", event2);
      case this.key.esc:
        return this.notify(target, "esc", event2);
      case this.key.backspace:
        this.preventContenteditableBug(target, event2);
        return this.notify(target, "backspace", event2);
      case this.key.delete:
        this.preventContenteditableBug(target, event2);
        return this.notify(target, "delete", event2);
      case this.key.enter:
        if (event2.shiftKey)
          return this.notify(target, "shiftEnter", event2);
        return this.notify(target, "enter", event2);
      case this.key.ctrl:
      case this.key.shift:
      case this.key.alt:
        return;
      case 224:
      case 17:
      case 91:
      case 93:
        return;
      default:
        if (event2.keyCode === this.key.b && (event2.ctrlKey || event2.metaKey)) {
          return this.notify(target, "bold", event2);
        }
        if (event2.keyCode === this.key.i && (event2.ctrlKey || event2.metaKey)) {
          return this.notify(target, "italic", event2);
        }
        this.preventContenteditableBug(target, event2);
        if (!notifyCharacterEvent)
          return;
        if (!event2.ctrlKey && !event2.metaKey)
          return this.notify(target, "character", event2);
    }
  }
  preventContenteditableBug(target, event2) {
    if (!contenteditableSpanBug)
      return;
    if (event2.ctrlKey || event2.metaKey)
      return;
    const rangyInstance = this.selectionWatcher.getFreshRange();
    if (!rangyInstance.isSelection)
      return;
    const nodeToRemove = Keyboard.getNodeToRemove(rangyInstance.range, target);
    if (nodeToRemove)
      nodeToRemove.remove();
  }
  static getNodeToRemove(selectionRange, target) {
    if (selectionRange.startOffset !== 0)
      return;
    let startNodeElement = selectionRange.startContainer;
    if (startNodeElement.nodeType === textNode)
      startNodeElement = startNodeElement.parentNode;
    if (startNodeElement === target)
      return;
    const startNodeRange = rangy.createRange();
    startNodeRange.setStartBefore(startNodeElement.firstChild);
    startNodeRange.setEndAfter(startNodeElement.lastChild);
    if (startNodeRange.containsRange(selectionRange))
      return;
    if (selectionRange.startContainer.nodeType === textNode) {
      const contentNodeTypes = [textNode, elementNode];
      let firstContentNode = startNodeElement.firstChild;
      do {
        if (contentNodeTypes.indexOf(firstContentNode.nodeType) !== -1)
          break;
      } while (firstContentNode = firstContentNode.nextSibling);
      if (firstContentNode !== selectionRange.startContainer)
        return;
    }
    const rangeStartingBeforeCurrentElement = selectionRange.cloneRange();
    rangeStartingBeforeCurrentElement.setStartBefore(startNodeElement);
    return Keyboard.getNodeToRemove(rangeStartingBeforeCurrentElement, target) || startNodeElement;
  }
}
Keyboard.key = Keyboard.prototype.key = {
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  tab: 9,
  esc: 27,
  backspace: 8,
  delete: 46,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  b: 66,
  i: 73
};
let isInputEventSupported = false;
class Dispatcher {
  constructor(editable) {
    const win = editable.win;
    eventable(this, editable);
    this.supportsInputEvent = false;
    this.document = win.document;
    this.config = editable.config;
    this.editable = editable;
    this.editableSelector = editable.editableSelector;
    this.selectionWatcher = new SelectionWatcher(this, win);
    this.keyboard = new Keyboard(this.selectionWatcher);
    this.activeListeners = [];
    this.setup();
    this.getEditableBlockByEvent = (evt) => closest(evt.target, editable.editableSelector);
  }
  setupDocumentListener(event2, func, capture = false) {
    const listener = { event: event2, listener: func.bind(this), capture };
    this.activeListeners.push(listener);
    this.document.addEventListener(event2, listener.listener, capture);
    return this;
  }
  setup() {
    this.setupKeyboardEvents();
    this.setupEventListeners();
  }
  unload() {
    this.off();
    for (const l2 of this.activeListeners) {
      this.document.removeEventListener(l2.event, l2.listener, l2.capture);
    }
    this.activeListeners.length = 0;
  }
  suspend() {
    if (this.suspended)
      return;
    this.suspended = true;
    for (const l2 of this.activeListeners) {
      this.document.removeEventListener(l2.event, l2.listener, l2.capture);
    }
    this.activeListeners.length = 0;
  }
  continue() {
    if (!this.suspended)
      return;
    this.suspended = false;
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.setupElementListeners();
    this.setupKeydownListener();
    if (selectionchange) {
      this.setupSelectionChangeListeners();
    } else {
      this.setupSelectionChangeFallbackListeners();
    }
  }
  setupElementListeners() {
    this.setupDocumentListener("focus", function focusListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      if (evt.target.getAttribute(config$1.pastingAttribute))
        return;
      this.selectionWatcher.syncSelection();
      this.notify("focus", block2);
    }, true).setupDocumentListener("blur", function blurListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      if (block2.getAttribute(config$1.pastingAttribute))
        return;
      this.notify("blur", block2);
    }, true).setupDocumentListener("copy", function copyListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      const selection = this.selectionWatcher.getFreshSelection();
      if (selection && selection.isSelection) {
        this.notify("clipboard", block2, "copy", selection);
      }
    }).setupDocumentListener("cut", function cutListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      const selection = this.selectionWatcher.getFreshSelection();
      if (selection && selection.isSelection) {
        this.notify("clipboard", block2, "cut", selection);
        this.triggerChangeEvent(block2);
      }
    }).setupDocumentListener("paste", function pasteListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      evt.preventDefault();
      const selection = this.selectionWatcher.getFreshSelection();
      const clipboardContent = evt.clipboardData.getData("text/html") || evt.clipboardData.getData("text/plain");
      const { blocks, cursor } = paste(block2, selection, clipboardContent);
      if (blocks.length) {
        this.notify("paste", block2, blocks, cursor);
        this.notify("change", block2);
      } else {
        cursor.setVisibleSelection();
      }
    }).setupDocumentListener("input", function inputListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      if (isInputEventSupported) {
        this.notify("change", block2);
      } else {
        isInputEventSupported = true;
      }
    }).setupDocumentListener("formatEditable", function formatEditableListener(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      this.notify("change", block2);
    });
  }
  triggerChangeEvent(target) {
    if (isInputEventSupported)
      return;
    this.notify("change", target);
  }
  dispatchSwitchEvent(event2, element2, direction) {
    if (event2.altKey || event2.ctrlKey || event2.metaKey || event2.shiftKey)
      return;
    const cursor = this.selectionWatcher.getFreshSelection();
    if (!cursor || cursor.isSelection)
      return;
    if (!this.switchContext) {
      this.switchContext = {
        positionX: cursor.getBoundingClientRect().left,
        events: ["cursor"]
      };
    } else {
      this.switchContext.events = ["cursor"];
    }
    if (direction === "up" && cursor.isAtFirstLine()) {
      event2.preventDefault();
      event2.stopPropagation();
      this.switchContext.events = ["switch", "blur", "focus", "cursor"];
      this.notify("switch", element2, direction, cursor);
    }
    if (direction === "down" && cursor.isAtLastLine()) {
      event2.preventDefault();
      event2.stopPropagation();
      this.switchContext.events = ["switch", "blur", "focus", "cursor"];
      this.notify("switch", element2, direction, cursor);
    }
  }
  setupKeydownListener() {
    this.setupDocumentListener("keydown", function(evt) {
      const block2 = this.getEditableBlockByEvent(evt);
      if (!block2)
        return;
      const notifyCharacterEvent = !isInputEventSupported;
      this.keyboard.dispatchKeyEvent(evt, block2, notifyCharacterEvent);
    }, true);
  }
  setupKeyboardEvents() {
    const self2 = this;
    this.keyboard.on("up", function(event2) {
      self2.dispatchSwitchEvent(event2, this, "up");
    }).on("down", function(event2) {
      self2.dispatchSwitchEvent(event2, this, "down");
    }).on("backspace", function(event2) {
      const range2 = self2.selectionWatcher.getFreshRange();
      if (!range2.isCursor)
        return self2.triggerChangeEvent(this);
      const cursor = range2.getCursor();
      if (!cursor.isAtBeginning())
        return self2.triggerChangeEvent(this);
      event2.preventDefault();
      event2.stopPropagation();
      self2.notify("merge", this, "before", cursor);
    }).on("delete", function(event2) {
      const range2 = self2.selectionWatcher.getFreshRange();
      if (!range2.isCursor)
        return self2.triggerChangeEvent(this);
      const cursor = range2.getCursor();
      if (!cursor.isAtTextEnd())
        return self2.triggerChangeEvent(this);
      event2.preventDefault();
      event2.stopPropagation();
      self2.notify("merge", this, "after", cursor);
    }).on("enter", function(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      const range2 = self2.selectionWatcher.getFreshRange();
      const cursor = range2.forceCursor();
      if (cursor.isAtTextEnd()) {
        self2.notify("insert", this, "after", cursor);
      } else if (cursor.isAtBeginning()) {
        self2.notify("insert", this, "before", cursor);
      } else {
        self2.notify("split", this, cursor.before(), cursor.after(), cursor);
      }
    }).on("shiftEnter", function(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      const cursor = self2.selectionWatcher.forceCursor();
      self2.notify("newline", this, cursor);
    }).on("bold", function(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      const selection = self2.selectionWatcher.getFreshSelection();
      if (selection.isSelection) {
        self2.notify("toggleBold", selection);
      }
    }).on("italic", function(event2) {
      event2.preventDefault();
      event2.stopPropagation();
      const selection = self2.selectionWatcher.getFreshSelection();
      if (selection.isSelection) {
        self2.notify("toggleEmphasis", selection);
      }
    }).on("character", function(event2) {
      self2.notify("change", this);
    });
  }
  setupSelectionChangeListeners() {
    let selectionDirty = false;
    let suppressSelectionChanges = false;
    const selectionWatcher = this.selectionWatcher;
    this.setupDocumentListener("selectionchange", (evt) => {
      const cursor = this.selectionWatcher.getFreshSelection();
      if (cursor && cursor.isSelection && cursor.isAtBeginning() && cursor.isAtEnd()) {
        this.notify("selectToBoundary", cursor.host, evt, "both");
      } else if (cursor && cursor.isSelection && cursor.isAtBeginning()) {
        this.notify("selectToBoundary", cursor.host, evt, "start");
      } else if (cursor && cursor.isSelection && cursor.isAtEnd()) {
        this.notify("selectToBoundary", cursor.host, evt, "end");
      }
      if (suppressSelectionChanges) {
        selectionDirty = true;
      } else {
        selectionWatcher.selectionChanged();
      }
    });
    this.setupDocumentListener("mousedown", function(evt) {
      if (!this.getEditableBlockByEvent(evt))
        return;
      if (this.config.mouseMoveSelectionChanges === false) {
        suppressSelectionChanges = true;
        setTimeout(() => selectionWatcher.selectionChanged(), 0);
      }
      this.document.addEventListener("mouseup", () => {
        suppressSelectionChanges = false;
        if (selectionDirty) {
          selectionDirty = false;
          selectionWatcher.selectionChanged();
        }
      }, {
        capture: true,
        once: true
      });
    });
  }
  setupSelectionChangeFallbackListeners() {
    this.setupDocumentListener("mouseup", () => {
      setTimeout(() => this.selectionWatcher.selectionChanged(), 0);
    });
    this.setupDocumentListener("keyup", (evt) => {
      if (!this.getEditableBlockByEvent(evt))
        return;
      this.selectionWatcher.selectionChanged();
    });
  }
}
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}
function eq$5(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
function assocIndexOf$5(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$5(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$2(key) {
  var data = this.__data__, index2 = assocIndexOf$5(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet$2(key) {
  var data = this.__data__, index2 = assocIndexOf$5(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas$2(key) {
  return assocIndexOf$5(this.__data__, key) > -1;
}
function listCacheSet$2(key, value2) {
  var data = this.__data__, index2 = assocIndexOf$5(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
function ListCache$5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$2;
ListCache$5.prototype["delete"] = listCacheDelete$2;
ListCache$5.prototype.get = listCacheGet$2;
ListCache$5.prototype.has = listCacheHas$2;
ListCache$5.prototype.set = listCacheSet$2;
function stackClear$2() {
  this.__data__ = new ListCache$5();
  this.size = 0;
}
function stackDelete$2(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
function stackGet$2(key) {
  return this.__data__.get(key);
}
function stackHas$2(key) {
  return this.__data__.has(key);
}
var freeGlobal$2 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$3 = freeGlobal$2;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$5 = freeGlobal$3 || freeSelf$1 || Function("return this")();
var root$6 = root$5;
var Symbol$4 = root$6.Symbol;
var Symbol$5 = Symbol$4;
var objectProto$l = Object.prototype;
var hasOwnProperty$h = objectProto$l.hasOwnProperty;
var nativeObjectToString$3 = objectProto$l.toString;
var symToStringTag$3 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$2(value2) {
  var isOwn = hasOwnProperty$h.call(value2, symToStringTag$3), tag = value2[symToStringTag$3];
  try {
    value2[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$3.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$3] = tag;
    } else {
      delete value2[symToStringTag$3];
    }
  }
  return result2;
}
var objectProto$k = Object.prototype;
var nativeObjectToString$2 = objectProto$k.toString;
function objectToString$2(value2) {
  return nativeObjectToString$2.call(value2);
}
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$5(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value2) ? getRawTag$2(value2) : objectToString$2(value2);
}
function isObject$c(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$4(value2) {
  if (!isObject$c(value2)) {
    return false;
  }
  var tag = baseGetTag$5(value2);
  return tag == funcTag$3 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}
var coreJsData$2 = root$6["__core-js_shared__"];
var coreJsData$3 = coreJsData$2;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$3 && coreJsData$3.keys && coreJsData$3.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$5 = Function.prototype;
var funcToString$5 = funcProto$5.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$5.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$4 = Function.prototype, objectProto$j = Object.prototype;
var funcToString$4 = funcProto$4.toString;
var hasOwnProperty$g = objectProto$j.hasOwnProperty;
var reIsNative$1 = RegExp("^" + funcToString$4.call(hasOwnProperty$g).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$2(value2) {
  if (!isObject$c(value2) || isMasked$2(value2)) {
    return false;
  }
  var pattern = isFunction$4(value2) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$2(value2));
}
function getValue$2(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative$4(object, key) {
  var value2 = getValue$2(object, key);
  return baseIsNative$2(value2) ? value2 : void 0;
}
var Map$4 = getNative$4(root$6, "Map");
var Map$5 = Map$4;
var nativeCreate$5 = getNative$4(Object, "create");
var nativeCreate$6 = nativeCreate$5;
function hashClear$2() {
  this.__data__ = nativeCreate$6 ? nativeCreate$6(null) : {};
  this.size = 0;
}
function hashDelete$2(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
var objectProto$i = Object.prototype;
var hasOwnProperty$f = objectProto$i.hasOwnProperty;
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$6) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED$3 ? void 0 : result2;
  }
  return hasOwnProperty$f.call(data, key) ? data[key] : void 0;
}
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$6 ? data[key] !== void 0 : hasOwnProperty$e.call(data, key);
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
function hashSet$2(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$6 && value2 === void 0 ? HASH_UNDEFINED$2 : value2;
  return this;
}
function Hash$2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear$2;
Hash$2.prototype["delete"] = hashDelete$2;
Hash$2.prototype.get = hashGet$2;
Hash$2.prototype.has = hashHas$2;
Hash$2.prototype.set = hashSet$2;
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$2(),
    "map": new (Map$5 || ListCache$5)(),
    "string": new Hash$2()
  };
}
function isKeyable$2(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData$5(map2, key) {
  var data = map2.__data__;
  return isKeyable$2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete$2(key) {
  var result2 = getMapData$5(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
function mapCacheGet$2(key) {
  return getMapData$5(this, key).get(key);
}
function mapCacheHas$2(key) {
  return getMapData$5(this, key).has(key);
}
function mapCacheSet$2(key, value2) {
  var data = getMapData$5(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache$2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear$2;
MapCache$2.prototype["delete"] = mapCacheDelete$2;
MapCache$2.prototype.get = mapCacheGet$2;
MapCache$2.prototype.has = mapCacheHas$2;
MapCache$2.prototype.set = mapCacheSet$2;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(key, value2) {
  var data = this.__data__;
  if (data instanceof ListCache$5) {
    var pairs2 = data.__data__;
    if (!Map$5 || pairs2.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs2.push([key, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs2);
  }
  data.set(key, value2);
  this.size = data.size;
  return this;
}
function Stack$2(entries) {
  var data = this.__data__ = new ListCache$5(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear$2;
Stack$2.prototype["delete"] = stackDelete$2;
Stack$2.prototype.get = stackGet$2;
Stack$2.prototype.has = stackHas$2;
Stack$2.prototype.set = stackSet$2;
var defineProperty$3 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$4 = defineProperty$3;
function baseAssignValue$4(object, key, value2) {
  if (key == "__proto__" && defineProperty$4) {
    defineProperty$4(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
function assignMergeValue$3(object, key, value2) {
  if (value2 !== void 0 && !eq$5(object[key], value2) || value2 === void 0 && !(key in object)) {
    baseAssignValue$4(object, key, value2);
  }
}
function createBaseFor$2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor$2 = createBaseFor$2();
var baseFor$3 = baseFor$2;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$6.Buffer : void 0, allocUnsafe = Buffer$2 ? Buffer$2.allocUnsafe : void 0;
function cloneBuffer$1(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var Uint8Array$3 = root$6.Uint8Array;
var Uint8Array$4 = Uint8Array$3;
function cloneArrayBuffer$2(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$4(result2).set(new Uint8Array$4(arrayBuffer));
  return result2;
}
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray$2(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var objectCreate$1 = Object.create;
var baseCreate$2 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$c(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate$3 = baseCreate$2;
function overArg$2(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype$3 = overArg$2(Object.getPrototypeOf, Object);
var getPrototype$4 = getPrototype$3;
var objectProto$g = Object.prototype;
function isPrototype$3(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$g;
  return value2 === proto;
}
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$3(object) ? baseCreate$3(getPrototype$4(object)) : {};
}
function isObjectLike$6(value2) {
  return value2 != null && typeof value2 == "object";
}
var argsTag$3 = "[object Arguments]";
function baseIsArguments$2(value2) {
  return isObjectLike$6(value2) && baseGetTag$5(value2) == argsTag$3;
}
var objectProto$f = Object.prototype;
var hasOwnProperty$d = objectProto$f.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$f.propertyIsEnumerable;
var isArguments$3 = baseIsArguments$2(function() {
  return arguments;
}()) ? baseIsArguments$2 : function(value2) {
  return isObjectLike$6(value2) && hasOwnProperty$d.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
var isArguments$4 = isArguments$3;
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
var MAX_SAFE_INTEGER$3 = 9007199254740991;
function isLength$3(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$3;
}
function isArrayLike$4(value2) {
  return value2 != null && isLength$3(value2.length) && !isFunction$4(value2);
}
function isArrayLikeObject$2(value2) {
  return isObjectLike$6(value2) && isArrayLike$4(value2);
}
function stubFalse$1() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer$1 = moduleExports$1 ? root$6.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer$3 = nativeIsBuffer || stubFalse$1;
var isBuffer$4 = isBuffer$3;
var objectTag$3 = "[object Object]";
var funcProto$3 = Function.prototype, objectProto$e = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var objectCtorString$1 = funcToString$3.call(Object);
function isPlainObject$2(value2) {
  if (!isObjectLike$6(value2) || baseGetTag$5(value2) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$4(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$3.call(Ctor) == objectCtorString$1;
}
var argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$2 = "[object Function]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] = typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] = typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] = typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] = typedArrayTags$1[uint32Tag$1] = true;
typedArrayTags$1[argsTag$2] = typedArrayTags$1[arrayTag$1] = typedArrayTags$1[arrayBufferTag$1] = typedArrayTags$1[boolTag$1] = typedArrayTags$1[dataViewTag$1] = typedArrayTags$1[dateTag$1] = typedArrayTags$1[errorTag$1] = typedArrayTags$1[funcTag$2] = typedArrayTags$1[mapTag$1] = typedArrayTags$1[numberTag$1] = typedArrayTags$1[objectTag$2] = typedArrayTags$1[regexpTag$1] = typedArrayTags$1[setTag$1] = typedArrayTags$1[stringTag$1] = typedArrayTags$1[weakMapTag$1] = false;
function baseIsTypedArray$2(value2) {
  return isObjectLike$6(value2) && isLength$3(value2.length) && !!typedArrayTags$1[baseGetTag$5(value2)];
}
function baseUnary$2(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$3.process;
var nodeUtil$1 = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$2 = nodeUtil$1;
var nodeIsTypedArray$1 = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray$1 ? baseUnary$2(nodeIsTypedArray$1) : baseIsTypedArray$2;
var isTypedArray$4 = isTypedArray$3;
function safeGet$3(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
function assignValue$2(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$b.call(object, key) && eq$5(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue$4(object, key, value2);
  }
}
function copyObject$2(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$4(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
function baseTimes$2(n2, iteratee) {
  var index2 = -1, result2 = Array(n2);
  while (++index2 < n2) {
    result2[index2] = iteratee(index2);
  }
  return result2;
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint$1.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
function arrayLikeKeys$2(value2, inherited) {
  var isArr = isArray$4(value2), isArg = !isArr && isArguments$4(value2), isBuff = !isArr && !isArg && isBuffer$4(value2), isType2 = !isArr && !isArg && !isBuff && isTypedArray$4(value2), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes$2(value2.length, String) : [], length = result2.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$a.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$3(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
function nativeKeysIn$2(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function baseKeysIn$2(object) {
  if (!isObject$c(object)) {
    return nativeKeysIn$2(object);
  }
  var isProto = isPrototype$3(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
function keysIn$3(object) {
  return isArrayLike$4(object) ? arrayLikeKeys$2(object, true) : baseKeysIn$2(object);
}
function toPlainObject$2(value2) {
  return copyObject$2(value2, keysIn$3(value2));
}
function baseMergeDeep$2(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$3(object, key), srcValue = safeGet$3(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$3(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$4(srcValue), isBuff = !isArr && isBuffer$4(srcValue), isTyped = !isArr && !isBuff && isTypedArray$4(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$4(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject$2(objValue)) {
        newValue = copyArray$2(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$2(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$2(srcValue) || isArguments$4(srcValue)) {
      newValue = objValue;
      if (isArguments$4(objValue)) {
        newValue = toPlainObject$2(objValue);
      } else if (!isObject$c(objValue) || isFunction$4(objValue)) {
        newValue = initCloneObject$2(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$3(object, key, newValue);
}
function baseMerge$2(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$3(source, function(srcValue, key) {
    stack || (stack = new Stack$2());
    if (isObject$c(srcValue)) {
      baseMergeDeep$2(object, source, key, srcIndex, baseMerge$2, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet$3(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue$3(object, key, newValue);
    }
  }, keysIn$3);
}
function identity$3(value2) {
  return value2;
}
function apply$2(func, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args2[0]);
    case 2:
      return func.call(thisArg, args2[0], args2[1]);
    case 3:
      return func.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func.apply(thisArg, args2);
}
var nativeMax$1 = Math.max;
function overRest$2(func, start, transform2) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args2 = arguments, index2 = -1, length = nativeMax$1(args2.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args2[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args2[index2];
    }
    otherArgs[start] = transform2(array);
    return apply$2(func, this, otherArgs);
  };
}
function constant$2(value2) {
  return function() {
    return value2;
  };
}
var baseSetToString$2 = !defineProperty$4 ? identity$3 : function(func, string) {
  return defineProperty$4(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$2(string),
    "writable": true
  });
};
var baseSetToString$3 = baseSetToString$2;
var HOT_COUNT$1 = 800, HOT_SPAN$1 = 16;
var nativeNow$1 = Date.now;
function shortOut$2(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT$1) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString$2 = shortOut$2(baseSetToString$3);
var setToString$3 = setToString$2;
function baseRest$2(func, start) {
  return setToString$3(overRest$2(func, start, identity$3), func + "");
}
function isIterateeCall$2(value2, index2, object) {
  if (!isObject$c(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike$4(object) && isIndex$3(index2, object.length) : type2 == "string" && index2 in object) {
    return eq$5(object[index2], value2);
  }
  return false;
}
function createAssigner$2(assigner) {
  return baseRest$2(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var merge$1 = createAssigner$2(function(object, source, srcIndex) {
  baseMerge$2(object, source, srcIndex);
});
var _merge = merge$1;
class SpellcheckService {
  constructor(spellcheckService) {
    this.spellcheckService = spellcheckService;
  }
  check(text2, callback) {
    if (!text2)
      return callback(null);
    const condensedText = normalizeWhitespace(text2);
    this.spellcheckService(condensedText, (misspelledWords) => {
      if (misspelledWords && misspelledWords.length > 0) {
        callback(null, misspelledWords);
      } else {
        callback(null);
      }
    });
  }
}
const characters = {
  "A0": "no-break space",
  "2000": "en quad",
  "2001": "em quad",
  "2002": "en space",
  "2003": "em space",
  "2004": "three-per-em space",
  "2005": "four-per-em space",
  "2006": "six-per-em space",
  "2007": "figure space",
  "2008": "punctuation space",
  "2009": "thin space",
  "200A": "hair space",
  "202F": "narrow no-break space",
  "205F": "medium mathematical space",
  "3000": "ideographic space"
};
const specialWhitespaceChars = "\\u2000-\\u200A\\u202F\\u205F\\u3000";
class WhitespaceHighlighting {
  constructor(markerNode) {
    this.marker = markerNode;
  }
  findMatches(text2) {
    if (!text2)
      return;
    let regex = `[${specialWhitespaceChars}]`;
    regex = new RegExp(regex, "g");
    const matches2 = [];
    let match;
    while (match = regex.exec(text2))
      matches2.push(match);
    return matches2.map((entry) => this.prepareMatch(entry));
  }
  prepareMatch(match) {
    const startIndex = match.index;
    const unicode = getUnicode(match[0]);
    const description = characters[unicode];
    return {
      startIndex,
      endIndex: startIndex + match.length,
      match: match[0],
      title: `${description} (\\u${unicode})`,
      marker: this.marker
    };
  }
}
function getUnicode(character) {
  const code2 = character.charCodeAt(0);
  return `${code2.toString(16).toUpperCase()}`;
}
class MatchCollection {
  constructor() {
    this.matches = [];
  }
  addMatches(name, matches2) {
    if (!matches2 || !matches2.length)
      return;
    this.matches = mergeMatches(this.matches, matches2);
  }
}
function mergeMatches(matches1, matches2) {
  let next2;
  const length1 = matches1.length;
  const length2 = matches2.length;
  let lastEndIndex = -1;
  const output = [];
  const state2 = {
    a1: matches1,
    i1: 0,
    a2: matches2,
    i2: 0
  };
  while (state2.i1 < length1 || state2.i2 < length2) {
    next2 = pickNext(state2);
    if (next2.startIndex >= lastEndIndex) {
      output.push(next2);
    }
    lastEndIndex = next2.endIndex;
  }
  return output;
}
function pickNext(state2) {
  const i1 = state2.i1;
  const i2 = state2.i2;
  const item1 = state2.a1[i1];
  const item2 = state2.a2[i2];
  if (item1 && item2 && item1.startIndex < item2.startIndex) {
    state2.i1 = i1 + 1;
    return item1;
  } else if (item1 && item2) {
    state2.i2 = i2 + 1;
    return item2;
  } else if (item1) {
    state2.i1 = i1 + 1;
    return item1;
  } else if (item2) {
    state2.i2 = i2 + 1;
    return item2;
  } else {
    return void 0;
  }
}
class Highlighting {
  constructor(editable, configuration, spellcheckConfig) {
    this.editable = editable;
    this.win = editable.win;
    this.focusedEditableHost = void 0;
    this.currentlyCheckedEditableHost = void 0;
    this.timeout = {};
    const defaultConfig = {
      checkOnInit: false,
      checkOnFocus: false,
      checkOnChange: true,
      throttle: 1e3,
      removeOnCorrection: true,
      spellcheck: {
        marker: '<span class="highlight-spellcheck"></span>',
        throttle: 1e3,
        spellcheckService: function() {
        }
      },
      whitespace: {
        marker: '<span class="highlight-whitespace"></span>'
      }
    };
    this.config = _merge({}, defaultConfig, configuration);
    const spellcheckService = this.config.spellcheck.spellcheckService;
    const spellcheckMarker = this.config.spellcheck.marker;
    const whitespaceMarker = this.config.whitespace.marker;
    const spellcheckMarkerNode = highlightSupport.createMarkerNode(spellcheckMarker, "spellcheck", this.win);
    const whitespaceMarkerNode = highlightSupport.createMarkerNode(whitespaceMarker, "spellcheck", this.win);
    this.spellcheckService = new SpellcheckService(spellcheckService);
    this.spellcheck = new WordHighlighting(spellcheckMarkerNode);
    this.whitespace = new WhitespaceHighlighting(whitespaceMarkerNode);
    this.setupListeners();
  }
  setupListeners() {
    if (this.config.checkOnFocus) {
      this.editable.on("focus", (...args2) => this.onFocus(...args2));
      this.editable.on("blur", (...args2) => this.onBlur(...args2));
    }
    if (this.config.checkOnChange || this.config.removeOnCorrection) {
      this.editable.on("change", (...args2) => this.onChange(...args2));
    }
    if (this.config.checkOnInit) {
      this.editable.on("init", (...args2) => this.onInit(...args2));
    }
  }
  onInit(editableHost) {
    this.highlight(editableHost);
  }
  onFocus(editableHost) {
    if (this.focusedEditableHost !== editableHost) {
      this.focusedEditableHost = editableHost;
      this.editableHasChanged(editableHost);
    }
  }
  onBlur(editableHost) {
    if (this.focusedEditableHost === editableHost) {
      this.focusedEditableHost = void 0;
    }
  }
  onChange(editableHost) {
    if (this.config.checkOnChange) {
      this.editableHasChanged(editableHost, this.config.throttle);
    }
    if (this.config.removeOnCorrection) {
      this.removeHighlightsAtCursor(editableHost);
    }
  }
  editableHasChanged(editableHost, throttle2) {
    if (this.timeout.id && this.timeout.editableHost === editableHost) {
      clearTimeout(this.timeout.id);
    }
    const timeoutId = setTimeout(() => {
      this.highlight(editableHost);
      this.timeout = {};
    }, throttle2 || 0);
    this.timeout = {
      id: timeoutId,
      editableHost
    };
  }
  highlight(editableHost) {
    let text2 = highlightText.extractText(editableHost);
    this.spellcheckService.check(text2, (err2, misspelledWords) => {
      if (err2) {
        return;
      }
      text2 = highlightText.extractText(editableHost);
      const matchCollection = new MatchCollection();
      let matches2 = this.spellcheck.findMatches(text2, misspelledWords);
      matchCollection.addMatches("spellcheck", matches2);
      matches2 = this.whitespace.findMatches(text2);
      matchCollection.addMatches("whitespace", matches2);
      this.safeHighlightMatches(editableHost, matchCollection.matches);
    });
  }
  safeHighlightMatches(editableHost, matches2) {
    const selection = this.editable.getSelection(editableHost);
    if (selection) {
      selection.retainVisibleSelection(() => {
        this.highlightMatches(editableHost, matches2);
      });
    } else {
      this.highlightMatches(editableHost, matches2);
    }
    if (this.editable.dispatcher) {
      this.editable.dispatcher.notify("spellcheckUpdated", editableHost);
    }
  }
  highlightMatches(editableHost, matches2) {
    this.removeHighlights(editableHost);
    if (matches2 && matches2.length > 0) {
      highlightText.highlightMatches(editableHost, matches2);
    }
  }
  removeHighlights(editableHost) {
    editableHost = domSelector(editableHost, this.win.document);
    for (const elem of domArray('[data-highlight="spellcheck"]', editableHost)) {
      unwrap(elem);
    }
  }
  removeHighlightsAtCursor(editableHost) {
    editableHost = domSelector(editableHost, this.win.document);
    const selection = this.editable.getSelection(editableHost);
    if (selection && selection.isCursor) {
      let elementAtCursor = selection.range.startContainer;
      if (elementAtCursor.nodeType === textNode) {
        elementAtCursor = elementAtCursor.parentNode;
      }
      let wordId;
      do {
        if (elementAtCursor === editableHost)
          return;
        const highlightType = elementAtCursor.getAttribute("data-highlight");
        if (highlightType === "spellcheck") {
          wordId = elementAtCursor.getAttribute("data-word-id");
          break;
        }
      } while (elementAtCursor = elementAtCursor.parentNode);
      if (wordId) {
        selection.retainVisibleSelection(() => {
          for (const elem of domArray(`[data-word-id="${wordId}"]`, editableHost)) {
            unwrap(elem);
          }
        });
      }
    }
  }
}
function log$1() {
  if (config$1.log === false)
    return;
  if (!global.console)
    return;
  const args2 = arguments.length === 1 ? arguments[0] : Array.from(arguments);
  if (arguments.length !== 1 && args2[args2.length - 1] === "trace") {
    args2.pop();
    if (console.trace)
      console.trace();
  }
  return console.log(args2);
}
function createDefaultBehavior(editable) {
  const document2 = editable.win.document;
  return {
    focus(element2) {
      if (!isVoid(element2))
        return;
      element2.appendChild(document2.createTextNode("\uFEFF"));
    },
    blur(element2) {
      cleanInternals(element2);
    },
    selection(element2, selection) {
      log$1(selection ? "Default selection behavior" : "Default selection empty behavior");
    },
    cursor(element2, cursor) {
      log$1(cursor ? "Default cursor behavior" : "Default cursor empty behavior");
    },
    newline(element2, cursor) {
      var _a2;
      if (cursor.isAtTextEnd()) {
        const br = document2.createElement("br");
        cursor.insertBefore(br);
        if (((_a2 = br.nextSibling) == null ? void 0 : _a2.nodeType) !== textNode || br.nextSibling.textContent[0] !== "\uFEFF") {
          cursor.insertAfter(document2.createTextNode("\uFEFF"));
        }
      } else {
        cursor.insertBefore(document2.createElement("br"));
      }
      cursor.setVisibleSelection();
    },
    insert(element2, direction, cursor) {
      const parent = element2.parentNode;
      const newElement = element2.cloneNode(false);
      if (newElement.id)
        newElement.removeAttribute("id");
      switch (direction) {
        case "before":
          parent.insertBefore(newElement, element2);
          element2.focus();
          break;
        case "after":
          parent.insertBefore(newElement, element2.nextSibling);
          newElement.focus();
          break;
      }
    },
    split(element2, before, after, cursor) {
      const newNode = element2.cloneNode(false);
      newNode.appendChild(before);
      const parent = element2.parentNode;
      parent.insertBefore(newNode, element2);
      while (element2.firstChild)
        element2.removeChild(element2.firstChild);
      element2.appendChild(after);
      tidyHtml(newNode);
      tidyHtml(element2);
      element2.focus();
    },
    merge(element2, direction, cursor) {
      let container, merger;
      switch (direction) {
        case "before":
          container = previous(element2);
          merger = element2;
          break;
        case "after":
          container = element2;
          merger = next(element2);
          break;
      }
      if (!(container && merger))
        return;
      cursor = container.childNodes.length > 0 ? editable.appendTo(container, merger.innerHTML) : editable.prependTo(container, merger.innerHTML);
      merger.remove();
      cursor.save();
      tidyHtml(container);
      cursor.restore();
      cursor.setVisibleSelection();
    },
    empty(element2) {
      log$1("Default empty behavior");
    },
    switch(element2, direction, cursor) {
      switch (direction) {
        case "before":
          const previous$1 = previous(element2);
          if (previous$1) {
            cursor.moveAtTextEnd(previous$1);
            cursor.setVisibleSelection();
          }
          break;
        case "after":
          const next$1 = next(element2);
          if (next$1) {
            cursor.moveAtBeginning(next$1);
            cursor.setVisibleSelection();
          }
          break;
      }
    },
    move(element2, selection, direction) {
      log$1("Default move behavior");
    },
    paste(element2, blocks, cursor) {
      if (blocks.length === 0)
        return;
      cursor.insertBefore(blocks.shift());
      if (blocks.length === 0)
        return cursor.setVisibleSelection();
      const parent = element2.parentNode;
      let currentElement = element2;
      blocks.forEach((str2) => {
        const newElement = element2.cloneNode(false);
        if (newElement.id)
          newElement.removeAttribute("id");
        const fragment = createFragmentFromString(str2);
        newElement.appendChild(fragment);
        parent.insertBefore(newElement, currentElement.nextSibling);
        currentElement = newElement;
      });
      editable.createCursorAtEnd(currentElement).setVisibleSelection();
    },
    clipboard(element2, action, cursor) {
      log$1("Default clipboard behavior");
    },
    toggleBold(selection) {
      selection.toggleBold();
    },
    toggleEmphasis(selection) {
      selection.toggleEmphasis();
    }
  };
}
function createDefaultEvents(editable) {
  const behavior = createDefaultBehavior(editable);
  return {
    focus(element2) {
      behavior.focus(element2);
    },
    blur(element2) {
      behavior.blur(element2);
    },
    flow(element2, action) {
      behavior.flow(element2, action);
    },
    selection(element2, selection) {
      behavior.selection(element2, selection);
    },
    cursor(element2, cursor) {
      behavior.cursor(element2, cursor);
    },
    newline(element2, cursor) {
      behavior.newline(element2, cursor);
    },
    split(element2, before, after, cursor) {
      behavior.split(element2, before, after, cursor);
    },
    insert(element2, direction, cursor) {
      behavior.insert(element2, direction, cursor);
    },
    merge(element2, direction, cursor) {
      behavior.merge(element2, direction, cursor);
    },
    empty(element2) {
      behavior.empty(element2);
    },
    switch(element2, direction, cursor) {
      behavior.switch(element2, direction, cursor);
    },
    move(element2, selection, direction) {
      behavior.move(element2, selection, direction);
    },
    clipboard(element2, action, selection) {
      behavior.clipboard(element2, action, selection);
    },
    paste(element2, blocks, cursor) {
      behavior.paste(element2, blocks, cursor);
    },
    toggleBold(selection) {
      behavior.toggleBold(selection);
    },
    toggleEmphasis(selection) {
      behavior.toggleEmphasis(selection);
    }
  };
}
function textNodesUnder(node) {
  const iterator = new NodeIterator(node, "getNextTextNode");
  return [...iterator];
}
function getTextNodeAndRelativeOffset({ textNodes, absOffset }) {
  let cumulativeOffset = 0;
  let relativeOffset = 0;
  let targetNode;
  for (let i2 = 0; i2 < textNodes.length; i2++) {
    const node = textNodes[i2];
    if (absOffset <= cumulativeOffset + node.textContent.length) {
      targetNode = node;
      relativeOffset = absOffset - cumulativeOffset;
      break;
    }
    cumulativeOffset += node.textContent.length;
  }
  return { node: targetNode, relativeOffset };
}
function getTotalCharCount(element2) {
  const textNodes = textNodesUnder(element2);
  const reducer = (acc, node) => acc + node.textContent.length;
  return textNodes.reduce(reducer, 0);
}
function binaryCursorSearch({
  host,
  requiredOnFirstLine,
  requiredOnLastLine,
  positionX
}) {
  const hostRange = host.ownerDocument.createRange();
  hostRange.selectNodeContents(host);
  const hostCoords = hostRange.getBoundingClientRect();
  const totalCharCount = getTotalCharCount(host);
  const textNodes = textNodesUnder(host);
  if (totalCharCount === 0)
    return { wasFound: false };
  const data = {
    currentOffset: Math.floor(totalCharCount / 2),
    leftLimit: 0,
    rightLimit: totalCharCount
  };
  let offset = data.currentOffset;
  let distance;
  let safety = 20;
  while (data.leftLimit < data.rightLimit && safety > 0) {
    safety = safety -= 1;
    offset = data.currentOffset;
    const range3 = createRangeAtCharacterOffset({ textNodes, offset: data.currentOffset });
    const coords2 = range3.getBoundingClientRect();
    distance = Math.abs(coords2.left - positionX);
    if (requiredOnFirstLine && hostCoords.top !== coords2.top) {
      moveLeft(data);
      continue;
    } else if (requiredOnLastLine && hostCoords.bottom !== coords2.bottom) {
      moveRight(data);
      continue;
    }
    if (positionX < coords2.left) {
      moveLeft(data);
    } else {
      moveRight(data);
    }
  }
  const range2 = createRangeAtCharacterOffset({ textNodes, offset: data.currentOffset });
  const coords = range2.getBoundingClientRect();
  const finalDistance = Math.abs(coords.left - positionX);
  if (finalDistance < distance) {
    distance = finalDistance;
    offset = data.currentOffset;
  }
  return { distance, offset, wasFound: true };
}
function moveLeft(data) {
  data.rightLimit = data.currentOffset;
  data.currentOffset = Math.floor((data.currentOffset + data.leftLimit) / 2);
}
function moveRight(data) {
  data.leftLimit = data.currentOffset;
  data.currentOffset = Math.ceil((data.currentOffset + data.rightLimit) / 2);
}
function createRangeAtCharacterOffset({ textNodes, offset }) {
  const { node, relativeOffset } = getTextNodeAndRelativeOffset({ textNodes, absOffset: offset });
  const newRange = node.ownerDocument.createRange();
  newRange.setStart(node, relativeOffset);
  newRange.collapse(true);
  return newRange;
}
class Editable {
  constructor(instanceConfig) {
    const defaultInstanceConfig = {
      window,
      defaultBehavior: true,
      mouseMoveSelectionChanges: false,
      browserSpellcheck: true
    };
    this.config = Object.assign(defaultInstanceConfig, instanceConfig);
    this.win = this.config.window;
    this.editableSelector = `.${config$1.editableClass}`;
    if (!rangy.initialized) {
      rangy.init();
    }
    this.dispatcher = new Dispatcher(this);
    if (this.config.defaultBehavior === true) {
      this.dispatcher.on(createDefaultEvents(this));
    }
  }
  static getGlobalConfig() {
    return config$1;
  }
  static globalConfig(globalConfig) {
    Object.assign(config$1, globalConfig);
    updateConfig(config$1);
  }
  add(target) {
    this.enable(target);
    return this;
  }
  remove(target) {
    const targets = domArray(target, this.win.document);
    this.disable(targets);
    for (const element2 of targets) {
      element2.classList.remove(config$1.editableDisabledClass);
    }
    return this;
  }
  disable(target) {
    const targets = domArray(target || `.${config$1.editableClass}`, this.win.document);
    for (const element2 of targets) {
      disable(element2);
    }
    return this;
  }
  enable(target, normalize3) {
    const shouldSpellcheck = this.config.browserSpellcheck;
    const targets = domArray(target || `.${config$1.editableDisabledClass}`, this.win.document);
    for (const element2 of targets) {
      init(element2, { normalize: normalize3, shouldSpellcheck });
      this.dispatcher.notify("init", element2);
    }
    return this;
  }
  suspend(target) {
    const targets = domArray(target || `.${config$1.editableClass}`, this.win.document);
    for (const element2 of targets) {
      element2.removeAttribute("contenteditable");
    }
    this.dispatcher.suspend();
    return this;
  }
  continue(target) {
    const targets = domArray(target || `.${config$1.editableClass}`, this.win.document);
    for (const element2 of targets) {
      element2.setAttribute("contenteditable", true);
    }
    this.dispatcher.continue();
    return this;
  }
  createCursor(element2, position2 = "beginning") {
    const host = Cursor.findHost(element2, this.editableSelector);
    if (!host)
      return void 0;
    const range2 = rangy.createRange();
    if (position2 === "beginning" || position2 === "end") {
      range2.selectNodeContents(element2);
      range2.collapse(position2 === "beginning");
    } else if (element2 !== host) {
      if (position2 === "before") {
        range2.setStartBefore(element2);
        range2.setEndBefore(element2);
      } else if (position2 === "after") {
        range2.setStartAfter(element2);
        range2.setEndAfter(element2);
      }
    } else {
      error("EditableJS: cannot create cursor outside of an editable block.");
    }
    return new Cursor(host, range2);
  }
  createCursorAtCharacterOffset({ element: element2, offset }) {
    const textNodes = textNodesUnder(element2);
    const { node, relativeOffset } = getTextNodeAndRelativeOffset({ textNodes, absOffset: offset });
    const newRange = rangy.createRange();
    newRange.setStart(node, relativeOffset);
    newRange.collapse(true);
    const host = Cursor.findHost(element2, this.editableSelector);
    const nextCursor = new Cursor(host, newRange);
    nextCursor.setVisibleSelection();
    return nextCursor;
  }
  createCursorAtBeginning(element2) {
    return this.createCursor(element2, "beginning");
  }
  createCursorAtEnd(element2) {
    return this.createCursor(element2, "end");
  }
  createCursorBefore(element2) {
    return this.createCursor(element2, "before");
  }
  createCursorAfter(element2) {
    return this.createCursor(element2, "after");
  }
  getContent(element2) {
    return extractContent(element2);
  }
  appendTo(inputElement, contentToAppend) {
    const element2 = adoptElement(inputElement, this.win.document);
    const cursor = this.createCursor(element2, "end");
    cursor.insertAfter(typeof contentToAppend === "string" ? createFragmentFromString(contentToAppend) : contentToAppend);
    return cursor;
  }
  prependTo(inputElement, contentToPrepend) {
    const element2 = adoptElement(inputElement, this.win.document);
    const cursor = this.createCursor(element2, "beginning");
    cursor.insertBefore(typeof contentToPrepend === "string" ? createFragmentFromString(contentToPrepend) : contentToPrepend);
    return cursor;
  }
  getSelection(editableHost) {
    let selection = this.dispatcher.selectionWatcher.getFreshSelection();
    if (!(editableHost && selection))
      return selection;
    const range2 = selection.range;
    try {
      if (range2.compareNode(editableHost) !== range2.NODE_BEFORE_AND_AFTER) {
        selection = void 0;
      }
    } catch (e) {
      selection = void 0;
    }
    return selection;
  }
  setupHighlighting(hightlightingConfig) {
    this.highlighting = new Highlighting(this, hightlightingConfig);
    return this;
  }
  setupSpellcheck(conf) {
    let marker2;
    if (conf.markerNode) {
      marker2 = conf.markerNode.outerHTML;
    }
    this.setupHighlighting({
      throttle: conf.throttle,
      spellcheck: {
        marker: marker2,
        spellcheckService: conf.spellcheckService
      }
    });
    this.spellcheck = {
      checkSpelling: (elem) => {
        this.highlighting.highlight(elem);
      }
    };
  }
  highlight({ editableHost, text: text2, highlightId, textRange, raiseEvents, type: type2 = "comment" }) {
    if (!textRange) {
      return highlightSupport.highlightText(editableHost, text2, highlightId, type2);
    }
    if (typeof textRange.start !== "number" || typeof textRange.end !== "number") {
      error("Error in Editable.highlight: You passed a textRange object with invalid keys. Expected shape: { start: Number, end: Number }");
      return -1;
    }
    if (textRange.start === textRange.end) {
      error("Error in Editable.highlight: You passed a textRange object with equal start and end offsets, which is considered a cursor and therefore unfit to create a highlight.");
      return -1;
    }
    return highlightSupport.highlightRange(editableHost, highlightId, textRange.start, textRange.end, raiseEvents ? this.dispatcher : void 0, type2);
  }
  getHighlightPositions({ editableHost, type: type2 }) {
    return highlightSupport.extractHighlightedRanges(editableHost, type2);
  }
  removeHighlight({ editableHost, highlightId, raiseEvents }) {
    highlightSupport.removeHighlight(editableHost, highlightId, raiseEvents ? this.dispatcher : void 0);
  }
  decorateHighlight({ editableHost, highlightId, addCssClass, removeCssClass }) {
    highlightSupport.updateHighlight(editableHost, highlightId, addCssClass, removeCssClass);
  }
  on(event2, handler) {
    this.dispatcher.on(event2, handler);
    return this;
  }
  off(...args2) {
    this.dispatcher.off.apply(this.dispatcher, args2);
    return this;
  }
  unload() {
    this.dispatcher.unload();
    return this;
  }
  findClosestCursorOffset({
    element: element2,
    origCoordinates,
    requiredOnFirstLine = false,
    requiredOnLastLine = false
  }) {
    const positionX = this.dispatcher.switchContext ? this.dispatcher.switchContext.positionX : origCoordinates.left;
    return binaryCursorSearch({
      host: element2,
      requiredOnFirstLine,
      requiredOnLastLine,
      positionX
    });
  }
}
Editable.parser = parser$1;
Editable.content = content;
Editable.browser = Bowser;
[
  "focus",
  "blur",
  "flow",
  "selection",
  "cursor",
  "newline",
  "insert",
  "split",
  "merge",
  "empty",
  "change",
  "switch",
  "move",
  "clipboard",
  "paste",
  "spellcheckUpdated",
  "selectToBoundary"
].forEach((name) => {
  Editable.prototype[name] = function(handler) {
    return this.on(name, handler);
  };
});
const setEndOfContenteditable = (editingElement, el2, pos) => {
  const selection = window.getSelection();
  const range2 = document.createRange();
  selection.removeAllRanges();
  if (pos) {
    range2.setStart(editingElement.childNodes[0], pos);
  } else {
    range2.selectNodeContents(el2);
    range2.collapse(false);
  }
  selection.addRange(range2);
};
const CANVAS_TEMPLATE = {
  version: "2.2.11",
  width: 2e3,
  height: 2e3,
  scrollTop: 0,
  scrollLeft: 0,
  zoomLevel: 1,
  show: {
    tableComment: false,
    columnComment: false,
    columnDataType: true,
    columnDefault: true,
    columnAutoIncrement: false,
    columnPrimaryKey: true,
    columnUnique: true,
    columnNotNull: true,
    relationship: true
  },
  database: "PostgreSQL",
  databaseName: "",
  canvasType: "ERD",
  language: "GraphQL",
  tableCase: "snakeCase",
  columnCase: "snakeCase",
  highlightTheme: "VS2015",
  bracketType: "none",
  setting: {
    relationshipDataTypeSync: true,
    relationshipOptimization: false,
    columnOrder: [
      "columnName",
      "columnDataType",
      "columnNotNull",
      "columnUnique",
      "columnAutoIncrement",
      "columnDefault",
      "columnComment"
    ]
  },
  pluginSerializationMap: {}
};
const createTableTemplate = (table, id) => {
  let result2 = {
    name: table.schema != "public" ? table.schema + "." + table.name : table.name,
    comment: "",
    columns: [],
    visible: true,
    id: "" + id,
    ui: {
      active: false,
      left: 50 + id % 4 * 500,
      top: 50 + Math.floor(id / 4) * 300,
      zIndex: 1,
      widthName: 60,
      widthComment: 60
    }
  };
  result2.columns = table.columns.map((column, index2) => {
    return {
      id: id + "-" + index2,
      name: column.name,
      comment: "",
      dataType: column.type,
      default: column.default === "NULL" ? "" : column.default,
      option: {
        autoIncrement: column.name === table.primaryKey,
        primaryKey: column.name === table.primaryKey,
        unique: column.name === table.primaryKey,
        notNull: !column.nullable
      },
      ui: {
        active: false,
        pk: column.name === table.primaryKey,
        fk: false,
        pfk: false,
        widthName: 0,
        widthComment: 0,
        widthDataType: 0,
        widthDefault: 0
      }
    };
  });
  return result2;
};
const createRelationshipTemplate = (foreignKey, id, tables) => {
  let endIndex = tables.findIndex((table) => table.name === foreignKey.tableName && table.schema === foreignKey.tableSchema);
  let startIndex = tables.findIndex((table) => table.name === foreignKey.referenceTable && table.schema === foreignKey.referenceSchema);
  let result2 = {
    id: "fk-" + id,
    identification: false,
    relationshipType: "ZeroN",
    startRelationshipType: "Dash",
    start: {
      tableId: "" + startIndex,
      columnIds: [
        startIndex + "-" + tables[startIndex].columns.findIndex((column) => column.name === foreignKey.referenceColumn)
      ],
      x: 0,
      y: 0,
      direction: "right"
    },
    end: {
      tableId: "" + endIndex,
      columnIds: [
        endIndex + "-" + tables[endIndex].columns.findIndex((column) => column.name === foreignKey.constraintColumn)
      ],
      x: 0,
      y: 0,
      direction: "left"
    },
    constraintName: foreignKey.constraintName,
    visible: true
  };
  return result2;
};
const addForeignKeyUI = (vuerd, sqlData) => {
  sqlData.foreignKeys.forEach((foreignKey) => {
    let tableIndex = sqlData.tables.findIndex((table) => table.name === foreignKey.tableName && table.schema === foreignKey.tableSchema);
    let columnIndex = sqlData.tables[tableIndex].columns.findIndex((column) => column.name === foreignKey.constraintColumn);
    vuerd.table.tables[tableIndex].columns[columnIndex].ui.fk = true;
  });
  return vuerd;
};
const createVuerdTemplate = (sqlData) => {
  let result2 = {
    canvas: CANVAS_TEMPLATE,
    table: {
      tables: [],
      indexes: []
    },
    memo: {
      memos: []
    },
    relationship: {
      relationships: []
    }
  };
  result2.table.tables = sqlData.tables.map((table, index2) => {
    return createTableTemplate(table, index2);
  });
  result2.relationship.relationships = sqlData.foreignKeys.map((foreignKey, index2) => {
    return createRelationshipTemplate(foreignKey, index2, sqlData.tables);
  });
  result2 = addForeignKeyUI(result2, sqlData);
  return result2;
};
const defaultTheme = {
  primary: "#3f51b5",
  secondary: "#9c27b0",
  error: "#d32f2f",
  warning: "#ed6c02",
  info: "#0288d1",
  success: "#2e7d32",
  background: "#ffffff",
  divider: "rgba(0, 0, 0, 0.12)"
};
const createThemeFile = async (file, frontendActions2) => {
  frontendActions2.fileWrite(file, JSON.stringify(defaultTheme, void 0, 2));
};
const getTheme = async (path2, fileName = "colors", io, frontendActions2) => {
  if (path2) {
    const file = (await io.readDirectory(path2)).find((dir) => (dir == null ? void 0 : dir.fileName) === fileName + ".json");
    if (!file) {
      createThemeFile(path2 + "/" + fileName + ".json", frontendActions2);
    }
    const theme = await io.readFile(file == null ? void 0 : file.filePath);
    if (!theme) {
      console.log("Theme does not exist, creating...");
      return null;
    }
    return { file: file.filePath, [fileName]: JSON.parse(theme) };
  }
  return null;
};
const generateTables = (data) => {
  let tables;
  tables = data.table.tables.map((table) => {
    let schema2;
    let tableName;
    let index2 = table.name.indexOf(".");
    if (index2 !== -1) {
      schema2 = table.name.substring(0, index2);
      tableName = table.name.substring(index2 + 1, table.name.length);
    } else {
      schema2 = "public";
      tableName = table.name;
    }
    let columns = [];
    columns = table.columns.map((column) => {
      return {
        name: column.name,
        type: column.dataType,
        nullable: !column.option.notNull,
        default: column.default,
        unique: column.option.unique
      };
    });
    return {
      schema: schema2,
      name: tableName,
      primaryKey: "",
      columns
    };
  });
  return tables;
};
const generateDBConstraints = (intro, constraints) => {
  let newConstraints = [];
  let typesCollection2 = setTypes(intro.types);
  let constraintMap = setConstraintInfo(constraints);
  constraintMap.forEach((constraints2) => {
    constraints2.filter((constraint) => constraint.constraintName.includes(FOREIGN_KEY)).forEach((constraint) => {
      newConstraints.push(...getConstraints(constraint, typesCollection2, constraintMap));
    });
  });
  return newConstraints;
};
const compareTables = (tablesDB, tablesERD) => {
  const uniqueDB = new Set(tablesDB == null ? void 0 : tablesDB.map((item) => item.schema + "." + item.name));
  const uniqueERD = [
    ...new Set(tablesERD == null ? void 0 : tablesERD.map((item) => item.schema + "." + item.name))
  ];
  return uniqueERD.filter((element2) => !uniqueDB.has(element2));
};
const createTablesMap = (tables) => {
  let map2 = /* @__PURE__ */ new Map();
  tables.forEach((table) => {
    map2.set(table.schema + "." + table.name, table.columns);
  });
  return map2;
};
const createColumnMap = (columns) => {
  let map2 = /* @__PURE__ */ new Map();
  columns.forEach((column) => {
    map2.set(column.name, column);
  });
  return map2;
};
const differentColumns = (dbColumns, erdColumns) => {
  const uniqueDB = new Set(dbColumns == null ? void 0 : dbColumns.map((item) => item.name));
  const uniqueERD = [...new Set(erdColumns == null ? void 0 : erdColumns.map((item) => item.name))];
  return uniqueERD.filter((element2) => !uniqueDB.has(element2));
};
const returnType = (dataType) => {
  return dataTypes.filter((type2) => type2.name === dataType)[0].type;
};
const compareColumns = (tablesDB, tablesERD) => {
  let newColumns = /* @__PURE__ */ new Map();
  let dbMap = createTablesMap(tablesDB);
  let erdMap = createTablesMap(tablesERD);
  erdMap.forEach((columns, table) => {
    let dbColumns = dbMap.get(table);
    dbColumns = dbColumns != null ? dbColumns : [];
    if (dbColumns && columns.length > dbColumns.length) {
      let difference = differentColumns(dbColumns, columns);
      let columnMap = createColumnMap(columns);
      difference.forEach((columnName) => {
        let column = columnMap.get(columnName);
        table = table.toString();
        let index2 = table.indexOf(".");
        if (column) {
          newColumns.set(table + "." + columnName, {
            schema: table.substring(0, index2),
            migration: false,
            tableName: table.substring(index2 + 1, table.length),
            columnName,
            type: returnType(column.type),
            nullable: column.nullable,
            unique: column.unique ? column.unique : false,
            defaultValue: column.default,
            foreignKey: {
              referenceSchema: "",
              referenceTable: "",
              referenceColumn: "",
              updateConstraints: "restrict",
              deleteConstraints: "restrict"
            }
          });
        }
      });
    }
  });
  return newColumns;
};
const differentConstraints = (cosntraintDB, constraintsERD) => {
  const uniqueDB = new Set(cosntraintDB == null ? void 0 : cosntraintDB.map((item) => item.constraintName));
  const uniqueERD = [
    ...new Set(constraintsERD == null ? void 0 : constraintsERD.map((item) => item.constraintName))
  ];
  return uniqueERD.filter((element2) => !uniqueDB.has(element2));
};
const setConstraints = (constraints) => {
  const constraintMap = /* @__PURE__ */ new Map();
  constraints.forEach((constraint) => {
    constraintMap.set(constraint.constraintName, constraint);
  });
  return constraintMap;
};
const setIdList = (data) => {
  const map2 = /* @__PURE__ */ new Map();
  data.table.tables.forEach((table) => {
    map2.set(table.id, { data: table });
    table.columns.forEach((column) => {
      map2.set(column.id, { data: column });
    });
  });
  return map2;
};
const compareConstraint = (data, intro, constraints, newColumns) => {
  const constraintDB = generateDBConstraints(intro, constraints);
  const constraintsERD = data.relationship.relationships;
  const constraintMap = setConstraints(constraintsERD);
  const idMap = setIdList(data);
  let difference = differentConstraints(constraintDB, constraintsERD);
  difference.forEach((constraintName) => {
    var _a2, _b, _c, _d;
    let constraint = constraintMap.get(constraintName);
    if (constraint) {
      const startInfo = constraint.start;
      const endInfo = constraint.end;
      const referenceTable = (_a2 = idMap.get(startInfo.tableId)) == null ? void 0 : _a2.data.name;
      const index2 = referenceTable ? referenceTable.indexOf(".") : -1;
      const referenceColumn = (_b = idMap.get(startInfo.columnIds[0])) == null ? void 0 : _b.data.name;
      let tableName = (_c = idMap.get(endInfo.tableId)) == null ? void 0 : _c.data.name;
      tableName = (tableName == null ? void 0 : tableName.indexOf(".")) !== -1 ? tableName : "public." + tableName;
      const table = tableName + "." + ((_d = idMap.get(endInfo.columnIds[0])) == null ? void 0 : _d.data.name);
      let column = newColumns.get(table);
      let schema2 = index2 === -1 ? "public" : referenceTable == null ? void 0 : referenceTable.substring(0, index2);
      if (column) {
        column.defaultValue = "";
        column.foreignKey = {
          referenceSchema: schema2 ? schema2 : "",
          referenceTable: referenceTable ? referenceTable.substring(index2 + 1, referenceTable.length) : "",
          referenceColumn: referenceColumn ? referenceColumn : "",
          updateConstraints: "restrict",
          deleteConstraints: "restrict"
        };
        newColumns.set(table, column);
      }
    }
  });
  return newColumns;
};
const generateColumns = (tables, data, intro, constraints) => {
  let map2 = compareColumns(tables.tablesDB, tables.tablesERD);
  map2 = compareConstraint(data, intro, constraints, map2);
  return Array.from(map2.values());
};
const checkResponse = (response) => {
  if (!response.ok) {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: {
        type: `CREATE_TABLE_ERROR`
      }
    });
  }
  return response.ok;
};
async function createNewTable(tableInfo, workbench2) {
  let columnNames;
  let response = await fetchHasuraQuery(createTable$1(tableInfo), "create_table_" + tableInfo.name, tableInfo.migration, workbench2);
  if (!checkResponse(response)) {
    return Promise.reject();
  }
  await fetchHasuraQuery(getColumnNames(tableInfo), "get_columns", false, workbench2).then(handleErrors).then((res2) => columnNames = getColumns(res2, void 0));
  await fetchHasuraMetadata(trackTable(tableInfo), workbench2);
  await fetchHasuraMetadata(changeColumnName(tableInfo, columnNames), workbench2);
  return await createPermissions(tableInfo, workbench2);
}
const saveDatabase = async (props) => {
  window.postMessage({
    type: "SHOW_USER_FEEDBACK",
    payload: {
      type: `UPDATE_DATABASE_INFO`
    }
  });
  let sqlTablesDB = generateSQLData(props.introspection, props.tablesInfo, [...props.constraintInfo]).tables;
  let sqlTablesERD = generateTables(props.jsonData);
  let newTables = compareTables(sqlTablesDB, sqlTablesERD);
  if (newTables.length) {
    let index2;
    for (const newTable of newTables) {
      index2 = newTable.indexOf(".");
      const response = await createNewTable({
        schema: newTable.substring(0, index2),
        name: newTable.substring(index2 + 1, newTable.length),
        migration: props.migration
      }, props.workbench);
      if (!checkResponse(response)) {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `UPDATE_DATABASE_ERROR`
          }
        });
        return Promise.reject();
      }
    }
  }
  const newColumns = generateColumns({ tablesDB: sqlTablesDB, tablesERD: sqlTablesERD }, props.jsonData, props.introspection, [...props.constraintInfo]);
  if (newColumns.length) {
    for (const newColumn of newColumns) {
      let error2 = void 0;
      await addNewColumn$1(newColumn, props.migration, props.workbench).catch((err2) => error2 = err2);
      if (error2)
        return Promise.reject(error2);
    }
  }
  return Promise.resolve();
};
const addNewColumn$1 = (columnProps, migration, workbench2) => {
  let error2 = void 0;
  createColumn(columnProps, migration, workbench2).then(() => {
    return resolveForeignKey(columnProps, workbench2, "UPDATE_DATABASE_ERROR", false);
  }).catch((err2) => {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: {
        type: `UPDATE_DATABASE_ERROR`
      }
    });
    error2 = err2;
  });
  return error2 ? Promise.reject(error2) : Promise.resolve();
};
var LIB;
LIB = (() => {
  var t = { 470: (t2) => {
    function e2(t3) {
      if (typeof t3 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", o = 0, i2 = -1, a = 0, h = 0; h <= t3.length; ++h) {
        if (h < t3.length)
          r3 = t3.charCodeAt(h);
        else {
          if (r3 === 47)
            break;
          r3 = 47;
        }
        if (r3 === 47) {
          if (i2 === h - 1 || a === 1)
            ;
          else if (i2 !== h - 1 && a === 2) {
            if (n3.length < 2 || o !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
              if (n3.length > 2) {
                var s = n3.lastIndexOf("/");
                if (s !== n3.length - 1) {
                  s === -1 ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, s)).length - 1 - n3.lastIndexOf("/"), i2 = h, a = 0;
                  continue;
                }
              } else if (n3.length === 2 || n3.length === 1) {
                n3 = "", o = 0, i2 = h, a = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
          } else
            n3.length > 0 ? n3 += "/" + t3.slice(i2 + 1, h) : n3 = t3.slice(i2 + 1, h), o = h - i2 - 1;
          i2 = h, a = 0;
        } else
          r3 === 46 && a !== -1 ? ++a : a = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", o = false, i2 = arguments.length - 1; i2 >= -1 && !o; i2--) {
        var a;
        i2 >= 0 ? a = arguments[i2] : (t3 === void 0 && (t3 = process.cwd()), a = t3), e2(a), a.length !== 0 && (n3 = a + "/" + n3, o = a.charCodeAt(0) === 47);
      }
      return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), t3.length === 0)
        return ".";
      var n3 = t3.charCodeAt(0) === 47, o = t3.charCodeAt(t3.length - 1) === 47;
      return (t3 = r2(t3, !n3)).length !== 0 || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && t3.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var o = arguments[r3];
        e2(o), o.length > 0 && (t3 === void 0 ? t3 = o : t3 += "/" + o);
      }
      return t3 === void 0 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3)
        return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
        return "";
      for (var o = 1; o < t3.length && t3.charCodeAt(o) === 47; ++o)
        ;
      for (var i2 = t3.length, a = i2 - o, h = 1; h < r3.length && r3.charCodeAt(h) === 47; ++h)
        ;
      for (var s = r3.length - h, c2 = a < s ? a : s, f = -1, u = 0; u <= c2; ++u) {
        if (u === c2) {
          if (s > c2) {
            if (r3.charCodeAt(h + u) === 47)
              return r3.slice(h + u + 1);
            if (u === 0)
              return r3.slice(h + u);
          } else
            a > c2 && (t3.charCodeAt(o + u) === 47 ? f = u : u === 0 && (f = 0));
          break;
        }
        var l2 = t3.charCodeAt(o + u);
        if (l2 !== r3.charCodeAt(h + u))
          break;
        l2 === 47 && (f = u);
      }
      var p2 = "";
      for (u = o + f + 1; u <= i2; ++u)
        u !== i2 && t3.charCodeAt(u) !== 47 || (p2.length === 0 ? p2 += ".." : p2 += "/..");
      return p2.length > 0 ? p2 + r3.slice(h + f) : (h += f, r3.charCodeAt(h) === 47 && ++h, r3.slice(h));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), t3.length === 0)
        return ".";
      for (var r3 = t3.charCodeAt(0), n3 = r3 === 47, o = -1, i2 = true, a = t3.length - 1; a >= 1; --a)
        if ((r3 = t3.charCodeAt(a)) === 47) {
          if (!i2) {
            o = a;
            break;
          }
        } else
          i2 = false;
      return o === -1 ? n3 ? "/" : "." : n3 && o === 1 ? "//" : t3.slice(0, o);
    }, basename: function(t3, r3) {
      if (r3 !== void 0 && typeof r3 != "string")
        throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, o = 0, i2 = -1, a = true;
      if (r3 !== void 0 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3)
          return "";
        var h = r3.length - 1, s = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (c2 === 47) {
            if (!a) {
              o = n3 + 1;
              break;
            }
          } else
            s === -1 && (a = false, s = n3 + 1), h >= 0 && (c2 === r3.charCodeAt(h) ? --h == -1 && (i2 = n3) : (h = -1, i2 = s));
        }
        return o === i2 ? i2 = s : i2 === -1 && (i2 = t3.length), t3.slice(o, i2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3)
        if (t3.charCodeAt(n3) === 47) {
          if (!a) {
            o = n3 + 1;
            break;
          }
        } else
          i2 === -1 && (a = false, i2 = n3 + 1);
      return i2 === -1 ? "" : t3.slice(o, i2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, o = -1, i2 = true, a = 0, h = t3.length - 1; h >= 0; --h) {
        var s = t3.charCodeAt(h);
        if (s !== 47)
          o === -1 && (i2 = false, o = h + 1), s === 46 ? r3 === -1 ? r3 = h : a !== 1 && (a = 1) : r3 !== -1 && (a = -1);
        else if (!i2) {
          n3 = h + 1;
          break;
        }
      }
      return r3 === -1 || o === -1 || a === 0 || a === 1 && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
    }, format: function(t3) {
      if (t3 === null || typeof t3 != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (t3.length === 0)
        return r3;
      var n3, o = t3.charCodeAt(0), i2 = o === 47;
      i2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var a = -1, h = 0, s = -1, c2 = true, f = t3.length - 1, u = 0; f >= n3; --f)
        if ((o = t3.charCodeAt(f)) !== 47)
          s === -1 && (c2 = false, s = f + 1), o === 46 ? a === -1 ? a = f : u !== 1 && (u = 1) : a !== -1 && (u = -1);
        else if (!c2) {
          h = f + 1;
          break;
        }
      return a === -1 || s === -1 || u === 0 || u === 1 && a === s - 1 && a === h + 1 ? s !== -1 && (r3.base = r3.name = h === 0 && i2 ? t3.slice(1, s) : t3.slice(h, s)) : (h === 0 && i2 ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  }, 447: (t2, e2, r2) => {
    var n2;
    if (r2.r(e2), r2.d(e2, { URI: () => d, Utils: () => P }), typeof process == "object")
      n2 = process.platform === "win32";
    else if (typeof navigator == "object") {
      var o = navigator.userAgent;
      n2 = o.indexOf("Windows") >= 0;
    }
    var i2, a, h = (i2 = function(t3, e3) {
      return (i2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
        t4.__proto__ = e4;
      } || function(t4, e4) {
        for (var r3 in e4)
          Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
      })(t3, e3);
    }, function(t3, e3) {
      if (typeof e3 != "function" && e3 !== null)
        throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
      function r3() {
        this.constructor = t3;
      }
      i2(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
    }), s = /^\w[\w\d+.-]*$/, c2 = /^\//, f = /^\/\//;
    function u(t3, e3) {
      if (!t3.scheme && e3)
        throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
      if (t3.scheme && !s.test(t3.scheme))
        throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t3.path) {
        if (t3.authority) {
          if (!c2.test(t3.path))
            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (f.test(t3.path))
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    var l2 = "", p2 = "/", g = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
      function t3(t4, e3, r3, n3, o2, i3) {
        i3 === void 0 && (i3 = false), typeof t4 == "object" ? (this.scheme = t4.scheme || l2, this.authority = t4.authority || l2, this.path = t4.path || l2, this.query = t4.query || l2, this.fragment = t4.fragment || l2) : (this.scheme = function(t5, e4) {
          return t5 || e4 ? t5 : "file";
        }(t4, i3), this.authority = e3 || l2, this.path = function(t5, e4) {
          switch (t5) {
            case "https":
            case "http":
            case "file":
              e4 ? e4[0] !== p2 && (e4 = p2 + e4) : e4 = p2;
          }
          return e4;
        }(this.scheme, r3 || l2), this.query = n3 || l2, this.fragment = o2 || l2, u(this, i3));
      }
      return t3.isUri = function(e3) {
        return e3 instanceof t3 || !!e3 && typeof e3.authority == "string" && typeof e3.fragment == "string" && typeof e3.path == "string" && typeof e3.query == "string" && typeof e3.scheme == "string" && typeof e3.fsPath == "string" && typeof e3.with == "function" && typeof e3.toString == "function";
      }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
        return A(this, false);
      }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
        if (!t4)
          return this;
        var e3 = t4.scheme, r3 = t4.authority, n3 = t4.path, o2 = t4.query, i3 = t4.fragment;
        return e3 === void 0 ? e3 = this.scheme : e3 === null && (e3 = l2), r3 === void 0 ? r3 = this.authority : r3 === null && (r3 = l2), n3 === void 0 ? n3 = this.path : n3 === null && (n3 = l2), o2 === void 0 ? o2 = this.query : o2 === null && (o2 = l2), i3 === void 0 ? i3 = this.fragment : i3 === null && (i3 = l2), e3 === this.scheme && r3 === this.authority && n3 === this.path && o2 === this.query && i3 === this.fragment ? this : new y2(e3, r3, n3, o2, i3);
      }, t3.parse = function(t4, e3) {
        e3 === void 0 && (e3 = false);
        var r3 = g.exec(t4);
        return r3 ? new y2(r3[2] || l2, O(r3[4] || l2), O(r3[5] || l2), O(r3[7] || l2), O(r3[9] || l2), e3) : new y2(l2, l2, l2, l2, l2);
      }, t3.file = function(t4) {
        var e3 = l2;
        if (n2 && (t4 = t4.replace(/\\/g, p2)), t4[0] === p2 && t4[1] === p2) {
          var r3 = t4.indexOf(p2, 2);
          r3 === -1 ? (e3 = t4.substring(2), t4 = p2) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || p2);
        }
        return new y2("file", e3, t4, l2, l2);
      }, t3.from = function(t4) {
        var e3 = new y2(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
        return u(e3, true), e3;
      }, t3.prototype.toString = function(t4) {
        return t4 === void 0 && (t4 = false), w(this, t4);
      }, t3.prototype.toJSON = function() {
        return this;
      }, t3.revive = function(e3) {
        if (e3) {
          if (e3 instanceof t3)
            return e3;
          var r3 = new y2(e3);
          return r3._formatted = e3.external, r3._fsPath = e3._sep === v ? e3.fsPath : null, r3;
        }
        return e3;
      }, t3;
    }(), v = n2 ? 1 : void 0, y2 = function(t3) {
      function e3() {
        var e4 = t3 !== null && t3.apply(this, arguments) || this;
        return e4._formatted = null, e4._fsPath = null, e4;
      }
      return h(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
        return this._fsPath || (this._fsPath = A(this, false)), this._fsPath;
      }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
        return t4 === void 0 && (t4 = false), t4 ? w(this, true) : (this._formatted || (this._formatted = w(this, false)), this._formatted);
      }, e3.prototype.toJSON = function() {
        var t4 = { $mid: 1 };
        return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = v), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
      }, e3;
    }(d), m = ((a = {})[58] = "%3A", a[47] = "%2F", a[63] = "%3F", a[35] = "%23", a[91] = "%5B", a[93] = "%5D", a[64] = "%40", a[33] = "%21", a[36] = "%24", a[38] = "%26", a[39] = "%27", a[40] = "%28", a[41] = "%29", a[42] = "%2A", a[43] = "%2B", a[44] = "%2C", a[59] = "%3B", a[61] = "%3D", a[32] = "%20", a);
    function b(t3, e3) {
      for (var r3 = void 0, n3 = -1, o2 = 0; o2 < t3.length; o2++) {
        var i3 = t3.charCodeAt(o2);
        if (i3 >= 97 && i3 <= 122 || i3 >= 65 && i3 <= 90 || i3 >= 48 && i3 <= 57 || i3 === 45 || i3 === 46 || i3 === 95 || i3 === 126 || e3 && i3 === 47)
          n3 !== -1 && (r3 += encodeURIComponent(t3.substring(n3, o2)), n3 = -1), r3 !== void 0 && (r3 += t3.charAt(o2));
        else {
          r3 === void 0 && (r3 = t3.substr(0, o2));
          var a2 = m[i3];
          a2 !== void 0 ? (n3 !== -1 && (r3 += encodeURIComponent(t3.substring(n3, o2)), n3 = -1), r3 += a2) : n3 === -1 && (n3 = o2);
        }
      }
      return n3 !== -1 && (r3 += encodeURIComponent(t3.substring(n3))), r3 !== void 0 ? r3 : t3;
    }
    function C(t3) {
      for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
        var n3 = t3.charCodeAt(r3);
        n3 === 35 || n3 === 63 ? (e3 === void 0 && (e3 = t3.substr(0, r3)), e3 += m[n3]) : e3 !== void 0 && (e3 += t3[r3]);
      }
      return e3 !== void 0 ? e3 : t3;
    }
    function A(t3, e3) {
      var r3;
      return r3 = t3.authority && t3.path.length > 1 && t3.scheme === "file" ? "//".concat(t3.authority).concat(t3.path) : t3.path.charCodeAt(0) === 47 && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && t3.path.charCodeAt(2) === 58 ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2 && (r3 = r3.replace(/\//g, "\\")), r3;
    }
    function w(t3, e3) {
      var r3 = e3 ? C : b, n3 = "", o2 = t3.scheme, i3 = t3.authority, a2 = t3.path, h2 = t3.query, s2 = t3.fragment;
      if (o2 && (n3 += o2, n3 += ":"), (i3 || o2 === "file") && (n3 += p2, n3 += p2), i3) {
        var c3 = i3.indexOf("@");
        if (c3 !== -1) {
          var f2 = i3.substr(0, c3);
          i3 = i3.substr(c3 + 1), (c3 = f2.indexOf(":")) === -1 ? n3 += r3(f2, false) : (n3 += r3(f2.substr(0, c3), false), n3 += ":", n3 += r3(f2.substr(c3 + 1), false)), n3 += "@";
        }
        (c3 = (i3 = i3.toLowerCase()).indexOf(":")) === -1 ? n3 += r3(i3, false) : (n3 += r3(i3.substr(0, c3), false), n3 += i3.substr(c3));
      }
      if (a2) {
        if (a2.length >= 3 && a2.charCodeAt(0) === 47 && a2.charCodeAt(2) === 58)
          (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
        else if (a2.length >= 2 && a2.charCodeAt(1) === 58) {
          var u2;
          (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
        }
        n3 += r3(a2, true);
      }
      return h2 && (n3 += "?", n3 += r3(h2, false)), s2 && (n3 += "#", n3 += e3 ? s2 : b(s2, false)), n3;
    }
    function x2(t3) {
      try {
        return decodeURIComponent(t3);
      } catch (e3) {
        return t3.length > 3 ? t3.substr(0, 3) + x2(t3.substr(3)) : t3;
      }
    }
    var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function O(t3) {
      return t3.match(_) ? t3.replace(_, function(t4) {
        return x2(t4);
      }) : t3;
    }
    var P, j2 = r2(470), U = function(t3, e3, r3) {
      if (r3 || arguments.length === 2)
        for (var n3, o2 = 0, i3 = e3.length; o2 < i3; o2++)
          !n3 && o2 in e3 || (n3 || (n3 = Array.prototype.slice.call(e3, 0, o2)), n3[o2] = e3[o2]);
      return t3.concat(n3 || Array.prototype.slice.call(e3));
    }, I = j2.posix || j2;
    !function(t3) {
      t3.joinPath = function(t4) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3[r3 - 1] = arguments[r3];
        return t4.with({ path: I.join.apply(I, U([t4.path], e3, false)) });
      }, t3.resolvePath = function(t4) {
        for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
          e3[r3 - 1] = arguments[r3];
        var n3 = t4.path || "/";
        return t4.with({ path: I.resolve.apply(I, U([n3], e3, false)) });
      }, t3.dirname = function(t4) {
        var e3 = I.dirname(t4.path);
        return e3.length === 1 && e3.charCodeAt(0) === 46 ? t4 : t4.with({ path: e3 });
      }, t3.basename = function(t4) {
        return I.basename(t4.path);
      }, t3.extname = function(t4) {
        return I.extname(t4.path);
      };
    }(P || (P = {}));
  } }, e = {};
  function r(n2) {
    if (e[n2])
      return e[n2].exports;
    var o = e[n2] = { exports: {} };
    return t[n2](o, o.exports, r), o.exports;
  }
  return r.d = (t2, e2) => {
    for (var n2 in e2)
      r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  }, r(447);
})();
const { URI: URI$1, Utils } = LIB;
const getJsxIdentifierLength = (code2, source) => {
  const pos = startOfJsxIdentifier(code2, source);
  const node = astFindStart(code2, pos);
  if (!node)
    throw new Error("Unable to find node in AST");
  return node.end - node.pos;
};
const VSCODE_IFRAME_ID = "vscode-iframe";
const CONFIG_PATH = "/codegen.yml";
const transformObjectToUint8Array = (object) => {
  const data = Object.keys(object).map((k2) => object[k2]);
  const arr = new Uint8Array(data);
  return arr;
};
const uint8ToString = (content2) => {
  const buffer = Buffer.from(content2);
  return buffer.toString();
};
const notifyVSCodeFrontend = (path2, data) => {
  const vscodeIframe = document.getElementById(VSCODE_IFRAME_ID);
  if (!vscodeIframe)
    return;
  const { contentWindow } = vscodeIframe;
  vscodeIframe.focus();
  contentWindow.postMessage({
    command: "iteria.refreshFile",
    payload: { uri: URI$1.parse(path2), content: Buffer.from(data) }
  }, "*");
};
const dispatchFrontendFileWriteAction = (uri2, content2) => {
  const buffer = Buffer.from(content2);
  const stringContent = buffer.toString();
  frontendActions.frontendFileWrite(uri2.path, stringContent);
};
const navigateToSourceCodeVscode = async (source) => {
  var _a2;
  const filePath = normalizePath(source.fileName);
  const file = await workbench.readFile(filePath);
  if (!file) {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: { type: "NAVIGATE_TO_SOURCE_CODE_ERROR" }
    });
    return console.error("File not found in Workbench");
  }
  const vscodeIframe = document.getElementById(VSCODE_IFRAME_ID);
  if (!vscodeIframe) {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: { type: "NAVIGATE_TO_SOURCE_CODE_ERROR" }
    });
    return console.error("No VSCode Iframe found");
  }
  const identifierLength = getJsxIdentifierLength(file, source) + 1;
  window.windows.vscode.show();
  (_a2 = vscodeIframe == null ? void 0 : vscodeIframe.contentWindow) == null ? void 0 : _a2.postMessage({
    command: "iteria.navigateEditor",
    payload: {
      uri: URI$1.parse(filePath),
      lineNumber: source.lineNumber - 1,
      columnNumber: source.columnNumber - 1,
      identifierLength
    }
  }, "*");
};
const resolveFilename = (uri2) => {
  const pathParts = uri2.path.split("/").filter(Boolean);
  const basename2 = pathParts[pathParts.length - 1];
  return basename2;
};
const resolveDirname = (uri2) => {
  const pathParts = uri2.path.split("/").filter(Boolean);
  pathParts.pop();
  if (!pathParts.length) {
    return "/";
  }
  return pathParts.join("/");
};
const isEmptyOrSpaces = (str2) => {
  return str2 === null || str2.match(/^ *$/) !== null;
};
var VsCodeFSErrors = /* @__PURE__ */ ((VsCodeFSErrors2) => {
  VsCodeFSErrors2["FileNotFound"] = "FileNotFound";
  VsCodeFSErrors2["FileIsADirectory"] = "FileIsADirectory";
  VsCodeFSErrors2["FileExists"] = "FileExists";
  VsCodeFSErrors2["FileNotADirectory"] = "FileNotADirectory";
  return VsCodeFSErrors2;
})(VsCodeFSErrors || {});
class VSCodeFSTransferableError {
  constructor(errorType, uri2) {
    __publicField2(this, "errorType");
    __publicField2(this, "uri");
    this.errorType = errorType;
    this.uri = uri2;
  }
}
const vscodeFileSystemListener = async (args2, fileTree, contentWindow) => {
  const {
    payload: { uri: uri2 },
    command,
    id
  } = args2;
  switch (command) {
    case "readFile": {
      const data = fileTree.readFileTree(uri2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "readDir": {
      const data = fileTree.readDirectoryTree(uri2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "writeFile": {
      const { content: content2, options: options2 } = args2.payload;
      const data = await fileTree.writeFileTree(uri2, content2, options2);
      if (!(data instanceof VSCodeFSTransferableError)) {
        dispatchFrontendFileWriteAction(uri2, data);
      }
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "rename": {
      const { oldUri, newUri, options: options2 } = args2.payload;
      const data = fileTree.rename(oldUri, newUri, options2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "stat": {
      const data = fileTree.stat(uri2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "delete": {
      const data = fileTree.delete(uri2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
    case "createDir": {
      const data = fileTree.createDirectory(uri2);
      contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
      break;
    }
  }
};
class File {
  constructor(uri2, data) {
    __publicField2(this, "type");
    __publicField2(this, "ctime");
    __publicField2(this, "mtime");
    __publicField2(this, "size");
    __publicField2(this, "uri");
    __publicField2(this, "name");
    __publicField2(this, "data");
    __publicField2(this, "id");
    this.type = 1;
    this.ctime = Date.now();
    this.mtime = Date.now();
    this.size = 0;
    this.data = data;
    this.uri = uri2;
    const pathParts = uri2.path.split("/").filter(Boolean);
    this.name = pathParts[pathParts.length - 1];
  }
}
class Directory {
  constructor(uri2) {
    __publicField2(this, "type");
    __publicField2(this, "ctime");
    __publicField2(this, "mtime");
    __publicField2(this, "size");
    __publicField2(this, "uri");
    __publicField2(this, "name");
    __publicField2(this, "entries");
    this.type = 2;
    this.ctime = Date.now();
    this.mtime = Date.now();
    this.size = 0;
    this.entries = /* @__PURE__ */ new Map();
    this.uri = uri2;
    const pathParts = uri2.path.split("/").filter(Boolean);
    this.name = pathParts[pathParts.length - 1];
  }
}
const fileSearchInFileTree = (root2, query2) => {
  const stack = [];
  const uris = [];
  stack.push(root2);
  while (stack.length > 0) {
    const dir = stack.pop();
    dir == null ? void 0 : dir.entries.forEach((e) => {
      if (e instanceof Directory) {
        stack.push(e);
      } else if (e instanceof File) {
        const match = e.name.match(new RegExp(query2, "i"));
        if (match) {
          uris.push(e.uri);
        }
      }
    });
  }
  return uris;
};
const vscodeFileSearchListener = (args2, fileTree, contentWindow) => {
  const { payload, command, id } = args2;
  if (command === "fileSearch") {
    const { query: query2 } = payload;
    const root2 = fileTree.getRoot();
    if (!root2) {
      throw new Error("Files not in Workbench");
    }
    const data = fileSearchInFileTree(root2, query2.pattern);
    contentWindow == null ? void 0 : contentWindow.postMessage({ id, command, payload: data }, "*");
  }
};
const listenToVsCodeEvent = (payload, fileTree, window2) => {
  vscodeFileSystemListener(payload, fileTree, window2);
  vscodeFileSearchListener(payload, fileTree, window2);
};
const LIST_VIEW = "ListView";
const addField = async (props) => {
  const { workbench: workbench2, page, entityName, columnToAdd, selectedColumn, insertType, source } = props;
  const generatedDirectory = await workbench2.readDirectory(workbench2.cwd + `/src/pages/${entityName}`);
  const newField = columnToAdd.split(".").slice(1).join(".");
  const entity = columnToAdd.split(".")[0];
  const fields8 = getFields(workbench2, entityName);
  const tmp2 = fields8.find((field2) => field2.name == newField);
  const field = {
    name: newField,
    type: tmp2 == null ? void 0 : tmp2.type
  };
  const columnInfo = {
    io: workbench2,
    ast: void 0,
    entity,
    field,
    fields: fields8,
    page,
    selectedColumn,
    insertType
  };
  if (page === PageType.LIST) {
    const found = generatedDirectory.filter((file) => file.fileName.includes(LIST_VIEW));
    if (source && source.fileName.includes(LIST_VIEW)) {
      const code22 = await workbench2.readFile(source.fileName);
      const encoded = encodeEmptyLines$1(code22);
      columnInfo.ast = encoded;
      const generatedCode = await generateColumn(columnInfo);
      return {
        path: source.fileName,
        generatedCode
      };
    } else if (found) {
      const tsxPath = found[0].filePath;
      const code22 = await workbench2.readFile(tsxPath);
      const encoded = encodeEmptyLines$1(code22);
      columnInfo.ast = encoded;
      const generatedCode = await generateColumn(columnInfo);
      return {
        path: tsxPath,
        generatedCode
      };
    }
  }
  const fileName = source.fileName;
  const code2 = await workbench2.readFile(fileName);
  const node = astFindSource(code2, source);
  const foundFields = findFields(node, fields8.map((field2) => field2.name));
  if ((foundFields == null ? void 0 : foundFields.length) !== 1)
    return;
  const clonedAndRenamedFieldsFile = await cloneAndRenameElement(code2, source, foundFields[0], newField);
  if (clonedAndRenamedFieldsFile)
    return {
      path: source.fileName,
      generatedCode: clonedAndRenamedFieldsFile
    };
};
const getFields = (workbench2, entityName) => {
  var _a2, _b;
  const fieldNames = [entityName];
  const fields8 = (_b = (_a2 = workbench2.introspection.types.find((type2) => type2.name === entityName)) == null ? void 0 : _a2.fields) == null ? void 0 : _b.map((field) => {
    return {
      name: field.name,
      type: getNestedOfType(field).name
    };
  });
  for (let index2 = 0; index2 < fields8.length; index2++) {
    const tmp2 = workbench2.introspection.types.find((type2) => type2.name === fields8[index2].type);
    if (fieldNames.includes(tmp2.name)) {
      fields8.splice(index2, 1);
      index2--;
      continue;
    }
    if (tmp2.kind !== "SCALAR")
      fieldNames.push(tmp2.name);
    if (tmp2.fields) {
      fields8.push(...tmp2.fields.map((field) => {
        return {
          name: `${fields8[index2].name}.${field.name}`,
          type: getNestedOfType(field).name
        };
      }));
      fields8.splice(index2, 1);
      index2--;
    }
  }
  return fields8;
};
const removeFieldFromTable = async (workbench2, source) => {
  if (source && source.fileName.includes(LIST_VIEW)) {
    const code2 = await workbench2.readFile(source.fileName);
    const encoded = encodeEmptyLines$1(code2);
    const alteredAst = removeColumnFromAst(encoded, source);
    if (!alteredAst)
      return console.error("Unable to remove Element from AST");
    const newCode = await printFormattedSourceFile$1(alteredAst);
    await workbench2.writeFile(source.fileName, newCode);
  }
};
const executeCommit = async (fetchUrl, accessToken, branchName, repositoryUrl, commitMessage, allChangedFiles) => {
  const repo = repositoryUrl.split("/");
  const headOid = await fetchHeadOid(fetchUrl, accessToken, branchName, repo[1], repo[0]);
  if (headOid) {
    if (headOid.errors) {
      return { success: false, errors: headOid.errors };
    }
    let changedFiles = [];
    let deletedFiles = [];
    Object.entries(allChangedFiles).forEach(([key, { data }]) => {
      if (data !== null)
        changedFiles.push({
          path: key[0] == "/" ? key.substring(1) : key,
          contents: Buffer.from(data).toString("base64")
        });
      else
        deletedFiles.push({ path: key.substring(1) });
    });
    const query2 = `mutation CommitAddition(
      $branchName: String = ""
      $repositoryNameWithOwner: String = ""
      $clientMutationId: String = ""
      $commitMessage: String = ""
      $additions: [GitHubFileAddition!] = []
      $deletions: [GitHubFileDeletion!] = []
      $headOid: GitHubGitObjectID = null
    ) {
      gitHub {
        createCommitOnBranch(
          input: {
            branch: {
              branchName: $branchName
              repositoryNameWithOwner: $repositoryNameWithOwner
            }
            fileChanges: { additions: $additions, deletions: $deletions }
            message: { headline: $commitMessage }
            expectedHeadOid: $headOid
          }
        ) {
          clientMutationId
        }
      }
    }`;
    const responseData = await httpFetch(fetchUrl, query2, {
      headOid,
      commitMessage: isEmptyOrSpaces(commitMessage) ? "Commit " + headOid : commitMessage,
      branchName,
      repositoryNameWithOwner: repositoryUrl,
      additions: changedFiles,
      deletions: deletedFiles
    }, accessToken);
    if (responseData.errors) {
      return { success: false, errors: responseData.errors };
    } else {
      return { success: true, errors: "" };
    }
  }
};
const fetchHeadOid = async (fetchUrl, accessToken, branchName, repositoryName, owner) => {
  const query2 = `query fetchHeadOid(
      $repositoryName: String = ""
      $owner: String = ""
      $branchName: String = ""
    ) {
      gitHub {
        repository(name: $repositoryName, owner: $owner) {
          ref(qualifiedName: $branchName) {
            target {
              oid
            }
            name
          }
        }
      }
    }`;
  const responseData = await httpFetch(fetchUrl, query2, { branchName, repositoryName, owner }, accessToken);
  if (responseData.errors)
    return responseData;
  const headOid = responseData.data.gitHub.repository.ref.target.oid;
  return headOid;
};
const httpFetch = async (fetchUrl, query2, variables, accessToken) => {
  let responseData;
  try {
    const payload = {
      query: query2,
      variables
    };
    const body2 = JSON.stringify(payload);
    const response = await fetchWithTimeout(fetchUrl, {
      method: "POST",
      credentials: "include",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": body2.length.toString(),
        Authorization: accessToken ? "Bearer " + accessToken : ""
      },
      body: body2
    });
    const data = await response.json();
    responseData = data;
  } catch (error2) {
    responseData = {
      errors: error2.name !== "AbortError" ? error2 : "Timeout: The server is taking longer than expected to respond."
    };
  }
  return responseData;
};
const fetchWithTimeout = async (input, init2, timeout = 3e4) => {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  const response = await fetch(input, __spreadProps2(__spreadValues2({}, init2), {
    signal: controller.signal
  }));
  clearTimeout(id);
  return response;
};
var dist$1 = {};
var auth = {};
var oauthError = {};
Object.defineProperty(oauthError, "__esModule", { value: true });
function OAuthError(errorObject, fileName, lineNumber) {
  var message = "OAuthError: " + errorObject.error + " " + errorObject.error_description;
  var oauthErrorInstance = new Error(message, fileName, lineNumber);
  oauthErrorInstance.oauthError = errorObject;
  Object.setPrototypeOf(oauthErrorInstance, Object.getPrototypeOf(this));
  if (Error.captureStackTrace) {
    Error.captureStackTrace(oauthErrorInstance, OAuthError);
  }
  return oauthErrorInstance;
}
OAuthError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: Error,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
if (Object.setPrototypeOf) {
  Object.setPrototypeOf(OAuthError, Error);
} else {
  OAuthError.__proto__ = Error;
}
oauthError.default = OAuthError;
var storage = {};
Object.defineProperty(storage, "__esModule", { value: true });
storage.hasLocalStorage = storage.LocalStorage = storage.InMemoryStorage = void 0;
var InMemoryStorage = function() {
  function InMemoryStorage2() {
    var _this = this;
    this.state = {};
    this.getItem = function(key) {
      return _this.state[key];
    };
    this.setItem = function(key, value2) {
      _this.state[key] = value2;
    };
    this.removeItem = function(key) {
      delete _this.state[key];
    };
  }
  return InMemoryStorage2;
}();
storage.InMemoryStorage = InMemoryStorage;
var NETLIFY_GRAPH_PREFIX = "netlifyGraph:";
var LocalStorage = function() {
  function LocalStorage2() {
  }
  LocalStorage2.prototype.getItem = function(key) {
    return localStorage.getItem(NETLIFY_GRAPH_PREFIX + key);
  };
  LocalStorage2.prototype.setItem = function(key, value2) {
    return localStorage.setItem(NETLIFY_GRAPH_PREFIX + key, value2);
  };
  LocalStorage2.prototype.removeItem = function(key) {
    return localStorage.removeItem(NETLIFY_GRAPH_PREFIX + key);
  };
  return LocalStorage2;
}();
storage.LocalStorage = LocalStorage;
var DEBUG_KEY = "__og_debug";
function hasLocalStorage() {
  try {
    localStorage.setItem(DEBUG_KEY, "debug");
    localStorage.removeItem(DEBUG_KEY);
    return true;
  } catch (e) {
    return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && localStorage.length !== 0;
  }
}
storage.hasLocalStorage = hasLocalStorage;
var uri$1 = {};
var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$2 = Object.assign || function(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
Object.defineProperty(uri$1, "__esModule", { value: true });
var URI_REGEX = new RegExp([
  "^(https?://[^:/?#]*(?::[0-9]+)?)",
  "(/{0,1}[^?#]*)",
  "(\\?[^#]*|)",
  "(#.*|)$"
].join(""));
function parseQuery(queryString) {
  return queryString.split(/[?&]/).reduce(function(query2, part) {
    var _a2 = part.split("="), param = _a2[0], value2 = _a2[1];
    if (param != null && value2 != null) {
      query2[param] = value2;
    }
    return query2;
  }, {});
}
function parse$5(uriString) {
  var match = uriString.match(URI_REGEX);
  if (!match) {
    throw new Error("invalid url " + uriString);
  }
  return {
    origin: match[1],
    path: match[2],
    query: parseQuery(match[3])
  };
}
function safeParse(uriString) {
  try {
    return parse$5(uriString);
  } catch (e) {
    return null;
  }
}
function addQueryParams(uri2, query2) {
  return __assign$2(__assign$2({}, uri2), { query: __assign$2(__assign$2({}, uri2.query), query2) });
}
function setPath(uri2, path2) {
  return __assign$2(__assign$2({}, uri2), { path: path2 });
}
function queryToString(query2) {
  return Object.keys(query2).map(function(k2) {
    return k2 + "=" + query2[k2];
  }).join("&");
}
function toString$2(uri2) {
  var origin = uri2.origin, path2 = uri2.path, query2 = uri2.query;
  var queryString = queryToString(query2);
  return origin + path2 + (queryString ? "?" + queryString : "");
}
function make(_a2) {
  var origin = _a2.origin, path2 = _a2.path, query2 = _a2.query;
  var uri2 = parse$5(origin);
  uri2 = setPath(uri2, path2);
  uri2 = addQueryParams(uri2, query2);
  return uri2;
}
uri$1.default = {
  parse: parse$5,
  safeParse,
  addQueryParams,
  setPath,
  toString: toString$2,
  make,
  queryToString
};
var pkce = {};
Object.defineProperty(pkce, "__esModule", { value: true });
function getCrypto() {
  return window.crypto || window.msCrypto;
}
function getSubtle() {
  var crypto = getCrypto();
  return crypto.subtle || crypto.webkitSubtle;
}
function generateVerifier() {
  var chars = "0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz-._~";
  var s = "";
  for (var _i = 0, _a2 = getCrypto().getRandomValues(new Uint8Array(64)); _i < _a2.length; _i++) {
    var value2 = _a2[_i];
    s = s + chars[value2 % chars.length];
  }
  return s;
}
function supportsSha256() {
  var subtle = getSubtle();
  return subtle && subtle.digest && typeof TextEncoder !== "undefined" && typeof btoa !== "undefined" && typeof subtle.digest({ name: "SHA-256" }, new Uint8Array(2)).process === "undefined";
}
function sha256(s) {
  return getSubtle().digest({ name: "SHA-256" }, new TextEncoder().encode(s));
}
function urlSafeBase64(s) {
  return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function codeChallengeOfVerifier(verifier) {
  if (!supportsSha256()) {
    return Promise.resolve({
      challenge: verifier,
      method: "plain"
    });
  } else {
    return sha256(verifier).then(function(s) {
      return {
        challenge: urlSafeBase64(btoa(String.fromCharCode.apply(String, Array.from(new Uint8Array(s))))),
        method: "S256"
      };
    });
  }
}
pkce.default = {
  generateVerifier,
  codeChallengeOfVerifier
};
var helpers = {};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.findMissingAuthServices = void 0;
function findMissingAuthServices(results2) {
  var errors = results2 && (results2.errors || results2.graphQLErrors || results2);
  if (!Array.isArray(errors)) {
    return [];
  }
  var missingServiceErrors = errors.filter(function(error2) {
    var _a2;
    return ((_a2 = error2 === null || error2 === void 0 ? void 0 : error2.extensions) === null || _a2 === void 0 ? void 0 : _a2.type) === "auth/missing-auth";
  });
  var missingServices = missingServiceErrors.map(function(error2) {
    return error2.extensions.service;
  }).filter(Boolean);
  return missingServices;
}
helpers.findMissingAuthServices = findMissingAuthServices;
var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$1 = Object.assign || function(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve5) {
      resolve5(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve5, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve5(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done)
          return t;
        if (y2 = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest = commonjsGlobal && commonjsGlobal.__rest || function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s); i2 < p2.length; i2++) {
      if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i2]))
        t[p2[i2]] = s[p2[i2]];
    }
  return t;
};
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(auth, "__esModule", { value: true });
auth.NetlifyGraphAuth = void 0;
var oauthError_1 = oauthError;
var storage_1 = storage;
var uri_1 = uri$1;
var pkce_1 = pkce;
var helpers_1 = helpers;
var POLL_INTERVAL = 35;
var ALL_SERVICES = [
  "adroll",
  "asana",
  "box",
  "contentful",
  "dev-to",
  "dribbble",
  "dropbox",
  "eggheadio",
  "eventil",
  "facebook",
  "firebase",
  "github",
  "gmail",
  "google",
  "google-ads",
  "google-analytics",
  "google-calendar",
  "google-compute",
  "google-docs",
  "google-search-console",
  "google-translate",
  "hubspot",
  "intercom",
  "mailchimp",
  "meetup",
  "netlify",
  "product-hunt",
  "quickbooks",
  "salesforce",
  "slack",
  "spotify",
  "stripe",
  "trello",
  "twilio",
  "twitch-tv",
  "twitter",
  "ynab",
  "youtube",
  "zeit",
  "zendesk"
];
function friendlyServiceName(service) {
  switch (service) {
    case "adroll":
      return "Adroll";
    case "asana":
      return "Asana";
    case "box":
      return "Box";
    case "dev-to":
      return "Dev.to";
    case "dribbble":
      return "Dribbble";
    case "dropbox":
      return "Dropbox";
    case "contentful":
      return "Contentful";
    case "eggheadio":
      return "Egghead.io";
    case "eventil":
      return "Eventil";
    case "facebook":
      return "Facebook";
    case "firebase":
      return "Firebase";
    case "github":
      return "GitHub";
    case "gmail":
      return "Gmail";
    case "google":
      return "Google";
    case "google-ads":
      return "Google Ads";
    case "google-analytics":
      return "Google Analytics";
    case "google-calendar":
      return "Google Calendar";
    case "google-compute":
      return "Google Compute";
    case "google-docs":
      return "Google Docs";
    case "google-search-console":
      return "Google Search Console";
    case "google-translate":
      return "Google Translate";
    case "hubspot":
      return "Hubspot";
    case "intercom":
      return "Intercom";
    case "mailchimp":
      return "Mailchimp";
    case "meetup":
      return "Meetup";
    case "netlify":
      return "Netlify";
    case "product-hunt":
      return "Product Hunt";
    case "quickbooks":
      return "QuickBooks";
    case "salesforce":
      return "Salesforce";
    case "slack":
      return "Slack";
    case "spotify":
      return "Spotify";
    case "stripe":
      return "Stripe";
    case "trello":
      return "Trello";
    case "twilio":
      return "Twilio";
    case "twitter":
      return "Twitter";
    case "twitch-tv":
      return "Twitch";
    case "ynab":
      return "You Need a Budget";
    case "youtube":
      return "YouTube";
    case "zeit":
      return "Vercel";
    case "zendesk":
      return "Zendesk";
    default:
      return service;
  }
}
function getWindowOpts() {
  var windowWidth = Math.min(800, Math.floor(window.outerWidth * 0.8));
  var windowHeight = Math.min(630, Math.floor(window.outerHeight * 0.5));
  var windowArea = {
    width: windowWidth,
    height: windowHeight,
    left: Math.round(window.screenX + (window.outerWidth - windowWidth) / 2),
    top: Math.round(window.screenY + (window.outerHeight - windowHeight) / 8)
  };
  return {
    width: windowArea.width,
    height: windowArea.height,
    left: windowArea.left,
    top: windowArea.top,
    toolbar: 0,
    scrollbars: 1,
    status: 1,
    resizable: 1,
    menuBar: 0
  };
}
function createAuthWindow(_a2) {
  var url = _a2.url, service = _a2.service;
  var windowOpts = getWindowOpts();
  var w = window.open(url || "", (service + "_" + Math.random()).replace(".", ""), Object.keys(windowOpts).map(function(k2) {
    return k2 + "=" + windowOpts[k2];
  }).join(","));
  if (!url && w && w.document) {
    try {
      w.document.title = "Log in with " + friendlyServiceName(service);
      w.document.body.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100vh;width:100vw%"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" width="48px" height="48px" style="background: none;"><circle cx="50" cy="50" fill="none" stroke="#3cc7b6" stroke-width="8" r="24" stroke-dasharray="112 40" transform="rotate(138.553 50 50)"><animateTransform attributeName="transform" type="rotate" calcMode="linear" values="0 50 50;360 50 50" keyTimes="0;1" dur="1s" begin="0s" repeatCount="indefinite"></animateTransform></circle></svg></div>';
    } catch (e) {
    }
  }
  return w;
}
function normalizeRedirectOrigin(origin) {
  return uri_1.default.parse(origin).origin;
}
function normalizeRedirectPath(path2) {
  return path2 === "/" ? "" : path2;
}
var loggedInQuery = "\nquery LoggedInQuery {\n  me {\n    serviceMetadata {\n      loggedInServices {\n        service\n        foreignUserId\n        usedTestFlow\n      }\n    }\n  }\n}\n";
var allServicesQuery = "\nquery AllServicesQuery {\n  oneGraph {\n    services(filter: {supportsOauthLogin: true}) {\n      service\n      friendlyServiceName\n      supportsTestFlow\n    }\n  }\n}\n";
function getServiceEnum(service) {
  return service.toUpperCase().replace(/-/g, "_");
}
function fromServiceEnum(serviceEnum) {
  return serviceEnum.toLowerCase().replace(/_/g, "-");
}
function getIsLoggedIn(queryResult, service, foreignUserId) {
  var _a2, _b, _c;
  var serviceEnum = getServiceEnum(service);
  var loggedInServices = ((_c = (_b = (_a2 = queryResult === null || queryResult === void 0 ? void 0 : queryResult.data) === null || _a2 === void 0 ? void 0 : _a2.me) === null || _b === void 0 ? void 0 : _b.serviceMetadata) === null || _c === void 0 ? void 0 : _c.loggedInServices) || [];
  return !!loggedInServices.find(function(serviceInfo) {
    return serviceInfo.service === serviceEnum && (!foreignUserId || foreignUserId === serviceInfo.foreignUserId);
  });
}
function getServiceErrors(errors, service) {
  return errors.filter(function(error2) {
    return error2.path && error2.path.includes(service);
  });
}
var logoutMutation = "mutation SignOutServicesMutation(\n  $services: [OneGraphServiceEnum!]!\n) {\n  signoutServices(data: { services: $services }) {\n    me {\n      serviceMetadata {\n        loggedInServices {\n          service\n          foreignUserId\n        }\n      }\n    }\n  }\n}";
var logoutUserMutation = "mutation SignOutServicesMutation(\n  $service: OneGraphServiceEnum!\n  $foreignUserId: String!\n) {\n  signoutServiceUser(\n    input: {\n      service: $service\n      foreignUserId: $foreignUserId\n    }\n  ) {\n    me {\n      serviceMetadata {\n        loggedInServices {\n          service\n          foreignUserId\n        }\n      }\n    }\n  }\n}";
function fetchQuery(fetchUrl, query2, variables, token) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, response;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
          };
          if (token) {
            headers.Authorization = "Bearer " + token.accessToken;
          }
          return [4, fetch(fetchUrl, {
            method: "POST",
            headers,
            body: JSON.stringify({ query: query2, variables })
          })];
        case 1:
          response = _a2.sent();
          return [4, response.json()];
        case 2:
          return [2, _a2.sent()];
      }
    });
  });
}
function exchangeCode(graphOrigin, siteId, redirectOrigin, redirectPath, code2, token, verifier) {
  return __awaiter(this, void 0, void 0, function() {
    var redirectUri, url, headers, response;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          redirectUri = redirectOrigin + redirectPath;
          url = uri_1.default.make({
            origin: graphOrigin,
            path: "/oauth/code",
            query: {
              app_id: siteId,
              redirect_uri: redirectUri,
              code: code2,
              code_verifier: verifier
            }
          });
          headers = {
            "Content-Type": "application/json",
            Accept: "application/json"
          };
          if (token) {
            headers.Authorization = "Bearer " + token.accessToken;
          }
          return [4, fetch(uri_1.default.toString(url), {
            method: "POST",
            headers
          })];
        case 1:
          response = _a2.sent();
          return [4, response.json()];
        case 2:
          return [2, _a2.sent()];
      }
    });
  });
}
function exchangeRefreshToken(graphOrigin, siteId, refreshToken) {
  return __awaiter(this, void 0, void 0, function() {
    var url, headers, response;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          url = uri_1.default.make({
            origin: graphOrigin,
            path: "/oauth/token",
            query: {
              app_id: siteId
            }
          });
          headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            accept: "application/json"
          };
          return [4, fetch(uri_1.default.toString(url), {
            method: "POST",
            headers,
            body: uri_1.default.queryToString({
              grant_type: "refresh_token",
              refresh_token: refreshToken
            })
          })];
        case 1:
          response = _a2.sent();
          return [4, response.json()];
        case 2:
          return [2, _a2.sent()];
      }
    });
  });
}
function byteArrayToString(byteArray) {
  return byteArray.reduce(function(acc, byte) {
    return acc + (byte & 255).toString(16).slice(-2);
  }, "");
}
function makeStateParam() {
  return byteArrayToString(window.crypto.getRandomValues(new Uint8Array(32)));
}
function isExpired(token) {
  return token.expireDate < Date.now();
}
function tokenFromStorage(storage2, siteId) {
  var v = storage2.getItem(siteId);
  if (v) {
    var possibleToken = JSON.parse(v);
    if (typeof possibleToken.accessToken === "string" && typeof possibleToken.expireDate === "number" && !isExpired(possibleToken)) {
      return possibleToken;
    }
  }
  return null;
}
var DEFAULT_GRAPH_ORIGIN = "https://serve.onegraph.com";
var NetlifyGraphAuth = function() {
  function NetlifyGraphAuth2(opts) {
    var _this = this;
    this._authWindows = {};
    this._intervalIds = {};
    this._messageListeners = {};
    this._accessToken = null;
    this.supportedServices = ALL_SERVICES;
    this._clearInterval = function(service) {
      var intervalId = _this._intervalIds[service];
      clearInterval(intervalId);
      delete _this._intervalIds[service];
    };
    this._clearMessageListener = function(service) {
      window.removeEventListener("message", _this._messageListeners[service], false);
      delete _this._messageListeners[service];
    };
    this.closeAuthWindow = function(service) {
      var w = _this._authWindows[service];
      w && w.close();
      delete _this._authWindows[service];
    };
    this.cleanup = function(service, keepWindowOpen) {
      _this._clearInterval(service);
      _this._clearMessageListener(service);
      if (!keepWindowOpen) {
        _this.closeAuthWindow(service);
      }
    };
    this.accessToken = function() {
      return _this._accessToken;
    };
    this.tokenExpireDate = function() {
      if (!_this._accessToken) {
        return null;
      }
      return new Date(_this._accessToken.expireDate);
    };
    this.tokenExpiresSecondsFromNow = function() {
      var expireDate = _this.tokenExpireDate();
      if (!expireDate) {
        return null;
      }
      var milliseconds = expireDate.getTime() - new Date().getTime();
      if (milliseconds < 0) {
        return null;
      }
      return Math.floor(milliseconds / 1e3);
    };
    this.refreshToken = function(refreshToken) {
      return __awaiter(_this, void 0, void 0, function() {
        var baseResponse, errorResponse, successResponse, token;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, exchangeRefreshToken(this.graphOrigin, this.siteId, refreshToken)];
            case 1:
              baseResponse = _a2.sent();
              if (!baseResponse) {
                throw new oauthError_1.default({
                  error: "invalid_grant",
                  error_description: "Invalid response refreshing token."
                });
              }
              errorResponse = baseResponse;
              if (errorResponse.error) {
                throw new oauthError_1.default({
                  error: errorResponse.error,
                  error_description: errorResponse.error_description
                });
              }
              successResponse = baseResponse;
              if (!successResponse.access_token || !successResponse.expires_in || !successResponse.refresh_token) {
                throw new oauthError_1.default({
                  error: "invalid_grant",
                  error_description: "Inavlid response from server while refreshing token."
                });
              } else {
                token = {
                  accessToken: successResponse.access_token,
                  expireDate: Date.now() + successResponse.expires_in * 1e3,
                  refreshToken: successResponse.refresh_token
                };
                this.setToken(token);
                return [2, token];
              }
          }
        });
      });
    };
    this.authHeaders = function() {
      if (_this._accessToken) {
        return { Authorization: "Bearer " + _this._accessToken.accessToken };
      } else {
        return {};
      }
    };
    this._makeAuthUrl = function(opts2) {
      return __awaiter(_this, void 0, void 0, function() {
        var service, verifier, stateParam, scopes, useTestFlow, challenge, query2, authUrl;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              service = opts2.service, verifier = opts2.verifier, stateParam = opts2.stateParam, scopes = opts2.scopes, useTestFlow = opts2.useTestFlow;
              return [4, pkce_1.default.codeChallengeOfVerifier(verifier)];
            case 1:
              challenge = _a2.sent();
              query2 = __assign$1({ service, app_id: this.siteId, response_type: "code", redirect_origin: this._redirectOrigin, redirect_path: this._redirectPath, communication_mode: this._communicationMode, code_challenge: challenge.challenge, code_challenge_method: challenge.method, state: stateParam }, scopes ? { scopes: scopes.join(",") } : {});
              if (useTestFlow) {
                query2.test = "true";
              }
              authUrl = uri_1.default.make({
                origin: this.graphOrigin,
                path: "/oauth/start",
                query: query2
              });
              return [2, uri_1.default.toString(authUrl)];
          }
        });
      });
    };
    this.setToken = function(token) {
      _this._accessToken = token;
      token.refreshToken;
      var storableToken = __rest(token, ["refreshToken"]);
      _this._storage.setItem(_this._storageKey, JSON.stringify(storableToken));
    };
    this._waitForAuthFinishPostMessage = function(service, stateParam, verifier) {
      return new Promise(function(resolve5, reject) {
        function parseEvent(event2) {
          try {
            return JSON.parse(event2.data);
          } catch (e) {
            return {};
          }
        }
        var listener = function(event2) {
          var message = parseEvent(event2);
          if (message && message.version <= 2) {
            var state2 = message.state;
            if (state2 !== stateParam) {
              console.warn("Invalid state param, skipping event");
            } else {
              var error2 = message.error, error_description = message.error_description, code2 = message.code;
              if (!code2) {
                reject(new oauthError_1.default({
                  error: error2 || "invalid_grant",
                  error_description: error_description || "Missing code"
                }));
              } else {
                exchangeCode(_this.graphOrigin, _this.siteId, _this._redirectOrigin, _this._redirectPath, code2, _this._accessToken, verifier).then(function(baseResponse) {
                  var errorResponse = baseResponse;
                  var successResponse = baseResponse;
                  if (errorResponse.error) {
                    reject(new oauthError_1.default(errorResponse));
                  } else if (typeof successResponse.access_token === "string" && typeof successResponse.expires_in === "number") {
                    var token = {
                      accessToken: successResponse.access_token,
                      expireDate: Date.now() + successResponse.expires_in * 1e3,
                      refreshToken: successResponse.refresh_token
                    };
                    _this.setToken(token);
                    resolve5({
                      token,
                      service: successResponse.service,
                      foreignUserId: successResponse.foreign_user_id
                    });
                  } else {
                    reject(new Error("Unexpected result from server"));
                  }
                }).catch(function(e) {
                  return reject(e);
                });
              }
            }
          }
        };
        _this._messageListeners[service] = listener;
        window.addEventListener("message", listener, false);
      });
    };
    this._waitForAuthFinishRedirect = function(service, stateParam, verifier) {
      return new Promise(function(resolve5, reject) {
        _this._intervalIds[service] = setInterval(function() {
          try {
            var authWindow = _this._authWindows[service];
            var authUri = authWindow && uri_1.default.safeParse(authWindow.location.toString());
            if (authUri && authUri.origin === _this._redirectOrigin) {
              var params = authUri.query;
              if (stateParam !== params.state) {
                reject(new oauthError_1.default({
                  error: "invalid_request",
                  error_description: "The state param does not match"
                }));
              } else {
                var code2 = params.code;
                if (!code2) {
                  reject(new oauthError_1.default({
                    error: "invalid_grant",
                    error_description: "Missing code"
                  }));
                } else {
                  exchangeCode(_this.graphOrigin, _this.siteId, _this._redirectOrigin, _this._redirectPath, code2, _this._accessToken, verifier).then(function(baseResponse) {
                    var errorResponse = baseResponse;
                    var successResponse = baseResponse;
                    if (errorResponse.error) {
                      reject(new oauthError_1.default(errorResponse));
                    } else if (typeof successResponse.access_token === "string" && typeof successResponse.expires_in === "number") {
                      var token = {
                        accessToken: successResponse.access_token,
                        expireDate: Date.now() + successResponse.expires_in * 1e3,
                        refreshToken: successResponse.refresh_token
                      };
                      _this.setToken(token);
                      resolve5({ token });
                    } else {
                      reject(new Error("Unexpected result from server"));
                    }
                  }).catch(function(e) {
                    return reject(e);
                  });
                }
              }
            }
          } catch (e) {
            if (e instanceof window.DOMException)
              ;
            else {
              console.error("unexpected error waiting for auth to finish for " + service, e);
              reject(e);
            }
          }
        }, POLL_INTERVAL);
      });
    };
    this.login = function(service, scopes, useTestFlow) {
      return __awaiter(_this, void 0, void 0, function() {
        var stateParam, verifier, authWindow, authFinish, windowUrl, url, result_3, e_1_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!service) {
                throw new oauthError_1.default({
                  error: "invalid_request",
                  error_description: "Missing required argument. Provide service as first argument to login (e.g. `auth.login('stripe')`)."
                });
              }
              this.cleanup(service);
              stateParam = makeStateParam();
              verifier = pkce_1.default.generateVerifier();
              authWindow = createAuthWindow({ service });
              this._authWindows[service] = authWindow;
              authFinish = this._communicationMode === "redirect" ? this._waitForAuthFinishRedirect : this._waitForAuthFinishPostMessage;
              windowUrl = this._makeAuthUrl({
                service,
                verifier,
                stateParam,
                scopes,
                useTestFlow
              });
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 4, , 5]);
              return [4, windowUrl];
            case 2:
              url = _a2.sent();
              try {
                authWindow.location.href = url;
              } catch (e) {
                throw new oauthError_1.default({
                  error: "invalid_response",
                  error_description: "Popup window was closed or blocked"
                });
              }
              return [4, authFinish(service, stateParam, verifier)];
            case 3:
              result_3 = _a2.sent();
              this.cleanup(service);
              return [2, result_3];
            case 4:
              e_1_1 = _a2.sent();
              this.cleanup(service, true);
              throw e_1_1;
            case 5:
              return [2];
          }
        });
      });
    };
    this.isLoggedIn = function(args2) {
      return __awaiter(_this, void 0, void 0, function() {
        var accessToken, service, foreignUserId, result2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              accessToken = this._accessToken;
              if (!accessToken)
                return [3, 2];
              service = typeof args2 === "string" ? args2 : args2.service;
              if (!service) {
                throw new Error("Missing required argument. Provide service as first argument to isLoggedIn (e.g. `auth.isLoggedIn('stripe')`).");
              }
              foreignUserId = typeof args2 === "string" ? null : args2.foreignUserId;
              return [4, fetchQuery(this._fetchUrl, loggedInQuery, {}, accessToken)];
            case 1:
              result2 = _a2.sent();
              return [2, getIsLoggedIn(result2, service, foreignUserId)];
            case 2:
              return [2, Promise.resolve(false)];
          }
        });
      });
    };
    this.servicesStatus = function() {
      return __awaiter(_this, void 0, void 0, function() {
        var accessToken, result_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              accessToken = this._accessToken;
              if (!accessToken)
                return [3, 2];
              return [4, fetchQuery(this._fetchUrl, loggedInQuery, {}, accessToken)];
            case 1:
              result_1 = _a2.sent();
              return [2, ALL_SERVICES.reduce(function(acc, service) {
                acc[service] = { isLoggedIn: getIsLoggedIn(result_1, service) };
                return acc;
              }, {})];
            case 2:
              return [2, Promise.resolve(ALL_SERVICES.reduce(function(acc, service) {
                acc[service] = { isLoggedIn: false };
                return acc;
              }, {}))];
          }
        });
      });
    };
    this.allServices = function() {
      return __awaiter(_this, void 0, void 0, function() {
        var result2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, fetchQuery(this._fetchUrl, allServicesQuery, {}, null)];
            case 1:
              result2 = _a2.sent();
              return [2, result2.data.oneGraph.services.map(function(serviceInfo) {
                return {
                  serviceEnum: serviceInfo.service,
                  service: fromServiceEnum(serviceInfo.service),
                  friendlyServiceName: serviceInfo.friendlyServiceName,
                  supportsTestFlow: serviceInfo.supportsTestFlow
                };
              })];
          }
        });
      });
    };
    this.loggedInServices = function() {
      return __awaiter(_this, void 0, void 0, function() {
        var accessToken, result2, loggedInServices;
        var _a2, _b, _c;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              accessToken = this._accessToken;
              if (!accessToken)
                return [3, 2];
              return [4, fetchQuery(this._fetchUrl, loggedInQuery, {}, accessToken)];
            case 1:
              result2 = _d.sent();
              loggedInServices = ((_c = (_b = (_a2 = result2 === null || result2 === void 0 ? void 0 : result2.data) === null || _a2 === void 0 ? void 0 : _a2.me) === null || _b === void 0 ? void 0 : _b.serviceMetadata) === null || _c === void 0 ? void 0 : _c.loggedInServices) || [];
              return [2, loggedInServices.reduce(function(acc, serviceInfo) {
                var serviceKey = fromServiceEnum(serviceInfo.service);
                var loggedInInfo = acc[serviceKey] || {
                  serviceEnum: serviceInfo.service,
                  foreignUserIds: []
                };
                acc[serviceKey] = __assign$1(__assign$1({}, loggedInInfo), { usedTestFlow: serviceInfo.usedTestFlow, foreignUserIds: __spreadArray([
                  serviceInfo.foreignUserId
                ], loggedInInfo.foreignUserIds, true) });
                return acc;
              }, {})];
            case 2:
              return [2, Promise.resolve({})];
          }
        });
      });
    };
    this.logout = function(service, foreignUserId) {
      return __awaiter(_this, void 0, void 0, function() {
        var accessToken, serviceEnum, signoutPromise, result2, loggedIn;
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!service) {
                throw new Error("Missing required argument. Provide service as first argument to logout (e.g. `auth.logout('stripe')`).");
              }
              this.cleanup(service);
              accessToken = this._accessToken;
              if (!accessToken)
                return [3, 2];
              serviceEnum = getServiceEnum(service);
              signoutPromise = foreignUserId ? fetchQuery(this._fetchUrl, logoutUserMutation, {
                service: serviceEnum,
                foreignUserId
              }, accessToken) : fetchQuery(this._fetchUrl, logoutMutation, {
                services: [serviceEnum]
              }, accessToken);
              return [4, signoutPromise];
            case 1:
              result2 = _b.sent();
              if (((_a2 = result2.errors) === null || _a2 === void 0 ? void 0 : _a2.length) && getServiceErrors(result2.errors, serviceEnum).length) {
                return [2, { result: "failure", errors: result2.errors }];
              } else {
                loggedIn = getIsLoggedIn({ data: result2.signoutServices }, service, foreignUserId);
                return [2, { result: loggedIn ? "failure" : "success" }];
              }
            case 2:
              return [2, Promise.resolve({ result: "failure" })];
            case 3:
              return [2];
          }
        });
      });
    };
    this.destroy = function() {
      Object.keys(_this._intervalIds).forEach(function(key) {
        return _this.cleanup(key);
      });
      Object.keys(_this._authWindows).forEach(function(key) {
        return _this.cleanup(key);
      });
      _this._storage.removeItem(_this._storageKey);
      _this._accessToken = null;
    };
    this.findMissingAuthServices = helpers_1.findMissingAuthServices;
    var siteId = opts.siteId, oauthFinishOrigin = opts.oauthFinishOrigin, oauthFinishPath = opts.oauthFinishPath;
    this.graphOrigin = opts.graphOrigin || DEFAULT_GRAPH_ORIGIN;
    this.siteId = siteId;
    var windowUri = uri_1.default.parse(window.location.toString());
    this._redirectOrigin = normalizeRedirectOrigin(oauthFinishOrigin || windowUri.origin);
    if (this._redirectOrigin !== windowUri.origin) {
      console.warn("oauthFinishOrigin does not match window.location.origin");
    }
    this._redirectPath = normalizeRedirectPath(oauthFinishPath || windowUri.path);
    var fetchUrl = uri_1.default.make({
      origin: opts.graphOrigin || DEFAULT_GRAPH_ORIGIN,
      path: "/graphql",
      query: { app_id: siteId }
    });
    this._fetchUrl = opts.graphqlUrl || uri_1.default.toString(fetchUrl);
    this._storage = opts.storage || ((0, storage_1.hasLocalStorage)() ? new storage_1.LocalStorage() : new storage_1.InMemoryStorage());
    this._storageKey = this.siteId;
    this._accessToken = tokenFromStorage(this._storage, this._storageKey);
    this._communicationMode = opts.communicationMode || "post_message";
  }
  NetlifyGraphAuth2.prototype.friendlyServiceName = function(service) {
    return friendlyServiceName(service);
  };
  return NetlifyGraphAuth2;
}();
auth.NetlifyGraphAuth = NetlifyGraphAuth;
auth.default = NetlifyGraphAuth;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.findMissingAuthServices = exports2.LocalStorage = exports2.InMemoryStorage = exports2.OAuthError = exports2.Auth = exports2.default = void 0;
  exports2.default = auth;
  exports2.Auth = auth;
  exports2.OAuthError = oauthError;
  var storage_12 = storage;
  Object.defineProperty(exports2, "InMemoryStorage", { enumerable: true, get: function() {
    return storage_12.InMemoryStorage;
  } });
  Object.defineProperty(exports2, "LocalStorage", { enumerable: true, get: function() {
    return storage_12.LocalStorage;
  } });
  var helpers_12 = helpers;
  Object.defineProperty(exports2, "findMissingAuthServices", { enumerable: true, get: function() {
    return helpers_12.findMissingAuthServices;
  } });
})(dist$1);
class OneGraphAuth {
  constructor(siteId) {
    __publicField2(this, "auth");
    __publicField2(this, "isLoggedIn", async () => {
      return await this.auth.isLoggedIn("github");
    });
    __publicField2(this, "checkCORS", async () => {
      try {
        const payload = { query: "{me{github{login}}}" };
        const json2 = JSON.stringify(payload);
        const corsCheck = await fetch(this.auth._fetchUrl, {
          method: "POST",
          redirect: "error",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": json2.length.toString(),
            Accept: "application/json"
          },
          body: json2
        });
      } catch (error2) {
        console.error("Check if you have [ENABLED Netlify Graph on https://app.netlify.com/user/labs] & added [" + window.location.protocol + "//" + window.location.hostname + (window.location.port === "" ? "" : ":" + window.location.port) + " to your CORS origins on https://app.netlify.com/site-redirect/" + this.auth.siteId + "/graph/settings] then refresh your application.");
        return true;
      }
      return false;
    });
    __publicField2(this, "login", async () => {
      const authRes = await this.auth.login("github");
      if (authRes) {
        showUserFeedback({
          type: "LOGIN_SUCCESS",
          payload: { login: true, provider: "Github" }
        });
      } else {
        showUserFeedback({
          type: "LOGIN_ERROR",
          payload: { login: true, provider: "Github" }
        });
        console.error("Did not grant auth for GitHub");
      }
      return authRes;
    });
    __publicField2(this, "logout", () => {
      const result2 = this.auth.logout("github");
      if (result2) {
        showUserFeedback({
          type: "LOGIN_SUCCESS",
          payload: { login: false, provider: "Github" }
        });
      } else {
        showUserFeedback({
          type: "LOGIN_ERROR",
          payload: { login: false, provider: "Github" }
        });
      }
      this.destroy();
      return result2;
    });
    __publicField2(this, "destroy", () => {
      this.auth.destroy();
    });
    __publicField2(this, "fetchUrl", () => {
      return this.auth._fetchUrl;
    });
    __publicField2(this, "accessToken", () => {
      return this.auth._accessToken.accessToken;
    });
    this.auth = new dist$1.Auth.NetlifyGraphAuth({
      siteId,
      communicationMode: "post_message"
    });
  }
}
const ElementEditable = (() => {
  const editable = new Editable();
  let editingElement = void 0;
  let buttonElement = void 0;
  let prevContent = void 0;
  const findClosestBtn = (el2) => {
    const MAX_DEPTH = 5;
    let depth2 = 0;
    while (el2.parentNode && depth2 < MAX_DEPTH) {
      el2 = el2.parentNode;
      if (el2.onclick || el2.tagName === "A" || el2.tagName === "BUTTON") {
        return el2;
      }
      depth2++;
    }
    return null;
  };
  const save3 = () => {
    if (editingElement) {
      if (buttonElement) {
        buttonElement.setAttribute("style", "pointer-events: auto");
        buttonElement.removeAttribute("contenteditable", "true");
        editingElement.removeAttribute("data-editable");
      }
      editable.remove(editingElement);
      editingElement.blur();
      editingElement.removeAttribute("style", "display: block; outline: 0");
      const inspectedElement = getDataFromElement(editingElement);
      forceSaveLocaleElement(editingElement, inspectedElement, void 0, workbench);
      editingElement = void 0;
      buttonElement = void 0;
      prevContent = void 0;
    }
  };
  return {
    editingElement: (el2) => {
      if (!el2)
        return;
      editingElement = el2;
      buttonElement = findClosestBtn(editingElement);
      editingElement.focus();
      editable.add(editingElement);
      if (buttonElement) {
        if (buttonElement.tagName === "A") {
          buttonElement.setAttribute("contenteditable", "true");
        } else {
          buttonElement.setAttribute("style", "pointer-events: none");
        }
        setEndOfContenteditable(editingElement, editingElement, editingElement.innerHTML.length / 2);
      } else {
        setEndOfContenteditable(editingElement, editingElement);
        editingElement.setAttribute("style", "display: block; outline: 0");
      }
      editable.add(editingElement);
      if (prevContent === void 0) {
        prevContent = el2.innerHTML;
      }
      const inspectedElement = getDataFromElement(editingElement);
      if (inspectedElement) {
        if (inspectedElement.displayName === "Anonymous" || inspectedElement.displayName.indexOf("FormattedMessage") !== -1 || inspectedElement.displayName === "Translate") {
          inspectedElement.displayName = "FormattedMessage";
        }
      }
    },
    saveChanges: save3,
    cancelChanges: () => {
      if (prevContent !== void 0) {
        editingElement.innerHTML = prevContent;
      }
      save3();
    }
  };
})();
const addElementHighlight = async (window2, injectMode, features) => {
  const el2 = document.createElement("iteria-wysiwyg");
  if (features)
    el2.features = features;
  el2.addEventListener("iframeLoaded", () => {
    const vscodeIframe = document.getElementById(VSCODE_IFRAME_ID);
    const { contentWindow } = vscodeIframe;
    if (!contentWindow) {
      throw new Error("Unable to destructure window from Iframe");
    }
    window2.addEventListener("message", async ({ data }) => {
      if (!data.command) {
        return;
      }
      listenToVsCodeEvent(data, workbench, contentWindow);
    });
    el2.win = contentWindow;
  });
  const hoverInspector = new HoverInspector(workbench);
  const hoverCallback = async (e) => {
    const {
      detail: { inspect: inspect2, hoverElement }
    } = e;
    const tooltipText = await hoverInspector.getComponentName(hoverElement);
    const display2 = shouldDisplayElementHighlight(hoverElement);
    el2.__typename = hoverElement.__typename;
    el2.isInsideTable = isInsideTable(hoverElement) || hoverElement.nodeName === "INPUT" || isFormInput(hoverElement);
    const formattedMessageElement = getFormattedMessageElement(hoverElement);
    inspect2({
      display: display2,
      tooltipText: tooltipText === "Translate" ? "FormattedMessage" : tooltipText,
      disabled: false,
      icon: "settings",
      icons: [],
      extraPayload: {
        formattedMessageElement
      }
    });
  };
  const debouncedHoverCallback = lodash_debounce(hoverCallback, 50);
  el2.addEventListener("hover", debouncedHoverCallback);
  el2.addEventListener("delete", (e) => {
    var _a2;
    const editingElement = (_a2 = e == null ? void 0 : e.detail) == null ? void 0 : _a2.editingElement;
    if (isDataGridCell(editingElement)) {
      handleRemoveTableColumn(window2, editingElement, REMOVE_ELEMENT);
    } else if (isFormInput(editingElement)) {
      handleRemoveFormColumn(window2, editingElement, REMOVE_ELEMENT);
    } else {
      handleIconClick(window2, editingElement, REMOVE_ELEMENT);
    }
  });
  el2.addEventListener("clone", async (e) => {
    const type2 = e.detail.type;
    const element2 = e.detail.payload.element;
    if (type2 === "CLONE_ELEMENT") {
      handleIconClick(window2, element2, CLONE_ELEMENT);
    } else if (type2 === "CLONE_COLUMN") {
      const selectedFields2 = e.detail.payload.fields instanceof Array ? e.detail.payload.fields : [e.detail.payload.fields];
      const insertType = getInsertType(e.detail.payload.insertType);
      const page = getPageTypeFromUrl();
      const source = page === PageType.LIST ? getSourceFromElement(getColumnTitle(element2)) : getSourceFromElement(element2);
      const entityName = getEntityNameFromUrl();
      const code2 = (source == null ? void 0 : source.fileName) ? await workbench.readFile(source.fileName) : void 0;
      const selectedColumn = code2 ? findColumn(code2, source) : void 0;
      for (let selectedField of selectedFields2) {
        const columnInfo = {
          workbench,
          source,
          page,
          entityName,
          columnToAdd: selectedField,
          selectedColumn,
          insertType
        };
        const generatedFile = await addField(columnInfo);
        await workbench.writeFile(generatedFile.path, generatedFile.generatedCode);
      }
      cloneColumn(selectedFields2, insertType, element2);
    } else if (type2 === "CLONE_AND_RENAME_ELEMENT") {
      const source = getSourceFromElement(element2);
      const insertType = getInsertType(e.detail.payload.insertType);
      if (!source)
        return console.error("Source not found", el2);
      const selectedFields2 = e.detail.payload.fields;
      const __typename = e.detail.payload.__typename;
      const payloadArr = Array.isArray(selectedFields2) ? selectedFields2 : [selectedFields2];
      payloadArr.forEach((field) => cloneColumn(field, insertType, void 0, __typename));
      const page = getPageTypeFromUrl();
      const code2 = await workbench.readFile(source.fileName);
      const selectedColumn = findColumn(code2, source);
      const columnInfo = {
        workbench,
        source,
        page,
        entityName: __typename,
        columnToAdd: selectedFields2,
        selectedColumn,
        insertType
      };
      const generatedFile = await addField(columnInfo);
      await workbench.writeFile(generatedFile.path, generatedFile.generatedCode);
    }
  });
  el2.addEventListener("showsource", (e) => {
    var _a2;
    const editingElement = (_a2 = e == null ? void 0 : e.detail) == null ? void 0 : _a2.editingElement;
    handleIconClick(window2, editingElement, NAVIGATE_TO_SOURCE_CODE);
  });
  el2.addEventListener("translate", (e) => {
    var _a2;
    const editingElement = (_a2 = e == null ? void 0 : e.detail) == null ? void 0 : _a2.editingElement;
    handleIconClick(window2, editingElement, TRANSLATE_ELEMENT);
    ElementEditable.editingElement(editingElement);
  });
  el2.addEventListener("confirmaction", (e) => {
    if (e.detail.actionType === "translate") {
      ElementEditable.saveChanges();
    } else if (e.detail.actionType === "drag_and_drop_grid" || e.detail.actionType === "drag_and_drop_relations") {
      handleReorderElements(window2, e.detail.payload, REORDER_ELEMENT);
    }
  });
  el2.addEventListener("cancelaction", (e) => {
    if (e.detail.actionType === "translate") {
      ElementEditable.cancelChanges();
    }
  });
  el2.addEventListener("editing", async (e) => {
    var _a2, _b, _c;
    const __typename = el2 == null ? void 0 : el2.__typename;
    if (!__typename)
      return;
    const editingElement = (_a2 = e == null ? void 0 : e.detail) == null ? void 0 : _a2.editingElement;
    const source = getSourceFromElement(editingElement);
    const fields8 = (_c = (_b = workbench.introspection.types.find((type2) => type2.name === __typename)) == null ? void 0 : _b.fields) == null ? void 0 : _c.map((field) => field.name);
    if (!source || !fields8)
      return;
    const { fileName } = source;
    const code2 = await workbench.readFile(fileName);
    const node = astFindSource(code2, source);
    const foundFields = findFields(node, fields8);
    el2.__typename = (foundFields == null ? void 0 : foundFields.length) === 1 ? __typename : void 0;
  });
  el2.addEventListener("commitAllChanges", async (e) => {
    handleCommitAllChanges(LOGIN_GITHUB, COMMIT_CHANGES, e);
  });
  el2.addEventListener("saveProjectZip", async () => {
    frontendActions.saveZip();
  });
  el2.addEventListener("modechange", async (e) => {
  });
  el2.addEventListener("generatePage", async (e) => {
    handleGeneratePageClick(window2, GENERATE_PAGE, e);
  });
  el2.addEventListener("listAllTranslations", async (e) => {
    handleShowAllTranslations(e);
  });
  el2.addEventListener("changeGraphqlEndpoint", async (e) => {
    handleChangeGraphqlEndpoint(CHANGE_GRAPHQL_ENDPOINT, e);
  });
  el2.addEventListener("changeTheme", async (e) => {
    handleChangeTheme(CHANGE_THEME, e);
  });
  el2.addEventListener("createTable", async (e) => {
    handleCreateTable(el2, e);
  });
  el2.addEventListener("addNewColumn", async (e) => {
    handleAddColumn(el2, e);
  });
  el2.addEventListener("viewERD", async (e) => {
    handleViewERD(el2, e);
  });
  el2.addEventListener("loadIntrospection", async () => {
    const introspection2 = await loadIntrospection({ viewMessage: true });
    if (introspection2) {
      workbench.setIntrospection(introspection2);
      el2.introspection = introspectionDeepCopy(introspection2);
    }
  });
  el2.addEventListener("filterIntrospection", async () => {
    let entityName = getEntityNameFromUrl();
    if (!workbench.introspection.types.some((type2) => type2.name === entityName))
      entityName = el2.__typename;
    const filteredIntrospection = filterIntrospection(workbench.introspection, entityName);
    el2.introspection = filteredIntrospection;
  });
  document.body.appendChild(el2);
  el2.id = "iteria-wysiwyg";
  const introspection = await loadIntrospection({ viewMessage: false });
  el2.introspection = introspectionDeepCopy(introspection);
  workbench.setIntrospection(introspection);
  el2.win = window2;
  el2.isDevserver = injectMode === "devServer";
  el2.isNetlify = workbench.env.VITE_NETLIFY === "true";
  messagingService.postMessage(LOWCODE_INITIALIZED, {});
  el2.isInitialized = true;
  oneAuth = new OneGraphAuth(workbench.env.VITE_SITE_ID);
};
let oneAuth;
const loadIntrospection = async (options2 = { viewMessage: true }) => {
  try {
    const schema2 = await fetchGraphqlIntrospectionSchema(workbench.graphQLEndpoint, workbench.graphQLSecret);
    if (options2.viewMessage) {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: { type: "LOAD_INTROSPECTION_SUCCESS" }
      });
    }
    return schema2;
  } catch (err2) {
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: { type: "LOAD_INTROSPECTION_ERROR", payload: err2 }
    });
    console.error(err2);
    return null;
  }
};
const getPageTypeFromUrl = () => {
  const url = window.location.href;
  const urlParts = url.split("/").filter(Boolean);
  if (detailPageRegex.test(urlParts[urlParts.length - 1]) || detailPageFullRegex.test(urlParts[urlParts.length - 1]) || urlParts[urlParts.length - 1] === "create") {
    return PageType.DETAIL;
  } else
    return PageType.LIST;
};
const cloneColumn = async (selectedFields2, insertType, el2, entity) => {
  var _a2;
  const entityFromUrl = (_a2 = entity != null ? entity : getEntityNameFromUrl()) != null ? _a2 : selectedFields2[0].split(".")[0];
  const entityName = entityExists(workbench.introspection.types, entityFromUrl) ? entityFromUrl : findTypenameValue();
  let source = {};
  source.columnToAdd = selectedFields2;
  source.referenceField = el2 ? getFieldNameFromElement(el2) : void 0;
  source.entityName = entityName;
  source.page = getPageTypeFromUrl();
  source.insertType = insertType;
  frontendActions.elementHighlightClick(CLONE_ELEMENT, source);
};
const getInsertType = (insertType) => {
  if (!insertType)
    return InsertType.AFTER;
  switch (insertType) {
    case "before":
      return InsertType.BEFORE;
    case "after":
      return InsertType.AFTER;
    case "first":
      return InsertType.FIRST;
    case "last":
      return InsertType.LAST;
    default:
      return InsertType.AFTER;
  }
};
const getAllTranslations = async (path2, io) => {
  if (path2) {
    const allTranslations = {
      langs: {}
    };
    const directory = await io.readDirectory(path2);
    if (directory) {
      const langs = Object.values(directory);
      for (let index2 in langs) {
        const item = langs[index2];
        const fileName = item.fileName;
        const lang = stripExtension$1(fileName);
        const translation = await io.readFile(item.filePath);
        if (translation) {
          allTranslations["langs"][lang] = JSON.parse(translation);
          allTranslations[fileName] = item.filePath;
        }
      }
      return allTranslations;
    }
  }
  return { langs: {} };
};
const handleShowAllTranslations = async (event2) => {
  var _a2, _b, _c;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogTranslationSheet;
  const hide = (_b = event2 == null ? void 0 : event2.detail) == null ? void 0 : _b.hide;
  const cwd = (_c = guessCurrentWorkingDirectory()) != null ? _c : workbench == null ? void 0 : workbench.cwd;
  const LANGS_PATH = workbench.injectMode === "devServer" ? cwd + "/src/compiled-lang" : "/src/compiled-lang";
  const translation = await getAllTranslations(LANGS_PATH, workbench);
  await dialog({
    translations: translation.langs,
    ok: async (e, changedTranslations) => {
      let langsToWrite = Object.keys(e).map((localeLang) => !(localeLang in translation.langs) || changedTranslations.has(localeLang) ? {
        path: LANGS_PATH + "/" + localeLang + ".json",
        data: JSON.stringify(e[localeLang], void 0, 2)
      } : null).filter(Boolean);
      const langsToDelete = Object.keys(translation.langs).map((localeLang) => localeLang in e ? null : { path: LANGS_PATH + "/" + localeLang + ".json" }).filter(Boolean);
      if (langsToDelete.length)
        frontendActions.multipleFileDelete(langsToDelete);
      if (langsToWrite.length)
        frontendActions.multipleFileWrite(langsToWrite);
      if (typeof hide === "function")
        hide();
    }
  });
};
const handleRemoveTableColumn = async (window2, el2, type2) => {
  if (!window2.__REACT_DEVTOOLS_GLOBAL_HOOK__)
    throw new Error("__REACT_DEVTOOLS_GLOBAL_HOOK__ not available on window object");
  const entityName = getEntityNameFromUrl();
  const source = getSourceFromElement(getColumnTitle(el2));
  console.log("test", source);
  if (!source)
    return console.error("Source not found", el2);
  source.colIndex = getColIndex(el2);
  source.schema = workbench.introspection;
  source.page = PageType.LIST;
  source.entityName = entityName;
  source.columnToDelete = getFieldNameFromElement(el2);
  await removeFieldFromTable(workbench, getSourceFromElement(getColumnTitle(el2)));
  if (!source)
    return console.error("Source not found", el2);
  frontendActions.elementHighlightClick(type2, source);
};
const handleRemoveFormColumn = async (contentWindow, el2, type2) => {
  var _a2;
  const schema2 = await fetchGraphqlIntrospectionSchema(workbench.graphQLEndpoint, workbench.graphQLSecret);
  const entityName = getEntityNameFromUrl();
  const source = getSourceFromElement(el2);
  if (!source)
    return console.error("Source not found", el2);
  source.schema = schema2;
  source.page = PageType.DETAIL;
  source.entityName = entityName;
  const element2 = (_a2 = getInputElement(el2)) != null ? _a2 : el2;
  source.columnToDelete = element2.getAttribute("name");
  if (!source)
    return console.error("Source not found", el2);
  frontendActions.elementHighlightClick(type2, source);
};
const handleIconClick = (window2, el2, type2) => {
  const source = getSourceFromElement(el2);
  if (!window2.__REACT_DEVTOOLS_GLOBAL_HOOK__)
    throw new Error("__REACT_DEVTOOLS_GLOBAL_HOOK__ not available on window object");
  if (!source) {
    window2.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: { type: `${type2}_ERROR` }
    });
    return console.error("Source not found", el2);
  }
  frontendActions.elementHighlightClick(type2, source);
};
const handleGeneratePageClick = async (window2, type2, event2) => {
  var _a2, _b;
  const introspection = introspectionDeepCopy(workbench.introspection);
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogChooseEntityFields;
  const hide = (_b = event2 == null ? void 0 : event2.detail) == null ? void 0 : _b.hide;
  const [queryRoot] = getRoots(introspection);
  queryRoot.fields = queryRoot.fields.filter((field) => !isByPkQuery(field) && !isAggregateField(field));
  introspection.types.map((type22) => {
    if (type22.name === "query_root") {
      type22.fields = queryRoot.fields;
    }
  });
  const introDeepCopy = introspectionDeepCopy(introspection);
  await dialog({
    intro: introDeepCopy,
    fieldSelected: async (e) => {
      const source = {};
      source.fieldToGenerate = e.selectedFields;
      source.typeOfField = e.selectedFields.type;
      source.generateReact = e.generateReact;
      source.intro = introDeepCopy;
      frontendActions.elementHighlightClick(type2, source);
      hide();
    }
  });
};
const handleChangeGraphqlEndpoint = async (type2, event2) => {
  var _a2;
  const graphqlEndpointURL = workbench.graphQLEndpoint;
  const graphqlSecret = workbench.graphQLSecret;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogChangeGraphqlEndpoint;
  await dialog({
    currentEndpoint: graphqlEndpointURL,
    currentSecret: graphqlSecret,
    endpointChanged: async (e, ex) => {
      const source = {};
      source.newEndpointURL = e;
      source.newSecret = ex;
      frontendActions.elementHighlightClick(type2, source);
    }
  });
};
const handleChangeTheme = async (type2, event2) => {
  var _a2, _b;
  const THEME_NAME = "colors";
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogThemeEditor;
  const cwd = (_b = guessCurrentWorkingDirectory()) != null ? _b : workbench == null ? void 0 : workbench.cwd;
  if (cwd) {
    const THEME_DIR = cwd + "/src/theme";
    const theme = await getTheme(THEME_DIR, THEME_NAME, workbench, frontendActions);
    if (theme) {
      await dialog({
        theme: theme[THEME_NAME],
        save: async (e) => {
          const source = {};
          source.theme = e;
          frontendActions.elementHighlightClick(type2, source);
        }
      });
    }
  }
};
const handleCreateTable = async (el2, event2) => {
  var _a2;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogCreateTable;
  await dialog({
    tableCreated: async (tableInfo) => {
      showUserFeedback({ type: "CREATE_TABLE_INFO" });
      createNewTable(tableInfo, workbench).then(() => {
        showUserFeedback({ type: "CREATE_TABLE_SUCCESS" });
        loadNewIntrospection(el2);
      }).catch(() => {
      });
    }
  });
};
const handleAddColumn = async (el2, event2) => {
  var _a2;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogAddNewColum;
  await dialog({
    dataTypes,
    columnAdded: async (e) => {
      addNewColumn(e).then(() => loadNewIntrospection(el2));
    }
  });
};
const handleCommitAllChanges = async (loginType, commitType, event2) => {
  var _a2;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogCommitChanges;
  const checkCORS = await oneAuth.checkCORS();
  let isLoggedIn = false;
  if (!checkCORS)
    isLoggedIn = await oneAuth.isLoggedIn();
  let allChangedFiles = workbench.fs.readHistoryFiles();
  const changedFilesCount = Object.keys(allChangedFiles).length;
  let defaultCommitMessage = "";
  if (changedFilesCount > 0) {
    const fileNames = Object.keys(allChangedFiles);
    fileNames.every((fileName, index2) => {
      const lastIndexOfSlash = fileName.lastIndexOf("/");
      if (index2 >= 2) {
        defaultCommitMessage += ", " + fileName.substring(lastIndexOfSlash + 1).slice(0, 3) + "...";
        return false;
      }
      if (index2 > 0)
        defaultCommitMessage += ", ";
      defaultCommitMessage += fileName.substring(lastIndexOfSlash + 1);
      return true;
    });
  } else {
    defaultCommitMessage = "Nothing to Commit!";
  }
  await dialog({
    commitMessage: defaultCommitMessage,
    siteId: workbench.env.VITE_SITE_ID,
    repositoryUrl: workbench.env.VITE_REPOSITORY_URL,
    branch: workbench.env.VITE_BRANCH,
    corsCheck: checkCORS,
    isLoggedIn,
    changedFilesCount,
    loginGithub: async (e) => {
      if (e === true)
        await oneAuth.login();
      else
        await oneAuth.logout();
    },
    commitChanges: async (e) => {
      const source = {};
      source.commitMessage = e;
      const commitMessage = e;
      const branch = workbench.env.VITE_BRANCH;
      const repositoryUrl = stripGitHubUrl(workbench.env.VITE_REPOSITORY_URL);
      showUserFeedback({ type: "COMMIT_ALL_CHANGES_INFO" });
      let allChangedFiles2 = workbench.fs.readHistoryFiles();
      workbench.fs.deleteHistoryFiles();
      executeCommit(oneAuth.fetchUrl(), oneAuth.accessToken(), branch, repositoryUrl, commitMessage, allChangedFiles2).then((response) => {
        const success = response.success;
        if (!success)
          workbench.fs.mergeHistoryFiles(allChangedFiles2);
        delay(4e3).then(() => {
          if (response.success) {
            showUserFeedback({ type: "COMMIT_ALL_CHANGES_SUCCESS" });
          } else {
            showUserFeedback({ type: "COMMIT_ALL_CHANGES_ERROR" });
            console.error("Commit Error: ", response.errors);
          }
        });
      });
      frontendActions.elementHighlightClick(commitType, source);
    }
  });
};
const handleViewERD = async (el2, event2) => {
  var _a2;
  const dialog = (_a2 = event2 == null ? void 0 : event2.detail) == null ? void 0 : _a2.dialogViewERD;
  const introspection = introspectionDeepCopy(workbench.introspection);
  let tablesInfo;
  let constraintInfo;
  let error2 = false;
  showUserFeedback({ type: "ERD_VIEW_INFO" });
  await fetchHasuraQuery(getTablesInfo(), "get_tables_info", false, workbench).then(handleErrors).then((res2) => {
    tablesInfo = res2.result;
  }).catch(() => {
    error2 = true;
  });
  await fetchHasuraQuery(getConstraintInfo(), "get_constraints_info", false, workbench).then(handleErrors).then((res2) => {
    constraintInfo = res2.result;
  }).catch(() => {
    error2 = true;
  });
  if (error2 || !introspection) {
    showUserFeedback({ type: "LOAD_INTROSPECTION_ERROR" });
  }
  let sqlData = generateSQLData(introspection, tablesInfo, [...constraintInfo]);
  await dialog({
    data: createVuerdTemplate(sqlData),
    saved: async (e) => {
      const properties = {
        introspection,
        jsonData: e.jsonData,
        migration: e.migration,
        workbench,
        tablesInfo,
        constraintInfo
      };
      saveDatabase(properties).then(() => {
        showUserFeedback({ type: "UPDATE_DATABASE_SUCCESS" });
        loadNewIntrospection(el2);
      }).catch(() => {
      });
    }
  });
};
const findFormattedMessageElementUp = (el2) => {
  let foundedFormattedMessageElement = void 0;
  if (el2.tagName === "SPAN" && el2.dataset.messageId) {
    foundedFormattedMessageElement = el2;
  } else {
    const existParentFormattedMessage = (el22) => {
      let depth2 = 5;
      while (el22.parentNode && depth2--) {
        el22 = el22.parentNode;
        if (el22.tagName === "SPAN" && el22.dataset.messageId) {
          foundedFormattedMessageElement = el22;
          break;
        }
      }
    };
    existParentFormattedMessage(el2);
  }
  return foundedFormattedMessageElement;
};
const getFormattedMessageElement = (element2) => {
  let foundedFormattedMessageElement = void 0;
  const findFormattedMessageElement = (el2, depth2) => {
    if (el2.tagName === "SPAN" && el2.dataset.messageId) {
      foundedFormattedMessageElement = el2;
      return el2;
    }
    if (depth2 === 0) {
      return el2;
    }
    el2.childNodes.forEach((node) => {
      return findFormattedMessageElement(node, depth2 - 1);
    });
  };
  findFormattedMessageElement(element2, 5);
  return foundedFormattedMessageElement || findFormattedMessageElementUp(element2);
};
const addNewColumn = (columnProps) => {
  showUserFeedback({ type: "ADD_COLUMN_INFO" });
  return createColumn(columnProps, columnProps.migration, workbench).then(() => {
    return resolveForeignKey(columnProps, workbench, "ADD_COLUMN_ERROR", true);
  }).catch((err2) => {
    showUserFeedback({ type: "ADD_COLUMN_ERROR" });
    return Promise.reject(err2);
  });
};
async function loadNewIntrospection(el2) {
  const introspection = await loadIntrospection({ viewMessage: true });
  if (introspection) {
    workbench.setIntrospection(introspection);
    if (el2)
      el2.introspection = introspectionDeepCopy(introspection);
  }
}
const handleReorderElements = async (window2, payload, type2) => {
  if (!window2.__REACT_DEVTOOLS_GLOBAL_HOOK__)
    throw new Error("__REACT_DEVTOOLS_GLOBAL_HOOK__ not available on window object");
  let data = {
    fileName: void 0,
    elementsPosEnd: {},
    chained_changes: {},
    hasFields: payload.hasFields,
    hasRoutes: payload.hasRoutes,
    hasColumns: payload.hasColumns,
    hasRelations: payload.hasRelations,
    relationName: payload.relationName,
    entityName: getEntityNameFromUrl()
  };
  if (payload.hasFields || payload.hasRoutes || payload.hasColumns || payload.hasRelations) {
    let allNames = Array(payload.elements.length + 1);
    payload.elements.forEach((element2) => {
      allNames[element2.prevIndex] = element2.fieldName;
    });
    payload.elements.forEach((item) => data.chained_changes[allNames[item.prevIndex]] = allNames[item.newIndex]);
  } else {
    payload.elements.forEach((item) => data.chained_changes[item.prevIndex] = item.newIndex);
  }
  if (!payload.hasFields && !payload.hasRoutes && !payload.hasColumns && !payload.hasRelations) {
    payload.elements.forEach((item) => {
      const source = getSourceFromElement(item.element);
      if (!source) {
        window2.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: { type: `${type2}_ERROR` }
        });
        console.error("Source not found", item.element);
      }
      data.elementsPosEnd[item.prevIndex] = source;
      data.fileName = source.fileName;
    });
  }
  frontendActions.elementHighlightClick(type2, data);
};
var FileSaver_min = { exports: {} };
(function(module2, exports2) {
  (function(a, b) {
    b();
  })(commonjsGlobal, function() {
    function b(a2, b2) {
      return typeof b2 == "undefined" ? b2 = { autoBom: false } : typeof b2 != "object" && (console.warn("Deprecated: Expected third argument to be a object"), b2 = { autoBom: !b2 }), b2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a2.type) ? new Blob(["\uFEFF", a2], { type: a2.type }) : a2;
    }
    function c2(a2, b2, c3) {
      var d2 = new XMLHttpRequest();
      d2.open("GET", a2), d2.responseType = "blob", d2.onload = function() {
        g(d2.response, b2, c3);
      }, d2.onerror = function() {
        console.error("could not download file");
      }, d2.send();
    }
    function d(a2) {
      var b2 = new XMLHttpRequest();
      b2.open("HEAD", a2, false);
      try {
        b2.send();
      } catch (a3) {
      }
      return 200 <= b2.status && 299 >= b2.status;
    }
    function e(a2) {
      try {
        a2.dispatchEvent(new MouseEvent("click"));
      } catch (c3) {
        var b2 = document.createEvent("MouseEvents");
        b2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a2.dispatchEvent(b2);
      }
    }
    var f = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal ? commonjsGlobal : void 0, a = f.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g = f.saveAs || (typeof window != "object" || window !== f ? function() {
    } : "download" in HTMLAnchorElement.prototype && !a ? function(b2, g2, h) {
      var i2 = f.URL || f.webkitURL, j2 = document.createElement("a");
      g2 = g2 || b2.name || "download", j2.download = g2, j2.rel = "noopener", typeof b2 == "string" ? (j2.href = b2, j2.origin === location.origin ? e(j2) : d(j2.href) ? c2(b2, g2, h) : e(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b2), setTimeout(function() {
        i2.revokeObjectURL(j2.href);
      }, 4e4), setTimeout(function() {
        e(j2);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(f2, g2, h) {
      if (g2 = g2 || f2.name || "download", typeof f2 != "string")
        navigator.msSaveOrOpenBlob(b(f2, h), g2);
      else if (d(f2))
        c2(f2, g2, h);
      else {
        var i2 = document.createElement("a");
        i2.href = f2, i2.target = "_blank", setTimeout(function() {
          e(i2);
        });
      }
    } : function(b2, d2, e2, g2) {
      if (g2 = g2 || open("", "_blank"), g2 && (g2.document.title = g2.document.body.innerText = "downloading..."), typeof b2 == "string")
        return c2(b2, d2, e2);
      var h = b2.type === "application/octet-stream", i2 = /constructor/i.test(f.HTMLElement) || f.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((j2 || h && i2 || a) && typeof FileReader != "undefined") {
        var k2 = new FileReader();
        k2.onloadend = function() {
          var a2 = k2.result;
          a2 = j2 ? a2 : a2.replace(/^data:[^;]*;/, "data:attachment/file;"), g2 ? g2.location.href = a2 : location = a2, g2 = null;
        }, k2.readAsDataURL(b2);
      } else {
        var l2 = f.URL || f.webkitURL, m = l2.createObjectURL(b2);
        g2 ? g2.location = m : location.href = m, g2 = null, setTimeout(function() {
          l2.revokeObjectURL(m);
        }, 4e4);
      }
    });
    f.saveAs = g.saveAs = g, module2.exports = g;
  });
})(FileSaver_min);
var FileSaver = FileSaver_min.exports;
var jszip_min = { exports: {} };
/*!

JSZip v3.7.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
(function(module2, exports2) {
  !function(t) {
    module2.exports = t();
  }(function() {
    return function s(a, o, h) {
      function u(r, t2) {
        if (!o[r]) {
          if (!a[r]) {
            var e = typeof commonjsRequire == "function" && commonjsRequire;
            if (!t2 && e)
              return e(r, true);
            if (l2)
              return l2(r, true);
            var i2 = new Error("Cannot find module '" + r + "'");
            throw i2.code = "MODULE_NOT_FOUND", i2;
          }
          var n2 = o[r] = { exports: {} };
          a[r][0].call(n2.exports, function(t3) {
            var e2 = a[r][1][t3];
            return u(e2 || t3);
          }, n2, n2.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l2 = typeof commonjsRequire == "function" && commonjsRequire, t = 0; t < h.length; t++)
        u(h[t]);
      return u;
    }({ 1: [function(t, e, r) {
      var c2 = t("./utils"), d = t("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(t2) {
        for (var e2, r2, i2, n2, s, a, o, h = [], u = 0, l2 = t2.length, f = l2, d2 = c2.getTypeOf(t2) !== "string"; u < t2.length; )
          f = l2 - u, i2 = d2 ? (e2 = t2[u++], r2 = u < l2 ? t2[u++] : 0, u < l2 ? t2[u++] : 0) : (e2 = t2.charCodeAt(u++), r2 = u < l2 ? t2.charCodeAt(u++) : 0, u < l2 ? t2.charCodeAt(u++) : 0), n2 = e2 >> 2, s = (3 & e2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | i2 >> 6 : 64, o = 2 < f ? 63 & i2 : 64, h.push(p2.charAt(n2) + p2.charAt(s) + p2.charAt(a) + p2.charAt(o));
        return h.join("");
      }, r.decode = function(t2) {
        var e2, r2, i2, n2, s, a, o = 0, h = 0, u = "data:";
        if (t2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l2, f = 3 * (t2 = t2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
        if (t2.charAt(t2.length - 1) === p2.charAt(64) && f--, t2.charAt(t2.length - 2) === p2.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l2 = d.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < t2.length; )
          e2 = p2.indexOf(t2.charAt(o++)) << 2 | (n2 = p2.indexOf(t2.charAt(o++))) >> 4, r2 = (15 & n2) << 4 | (s = p2.indexOf(t2.charAt(o++))) >> 2, i2 = (3 & s) << 6 | (a = p2.indexOf(t2.charAt(o++))), l2[h++] = e2, s !== 64 && (l2[h++] = r2), a !== 64 && (l2[h++] = i2);
        return l2;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, e, r) {
      var i2 = t("./external"), n2 = t("./stream/DataWorker"), s = t("./stream/Crc32Probe"), a = t("./stream/DataLengthProbe");
      function o(t2, e2, r2, i3, n3) {
        this.compressedSize = t2, this.uncompressedSize = e2, this.crc32 = r2, this.compression = i3, this.compressedContent = n3;
      }
      o.prototype = { getContentWorker: function() {
        var t2 = new n2(i2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), e2 = this;
        return t2.on("end", function() {
          if (this.streamInfo.data_length !== e2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), t2;
      }, getCompressedWorker: function() {
        return new n2(i2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(t2, e2, r2) {
        return t2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(e2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", e2);
      }, e.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, e, r) {
      var i2 = t("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function(t2) {
        return new i2("STORE compression");
      }, uncompressWorker: function() {
        return new i2("STORE decompression");
      } }, r.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, e, r) {
      var i2 = t("./utils");
      var o = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var i3 = 0; i3 < 8; i3++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2) {
        return t2 !== void 0 && t2.length ? i2.getTypeOf(t2) !== "string" ? function(t3, e3, r2, i3) {
          var n2 = o, s = i3 + r2;
          t3 ^= -1;
          for (var a = i3; a < s; a++)
            t3 = t3 >>> 8 ^ n2[255 & (t3 ^ e3[a])];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : function(t3, e3, r2, i3) {
          var n2 = o, s = i3 + r2;
          t3 ^= -1;
          for (var a = i3; a < s; a++)
            t3 = t3 >>> 8 ^ n2[255 & (t3 ^ e3.charCodeAt(a))];
          return -1 ^ t3;
        }(0 | e2, t2, t2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, e, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(t, e, r) {
      var i2 = null;
      i2 = typeof Promise != "undefined" ? Promise : t("lie"), e.exports = { Promise: i2 };
    }, { lie: 37 }], 7: [function(t, e, r) {
      var i2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined", n2 = t("pako"), s = t("./utils"), a = t("./stream/GenericWorker"), o = i2 ? "uint8array" : "array";
      function h(t2, e2) {
        a.call(this, "FlateWorker/" + t2), this._pako = null, this._pakoAction = t2, this._pakoOptions = e2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(t2) {
        this.meta = t2.meta, this._pako === null && this._createPako(), this._pako.push(s.transformTo(o, t2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new n2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var e2 = this;
        this._pako.onData = function(t2) {
          e2.push({ data: t2, meta: e2.meta });
        };
      }, r.compressWorker = function(t2) {
        return new h("Deflate", t2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, e, r) {
      function A(t2, e2) {
        var r2, i3 = "";
        for (r2 = 0; r2 < e2; r2++)
          i3 += String.fromCharCode(255 & t2), t2 >>>= 8;
        return i3;
      }
      function i2(t2, e2, r2, i3, n3, s2) {
        var a, o, h = t2.file, u = t2.compression, l2 = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), d = I.transformTo("string", O.utf8encode(h.name)), c2 = h.comment, p2 = I.transformTo("string", s2(c2)), m = I.transformTo("string", O.utf8encode(c2)), _ = d.length !== h.name.length, g = m.length !== c2.length, b = "", v = "", y2 = "", w = h.dir, k2 = h.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        e2 && !r2 || (x2.crc32 = t2.crc32, x2.compressedSize = t2.compressedSize, x2.uncompressedSize = t2.uncompressedSize);
        var S = 0;
        e2 && (S |= 8), l2 || !_ && !g || (S |= 2048);
        var z2 = 0, C = 0;
        w && (z2 |= 16), n3 === "UNIX" ? (C = 798, z2 |= function(t3, e3) {
          var r3 = t3;
          return t3 || (r3 = e3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z2 |= function(t3) {
          return 63 & (t3 || 0);
        }(h.dosPermissions)), a = k2.getUTCHours(), a <<= 6, a |= k2.getUTCMinutes(), a <<= 5, a |= k2.getUTCSeconds() / 2, o = k2.getUTCFullYear() - 1980, o <<= 4, o |= k2.getUTCMonth() + 1, o <<= 5, o |= k2.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + d, b += "up" + A(v.length, 2) + v), g && (y2 = A(1, 1) + A(B(p2), 4) + m, b += "uc" + A(y2.length, 2) + y2);
        var E = "";
        return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x2.crc32, 4), E += A(x2.compressedSize, 4), E += A(x2.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p2.length, 2) + "\0\0\0\0" + A(z2, 4) + A(i3, 4) + f + b + p2 };
      }
      var I = t("../utils"), n2 = t("../stream/GenericWorker"), O = t("../utf8"), B = t("../crc32"), R = t("../signature");
      function s(t2, e2, r2, i3) {
        n2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = e2, this.zipPlatform = r2, this.encodeFileName = i3, this.streamFiles = t2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, n2), s.prototype.push = function(t2) {
        var e2 = t2.meta.percent || 0, r2 = this.entriesCount, i3 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(t2) : (this.bytesWritten += t2.data.length, n2.prototype.push.call(this, { data: t2.data, meta: { currentFile: this.currentFile, percent: r2 ? (e2 + 100 * (r2 - i3 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(t2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = t2.file.name;
        var e2 = this.streamFiles && !t2.file.dir;
        if (e2) {
          var r2 = i2(t2, e2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(t2) {
        this.accumulate = false;
        var e2 = this.streamFiles && !t2.file.dir, r2 = i2(t2, e2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), e2)
          this.push({ data: function(t3) {
            return R.DATA_DESCRIPTOR + A(t3.crc32, 4) + A(t3.compressedSize, 4) + A(t3.uncompressedSize, 4);
          }(t2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var t2 = this.bytesWritten, e2 = 0; e2 < this.dirRecords.length; e2++)
          this.push({ data: this.dirRecords[e2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - t2, i3 = function(t3, e3, r3, i4, n3) {
          var s2 = I.transformTo("string", n3(i4));
          return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(t3, 2) + A(t3, 2) + A(e3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, t2, this.zipComment, this.encodeFileName);
        this.push({ data: i3, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(t2) {
        this._sources.push(t2);
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.closedSource(e2.previous.streamInfo), e2._sources.length ? e2.prepareNextSource() : e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, s.prototype.resume = function() {
        return !!n2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(t2) {
        var e2 = this._sources;
        if (!n2.prototype.error.call(this, t2))
          return false;
        for (var r2 = 0; r2 < e2.length; r2++)
          try {
            e2[r2].error(t2);
          } catch (t3) {
          }
        return true;
      }, s.prototype.lock = function() {
        n2.prototype.lock.call(this);
        for (var t2 = this._sources, e2 = 0; e2 < t2.length; e2++)
          t2[e2].lock();
      }, e.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, e, r) {
      var u = t("../compressions"), i2 = t("./ZipFileWorker");
      r.generateWorker = function(t2, a, e2) {
        var o = new i2(a.streamFiles, e2, a.platform, a.encodeFileName), h = 0;
        try {
          t2.forEach(function(t3, e3) {
            h++;
            var r2 = function(t4, e4) {
              var r3 = t4 || e4, i4 = u[r3];
              if (!i4)
                throw new Error(r3 + " is not a valid compression method !");
              return i4;
            }(e3.options.compression, a.compression), i3 = e3.options.compressionOptions || a.compressionOptions || {}, n2 = e3.dir, s = e3.date;
            e3._compressWorker(r2, i3).withStreamInfo("file", { name: t3, dir: n2, date: s, comment: e3.comment || "", unixPermissions: e3.unixPermissions, dosPermissions: e3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (t3) {
          o.error(t3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, e, r) {
      function i2() {
        if (!(this instanceof i2))
          return new i2();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var t2 = new i2();
          for (var e2 in this)
            typeof this[e2] != "function" && (t2[e2] = this[e2]);
          return t2;
        };
      }
      (i2.prototype = t("./object")).loadAsync = t("./load"), i2.support = t("./support"), i2.defaults = t("./defaults"), i2.version = "3.7.1", i2.loadAsync = function(t2, e2) {
        return new i2().loadAsync(t2, e2);
      }, i2.external = t("./external"), e.exports = i2;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, e, r) {
      var i2 = t("./utils"), n2 = t("./external"), o = t("./utf8"), h = t("./zipEntries"), s = t("./stream/Crc32Probe"), u = t("./nodejsUtils");
      function l2(i3) {
        return new n2.Promise(function(t2, e2) {
          var r2 = i3.decompressed.getContentWorker().pipe(new s());
          r2.on("error", function(t3) {
            e2(t3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== i3.decompressed.crc32 ? e2(new Error("Corrupted zip : CRC32 mismatch")) : t2();
          }).resume();
        });
      }
      e.exports = function(t2, s2) {
        var a = this;
        return s2 = i2.extend(s2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), u.isNode && u.isStream(t2) ? n2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i2.prepareContent("the loaded zip file", t2, true, s2.optimizedBinaryString, s2.base64).then(function(t3) {
          var e2 = new h(s2);
          return e2.load(t3), e2;
        }).then(function(t3) {
          var e2 = [n2.Promise.resolve(t3)], r2 = t3.files;
          if (s2.checkCRC32)
            for (var i3 = 0; i3 < r2.length; i3++)
              e2.push(l2(r2[i3]));
          return n2.Promise.all(e2);
        }).then(function(t3) {
          for (var e2 = t3.shift(), r2 = e2.files, i3 = 0; i3 < r2.length; i3++) {
            var n3 = r2[i3];
            a.file(n3.fileNameStr, n3.decompressed, { binary: true, optimizedBinaryString: true, date: n3.date, dir: n3.dir, comment: n3.fileCommentStr.length ? n3.fileCommentStr : null, unixPermissions: n3.unixPermissions, dosPermissions: n3.dosPermissions, createFolders: s2.createFolders });
          }
          return e2.zipComment.length && (a.comment = e2.zipComment), a;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, e, r) {
      var i2 = t("../utils"), n2 = t("../stream/GenericWorker");
      function s(t2, e2) {
        n2.call(this, "Nodejs stream input adapter for " + t2), this._upstreamEnded = false, this._bindStream(e2);
      }
      i2.inherits(s, n2), s.prototype._bindStream = function(t2) {
        var e2 = this;
        (this._stream = t2).pause(), t2.on("data", function(t3) {
          e2.push({ data: t3, meta: { percent: 0 } });
        }).on("error", function(t3) {
          e2.isPaused ? this.generatedError = t3 : e2.error(t3);
        }).on("end", function() {
          e2.isPaused ? e2._upstreamEnded = true : e2.end();
        });
      }, s.prototype.pause = function() {
        return !!n2.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!n2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, e.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, e, r) {
      var n2 = t("readable-stream").Readable;
      function i2(t2, e2, r2) {
        n2.call(this, e2), this._helper = t2;
        var i3 = this;
        t2.on("data", function(t3, e3) {
          i3.push(t3) || i3._helper.pause(), r2 && r2(e3);
        }).on("error", function(t3) {
          i3.emit("error", t3);
        }).on("end", function() {
          i3.push(null);
        });
      }
      t("../utils").inherits(i2, n2), i2.prototype._read = function() {
        this._helper.resume();
      }, e.exports = i2;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, e, r) {
      e.exports = { isNode: typeof Buffer != "undefined", newBufferFrom: function(t2, e2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(t2, e2);
        if (typeof t2 == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(t2, e2);
      }, allocBuffer: function(t2) {
        if (Buffer.alloc)
          return Buffer.alloc(t2);
        var e2 = new Buffer(t2);
        return e2.fill(0), e2;
      }, isBuffer: function(t2) {
        return Buffer.isBuffer(t2);
      }, isStream: function(t2) {
        return t2 && typeof t2.on == "function" && typeof t2.pause == "function" && typeof t2.resume == "function";
      } };
    }, {}], 15: [function(t, e, r) {
      function s(t2, e2, r2) {
        var i3, n3 = u.getTypeOf(e2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || new Date(), s2.compression !== null && (s2.compression = s2.compression.toUpperCase()), typeof s2.unixPermissions == "string" && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (t2 = g(t2)), s2.createFolders && (i3 = _(t2)) && b.call(this, i3, true);
        var a2 = n3 === "string" && s2.binary === false && s2.base64 === false;
        r2 && r2.binary !== void 0 || (s2.binary = !a2), (e2 instanceof d && e2.uncompressedSize === 0 || s2.dir || !e2 || e2.length === 0) && (s2.base64 = false, s2.binary = true, e2 = "", s2.compression = "STORE", n3 = "string");
        var o2 = null;
        o2 = e2 instanceof d || e2 instanceof l2 ? e2 : p2.isNode && p2.isStream(e2) ? new m(t2, e2) : u.prepareContent(t2, e2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new c2(t2, o2, s2);
        this.files[t2] = h2;
      }
      var n2 = t("./utf8"), u = t("./utils"), l2 = t("./stream/GenericWorker"), a = t("./stream/StreamHelper"), f = t("./defaults"), d = t("./compressedObject"), c2 = t("./zipObject"), o = t("./generate"), p2 = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), _ = function(t2) {
        t2.slice(-1) === "/" && (t2 = t2.substring(0, t2.length - 1));
        var e2 = t2.lastIndexOf("/");
        return 0 < e2 ? t2.substring(0, e2) : "";
      }, g = function(t2) {
        return t2.slice(-1) !== "/" && (t2 += "/"), t2;
      }, b = function(t2, e2) {
        return e2 = e2 !== void 0 ? e2 : f.createFolders, t2 = g(t2), this.files[t2] || s.call(this, t2, null, { dir: true, createFolders: e2 }), this.files[t2];
      };
      function h(t2) {
        return Object.prototype.toString.call(t2) === "[object RegExp]";
      }
      var i2 = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(t2) {
        var e2, r2, i3;
        for (e2 in this.files)
          i3 = this.files[e2], (r2 = e2.slice(this.root.length, e2.length)) && e2.slice(0, this.root.length) === this.root && t2(r2, i3);
      }, filter: function(r2) {
        var i3 = [];
        return this.forEach(function(t2, e2) {
          r2(t2, e2) && i3.push(e2);
        }), i3;
      }, file: function(t2, e2, r2) {
        if (arguments.length !== 1)
          return t2 = this.root + t2, s.call(this, t2, e2, r2), this;
        if (h(t2)) {
          var i3 = t2;
          return this.filter(function(t3, e3) {
            return !e3.dir && i3.test(t3);
          });
        }
        var n3 = this.files[this.root + t2];
        return n3 && !n3.dir ? n3 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(t3, e3) {
            return e3.dir && r2.test(t3);
          });
        var t2 = this.root + r2, e2 = b.call(this, t2), i3 = this.clone();
        return i3.root = e2.name, i3;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var t2 = this.files[r2];
        if (t2 || (r2.slice(-1) !== "/" && (r2 += "/"), t2 = this.files[r2]), t2 && !t2.dir)
          delete this.files[r2];
        else
          for (var e2 = this.filter(function(t3, e3) {
            return e3.name.slice(0, r2.length) === r2;
          }), i3 = 0; i3 < e2.length; i3++)
            delete this.files[e2[i3].name];
        return this;
      }, generate: function(t2) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(t2) {
        var e2, r2 = {};
        try {
          if ((r2 = u.extend(t2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n2.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), r2.type === "binarystring" && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), r2.platform !== "darwin" && r2.platform !== "freebsd" && r2.platform !== "linux" && r2.platform !== "sunos" || (r2.platform = "UNIX"), r2.platform === "win32" && (r2.platform = "DOS");
          var i3 = r2.comment || this.comment || "";
          e2 = o.generateWorker(this, r2, i3);
        } catch (t3) {
          (e2 = new l2("error")).error(t3);
        }
        return new a(e2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(t2, e2) {
        return this.generateInternalStream(t2).accumulate(e2);
      }, generateNodeStream: function(t2, e2) {
        return (t2 = t2 || {}).type || (t2.type = "nodebuffer"), this.generateInternalStream(t2).toNodejsStream(e2);
      } };
      e.exports = i2;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, e, r) {
      e.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, e, r) {
      var i2 = t("./DataReader");
      function n2(t2) {
        i2.call(this, t2);
        for (var e2 = 0; e2 < this.data.length; e2++)
          t2[e2] = 255 & t2[e2];
      }
      t("../utils").inherits(n2, i2), n2.prototype.byteAt = function(t2) {
        return this.data[this.zero + t2];
      }, n2.prototype.lastIndexOfSignature = function(t2) {
        for (var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i3 = t2.charCodeAt(2), n3 = t2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === e2 && this.data[s + 1] === r2 && this.data[s + 2] === i3 && this.data[s + 3] === n3)
            return s - this.zero;
        return -1;
      }, n2.prototype.readAndCheckSignature = function(t2) {
        var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i3 = t2.charCodeAt(2), n3 = t2.charCodeAt(3), s = this.readData(4);
        return e2 === s[0] && r2 === s[1] && i3 === s[2] && n3 === s[3];
      }, n2.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return [];
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n2;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, e, r) {
      var i2 = t("../utils");
      function n2(t2) {
        this.data = t2, this.length = t2.length, this.index = 0, this.zero = 0;
      }
      n2.prototype = { checkOffset: function(t2) {
        this.checkIndex(this.index + t2);
      }, checkIndex: function(t2) {
        if (this.length < this.zero + t2 || t2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t2 + "). Corrupted zip ?");
      }, setIndex: function(t2) {
        this.checkIndex(t2), this.index = t2;
      }, skip: function(t2) {
        this.setIndex(this.index + t2);
      }, byteAt: function(t2) {
      }, readInt: function(t2) {
        var e2, r2 = 0;
        for (this.checkOffset(t2), e2 = this.index + t2 - 1; e2 >= this.index; e2--)
          r2 = (r2 << 8) + this.byteAt(e2);
        return this.index += t2, r2;
      }, readString: function(t2) {
        return i2.transformTo("string", this.readData(t2));
      }, readData: function(t2) {
      }, lastIndexOfSignature: function(t2) {
      }, readAndCheckSignature: function(t2) {
      }, readDate: function() {
        var t2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (t2 >> 25 & 127), (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (31 & t2) << 1));
      } }, e.exports = n2;
    }, { "../utils": 32 }], 19: [function(t, e, r) {
      var i2 = t("./Uint8ArrayReader");
      function n2(t2) {
        i2.call(this, t2);
      }
      t("../utils").inherits(n2, i2), n2.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n2;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, e, r) {
      var i2 = t("./DataReader");
      function n2(t2) {
        i2.call(this, t2);
      }
      t("../utils").inherits(n2, i2), n2.prototype.byteAt = function(t2) {
        return this.data.charCodeAt(this.zero + t2);
      }, n2.prototype.lastIndexOfSignature = function(t2) {
        return this.data.lastIndexOf(t2) - this.zero;
      }, n2.prototype.readAndCheckSignature = function(t2) {
        return t2 === this.readData(4);
      }, n2.prototype.readData = function(t2) {
        this.checkOffset(t2);
        var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n2;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, e, r) {
      var i2 = t("./ArrayReader");
      function n2(t2) {
        i2.call(this, t2);
      }
      t("../utils").inherits(n2, i2), n2.prototype.readData = function(t2) {
        if (this.checkOffset(t2), t2 === 0)
          return new Uint8Array(0);
        var e2 = this.data.subarray(this.zero + this.index, this.zero + this.index + t2);
        return this.index += t2, e2;
      }, e.exports = n2;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, e, r) {
      var i2 = t("../utils"), n2 = t("../support"), s = t("./ArrayReader"), a = t("./StringReader"), o = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
      e.exports = function(t2) {
        var e2 = i2.getTypeOf(t2);
        return i2.checkSupport(e2), e2 !== "string" || n2.uint8array ? e2 === "nodebuffer" ? new o(t2) : n2.uint8array ? new h(i2.transformTo("uint8array", t2)) : new s(i2.transformTo("array", t2)) : new a(t2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, e, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, e, r) {
      var i2 = t("./GenericWorker"), n2 = t("../utils");
      function s(t2) {
        i2.call(this, "ConvertWorker to " + t2), this.destType = t2;
      }
      n2.inherits(s, i2), s.prototype.processChunk = function(t2) {
        this.push({ data: n2.transformTo(this.destType, t2.data), meta: t2.meta });
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, e, r) {
      var i2 = t("./GenericWorker"), n2 = t("../crc32");
      function s() {
        i2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(s, i2), s.prototype.processChunk = function(t2) {
        this.streamInfo.crc32 = n2(t2.data, this.streamInfo.crc32 || 0), this.push(t2);
      }, e.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, e, r) {
      var i2 = t("../utils"), n2 = t("./GenericWorker");
      function s(t2) {
        n2.call(this, "DataLengthProbe for " + t2), this.propName = t2, this.withStreamInfo(t2, 0);
      }
      i2.inherits(s, n2), s.prototype.processChunk = function(t2) {
        if (t2) {
          var e2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = e2 + t2.data.length;
        }
        n2.prototype.processChunk.call(this, t2);
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, e, r) {
      var i2 = t("../utils"), n2 = t("./GenericWorker");
      function s(t2) {
        n2.call(this, "DataWorker");
        var e2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, t2.then(function(t3) {
          e2.dataIsReady = true, e2.data = t3, e2.max = t3 && t3.length || 0, e2.type = i2.getTypeOf(t3), e2.isPaused || e2._tickAndRepeat();
        }, function(t3) {
          e2.error(t3);
        });
      }
      i2.inherits(s, n2), s.prototype.cleanUp = function() {
        n2.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!n2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, i2.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var t2 = null, e2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            t2 = this.data.substring(this.index, e2);
            break;
          case "uint8array":
            t2 = this.data.subarray(this.index, e2);
            break;
          case "array":
          case "nodebuffer":
            t2 = this.data.slice(this.index, e2);
        }
        return this.index = e2, this.push({ data: t2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, e.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, e, r) {
      function i2(t2) {
        this.name = t2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      i2.prototype = { push: function(t2) {
        this.emit("data", t2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (t2) {
          this.emit("error", t2);
        }
        return true;
      }, error: function(t2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = t2 : (this.isFinished = true, this.emit("error", t2), this.previous && this.previous.error(t2), this.cleanUp()), true);
      }, on: function(t2, e2) {
        return this._listeners[t2].push(e2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(t2, e2) {
        if (this._listeners[t2])
          for (var r2 = 0; r2 < this._listeners[t2].length; r2++)
            this._listeners[t2][r2].call(this, e2);
      }, pipe: function(t2) {
        return t2.registerPrevious(this);
      }, registerPrevious: function(t2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = t2.streamInfo, this.mergeStreamInfo(), this.previous = t2;
        var e2 = this;
        return t2.on("data", function(t3) {
          e2.processChunk(t3);
        }), t2.on("end", function() {
          e2.end();
        }), t2.on("error", function(t3) {
          e2.error(t3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var t2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), t2 = true), this.previous && this.previous.resume(), !t2;
      }, flush: function() {
      }, processChunk: function(t2) {
        this.push(t2);
      }, withStreamInfo: function(t2, e2) {
        return this.extraStreamInfo[t2] = e2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var t2 in this.extraStreamInfo)
          this.extraStreamInfo.hasOwnProperty(t2) && (this.streamInfo[t2] = this.extraStreamInfo[t2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var t2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + t2 : t2;
      } }, e.exports = i2;
    }, {}], 29: [function(t, e, r) {
      var h = t("../utils"), n2 = t("./ConvertWorker"), s = t("./GenericWorker"), u = t("../base64"), i2 = t("../support"), a = t("../external"), o = null;
      if (i2.nodestream)
        try {
          o = t("../nodejs/NodejsStreamOutputAdapter");
        } catch (t2) {
        }
      function l2(t2, o2) {
        return new a.Promise(function(e2, r2) {
          var i3 = [], n3 = t2._internalType, s2 = t2._outputType, a2 = t2._mimeType;
          t2.on("data", function(t3, e3) {
            i3.push(t3), o2 && o2(e3);
          }).on("error", function(t3) {
            i3 = [], r2(t3);
          }).on("end", function() {
            try {
              var t3 = function(t4, e3, r3) {
                switch (t4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", e3), r3);
                  case "base64":
                    return u.encode(e3);
                  default:
                    return h.transformTo(t4, e3);
                }
              }(s2, function(t4, e3) {
                var r3, i4 = 0, n4 = null, s3 = 0;
                for (r3 = 0; r3 < e3.length; r3++)
                  s3 += e3[r3].length;
                switch (t4) {
                  case "string":
                    return e3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], e3);
                  case "uint8array":
                    for (n4 = new Uint8Array(s3), r3 = 0; r3 < e3.length; r3++)
                      n4.set(e3[r3], i4), i4 += e3[r3].length;
                    return n4;
                  case "nodebuffer":
                    return Buffer.concat(e3);
                  default:
                    throw new Error("concat : unsupported type '" + t4 + "'");
                }
              }(n3, i3), a2);
              e2(t3);
            } catch (t4) {
              r2(t4);
            }
            i3 = [];
          }).resume();
        });
      }
      function f(t2, e2, r2) {
        var i3 = e2;
        switch (e2) {
          case "blob":
          case "arraybuffer":
            i3 = "uint8array";
            break;
          case "base64":
            i3 = "string";
        }
        try {
          this._internalType = i3, this._outputType = e2, this._mimeType = r2, h.checkSupport(i3), this._worker = t2.pipe(new n2(i3)), t2.lock();
        } catch (t3) {
          this._worker = new s("error"), this._worker.error(t3);
        }
      }
      f.prototype = { accumulate: function(t2) {
        return l2(this, t2);
      }, on: function(t2, e2) {
        var r2 = this;
        return t2 === "data" ? this._worker.on(t2, function(t3) {
          e2.call(r2, t3.data, t3.meta);
        }) : this._worker.on(t2, function() {
          h.delay(e2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(t2) {
        if (h.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: this._outputType !== "nodebuffer" }, t2);
      } }, e.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, e, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = typeof ArrayBuffer != "undefined" && typeof Uint8Array != "undefined", r.nodebuffer = typeof Buffer != "undefined", r.uint8array = typeof Uint8Array != "undefined", typeof ArrayBuffer == "undefined")
        r.blob = false;
      else {
        var i2 = new ArrayBuffer(0);
        try {
          r.blob = new Blob([i2], { type: "application/zip" }).size === 0;
        } catch (t2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            n2.append(i2), r.blob = n2.getBlob("application/zip").size === 0;
          } catch (t3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!t("readable-stream").Readable;
      } catch (t2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(t, e, s) {
      for (var o = t("./utils"), h = t("./support"), r = t("./nodejsUtils"), i2 = t("./stream/GenericWorker"), u = new Array(256), n2 = 0; n2 < 256; n2++)
        u[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        i2.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l2() {
        i2.call(this, "utf-8 encode");
      }
      s.utf8encode = function(t2) {
        return h.nodebuffer ? r.newBufferFrom(t2, "utf-8") : function(t3) {
          var e2, r2, i3, n3, s2, a2 = t3.length, o2 = 0;
          for (n3 = 0; n3 < a2; n3++)
            (64512 & (r2 = t3.charCodeAt(n3))) == 55296 && n3 + 1 < a2 && (64512 & (i3 = t3.charCodeAt(n3 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i3 - 56320), n3++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (e2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), n3 = s2 = 0; s2 < o2; n3++)
            (64512 & (r2 = t3.charCodeAt(n3))) == 55296 && n3 + 1 < a2 && (64512 & (i3 = t3.charCodeAt(n3 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i3 - 56320), n3++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
          return e2;
        }(t2);
      }, s.utf8decode = function(t2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", t2).toString("utf-8") : function(t3) {
          var e2, r2, i3, n3, s2 = t3.length, a2 = new Array(2 * s2);
          for (e2 = r2 = 0; e2 < s2; )
            if ((i3 = t3[e2++]) < 128)
              a2[r2++] = i3;
            else if (4 < (n3 = u[i3]))
              a2[r2++] = 65533, e2 += n3 - 1;
            else {
              for (i3 &= n3 === 2 ? 31 : n3 === 3 ? 15 : 7; 1 < n3 && e2 < s2; )
                i3 = i3 << 6 | 63 & t3[e2++], n3--;
              1 < n3 ? a2[r2++] = 65533 : i3 < 65536 ? a2[r2++] = i3 : (i3 -= 65536, a2[r2++] = 55296 | i3 >> 10 & 1023, a2[r2++] = 56320 | 1023 & i3);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(t2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2));
      }, o.inherits(a, i2), a.prototype.processChunk = function(t2) {
        var e2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = e2;
            (e2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), e2.set(r2, this.leftOver.length);
          } else
            e2 = this.leftOver.concat(e2);
          this.leftOver = null;
        }
        var i3 = function(t3, e3) {
          var r3;
          for ((e3 = e3 || t3.length) > t3.length && (e3 = t3.length), r3 = e3 - 1; 0 <= r3 && (192 & t3[r3]) == 128; )
            r3--;
          return r3 < 0 ? e3 : r3 === 0 ? e3 : r3 + u[t3[r3]] > e3 ? r3 : e3;
        }(e2), n3 = e2;
        i3 !== e2.length && (h.uint8array ? (n3 = e2.subarray(0, i3), this.leftOver = e2.subarray(i3, e2.length)) : (n3 = e2.slice(0, i3), this.leftOver = e2.slice(i3, e2.length))), this.push({ data: s.utf8decode(n3), meta: t2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l2, i2), l2.prototype.processChunk = function(t2) {
        this.push({ data: s.utf8encode(t2.data), meta: t2.meta });
      }, s.Utf8EncodeWorker = l2;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, e, a) {
      var o = t("./support"), h = t("./base64"), r = t("./nodejsUtils"), i2 = t("set-immediate-shim"), u = t("./external");
      function n2(t2) {
        return t2;
      }
      function l2(t2, e2) {
        for (var r2 = 0; r2 < t2.length; ++r2)
          e2[r2] = 255 & t2.charCodeAt(r2);
        return e2;
      }
      a.newBlob = function(e2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([e2], { type: r2 });
        } catch (t2) {
          try {
            var i3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return i3.append(e2), i3.getBlob(r2);
          } catch (t3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var s = { stringifyByChunk: function(t2, e2, r2) {
        var i3 = [], n3 = 0, s2 = t2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, t2);
        for (; n3 < s2; )
          e2 === "array" || e2 === "nodebuffer" ? i3.push(String.fromCharCode.apply(null, t2.slice(n3, Math.min(n3 + r2, s2)))) : i3.push(String.fromCharCode.apply(null, t2.subarray(n3, Math.min(n3 + r2, s2)))), n3 += r2;
        return i3.join("");
      }, stringifyByChar: function(t2) {
        for (var e2 = "", r2 = 0; r2 < t2.length; r2++)
          e2 += String.fromCharCode(t2[r2]);
        return e2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, r.allocBuffer(1)).length === 1;
        } catch (t2) {
          return false;
        }
      }() } };
      function f(t2) {
        var e2 = 65536, r2 = a.getTypeOf(t2), i3 = true;
        if (r2 === "uint8array" ? i3 = s.applyCanBeUsed.uint8array : r2 === "nodebuffer" && (i3 = s.applyCanBeUsed.nodebuffer), i3)
          for (; 1 < e2; )
            try {
              return s.stringifyByChunk(t2, r2, e2);
            } catch (t3) {
              e2 = Math.floor(e2 / 2);
            }
        return s.stringifyByChar(t2);
      }
      function d(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2[r2] = t2[r2];
        return e2;
      }
      a.applyFromCharCode = f;
      var c2 = {};
      c2.string = { string: n2, array: function(t2) {
        return l2(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return c2.string.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return l2(t2, new Uint8Array(t2.length));
      }, nodebuffer: function(t2) {
        return l2(t2, r.allocBuffer(t2.length));
      } }, c2.array = { string: f, array: n2, arraybuffer: function(t2) {
        return new Uint8Array(t2).buffer;
      }, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return r.newBufferFrom(t2);
      } }, c2.arraybuffer = { string: function(t2) {
        return f(new Uint8Array(t2));
      }, array: function(t2) {
        return d(new Uint8Array(t2), new Array(t2.byteLength));
      }, arraybuffer: n2, uint8array: function(t2) {
        return new Uint8Array(t2);
      }, nodebuffer: function(t2) {
        return r.newBufferFrom(new Uint8Array(t2));
      } }, c2.uint8array = { string: f, array: function(t2) {
        return d(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return t2.buffer;
      }, uint8array: n2, nodebuffer: function(t2) {
        return r.newBufferFrom(t2);
      } }, c2.nodebuffer = { string: f, array: function(t2) {
        return d(t2, new Array(t2.length));
      }, arraybuffer: function(t2) {
        return c2.nodebuffer.uint8array(t2).buffer;
      }, uint8array: function(t2) {
        return d(t2, new Uint8Array(t2.length));
      }, nodebuffer: n2 }, a.transformTo = function(t2, e2) {
        if (e2 = e2 || "", !t2)
          return e2;
        a.checkSupport(t2);
        var r2 = a.getTypeOf(e2);
        return c2[r2][t2](e2);
      }, a.getTypeOf = function(t2) {
        return typeof t2 == "string" ? "string" : Object.prototype.toString.call(t2) === "[object Array]" ? "array" : o.nodebuffer && r.isBuffer(t2) ? "nodebuffer" : o.uint8array && t2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && t2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(t2) {
        if (!o[t2.toLowerCase()])
          throw new Error(t2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(t2) {
        var e2, r2, i3 = "";
        for (r2 = 0; r2 < (t2 || "").length; r2++)
          i3 += "\\x" + ((e2 = t2.charCodeAt(r2)) < 16 ? "0" : "") + e2.toString(16).toUpperCase();
        return i3;
      }, a.delay = function(t2, e2, r2) {
        i2(function() {
          t2.apply(r2 || null, e2 || []);
        });
      }, a.inherits = function(t2, e2) {
        function r2() {
        }
        r2.prototype = e2.prototype, t2.prototype = new r2();
      }, a.extend = function() {
        var t2, e2, r2 = {};
        for (t2 = 0; t2 < arguments.length; t2++)
          for (e2 in arguments[t2])
            arguments[t2].hasOwnProperty(e2) && r2[e2] === void 0 && (r2[e2] = arguments[t2][e2]);
        return r2;
      }, a.prepareContent = function(r2, t2, i3, n3, s2) {
        return u.Promise.resolve(t2).then(function(i4) {
          return o.blob && (i4 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(i4)) !== -1) && typeof FileReader != "undefined" ? new u.Promise(function(e2, r3) {
            var t3 = new FileReader();
            t3.onload = function(t4) {
              e2(t4.target.result);
            }, t3.onerror = function(t4) {
              r3(t4.target.error);
            }, t3.readAsArrayBuffer(i4);
          }) : i4;
        }).then(function(t3) {
          var e2 = a.getTypeOf(t3);
          return e2 ? (e2 === "arraybuffer" ? t3 = a.transformTo("uint8array", t3) : e2 === "string" && (s2 ? t3 = h.decode(t3) : i3 && n3 !== true && (t3 = function(t4) {
            return l2(t4, o.uint8array ? new Uint8Array(t4.length) : new Array(t4.length));
          }(t3))), t3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(t, e, r) {
      var i2 = t("./reader/readerFor"), n2 = t("./utils"), s = t("./signature"), a = t("./zipEntry"), o = (t("./utf8"), t("./support"));
      function h(t2) {
        this.files = [], this.loadOptions = t2;
      }
      h.prototype = { checkSignature: function(t2) {
        if (!this.reader.readAndCheckSignature(t2)) {
          this.reader.index -= 4;
          var e2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + n2.pretty(e2) + ", expected " + n2.pretty(t2) + ")");
        }
      }, isSignature: function(t2, e2) {
        var r2 = this.reader.index;
        this.reader.setIndex(t2);
        var i3 = this.reader.readString(4) === e2;
        return this.reader.setIndex(r2), i3;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var t2 = this.reader.readData(this.zipCommentLength), e2 = o.uint8array ? "uint8array" : "array", r2 = n2.transformTo(e2, t2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var t2, e2, r2, i3 = this.zip64EndOfCentralSize - 44; 0 < i3; )
          t2 = this.reader.readInt(2), e2 = this.reader.readInt(4), r2 = this.reader.readData(e2), this.zip64ExtensibleData[t2] = { id: t2, length: e2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var t2, e2;
        for (t2 = 0; t2 < this.files.length; t2++)
          e2 = this.files[t2], this.reader.setIndex(e2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), e2.readLocalPart(this.reader), e2.handleUTF8(), e2.processAttributes();
      }, readCentralDir: function() {
        var t2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (t2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t2);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var t2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (t2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(t2);
        var e2 = t2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n2.MAX_VALUE_16BITS || this.centralDirRecords === n2.MAX_VALUE_16BITS || this.centralDirSize === n2.MAX_VALUE_32BITS || this.centralDirOffset === n2.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (t2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(t2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var i3 = e2 - r2;
        if (0 < i3)
          this.isSignature(e2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = i3);
        else if (i3 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(i3) + " bytes.");
      }, prepareReader: function(t2) {
        this.reader = i2(t2);
      }, load: function(t2) {
        this.prepareReader(t2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, e.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, e, r) {
      var i2 = t("./reader/readerFor"), s = t("./utils"), n2 = t("./compressedObject"), a = t("./crc32"), o = t("./utf8"), h = t("./compressions"), u = t("./support");
      function l2(t2, e2) {
        this.options = t2, this.loadOptions = e2;
      }
      l2.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(t2) {
        var e2, r2;
        if (t2.skip(22), this.fileNameLength = t2.readInt(2), r2 = t2.readInt(2), this.fileName = t2.readData(this.fileNameLength), t2.skip(r2), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((e2 = function(t3) {
          for (var e3 in h)
            if (h.hasOwnProperty(e3) && h[e3].magic === t3)
              return h[e3];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new n2(this.compressedSize, this.uncompressedSize, this.crc32, e2, t2.readData(this.compressedSize));
      }, readCentralPart: function(t2) {
        this.versionMadeBy = t2.readInt(2), t2.skip(2), this.bitFlag = t2.readInt(2), this.compressionMethod = t2.readString(2), this.date = t2.readDate(), this.crc32 = t2.readInt(4), this.compressedSize = t2.readInt(4), this.uncompressedSize = t2.readInt(4);
        var e2 = t2.readInt(2);
        if (this.extraFieldsLength = t2.readInt(2), this.fileCommentLength = t2.readInt(2), this.diskNumberStart = t2.readInt(2), this.internalFileAttributes = t2.readInt(2), this.externalFileAttributes = t2.readInt(4), this.localHeaderOffset = t2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        t2.skip(e2), this.readExtraFields(t2), this.parseZIP64ExtraField(t2), this.fileComment = t2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var t2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), t2 == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), t2 == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function(t2) {
        if (this.extraFields[1]) {
          var e2 = i2(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(t2) {
        var e2, r2, i3, n3 = t2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); t2.index + 4 < n3; )
          e2 = t2.readInt(2), r2 = t2.readInt(2), i3 = t2.readData(r2), this.extraFields[e2] = { id: e2, length: r2, value: i3 };
        t2.setIndex(n3);
      }, handleUTF8: function() {
        var t2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var e2 = this.findExtraFieldUnicodePath();
          if (e2 !== null)
            this.fileNameStr = e2;
          else {
            var r2 = s.transformTo(t2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var i3 = this.findExtraFieldUnicodeComment();
          if (i3 !== null)
            this.fileCommentStr = i3;
          else {
            var n3 = s.transformTo(t2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(n3);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var t2 = this.extraFields[28789];
        if (t2) {
          var e2 = i2(t2.value);
          return e2.readInt(1) !== 1 ? null : a(this.fileName) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var t2 = this.extraFields[25461];
        if (t2) {
          var e2 = i2(t2.value);
          return e2.readInt(1) !== 1 ? null : a(this.fileComment) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
        }
        return null;
      } }, e.exports = l2;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, e, r) {
      function i2(t2, e2, r2) {
        this.name = t2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = e2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = t("./stream/StreamHelper"), n2 = t("./stream/DataWorker"), a = t("./utf8"), o = t("./compressedObject"), h = t("./stream/GenericWorker");
      i2.prototype = { internalStream: function(t2) {
        var e2 = null, r2 = "string";
        try {
          if (!t2)
            throw new Error("No output type specified.");
          var i3 = (r2 = t2.toLowerCase()) === "string" || r2 === "text";
          r2 !== "binarystring" && r2 !== "text" || (r2 = "string"), e2 = this._decompressWorker();
          var n3 = !this._dataBinary;
          n3 && !i3 && (e2 = e2.pipe(new a.Utf8EncodeWorker())), !n3 && i3 && (e2 = e2.pipe(new a.Utf8DecodeWorker()));
        } catch (t3) {
          (e2 = new h("error")).error(t3);
        }
        return new s(e2, r2, "");
      }, async: function(t2, e2) {
        return this.internalStream(t2).accumulate(e2);
      }, nodeStream: function(t2, e2) {
        return this.internalStream(t2 || "nodebuffer").toNodejsStream(e2);
      }, _compressWorker: function(t2, e2) {
        if (this._data instanceof o && this._data.compression.magic === t2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, t2, e2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new n2(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        i2.prototype[u[f]] = l2;
      e.exports = i2;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, l2, e) {
      (function(e2) {
        var r, i2, t2 = e2.MutationObserver || e2.WebKitMutationObserver;
        if (t2) {
          var n2 = 0, s = new t2(u), a = e2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = n2 = ++n2 % 2;
          };
        } else if (e2.setImmediate || e2.MessageChannel === void 0)
          r = "document" in e2 && "onreadystatechange" in e2.document.createElement("script") ? function() {
            var t3 = e2.document.createElement("script");
            t3.onreadystatechange = function() {
              u(), t3.onreadystatechange = null, t3.parentNode.removeChild(t3), t3 = null;
            }, e2.document.documentElement.appendChild(t3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new e2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var t3, e3;
          i2 = true;
          for (var r2 = h.length; r2; ) {
            for (e3 = h, h = [], t3 = -1; ++t3 < r2; )
              e3[t3]();
            r2 = h.length;
          }
          i2 = false;
        }
        l2.exports = function(t3) {
          h.push(t3) !== 1 || i2 || r();
        };
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 37: [function(t, e, r) {
      var n2 = t("immediate");
      function u() {
      }
      var l2 = {}, s = ["REJECTED"], a = ["FULFILLED"], i2 = ["PENDING"];
      function o(t2) {
        if (typeof t2 != "function")
          throw new TypeError("resolver must be a function");
        this.state = i2, this.queue = [], this.outcome = void 0, t2 !== u && c2(this, t2);
      }
      function h(t2, e2, r2) {
        this.promise = t2, typeof e2 == "function" && (this.onFulfilled = e2, this.callFulfilled = this.otherCallFulfilled), typeof r2 == "function" && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(e2, r2, i3) {
        n2(function() {
          var t2;
          try {
            t2 = r2(i3);
          } catch (t3) {
            return l2.reject(e2, t3);
          }
          t2 === e2 ? l2.reject(e2, new TypeError("Cannot resolve promise with itself")) : l2.resolve(e2, t2);
        });
      }
      function d(t2) {
        var e2 = t2 && t2.then;
        if (t2 && (typeof t2 == "object" || typeof t2 == "function") && typeof e2 == "function")
          return function() {
            e2.apply(t2, arguments);
          };
      }
      function c2(e2, t2) {
        var r2 = false;
        function i3(t3) {
          r2 || (r2 = true, l2.reject(e2, t3));
        }
        function n3(t3) {
          r2 || (r2 = true, l2.resolve(e2, t3));
        }
        var s2 = p2(function() {
          t2(n3, i3);
        });
        s2.status === "error" && i3(s2.value);
      }
      function p2(t2, e2) {
        var r2 = {};
        try {
          r2.value = t2(e2), r2.status = "success";
        } catch (t3) {
          r2.status = "error", r2.value = t3;
        }
        return r2;
      }
      (e.exports = o).prototype.finally = function(e2) {
        if (typeof e2 != "function")
          return this;
        var r2 = this.constructor;
        return this.then(function(t2) {
          return r2.resolve(e2()).then(function() {
            return t2;
          });
        }, function(t2) {
          return r2.resolve(e2()).then(function() {
            throw t2;
          });
        });
      }, o.prototype.catch = function(t2) {
        return this.then(null, t2);
      }, o.prototype.then = function(t2, e2) {
        if (typeof t2 != "function" && this.state === a || typeof e2 != "function" && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== i2 ? f(r2, this.state === a ? t2 : e2, this.outcome) : this.queue.push(new h(r2, t2, e2));
        return r2;
      }, h.prototype.callFulfilled = function(t2) {
        l2.resolve(this.promise, t2);
      }, h.prototype.otherCallFulfilled = function(t2) {
        f(this.promise, this.onFulfilled, t2);
      }, h.prototype.callRejected = function(t2) {
        l2.reject(this.promise, t2);
      }, h.prototype.otherCallRejected = function(t2) {
        f(this.promise, this.onRejected, t2);
      }, l2.resolve = function(t2, e2) {
        var r2 = p2(d, e2);
        if (r2.status === "error")
          return l2.reject(t2, r2.value);
        var i3 = r2.value;
        if (i3)
          c2(t2, i3);
        else {
          t2.state = a, t2.outcome = e2;
          for (var n3 = -1, s2 = t2.queue.length; ++n3 < s2; )
            t2.queue[n3].callFulfilled(e2);
        }
        return t2;
      }, l2.reject = function(t2, e2) {
        t2.state = s, t2.outcome = e2;
        for (var r2 = -1, i3 = t2.queue.length; ++r2 < i3; )
          t2.queue[r2].callRejected(e2);
        return t2;
      }, o.resolve = function(t2) {
        if (t2 instanceof this)
          return t2;
        return l2.resolve(new this(u), t2);
      }, o.reject = function(t2) {
        var e2 = new this(u);
        return l2.reject(e2, t2);
      }, o.all = function(t2) {
        var r2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var i3 = t2.length, n3 = false;
        if (!i3)
          return this.resolve([]);
        var s2 = new Array(i3), a2 = 0, e2 = -1, o2 = new this(u);
        for (; ++e2 < i3; )
          h2(t2[e2], e2);
        return o2;
        function h2(t3, e3) {
          r2.resolve(t3).then(function(t4) {
            s2[e3] = t4, ++a2 !== i3 || n3 || (n3 = true, l2.resolve(o2, s2));
          }, function(t4) {
            n3 || (n3 = true, l2.reject(o2, t4));
          });
        }
      }, o.race = function(t2) {
        var e2 = this;
        if (Object.prototype.toString.call(t2) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var r2 = t2.length, i3 = false;
        if (!r2)
          return this.resolve([]);
        var n3 = -1, s2 = new this(u);
        for (; ++n3 < r2; )
          a2 = t2[n3], e2.resolve(a2).then(function(t3) {
            i3 || (i3 = true, l2.resolve(s2, t3));
          }, function(t3) {
            i3 || (i3 = true, l2.reject(s2, t3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(t, e, r) {
      var i2 = {};
      (0, t("./lib/utils/common").assign)(i2, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i2;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, e, r) {
      var a = t("./zlib/deflate"), o = t("./utils/common"), h = t("./utils/strings"), n2 = t("./zlib/messages"), s = t("./zlib/zstream"), u = Object.prototype.toString, l2 = 0, f = -1, d = 0, c2 = 8;
      function p2(t2) {
        if (!(this instanceof p2))
          return new p2(t2);
        this.options = o.assign({ level: f, method: c2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && 0 < e2.windowBits ? e2.windowBits = -e2.windowBits : e2.gzip && 0 < e2.windowBits && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
        if (r2 !== l2)
          throw new Error(n2[r2]);
        if (e2.header && a.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
          var i3;
          if (i3 = typeof e2.dictionary == "string" ? h.string2buf(e2.dictionary) : u.call(e2.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = a.deflateSetDictionary(this.strm, i3)) !== l2)
            throw new Error(n2[r2]);
          this._dict_set = true;
        }
      }
      function i2(t2, e2) {
        var r2 = new p2(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || n2[r2.err];
        return r2.result;
      }
      p2.prototype.push = function(t2, e2) {
        var r2, i3, n3 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        i3 = e2 === ~~e2 ? e2 : e2 === true ? 4 : 0, typeof t2 == "string" ? n3.input = h.string2buf(t2) : u.call(t2) === "[object ArrayBuffer]" ? n3.input = new Uint8Array(t2) : n3.input = t2, n3.next_in = 0, n3.avail_in = n3.input.length;
        do {
          if (n3.avail_out === 0 && (n3.output = new o.Buf8(s2), n3.next_out = 0, n3.avail_out = s2), (r2 = a.deflate(n3, i3)) !== 1 && r2 !== l2)
            return this.onEnd(r2), !(this.ended = true);
          n3.avail_out !== 0 && (n3.avail_in !== 0 || i3 !== 4 && i3 !== 2) || (this.options.to === "string" ? this.onData(h.buf2binstring(o.shrinkBuf(n3.output, n3.next_out))) : this.onData(o.shrinkBuf(n3.output, n3.next_out)));
        } while ((0 < n3.avail_in || n3.avail_out === 0) && r2 !== 1);
        return i3 === 4 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l2) : i3 !== 2 || (this.onEnd(l2), !(n3.avail_out = 0));
      }, p2.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, p2.prototype.onEnd = function(t2) {
        t2 === l2 && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Deflate = p2, r.deflate = i2, r.deflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, i2(t2, e2);
      }, r.gzip = function(t2, e2) {
        return (e2 = e2 || {}).gzip = true, i2(t2, e2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, e, r) {
      var d = t("./zlib/inflate"), c2 = t("./utils/common"), p2 = t("./utils/strings"), m = t("./zlib/constants"), i2 = t("./zlib/messages"), n2 = t("./zlib/zstream"), s = t("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(t2) {
        if (!(this instanceof a))
          return new a(t2);
        this.options = c2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
        var e2 = this.options;
        e2.raw && 0 <= e2.windowBits && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, e2.windowBits === 0 && (e2.windowBits = -15)), !(0 <= e2.windowBits && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), 15 < e2.windowBits && e2.windowBits < 48 && (15 & e2.windowBits) == 0 && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n2(), this.strm.avail_out = 0;
        var r2 = d.inflateInit2(this.strm, e2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(i2[r2]);
        this.header = new s(), d.inflateGetHeader(this.strm, this.header);
      }
      function o(t2, e2) {
        var r2 = new a(e2);
        if (r2.push(t2, true), r2.err)
          throw r2.msg || i2[r2.err];
        return r2.result;
      }
      a.prototype.push = function(t2, e2) {
        var r2, i3, n3, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l2 = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        i3 = e2 === ~~e2 ? e2 : e2 === true ? m.Z_FINISH : m.Z_NO_FLUSH, typeof t2 == "string" ? h.input = p2.binstring2buf(t2) : _.call(t2) === "[object ArrayBuffer]" ? h.input = new Uint8Array(t2) : h.input = t2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (h.avail_out === 0 && (h.output = new c2.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = d.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l2 && (o2 = typeof l2 == "string" ? p2.string2buf(l2) : _.call(l2) === "[object ArrayBuffer]" ? new Uint8Array(l2) : l2, r2 = d.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && f === true && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (h.avail_out !== 0 && r2 !== m.Z_STREAM_END && (h.avail_in !== 0 || i3 !== m.Z_FINISH && i3 !== m.Z_SYNC_FLUSH) || (this.options.to === "string" ? (n3 = p2.utf8border(h.output, h.next_out), s2 = h.next_out - n3, a2 = p2.buf2string(h.output, n3), h.next_out = s2, h.avail_out = u - s2, s2 && c2.arraySet(h.output, h.output, n3, s2, 0), this.onData(a2)) : this.onData(c2.shrinkBuf(h.output, h.next_out)))), h.avail_in === 0 && h.avail_out === 0 && (f = true);
        } while ((0 < h.avail_in || h.avail_out === 0) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (i3 = m.Z_FINISH), i3 === m.Z_FINISH ? (r2 = d.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : i3 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(t2) {
        this.chunks.push(t2);
      }, a.prototype.onEnd = function(t2) {
        t2 === m.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = c2.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(t2, e2) {
        return (e2 = e2 || {}).raw = true, o(t2, e2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, e, r) {
      var i2 = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      r.assign = function(t2) {
        for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
          var r2 = e2.shift();
          if (r2) {
            if (typeof r2 != "object")
              throw new TypeError(r2 + "must be non-object");
            for (var i3 in r2)
              r2.hasOwnProperty(i3) && (t2[i3] = r2[i3]);
          }
        }
        return t2;
      }, r.shrinkBuf = function(t2, e2) {
        return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
      };
      var n2 = { arraySet: function(t2, e2, r2, i3, n3) {
        if (e2.subarray && t2.subarray)
          t2.set(e2.subarray(r2, r2 + i3), n3);
        else
          for (var s2 = 0; s2 < i3; s2++)
            t2[n3 + s2] = e2[r2 + s2];
      }, flattenChunks: function(t2) {
        var e2, r2, i3, n3, s2, a;
        for (e2 = i3 = 0, r2 = t2.length; e2 < r2; e2++)
          i3 += t2[e2].length;
        for (a = new Uint8Array(i3), e2 = n3 = 0, r2 = t2.length; e2 < r2; e2++)
          s2 = t2[e2], a.set(s2, n3), n3 += s2.length;
        return a;
      } }, s = { arraySet: function(t2, e2, r2, i3, n3) {
        for (var s2 = 0; s2 < i3; s2++)
          t2[n3 + s2] = e2[r2 + s2];
      }, flattenChunks: function(t2) {
        return [].concat.apply([], t2);
      } };
      r.setTyped = function(t2) {
        t2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n2)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(i2);
    }, {}], 42: [function(t, e, r) {
      var h = t("./common"), n2 = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (t2) {
        n2 = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (t2) {
        s = false;
      }
      for (var u = new h.Buf8(256), i2 = 0; i2 < 256; i2++)
        u[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
      function l2(t2, e2) {
        if (e2 < 65537 && (t2.subarray && s || !t2.subarray && n2))
          return String.fromCharCode.apply(null, h.shrinkBuf(t2, e2));
        for (var r2 = "", i3 = 0; i3 < e2; i3++)
          r2 += String.fromCharCode(t2[i3]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(t2) {
        var e2, r2, i3, n3, s2, a = t2.length, o = 0;
        for (n3 = 0; n3 < a; n3++)
          (64512 & (r2 = t2.charCodeAt(n3))) == 55296 && n3 + 1 < a && (64512 & (i3 = t2.charCodeAt(n3 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i3 - 56320), n3++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (e2 = new h.Buf8(o), n3 = s2 = 0; s2 < o; n3++)
          (64512 & (r2 = t2.charCodeAt(n3))) == 55296 && n3 + 1 < a && (64512 & (i3 = t2.charCodeAt(n3 + 1))) == 56320 && (r2 = 65536 + (r2 - 55296 << 10) + (i3 - 56320), n3++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
        return e2;
      }, r.buf2binstring = function(t2) {
        return l2(t2, t2.length);
      }, r.binstring2buf = function(t2) {
        for (var e2 = new h.Buf8(t2.length), r2 = 0, i3 = e2.length; r2 < i3; r2++)
          e2[r2] = t2.charCodeAt(r2);
        return e2;
      }, r.buf2string = function(t2, e2) {
        var r2, i3, n3, s2, a = e2 || t2.length, o = new Array(2 * a);
        for (r2 = i3 = 0; r2 < a; )
          if ((n3 = t2[r2++]) < 128)
            o[i3++] = n3;
          else if (4 < (s2 = u[n3]))
            o[i3++] = 65533, r2 += s2 - 1;
          else {
            for (n3 &= s2 === 2 ? 31 : s2 === 3 ? 15 : 7; 1 < s2 && r2 < a; )
              n3 = n3 << 6 | 63 & t2[r2++], s2--;
            1 < s2 ? o[i3++] = 65533 : n3 < 65536 ? o[i3++] = n3 : (n3 -= 65536, o[i3++] = 55296 | n3 >> 10 & 1023, o[i3++] = 56320 | 1023 & n3);
          }
        return l2(o, i3);
      }, r.utf8border = function(t2, e2) {
        var r2;
        for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; 0 <= r2 && (192 & t2[r2]) == 128; )
          r2--;
        return r2 < 0 ? e2 : r2 === 0 ? e2 : r2 + u[t2[r2]] > e2 ? r2 : e2;
      };
    }, { "./common": 41 }], 43: [function(t, e, r) {
      e.exports = function(t2, e2, r2, i2) {
        for (var n2 = 65535 & t2 | 0, s = t2 >>> 16 & 65535 | 0, a = 0; r2 !== 0; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (n2 = n2 + e2[i2++] | 0) | 0, --a; )
            ;
          n2 %= 65521, s %= 65521;
        }
        return n2 | s << 16 | 0;
      };
    }, {}], 44: [function(t, e, r) {
      e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, e, r) {
      var o = function() {
        for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
          t2 = r2;
          for (var i2 = 0; i2 < 8; i2++)
            t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
          e2[r2] = t2;
        }
        return e2;
      }();
      e.exports = function(t2, e2, r2, i2) {
        var n2 = o, s = i2 + r2;
        t2 ^= -1;
        for (var a = i2; a < s; a++)
          t2 = t2 >>> 8 ^ n2[255 & (t2 ^ e2[a])];
        return -1 ^ t2;
      };
    }, {}], 46: [function(t, e, r) {
      var h, d = t("../utils/common"), u = t("./trees"), c2 = t("./adler32"), p2 = t("./crc32"), i2 = t("./messages"), l2 = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, n2 = 2, v = 8, y2 = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k2 = 15, x2 = 3, S = 258, z2 = S + x2 + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
      function R(t2, e2) {
        return t2.msg = i2[e2], e2;
      }
      function T(t2) {
        return (t2 << 1) - (4 < t2 ? 9 : 0);
      }
      function D(t2) {
        for (var e2 = t2.length; 0 <= --e2; )
          t2[e2] = 0;
      }
      function F2(t2) {
        var e2 = t2.state, r2 = e2.pending;
        r2 > t2.avail_out && (r2 = t2.avail_out), r2 !== 0 && (d.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, e2.pending === 0 && (e2.pending_out = 0));
      }
      function N(t2, e2) {
        u._tr_flush_block(t2, 0 <= t2.block_start ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, F2(t2.strm);
      }
      function U(t2, e2) {
        t2.pending_buf[t2.pending++] = e2;
      }
      function P(t2, e2) {
        t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
      }
      function L(t2, e2) {
        var r2, i3, n3 = t2.max_chain_length, s2 = t2.strstart, a2 = t2.prev_length, o2 = t2.nice_match, h2 = t2.strstart > t2.w_size - z2 ? t2.strstart - (t2.w_size - z2) : 0, u2 = t2.window, l3 = t2.w_mask, f2 = t2.prev, d2 = t2.strstart + S, c3 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
        t2.prev_length >= t2.good_match && (n3 >>= 2), o2 > t2.lookahead && (o2 = t2.lookahead);
        do {
          if (u2[(r2 = e2) + a2] === p3 && u2[r2 + a2 - 1] === c3 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < d2);
            if (i3 = S - (d2 - s2), s2 = d2 - S, a2 < i3) {
              if (t2.match_start = e2, o2 <= (a2 = i3))
                break;
              c3 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
            }
          }
        } while ((e2 = f2[e2 & l3]) > h2 && --n3 != 0);
        return a2 <= t2.lookahead ? a2 : t2.lookahead;
      }
      function j2(t2) {
        var e2, r2, i3, n3, s2, a2, o2, h2, u2, l3, f2 = t2.w_size;
        do {
          if (n3 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= f2 + (f2 - z2)) {
            for (d.arraySet(t2.window, t2.window, f2, f2, 0), t2.match_start -= f2, t2.strstart -= f2, t2.block_start -= f2, e2 = r2 = t2.hash_size; i3 = t2.head[--e2], t2.head[e2] = f2 <= i3 ? i3 - f2 : 0, --r2; )
              ;
            for (e2 = r2 = f2; i3 = t2.prev[--e2], t2.prev[e2] = f2 <= i3 ? i3 - f2 : 0, --r2; )
              ;
            n3 += f2;
          }
          if (t2.strm.avail_in === 0)
            break;
          if (a2 = t2.strm, o2 = t2.window, h2 = t2.strstart + t2.lookahead, u2 = n3, l3 = void 0, l3 = a2.avail_in, u2 < l3 && (l3 = u2), r2 = l3 === 0 ? 0 : (a2.avail_in -= l3, d.arraySet(o2, a2.input, a2.next_in, l3, h2), a2.state.wrap === 1 ? a2.adler = c2(a2.adler, o2, l3, h2) : a2.state.wrap === 2 && (a2.adler = p2(a2.adler, o2, l3, h2)), a2.next_in += l3, a2.total_in += l3, l3), t2.lookahead += r2, t2.lookahead + t2.insert >= x2)
            for (s2 = t2.strstart - t2.insert, t2.ins_h = t2.window[s2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + x2 - 1]) & t2.hash_mask, t2.prev[s2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = s2, s2++, t2.insert--, !(t2.lookahead + t2.insert < x2)); )
              ;
        } while (t2.lookahead < z2 && t2.strm.avail_in !== 0);
      }
      function Z(t2, e2) {
        for (var r2, i3; ; ) {
          if (t2.lookahead < z2) {
            if (j2(t2), t2.lookahead < z2 && e2 === l2)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= x2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x2 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), r2 !== 0 && t2.strstart - r2 <= t2.w_size - z2 && (t2.match_length = L(t2, r2)), t2.match_length >= x2)
            if (i3 = u._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - x2), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= x2) {
              for (t2.match_length--; t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x2 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart, --t2.match_length != 0; )
                ;
              t2.strstart++;
            } else
              t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
          else
            i3 = u._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
          if (i3 && (N(t2, false), t2.strm.avail_out === 0))
            return A;
        }
        return t2.insert = t2.strstart < x2 - 1 ? t2.strstart : x2 - 1, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : t2.last_lit && (N(t2, false), t2.strm.avail_out === 0) ? A : I;
      }
      function W(t2, e2) {
        for (var r2, i3, n3; ; ) {
          if (t2.lookahead < z2) {
            if (j2(t2), t2.lookahead < z2 && e2 === l2)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          if (r2 = 0, t2.lookahead >= x2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x2 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = x2 - 1, r2 !== 0 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - z2 && (t2.match_length = L(t2, r2), t2.match_length <= 5 && (t2.strategy === 1 || t2.match_length === x2 && 4096 < t2.strstart - t2.match_start) && (t2.match_length = x2 - 1)), t2.prev_length >= x2 && t2.match_length <= t2.prev_length) {
            for (n3 = t2.strstart + t2.lookahead - x2, i3 = u._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - x2), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2; ++t2.strstart <= n3 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x2 - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), --t2.prev_length != 0; )
              ;
            if (t2.match_available = 0, t2.match_length = x2 - 1, t2.strstart++, i3 && (N(t2, false), t2.strm.avail_out === 0))
              return A;
          } else if (t2.match_available) {
            if ((i3 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && N(t2, false), t2.strstart++, t2.lookahead--, t2.strm.avail_out === 0)
              return A;
          } else
            t2.match_available = 1, t2.strstart++, t2.lookahead--;
        }
        return t2.match_available && (i3 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < x2 - 1 ? t2.strstart : x2 - 1, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : t2.last_lit && (N(t2, false), t2.strm.avail_out === 0) ? A : I;
      }
      function M(t2, e2, r2, i3, n3) {
        this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = i3, this.func = n3;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * w), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(k2 + 1), this.heap = new d.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(t2) {
        var e2;
        return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = n2, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? C : E, t2.adler = e2.wrap === 2 ? 0 : 1, e2.last_flush = l2, u._tr_init(e2), m) : R(t2, _);
      }
      function K(t2) {
        var e2 = G(t2);
        return e2 === m && function(t3) {
          t3.window_size = 2 * t3.w_size, D(t3.head), t3.max_lazy_match = h[t3.level].max_lazy, t3.good_match = h[t3.level].good_length, t3.nice_match = h[t3.level].nice_length, t3.max_chain_length = h[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = x2 - 1, t3.match_available = 0, t3.ins_h = 0;
        }(t2.state), e2;
      }
      function Y(t2, e2, r2, i3, n3, s2) {
        if (!t2)
          return _;
        var a2 = 1;
        if (e2 === g && (e2 = 6), i3 < 0 ? (a2 = 0, i3 = -i3) : 15 < i3 && (a2 = 2, i3 -= 16), n3 < 1 || y2 < n3 || r2 !== v || i3 < 8 || 15 < i3 || e2 < 0 || 9 < e2 || s2 < 0 || b < s2)
          return R(t2, _);
        i3 === 8 && (i3 = 9);
        var o2 = new H();
        return (t2.state = o2).strm = t2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = i3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n3 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x2 - 1) / x2), o2.window = new d.Buf8(2 * o2.w_size), o2.head = new d.Buf16(o2.hash_size), o2.prev = new d.Buf16(o2.w_size), o2.lit_bufsize = 1 << n3 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new d.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = e2, o2.strategy = s2, o2.method = r2, K(t2);
      }
      h = [new M(0, 0, 0, 0, function(t2, e2) {
        var r2 = 65535;
        for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
          if (t2.lookahead <= 1) {
            if (j2(t2), t2.lookahead === 0 && e2 === l2)
              return A;
            if (t2.lookahead === 0)
              break;
          }
          t2.strstart += t2.lookahead, t2.lookahead = 0;
          var i3 = t2.block_start + r2;
          if ((t2.strstart === 0 || t2.strstart >= i3) && (t2.lookahead = t2.strstart - i3, t2.strstart = i3, N(t2, false), t2.strm.avail_out === 0))
            return A;
          if (t2.strstart - t2.block_start >= t2.w_size - z2 && (N(t2, false), t2.strm.avail_out === 0))
            return A;
        }
        return t2.insert = 0, e2 === f ? (N(t2, true), t2.strm.avail_out === 0 ? O : B) : (t2.strstart > t2.block_start && (N(t2, false), t2.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(t2, e2) {
        return Y(t2, e2, v, 15, 8, 0);
      }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(t2, e2) {
        return t2 && t2.state ? t2.state.wrap !== 2 ? _ : (t2.state.gzhead = e2, m) : _;
      }, r.deflate = function(t2, e2) {
        var r2, i3, n3, s2;
        if (!t2 || !t2.state || 5 < e2 || e2 < 0)
          return t2 ? R(t2, _) : _;
        if (i3 = t2.state, !t2.output || !t2.input && t2.avail_in !== 0 || i3.status === 666 && e2 !== f)
          return R(t2, t2.avail_out === 0 ? -5 : _);
        if (i3.strm = t2, r2 = i3.last_flush, i3.last_flush = e2, i3.status === C)
          if (i3.wrap === 2)
            t2.adler = 0, U(i3, 31), U(i3, 139), U(i3, 8), i3.gzhead ? (U(i3, (i3.gzhead.text ? 1 : 0) + (i3.gzhead.hcrc ? 2 : 0) + (i3.gzhead.extra ? 4 : 0) + (i3.gzhead.name ? 8 : 0) + (i3.gzhead.comment ? 16 : 0)), U(i3, 255 & i3.gzhead.time), U(i3, i3.gzhead.time >> 8 & 255), U(i3, i3.gzhead.time >> 16 & 255), U(i3, i3.gzhead.time >> 24 & 255), U(i3, i3.level === 9 ? 2 : 2 <= i3.strategy || i3.level < 2 ? 4 : 0), U(i3, 255 & i3.gzhead.os), i3.gzhead.extra && i3.gzhead.extra.length && (U(i3, 255 & i3.gzhead.extra.length), U(i3, i3.gzhead.extra.length >> 8 & 255)), i3.gzhead.hcrc && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending, 0)), i3.gzindex = 0, i3.status = 69) : (U(i3, 0), U(i3, 0), U(i3, 0), U(i3, 0), U(i3, 0), U(i3, i3.level === 9 ? 2 : 2 <= i3.strategy || i3.level < 2 ? 4 : 0), U(i3, 3), i3.status = E);
          else {
            var a2 = v + (i3.w_bits - 8 << 4) << 8;
            a2 |= (2 <= i3.strategy || i3.level < 2 ? 0 : i3.level < 6 ? 1 : i3.level === 6 ? 2 : 3) << 6, i3.strstart !== 0 && (a2 |= 32), a2 += 31 - a2 % 31, i3.status = E, P(i3, a2), i3.strstart !== 0 && (P(i3, t2.adler >>> 16), P(i3, 65535 & t2.adler)), t2.adler = 1;
          }
        if (i3.status === 69)
          if (i3.gzhead.extra) {
            for (n3 = i3.pending; i3.gzindex < (65535 & i3.gzhead.extra.length) && (i3.pending !== i3.pending_buf_size || (i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), F2(t2), n3 = i3.pending, i3.pending !== i3.pending_buf_size)); )
              U(i3, 255 & i3.gzhead.extra[i3.gzindex]), i3.gzindex++;
            i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), i3.gzindex === i3.gzhead.extra.length && (i3.gzindex = 0, i3.status = 73);
          } else
            i3.status = 73;
        if (i3.status === 73)
          if (i3.gzhead.name) {
            n3 = i3.pending;
            do {
              if (i3.pending === i3.pending_buf_size && (i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), F2(t2), n3 = i3.pending, i3.pending === i3.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = i3.gzindex < i3.gzhead.name.length ? 255 & i3.gzhead.name.charCodeAt(i3.gzindex++) : 0, U(i3, s2);
            } while (s2 !== 0);
            i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), s2 === 0 && (i3.gzindex = 0, i3.status = 91);
          } else
            i3.status = 91;
        if (i3.status === 91)
          if (i3.gzhead.comment) {
            n3 = i3.pending;
            do {
              if (i3.pending === i3.pending_buf_size && (i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), F2(t2), n3 = i3.pending, i3.pending === i3.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = i3.gzindex < i3.gzhead.comment.length ? 255 & i3.gzhead.comment.charCodeAt(i3.gzindex++) : 0, U(i3, s2);
            } while (s2 !== 0);
            i3.gzhead.hcrc && i3.pending > n3 && (t2.adler = p2(t2.adler, i3.pending_buf, i3.pending - n3, n3)), s2 === 0 && (i3.status = 103);
          } else
            i3.status = 103;
        if (i3.status === 103 && (i3.gzhead.hcrc ? (i3.pending + 2 > i3.pending_buf_size && F2(t2), i3.pending + 2 <= i3.pending_buf_size && (U(i3, 255 & t2.adler), U(i3, t2.adler >> 8 & 255), t2.adler = 0, i3.status = E)) : i3.status = E), i3.pending !== 0) {
          if (F2(t2), t2.avail_out === 0)
            return i3.last_flush = -1, m;
        } else if (t2.avail_in === 0 && T(e2) <= T(r2) && e2 !== f)
          return R(t2, -5);
        if (i3.status === 666 && t2.avail_in !== 0)
          return R(t2, -5);
        if (t2.avail_in !== 0 || i3.lookahead !== 0 || e2 !== l2 && i3.status !== 666) {
          var o2 = i3.strategy === 2 ? function(t3, e3) {
            for (var r3; ; ) {
              if (t3.lookahead === 0 && (j2(t3), t3.lookahead === 0)) {
                if (e3 === l2)
                  return A;
                break;
              }
              if (t3.match_length = 0, r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (N(t3, false), t3.strm.avail_out === 0))
                return A;
            }
            return t3.insert = 0, e3 === f ? (N(t3, true), t3.strm.avail_out === 0 ? O : B) : t3.last_lit && (N(t3, false), t3.strm.avail_out === 0) ? A : I;
          }(i3, e2) : i3.strategy === 3 ? function(t3, e3) {
            for (var r3, i4, n4, s3, a3 = t3.window; ; ) {
              if (t3.lookahead <= S) {
                if (j2(t3), t3.lookahead <= S && e3 === l2)
                  return A;
                if (t3.lookahead === 0)
                  break;
              }
              if (t3.match_length = 0, t3.lookahead >= x2 && 0 < t3.strstart && (i4 = a3[n4 = t3.strstart - 1]) === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4]) {
                s3 = t3.strstart + S;
                do {
                } while (i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && i4 === a3[++n4] && n4 < s3);
                t3.match_length = S - (s3 - n4), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
              }
              if (t3.match_length >= x2 ? (r3 = u._tr_tally(t3, 1, t3.match_length - x2), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (N(t3, false), t3.strm.avail_out === 0))
                return A;
            }
            return t3.insert = 0, e3 === f ? (N(t3, true), t3.strm.avail_out === 0 ? O : B) : t3.last_lit && (N(t3, false), t3.strm.avail_out === 0) ? A : I;
          }(i3, e2) : h[i3.level].func(i3, e2);
          if (o2 !== O && o2 !== B || (i3.status = 666), o2 === A || o2 === O)
            return t2.avail_out === 0 && (i3.last_flush = -1), m;
          if (o2 === I && (e2 === 1 ? u._tr_align(i3) : e2 !== 5 && (u._tr_stored_block(i3, 0, 0, false), e2 === 3 && (D(i3.head), i3.lookahead === 0 && (i3.strstart = 0, i3.block_start = 0, i3.insert = 0))), F2(t2), t2.avail_out === 0))
            return i3.last_flush = -1, m;
        }
        return e2 !== f ? m : i3.wrap <= 0 ? 1 : (i3.wrap === 2 ? (U(i3, 255 & t2.adler), U(i3, t2.adler >> 8 & 255), U(i3, t2.adler >> 16 & 255), U(i3, t2.adler >> 24 & 255), U(i3, 255 & t2.total_in), U(i3, t2.total_in >> 8 & 255), U(i3, t2.total_in >> 16 & 255), U(i3, t2.total_in >> 24 & 255)) : (P(i3, t2.adler >>> 16), P(i3, 65535 & t2.adler)), F2(t2), 0 < i3.wrap && (i3.wrap = -i3.wrap), i3.pending !== 0 ? m : 1);
      }, r.deflateEnd = function(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state.status) !== C && e2 !== 69 && e2 !== 73 && e2 !== 91 && e2 !== 103 && e2 !== E && e2 !== 666 ? R(t2, _) : (t2.state = null, e2 === E ? R(t2, -3) : m) : _;
      }, r.deflateSetDictionary = function(t2, e2) {
        var r2, i3, n3, s2, a2, o2, h2, u2, l3 = e2.length;
        if (!t2 || !t2.state)
          return _;
        if ((s2 = (r2 = t2.state).wrap) === 2 || s2 === 1 && r2.status !== C || r2.lookahead)
          return _;
        for (s2 === 1 && (t2.adler = c2(t2.adler, e2, l3, 0)), r2.wrap = 0, l3 >= r2.w_size && (s2 === 0 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new d.Buf8(r2.w_size), d.arraySet(u2, e2, l3 - r2.w_size, r2.w_size, 0), e2 = u2, l3 = r2.w_size), a2 = t2.avail_in, o2 = t2.next_in, h2 = t2.input, t2.avail_in = l3, t2.next_in = 0, t2.input = e2, j2(r2); r2.lookahead >= x2; ) {
          for (i3 = r2.strstart, n3 = r2.lookahead - (x2 - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[i3 + x2 - 1]) & r2.hash_mask, r2.prev[i3 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = i3, i3++, --n3; )
            ;
          r2.strstart = i3, r2.lookahead = x2 - 1, j2(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x2 - 1, r2.match_available = 0, t2.next_in = o2, t2.input = h2, t2.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, e, r) {
      e.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(t, e, r) {
      e.exports = function(t2, e2) {
        var r2, i2, n2, s, a, o, h, u, l2, f, d, c2, p2, m, _, g, b, v, y2, w, k2, x2, S, z2, C;
        r2 = t2.state, i2 = t2.next_in, z2 = t2.input, n2 = i2 + (t2.avail_in - 5), s = t2.next_out, C = t2.output, a = s - (e2 - t2.avail_out), o = s + (t2.avail_out - 257), h = r2.dmax, u = r2.wsize, l2 = r2.whave, f = r2.wnext, d = r2.window, c2 = r2.hold, p2 = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        t:
          do {
            p2 < 15 && (c2 += z2[i2++] << p2, p2 += 8, c2 += z2[i2++] << p2, p2 += 8), v = m[c2 & g];
            e:
              for (; ; ) {
                if (c2 >>>= y2 = v >>> 24, p2 -= y2, (y2 = v >>> 16 & 255) === 0)
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y2)) {
                    if ((64 & y2) == 0) {
                      v = m[(65535 & v) + (c2 & (1 << y2) - 1)];
                      continue e;
                    }
                    if (32 & y2) {
                      r2.mode = 12;
                      break t;
                    }
                    t2.msg = "invalid literal/length code", r2.mode = 30;
                    break t;
                  }
                  w = 65535 & v, (y2 &= 15) && (p2 < y2 && (c2 += z2[i2++] << p2, p2 += 8), w += c2 & (1 << y2) - 1, c2 >>>= y2, p2 -= y2), p2 < 15 && (c2 += z2[i2++] << p2, p2 += 8, c2 += z2[i2++] << p2, p2 += 8), v = _[c2 & b];
                  r:
                    for (; ; ) {
                      if (c2 >>>= y2 = v >>> 24, p2 -= y2, !(16 & (y2 = v >>> 16 & 255))) {
                        if ((64 & y2) == 0) {
                          v = _[(65535 & v) + (c2 & (1 << y2) - 1)];
                          continue r;
                        }
                        t2.msg = "invalid distance code", r2.mode = 30;
                        break t;
                      }
                      if (k2 = 65535 & v, p2 < (y2 &= 15) && (c2 += z2[i2++] << p2, (p2 += 8) < y2 && (c2 += z2[i2++] << p2, p2 += 8)), h < (k2 += c2 & (1 << y2) - 1)) {
                        t2.msg = "invalid distance too far back", r2.mode = 30;
                        break t;
                      }
                      if (c2 >>>= y2, p2 -= y2, (y2 = s - a) < k2) {
                        if (l2 < (y2 = k2 - y2) && r2.sane) {
                          t2.msg = "invalid distance too far back", r2.mode = 30;
                          break t;
                        }
                        if (S = d, (x2 = 0) === f) {
                          if (x2 += u - y2, y2 < w) {
                            for (w -= y2; C[s++] = d[x2++], --y2; )
                              ;
                            x2 = s - k2, S = C;
                          }
                        } else if (f < y2) {
                          if (x2 += u + f - y2, (y2 -= f) < w) {
                            for (w -= y2; C[s++] = d[x2++], --y2; )
                              ;
                            if (x2 = 0, f < w) {
                              for (w -= y2 = f; C[s++] = d[x2++], --y2; )
                                ;
                              x2 = s - k2, S = C;
                            }
                          }
                        } else if (x2 += f - y2, y2 < w) {
                          for (w -= y2; C[s++] = d[x2++], --y2; )
                            ;
                          x2 = s - k2, S = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S[x2++], C[s++] = S[x2++], C[s++] = S[x2++], w -= 3;
                        w && (C[s++] = S[x2++], 1 < w && (C[s++] = S[x2++]));
                      } else {
                        for (x2 = s - k2; C[s++] = C[x2++], C[s++] = C[x2++], C[s++] = C[x2++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x2++], 1 < w && (C[s++] = C[x2++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (i2 < n2 && s < o);
        i2 -= w = p2 >> 3, c2 &= (1 << (p2 -= w << 3)) - 1, t2.next_in = i2, t2.next_out = s, t2.avail_in = i2 < n2 ? n2 - i2 + 5 : 5 - (i2 - n2), t2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = c2, r2.bits = p2;
      };
    }, {}], 49: [function(t, e, r) {
      var I = t("../utils/common"), O = t("./adler32"), B = t("./crc32"), R = t("./inffast"), T = t("./inftrees"), D = 1, F2 = 2, N = 0, U = -2, P = 1, i2 = 852, n2 = 592;
      function L(t2) {
        return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(t2) {
        var e2;
        return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = P, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new I.Buf32(i2), e2.distcode = e2.distdyn = new I.Buf32(n2), e2.sane = 1, e2.back = -1, N) : U;
      }
      function o(t2) {
        var e2;
        return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, a(t2)) : U;
      }
      function h(t2, e2) {
        var r2, i3;
        return t2 && t2.state ? (i3 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || 15 < e2) ? U : (i3.window !== null && i3.wbits !== e2 && (i3.window = null), i3.wrap = r2, i3.wbits = e2, o(t2))) : U;
      }
      function u(t2, e2) {
        var r2, i3;
        return t2 ? (i3 = new s(), (t2.state = i3).window = null, (r2 = h(t2, e2)) !== N && (t2.state = null), r2) : U;
      }
      var l2, f, d = true;
      function j2(t2) {
        if (d) {
          var e2;
          for (l2 = new I.Buf32(512), f = new I.Buf32(32), e2 = 0; e2 < 144; )
            t2.lens[e2++] = 8;
          for (; e2 < 256; )
            t2.lens[e2++] = 9;
          for (; e2 < 280; )
            t2.lens[e2++] = 7;
          for (; e2 < 288; )
            t2.lens[e2++] = 8;
          for (T(D, t2.lens, 0, 288, l2, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; )
            t2.lens[e2++] = 5;
          T(F2, t2.lens, 0, 32, f, 0, t2.work, { bits: 5 }), d = false;
        }
        t2.lencode = l2, t2.lenbits = 9, t2.distcode = f, t2.distbits = 5;
      }
      function Z(t2, e2, r2, i3) {
        var n3, s2 = t2.state;
        return s2.window === null && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), i3 >= s2.wsize ? (I.arraySet(s2.window, e2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (i3 < (n3 = s2.wsize - s2.wnext) && (n3 = i3), I.arraySet(s2.window, e2, r2 - i3, n3, s2.wnext), (i3 -= n3) ? (I.arraySet(s2.window, e2, r2 - i3, i3, 0), s2.wnext = i3, s2.whave = s2.wsize) : (s2.wnext += n3, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += n3))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(t2) {
        return u(t2, 15);
      }, r.inflateInit2 = u, r.inflate = function(t2, e2) {
        var r2, i3, n3, s2, a2, o2, h2, u2, l3, f2, d2, c2, p2, m, _, g, b, v, y2, w, k2, x2, S, z2, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!t2 || !t2.state || !t2.output || !t2.input && t2.avail_in !== 0)
          return U;
        (r2 = t2.state).mode === 12 && (r2.mode = 13), a2 = t2.next_out, n3 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i3 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l3 = r2.bits, f2 = o2, d2 = h2, x2 = N;
        t:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (r2.wrap === 0) {
                  r2.mode = 13;
                  break;
                }
                for (; l3 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if (2 & r2.wrap && u2 === 35615) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l3 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  t2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if ((15 & u2) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l3 -= 4, k2 = 8 + (15 & (u2 >>>= 4)), r2.wbits === 0)
                  r2.wbits = k2;
                else if (k2 > r2.wbits) {
                  t2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k2, t2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l3 = u2 = 0;
                break;
              case 2:
                for (; l3 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if (r2.flags = u2, (255 & r2.flags) != 8) {
                  t2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  t2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l3 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l3 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l3 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l3 < 16; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l3 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l3 < 16; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l3 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (c2 = r2.length) && (c2 = o2), c2 && (r2.head && (k2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, i3, s2, c2, k2)), 512 & r2.flags && (r2.check = B(r2.check, i3, c2, s2)), o2 -= c2, s2 += c2, r2.length -= c2), r2.length))
                  break t;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (o2 === 0)
                    break t;
                  for (c2 = 0; k2 = i3[s2 + c2++], r2.head && k2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(k2)), k2 && c2 < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i3, c2, s2)), o2 -= c2, s2 += c2, k2)
                    break t;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (o2 === 0)
                    break t;
                  for (c2 = 0; k2 = i3[s2 + c2++], r2.head && k2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k2)), k2 && c2 < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, i3, c2, s2)), o2 -= c2, s2 += c2, k2)
                    break t;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l3 < 16; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    t2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l3 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                t2.adler = r2.check = L(u2), l3 = u2 = 0, r2.mode = 11;
              case 11:
                if (r2.havedict === 0)
                  return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l3, 2;
                t2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (e2 === 5 || e2 === 6)
                  break t;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l3, l3 -= 7 & l3, r2.mode = 27;
                  break;
                }
                for (; l3 < 3; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                switch (r2.last = 1 & u2, l3 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j2(r2), r2.mode = 20, e2 !== 6)
                      break;
                    u2 >>>= 2, l3 -= 2;
                    break t;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    t2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l3 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  t2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l3 = u2 = 0, r2.mode = 15, e2 === 6)
                  break t;
              case 15:
                r2.mode = 16;
              case 16:
                if (c2 = r2.length) {
                  if (o2 < c2 && (c2 = o2), h2 < c2 && (c2 = h2), c2 === 0)
                    break t;
                  I.arraySet(n3, i3, s2, c2, a2), o2 -= c2, s2 += c2, h2 -= c2, a2 += c2, r2.length -= c2;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l3 < 14; ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l3 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l3 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l3 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  t2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l3 < 3; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l3 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x2 = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x2) {
                  t2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l3); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l3 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (b === 16) {
                      for (z2 = _ + 2; l3 < z2; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i3[s2++] << l3, l3 += 8;
                      }
                      if (u2 >>>= _, l3 -= _, r2.have === 0) {
                        t2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k2 = r2.lens[r2.have - 1], c2 = 3 + (3 & u2), u2 >>>= 2, l3 -= 2;
                    } else if (b === 17) {
                      for (z2 = _ + 3; l3 < z2; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i3[s2++] << l3, l3 += 8;
                      }
                      l3 -= _, k2 = 0, c2 = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l3 -= 3;
                    } else {
                      for (z2 = _ + 7; l3 < z2; ) {
                        if (o2 === 0)
                          break t;
                        o2--, u2 += i3[s2++] << l3, l3 += 8;
                      }
                      l3 -= _, k2 = 0, c2 = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l3 -= 7;
                    }
                    if (r2.have + c2 > r2.nlen + r2.ndist) {
                      t2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; c2--; )
                      r2.lens[r2.have++] = k2;
                  }
                }
                if (r2.mode === 30)
                  break;
                if (r2.lens[256] === 0) {
                  t2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x2 = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x2) {
                  t2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x2 = T(F2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x2) {
                  t2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, e2 === 6)
                  break t;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l3, R(t2, d2), a2 = t2.next_out, n3 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i3 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l3 = r2.bits, r2.mode === 12 && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l3); ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if (g && (240 & g) == 0) {
                  for (v = _, y2 = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l3); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  u2 >>>= v, l3 -= v, r2.back += v;
                }
                if (u2 >>>= _, l3 -= _, r2.back += _, r2.length = b, g === 0) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  t2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z2 = r2.extra; l3 < z2; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l3 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l3); ) {
                  if (o2 === 0)
                    break t;
                  o2--, u2 += i3[s2++] << l3, l3 += 8;
                }
                if ((240 & g) == 0) {
                  for (v = _, y2 = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y2) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l3); ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  u2 >>>= v, l3 -= v, r2.back += v;
                }
                if (u2 >>>= _, l3 -= _, r2.back += _, 64 & g) {
                  t2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z2 = r2.extra; l3 < z2; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l3 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  t2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (h2 === 0)
                  break t;
                if (c2 = d2 - h2, r2.offset > c2) {
                  if ((c2 = r2.offset - c2) > r2.whave && r2.sane) {
                    t2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p2 = c2 > r2.wnext ? (c2 -= r2.wnext, r2.wsize - c2) : r2.wnext - c2, c2 > r2.length && (c2 = r2.length), m = r2.window;
                } else
                  m = n3, p2 = a2 - r2.offset, c2 = r2.length;
                for (h2 < c2 && (c2 = h2), h2 -= c2, r2.length -= c2; n3[a2++] = m[p2++], --c2; )
                  ;
                r2.length === 0 && (r2.mode = 21);
                break;
              case 26:
                if (h2 === 0)
                  break t;
                n3[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l3 < 32; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 |= i3[s2++] << l3, l3 += 8;
                  }
                  if (d2 -= h2, t2.total_out += d2, r2.total += d2, d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n3, d2, a2 - d2) : O(r2.check, n3, d2, a2 - d2)), d2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    t2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l3 < 32; ) {
                    if (o2 === 0)
                      break t;
                    o2--, u2 += i3[s2++] << l3, l3 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    t2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x2 = 1;
                break t;
              case 30:
                x2 = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l3, (r2.wsize || d2 !== t2.avail_out && r2.mode < 30 && (r2.mode < 27 || e2 !== 4)) && Z(t2, t2.output, t2.next_out, d2 - t2.avail_out) ? (r2.mode = 31, -4) : (f2 -= t2.avail_in, d2 -= t2.avail_out, t2.total_in += f2, t2.total_out += d2, r2.total += d2, r2.wrap && d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n3, d2, t2.next_out - d2) : O(r2.check, n3, d2, t2.next_out - d2)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 == 0 && d2 === 0 || e2 === 4) && x2 === N && (x2 = -5), x2);
      }, r.inflateEnd = function(t2) {
        if (!t2 || !t2.state)
          return U;
        var e2 = t2.state;
        return e2.window && (e2.window = null), t2.state = null, N;
      }, r.inflateGetHeader = function(t2, e2) {
        var r2;
        return t2 && t2.state ? (2 & (r2 = t2.state).wrap) == 0 ? U : ((r2.head = e2).done = false, N) : U;
      }, r.inflateSetDictionary = function(t2, e2) {
        var r2, i3 = e2.length;
        return t2 && t2.state ? (r2 = t2.state).wrap !== 0 && r2.mode !== 11 ? U : r2.mode === 11 && O(1, e2, i3, 0) !== r2.check ? -3 : Z(t2, e2, i3, i3) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, e, r) {
      var D = t("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      e.exports = function(t2, e2, r2, i2, n2, s, a, o) {
        var h, u, l2, f, d, c2, p2, m, _, g = o.bits, b = 0, v = 0, y2 = 0, w = 0, k2 = 0, x2 = 0, S = 0, z2 = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < i2; v++)
          O[e2[r2 + v]]++;
        for (k2 = g, w = 15; 1 <= w && O[w] === 0; w--)
          ;
        if (w < k2 && (k2 = w), w === 0)
          return n2[s++] = 20971520, n2[s++] = 20971520, o.bits = 1, 0;
        for (y2 = 1; y2 < w && O[y2] === 0; y2++)
          ;
        for (k2 < y2 && (k2 = y2), b = z2 = 1; b <= 15; b++)
          if (z2 <<= 1, (z2 -= O[b]) < 0)
            return -1;
        if (0 < z2 && (t2 === 0 || w !== 1))
          return -1;
        for (B[1] = 0, b = 1; b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0; v < i2; v++)
          e2[r2 + v] !== 0 && (a[B[e2[r2 + v]]++] = v);
        if (c2 = t2 === 0 ? (A = R = a, 19) : t2 === 1 ? (A = F2, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y2, d = s, S = v = E = 0, l2 = -1, f = (C = 1 << (x2 = k2)) - 1, t2 === 1 && 852 < C || t2 === 2 && 592 < C)
          return 1;
        for (; ; ) {
          for (p2 = b - S, _ = a[v] < c2 ? (m = 0, a[v]) : a[v] > c2 ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y2 = u = 1 << x2; n2[d + (E >> S) + (u -= h)] = p2 << 24 | m << 16 | _ | 0, u !== 0; )
            ;
          for (h = 1 << b - 1; E & h; )
            h >>= 1;
          if (h !== 0 ? (E &= h - 1, E += h) : E = 0, v++, --O[b] == 0) {
            if (b === w)
              break;
            b = e2[r2 + a[v]];
          }
          if (k2 < b && (E & f) !== l2) {
            for (S === 0 && (S = k2), d += y2, z2 = 1 << (x2 = b - S); x2 + S < w && !((z2 -= O[x2 + S]) <= 0); )
              x2++, z2 <<= 1;
            if (C += 1 << x2, t2 === 1 && 852 < C || t2 === 2 && 592 < C)
              return 1;
            n2[l2 = E & f] = k2 << 24 | x2 << 16 | d - s | 0;
          }
        }
        return E !== 0 && (n2[d + E] = b - S << 24 | 64 << 16 | 0), o.bits = k2, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, e, r) {
      e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, e, r) {
      var n2 = t("../utils/common"), o = 0, h = 1;
      function i2(t2) {
        for (var e2 = t2.length; 0 <= --e2; )
          t2[e2] = 0;
      }
      var s = 0, a = 29, u = 256, l2 = u + 1 + a, f = 30, d = 19, _ = 2 * l2 + 1, g = 15, c2 = 16, p2 = 7, m = 256, b = 16, v = 17, y2 = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l2 + 2));
      i2(z2);
      var C = new Array(2 * f);
      i2(C);
      var E = new Array(512);
      i2(E);
      var A = new Array(256);
      i2(A);
      var I = new Array(a);
      i2(I);
      var O, B, R, T = new Array(f);
      function D(t2, e2, r2, i3, n3) {
        this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = i3, this.max_length = n3, this.has_stree = t2 && t2.length;
      }
      function F2(t2, e2) {
        this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
      }
      function N(t2) {
        return t2 < 256 ? E[t2] : E[256 + (t2 >>> 7)];
      }
      function U(t2, e2) {
        t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
      }
      function P(t2, e2, r2) {
        t2.bi_valid > c2 - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, U(t2, t2.bi_buf), t2.bi_buf = e2 >> c2 - t2.bi_valid, t2.bi_valid += r2 - c2) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
      }
      function L(t2, e2, r2) {
        P(t2, r2[2 * e2], r2[2 * e2 + 1]);
      }
      function j2(t2, e2) {
        for (var r2 = 0; r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1, 0 < --e2; )
          ;
        return r2 >>> 1;
      }
      function Z(t2, e2, r2) {
        var i3, n3, s2 = new Array(g + 1), a2 = 0;
        for (i3 = 1; i3 <= g; i3++)
          s2[i3] = a2 = a2 + r2[i3 - 1] << 1;
        for (n3 = 0; n3 <= e2; n3++) {
          var o2 = t2[2 * n3 + 1];
          o2 !== 0 && (t2[2 * n3] = j2(s2[o2]++, o2));
        }
      }
      function W(t2) {
        var e2;
        for (e2 = 0; e2 < l2; e2++)
          t2.dyn_ltree[2 * e2] = 0;
        for (e2 = 0; e2 < f; e2++)
          t2.dyn_dtree[2 * e2] = 0;
        for (e2 = 0; e2 < d; e2++)
          t2.bl_tree[2 * e2] = 0;
        t2.dyn_ltree[2 * m] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
      }
      function M(t2) {
        8 < t2.bi_valid ? U(t2, t2.bi_buf) : 0 < t2.bi_valid && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
      }
      function H(t2, e2, r2, i3) {
        var n3 = 2 * e2, s2 = 2 * r2;
        return t2[n3] < t2[s2] || t2[n3] === t2[s2] && i3[e2] <= i3[r2];
      }
      function G(t2, e2, r2) {
        for (var i3 = t2.heap[r2], n3 = r2 << 1; n3 <= t2.heap_len && (n3 < t2.heap_len && H(e2, t2.heap[n3 + 1], t2.heap[n3], t2.depth) && n3++, !H(e2, i3, t2.heap[n3], t2.depth)); )
          t2.heap[r2] = t2.heap[n3], r2 = n3, n3 <<= 1;
        t2.heap[r2] = i3;
      }
      function K(t2, e2, r2) {
        var i3, n3, s2, a2, o2 = 0;
        if (t2.last_lit !== 0)
          for (; i3 = t2.pending_buf[t2.d_buf + 2 * o2] << 8 | t2.pending_buf[t2.d_buf + 2 * o2 + 1], n3 = t2.pending_buf[t2.l_buf + o2], o2++, i3 === 0 ? L(t2, n3, e2) : (L(t2, (s2 = A[n3]) + u + 1, e2), (a2 = w[s2]) !== 0 && P(t2, n3 -= I[s2], a2), L(t2, s2 = N(--i3), r2), (a2 = k2[s2]) !== 0 && P(t2, i3 -= T[s2], a2)), o2 < t2.last_lit; )
            ;
        L(t2, m, e2);
      }
      function Y(t2, e2) {
        var r2, i3, n3, s2 = e2.dyn_tree, a2 = e2.stat_desc.static_tree, o2 = e2.stat_desc.has_stree, h2 = e2.stat_desc.elems, u2 = -1;
        for (t2.heap_len = 0, t2.heap_max = _, r2 = 0; r2 < h2; r2++)
          s2[2 * r2] !== 0 ? (t2.heap[++t2.heap_len] = u2 = r2, t2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; t2.heap_len < 2; )
          s2[2 * (n3 = t2.heap[++t2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, t2.depth[n3] = 0, t2.opt_len--, o2 && (t2.static_len -= a2[2 * n3 + 1]);
        for (e2.max_code = u2, r2 = t2.heap_len >> 1; 1 <= r2; r2--)
          G(t2, s2, r2);
        for (n3 = h2; r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], G(t2, s2, 1), i3 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = i3, s2[2 * n3] = s2[2 * r2] + s2[2 * i3], t2.depth[n3] = (t2.depth[r2] >= t2.depth[i3] ? t2.depth[r2] : t2.depth[i3]) + 1, s2[2 * r2 + 1] = s2[2 * i3 + 1] = n3, t2.heap[1] = n3++, G(t2, s2, 1), 2 <= t2.heap_len; )
          ;
        t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
          var r3, i4, n4, s3, a3, o3, h3 = e3.dyn_tree, u3 = e3.max_code, l3 = e3.stat_desc.static_tree, f2 = e3.stat_desc.has_stree, d2 = e3.stat_desc.extra_bits, c3 = e3.stat_desc.extra_base, p3 = e3.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            t3.bl_count[s3] = 0;
          for (h3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < _; r3++)
            p3 < (s3 = h3[2 * h3[2 * (i4 = t3.heap[r3]) + 1] + 1] + 1) && (s3 = p3, m2++), h3[2 * i4 + 1] = s3, u3 < i4 || (t3.bl_count[s3]++, a3 = 0, c3 <= i4 && (a3 = d2[i4 - c3]), o3 = h3[2 * i4], t3.opt_len += o3 * (s3 + a3), f2 && (t3.static_len += o3 * (l3[2 * i4 + 1] + a3)));
          if (m2 !== 0) {
            do {
              for (s3 = p3 - 1; t3.bl_count[s3] === 0; )
                s3--;
              t3.bl_count[s3]--, t3.bl_count[s3 + 1] += 2, t3.bl_count[p3]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p3; s3 !== 0; s3--)
              for (i4 = t3.bl_count[s3]; i4 !== 0; )
                u3 < (n4 = t3.heap[--r3]) || (h3[2 * n4 + 1] !== s3 && (t3.opt_len += (s3 - h3[2 * n4 + 1]) * h3[2 * n4], h3[2 * n4 + 1] = s3), i4--);
          }
        }(t2, e2), Z(s2, u2, t2.bl_count);
      }
      function X(t2, e2, r2) {
        var i3, n3, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), e2[2 * (r2 + 1) + 1] = 65535, i3 = 0; i3 <= r2; i3++)
          n3 = a2, a2 = e2[2 * (i3 + 1) + 1], ++o2 < h2 && n3 === a2 || (o2 < u2 ? t2.bl_tree[2 * n3] += o2 : n3 !== 0 ? (n3 !== s2 && t2.bl_tree[2 * n3]++, t2.bl_tree[2 * b]++) : o2 <= 10 ? t2.bl_tree[2 * v]++ : t2.bl_tree[2 * y2]++, s2 = n3, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n3 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V(t2, e2, r2) {
        var i3, n3, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
        for (a2 === 0 && (h2 = 138, u2 = 3), i3 = 0; i3 <= r2; i3++)
          if (n3 = a2, a2 = e2[2 * (i3 + 1) + 1], !(++o2 < h2 && n3 === a2)) {
            if (o2 < u2)
              for (; L(t2, n3, t2.bl_tree), --o2 != 0; )
                ;
            else
              n3 !== 0 ? (n3 !== s2 && (L(t2, n3, t2.bl_tree), o2--), L(t2, b, t2.bl_tree), P(t2, o2 - 3, 2)) : o2 <= 10 ? (L(t2, v, t2.bl_tree), P(t2, o2 - 3, 3)) : (L(t2, y2, t2.bl_tree), P(t2, o2 - 11, 7));
            s2 = n3, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n3 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      i2(T);
      var q = false;
      function J(t2, e2, r2, i3) {
        P(t2, (s << 1) + (i3 ? 1 : 0), 3), function(t3, e3, r3, i4) {
          M(t3), i4 && (U(t3, r3), U(t3, ~r3)), n2.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
        }(t2, e2, r2, true);
      }
      r._tr_init = function(t2) {
        q || (function() {
          var t3, e2, r2, i3, n3, s2 = new Array(g + 1);
          for (i3 = r2 = 0; i3 < a - 1; i3++)
            for (I[i3] = r2, t3 = 0; t3 < 1 << w[i3]; t3++)
              A[r2++] = i3;
          for (A[r2 - 1] = i3, i3 = n3 = 0; i3 < 16; i3++)
            for (T[i3] = n3, t3 = 0; t3 < 1 << k2[i3]; t3++)
              E[n3++] = i3;
          for (n3 >>= 7; i3 < f; i3++)
            for (T[i3] = n3 << 7, t3 = 0; t3 < 1 << k2[i3] - 7; t3++)
              E[256 + n3++] = i3;
          for (e2 = 0; e2 <= g; e2++)
            s2[e2] = 0;
          for (t3 = 0; t3 <= 143; )
            z2[2 * t3 + 1] = 8, t3++, s2[8]++;
          for (; t3 <= 255; )
            z2[2 * t3 + 1] = 9, t3++, s2[9]++;
          for (; t3 <= 279; )
            z2[2 * t3 + 1] = 7, t3++, s2[7]++;
          for (; t3 <= 287; )
            z2[2 * t3 + 1] = 8, t3++, s2[8]++;
          for (Z(z2, l2 + 1, s2), t3 = 0; t3 < f; t3++)
            C[2 * t3 + 1] = 5, C[2 * t3] = j2(t3, 5);
          O = new D(z2, w, u + 1, l2, g), B = new D(C, k2, 0, f, g), R = new D(new Array(0), x2, 0, d, p2);
        }(), q = true), t2.l_desc = new F2(t2.dyn_ltree, O), t2.d_desc = new F2(t2.dyn_dtree, B), t2.bl_desc = new F2(t2.bl_tree, R), t2.bi_buf = 0, t2.bi_valid = 0, W(t2);
      }, r._tr_stored_block = J, r._tr_flush_block = function(t2, e2, r2, i3) {
        var n3, s2, a2 = 0;
        0 < t2.level ? (t2.strm.data_type === 2 && (t2.strm.data_type = function(t3) {
          var e3, r3 = 4093624447;
          for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1)
            if (1 & r3 && t3.dyn_ltree[2 * e3] !== 0)
              return o;
          if (t3.dyn_ltree[18] !== 0 || t3.dyn_ltree[20] !== 0 || t3.dyn_ltree[26] !== 0)
            return h;
          for (e3 = 32; e3 < u; e3++)
            if (t3.dyn_ltree[2 * e3] !== 0)
              return h;
          return o;
        }(t2)), Y(t2, t2.l_desc), Y(t2, t2.d_desc), a2 = function(t3) {
          var e3;
          for (X(t3, t3.dyn_ltree, t3.l_desc.max_code), X(t3, t3.dyn_dtree, t3.d_desc.max_code), Y(t3, t3.bl_desc), e3 = d - 1; 3 <= e3 && t3.bl_tree[2 * S[e3] + 1] === 0; e3--)
            ;
          return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
        }(t2), n3 = t2.opt_len + 3 + 7 >>> 3, (s2 = t2.static_len + 3 + 7 >>> 3) <= n3 && (n3 = s2)) : n3 = s2 = r2 + 5, r2 + 4 <= n3 && e2 !== -1 ? J(t2, e2, r2, i3) : t2.strategy === 4 || s2 === n3 ? (P(t2, 2 + (i3 ? 1 : 0), 3), K(t2, z2, C)) : (P(t2, 4 + (i3 ? 1 : 0), 3), function(t3, e3, r3, i4) {
          var n4;
          for (P(t3, e3 - 257, 5), P(t3, r3 - 1, 5), P(t3, i4 - 4, 4), n4 = 0; n4 < i4; n4++)
            P(t3, t3.bl_tree[2 * S[n4] + 1], 3);
          V(t3, t3.dyn_ltree, e3 - 1), V(t3, t3.dyn_dtree, r3 - 1);
        }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, a2 + 1), K(t2, t2.dyn_ltree, t2.dyn_dtree)), W(t2), i3 && M(t2);
      }, r._tr_tally = function(t2, e2, r2) {
        return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, e2 === 0 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (A[r2] + u + 1)]++, t2.dyn_dtree[2 * N(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
      }, r._tr_align = function(t2) {
        P(t2, 2, 3), L(t2, m, z2), function(t3) {
          t3.bi_valid === 16 ? (U(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : 8 <= t3.bi_valid && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
        }(t2);
      };
    }, { "../utils/common": 41 }], 53: [function(t, e, r) {
      e.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, e, r) {
      e.exports = typeof setImmediate == "function" ? setImmediate : function() {
        var t2 = [].slice.apply(arguments);
        t2.splice(1, 0, 0), setTimeout.apply(null, t2);
      };
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var JSZip = jszip_min.exports;
const zipAndSaveProject = async (files) => {
  const zip2 = new JSZip();
  for (const file in files) {
    zip2.file(file, files[file]);
  }
  const data = await zip2.generateAsync({ type: "blob" });
  FileSaver.saveAs(data, "Sources.zip");
};
var util$2 = {};
var isBufferBrowser = function isBuffer2(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {
    };
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
(function(exports2) {
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f) {
    if (!isString2(f)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect2(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args2 = arguments;
    var len = args2.length;
    var str2 = String(f).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len)
        return x3;
      switch (x3) {
        case "%s":
          return String(args2[i2++]);
        case "%d":
          return Number(args2[i2++]);
        case "%j":
          try {
            return JSON.stringify(args2[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args2[i2]; i2 < len; x2 = args2[++i2]) {
      if (isNull2(x2) || !isObject2(x2)) {
        str2 += " " + x2;
      } else {
        str2 += " " + inspect2(x2);
      }
    }
    return str2;
  };
  exports2.deprecate = function(fn2, msg) {
    if (isUndefined(commonjsGlobal.process)) {
      return function() {
        return exports2.deprecate(fn2, msg).apply(this, arguments);
      };
    }
    if (process.noDeprecation === true) {
      return fn2;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn2.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnviron;
  exports2.debuglog = function(set2) {
    if (isUndefined(debugEnviron))
      debugEnviron = {}.NODE_DEBUG || "";
    set2 = set2.toUpperCase();
    if (!debugs[set2]) {
      if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
        var pid = process.pid;
        debugs[set2] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set2, pid, msg);
        };
      } else {
        debugs[set2] = function() {
        };
      }
    }
    return debugs[set2];
  };
  function inspect2(obj2, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue2(ctx, obj2, ctx.depth);
  }
  exports2.inspect = inspect2;
  inspect2.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect2.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    "regexp": "red"
  };
  function stylizeWithColor(str2, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str2 + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str2;
    }
  }
  function stylizeNoColor(str2, styleType) {
    return str2;
  }
  function arrayToHash(array) {
    var hash2 = {};
    array.forEach(function(val, idx) {
      hash2[val] = true;
    });
    return hash2;
  }
  function formatValue2(ctx, value2, recurseTimes) {
    if (ctx.customInspect && value2 && isFunction2(value2.inspect) && value2.inspect !== exports2.inspect && !(value2.constructor && value2.constructor.prototype === value2)) {
      var ret = value2.inspect(recurseTimes, ctx);
      if (!isString2(ret)) {
        ret = formatValue2(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value2);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value2);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value2);
    }
    if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError2(value2);
    }
    if (keys2.length === 0) {
      if (isFunction2(value2)) {
        var name = value2.name ? ": " + value2.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      }
      if (isDate(value2)) {
        return ctx.stylize(Date.prototype.toString.call(value2), "date");
      }
      if (isError(value2)) {
        return formatError2(value2);
      }
    }
    var base = "", array = false, braces2 = ["{", "}"];
    if (isArray2(value2)) {
      array = true;
      braces2 = ["[", "]"];
    }
    if (isFunction2(value2)) {
      var n2 = value2.name ? ": " + value2.name : "";
      base = " [Function" + n2 + "]";
    }
    if (isRegExp(value2)) {
      base = " " + RegExp.prototype.toString.call(value2);
    }
    if (isDate(value2)) {
      base = " " + Date.prototype.toUTCString.call(value2);
    }
    if (isError(value2)) {
      base = " " + formatError2(value2);
    }
    if (keys2.length === 0 && (!array || value2.length == 0)) {
      return braces2[0] + base + braces2[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value2);
    var output;
    if (array) {
      output = formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces2);
  }
  function formatPrimitive(ctx, value2) {
    if (isUndefined(value2))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value2)) {
      var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value2))
      return ctx.stylize("" + value2, "number");
    if (isBoolean2(value2))
      return ctx.stylize("" + value2, "boolean");
    if (isNull2(value2))
      return ctx.stylize("null", "null");
  }
  function formatError2(value2) {
    return "[" + Error.prototype.toString.call(value2) + "]";
  }
  function formatArray2(ctx, value2, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l2 = value2.length; i2 < l2; ++i2) {
      if (hasOwnProperty2(value2, String(i2))) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i2), true));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
    var name, str2, desc;
    desc = Object.getOwnPropertyDescriptor(value2, key) || { value: value2[key] };
    if (desc.get) {
      if (desc.set) {
        str2 = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str2 = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str2 = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str2) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull2(recurseTimes)) {
          str2 = formatValue2(ctx, desc.value, null);
        } else {
          str2 = formatValue2(ctx, desc.value, recurseTimes - 1);
        }
        if (str2.indexOf("\n") > -1) {
          if (array) {
            str2 = str2.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str2 = "\n" + str2.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str2 = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str2;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str2;
  }
  function reduceToSingleString(output, base, braces2) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces2[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces2[1];
    }
    return braces2[0] + base + " " + output.join(", ") + " " + braces2[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull2(arg) {
    return arg === null;
  }
  exports2.isNull = isNull2;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString2;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol2;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return isObject2(re) && objectToString2(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate(d) {
    return isObject2(d) && objectToString2(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  function isError(e) {
    return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
  }
  exports2.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction2;
  function isPrimitive2(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive2;
  exports2.isBuffer = isBufferBrowser;
  function objectToString2(o) {
    return Object.prototype.toString.call(o);
  }
  function pad2(n2) {
    return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp2() {
    var d = new Date();
    var time = [
      pad2(d.getHours()),
      pad2(d.getMinutes()),
      pad2(d.getSeconds())
    ].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp2(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = inherits_browser.exports;
  exports2._extend = function(origin, add2) {
    if (!add2 || !isObject2(add2))
      return origin;
    var keys2 = Object.keys(add2);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add2[keys2[i2]];
    }
    return origin;
  };
  function hasOwnProperty2(obj2, prop) {
    return Object.prototype.hasOwnProperty.call(obj2, prop);
  }
})(util$2);
var utils$8 = {};
(function(exports2) {
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type2) => node.nodes.find((node2) => node2.type === type2);
  exports2.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min) || !exports2.isInteger(max))
      return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block2, n2 = 0, type2) => {
    let node = block2.nodes[n2];
    if (!node)
      return;
    if (type2 && node.type === type2 || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block2) => {
    if (block2.type !== "brace")
      return false;
    if (block2.invalid === true || block2.dollar)
      return true;
    if (block2.commas >> 0 + block2.ranges >> 0 === 0) {
      block2.invalid = true;
      return true;
    }
    if (block2.open !== true || block2.close !== true) {
      block2.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args2) => {
    const result2 = [];
    const flat = (arr) => {
      for (let i2 = 0; i2 < arr.length; i2++) {
        let ele = arr[i2];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result2.push(ele);
      }
      return result2;
    };
    flat(args2);
    return result2;
  };
})(utils$8);
const utils$7 = utils$8;
var stringify$4 = (ast, options2 = {}) => {
  let stringify2 = (node, parent = {}) => {
    let invalidBlock = options2.escapeInvalid && utils$7.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options2.escapeInvalid === true;
    let output = "";
    if (node.value) {
      if ((invalidBlock || invalidNode) && utils$7.isOpenOrClose(node)) {
        return "\\" + node.value;
      }
      return node.value;
    }
    if (node.value) {
      return node.value;
    }
    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify2(child);
      }
    }
    return output;
  };
  return stringify2(ast);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isNumber$2 = function(num) {
  if (typeof num === "number") {
    return num - num === 0;
  }
  if (typeof num === "string" && num.trim() !== "") {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const isNumber$1 = isNumber$2;
const toRegexRange$1 = (min, max, options2) => {
  if (isNumber$1(min) === false) {
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  }
  if (max === void 0 || min === max) {
    return String(min);
  }
  if (isNumber$1(max) === false) {
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  }
  let opts = __spreadValues2({ relaxZeros: true }, options2);
  if (typeof opts.strictZeros === "boolean") {
    opts.relaxZeros = opts.strictZeros === false;
  }
  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap2 = String(opts.wrap);
  let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap2;
  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }
  let a = Math.min(min, max);
  let b = Math.max(min, max);
  if (Math.abs(a - b) === 1) {
    let result2 = min + "|" + max;
    if (opts.capture) {
      return `(${result2})`;
    }
    if (opts.wrap === false) {
      return result2;
    }
    return `(?:${result2})`;
  }
  let isPadded = hasPadding(min) || hasPadding(max);
  let state2 = { min, max, a, b };
  let positives = [];
  let negatives = [];
  if (isPadded) {
    state2.isPadded = isPadded;
    state2.maxLen = String(state2.max).length;
  }
  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state2, opts);
    a = state2.a = 0;
  }
  if (b >= 0) {
    positives = splitToPatterns(a, b, state2, opts);
  }
  state2.negatives = negatives;
  state2.positives = positives;
  state2.result = collatePatterns(negatives, positives);
  if (opts.capture === true) {
    state2.result = `(${state2.result})`;
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state2.result = `(?:${state2.result})`;
  }
  toRegexRange$1.cache[cacheKey] = state2;
  return state2.result;
};
function collatePatterns(neg, pos, options2) {
  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start, stop, options2) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }
  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = "";
  let count = 0;
  for (let i2 = 0; i2 < digits; i2++) {
    let [startDigit, stopDigit] = zipped[i2];
    if (startDigit === stopDigit) {
      pattern += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern += options2.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern, count: [count], digits };
}
function splitToPatterns(min, max, tok, options2) {
  let ranges = splitToRanges(min, max);
  let tokens2 = [];
  let start = min;
  let prev;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let max2 = ranges[i2];
    let obj2 = rangeToPattern(String(start), String(max2), options2);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj2.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj2.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options2);
    }
    obj2.string = zeros2 + obj2.pattern + toQuantifier(obj2.count);
    tokens2.push(obj2);
    start = max2 + 1;
    prev = obj2;
  }
  return tokens2;
}
function filterPatterns(arr, comparison, prefix, intersection, options2) {
  let result2 = [];
  for (let ele of arr) {
    let { string } = ele;
    if (!intersection && !contains(comparison, "string", string)) {
      result2.push(prefix + string);
    }
    if (intersection && contains(comparison, "string", string)) {
      result2.push(prefix + string);
    }
  }
  return result2;
}
function zip(a, b) {
  let arr = [];
  for (let i2 = 0; i2 < a.length; i2++)
    arr.push([a[i2], b[i2]]);
  return arr;
}
function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
  return arr.some((ele) => ele[key] === val);
}
function countNines(min, len) {
  return Number(String(min).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a, b, options2) {
  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str2) {
  return /^-?(0+)\d/.test(str2);
}
function padZeros(value2, tok, options2) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options2.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
var toRegexRange_1 = toRegexRange$1;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
const util$1 = util$2;
const toRegexRange = toRegexRange_1;
const isObject$b = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
const transform = (toNumber2) => {
  return (value2) => toNumber2 === true ? Number(value2) : String(value2);
};
const isValidValue = (value2) => {
  return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
};
const isNumber = (num) => Number.isInteger(+num);
const zeros = (input) => {
  let value2 = `${input}`;
  let index2 = -1;
  if (value2[0] === "-")
    value2 = value2.slice(1);
  if (value2 === "0")
    return false;
  while (value2[++index2] === "0")
    ;
  return index2 > 0;
};
const stringify$3 = (start, end, options2) => {
  if (typeof start === "string" || typeof end === "string") {
    return true;
  }
  return options2.stringify === true;
};
const pad = (input, maxLength, toNumber2) => {
  if (maxLength > 0) {
    let dash = input[0] === "-" ? "-" : "";
    if (dash)
      input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
  }
  if (toNumber2 === false) {
    return String(input);
  }
  return input;
};
const toMaxLen = (input, maxLength) => {
  let negative = input[0] === "-" ? "-" : "";
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength)
    input = "0" + input;
  return negative ? "-" + input : input;
};
const toSequence = (parts2, options2) => {
  parts2.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts2.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  let prefix = options2.capture ? "" : "?:";
  let positives = "";
  let negatives = "";
  let result2;
  if (parts2.positives.length) {
    positives = parts2.positives.join("|");
  }
  if (parts2.negatives.length) {
    negatives = `-(${prefix}${parts2.negatives.join("|")})`;
  }
  if (positives && negatives) {
    result2 = `${positives}|${negatives}`;
  } else {
    result2 = positives || negatives;
  }
  if (options2.wrap) {
    return `(${prefix}${result2})`;
  }
  return result2;
};
const toRange = (a, b, isNumbers, options2) => {
  if (isNumbers) {
    return toRegexRange(a, b, __spreadValues2({ wrap: false }, options2));
  }
  let start = String.fromCharCode(a);
  if (a === b)
    return start;
  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};
const toRegex = (start, end, options2) => {
  if (Array.isArray(start)) {
    let wrap2 = options2.wrap === true;
    let prefix = options2.capture ? "" : "?:";
    return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
  }
  return toRegexRange(start, end, options2);
};
const rangeError = (...args2) => {
  return new RangeError("Invalid range arguments: " + util$1.inspect(...args2));
};
const invalidRange = (start, end, options2) => {
  if (options2.strictRanges === true)
    throw rangeError([start, end]);
  return [];
};
const invalidStep = (step, options2) => {
  if (options2.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};
const fillNumbers = (start, end, step = 1, options2 = {}) => {
  let a = Number(start);
  let b = Number(end);
  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options2.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  }
  if (a === 0)
    a = 0;
  if (b === 0)
    b = 0;
  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber2 = padded === false && stringify$3(start, end, options2) === false;
  let format3 = options2.transform || transform(toNumber2);
  if (options2.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
  }
  let parts2 = { negatives: [], positives: [] };
  let push = (num) => parts2[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
  let range2 = [];
  let index2 = 0;
  while (descending ? a >= b : a <= b) {
    if (options2.toRegex === true && step > 1) {
      push(a);
    } else {
      range2.push(pad(format3(a, index2), maxLen, toNumber2));
    }
    a = descending ? a - step : a + step;
    index2++;
  }
  if (options2.toRegex === true) {
    return step > 1 ? toSequence(parts2, options2) : toRegex(range2, null, __spreadValues2({ wrap: false }, options2));
  }
  return range2;
};
const fillLetters = (start, end, step = 1, options2 = {}) => {
  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options2);
  }
  let format3 = options2.transform || ((val) => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);
  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);
  if (options2.toRegex && step === 1) {
    return toRange(min, max, false, options2);
  }
  let range2 = [];
  let index2 = 0;
  while (descending ? a >= b : a <= b) {
    range2.push(format3(a, index2));
    a = descending ? a - step : a + step;
    index2++;
  }
  if (options2.toRegex === true) {
    return toRegex(range2, null, { wrap: false, options: options2 });
  }
  return range2;
};
const fill$2 = (start, end, step, options2 = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }
  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options2);
  }
  if (typeof step === "function") {
    return fill$2(start, end, 1, { transform: step });
  }
  if (isObject$b(step)) {
    return fill$2(start, end, 0, step);
  }
  let opts = __spreadValues2({}, options2);
  if (opts.capture === true)
    opts.wrap = true;
  step = step || opts.step || 1;
  if (!isNumber(step)) {
    if (step != null && !isObject$b(step))
      return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }
  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }
  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
var fillRange = fill$2;
const fill$1 = fillRange;
const utils$6 = utils$8;
const compile$1 = (ast, options2 = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils$6.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options2.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options2.escapeInvalid === true ? "\\" : "";
    let output = "";
    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }
    if (node.type === "open") {
      return invalid ? prefix + node.value : "(";
    }
    if (node.type === "close") {
      return invalid ? prefix + node.value : ")";
    }
    if (node.type === "comma") {
      return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
    }
    if (node.value) {
      return node.value;
    }
    if (node.nodes && node.ranges > 0) {
      let args2 = utils$6.reduce(node.nodes);
      let range2 = fill$1(...args2, __spreadProps2(__spreadValues2({}, options2), { wrap: false, toRegex: true }));
      if (range2.length !== 0) {
        return args2.length > 1 && range2.length > 1 ? `(${range2})` : range2;
      }
    }
    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };
  return walk(ast);
};
var compile_1 = compile$1;
const fill = fillRange;
const stringify$2 = stringify$4;
const utils$5 = utils$8;
const append = (queue2 = "", stash = "", enclose = false) => {
  let result2 = [];
  queue2 = [].concat(queue2);
  stash = [].concat(stash);
  if (!stash.length)
    return queue2;
  if (!queue2.length) {
    return enclose ? utils$5.flatten(stash).map((ele) => `{${ele}}`) : stash;
  }
  for (let item of queue2) {
    if (Array.isArray(item)) {
      for (let value2 of item) {
        result2.push(append(value2, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === "string")
          ele = `{${ele}}`;
        result2.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
      }
    }
  }
  return utils$5.flatten(result2);
};
const expand$1 = (ast, options2 = {}) => {
  let rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
  let walk = (node, parent = {}) => {
    node.queue = [];
    let p2 = parent;
    let q = parent.queue;
    while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
      p2 = p2.parent;
      q = p2.queue;
    }
    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify$2(node, options2)));
      return;
    }
    if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ["{}"]));
      return;
    }
    if (node.nodes && node.ranges > 0) {
      let args2 = utils$5.reduce(node.nodes);
      if (utils$5.exceedsLimit(...args2, options2.step, rangeLimit)) {
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      }
      let range2 = fill(...args2, options2);
      if (range2.length === 0) {
        range2 = stringify$2(node, options2);
      }
      q.push(append(q.pop(), range2));
      node.nodes = [];
      return;
    }
    let enclose = utils$5.encloseBrace(node);
    let queue2 = node.queue;
    let block2 = node;
    while (block2.type !== "brace" && block2.type !== "root" && block2.parent) {
      block2 = block2.parent;
      queue2 = block2.queue;
    }
    for (let i2 = 0; i2 < node.nodes.length; i2++) {
      let child = node.nodes[i2];
      if (child.type === "comma" && node.type === "brace") {
        if (i2 === 1)
          queue2.push("");
        queue2.push("");
        continue;
      }
      if (child.type === "close") {
        q.push(append(q.pop(), queue2, enclose));
        continue;
      }
      if (child.value && child.type !== "open") {
        queue2.push(append(queue2.pop(), child.value));
        continue;
      }
      if (child.nodes) {
        walk(child, node);
      }
    }
    return queue2;
  };
  return utils$5.flatten(walk(ast));
};
var expand_1 = expand$1;
var constants$6 = {
  MAX_LENGTH: 1024 * 64,
  CHAR_0: "0",
  CHAR_9: "9",
  CHAR_UPPERCASE_A: "A",
  CHAR_LOWERCASE_A: "a",
  CHAR_UPPERCASE_Z: "Z",
  CHAR_LOWERCASE_Z: "z",
  CHAR_LEFT_PARENTHESES: "(",
  CHAR_RIGHT_PARENTHESES: ")",
  CHAR_ASTERISK: "*",
  CHAR_AMPERSAND: "&",
  CHAR_AT: "@",
  CHAR_BACKSLASH: "\\",
  CHAR_BACKTICK: "`",
  CHAR_CARRIAGE_RETURN: "\r",
  CHAR_CIRCUMFLEX_ACCENT: "^",
  CHAR_COLON: ":",
  CHAR_COMMA: ",",
  CHAR_DOLLAR: "$",
  CHAR_DOT: ".",
  CHAR_DOUBLE_QUOTE: '"',
  CHAR_EQUAL: "=",
  CHAR_EXCLAMATION_MARK: "!",
  CHAR_FORM_FEED: "\f",
  CHAR_FORWARD_SLASH: "/",
  CHAR_HASH: "#",
  CHAR_HYPHEN_MINUS: "-",
  CHAR_LEFT_ANGLE_BRACKET: "<",
  CHAR_LEFT_CURLY_BRACE: "{",
  CHAR_LEFT_SQUARE_BRACKET: "[",
  CHAR_LINE_FEED: "\n",
  CHAR_NO_BREAK_SPACE: "\xA0",
  CHAR_PERCENT: "%",
  CHAR_PLUS: "+",
  CHAR_QUESTION_MARK: "?",
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  CHAR_RIGHT_CURLY_BRACE: "}",
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  CHAR_SEMICOLON: ";",
  CHAR_SINGLE_QUOTE: "'",
  CHAR_SPACE: " ",
  CHAR_TAB: "	",
  CHAR_UNDERSCORE: "_",
  CHAR_VERTICAL_LINE: "|",
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
};
const stringify$1 = stringify$4;
const {
  MAX_LENGTH: MAX_LENGTH$1,
  CHAR_BACKSLASH,
  CHAR_BACKTICK,
  CHAR_COMMA: CHAR_COMMA$1,
  CHAR_DOT: CHAR_DOT$1,
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1,
  CHAR_DOUBLE_QUOTE,
  CHAR_SINGLE_QUOTE,
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$6;
const parse$4 = (input, options2 = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  let opts = options2 || {};
  let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }
  let ast = { type: "root", input, nodes: [] };
  let stack = [ast];
  let block2 = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index2 = 0;
  let depth2 = 0;
  let value2;
  const advance = () => input[index2++];
  const push = (node) => {
    if (node.type === "text" && prev.type === "dot") {
      prev.type = "text";
    }
    if (prev && prev.type === "text" && node.type === "text") {
      prev.value += node.value;
      return;
    }
    block2.nodes.push(node);
    node.parent = block2;
    node.prev = prev;
    prev = node;
    return node;
  };
  push({ type: "bos" });
  while (index2 < length) {
    block2 = stack[stack.length - 1];
    value2 = advance();
    if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
      continue;
    }
    if (value2 === CHAR_BACKSLASH) {
      push({ type: "text", value: (options2.keepEscaping ? value2 : "") + advance() });
      continue;
    }
    if (value2 === CHAR_RIGHT_SQUARE_BRACKET$1) {
      push({ type: "text", value: "\\" + value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_SQUARE_BRACKET$1) {
      brackets++;
      let next2;
      while (index2 < length && (next2 = advance())) {
        value2 += next2;
        if (next2 === CHAR_LEFT_SQUARE_BRACKET$1) {
          brackets++;
          continue;
        }
        if (next2 === CHAR_BACKSLASH) {
          value2 += advance();
          continue;
        }
        if (next2 === CHAR_RIGHT_SQUARE_BRACKET$1) {
          brackets--;
          if (brackets === 0) {
            break;
          }
        }
      }
      push({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_PARENTHESES$1) {
      block2 = push({ type: "paren", nodes: [] });
      stack.push(block2);
      push({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_PARENTHESES$1) {
      if (block2.type !== "paren") {
        push({ type: "text", value: value2 });
        continue;
      }
      block2 = stack.pop();
      push({ type: "text", value: value2 });
      block2 = stack[stack.length - 1];
      continue;
    }
    if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
      let open2 = value2;
      let next2;
      if (options2.keepQuotes !== true) {
        value2 = "";
      }
      while (index2 < length && (next2 = advance())) {
        if (next2 === CHAR_BACKSLASH) {
          value2 += next2 + advance();
          continue;
        }
        if (next2 === open2) {
          if (options2.keepQuotes === true)
            value2 += next2;
          break;
        }
        value2 += next2;
      }
      push({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_CURLY_BRACE$1) {
      depth2++;
      let dollar = prev.value && prev.value.slice(-1) === "$" || block2.dollar === true;
      let brace = {
        type: "brace",
        open: true,
        close: false,
        dollar,
        depth: depth2,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block2 = push(brace);
      stack.push(block2);
      push({ type: "open", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_CURLY_BRACE$1) {
      if (block2.type !== "brace") {
        push({ type: "text", value: value2 });
        continue;
      }
      let type2 = "close";
      block2 = stack.pop();
      block2.close = true;
      push({ type: type2, value: value2 });
      depth2--;
      block2 = stack[stack.length - 1];
      continue;
    }
    if (value2 === CHAR_COMMA$1 && depth2 > 0) {
      if (block2.ranges > 0) {
        block2.ranges = 0;
        let open2 = block2.nodes.shift();
        block2.nodes = [open2, { type: "text", value: stringify$1(block2) }];
      }
      push({ type: "comma", value: value2 });
      block2.commas++;
      continue;
    }
    if (value2 === CHAR_DOT$1 && depth2 > 0 && block2.commas === 0) {
      let siblings = block2.nodes;
      if (depth2 === 0 || siblings.length === 0) {
        push({ type: "text", value: value2 });
        continue;
      }
      if (prev.type === "dot") {
        block2.range = [];
        prev.value += value2;
        prev.type = "range";
        if (block2.nodes.length !== 3 && block2.nodes.length !== 5) {
          block2.invalid = true;
          block2.ranges = 0;
          prev.type = "text";
          continue;
        }
        block2.ranges++;
        block2.args = [];
        continue;
      }
      if (prev.type === "range") {
        siblings.pop();
        let before = siblings[siblings.length - 1];
        before.value += prev.value + value2;
        prev = before;
        block2.ranges--;
        continue;
      }
      push({ type: "dot", value: value2 });
      continue;
    }
    push({ type: "text", value: value2 });
  }
  do {
    block2 = stack.pop();
    if (block2.type !== "root") {
      block2.nodes.forEach((node) => {
        if (!node.nodes) {
          if (node.type === "open")
            node.isOpen = true;
          if (node.type === "close")
            node.isClose = true;
          if (!node.nodes)
            node.type = "text";
          node.invalid = true;
        }
      });
      let parent = stack[stack.length - 1];
      let index3 = parent.nodes.indexOf(block2);
      parent.nodes.splice(index3, 1, ...block2.nodes);
    }
  } while (stack.length > 0);
  push({ type: "eos" });
  return ast;
};
var parse_1$1 = parse$4;
const stringify = stringify$4;
const compile = compile_1;
const expand = expand_1;
const parse$3 = parse_1$1;
const braces$1 = (input, options2 = {}) => {
  let output = [];
  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result2 = braces$1.create(pattern, options2);
      if (Array.isArray(result2)) {
        output.push(...result2);
      } else {
        output.push(result2);
      }
    }
  } else {
    output = [].concat(braces$1.create(input, options2));
  }
  if (options2 && options2.expand === true && options2.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};
braces$1.parse = (input, options2 = {}) => parse$3(input, options2);
braces$1.stringify = (input, options2 = {}) => {
  if (typeof input === "string") {
    return stringify(braces$1.parse(input, options2), options2);
  }
  return stringify(input, options2);
};
braces$1.compile = (input, options2 = {}) => {
  if (typeof input === "string") {
    input = braces$1.parse(input, options2);
  }
  return compile(input, options2);
};
braces$1.expand = (input, options2 = {}) => {
  if (typeof input === "string") {
    input = braces$1.parse(input, options2);
  }
  let result2 = expand(input, options2);
  if (options2.noempty === true) {
    result2 = result2.filter(Boolean);
  }
  if (options2.nodupes === true) {
    result2 = [...new Set(result2)];
  }
  return result2;
};
braces$1.create = (input, options2 = {}) => {
  if (input === "" || input.length < 3) {
    return [input];
  }
  return options2.expand !== true ? braces$1.compile(input, options2) : braces$1.expand(input, options2);
};
var braces_1 = braces$1;
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
  }
}
function normalizeStringPosix(path2, allowAboveRoot) {
  var res2 = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code2;
  for (var i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length)
      code2 = path2.charCodeAt(i2);
    else if (code2 === 47)
      break;
    else
      code2 = 47;
    if (code2 === 47) {
      if (lastSlash === i2 - 1 || dots === 1)
        ;
      else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res2.length < 2 || lastSegmentLength !== 2 || res2.charCodeAt(res2.length - 1) !== 46 || res2.charCodeAt(res2.length - 2) !== 46) {
          if (res2.length > 2) {
            var lastSlashIndex = res2.lastIndexOf("/");
            if (lastSlashIndex !== res2.length - 1) {
              if (lastSlashIndex === -1) {
                res2 = "";
                lastSegmentLength = 0;
              } else {
                res2 = res2.slice(0, lastSlashIndex);
                lastSegmentLength = res2.length - 1 - res2.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res2.length === 2 || res2.length === 1) {
            res2 = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res2.length > 0)
            res2 += "/..";
          else
            res2 = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res2.length > 0)
          res2 += "/" + path2.slice(lastSlash + 1, i2);
        else
          res2 = path2.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res2;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}
var posix = {
  resolve: function resolve4() {
    var resolvedPath = "";
    var resolvedAbsolute = false;
    var cwd;
    for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      var path2;
      if (i2 >= 0)
        path2 = arguments[i2];
      else {
        if (cwd === void 0)
          cwd = process.cwd();
        path2 = cwd;
      }
      assertPath(path2);
      if (path2.length === 0) {
        continue;
      }
      resolvedPath = path2 + "/" + resolvedPath;
      resolvedAbsolute = path2.charCodeAt(0) === 47;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return "/" + resolvedPath;
      else
        return "/";
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return ".";
    }
  },
  normalize: function normalize2(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    var isAbsolute2 = path2.charCodeAt(0) === 47;
    var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
    path2 = normalizeStringPosix(path2, !isAbsolute2);
    if (path2.length === 0 && !isAbsolute2)
      path2 = ".";
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute2)
      return "/" + path2;
    return path2;
  },
  isAbsolute: function isAbsolute(path2) {
    assertPath(path2);
    return path2.length > 0 && path2.charCodeAt(0) === 47;
  },
  join: function join2() {
    if (arguments.length === 0)
      return ".";
    var joined;
    for (var i2 = 0; i2 < arguments.length; ++i2) {
      var arg = arguments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else
          joined += "/" + arg;
      }
    }
    if (joined === void 0)
      return ".";
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to)
      return "";
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to)
      return "";
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i2 = 0;
    for (; i2 <= length; ++i2) {
      if (i2 === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i2) === 47) {
            return to.slice(toStart + i2 + 1);
          } else if (i2 === 0) {
            return to.slice(toStart + i2);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i2) === 47) {
            lastCommonSep = i2;
          } else if (i2 === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i2);
      var toCode = to.charCodeAt(toStart + i2);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47)
        lastCommonSep = i2;
    }
    var out = "";
    for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
      if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
        if (out.length === 0)
          out += "..";
        else
          out += "/..";
      }
    }
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47)
        ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path2) {
    return path2;
  },
  dirname: function dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    var code2 = path2.charCodeAt(0);
    var hasRoot = code2 === 47;
    var end = -1;
    var matchedSlash = true;
    for (var i2 = path2.length - 1; i2 >= 1; --i2) {
      code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end === 1)
      return "//";
    return path2.slice(0, end);
  },
  basename: function basename(path2, ext) {
    if (ext !== void 0 && typeof ext !== "string")
      throw new TypeError('"ext" argument must be a string');
    assertPath(path2);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i2;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        var code2 = path2.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    } else {
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        if (path2.charCodeAt(i2) === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i2 + 1;
        }
      }
      if (end === -1)
        return "";
      return path2.slice(start, end);
    }
  },
  extname: function extname(path2) {
    assertPath(path2);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var preDotState = 0;
    for (var i2 = path2.length - 1; i2 >= 0; --i2) {
      var code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  format: function format2(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse: function parse2(path2) {
    assertPath(path2);
    var ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    var code2 = path2.charCodeAt(0);
    var isAbsolute2 = code2 === 47;
    var start;
    if (isAbsolute2) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i2 = path2.length - 1;
    var preDotState = 0;
    for (; i2 >= start; --i2) {
      code2 = path2.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute2)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute2) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    if (startPart > 0)
      ret.dir = path2.slice(0, startPart - 1);
    else if (isAbsolute2)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.posix = posix;
var pathBrowserify = posix;
var utils$4 = {};
const path$2 = pathBrowserify;
const WIN_SLASH = "\\\\/";
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;
const DOT_LITERAL = "\\.";
const PLUS_LITERAL = "\\+";
const QMARK_LITERAL = "\\?";
const SLASH_LITERAL = "\\/";
const ONE_CHAR = "(?=.)";
const QMARK = "[^/]";
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;
const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};
const WINDOWS_CHARS = __spreadProps2(__spreadValues2({}, POSIX_CHARS), {
  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
});
const POSIX_REGEX_SOURCE$1 = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var constants$5 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  CHAR_0: 48,
  CHAR_9: 57,
  CHAR_UPPERCASE_A: 65,
  CHAR_LOWERCASE_A: 97,
  CHAR_UPPERCASE_Z: 90,
  CHAR_LOWERCASE_Z: 122,
  CHAR_LEFT_PARENTHESES: 40,
  CHAR_RIGHT_PARENTHESES: 41,
  CHAR_ASTERISK: 42,
  CHAR_AMPERSAND: 38,
  CHAR_AT: 64,
  CHAR_BACKWARD_SLASH: 92,
  CHAR_CARRIAGE_RETURN: 13,
  CHAR_CIRCUMFLEX_ACCENT: 94,
  CHAR_COLON: 58,
  CHAR_COMMA: 44,
  CHAR_DOT: 46,
  CHAR_DOUBLE_QUOTE: 34,
  CHAR_EQUAL: 61,
  CHAR_EXCLAMATION_MARK: 33,
  CHAR_FORM_FEED: 12,
  CHAR_FORWARD_SLASH: 47,
  CHAR_GRAVE_ACCENT: 96,
  CHAR_HASH: 35,
  CHAR_HYPHEN_MINUS: 45,
  CHAR_LEFT_ANGLE_BRACKET: 60,
  CHAR_LEFT_CURLY_BRACE: 123,
  CHAR_LEFT_SQUARE_BRACKET: 91,
  CHAR_LINE_FEED: 10,
  CHAR_NO_BREAK_SPACE: 160,
  CHAR_PERCENT: 37,
  CHAR_PLUS: 43,
  CHAR_QUESTION_MARK: 63,
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  CHAR_RIGHT_CURLY_BRACE: 125,
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  CHAR_SEMICOLON: 59,
  CHAR_SINGLE_QUOTE: 39,
  CHAR_SPACE: 32,
  CHAR_TAB: 9,
  CHAR_UNDERSCORE: 95,
  CHAR_VERTICAL_LINE: 124,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  SEP: path$2.sep,
  extglobChars(chars) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};
(function(exports2) {
  const path2 = pathBrowserify;
  const win32 = process.platform === "win32";
  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$5;
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
  exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2);
  exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str2) => {
    return str2.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options2) => {
    if (options2 && typeof options2.windows === "boolean") {
      return options2.windows;
    }
    return win32 === true || path2.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports2.removePrefix = (input, state2 = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state2.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state2 = {}, options2 = {}) => {
    const prepend = options2.contains ? "" : "^";
    const append2 = options2.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append2}`;
    if (state2.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
})(utils$4);
const utils$3 = utils$4;
const {
  CHAR_ASTERISK,
  CHAR_AT,
  CHAR_BACKWARD_SLASH,
  CHAR_COMMA,
  CHAR_DOT,
  CHAR_EXCLAMATION_MARK,
  CHAR_FORWARD_SLASH,
  CHAR_LEFT_CURLY_BRACE,
  CHAR_LEFT_PARENTHESES,
  CHAR_LEFT_SQUARE_BRACKET,
  CHAR_PLUS,
  CHAR_QUESTION_MARK,
  CHAR_RIGHT_CURLY_BRACE,
  CHAR_RIGHT_PARENTHESES,
  CHAR_RIGHT_SQUARE_BRACKET
} = constants$5;
const isPathSeparator = (code2) => {
  return code2 === CHAR_FORWARD_SLASH || code2 === CHAR_BACKWARD_SLASH;
};
const depth = (token) => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};
const scan$1 = (input, options2) => {
  const opts = options2 || {};
  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens2 = [];
  const parts2 = [];
  let str2 = input;
  let index2 = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces2 = 0;
  let prev;
  let code2;
  let token = { value: "", depth: 0, isGlob: false };
  const eos = () => index2 >= length;
  const peek = () => str2.charCodeAt(index2 + 1);
  const advance = () => {
    prev = code2;
    return str2.charCodeAt(++index2);
  };
  while (index2 < length) {
    code2 = advance();
    let next2;
    if (code2 === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code2 = advance();
      if (code2 === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }
    if (braceEscaped === true || code2 === CHAR_LEFT_CURLY_BRACE) {
      braces2++;
      while (eos() !== true && (code2 = advance())) {
        if (code2 === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }
        if (code2 === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          continue;
        }
        if (braceEscaped !== true && code2 === CHAR_DOT && (code2 = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (braceEscaped !== true && code2 === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code2 === CHAR_RIGHT_CURLY_BRACE) {
          braces2--;
          if (braces2 === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code2 === CHAR_FORWARD_SLASH) {
      slashes.push(index2);
      tokens2.push(token);
      token = { value: "", depth: 0, isGlob: false };
      if (finished === true)
        continue;
      if (prev === CHAR_DOT && index2 === start + 1) {
        start += 2;
        continue;
      }
      lastIndex = index2 + 1;
      continue;
    }
    if (opts.noext !== true) {
      const isExtglobChar = code2 === CHAR_PLUS || code2 === CHAR_AT || code2 === CHAR_ASTERISK || code2 === CHAR_QUESTION_MARK || code2 === CHAR_EXCLAMATION_MARK;
      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code2 === CHAR_EXCLAMATION_MARK && index2 === start) {
          negatedExtglob = true;
        }
        if (scanToEnd === true) {
          while (eos() !== true && (code2 = advance())) {
            if (code2 === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code2 = advance();
              continue;
            }
            if (code2 === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }
    if (code2 === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK)
        isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code2 === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code2 === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next2 = advance())) {
        if (next2 === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }
        if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (opts.nonegate !== true && code2 === CHAR_EXCLAMATION_MARK && index2 === start) {
      negated = token.negated = true;
      start++;
      continue;
    }
    if (opts.noparen !== true && code2 === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;
      if (scanToEnd === true) {
        while (eos() !== true && (code2 = advance())) {
          if (code2 === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code2 = advance();
            continue;
          }
          if (code2 === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (isGlob === true) {
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
  }
  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }
  let base = str2;
  let prefix = "";
  let glob = "";
  if (start > 0) {
    prefix = str2.slice(0, start);
    str2 = str2.slice(start);
    lastIndex -= start;
  }
  if (base && isGlob === true && lastIndex > 0) {
    base = str2.slice(0, lastIndex);
    glob = str2.slice(lastIndex);
  } else if (isGlob === true) {
    base = "";
    glob = str2;
  } else {
    base = str2;
  }
  if (base && base !== "" && base !== "/" && base !== str2) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }
  if (opts.unescape === true) {
    if (glob)
      glob = utils$3.removeBackslashes(glob);
    if (base && backslashes === true) {
      base = utils$3.removeBackslashes(base);
    }
  }
  const state2 = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };
  if (opts.tokens === true) {
    state2.maxDepth = 0;
    if (!isPathSeparator(code2)) {
      tokens2.push(token);
    }
    state2.tokens = tokens2;
  }
  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;
    for (let idx = 0; idx < slashes.length; idx++) {
      const n2 = prevIndex ? prevIndex + 1 : start;
      const i2 = slashes[idx];
      const value2 = input.slice(n2, i2);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens2[idx].isPrefix = true;
          tokens2[idx].value = prefix;
        } else {
          tokens2[idx].value = value2;
        }
        depth(tokens2[idx]);
        state2.maxDepth += tokens2[idx].depth;
      }
      if (idx !== 0 || value2 !== "") {
        parts2.push(value2);
      }
      prevIndex = i2;
    }
    if (prevIndex && prevIndex + 1 < input.length) {
      const value2 = input.slice(prevIndex + 1);
      parts2.push(value2);
      if (opts.tokens) {
        tokens2[tokens2.length - 1].value = value2;
        depth(tokens2[tokens2.length - 1]);
        state2.maxDepth += tokens2[tokens2.length - 1].depth;
      }
    }
    state2.slashes = slashes;
    state2.parts = parts2;
  }
  return state2;
};
var scan_1 = scan$1;
const constants$4 = constants$5;
const utils$2 = utils$4;
const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$4;
const expandRange = (args2, options2) => {
  if (typeof options2.expandRange === "function") {
    return options2.expandRange(...args2, options2);
  }
  args2.sort();
  const value2 = `[${args2.join("-")}]`;
  try {
    new RegExp(value2);
  } catch (ex) {
    return args2.map((v) => utils$2.escapeRegex(v)).join("..");
  }
  return value2;
};
const syntaxError = (type2, char) => {
  return `Missing ${type2}: "${char}" - use "\\\\${char}" to match literal characters`;
};
const parse$2 = (input, options2) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  input = REPLACEMENTS[input] || input;
  const opts = __spreadValues2({}, options2);
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  const bos = { type: "bos", value: "", output: opts.prepend || "" };
  const tokens2 = [bos];
  const capture = opts.capture ? "" : "?:";
  const win32 = utils$2.isWindows(options2);
  const PLATFORM_CHARS = constants$4.globChars(win32);
  const EXTGLOB_CHARS = constants$4.extglobChars(PLATFORM_CHARS);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    PLUS_LITERAL: PLUS_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOT_SLASH: NO_DOT_SLASH2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    QMARK: QMARK2,
    QMARK_NO_DOT: QMARK_NO_DOT2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = PLATFORM_CHARS;
  const globstar = (opts2) => {
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const nodot = opts.dot ? "" : NO_DOT2;
  const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
  let star = opts.bash === true ? globstar(opts) : STAR2;
  if (opts.capture) {
    star = `(${star})`;
  }
  if (typeof opts.noext === "boolean") {
    opts.noextglob = opts.noext;
  }
  const state2 = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens: tokens2
  };
  input = utils$2.removePrefix(input, state2);
  len = input.length;
  const extglobs = [];
  const braces2 = [];
  const stack = [];
  let prev = bos;
  let value2;
  const eos = () => state2.index === len - 1;
  const peek = state2.peek = (n2 = 1) => input[state2.index + n2];
  const advance = state2.advance = () => input[++state2.index] || "";
  const remaining = () => input.slice(state2.index + 1);
  const consume = (value3 = "", num = 0) => {
    state2.consumed += value3;
    state2.index += num;
  };
  const append2 = (token) => {
    state2.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };
  const negate = () => {
    let count = 1;
    while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
      advance();
      state2.start++;
      count++;
    }
    if (count % 2 === 0) {
      return false;
    }
    state2.negated = true;
    state2.start++;
    return true;
  };
  const increment = (type2) => {
    state2[type2]++;
    stack.push(type2);
  };
  const decrement = (type2) => {
    state2[type2]--;
    stack.pop();
  };
  const push = (tok) => {
    if (prev.type === "globstar") {
      const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace");
      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
      if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
        state2.output = state2.output.slice(0, -prev.output.length);
        prev.type = "star";
        prev.value = "*";
        prev.output = star;
        state2.output += prev.output;
      }
    }
    if (extglobs.length && tok.type !== "paren") {
      extglobs[extglobs.length - 1].inner += tok.value;
    }
    if (tok.value || tok.output)
      append2(tok);
    if (prev && prev.type === "text" && tok.type === "text") {
      prev.value += tok.value;
      prev.output = (prev.output || "") + tok.value;
      return;
    }
    tok.prev = prev;
    tokens2.push(tok);
    prev = tok;
  };
  const extglobOpen = (type2, value3) => {
    const token = __spreadProps2(__spreadValues2({}, EXTGLOB_CHARS[value3]), { conditions: 1, inner: "" });
    token.prev = prev;
    token.parens = state2.parens;
    token.output = state2.output;
    const output = (opts.capture ? "(" : "") + token.open;
    increment("parens");
    push({ type: type2, value: value3, output: state2.output ? "" : ONE_CHAR2 });
    push({ type: "paren", extglob: true, value: advance(), output });
    extglobs.push(token);
  };
  const extglobClose = (token) => {
    let output = token.close + (opts.capture ? ")" : "");
    let rest;
    if (token.type === "negate") {
      let extglobStar = star;
      if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
        extglobStar = globstar(opts);
      }
      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }
      if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        const expression2 = parse$2(rest, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false })).output;
        output = token.close = `)${expression2})${extglobStar})`;
      }
      if (token.prev.type === "bos") {
        state2.negatedExtglob = true;
      }
    }
    push({ type: "paren", extglob: true, value: value2, output });
    decrement("parens");
  };
  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;
    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index2) => {
      if (first === "\\") {
        backslashes = true;
        return m;
      }
      if (first === "?") {
        if (esc) {
          return esc + first + (rest ? QMARK2.repeat(rest.length) : "");
        }
        if (index2 === 0) {
          return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
        }
        return QMARK2.repeat(chars.length);
      }
      if (first === ".") {
        return DOT_LITERAL2.repeat(chars.length);
      }
      if (first === "*") {
        if (esc) {
          return esc + first + (rest ? star : "");
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });
    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, "");
      } else {
        output = output.replace(/\\+/g, (m) => {
          return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
        });
      }
    }
    if (output === input && opts.contains === true) {
      state2.output = input;
      return state2;
    }
    state2.output = utils$2.wrapOutput(output, state2, options2);
    return state2;
  }
  while (!eos()) {
    value2 = advance();
    if (value2 === "\0") {
      continue;
    }
    if (value2 === "\\") {
      const next2 = peek();
      if (next2 === "/" && opts.bash !== true) {
        continue;
      }
      if (next2 === "." || next2 === ";") {
        continue;
      }
      if (!next2) {
        value2 += "\\";
        push({ type: "text", value: value2 });
        continue;
      }
      const match = /^\\+/.exec(remaining());
      let slashes = 0;
      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state2.index += slashes;
        if (slashes % 2 !== 0) {
          value2 += "\\";
        }
      }
      if (opts.unescape === true) {
        value2 = advance();
      } else {
        value2 += advance();
      }
      if (state2.brackets === 0) {
        push({ type: "text", value: value2 });
        continue;
      }
    }
    if (state2.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
      if (opts.posix !== false && value2 === ":") {
        const inner = prev.value.slice(1);
        if (inner.includes("[")) {
          prev.posix = true;
          if (inner.includes(":")) {
            const idx = prev.value.lastIndexOf("[");
            const pre = prev.value.slice(0, idx);
            const rest2 = prev.value.slice(idx + 2);
            const posix2 = POSIX_REGEX_SOURCE[rest2];
            if (posix2) {
              prev.value = pre + posix2;
              state2.backtrack = true;
              advance();
              if (!bos.output && tokens2.indexOf(prev) === 1) {
                bos.output = ONE_CHAR2;
              }
              continue;
            }
          }
        }
      }
      if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
        value2 = `\\${value2}`;
      }
      if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
        value2 = `\\${value2}`;
      }
      if (opts.posix === true && value2 === "!" && prev.value === "[") {
        value2 = "^";
      }
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (state2.quotes === 1 && value2 !== '"') {
      value2 = utils$2.escapeRegex(value2);
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (value2 === '"') {
      state2.quotes = state2.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: "text", value: value2 });
      }
      continue;
    }
    if (value2 === "(") {
      increment("parens");
      push({ type: "paren", value: value2 });
      continue;
    }
    if (value2 === ")") {
      if (state2.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError("opening", "("));
      }
      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state2.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }
      push({ type: "paren", value: value2, output: state2.parens ? ")" : "\\)" });
      decrement("parens");
      continue;
    }
    if (value2 === "[") {
      if (opts.nobracket === true || !remaining().includes("]")) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("closing", "]"));
        }
        value2 = `\\${value2}`;
      } else {
        increment("brackets");
      }
      push({ type: "bracket", value: value2 });
      continue;
    }
    if (value2 === "]") {
      if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
        push({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      if (state2.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "["));
        }
        push({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      decrement("brackets");
      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
        value2 = `/${value2}`;
      }
      prev.value += value2;
      append2({ value: value2 });
      if (opts.literalBrackets === false || utils$2.hasRegexChars(prevValue)) {
        continue;
      }
      const escaped = utils$2.escapeRegex(prev.value);
      state2.output = state2.output.slice(0, -prev.value.length);
      if (opts.literalBrackets === true) {
        state2.output += escaped;
        prev.value = escaped;
        continue;
      }
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state2.output += prev.value;
      continue;
    }
    if (value2 === "{" && opts.nobrace !== true) {
      increment("braces");
      const open2 = {
        type: "brace",
        value: value2,
        output: "(",
        outputIndex: state2.output.length,
        tokensIndex: state2.tokens.length
      };
      braces2.push(open2);
      push(open2);
      continue;
    }
    if (value2 === "}") {
      const brace = braces2[braces2.length - 1];
      if (opts.nobrace === true || !brace) {
        push({ type: "text", value: value2, output: value2 });
        continue;
      }
      let output = ")";
      if (brace.dots === true) {
        const arr = tokens2.slice();
        const range2 = [];
        for (let i2 = arr.length - 1; i2 >= 0; i2--) {
          tokens2.pop();
          if (arr[i2].type === "brace") {
            break;
          }
          if (arr[i2].type !== "dots") {
            range2.unshift(arr[i2].value);
          }
        }
        output = expandRange(range2, opts);
        state2.backtrack = true;
      }
      if (brace.comma !== true && brace.dots !== true) {
        const out = state2.output.slice(0, brace.outputIndex);
        const toks = state2.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = "\\{";
        value2 = output = "\\}";
        state2.output = out;
        for (const t of toks) {
          state2.output += t.output || t.value;
        }
      }
      push({ type: "brace", value: value2, output });
      decrement("braces");
      braces2.pop();
      continue;
    }
    if (value2 === "|") {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: "text", value: value2 });
      continue;
    }
    if (value2 === ",") {
      let output = value2;
      const brace = braces2[braces2.length - 1];
      if (brace && stack[stack.length - 1] === "braces") {
        brace.comma = true;
        output = "|";
      }
      push({ type: "comma", value: value2, output });
      continue;
    }
    if (value2 === "/") {
      if (prev.type === "dot" && state2.index === state2.start + 1) {
        state2.start = state2.index + 1;
        state2.consumed = "";
        state2.output = "";
        tokens2.pop();
        prev = bos;
        continue;
      }
      push({ type: "slash", value: value2, output: SLASH_LITERAL2 });
      continue;
    }
    if (value2 === ".") {
      if (state2.braces > 0 && prev.type === "dot") {
        if (prev.value === ".")
          prev.output = DOT_LITERAL2;
        const brace = braces2[braces2.length - 1];
        prev.type = "dots";
        prev.output += value2;
        prev.value += value2;
        brace.dots = true;
        continue;
      }
      if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
        push({ type: "text", value: value2, output: DOT_LITERAL2 });
        continue;
      }
      push({ type: "dot", value: value2, output: DOT_LITERAL2 });
      continue;
    }
    if (value2 === "?") {
      const isGroup = prev && prev.value === "(";
      if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        extglobOpen("qmark", value2);
        continue;
      }
      if (prev && prev.type === "paren") {
        const next2 = peek();
        let output = value2;
        if (next2 === "<" && !utils$2.supportsLookbehinds()) {
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        }
        if (prev.value === "(" && !/[!=<:]/.test(next2) || next2 === "<" && !/<([!=]|\w+>)/.test(remaining())) {
          output = `\\${value2}`;
        }
        push({ type: "text", value: value2, output });
        continue;
      }
      if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
        push({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
        continue;
      }
      push({ type: "qmark", value: value2, output: QMARK2 });
      continue;
    }
    if (value2 === "!") {
      if (opts.noextglob !== true && peek() === "(") {
        if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
          extglobOpen("negate", value2);
          continue;
        }
      }
      if (opts.nonegate !== true && state2.index === 0) {
        negate();
        continue;
      }
    }
    if (value2 === "+") {
      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        extglobOpen("plus", value2);
        continue;
      }
      if (prev && prev.value === "(" || opts.regex === false) {
        push({ type: "plus", value: value2, output: PLUS_LITERAL2 });
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
        push({ type: "plus", value: value2 });
        continue;
      }
      push({ type: "plus", value: PLUS_LITERAL2 });
      continue;
    }
    if (value2 === "@") {
      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        push({ type: "at", extglob: true, value: value2, output: "" });
        continue;
      }
      push({ type: "text", value: value2 });
      continue;
    }
    if (value2 !== "*") {
      if (value2 === "$" || value2 === "^") {
        value2 = `\\${value2}`;
      }
      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value2 += match[0];
        state2.index += match[0].length;
      }
      push({ type: "text", value: value2 });
      continue;
    }
    if (prev && (prev.type === "globstar" || prev.star === true)) {
      prev.type = "star";
      prev.star = true;
      prev.value += value2;
      prev.output = star;
      state2.backtrack = true;
      state2.globstar = true;
      consume(value2);
      continue;
    }
    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen("star", value2);
      continue;
    }
    if (prev.type === "star") {
      if (opts.noglobstar === true) {
        consume(value2);
        continue;
      }
      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === "slash" || prior.type === "bos";
      const afterStar = before && (before.type === "star" || before.type === "globstar");
      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
        push({ type: "star", value: value2, output: "" });
        continue;
      }
      const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace");
      const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
      if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
        push({ type: "star", value: value2, output: "" });
        continue;
      }
      while (rest.slice(0, 3) === "/**") {
        const after = input[state2.index + 4];
        if (after && after !== "/") {
          break;
        }
        rest = rest.slice(3);
        consume("/**", 3);
      }
      if (prior.type === "bos" && eos()) {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = globstar(opts);
        state2.output = prev.output;
        state2.globstar = true;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
        state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
        prev.value += value2;
        state2.globstar = true;
        state2.output += prior.output + prev.output;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
        const end = rest[1] !== void 0 ? "|$" : "";
        state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
        prev.value += value2;
        state2.output += prior.output + prev.output;
        state2.globstar = true;
        consume(value2 + advance());
        push({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (prior.type === "bos" && rest[0] === "/") {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
        state2.output = prev.output;
        state2.globstar = true;
        consume(value2 + advance());
        push({ type: "slash", value: "/", output: "" });
        continue;
      }
      state2.output = state2.output.slice(0, -prev.output.length);
      prev.type = "globstar";
      prev.output = globstar(opts);
      prev.value += value2;
      state2.output += prev.output;
      state2.globstar = true;
      consume(value2);
      continue;
    }
    const token = { type: "star", value: value2, output: star };
    if (opts.bash === true) {
      token.output = ".*?";
      if (prev.type === "bos" || prev.type === "slash") {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }
    if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
      token.output = value2;
      push(token);
      continue;
    }
    if (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") {
      if (prev.type === "dot") {
        state2.output += NO_DOT_SLASH2;
        prev.output += NO_DOT_SLASH2;
      } else if (opts.dot === true) {
        state2.output += NO_DOTS_SLASH2;
        prev.output += NO_DOTS_SLASH2;
      } else {
        state2.output += nodot;
        prev.output += nodot;
      }
      if (peek() !== "*") {
        state2.output += ONE_CHAR2;
        prev.output += ONE_CHAR2;
      }
    }
    push(token);
  }
  while (state2.brackets > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", "]"));
    state2.output = utils$2.escapeLast(state2.output, "[");
    decrement("brackets");
  }
  while (state2.parens > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", ")"));
    state2.output = utils$2.escapeLast(state2.output, "(");
    decrement("parens");
  }
  while (state2.braces > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", "}"));
    state2.output = utils$2.escapeLast(state2.output, "{");
    decrement("braces");
  }
  if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
    push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
  }
  if (state2.backtrack === true) {
    state2.output = "";
    for (const token of state2.tokens) {
      state2.output += token.output != null ? token.output : token.value;
      if (token.suffix) {
        state2.output += token.suffix;
      }
    }
  }
  return state2;
};
parse$2.fastpaths = (input, options2) => {
  const opts = __spreadValues2({}, options2);
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  input = REPLACEMENTS[input] || input;
  const win32 = utils$2.isWindows(options2);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOTS: NO_DOTS2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = constants$4.globChars(win32);
  const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
  const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
  const capture = opts.capture ? "" : "?:";
  const state2 = { negated: false, prefix: "" };
  let star = opts.bash === true ? ".*?" : STAR2;
  if (opts.capture) {
    star = `(${star})`;
  }
  const globstar = (opts2) => {
    if (opts2.noglobstar === true)
      return star;
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const create2 = (str2) => {
    switch (str2) {
      case "*":
        return `${nodot}${ONE_CHAR2}${star}`;
      case ".*":
        return `${DOT_LITERAL2}${ONE_CHAR2}${star}`;
      case "*.*":
        return `${nodot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
      case "*/*":
        return `${nodot}${star}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star}`;
      case "**":
        return nodot + globstar(opts);
      case "**/*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star}`;
      case "**/*.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star}${DOT_LITERAL2}${ONE_CHAR2}${star}`;
      case "**/.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star}`;
      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str2);
        if (!match)
          return;
        const source2 = create2(match[1]);
        if (!source2)
          return;
        return source2 + DOT_LITERAL2 + match[2];
      }
    }
  };
  const output = utils$2.removePrefix(input, state2);
  let source = create2(output);
  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL2}?`;
  }
  return source;
};
var parse_1 = parse$2;
const path$1 = pathBrowserify;
const scan = scan_1;
const parse$1 = parse_1;
const utils$1 = utils$4;
const constants$3 = constants$5;
const isObject$a = (val) => val && typeof val === "object" && !Array.isArray(val);
const picomatch$2 = (glob, options2, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map((input) => picomatch$2(input, options2, returnState));
    const arrayMatcher = (str2) => {
      for (const isMatch of fns) {
        const state3 = isMatch(str2);
        if (state3)
          return state3;
      }
      return false;
    };
    return arrayMatcher;
  }
  const isState = isObject$a(glob) && glob.tokens && glob.input;
  if (glob === "" || typeof glob !== "string" && !isState) {
    throw new TypeError("Expected pattern to be a non-empty string");
  }
  const opts = options2 || {};
  const posix2 = utils$1.isWindows(options2);
  const regex = isState ? picomatch$2.compileRe(glob, options2) : picomatch$2.makeRe(glob, options2, false, true);
  const state2 = regex.state;
  delete regex.state;
  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = __spreadProps2(__spreadValues2({}, options2), { ignore: null, onMatch: null, onResult: null });
    isIgnored = picomatch$2(opts.ignore, ignoreOpts, returnState);
  }
  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch$2.test(input, regex, options2, { glob, posix: posix2 });
    const result2 = { glob, state: state2, regex, posix: posix2, input, output, match, isMatch };
    if (typeof opts.onResult === "function") {
      opts.onResult(result2);
    }
    if (isMatch === false) {
      result2.isMatch = false;
      return returnObject ? result2 : false;
    }
    if (isIgnored(input)) {
      if (typeof opts.onIgnore === "function") {
        opts.onIgnore(result2);
      }
      result2.isMatch = false;
      return returnObject ? result2 : false;
    }
    if (typeof opts.onMatch === "function") {
      opts.onMatch(result2);
    }
    return returnObject ? result2 : true;
  };
  if (returnState) {
    matcher.state = state2;
  }
  return matcher;
};
picomatch$2.test = (input, regex, options2, { glob, posix: posix2 } = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected input to be a string");
  }
  if (input === "") {
    return { isMatch: false, output: "" };
  }
  const opts = options2 || {};
  const format3 = opts.format || (posix2 ? utils$1.toPosixSlashes : null);
  let match = input === glob;
  let output = match && format3 ? format3(input) : input;
  if (match === false) {
    output = format3 ? format3(input) : input;
    match = output === glob;
  }
  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch$2.matchBase(input, regex, options2, posix2);
    } else {
      match = regex.exec(output);
    }
  }
  return { isMatch: Boolean(match), match, output };
};
picomatch$2.matchBase = (input, glob, options2, posix2 = utils$1.isWindows(options2)) => {
  const regex = glob instanceof RegExp ? glob : picomatch$2.makeRe(glob, options2);
  return regex.test(path$1.basename(input));
};
picomatch$2.isMatch = (str2, patterns, options2) => picomatch$2(patterns, options2)(str2);
picomatch$2.parse = (pattern, options2) => {
  if (Array.isArray(pattern))
    return pattern.map((p2) => picomatch$2.parse(p2, options2));
  return parse$1(pattern, __spreadProps2(__spreadValues2({}, options2), { fastpaths: false }));
};
picomatch$2.scan = (input, options2) => scan(input, options2);
picomatch$2.compileRe = (state2, options2, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state2.output;
  }
  const opts = options2 || {};
  const prepend = opts.contains ? "" : "^";
  const append2 = opts.contains ? "" : "$";
  let source = `${prepend}(?:${state2.output})${append2}`;
  if (state2 && state2.negated === true) {
    source = `^(?!${source}).*$`;
  }
  const regex = picomatch$2.toRegex(source, options2);
  if (returnState === true) {
    regex.state = state2;
  }
  return regex;
};
picomatch$2.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== "string") {
    throw new TypeError("Expected a non-empty string");
  }
  let parsed = { negated: false, fastpaths: true };
  if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
    parsed.output = parse$1.fastpaths(input, options2);
  }
  if (!parsed.output) {
    parsed = parse$1(input, options2);
  }
  return picomatch$2.compileRe(parsed, options2, returnOutput, returnState);
};
picomatch$2.toRegex = (source, options2) => {
  try {
    const opts = options2 || {};
    return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
  } catch (err2) {
    if (options2 && options2.debug === true)
      throw err2;
    return /$^/;
  }
};
picomatch$2.constants = constants$3;
var picomatch_1 = picomatch$2;
var picomatch$1 = picomatch_1;
const util = util$2;
const braces = braces_1;
const picomatch = picomatch$1;
const utils = utils$4;
const isEmptyString = (val) => val === "" || val === "./";
const micromatch = (list, patterns, options2) => {
  patterns = [].concat(patterns);
  list = [].concat(list);
  let omit = /* @__PURE__ */ new Set();
  let keep = /* @__PURE__ */ new Set();
  let items = /* @__PURE__ */ new Set();
  let negatives = 0;
  let onResult = (state2) => {
    items.add(state2.output);
    if (options2 && options2.onResult) {
      options2.onResult(state2);
    }
  };
  for (let i2 = 0; i2 < patterns.length; i2++) {
    let isMatch = picomatch(String(patterns[i2]), __spreadProps2(__spreadValues2({}, options2), { onResult }), true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated)
      negatives++;
    for (let item of list) {
      let matched = isMatch(item, true);
      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match)
        continue;
      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }
  let result2 = negatives === patterns.length ? [...items] : [...keep];
  let matches2 = result2.filter((item) => !omit.has(item));
  if (options2 && matches2.length === 0) {
    if (options2.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(", ")}"`);
    }
    if (options2.nonull === true || options2.nullglob === true) {
      return options2.unescape ? patterns.map((p2) => p2.replace(/\\/g, "")) : patterns;
    }
  }
  return matches2;
};
micromatch.match = micromatch;
micromatch.matcher = (pattern, options2) => picomatch(pattern, options2);
micromatch.isMatch = (str2, patterns, options2) => picomatch(patterns, options2)(str2);
micromatch.any = micromatch.isMatch;
micromatch.not = (list, patterns, options2 = {}) => {
  patterns = [].concat(patterns).map(String);
  let result2 = /* @__PURE__ */ new Set();
  let items = [];
  let onResult = (state2) => {
    if (options2.onResult)
      options2.onResult(state2);
    items.push(state2.output);
  };
  let matches2 = new Set(micromatch(list, patterns, __spreadProps2(__spreadValues2({}, options2), { onResult })));
  for (let item of items) {
    if (!matches2.has(item)) {
      result2.add(item);
    }
  }
  return [...result2];
};
micromatch.contains = (str2, pattern, options2) => {
  if (typeof str2 !== "string") {
    throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
  }
  if (Array.isArray(pattern)) {
    return pattern.some((p2) => micromatch.contains(str2, p2, options2));
  }
  if (typeof pattern === "string") {
    if (isEmptyString(str2) || isEmptyString(pattern)) {
      return false;
    }
    if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern)) {
      return true;
    }
  }
  return micromatch.isMatch(str2, pattern, __spreadProps2(__spreadValues2({}, options2), { contains: true }));
};
micromatch.matchKeys = (obj2, patterns, options2) => {
  if (!utils.isObject(obj2)) {
    throw new TypeError("Expected the first argument to be an object");
  }
  let keys2 = micromatch(Object.keys(obj2), patterns, options2);
  let res2 = {};
  for (let key of keys2)
    res2[key] = obj2[key];
  return res2;
};
micromatch.some = (list, patterns, options2) => {
  let items = [].concat(list);
  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options2);
    if (items.some((item) => isMatch(item))) {
      return true;
    }
  }
  return false;
};
micromatch.every = (list, patterns, options2) => {
  let items = [].concat(list);
  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options2);
    if (!items.every((item) => isMatch(item))) {
      return false;
    }
  }
  return true;
};
micromatch.all = (str2, patterns, options2) => {
  if (typeof str2 !== "string") {
    throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
  }
  return [].concat(patterns).every((p2) => picomatch(p2, options2)(str2));
};
micromatch.capture = (glob, input, options2) => {
  let posix2 = utils.isWindows(options2);
  let regex = picomatch.makeRe(String(glob), __spreadProps2(__spreadValues2({}, options2), { capture: true }));
  let match = regex.exec(posix2 ? utils.toPosixSlashes(input) : input);
  if (match) {
    return match.slice(1).map((v) => v === void 0 ? "" : v);
  }
};
micromatch.makeRe = (...args2) => picomatch.makeRe(...args2);
micromatch.scan = (...args2) => picomatch.scan(...args2);
micromatch.parse = (patterns, options2) => {
  let res2 = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str2 of braces(String(pattern), options2)) {
      res2.push(picomatch.parse(str2, options2));
    }
  }
  return res2;
};
micromatch.braces = (pattern, options2) => {
  if (typeof pattern !== "string")
    throw new TypeError("Expected a string");
  if (options2 && options2.nobrace === true || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options2);
};
micromatch.braceExpand = (pattern, options2) => {
  if (typeof pattern !== "string")
    throw new TypeError("Expected a string");
  return micromatch.braces(pattern, __spreadProps2(__spreadValues2({}, options2), { expand: true }));
};
var micromatch_1 = micromatch;
const addFrontendListeners = (messagingService2, injectMode, features) => {
  messagingService2.addEventListener(SAVE_ZIP, () => {
    const files = workbench.transformFsTreeToObject(workbench.getRoot());
    zipAndSaveProject(files);
  });
  messagingService2.addEventListener(CONNECT_ELEMENT_HIGHLIGHT, () => addElementHighlight(window, injectMode, features));
  messagingService2.addEventListener(BUNDLER_ERROR, (err2) => showUserFeedback({ type: BUNDLER_ERROR, payload: err2 }));
  messagingService2.addEventListener(TRANSPILER_ERROR, (err2) => showUserFeedback({ type: TRANSPILER_ERROR, payload: err2 }));
  messagingService2.addEventListener(PROJECT_LOADED, ({ files }) => {
    frontendActions.connectElementHighlight();
    workbench.parseEnvs().then((env) => {
      frontendActions.transpileFiles(files, env);
    });
  });
  messagingService2.addEventListener(LOWCODE_INITIALIZED, () => {
    hideSpinner();
  });
  messagingService2.addEventListener(CLONE_ELEMENT, async (source) => {
    var _a2;
    const { fileName, columnToAdd, entityName, referenceField, page, insertType } = source;
    if (columnToAdd) {
      const cwd = (_a2 = workbench == null ? void 0 : workbench.cwd) != null ? _a2 : guessCurrentWorkingDirectory();
      let pathToGraphqlFile = cwd + `/src/pages/${entityName}/index.graphql`;
      if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/") {
        pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
      }
      const graphQLFile = await workbench.readFile(pathToGraphqlFile);
      const modifiedGraphQLFile = await addColumn(graphQLFile, introspectionDeepCopy(workbench.introspection), entityName, columnToAdd, page, referenceField, insertType);
      workbench.writeFile(pathToGraphqlFile, modifiedGraphQLFile).then(() => delay(2e3)).then(() => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `CLONE_FIELD_SUCCESS`,
            entity: columnToAdd
          }
        });
      }).catch((err2) => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `CLONE_FIELD_ERROR`,
            entity: err2
          }
        });
        console.error(err2);
      });
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CLONE_FIELD_INFO`
        }
      });
      return;
    }
    const file = await workbench.readFile(fileName);
    if (!file) {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CLONE_ELEMENT_ERROR`
        }
      });
      throw new Error("File not found on FS");
    }
    cloneElement(file, source).then((code2) => {
      if (code2) {
        frontendActions.fileWrite(fileName, code2);
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `CLONE_ELEMENT_SUCCESS`
          }
        });
      }
    }).catch((err2) => window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: {
        type: `CLONE_ELEMENT_ERROR`,
        payload: err2
      }
    }));
  });
  messagingService2.addEventListener(CLONE_AND_RENAME_ELEMENT, async (source) => {
    const { fileName, fieldToBeAdded } = source;
    const file = await workbench.readFile(fileName);
    if (!file) {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CLONE_ELEMENT_ERROR`
        }
      });
      throw new Error("File not found on FS");
    }
    delay(4e3).then(() => {
      cloneAndRenameElement(file, source, fieldToBeAdded).then((code2) => {
        if (code2)
          frontendActions.fileWrite(fileName, code2);
      });
    });
  });
  messagingService2.addEventListener(REMOVE_ELEMENT, async (source) => {
    var _a2;
    const { colIndex, page, entityName, columnToDelete } = source;
    if (columnToDelete) {
      const cwd = (_a2 = workbench == null ? void 0 : workbench.cwd) != null ? _a2 : guessCurrentWorkingDirectory();
      let pathToGraphqlFile = cwd + `/src/pages/${entityName}/index.graphql`;
      if ((cwd == null ? void 0 : cwd.charAt(0)) !== "/" && pathToGraphqlFile.charAt(0) === "/")
        pathToGraphqlFile = pathToGraphqlFile.substring(1, pathToGraphqlFile.length);
      const graphQLFile = await workbench.readFile(pathToGraphqlFile);
      let fieldToDelete = columnToDelete;
      if (fieldToDelete.split(".")[0] === entityName) {
        fieldToDelete = fieldToDelete.split(".").slice(1).join(".");
      }
      const modifiedGraphQLFile = await iteriaGeneratorWorker.removeColumn(graphQLFile, introspectionDeepCopy(workbench.introspection), entityName, fieldToDelete, page, colIndex);
      await workbench.writeFile(pathToGraphqlFile, modifiedGraphQLFile).then(() => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `REMOVE_ELEMENT_SUCCESS`
          }
        });
      });
      return;
    }
    const file = await workbench.readFile(source.fileName);
    if (!file) {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `REMOVE_ELEMENT_ERROR`
        }
      });
      throw new Error("File not found on FS");
    }
    removeElement(file, source).then((code2) => {
      if (code2) {
        frontendActions.fileWrite(source.fileName, code2);
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `REMOVE_ELEMENT_SUCCESS`
          }
        });
      }
    }).catch((err2) => {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `REMOVE_ELEMENT_ERROR`,
          payload: err2
        }
      });
      console.error(err2);
    });
  });
  messagingService2.addEventListener(NAVIGATE_TO_SOURCE_CODE, async (source) => {
    const { fileName, columnNumber, lineNumber } = source;
    if (injectMode === "jamstack") {
      navigateToSourceCodeVscode(source);
    } else {
      window.open(`vscode://file/${fileName}:${lineNumber}:${columnNumber}`);
    }
  });
  messagingService2.addEventListener(GENERATE_PAGE, async (source) => {
    var _a2;
    const cwd = (_a2 = workbench == null ? void 0 : workbench.cwd) != null ? _a2 : guessCurrentWorkingDirectory();
    const intro = workbench.introspection;
    const [queryRoot] = getRoots(intro);
    const selectedFields2 = source.fieldToGenerate instanceof Array ? source.fieldToGenerate : [source.fieldToGenerate];
    const fieldTypes = selectedFields2.map((selectedField) => {
      const fieldType = queryRoot.fields.find((field) => field.name === selectedField);
      return getNestedOfType(fieldType).name;
    }).filter(Boolean);
    generatePages(intro, workbench, {
      entities: fieldTypes,
      generateReact: source.generateReact
    }).then(async (generatedPages) => {
      generatedPages.pages.forEach((val, key) => {
        const relativePath = key.split("/src")[1] ? "/src" + key.split("/src")[1] : key;
        workbench.writeFile(cwd + relativePath, val);
      });
      delay(2e3).then(() => {
        workbench.writeFiles(generatedPages.files);
      });
      delay(2e3).then(() => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `GENERATE_PAGE_SUCCESS`,
            payload: { entity: fieldTypes }
          }
        });
      }).catch((err2) => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `GENERATE_PAGE_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    });
    window.postMessage({
      type: "SHOW_USER_FEEDBACK",
      payload: {
        type: `GENERATE_PAGE_INFO`,
        payload: { entity: fieldTypes }
      }
    });
  });
  messagingService2.addEventListener(CHANGE_GRAPHQL_ENDPOINT, async (source) => {
    const newEndpointURL = source.newEndpointURL;
    const newSecret = source.newSecret;
    const envFile = await workbench.readEnvFileContent();
    workbench.setGraphQLEndpoint(newEndpointURL, newSecret);
    loadNewIntrospection();
    if (!envFile)
      return window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CHANGE_GRAPHQL_ENDPOINT_ERROR`
        }
      });
    const modifiedEnvFile = await changeGraphQLEndpoint(envFile, "VITE_HASURA_GRAPHQL_ENDPOINT", newEndpointURL, "VITE_HASURA_GRAPHQL_SECRET", newSecret);
    if (!modifiedEnvFile)
      return window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CHANGE_GRAPHQL_ENDPOINT_ERROR`
        }
      });
    await workbench.writeEnvFileContent(modifiedEnvFile).then(async () => {
      var _a2, _b, _c;
      const codegen2 = await workbench.generateGraphql(void 0, void 0);
      if ((_a2 = codegen2 == null ? void 0 : codegen2.generated) == null ? void 0 : _a2.errors) {
        const files = workbench.transformFsTreeToObject(workbench.getRoot());
        const generatedFiles = micromatch_1(Object.keys(files), [`/src/pages/**/*.graphql`, `!/src/pages/index.graphql`]).map((filePath) => {
          return { path: filePath.substring(0, filePath.lastIndexOf("/")) };
        });
        await workbench.deleteFiles(generatedFiles);
        const regenerated = await workbench.generateGraphql(void 0, void 0);
        if ((_b = regenerated == null ? void 0 : regenerated.generated) == null ? void 0 : _b.errors) {
          console.error((_c = regenerated.generated) == null ? void 0 : _c.errors);
          return window.postMessage({
            type: "SHOW_USER_FEEDBACK",
            payload: {
              type: `GRAPHQL_CODEGEN_ERROR`
            }
          });
        }
      }
    }).then(() => {
      window.postMessage({
        type: "SHOW_USER_FEEDBACK",
        payload: {
          type: `CHANGE_GRAPHQL_ENDPOINT_SUCESS`
        }
      });
    });
  });
  messagingService2.addEventListener(CHANGE_THEME, async (source) => {
    var _a2;
    const cwd = (_a2 = workbench == null ? void 0 : workbench.cwd) != null ? _a2 : guessCurrentWorkingDirectory();
    if (cwd) {
      const filePath = cwd + "/src/theme/colors.json";
      workbench.writeFile(filePath, JSON.stringify(source.theme)).then(() => {
        window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `CHANGE_THEME_SUCESS`
          }
        });
      }).catch((err2) => {
        return window.postMessage({
          type: "SHOW_USER_FEEDBACK",
          payload: {
            type: `CHANGE_THEME_ERROR`
          }
        });
      });
    }
  });
  messagingService2.addEventListener(SHOW_USER_FEEDBACK, (data) => showUserFeedback(data));
  messagingService2.addEventListener(REORDER_ELEMENT, async (data) => {
    if (data.hasFields) {
      reorderFields(introspectionDeepCopy(workbench.introspection), workbench, data).then(() => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: { type: `${REORDER_ELEMENT}_SUCCESS` }
        });
      }).catch((err2) => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    } else if (data.hasRoutes) {
      reorderRoutes(workbench, data).then(() => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: { type: `${REORDER_ELEMENT}_SUCCESS` }
        });
      }).catch((err2) => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    } else if (data.hasColumns) {
      reorderColumns(introspectionDeepCopy(workbench.introspection), workbench, data).then(() => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: { type: `${REORDER_ELEMENT}_SUCCESS` }
        });
      }).catch((err2) => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    } else if (data.hasRelations) {
      reorderRelations(introspectionDeepCopy(workbench.introspection), workbench, data).then(() => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: { type: `${REORDER_ELEMENT}_SUCCESS` }
        });
      }).catch((err2) => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    } else {
      const file = await workbench.readFile(data.fileName);
      if (!file) {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`
          }
        });
        throw new Error("File not found on FS");
      }
      reorderElement(file, data).then((code2) => {
        if (code2) {
          frontendActions.fileWrite(data.fileName, code2);
          window.postMessage({
            type: SHOW_USER_FEEDBACK,
            payload: { type: `${REORDER_ELEMENT}_SUCCESS` }
          });
        }
      }).catch((err2) => {
        window.postMessage({
          type: SHOW_USER_FEEDBACK,
          payload: {
            type: `${REORDER_ELEMENT}_ERROR`,
            payload: err2
          }
        });
        console.error(err2);
      });
    }
  });
};
class WindowMessaging {
  constructor(window2) {
    __publicField2(this, "window");
    this.window = window2;
  }
  addEventListener(type2, cb) {
    const eventListenerCallback = (e) => {
      if (e.data.type === type2 && e.source === window)
        cb(e.data.payload);
    };
    this.window.addEventListener("message", eventListenerCallback);
    return () => this.window.removeEventListener("message", eventListenerCallback);
  }
  postMessage(type2, payload) {
    console.log("messaging postMessage", type2);
    this.window.postMessage({ type: type2, payload }, "*");
  }
}
var untar$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, r) {
    module2.exports = r();
  }(commonjsGlobal, function() {
    function e(e2) {
      function r2(e3) {
        for (var r3 = 0, n4 = t2.length; r3 < n4; ++r3)
          t2[r3](e3);
        a2.push(e3);
      }
      if (typeof Promise != "function")
        throw new Error("Promise implementation not available in this environment.");
      var t2 = [], a2 = [], n3 = new Promise(function(t3, a3) {
        e2(t3, a3, r2);
      });
      n3.progress = function(e3) {
        if (typeof e3 != "function")
          throw new Error("cb is not a function.");
        for (var r3 = 0, i4 = a2.length; r3 < i4; ++r3)
          e3(a2[r3]);
        return t2.push(e3), n3;
      };
      var i3 = n3.then;
      return n3.then = function(e3, r3, t3) {
        return i3.call(n3, e3, r3), t3 !== void 0 && n3.progress(t3), n3;
      }, n3;
    }
    function r(r2) {
      if (!(r2 instanceof ArrayBuffer))
        throw new TypeError("arrayBuffer is not an instance of ArrayBuffer.");
      if (!n2.Worker)
        throw new Error("Worker implementation is not available in this environment.");
      return new e(function(e2, n3, i3) {
        var o2 = new Worker(a), s = [];
        o2.onerror = function(e3) {
          n3(e3);
        }, o2.onmessage = function(r3) {
          switch (r3 = r3.data, r3.type) {
            case "log":
              console[r3.data.level]("Worker: " + r3.data.msg);
              break;
            case "extract":
              var a2 = t(r3.data);
              s.push(a2), i3(a2);
              break;
            case "complete":
              o2.terminate(), e2(s);
              break;
            case "error":
              o2.terminate(), n3(new Error(r3.data.message));
              break;
            default:
              o2.terminate(), n3(new Error("Unknown message from worker: " + r3.type));
          }
        }, o2.postMessage({ type: "extract", buffer: r2 }, [r2]);
      });
    }
    function t(e2) {
      return Object.defineProperties(e2, o), e2;
    }
    var a, n2 = window || this, i2 = n2.URL || n2.webkitURL, o = { blob: { get: function() {
      return this._blob || (this._blob = new Blob([this.buffer]));
    } }, getBlobUrl: { value: function() {
      return this._blobUrl || (this._blobUrl = i2.createObjectURL(this.blob));
    } }, readAsString: { value: function() {
      for (var e2 = this.buffer, r2 = e2.byteLength, t2 = 1, a2 = new DataView(e2), n3 = [], i3 = 0; i3 < r2; ++i3) {
        var o2 = a2.getUint8(i3 * t2, true);
        n3.push(o2);
      }
      return this._string = String.fromCharCode.apply(null, n3);
    } }, readAsJSON: { value: function() {
      return JSON.parse(this.readAsString());
    } } };
    return a = (window || this).URL.createObjectURL(new Blob(['"use strict";function UntarWorker(){}function decodeUTF8(e){for(var r="",t=0;t<e.length;){var a=e[t++];if(a>127){if(a>191&&a<224){if(t>=e.length)throw"UTF-8 decode: incomplete 2-byte sequence";a=(31&a)<<6|63&e[t]}else if(a>223&&a<240){if(t+1>=e.length)throw"UTF-8 decode: incomplete 3-byte sequence";a=(15&a)<<12|(63&e[t])<<6|63&e[++t]}else{if(!(a>239&&a<248))throw"UTF-8 decode: unknown multibyte start 0x"+a.toString(16)+" at index "+(t-1);if(t+2>=e.length)throw"UTF-8 decode: incomplete 4-byte sequence";a=(7&a)<<18|(63&e[t])<<12|(63&e[++t])<<6|63&e[++t]}++t}if(a<=65535)r+=String.fromCharCode(a);else{if(!(a<=1114111))throw"UTF-8 decode: code point 0x"+a.toString(16)+" exceeds UTF-16 reach";a-=65536,r+=String.fromCharCode(a>>10|55296),r+=String.fromCharCode(1023&a|56320)}}return r}function PaxHeader(e){this._fields=e}function TarFile(){}function UntarStream(e){this._bufferView=new DataView(e),this._position=0}function UntarFileStream(e){this._stream=new UntarStream(e),this._globalPaxHeader=null}if(UntarWorker.prototype={onmessage:function(e){try{if("extract"!==e.data.type)throw new Error("Unknown message type: "+e.data.type);this.untarBuffer(e.data.buffer)}catch(r){this.postError(r)}},postError:function(e){this.postMessage({type:"error",data:{message:e.message}})},postLog:function(e,r){this.postMessage({type:"log",data:{level:e,msg:r}})},untarBuffer:function(e){try{for(var r=new UntarFileStream(e);r.hasNext();){var t=r.next();this.postMessage({type:"extract",data:t},[t.buffer])}this.postMessage({type:"complete"})}catch(a){this.postError(a)}},postMessage:function(e,r){self.postMessage(e,r)}},"undefined"!=typeof self){var worker=new UntarWorker;self.onmessage=function(e){worker.onmessage(e)}}PaxHeader.parse=function(e){for(var r=new Uint8Array(e),t=[];r.length>0;){var a=parseInt(decodeUTF8(r.subarray(0,r.indexOf(32)))),n=decodeUTF8(r.subarray(0,a)),i=n.match(/^\\d+ ([^=]+)=(.*)\\n$/);if(null===i)throw new Error("Invalid PAX header data format.");var s=i[1],o=i[2];0===o.length?o=null:null!==o.match(/^\\d+$/)&&(o=parseInt(o));var f={name:s,value:o};t.push(f),r=r.subarray(a)}return new PaxHeader(t)},PaxHeader.prototype={applyHeader:function(e){this._fields.forEach(function(r){var t=r.name,a=r.value;"path"===t?(t="name",void 0!==e.prefix&&delete e.prefix):"linkpath"===t&&(t="linkname"),null===a?delete e[t]:e[t]=a})}},UntarStream.prototype={readString:function(e){for(var r=1,t=e*r,a=[],n=0;n<e;++n){var i=this._bufferView.getUint8(this.position()+n*r,!0);if(0===i)break;a.push(i)}return this.seek(t),String.fromCharCode.apply(null,a)},readBuffer:function(e){var r;if("function"==typeof ArrayBuffer.prototype.slice)r=this._bufferView.buffer.slice(this.position(),this.position()+e);else{r=new ArrayBuffer(e);var t=new Uint8Array(r),a=new Uint8Array(this._bufferView.buffer,this.position(),e);t.set(a)}return this.seek(e),r},seek:function(e){this._position+=e},peekUint32:function(){return this._bufferView.getUint32(this.position(),!0)},position:function(e){return void 0===e?this._position:void(this._position=e)},size:function(){return this._bufferView.byteLength}},UntarFileStream.prototype={hasNext:function(){return this._stream.position()+4<this._stream.size()&&0!==this._stream.peekUint32()},next:function(){return this._readNextFile()},_readNextFile:function(){var e=this._stream,r=new TarFile,t=!1,a=null,n=e.position(),i=n+512;switch(r.name=e.readString(100),r.mode=e.readString(8),r.uid=parseInt(e.readString(8)),r.gid=parseInt(e.readString(8)),r.size=parseInt(e.readString(12),8),r.mtime=parseInt(e.readString(12),8),r.checksum=parseInt(e.readString(8)),r.type=e.readString(1),r.linkname=e.readString(100),r.ustarFormat=e.readString(6),r.ustarFormat.indexOf("ustar")>-1&&(r.version=e.readString(2),r.uname=e.readString(32),r.gname=e.readString(32),r.devmajor=parseInt(e.readString(8)),r.devminor=parseInt(e.readString(8)),r.namePrefix=e.readString(155),r.namePrefix.length>0&&(r.name=r.namePrefix+"/"+r.name)),e.position(i),r.type){case"0":case"":r.buffer=e.readBuffer(r.size);break;case"1":break;case"2":break;case"3":break;case"4":break;case"5":break;case"6":break;case"7":break;case"g":t=!0,this._globalPaxHeader=PaxHeader.parse(e.readBuffer(r.size));break;case"x":t=!0,a=PaxHeader.parse(e.readBuffer(r.size))}void 0===r.buffer&&(r.buffer=new ArrayBuffer(0));var s=i+r.size;return r.size%512!==0&&(s+=512-r.size%512),e.position(s),t&&(r=this._readNextFile()),null!==this._globalPaxHeader&&this._globalPaxHeader.applyHeader(r),null!==a&&a.applyHeader(r),r}};'])), r;
  });
})(untar$1);
var untar = untar$1.exports;
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
const extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
const extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist2) => {
  return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value2, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value2 >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value2 << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c2, tree) => {
  send_bits(s, tree[c2 * 2], tree[c2 * 2 + 1]);
};
const bi_reverse = (code2, len) => {
  let res2 = 0;
  do {
    res2 |= code2 & 1;
    code2 >>>= 1;
    res2 <<= 1;
  } while (--len > 0);
  return res2 >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n2, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n2 = s.heap[h];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base) {
      xbits = extra[n2 - base];
    }
    f = tree[n2 * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n2 = s.bl_count[bits];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code2 = 0;
  let bits;
  let n2;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n2;
  let bits;
  let length;
  let code2;
  let dist2;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES$1 - 1; code2++) {
    base_length[code2] = length;
    for (n2 = 0; n2 < 1 << extra_lbits[code2]; n2++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist2 = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist2;
    for (n2 = 0; n2 < 1 << extra_dbits[code2]; n2++) {
      _dist_code[dist2++] = code2;
    }
  }
  dist2 >>= 7;
  for (; code2 < D_CODES$1; code2++) {
    base_dist[code2] = dist2 << 7;
    for (n2 = 0; n2 < 1 << extra_dbits[code2] - 7; n2++) {
      _dist_code[256 + dist2++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n2;
  for (n2 = 0; n2 < L_CODES$1; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < D_CODES$1; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0; n2 < BL_CODES$1; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const copy_block = (s, buf, len, header) => {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};
const smaller = (tree, n2, m, depth2) => {
  const _n2 = n2 * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth2[n2] <= depth2[m];
};
const pqdownheap = (s, tree, k2) => {
  const v = s.heap[k2];
  let j2 = k2 << 1;
  while (j2 <= s.heap_len) {
    if (j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)) {
      j2++;
    }
    if (smaller(tree, v, s.heap[j2], s.depth)) {
      break;
    }
    s.heap[k2] = s.heap[j2];
    k2 = j2;
    j2 <<= 1;
  }
  s.heap[k2] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist2;
  let lc;
  let lx = 0;
  let code2;
  let extra;
  if (s.last_lit !== 0) {
    do {
      dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist2 === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist2--;
        code2 = d_code(dist2);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist2 -= base_dist[code2];
          send_bits(s, dist2, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n2 = 0; n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1; n2 >= 1; n2--) {
    pqdownheap(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0; n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let black_mask = 4093624447;
  let n2;
  for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32; n2 < LITERALS$1; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist2, lc) => {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist2 === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist2--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist2) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c2, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k2 = 0; k2 < 8; k2++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n2] = c2;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f) => {
  return (f << 1) - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan2 = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan2 + best_len - 1];
  let scan_end = _win[scan2 + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan2] || _win[++match] !== _win[scan2 + 1]) {
      continue;
    }
    scan2 += 2;
    match++;
    do {
    } while (_win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && _win[++scan2] === _win[++match] && scan2 < strend);
    len = MAX_MATCH - (strend - scan2);
    scan2 = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan2 + best_len - 1];
      scan_end = _win[scan2 + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let p2, n2, m, more, str2;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n2 = s.hash_size;
      p2 = n2;
      do {
        m = s.head[--p2];
        s.head[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      n2 = _w_size;
      p2 = n2;
      do {
        m = s.prev[--p2];
        s.prev[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n2);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str2 = s.strstart - s.insert;
      s.ins_h = s.window[str2];
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush2) => {
  let max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    const max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
const deflate_fast = (s, flush2) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush2) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush2) => {
  let bflush;
  let prev;
  let scan2, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan2 = s.strstart - 1;
      prev = _win[scan2];
      if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
        s.match_length = MAX_MATCH - (strend - scan2);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush2) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush2 === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush2 === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush2) => {
  let beg, val;
  if (!strm || !strm.state || flush2 > Z_BLOCK$1 || flush2 < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush2 !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  s.strm = strm;
  const old_flush = s.last_flush;
  s.last_flush = flush2;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush2 !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush2) : s.strategy === Z_RLE ? deflate_rle(s, flush2) : configuration_table[s.level].func(s, flush2);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush2 === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush2 !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush2 === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush2 !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap2 === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next2 = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str2 = s.strstart;
    let n2 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
      s.prev[str2 & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str2;
      str2++;
    } while (--n2);
    s.strstart = str2;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj2, key) => {
  return Object.prototype.hasOwnProperty.call(obj2, key);
};
var assign = function(obj2) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj2[p2] = source[p2];
      }
    }
  }
  return obj2;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
    len += chunks[i2].length;
  }
  const result2 = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
    let chunk = chunks[i2];
    result2.set(chunk, pos);
    pos += chunk.length;
  }
  return result2;
};
var common$1 = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str2) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str2);
  }
  let buf, c2, c22, m_pos, i2, str_len = str2.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str2.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str2.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c2 = str2.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str2.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i2++] = c2;
    } else if (c2 < 2048) {
      buf[i2++] = 192 | c2 >>> 6;
      buf[i2++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i2++] = 224 | c2 >>> 12;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    } else {
      buf[i2++] = 240 | c2 >>> 18;
      buf[i2++] = 128 | c2 >>> 12 & 63;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result2 = "";
  for (let i2 = 0; i2 < len; i2++) {
    result2 += String.fromCharCode(buf[i2]);
  }
  return result2;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c2 = buf[i2++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c2 = c2 << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options2) {
  this.options = common$1.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common$1.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  const deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
function gzip$1(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$1(input, options2);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
const BAD$1 = 30;
const TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist2;
  let from;
  let from_source;
  let input, output;
  const state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist2 = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist2 += hold & (1 << op) - 1;
                  if (dist2 > dmax) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist2 > op) {
                    op = dist2 - op;
                    if (op > whave) {
                      if (state2.sane) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist2;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist2;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state2.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state2.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop3 = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill2;
  let low;
  let mask;
  let next2;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type2 === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next2 = table_index;
  curr = root2;
  drop3 = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop3;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop3;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table[next2 + (huff >> drop3) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop3 === 0) {
        drop3 = root2;
      }
      next2 += min;
      curr = len - drop3;
      left = 1 << curr;
      while (curr + drop3 < max) {
        left -= count[curr + drop3];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop3 << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA = 6;
const NAME = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD = 30;
const MEM = 31;
const SYNC = 32;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new Int32Array(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new Int32Array(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap2;
  state2.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state2) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inftrees(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inftrees(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist2;
  const state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new Uint8Array(state2.wsize);
  }
  if (copy >= state2.wsize) {
    state2.window.set(src.subarray(end - state2.wsize, end), 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist2 = state2.wsize - state2.wnext;
    if (dist2 > copy) {
      dist2 = copy;
    }
    state2.window.set(src.subarray(end - copy, end - copy + dist2), state2.wnext);
    copy -= dist2;
    if (copy) {
      state2.window.set(src.subarray(end - copy, end), 0);
      state2.wnext = copy;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist2;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist2;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush2) => {
  let state2;
  let input, output;
  let next2;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << state2.wbits;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32_1(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32_1(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy = state2.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Uint8Array(state2.head.extra_len);
                }
                state2.head.extra.set(input.subarray(next2, next2 + copy), len);
              }
              if (state2.flags & 512) {
                state2.check = crc32_1(state2.check, input, copy, next2);
              }
              have -= copy;
              next2 += copy;
              state2.length -= copy;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512) {
              state2.check = crc32_1(state2.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next2 + copy++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state2.flags & 512) {
              state2.check = crc32_1(state2.check, input, copy, next2);
            }
            have -= copy;
            next2 += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush2 === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy = state2.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next2, next2 + copy), put);
            have -= copy;
            next2 += copy;
            left -= copy;
            put += copy;
            state2.length -= copy;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts = { bits: state2.lenbits };
          ret = inftrees(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts = { bits: state2.lenbits };
          ret = inftrees(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
          state2.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts = { bits: state2.distbits };
          ret = inftrees(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
          state2.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush2 === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n2 = state2.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n2 = state2.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state2.offset > copy) {
            copy = state2.offset - copy;
            if (copy > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy > state2.wnext) {
              copy -= state2.wnext;
              from = state2.wsize - copy;
            } else {
              from = state2.wnext - copy;
            }
            if (copy > state2.length) {
              copy = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from = put - state2.offset;
            copy = state2.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state2.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = state2.flags ? crc32_1(state2.check, output, _out, put - _out) : adler32_1(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush2 !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = state2.flags ? crc32_1(state2.check, output, _out, strm.next_out - _out) : adler32_1(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush2 === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state2.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state2;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state2.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options2) {
  this.options = common$1.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1(input, options2);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var Deflate_1 = Deflate;
var deflate_1 = deflate;
var deflateRaw_1 = deflateRaw;
var gzip_1 = gzip;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
var inflateRaw_1 = inflateRaw;
var ungzip_1 = ungzip;
var constants_1 = constants$2;
var pako = {
  Deflate: Deflate_1,
  deflate: deflate_1,
  deflateRaw: deflateRaw_1,
  gzip: gzip_1,
  Inflate: Inflate_1,
  inflate: inflate_1,
  inflateRaw: inflateRaw_1,
  ungzip: ungzip_1,
  constants: constants_1
};
const stripString = (str2, char) => str2.startsWith(char) ? str2.slice(1) : str2;
const fetchProjectTar = async (repoUrl, command) => {
  try {
    const normalizedRepoUrl = stripString(repoUrl, "/");
    const res2 = await fetch(`${normalizedRepoUrl}/Sources.tar.gz`);
    const arrayBuffer = await res2.arrayBuffer();
    let inflated;
    if (command === "serve") {
      inflated = new Uint8Array(arrayBuffer);
    } else {
      inflated = pako.inflate(new Uint8Array(arrayBuffer));
    }
    const untarred = await untar(inflated.buffer);
    const decoder = new TextDecoder("utf-8");
    const files = {};
    untarred.forEach((f) => {
      if (!f.name.endsWith("/")) {
        const fileKey = stripString(f.name, ".");
        const decoded = decoder.decode(f.buffer);
        files[fileKey] = decoded;
      }
    });
    return files;
  } catch (err2) {
    throw new Error(err2);
  }
};
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject$9(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index2, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
      key = sourceKeys[index2];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result2 = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result2 += string;
  }
  return result2;
}
function isNegativeZero(number2) {
  return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
}
var isNothing_1 = isNothing;
var isObject_1$1 = isObject$9;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1$1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError$1(exception2, compact2) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact2 && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError$1(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString4(compact2) {
  return this.name + ": " + formatError$1(this, compact2);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position2, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position2 - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position2 - maxHalfLength + head.length;
  }
  if (lineEnd - position2 > maxHalfLength) {
    tail = " ...";
    lineEnd = position2 + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position2 - lineStart + head.length
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options2) {
  options2 = Object.create(options2 || null);
  if (!mark.buffer)
    return null;
  if (!options2.maxLength)
    options2.maxLength = 79;
  if (typeof options2.indent !== "number")
    options2.indent = 1;
  if (typeof options2.linesBefore !== "number")
    options2.linesBefore = 3;
  if (typeof options2.linesAfter !== "number")
    options2.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result2 = "", i2, line;
  var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options2.linesBefore; i2++) {
    if (foundLineNo - i2 < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i2], lineEnds[foundLineNo - i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]), maxLineLength);
    result2 = common.repeat(" ", options2.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result2;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result2 += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result2 += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options2.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i2], lineEnds[foundLineNo + i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]), maxLineLength);
    result2 += common.repeat(" ", options2.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result2.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result2 = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result2[String(alias)] = style;
      });
    });
  }
  return result2;
}
function Type$1(tag, options2) {
  options2 = options2 || {};
  Object.keys(options2).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options2;
  this.tag = tag;
  this.kind = options2["kind"] || null;
  this.resolve = options2["resolve"] || function() {
    return true;
  };
  this.construct = options2["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options2["instanceOf"] || null;
  this.predicate = options2["predicate"] || null;
  this.represent = options2["represent"] || null;
  this.representName = options2["representName"] || null;
  this.defaultStyle = options2["defaultStyle"] || null;
  this.multi = options2["multi"] || false;
  this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result2 = [];
  schema2[name].forEach(function(currentType) {
    var newIndex2 = result2.length;
    result2.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex2 = previousIndex;
      }
    });
    result2[newIndex2] = currentType;
  });
  return result2;
}
function compileMap() {
  var result2 = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index2, length;
  function collectType(type2) {
    if (type2.multi) {
      result2.multi[type2.kind].push(type2);
      result2.multi["fallback"].push(type2);
    } else {
      result2[type2.kind][type2.tag] = result2["fallback"][type2.tag] = type2;
    }
  }
  for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
    arguments[index2].forEach(collectType);
  }
  return result2;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result2 = Object.create(Schema$1.prototype);
  result2.implicit = (this.implicit || []).concat(implicit);
  result2.explicit = (this.explicit || []).concat(explicit);
  result2.compiledImplicit = compileList(result2, "implicit");
  result2.compiledExplicit = compileList(result2, "explicit");
  result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit);
  return result2;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index2 = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index2];
  if (ch === "-" || ch === "+") {
    ch = data[++index2];
  }
  if (ch === "0") {
    if (index2 + 1 === max)
      return true;
    ch = data[++index2];
    if (ch === "b") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index2++;
      for (; index2 < max; index2++) {
        ch = data[index2];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index2)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index2 < max; index2++) {
    ch = data[index2];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index2))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value2 = data, sign = 1, ch;
  if (value2.indexOf("_") !== -1) {
    value2 = value2.replace(/_/g, "");
  }
  ch = value2[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value2 = value2.slice(1);
    ch = value2[0];
  }
  if (value2 === "0")
    return 0;
  if (ch === "0") {
    if (value2[1] === "b")
      return sign * parseInt(value2.slice(2), 2);
    if (value2[1] === "x")
      return sign * parseInt(value2.slice(2), 16);
    if (value2[1] === "o")
      return sign * parseInt(value2.slice(2), 8);
  }
  return sign * parseInt(value2, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj2) {
      return obj2 >= 0 ? "0b" + obj2.toString(2) : "-0b" + obj2.toString(2).slice(1);
    },
    octal: function(obj2) {
      return obj2 >= 0 ? "0o" + obj2.toString(8) : "-0o" + obj2.toString(8).slice(1);
    },
    decimal: function(obj2) {
      return obj2.toString(10);
    },
    hexadecimal: function(obj2) {
      return obj2 >= 0 ? "0x" + obj2.toString(16).toUpperCase() : "-0x" + obj2.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value2, sign;
  value2 = data.replace(/_/g, "").toLowerCase();
  sign = value2[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value2[0]) >= 0) {
    value2 = value2.slice(1);
  }
  if (value2 === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value2 === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value2, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res2;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res2 = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res2) ? res2.replace("e", ".e") : res2;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result2 = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result2.push(bits >> 16 & 255);
      result2.push(bits >> 8 & 255);
      result2.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result2.push(bits >> 16 & 255);
    result2.push(bits >> 8 & 255);
    result2.push(bits & 255);
  } else if (tailbits === 18) {
    result2.push(bits >> 10 & 255);
    result2.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result2.push(bits >> 4 & 255);
  }
  return new Uint8Array(result2);
}
function representYamlBinary(object) {
  var result2 = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result2 += map2[bits >> 18 & 63];
      result2 += map2[bits >> 12 & 63];
      result2 += map2[bits >> 6 & 63];
      result2 += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result2 += map2[bits >> 18 & 63];
    result2 += map2[bits >> 12 & 63];
    result2 += map2[bits >> 6 & 63];
    result2 += map2[bits & 63];
  } else if (tail === 2) {
    result2 += map2[bits >> 10 & 63];
    result2 += map2[bits >> 4 & 63];
    result2 += map2[bits << 2 & 63];
    result2 += map2[64];
  } else if (tail === 1) {
    result2 += map2[bits >> 2 & 63];
    result2 += map2[bits << 4 & 63];
    result2 += map2[64];
    result2 += map2[64];
  }
  return result2;
}
function isBinary(obj2) {
  return Object.prototype.toString.call(obj2) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index2, length, pair, pairKey, pairHasKey, object = data;
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index2, length, pair, keys2, result2, object = data;
  result2 = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys2 = Object.keys(pair);
    if (keys2.length !== 1)
      return false;
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index2, length, pair, keys2, result2, object = data;
  result2 = new Array(object.length);
  for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
    pair = object[index2];
    keys2 = Object.keys(pair);
    result2[index2] = [keys2[0], pair[keys2[0]]];
  }
  return result2;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj2) {
  return Object.prototype.toString.call(obj2);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode((c2 - 65536 >> 10) + 55296, (c2 - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options2) {
  this.input = input;
  this.filename = options2["filename"] || null;
  this.schema = options2["schema"] || _default;
  this.onWarning = options2["onWarning"] || null;
  this.legacy = options2["legacy"] || false;
  this.json = options2["json"] || false;
  this.listener = options2["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state2, message) {
  var mark = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  if (state2.onWarning) {
    state2.onWarning.call(null, generateError(state2, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state2, name, args2) {
    var match, major, minor;
    if (state2.version !== null) {
      throwError(state2, "duplication of %YAML directive");
    }
    if (args2.length !== 1) {
      throwError(state2, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args2[0]);
    if (match === null) {
      throwError(state2, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state2, "unacceptable YAML version of the document");
    }
    state2.version = args2[0];
    state2.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state2, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state2, name, args2) {
    var handle, prefix;
    if (args2.length !== 2) {
      throwError(state2, "TAG directive accepts exactly two arguments");
    }
    handle = args2[0];
    prefix = args2[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
      throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state2, "tag prefix is malformed: " + prefix);
    }
    state2.tagMap[handle] = prefix;
  }
};
function captureSegment(state2, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state2.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source, overridableKeys) {
  var sourceKeys, key, index2, quantity;
  if (!common.isObject(source)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
    key = sourceKeys[index2];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index2, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
      if (Array.isArray(keyNode[index2])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
        keyNode[index2] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
        mergeMappings(state2, _result, valueNode[index2], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count) {
  if (count === 1) {
    state2.result += " ";
  } else if (count > 1) {
    state2.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state2.input.charCodeAt(state2.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state2.line;
      _lineStart = state2.lineStart;
      _lineIndent = state2.lineIndent;
      skipSeparationSpace(state2, false, -1);
      if (state2.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state2.input.charCodeAt(state2.position);
        continue;
      } else {
        state2.position = captureEnd;
        state2.line = _line;
        state2.lineStart = _lineStart;
        state2.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state2, captureStart, captureEnd, false);
      writeFoldedLines(state2, state2.line - _line);
      captureStart = captureEnd = state2.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state2.position + 1;
    }
    ch = state2.input.charCodeAt(++state2.position);
  }
  captureSegment(state2, captureStart, captureEnd, false);
  if (state2.result) {
    return true;
  }
  state2.kind = _kind;
  state2.result = _result;
  return false;
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 39) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 39) {
        captureStart = state2.position;
        state2.position++;
        captureEnd = state2.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a single quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp2, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 34) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state2, captureStart, state2.position, true);
      state2.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state2, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state2.result += simpleEscapeMap[ch];
        state2.position++;
      } else if ((tmp2 = escapedHexLen(ch)) > 0) {
        hexLength = tmp2;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state2.input.charCodeAt(++state2.position);
          if ((tmp2 = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp2;
          } else {
            throwError(state2, "expected hexadecimal character");
          }
        }
        state2.result += charFromCodepoint(hexResult);
        state2.position++;
      } else {
        throwError(state2, "unknown escape sequence");
      }
      captureStart = captureEnd = state2.position;
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a double quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(++state2.position);
  while (ch !== 0) {
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === terminator) {
      state2.position++;
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = isMapping ? "mapping" : "sequence";
      state2.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state2, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state2, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state2.position++;
        skipSeparationSpace(state2, true, nodeIndent);
      }
    }
    _line = state2.line;
    _lineStart = state2.lineStart;
    _pos = state2.position;
    composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state2.tag;
    keyNode = state2.result;
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if ((isExplicitPair || state2.line === _line) && ch === 58) {
      isPair = true;
      ch = state2.input.charCodeAt(++state2.position);
      skipSeparationSpace(state2, true, nodeIndent);
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state2.result;
    }
    if (isMapping) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 44) {
      readNext = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      readNext = false;
    }
  }
  throwError(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp2, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  while (ch !== 0) {
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state2, "repeat of a chomping mode identifier");
      }
    } else if ((tmp2 = fromDecimalCode(ch)) >= 0) {
      if (tmp2 === 0) {
        throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp2 - 1;
        detectedIndent = true;
      } else {
        throwError(state2, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state2);
    state2.lineIndent = 0;
    ch = state2.input.charCodeAt(state2.position);
    while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
      state2.lineIndent++;
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (!detectedIndent && state2.lineIndent > textIndent) {
      textIndent = state2.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state2.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state2.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state2.result += " ";
        }
      } else {
        state2.result += common.repeat("\n", emptyLines);
      }
    } else {
      state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state2.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, state2.position, false);
  }
  return true;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
  if (state2.firstTabInLine !== -1)
    return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state2.input.charCodeAt(state2.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state2.position++;
    if (skipSeparationSpace(state2, true, -1)) {
      if (state2.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state2.input.charCodeAt(state2.position);
        continue;
      }
    }
    _line = state2.line;
    composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state2.result);
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a sequence entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "sequence";
    state2.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state2.firstTabInLine !== -1)
    return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (!atExplicitKey && state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    following = state2.input.charCodeAt(state2.position + 1);
    _line = state2.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state2.position += 1;
      ch = following;
    } else {
      _keyLine = state2.line;
      _keyLineStart = state2.lineStart;
      _keyPos = state2.position;
      if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state2.line === _line) {
        ch = state2.input.charCodeAt(state2.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 58) {
          ch = state2.input.charCodeAt(++state2.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state2.tag;
          keyNode = state2.result;
        } else if (detected) {
          throwError(state2, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state2.tag = _tag;
        state2.anchor = _anchor;
        return true;
      }
    }
    if (state2.line === _line || state2.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
      }
      if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state2.result;
        } else {
          valueNode = state2.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a mapping entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "mapping";
    state2.result = _result;
  }
  return detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 33)
    return false;
  if (state2.tag !== null) {
    throwError(state2, "duplication of a tag property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state2.input.charCodeAt(++state2.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state2.input.charCodeAt(++state2.position);
  } else {
    tagHandle = "!";
  }
  _position = state2.position;
  if (isVerbatim) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (ch !== 0 && ch !== 62);
    if (state2.position < state2.length) {
      tagName = state2.input.slice(_position, state2.position);
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      throwError(state2, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state2.input.slice(_position - 1, state2.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state2, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state2.position + 1;
        } else {
          throwError(state2, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    tagName = state2.input.slice(_position, state2.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state2, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state2, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state2, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state2.tag = tagName;
  } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
    state2.tag = state2.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state2.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state2.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state2) {
  var _position, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 38)
    return false;
  if (state2.anchor !== null) {
    throwError(state2, "duplication of an anchor property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an anchor node must contain at least one character");
  }
  state2.anchor = state2.input.slice(_position, state2.position);
  return true;
}
function readAlias(state2) {
  var _position, alias, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 42)
    return false;
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an alias node must contain at least one character");
  }
  alias = state2.input.slice(_position, state2.position);
  if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
    throwError(state2, 'unidentified alias "' + alias + '"');
  }
  state2.result = state2.anchorMap[alias];
  skipSeparationSpace(state2, true, -1);
  return true;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state2.listener !== null) {
    state2.listener("open", state2);
  }
  state2.tag = null;
  state2.anchor = null;
  state2.kind = null;
  state2.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state2, true, -1)) {
      atNewLine = true;
      if (state2.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state2.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state2.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state2) || readAnchorProperty(state2)) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state2.position - state2.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state2)) {
          hasContent = true;
          if (state2.tag !== null || state2.anchor !== null) {
            throwError(state2, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state2.tag === null) {
            state2.tag = "?";
          }
        }
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
    }
  }
  if (state2.tag === null) {
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = state2.result;
    }
  } else if (state2.tag === "?") {
    if (state2.result !== null && state2.kind !== "scalar") {
      throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state2.implicitTypes[typeIndex];
      if (type2.resolve(state2.result)) {
        state2.result = type2.construct(state2.result);
        state2.tag = type2.tag;
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
        break;
      }
    }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
      type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    } else {
      type2 = null;
      typeList = state2.typeMap.multi[state2.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state2, "unknown tag !<" + state2.tag + ">");
    }
    if (state2.result !== null && type2.kind !== state2.kind) {
      throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
    }
    if (!type2.resolve(state2.result, state2.tag)) {
      throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
    } else {
      state2.result = type2.construct(state2.result, state2.tag);
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    }
  }
  if (state2.listener !== null) {
    state2.listener("close", state2);
  }
  return state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0)
      readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
    return;
  }
  if (state2.position < state2.length - 1) {
    throwError(state2, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options2) {
  input = String(input);
  options2 = options2 || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options2);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll$1(input, iterator, options2) {
  if (iterator !== null && typeof iterator === "object" && typeof options2 === "undefined") {
    options2 = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options2);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
    iterator(documents[index2]);
  }
}
function load$1(input, options2) {
  var documents = loadDocuments(input, options2);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var load = loader.load;
const createRequire = () => {
};
var browser = { exports: {} };
var process$1 = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker2) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker2);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker2);
  }
  try {
    return cachedClearTimeout(marker2);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker2);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker2);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process$1.nextTick = function(fun) {
  var args2 = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args2[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args2));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = true;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop() {
}
process$1.on = noop;
process$1.addListener = noop;
process$1.once = noop;
process$1.off = noop;
process$1.removeListener = noop;
process$1.removeAllListeners = noop;
process$1.emit = noop;
process$1.prependListener = noop;
process$1.prependOnceListener = noop;
process$1.listeners = function(name) {
  return [];
};
process$1.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var dist = {};
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var SUPPORTED_LOCALE$1 = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      \u0130: "i",
      I: "\u0131",
      I\u0307: "i"
    }
  },
  az: {
    regexp: /\u0130/g,
    map: {
      \u0130: "i",
      I: "\u0131",
      I\u0307: "i"
    }
  },
  lt: {
    regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
    map: {
      I: "i\u0307",
      J: "j\u0307",
      \u012E: "\u012F\u0307",
      \u00CC: "i\u0307\u0300",
      \u00CD: "i\u0307\u0301",
      \u0128: "i\u0307\u0303"
    }
  }
};
function localeLowerCase$1(str2, locale) {
  var lang = SUPPORTED_LOCALE$1[locale.toLowerCase()];
  if (lang)
    return lowerCase$1(str2.replace(lang.regexp, function(m) {
      return lang.map[m];
    }));
  return lowerCase$1(str2);
}
function lowerCase$1(str2) {
  return str2.toLowerCase();
}
var dist_es2015$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  localeLowerCase: localeLowerCase$1,
  lowerCase: lowerCase$1
}, Symbol.toStringTag, { value: "Module" }));
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
function noCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a2 = options2.splitRegexp, splitRegexp = _a2 === void 0 ? DEFAULT_SPLIT_REGEXP : _a2, _b = options2.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options2.transform, transform2 = _c === void 0 ? lowerCase$1 : _c, _d = options2.delimiter, delimiter = _d === void 0 ? " " : _d;
  var result2 = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  var start = 0;
  var end = result2.length;
  while (result2.charAt(start) === "\0")
    start++;
  while (result2.charAt(end - 1) === "\0")
    end--;
  return result2.slice(start, end).split("\0").map(transform2).join(delimiter);
}
function replace(input, re, value2) {
  if (re instanceof RegExp)
    return input.replace(re, value2);
  return re.reduce(function(input2, re2) {
    return input2.replace(re2, value2);
  }, input);
}
function pascalCaseTransform(input, index2) {
  var firstChar = input.charAt(0);
  var lowerChars = input.substr(1).toLowerCase();
  if (index2 > 0 && firstChar >= "0" && firstChar <= "9") {
    return "_" + firstChar + lowerChars;
  }
  return "" + firstChar.toUpperCase() + lowerChars;
}
function pascalCaseTransformMerge(input) {
  return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
}
function pascalCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return noCase$1(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options2));
}
function camelCaseTransform(input, index2) {
  if (index2 === 0)
    return input.toLowerCase();
  return pascalCaseTransform(input, index2);
}
function camelCaseTransformMerge(input, index2) {
  if (index2 === 0)
    return input.toLowerCase();
  return pascalCaseTransformMerge(input);
}
function camelCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return pascalCase$1(input, __assign({ transform: camelCaseTransform }, options2));
}
function upperCaseFirst$1(input) {
  return input.charAt(0).toUpperCase() + input.substr(1);
}
var dist_es2015$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  upperCaseFirst: upperCaseFirst$1
}, Symbol.toStringTag, { value: "Module" }));
function capitalCaseTransform(input) {
  return upperCaseFirst$1(input.toLowerCase());
}
function capitalCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return noCase$1(input, __assign({ delimiter: " ", transform: capitalCaseTransform }, options2));
}
var SUPPORTED_LOCALE = {
  tr: {
    regexp: /[\u0069]/g,
    map: {
      i: "\u0130"
    }
  },
  az: {
    regexp: /[\u0069]/g,
    map: {
      i: "\u0130"
    }
  },
  lt: {
    regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
    map: {
      i\u0307: "I",
      j\u0307: "J",
      \u012F\u0307: "\u012E",
      i\u0307\u0300: "\xCC",
      i\u0307\u0301: "\xCD",
      i\u0307\u0303: "\u0128"
    }
  }
};
function localeUpperCase$1(str2, locale) {
  var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
  if (lang)
    return upperCase$1(str2.replace(lang.regexp, function(m) {
      return lang.map[m];
    }));
  return upperCase$1(str2);
}
function upperCase$1(str2) {
  return str2.toUpperCase();
}
var dist_es2015$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  localeUpperCase: localeUpperCase$1,
  upperCase: upperCase$1
}, Symbol.toStringTag, { value: "Module" }));
function constantCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return noCase$1(input, __assign({ delimiter: "_", transform: upperCase$1 }, options2));
}
function dotCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return noCase$1(input, __assign({ delimiter: "." }, options2));
}
function headerCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return capitalCase$1(input, __assign({ delimiter: "-" }, options2));
}
function paramCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return dotCase$1(input, __assign({ delimiter: "-" }, options2));
}
function pathCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return dotCase$1(input, __assign({ delimiter: "/" }, options2));
}
function sentenceCaseTransform(input, index2) {
  var result2 = input.toLowerCase();
  if (index2 === 0)
    return upperCaseFirst$1(result2);
  return result2;
}
function sentenceCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return noCase$1(input, __assign({ delimiter: " ", transform: sentenceCaseTransform }, options2));
}
function snakeCase$1(input, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return dotCase$1(input, __assign({ delimiter: "_" }, options2));
}
var dist_es2015$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  camelCaseTransform,
  camelCaseTransformMerge,
  camelCase: camelCase$1,
  capitalCaseTransform,
  capitalCase: capitalCase$1,
  constantCase: constantCase$1,
  dotCase: dotCase$1,
  headerCase: headerCase$1,
  noCase: noCase$1,
  paramCase: paramCase$1,
  pascalCaseTransform,
  pascalCaseTransformMerge,
  pascalCase: pascalCase$1,
  pathCase: pathCase$1,
  sentenceCaseTransform,
  sentenceCase: sentenceCase$1,
  snakeCase: snakeCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$6);
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$9);
function lowerCaseFirst$1(input) {
  return input.charAt(0).toLowerCase() + input.substr(1);
}
var dist_es2015$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  lowerCaseFirst: lowerCaseFirst$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$5);
function spongeCase$1(input) {
  var result2 = "";
  for (var i2 = 0; i2 < input.length; i2++) {
    result2 += Math.random() > 0.5 ? input[i2].toUpperCase() : input[i2].toLowerCase();
  }
  return result2;
}
var dist_es2015$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  spongeCase: spongeCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$4);
function swapCase$1(input) {
  var result2 = "";
  for (var i2 = 0; i2 < input.length; i2++) {
    var lower = input[i2].toLowerCase();
    result2 += input[i2] === lower ? input[i2].toUpperCase() : lower;
  }
  return result2;
}
var dist_es2015$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  swapCase: swapCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$3);
var SMALL_WORDS = /\b(?:an?d?|a[st]|because|but|by|en|for|i[fn]|neither|nor|o[fnr]|only|over|per|so|some|tha[tn]|the|to|up|upon|vs?\.?|versus|via|when|with|without|yet)\b/i;
var TOKENS = /[^\s:–—-]+|./g;
var WHITESPACE = /\s/;
var IS_MANUAL_CASE = /.(?=[A-Z]|\..)/;
var ALPHANUMERIC_PATTERN = /[A-Za-z0-9\u00C0-\u00FF]/;
function titleCase$1(input) {
  var result2 = "";
  var m;
  while ((m = TOKENS.exec(input)) !== null) {
    var token = m[0], index2 = m.index;
    if (!IS_MANUAL_CASE.test(token) && (!SMALL_WORDS.test(token) || index2 === 0 || index2 + token.length === input.length) && (input.charAt(index2 + token.length) !== ":" || WHITESPACE.test(input.charAt(index2 + token.length + 1)))) {
      result2 += token.replace(ALPHANUMERIC_PATTERN, function(m2) {
        return m2.toUpperCase();
      });
      continue;
    }
    result2 += token;
  }
  return result2;
}
var dist_es2015$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  titleCase: titleCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$5 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$2);
var require$$6 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$7);
var require$$7 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$8);
function isUpperCase$1(input) {
  return input.toUpperCase() === input && input.toLowerCase() !== input;
}
var dist_es2015$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isUpperCase: isUpperCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015$1);
function isLowerCase$1(input) {
  return input.toLowerCase() === input && input.toUpperCase() !== input;
}
var dist_es2015 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isLowerCase: isLowerCase$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$9 = /* @__PURE__ */ getAugmentedNamespace(dist_es2015);
Object.defineProperty(dist, "__esModule", { value: true });
var isLowerCase = dist.isLowerCase = isUpperCase = dist.isUpperCase = upperCaseFirst = dist.upperCaseFirst = localeUpperCase = dist.localeUpperCase = upperCase = dist.upperCase = titleCase = dist.titleCase = swapCase = dist.swapCase = spongeCase = dist.spongeCase = lowerCaseFirst = dist.lowerCaseFirst = localeLowerCase = dist.localeLowerCase = lowerCase = dist.lowerCase = snakeCase = dist.snakeCase = sentenceCase = dist.sentenceCase = pathCase = dist.pathCase = pascalCase = dist.pascalCase = paramCase = dist.paramCase = noCase = dist.noCase = headerCase = dist.headerCase = dotCase = dist.dotCase = constantCase = dist.constantCase = capitalCase = dist.capitalCase = camelCase = dist.camelCase = void 0;
var changeCase = require$$0$1;
var lowerCase1 = require$$1;
var lowerCaseFirst1 = require$$2;
var spongeCase1 = require$$3;
var swapCase1 = require$$4;
var titleCase1 = require$$5;
var upperCase1 = require$$6;
var upperCaseFirst1 = require$$7;
var isUpperCase1 = require$$8;
var isLowerCase1 = require$$9;
var camelCase = dist.camelCase = changeCase.camelCase;
var capitalCase = dist.capitalCase = changeCase.capitalCase;
var constantCase = dist.constantCase = changeCase.constantCase;
var dotCase = dist.dotCase = changeCase.dotCase;
var headerCase = dist.headerCase = changeCase.headerCase;
var noCase = dist.noCase = changeCase.noCase;
var paramCase = dist.paramCase = changeCase.paramCase;
var pascalCase = dist.pascalCase = changeCase.pascalCase;
var pathCase = dist.pathCase = changeCase.pathCase;
var sentenceCase = dist.sentenceCase = changeCase.sentenceCase;
var snakeCase = dist.snakeCase = changeCase.snakeCase;
var lowerCase = dist.lowerCase = lowerCase1.lowerCase;
var localeLowerCase = dist.localeLowerCase = lowerCase1.localeLowerCase;
var lowerCaseFirst = dist.lowerCaseFirst = lowerCaseFirst1.lowerCaseFirst;
var spongeCase = dist.spongeCase = spongeCase1.spongeCase;
var swapCase = dist.swapCase = swapCase1.swapCase;
var titleCase = dist.titleCase = titleCase1.titleCase;
var upperCase = dist.upperCase = upperCase1.upperCase;
var localeUpperCase = dist.localeUpperCase = upperCase1.localeUpperCase;
var upperCaseFirst = dist.upperCaseFirst = upperCaseFirst1.upperCaseFirst;
var isUpperCase = dist.isUpperCase = isUpperCase1.isUpperCase;
isLowerCase = dist.isLowerCase = isLowerCase1.isLowerCase;
var changeCaseAll = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  get isLowerCase() {
    return isLowerCase;
  },
  get isUpperCase() {
    return isUpperCase;
  },
  get upperCaseFirst() {
    return upperCaseFirst;
  },
  get localeUpperCase() {
    return localeUpperCase;
  },
  get upperCase() {
    return upperCase;
  },
  get titleCase() {
    return titleCase;
  },
  get swapCase() {
    return swapCase;
  },
  get spongeCase() {
    return spongeCase;
  },
  get lowerCaseFirst() {
    return lowerCaseFirst;
  },
  get localeLowerCase() {
    return localeLowerCase;
  },
  get lowerCase() {
    return lowerCase;
  },
  get snakeCase() {
    return snakeCase;
  },
  get sentenceCase() {
    return sentenceCase;
  },
  get pathCase() {
    return pathCase;
  },
  get pascalCase() {
    return pascalCase;
  },
  get paramCase() {
    return paramCase;
  },
  get noCase() {
    return noCase;
  },
  get headerCase() {
    return headerCase;
  },
  get dotCase() {
    return dotCase;
  },
  get constantCase() {
    return constantCase;
  },
  get capitalCase() {
    return capitalCase;
  },
  get camelCase() {
    return camelCase;
  },
  "default": dist
}, [dist]);
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal || freeSelf || Function("return this")();
var _root = root$4;
var root$3 = _root;
var Symbol$3 = root$3.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var nativeObjectToString$1 = objectProto$a.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$8.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result2;
}
var _getRawTag = getRawTag$1;
var objectProto$9 = Object.prototype;
var nativeObjectToString = objectProto$9.toString;
function objectToString$1(value2) {
  return nativeObjectToString.call(value2);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$4(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
var _baseGetTag = baseGetTag$4;
function isObject$8(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$8;
var baseGetTag$3 = _baseGetTag, isObject$7 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value2) {
  if (!isObject$7(value2)) {
    return false;
  }
  var tag = baseGetTag$3(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$2 = _root;
var coreJsData$1 = root$2["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$6 = isObject_1, toSource = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value2) {
  if (!isObject$6(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction$2(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$3(object, key) {
  var value2 = getValue(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var _getNative = getNative$3;
var getNative$2 = _getNative, root$1 = _root;
var Map$3 = getNative$2(root$1, "Map");
var _Map = Map$3;
var getNative$1 = _getNative;
var nativeCreate$4 = getNative$1(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED$1 ? void 0 : result2;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value2) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$2 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result2 = getMapData$3(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value2) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var ListCache$1 = _ListCache, Map$1 = _Map, MapCache = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value2) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs2 = data.__data__;
    if (!Map$1 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
      pairs2.push([key, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs2);
  }
  data.set(key, value2);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
function assignMergeValue$2(object, key, value2) {
  if (value2 !== void 0 && !eq$2(object[key], value2) || value2 === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value2);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
(function(module2, exports2) {
  var root2 = _root;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result2);
    return result2;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var root = _root;
var Uint8Array$2 = root.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$1(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
  return result2;
}
var _cloneArrayBuffer = cloneArrayBuffer$1;
var cloneArrayBuffer = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
function copyArray$1(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$1;
var isObject$5 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$5(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var _baseCreate = baseCreate$1;
function overArg$1(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var objectProto$5 = Object.prototype;
function isPrototype$2(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value2 === proto;
}
var _isPrototype = isPrototype$2;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
function isObjectLike$5(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$2 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike$4(value2) && baseGetTag$2(value2) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$3 = isObjectLike_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$3(value2) && hasOwnProperty$4.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_1 = isArguments$2;
var isArray$2 = Array.isArray;
var isArray_1 = isArray$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$3(value2) {
  return value2 != null && isLength$1(value2.length) && !isFunction$1(value2);
}
var isArrayLike_1 = isArrayLike$3;
var isArrayLike$2 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value2) {
  return isObjectLike$2(value2) && isArrayLike$2(value2);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer3;
})(isBuffer$2, isBuffer$2.exports);
var baseGetTag$1 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$1 = isObjectLike_1;
var objectTag$1 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value2) {
  if (!isObjectLike$1(value2) || baseGetTag$1(value2) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
var baseGetTag = _baseGetTag, isLength = isLength_1, isObjectLike = isObjectLike_1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function assignValue$1(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$2.call(object, key) && eq$1(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value2);
  }
}
var _assignValue = assignValue$1;
var assignValue = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$1(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result2 = Array(n2);
  while (++index2 < n2) {
    result2[index2] = iteratee(index2);
  }
  return result2;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var _isIndex = isIndex$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$1 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex$1 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function arrayLikeKeys$1(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType2 = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes(value2.length, String) : [], length = result2.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$1.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$1(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
var _arrayLikeKeys = arrayLikeKeys$1;
function nativeKeysIn$1(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$4 = isObject_1, isPrototype = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$4(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$2(object) {
  return isArrayLike$1(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$2;
var copyObject = _copyObject, keysIn$1 = keysIn_1;
function toPlainObject$1(value2) {
  return copyObject(value2, keysIn$1(value2));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBuffer.exports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments = isArguments_1, isArray = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer = isBuffer$2.exports, isFunction = isFunction_1, isObject$3 = isObject_1, isPlainObject = isPlainObject_1, isTypedArray = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$2 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
function identity$2(value2) {
  return value2;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args2) {
  switch (args2.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args2[0]);
    case 2:
      return func.call(thisArg, args2[0], args2[1]);
    case 3:
      return func.call(thisArg, args2[0], args2[1], args2[2]);
  }
  return func.apply(thisArg, args2);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start, transform2) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args2 = arguments, index2 = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args2[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args2[index2];
    }
    otherArgs[start] = transform2(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value2) {
  return function() {
    return value2;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike = isArrayLike_1, isIndex = _isIndex, isObject$1 = isObject_1;
function isIterateeCall$1(value2, index2, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value2);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge, createAssigner = _createAssigner;
createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
const asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  var _a2, _b;
  let name;
  if ("alias" in a) {
    name = (_a2 = a.alias) === null || _a2 === void 0 ? void 0 : _a2.value;
  }
  if (name == null && "name" in a) {
    name = (_b = a.name) === null || _b === void 0 ? void 0 : _b.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}
let AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
  class AggregateErrorClass extends Error {
    constructor(errors, message = "") {
      super(message);
      this.errors = errors;
      this.name = "AggregateError";
      Error.captureStackTrace(this, AggregateErrorClass);
    }
  }
  AggregateErrorImpl = function(errors, message) {
    return new AggregateErrorClass(errors, message);
  };
} else {
  AggregateErrorImpl = AggregateError;
}
function isAggregateError(error2) {
  return "errors" in error2 && Array.isArray(error2["errors"]);
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatError(value2) {
  if (value2 instanceof GraphQLError) {
    return value2.toString();
  }
  return `${value2.name}: ${value2.message};
 ${value2.stack}`;
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (value2 instanceof Error) {
    if (isAggregateError(value2)) {
      return formatError(value2) + "\n" + formatArray(value2.errors, previouslySeenValues);
    }
    return formatError(value2);
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value2]) => key + ": " + formatValue(value2, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  return pathToDirectivesInExtensions.reduce((acc, pathSegment) => acc == null ? acc : acc[pathSegment], node === null || node === void 0 ? void 0 : node.extensions);
}
function astFromType(type2) {
  if (isNonNullType(type2)) {
    const innerType = astFromType(type2.ofType);
    if (innerType.kind === Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type2)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if (isListType(type2)) {
    return {
      kind: Kind.LIST_TYPE,
      type: astFromType(type2.ofType)
    };
  }
  return {
    kind: Kind.NAMED_TYPE,
    name: {
      kind: Kind.NAME,
      value: type2.name
    }
  };
}
function astFromValueUntyped(value2) {
  if (value2 === null) {
    return { kind: Kind.NULL };
  }
  if (value2 === void 0) {
    return null;
  }
  if (Array.isArray(value2)) {
    const valuesNodes = [];
    for (const item of value2) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: Kind.LIST, values: valuesNodes };
  }
  if (typeof value2 === "object") {
    const fieldNodes = [];
    for (const fieldName in value2) {
      const fieldValue = value2[fieldName];
      const ast = astFromValueUntyped(fieldValue);
      if (ast) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: { kind: Kind.NAME, value: fieldName },
          value: ast
        });
      }
    }
    return { kind: Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value2 === "boolean") {
    return { kind: Kind.BOOLEAN, value: value2 };
  }
  if (typeof value2 === "number" && isFinite(value2)) {
    const stringNum = String(value2);
    return integerStringRegExp.test(stringNum) ? { kind: Kind.INT, value: stringNum } : { kind: Kind.FLOAT, value: stringNum };
  }
  if (typeof value2 === "string") {
    return { kind: Kind.STRING, value: value2 };
  }
  throw new TypeError(`Cannot convert value to AST: ${value2}.`);
}
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
function memoize1(fn2) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn2(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
const getRootTypes = memoize1(function getRootTypes2(schema2) {
  const rootTypeMap = getRootTypeMap(schema2);
  return new Set(rootTypeMap.values());
});
const getRootTypeMap = memoize1(function getRootTypeMap2(schema2) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema2.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});
function getDocumentNodeFromSchema(schema2, options2 = {}) {
  const pathToDirectivesInExtensions = options2.pathToDirectivesInExtensions;
  const typesMap = schema2.getTypeMap();
  const schemaNode = astFromSchema(schema2, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives2 = schema2.getDirectives();
  for (const directive2 of directives2) {
    if (isSpecifiedDirective(directive2)) {
      continue;
    }
    definitions.push(astFromDirective(directive2, schema2, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type2 = typesMap[typeName];
    const isPredefinedScalar = isSpecifiedScalarType(type2);
    const isIntrospection = isIntrospectionType(type2);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if (isObjectType(type2)) {
      definitions.push(astFromObjectType(type2, schema2, pathToDirectivesInExtensions));
    } else if (isInterfaceType(type2)) {
      definitions.push(astFromInterfaceType(type2, schema2, pathToDirectivesInExtensions));
    } else if (isUnionType(type2)) {
      definitions.push(astFromUnionType(type2, schema2, pathToDirectivesInExtensions));
    } else if (isInputObjectType(type2)) {
      definitions.push(astFromInputObjectType(type2, schema2, pathToDirectivesInExtensions));
    } else if (isEnumType(type2)) {
      definitions.push(astFromEnumType(type2, schema2, pathToDirectivesInExtensions));
    } else if (isScalarType(type2)) {
      definitions.push(astFromScalarType(type2, schema2, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type2}.`);
    }
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
function printSchemaWithDirectives(schema2, options2 = {}) {
  const documentNode = getDocumentNodeFromSchema(schema2, options2);
  return print(documentNode);
}
function astFromSchema(schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  const operationTypeMap = /* @__PURE__ */ new Map([
    ["query", void 0],
    ["mutation", void 0],
    ["subscription", void 0]
  ]);
  const nodes = [];
  if (schema2.astNode != null) {
    nodes.push(schema2.astNode);
  }
  if (schema2.extensionASTNodes != null) {
    for (const extensionASTNode of schema2.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema2);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType2 = rootTypeMap.get(operationTypeNode);
    if (rootType2 != null) {
      const rootTypeAST = astFromType(rootType2);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives2 = getDirectiveNodes(schema2, schema2, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives2.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives: directives2
  };
  schemaNode.description = ((_b = (_a2 = schema2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : schema2.description != null) ? {
    kind: Kind.STRING,
    value: schema2.description,
    block: true
  } : void 0;
  return schemaNode;
}
function astFromDirective(directive2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b, _c, _d;
  return {
    kind: Kind.DIRECTIVE_DEFINITION,
    description: (_b = (_a2 = directive2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : directive2.description ? {
      kind: Kind.STRING,
      value: directive2.description
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: directive2.name
    },
    arguments: (_c = directive2.args) === null || _c === void 0 ? void 0 : _c.map((arg) => astFromArg(arg, schema2, pathToDirectivesInExtensions)),
    repeatable: directive2.isRepeatable,
    locations: ((_d = directive2.locations) === null || _d === void 0 ? void 0 : _d.map((location2) => ({
      kind: Kind.NAME,
      value: location2
    }))) || []
  };
}
function getDirectiveNodes(entity, schema2, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let nodes = [];
  if (entity.astNode != null) {
    nodes.push(entity.astNode);
  }
  if ("extensionASTNodes" in entity && entity.extensionASTNodes != null) {
    nodes = nodes.concat(entity.extensionASTNodes);
  }
  let directives2;
  if (directivesInExtensions != null) {
    directives2 = makeDirectiveNodes(schema2, directivesInExtensions);
  } else {
    directives2 = [];
    for (const node of nodes) {
      if (node.directives) {
        directives2.push(...node.directives);
      }
    }
  }
  return directives2;
}
function getDeprecatableDirectiveNodes(entity, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  let directiveNodesBesidesDeprecated = [];
  let deprecatedDirectiveNode = null;
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives2;
  if (directivesInExtensions != null) {
    directives2 = makeDirectiveNodes(schema2, directivesInExtensions);
  } else {
    directives2 = (_a2 = entity.astNode) === null || _a2 === void 0 ? void 0 : _a2.directives;
  }
  if (directives2 != null) {
    directiveNodesBesidesDeprecated = directives2.filter((directive2) => directive2.name.value !== "deprecated");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = (_b = directives2.filter((directive2) => directive2.name.value === "deprecated")) === null || _b === void 0 ? void 0 : _b[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  return deprecatedDirectiveNode == null ? directiveNodesBesidesDeprecated : [deprecatedDirectiveNode].concat(directiveNodesBesidesDeprecated);
}
function astFromArg(arg, schema2, pathToDirectivesInExtensions) {
  var _a2, _b, _c;
  return {
    kind: Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a2 = arg.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : arg.description ? {
      kind: Kind.STRING,
      value: arg.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    defaultValue: arg.defaultValue !== void 0 ? (_c = astFromValue(arg.defaultValue, arg.type)) !== null && _c !== void 0 ? _c : void 0 : void 0,
    directives: getDeprecatableDirectiveNodes(arg, schema2, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.OBJECT_TYPE_DEFINITION,
    description: (_b = (_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema2, pathToDirectivesInExtensions)),
    interfaces: Object.values(type2.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type2, schema2, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  const node = {
    kind: Kind.INTERFACE_TYPE_DEFINITION,
    description: (_b = (_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromField(field, schema2, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type2, schema2, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type2) {
    node.interfaces = Object.values(type2.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.UNION_TYPE_DEFINITION,
    description: (_b = (_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    directives: getDirectiveNodes(type2, schema2, pathToDirectivesInExtensions),
    types: type2.getTypes().map((type3) => astFromType(type3))
  };
}
function astFromInputObjectType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: (_b = (_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    fields: Object.values(type2.getFields()).map((field) => astFromInputField(field, schema2, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type2, schema2, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.ENUM_TYPE_DEFINITION,
    description: (_b = (_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    values: Object.values(type2.getValues()).map((value2) => astFromEnumValue(value2, schema2, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type2, schema2, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b, _c;
  const directivesInExtensions = getDirectivesInExtensions(type2, pathToDirectivesInExtensions);
  const directives2 = directivesInExtensions ? makeDirectiveNodes(schema2, directivesInExtensions) : ((_a2 = type2.astNode) === null || _a2 === void 0 ? void 0 : _a2.directives) || [];
  const specifiedByValue = type2["specifiedByUrl"] || type2["specifiedByURL"];
  if (specifiedByValue && !directives2.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives2.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: Kind.SCALAR_TYPE_DEFINITION,
    description: (_c = (_b = type2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.description ? {
      kind: Kind.STRING,
      value: type2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: type2.name
    },
    directives: directives2
  };
}
function astFromField(field, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.FIELD_DEFINITION,
    description: (_b = (_a2 = field.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema2, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema2, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema2, pathToDirectivesInExtensions) {
  var _a2, _b, _c;
  return {
    kind: Kind.INPUT_VALUE_DEFINITION,
    description: (_b = (_a2 = field.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : field.description ? {
      kind: Kind.STRING,
      value: field.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    directives: getDeprecatableDirectiveNodes(field, schema2, pathToDirectivesInExtensions),
    defaultValue: (_c = astFromValue(field.defaultValue, field.type)) !== null && _c !== void 0 ? _c : void 0
  };
}
function astFromEnumValue(value2, schema2, pathToDirectivesInExtensions) {
  var _a2, _b;
  return {
    kind: Kind.ENUM_VALUE_DEFINITION,
    description: (_b = (_a2 = value2.astNode) === null || _a2 === void 0 ? void 0 : _a2.description) !== null && _b !== void 0 ? _b : value2.description ? {
      kind: Kind.STRING,
      value: value2.description,
      block: true
    } : void 0,
    name: {
      kind: Kind.NAME,
      value: value2.name
    },
    directives: getDirectiveNodes(value2, schema2, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args2, directive2) {
  const directiveArguments = [];
  if (directive2 != null) {
    for (const arg of directive2.args) {
      const argName = arg.name;
      const argValue = args2[argName];
      if (argValue !== void 0) {
        const value2 = astFromValue(argValue, arg.type);
        if (value2) {
          directiveArguments.push({
            kind: Kind.ARGUMENT,
            name: {
              kind: Kind.NAME,
              value: argName
            },
            value: value2
          });
        }
      }
    }
  } else {
    for (const argName in args2) {
      const argValue = args2[argName];
      const value2 = astFromValueUntyped(argValue);
      if (value2) {
        directiveArguments.push({
          kind: Kind.ARGUMENT,
          name: {
            kind: Kind.NAME,
            value: argName
          },
          value: value2
        });
      }
    }
  }
  return {
    kind: Kind.DIRECTIVE,
    name: {
      kind: Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema2, directiveValues) {
  const directiveNodes = [];
  for (const directiveName in directiveValues) {
    const arrayOrSingleValue = directiveValues[directiveName];
    const directive2 = schema2 === null || schema2 === void 0 ? void 0 : schema2.getDirective(directiveName);
    if (Array.isArray(arrayOrSingleValue)) {
      for (const value2 of arrayOrSingleValue) {
        directiveNodes.push(makeDirectiveNode(directiveName, value2, directive2));
      }
    } else {
      directiveNodes.push(makeDirectiveNode(directiveName, arrayOrSingleValue, directive2));
    }
  }
  return directiveNodes;
}
async function validateGraphQlDocuments(schema2, documentFiles, effectiveRules = createDefaultRules()) {
  const allFragmentMap = /* @__PURE__ */ new Map();
  const documentFileObjectsToValidate = [];
  for (const documentFile of documentFiles) {
    if (documentFile.document) {
      const definitionsToValidate = [];
      for (const definitionNode of documentFile.document.definitions) {
        if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {
          allFragmentMap.set(definitionNode.name.value, definitionNode);
        } else {
          definitionsToValidate.push(definitionNode);
        }
      }
      documentFileObjectsToValidate.push({
        location: documentFile.location,
        document: {
          kind: Kind.DOCUMENT,
          definitions: definitionsToValidate
        }
      });
    }
  }
  const allErrors = [];
  const allFragmentsDocument = {
    kind: Kind.DOCUMENT,
    definitions: [...allFragmentMap.values()]
  };
  await Promise.all(documentFileObjectsToValidate.map(async (documentFile) => {
    const documentToValidate = concatAST([allFragmentsDocument, documentFile.document]);
    const errors = validate(schema2, documentToValidate, effectiveRules);
    if (errors.length > 0) {
      allErrors.push({
        filePath: documentFile.location,
        errors
      });
    }
  }));
  return allErrors;
}
function checkValidationErrors(loadDocumentErrors) {
  if (loadDocumentErrors.length > 0) {
    const errors = [];
    for (const loadDocumentError of loadDocumentErrors) {
      for (const graphQLError of loadDocumentError.errors) {
        const error2 = new Error();
        error2.name = "GraphQLDocumentError";
        error2.message = `${error2.name}: ${graphQLError.message}`;
        error2.stack = error2.message;
        if (graphQLError.locations) {
          for (const location2 of graphQLError.locations) {
            error2.stack += `
    at ${loadDocumentError.filePath}:${location2.line}:${location2.column}`;
          }
        }
        errors.push(error2);
      }
    }
    throw new AggregateErrorImpl(errors, `GraphQL Document Validation failed with ${errors.length} errors;
  ${errors.map((error2, index2) => `Error ${index2}: ${error2.stack}`).join("\n\n")}`);
  }
}
function createDefaultRules() {
  let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
  if (versionInfo.major < 15) {
    ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
  }
  return specifiedRules.filter((f) => !ignored.includes(f.name));
}
const MAX_LINE_LENGTH = 80;
let commentsRegistry = {};
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  var _a2;
  const entityName = (_a2 = node.name) === null || _a2 === void 0 ? void 0 : _a2.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value2 of node.values) {
          pushComment(value2, entityName, value2.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys2 = [entity];
  if (field) {
    keys2.push(field);
    if (argument) {
      keys2.push(argument);
    }
  }
  const path2 = keys2.join(".");
  if (!commentsRegistry[path2]) {
    commentsRegistry[path2] = [];
  }
  commentsRegistry[path2].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x2) => x2).join(separator || "") : "";
}
function hasMultilineItems(maybeArray) {
  var _a2;
  return (_a2 = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str2) => str2.includes("\n"))) !== null && _a2 !== void 0 ? _a2 : false;
}
function addDescription(cb) {
  return (node, _key, _parent, path2, ancestors) => {
    var _a2;
    const keys2 = [];
    const parent = path2.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys2.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys2, (_a2 = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a2 === void 0 ? void 0 : _a2.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path2, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block(array) {
  return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
}
function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
}
function printBlockString(value2, isDescription = false) {
  const escaped = value2.replace(/"""/g, '\\"""');
  return (value2[0] === " " || value2[0] === "	") && value2.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
const printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: { leave: ({ selections }) => block(selections) },
  Field: {
    leave({ alias, name, arguments: args2, directives: directives2, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args2, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args2, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value: value2 }) => name + ": " + value2 },
  FragmentSpread: {
    leave: ({ name, directives: directives2 }) => "..." + name + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives2, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives: directives2, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives2, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value: value2 }) => value2 },
  FloatValue: { leave: ({ value: value2 }) => value2 },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value2);
      }
      return JSON.stringify(value2);
    }
  },
  BooleanValue: { leave: ({ value: value2 }) => value2 ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value: value2 }) => value2 },
  ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields: fields8 }) => "{" + join(fields8, ", ") + "}" },
  ObjectField: { leave: ({ name, value: value2 }) => name + ": " + value2 },
  Directive: {
    leave: ({ name, arguments: args2 }) => "@" + name + wrap("(", join(args2, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type: type2 }) => "[" + type2 + "]" },
  NonNullType: { leave: ({ type: type2 }) => type2 + "!" },
  SchemaDefinition: {
    leave: ({ directives: directives2, operationTypes }) => join(["schema", join(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives: directives2 }) => join(["scalar", name, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives: directives2, fields: fields8 }) => join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives2, " "), block(fields8)], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args2, type: type2, directives: directives2 }) => name + (hasMultilineItems(args2) ? wrap("(\n", indent(join(args2, "\n")), "\n)") : wrap("(", join(args2, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type: type2, defaultValue, directives: directives2 }) => join([name + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives: directives2, fields: fields8 }) => join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives2, " "), block(fields8)], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives: directives2, types }) => join(["union", name, join(directives2, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives: directives2, values }) => join(["enum", name, join(directives2, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives: directives2 }) => join([name, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives: directives2, fields: fields8 }) => join(["input", name, join(directives2, " "), block(fields8)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args2, repeatable, locations }) => "directive @" + name + (hasMultilineItems(args2) ? wrap("(\n", indent(join(args2, "\n")), "\n)") : wrap("(", join(args2, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(["extend schema", join(directives2, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives: directives2 }) => join(["extend scalar", name, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields: fields8 }) => join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives2, " "), block(fields8)], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives: directives2, fields: fields8 }) => join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives2, " "), block(fields8)], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives: directives2, types }) => join(["extend union", name, join(directives2, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives: directives2, values }) => join(["extend enum", name, join(directives2, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives: directives2, fields: fields8 }) => join(["extend input", name, join(directives2, " "), block(fields8)], " ")
  }
};
const printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => __spreadProps2(__spreadValues2({}, prev), {
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function printWithComments(ast) {
  return visit(ast, printDocASTReducerWithComments);
}
function isFieldDefinitionNode(node) {
  return node.kind === "FieldDefinition";
}
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== void 0) {
    return dedentBlockStringValue(`
${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value2 = String(token.value);
    comments.push(value2);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i2 = 1; i2 < lines.length; i2++) {
    const line = lines[i2];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str2) {
  let i2 = 0;
  while (i2 < str2.length && (str2[i2] === " " || str2[i2] === "	")) {
    i2++;
  }
  return i2;
}
function isBlank(str2) {
  return leadingWhitespace(str2) === str2.length;
}
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));
function getObjectTypeFromTypeMap(typeMap, type2) {
  if (type2) {
    const maybeObjectType = typeMap[type2.name];
    if (isObjectType(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}
function isNamedStub(type2) {
  if ("getFields" in type2) {
    const fields8 = type2.getFields();
    for (const fieldName in fields8) {
      const field = fields8[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type2) {
  switch (type2.name) {
    case GraphQLInt.name:
      return GraphQLInt;
    case GraphQLFloat.name:
      return GraphQLFloat;
    case GraphQLString.name:
      return GraphQLString;
    case GraphQLBoolean.name:
      return GraphQLBoolean;
    case GraphQLID.name:
      return GraphQLID;
    default:
      return type2;
  }
}
function rewireTypes(originalTypeMap, directives2) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      throw new Error(`Duplicate schema type name ${newName}`);
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives2.map((directive2) => rewireDirective(directive2));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive2) {
    if (isSpecifiedDirective(directive2)) {
      return directive2;
    }
    const directiveConfig = directive2.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args2) {
    const rewiredArgs = {};
    for (const argName in args2) {
      const arg = args2[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type2) {
    if (isObjectType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps2(__spreadValues2({}, config2), {
        fields: () => rewireFields(config2.fields),
        interfaces: () => rewireNamedTypes(config2.interfaces)
      });
      return new GraphQLObjectType(newConfig);
    } else if (isInterfaceType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps2(__spreadValues2({}, config2), {
        fields: () => rewireFields(config2.fields)
      });
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new GraphQLInterfaceType(newConfig);
    } else if (isUnionType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps2(__spreadValues2({}, config2), {
        types: () => rewireNamedTypes(config2.types)
      });
      return new GraphQLUnionType(newConfig);
    } else if (isInputObjectType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps2(__spreadValues2({}, config2), {
        fields: () => rewireInputFields(config2.fields)
      });
      return new GraphQLInputObjectType(newConfig);
    } else if (isEnumType(type2)) {
      const enumConfig = type2.toConfig();
      return new GraphQLEnumType(enumConfig);
    } else if (isScalarType(type2)) {
      if (isSpecifiedScalarType(type2)) {
        return type2;
      }
      const scalarConfig = type2.toConfig();
      return new GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type2}`);
  }
  function rewireFields(fields8) {
    const rewiredFields = {};
    for (const fieldName in fields8) {
      const field = fields8[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields8) {
    const rewiredFields = {};
    for (const fieldName in fields8) {
      const field = fields8[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type2) {
    if (isListType(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new GraphQLList(rewiredType) : null;
    } else if (isNonNullType(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;
    } else if (isNamedType(type2)) {
      let rewiredType = referenceTypeMap[type2.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type2) ? getBuiltInForStub(type2) : rewireNamedType(type2);
        newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}
function transformInputValue(type2, value2, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value2 == null) {
    return value2;
  }
  const nullableType = getNullableType(type2);
  if (isLeafType(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value2) : value2;
  } else if (isListType(nullableType)) {
    return value2.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if (isInputObjectType(nullableType)) {
    const fields8 = nullableType.getFields();
    const newValue = {};
    for (const key in value2) {
      const field = fields8[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value2[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type2, value2) {
  return transformInputValue(type2, value2, (t, v) => t.serialize(v));
}
function parseInputValue(type2, value2) {
  return transformInputValue(type2, value2, (t, v) => t.parseValue(v));
}
function mapSchema(schema2, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema2.getTypeMap(), schema2, serializeInputValue), schema2, schemaMapper, (type2) => isLeafType(type2)), schema2, schemaMapper), schema2, parseInputValue), schema2, schemaMapper, (type2) => !isLeafType(type2)), schema2, schemaMapper), schema2, schemaMapper);
  const originalDirectives = schema2.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema2, schemaMapper);
  const { typeMap, directives: directives2 } = rewireTypes(newTypeMap, newDirectives);
  return new GraphQLSchema(__spreadProps2(__spreadValues2({}, schema2.toConfig()), {
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema2.getSubscriptionType())),
    types: Object.values(typeMap),
    directives: directives2
  }));
}
function mapTypes(originalTypeMap, schema2, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema2, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema2);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema2, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema2, {
    [MapperKind.ENUM_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema2, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new GraphQLEnumType(__spreadProps2(__spreadValues2({}, config2), {
        values: newEnumValueConfigMap
      })));
    }
  }, (type2) => isEnumType(type2));
}
function mapDefaultValues(originalTypeMap, schema2, fn2) {
  const newTypeMap = mapArguments(originalTypeMap, schema2, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return __spreadProps2(__spreadValues2({}, argumentConfig), {
          defaultValue: fn2(maybeNewType, argumentConfig.defaultValue)
        });
      }
    }
  });
  return mapFields(newTypeMap, schema2, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return __spreadProps2(__spreadValues2({}, inputFieldConfig), {
          defaultValue: fn2(maybeNewType, inputFieldConfig.defaultValue)
        });
      }
    }
  });
}
function getNewType(newTypeMap, type2) {
  if (isListType(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new GraphQLList(newType) : null;
  } else if (isNonNullType(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new GraphQLNonNull(newType) : null;
  } else if (isNamedType(type2)) {
    const newType = newTypeMap[type2.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema2, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema2);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = __spreadProps2(__spreadValues2({}, newFieldConfig.astNode), {
              name: __spreadProps2(__spreadValues2({}, newFieldConfig.astNode.name), {
                value: newFieldName
              })
            });
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        })));
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        })));
      } else {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        })));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema2, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema2);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = __spreadProps2(__spreadValues2({}, originalFieldConfig), {
          args: newArgumentConfigMap
        });
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = new GraphQLObjectType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        }));
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = new GraphQLInterfaceType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = new GraphQLInputObjectType(__spreadProps2(__spreadValues2({}, config2), {
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema2, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive2 of originalDirectives) {
    const mappedDirective = directiveMapper(directive2, schema2);
    if (mappedDirective === void 0) {
      newDirectives.push(directive2);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema2, typeName) {
  var _a2, _b, _c;
  const type2 = schema2.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if (isObjectType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === ((_a2 = schema2.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === ((_b = schema2.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === ((_c = schema2.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if (isInputObjectType(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if (isInterfaceType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if (isUnionType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if (isEnumType(type2)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if (isScalarType(type2)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema2, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema2, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next2 = stack.pop();
    typeMapper = schemaMapper[next2];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema2, typeName) {
  var _a2, _b, _c;
  const type2 = schema2.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if (isObjectType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === ((_a2 = schema2.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema2.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c = schema2.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if (isInterfaceType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if (isInputObjectType(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema2, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema2, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next2 = stack.pop();
    fieldMapper = schemaMapper[next2];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type2) {
  if (isObjectType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields8 = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields8.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        fields: fields8
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps2(__spreadValues2({}, node), {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLObjectType(config2);
  } else if (isInterfaceType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields8 = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields8.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        fields: fields8
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps2(__spreadValues2({}, node), {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInterfaceType(config2);
  } else if (isInputObjectType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields8 = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields8.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields: fields8
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps2(__spreadValues2({}, node), {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInputObjectType(config2);
  } else if (isEnumType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
        values
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps2(__spreadValues2({}, node), {
        values: void 0
      }));
    }
    return new GraphQLEnumType(config2);
  } else {
    return type2;
  }
}
function healSchema(schema2) {
  healTypes(schema2.getTypeMap(), schema2.getDirectives());
  return schema2;
}
function healTypes(originalTypeMap, directives2) {
  const actualNamedTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualName in actualNamedTypeMap) {
      throw new Error(`Duplicate schema type name ${actualName}`);
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives2) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type2) {
    if (isObjectType(type2)) {
      healFields(type2);
      healInterfaces(type2);
      return;
    } else if (isInterfaceType(type2)) {
      healFields(type2);
      if ("getInterfaces" in type2) {
        healInterfaces(type2);
      }
      return;
    } else if (isUnionType(type2)) {
      healUnderlyingTypes(type2);
      return;
    } else if (isInputObjectType(type2)) {
      healInputFields(type2);
      return;
    } else if (isLeafType(type2)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type2}`);
  }
  function healFields(type2) {
    const fieldMap = type2.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type2) {
    if ("getInterfaces" in type2) {
      const interfaces = type2.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type2) {
    const fieldMap = type2.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type2) {
    const types = type2.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type2) {
    if (isListType(type2)) {
      const healedType = healType(type2.ofType);
      return healedType != null ? new GraphQLList(healedType) : null;
    } else if (isNonNullType(type2)) {
      const healedType = healType(type2.ofType);
      return healedType != null ? new GraphQLNonNull(healedType) : null;
    } else if (isNamedType(type2)) {
      const officialType = originalTypeMap[type2.name];
      if (officialType && type2 !== officialType) {
        return officialType;
      }
    }
    return type2;
  }
}
function getResolversFromSchema(schema2) {
  var _a2, _b;
  const resolvers = /* @__PURE__ */ Object.create(null);
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    if (!typeName.startsWith("__")) {
      const type2 = typeMap[typeName];
      if (isScalarType(type2)) {
        if (!isSpecifiedScalarType(type2)) {
          const config2 = type2.toConfig();
          delete config2.astNode;
          resolvers[typeName] = new GraphQLScalarType(config2);
        }
      } else if (isEnumType(type2)) {
        resolvers[typeName] = {};
        const values = type2.getValues();
        for (const value2 of values) {
          resolvers[typeName][value2.name] = value2.value;
        }
      } else if (isInterfaceType(type2)) {
        if (type2.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type2.resolveType
          };
        }
      } else if (isUnionType(type2)) {
        if (type2.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type2.resolveType
          };
        }
      } else if (isObjectType(type2)) {
        resolvers[typeName] = {};
        if (type2.isTypeOf != null) {
          resolvers[typeName].__isTypeOf = type2.isTypeOf;
        }
        const fields8 = type2.getFields();
        for (const fieldName in fields8) {
          const field = fields8[fieldName];
          if (field.subscribe != null) {
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].subscribe = field.subscribe;
          }
          if (field.resolve != null && ((_a2 = field.resolve) === null || _a2 === void 0 ? void 0 : _a2.name) !== "defaultFieldResolver" && ((_b = field.resolve) === null || _b === void 0 ? void 0 : _b.name) !== "defaultMergedResolver") {
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].resolve = field.resolve;
          }
        }
      }
    }
  }
  return resolvers;
}
function forEachField(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if (!getNamedType(type2).name.startsWith("__") && isObjectType(type2)) {
      const fields8 = type2.getFields();
      for (const fieldName in fields8) {
        const field = fields8[fieldName];
        fn2(field, typeName, fieldName);
      }
    }
  }
}
function forEachDefaultValue(schema2, fn2) {
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if (!getNamedType(type2).name.startsWith("__")) {
      if (isObjectType(type2)) {
        const fields8 = type2.getFields();
        for (const fieldName in fields8) {
          const field = fields8[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn2(arg.type, arg.defaultValue);
          }
        }
      } else if (isInputObjectType(type2)) {
        const fields8 = type2.getFields();
        for (const fieldName in fields8) {
          const field = fields8[fieldName];
          field.defaultValue = fn2(field.type, field.defaultValue);
        }
      }
    }
  }
}
function pruneSchema(schema2, options2 = {}) {
  const pruningContext = createPruningContext(schema2);
  visitTypes(pruningContext);
  const types = Object.values(schema2.getTypeMap());
  const typesToPrune = /* @__PURE__ */ new Set();
  for (const type2 of types) {
    if (type2.name.startsWith("__")) {
      continue;
    }
    if (options2.skipPruning && options2.skipPruning(type2)) {
      continue;
    }
    if (isObjectType(type2) || isInputObjectType(type2)) {
      if (!Object.keys(type2.getFields()).length && !options2.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type2.name] && !options2.skipUnusedTypesPruning) {
        typesToPrune.add(type2.name);
      }
    } else if (isUnionType(type2)) {
      if (!type2.getTypes().length && !options2.skipEmptyUnionPruning || pruningContext.unusedTypes[type2.name] && !options2.skipUnusedTypesPruning) {
        typesToPrune.add(type2.name);
      }
    } else if (isInterfaceType(type2)) {
      const implementations = getImplementations(pruningContext, type2);
      if (!Object.keys(type2.getFields()).length && !options2.skipEmptyCompositeTypePruning || implementations && !Object.keys(implementations).length && !options2.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type2.name] && !options2.skipUnusedTypesPruning) {
        typesToPrune.add(type2.name);
      }
    } else {
      if (pruningContext.unusedTypes[type2.name] && !options2.skipUnusedTypesPruning) {
        typesToPrune.add(type2.name);
      }
    }
  }
  const prunedSchema = mapSchema(schema2, {
    [MapperKind.TYPE]: (type2) => {
      if (typesToPrune.has(type2.name)) {
        return null;
      }
    }
  });
  return typesToPrune.size ? pruneSchema(prunedSchema, options2) : prunedSchema;
}
function visitOutputType(visitedTypes, pruningContext, type2) {
  if (visitedTypes[type2.name]) {
    return;
  }
  visitedTypes[type2.name] = true;
  pruningContext.unusedTypes[type2.name] = false;
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const fields8 = type2.getFields();
    for (const fieldName in fields8) {
      const field = fields8[fieldName];
      const namedType = getNamedType(field.type);
      visitOutputType(visitedTypes, pruningContext, namedType);
      for (const arg of field.args) {
        const type3 = getNamedType(arg.type);
        visitInputType(visitedTypes, pruningContext, type3);
      }
    }
    if (isInterfaceType(type2)) {
      const implementations = getImplementations(pruningContext, type2);
      if (implementations) {
        for (const typeName in implementations) {
          visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));
        }
      }
    }
    if ("getInterfaces" in type2) {
      for (const iFace of type2.getInterfaces()) {
        visitOutputType(visitedTypes, pruningContext, iFace);
      }
    }
  } else if (isUnionType(type2)) {
    const types = type2.getTypes();
    for (const type3 of types) {
      visitOutputType(visitedTypes, pruningContext, type3);
    }
  }
}
function createPruningContext(schema2) {
  const pruningContext = {
    schema: schema2,
    unusedTypes: /* @__PURE__ */ Object.create(null),
    implementations: /* @__PURE__ */ Object.create(null)
  };
  for (const typeName in schema2.getTypeMap()) {
    const type2 = schema2.getType(typeName);
    if (type2 && "getInterfaces" in type2) {
      for (const iface of type2.getInterfaces()) {
        const implementations = getImplementations(pruningContext, iface);
        if (implementations == null) {
          pruningContext.implementations[iface.name] = /* @__PURE__ */ Object.create(null);
        }
        pruningContext.implementations[iface.name][type2.name] = true;
      }
    }
  }
  return pruningContext;
}
function getImplementations(pruningContext, type2) {
  return pruningContext.implementations[type2.name];
}
function visitInputType(visitedTypes, pruningContext, type2) {
  if (visitedTypes[type2.name]) {
    return;
  }
  pruningContext.unusedTypes[type2.name] = false;
  visitedTypes[type2.name] = true;
  if (isInputObjectType(type2)) {
    const fields8 = type2.getFields();
    for (const fieldName in fields8) {
      const field = fields8[fieldName];
      const namedType = getNamedType(field.type);
      visitInputType(visitedTypes, pruningContext, namedType);
    }
  }
}
function visitTypes(pruningContext) {
  const schema2 = pruningContext.schema;
  for (const typeName in schema2.getTypeMap()) {
    if (!typeName.startsWith("__")) {
      pruningContext.unusedTypes[typeName] = true;
    }
  }
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const rootTypes = getRootTypes(schema2);
  for (const rootType2 of rootTypes) {
    visitOutputType(visitedTypes, pruningContext, rootType2);
  }
  for (const directive2 of schema2.getDirectives()) {
    for (const arg of directive2.args) {
      const type2 = getNamedType(arg.type);
      visitInputType(visitedTypes, pruningContext, type2);
    }
  }
}
function mergeDeep(sources, respectPrototype = false) {
  const target = sources[0] || {};
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(target)));
  }
  for (const source of sources) {
    if (isObject(target) && isObject(source)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source) {
        if (isObject(source[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source[key] });
          } else {
            output[key] = mergeDeep([output[key], source[key]], respectPrototype);
          }
        } else {
          Object.assign(output, { [key]: source[key] });
        }
      }
    }
  }
  return output;
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === Kind.DOCUMENT;
}
function resolveExternalModuleAndFn(pointer) {
  if (typeof pointer === "function") {
    return pointer;
  }
  let [moduleName, functionName] = pointer.split("#");
  if (moduleName === "change-case") {
    moduleName = "change-case-all";
  }
  let loadedModule;
  if (moduleName === "change-case-all") {
    loadedModule = changeCaseAll;
  } else {
    const cwdRequire = createRequire(browser.exports.cwd() + "/index.js");
    loadedModule = cwdRequire(moduleName);
    if (!(functionName in loadedModule) && typeof loadedModule !== "function") {
      throw new Error(`${functionName} couldn't be found in module ${moduleName}!`);
    }
  }
  return loadedModule[functionName] || loadedModule;
}
function isComplexPluginOutput(obj2) {
  return typeof obj2 === "object" && obj2.hasOwnProperty("content");
}
function isWrapperType(t) {
  return isListType(t) || isNonNullType(t);
}
function getBaseType(type2) {
  if (isWrapperType(type2)) {
    return getBaseType(type2.ofType);
  } else {
    return type2;
  }
}
function removeNonNullWrapper(type2) {
  return isNonNullType(type2) ? type2.ofType : type2;
}
const federationSpec = parse$6(`
  scalar _FieldSet

  directive @external on FIELD_DEFINITION
  directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
  directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
  directive @key(fields: _FieldSet!) on OBJECT | INTERFACE
`);
function removeFederation(schema2) {
  return mapSchema(schema2, {
    [MapperKind.QUERY]: (queryType) => {
      const queryTypeConfig = queryType.toConfig();
      delete queryTypeConfig.fields._entities;
      delete queryTypeConfig.fields._service;
      return new GraphQLObjectType(queryTypeConfig);
    },
    [MapperKind.UNION_TYPE]: (unionType) => {
      const unionTypeName = unionType.name;
      if (unionTypeName === "_Entity" || unionTypeName === "_Any") {
        return null;
      }
      return unionType;
    },
    [MapperKind.OBJECT_TYPE]: (objectType) => {
      if (objectType.name === "_Service") {
        return null;
      }
      return objectType;
    }
  });
}
class DetailedError extends Error {
  constructor(message, details, source) {
    super(message);
    this.message = message;
    this.details = details;
    this.source = source;
    Object.setPrototypeOf(this, DetailedError.prototype);
    Error.captureStackTrace(this, DetailedError);
  }
}
const getCachedDocumentNodeFromSchema = memoize1(getDocumentNodeFromSchema);
function oldVisit(root2, _a2) {
  var _b = _a2, { enter: enterVisitors, leave: leaveVisitors } = _b, newVisitor = __objRest(_b, ["enter", "leave"]);
  if (typeof enterVisitors === "object") {
    for (const key in enterVisitors) {
      newVisitor[key] = newVisitor[key] || {};
      newVisitor[key].enter = enterVisitors[key];
    }
  }
  if (typeof leaveVisitors === "object") {
    for (const key in leaveVisitors) {
      newVisitor[key] = newVisitor[key] || {};
      newVisitor[key].leave = leaveVisitors[key];
    }
  }
  return visit(root2, newVisitor);
}
function createNoopProfiler() {
  return {
    run(fn2) {
      return Promise.resolve().then(() => fn2());
    },
    collect() {
      return [];
    }
  };
}
function mergeResolvers(resolversDefinitions, options2) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers = new Array();
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers.push(resolversDefinition);
    }
  }
  const result2 = mergeDeep(resolvers, true);
  if (options2 === null || options2 === void 0 ? void 0 : options2.exclusions) {
    for (const exclusion of options2.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result2[typeName];
      } else if (result2[typeName]) {
        delete result2[typeName][fieldName];
      }
    }
  }
  return result2;
}
function mergeArguments(args1, args2, config2) {
  const result2 = deduplicateArguments([...args2, ...args1].filter(isSome));
  if (config2 && config2.sort) {
    result2.sort(compareNodes);
  }
  return result2;
}
function deduplicateArguments(args2) {
  return args2.reduce((acc, current) => {
    const dup = acc.find((arg) => arg.name.value === current.name.value);
    if (!dup) {
      return acc.concat([current]);
    }
    return acc;
  }, []);
}
function directiveAlreadyExists(directivesArr, otherDirective) {
  return !!directivesArr.find((directive2) => directive2.name.value === otherDirective.name.value);
}
function nameAlreadyExists(name, namesArr) {
  return namesArr.some(({ value: value2 }) => value2 === name.value);
}
function mergeArguments$1(a1, a2) {
  const result2 = [...a2];
  for (const argument of a1) {
    const existingIndex = result2.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result2[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source, target, (targetVal, source2) => {
          const value2 = targetVal.value;
          return !value2 || !source2.some((sourceVal) => sourceVal.value === value2);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result2.push(argument);
    }
  }
  return result2;
}
function deduplicateDirectives(directives2) {
  return directives2.map((directive2, i2, all) => {
    const firstAt = all.findIndex((d) => d.name.value === directive2.name.value);
    if (firstAt !== i2) {
      const dup = all[firstAt];
      directive2.arguments = mergeArguments$1(directive2.arguments, dup.arguments);
      return null;
    }
    return directive2;
  }).filter(isSome);
}
function mergeDirectives(d1 = [], d2 = [], config2) {
  const reverseOrder = config2 && config2.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result2 = deduplicateDirectives([...asNext]);
  for (const directive2 of asFirst) {
    if (directiveAlreadyExists(result2, directive2)) {
      const existingDirectiveIndex = result2.findIndex((d) => d.name.value === directive2.name.value);
      const existingDirective = result2[existingDirectiveIndex];
      result2[existingDirectiveIndex].arguments = mergeArguments$1(directive2.arguments || [], existingDirective.arguments || []);
    } else {
      result2.push(directive2);
    }
  }
  return result2;
}
function validateInputs(node, existingNode) {
  const printedNode = print(__spreadProps2(__spreadValues2({}, node), {
    description: void 0
  }));
  const printedExistingNode = print(__spreadProps2(__spreadValues2({}, existingNode), {
    description: void 0
  }));
  const leaveInputs = new RegExp("(directive @w*d*)|( on .*$)", "g");
  const sameArguments2 = printedNode.replace(leaveInputs, "") === printedExistingNode.replace(leaveInputs, "");
  if (!sameArguments2) {
    throw new Error(`Unable to merge GraphQL directive "${node.name.value}". 
Existing directive:  
	${printedExistingNode} 
Received directive: 
	${printedNode}`);
  }
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    validateInputs(node, existingNode);
    return __spreadProps2(__spreadValues2({}, node), {
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    });
  }
  return node;
}
function deduplicateLists(source, target, filterFn) {
  return source.concat(target.filter((val) => filterFn(val, source)));
}
function mergeEnumValues(first, second, config2) {
  if (config2 === null || config2 === void 0 ? void 0 : config2.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = /* @__PURE__ */ new Map();
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result2 = [...enumValueMap.values()];
  if (config2 && config2.sort) {
    result2.sort(compareNodes);
  }
  return result2;
}
function mergeEnum(e1, e2, config2) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config2),
      values: mergeEnumValues(e1.values, e2.values, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, e1), {
    kind: Kind.ENUM_TYPE_DEFINITION
  }) : e1;
}
function isStringTypes(types) {
  return typeof types === "string";
}
function isSourceTypes(types) {
  return types instanceof Source;
}
function extractType(type2) {
  let visitedType = type2;
  while (visitedType.kind === Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type2) {
  return type2.kind !== Kind.NAMED_TYPE;
}
function isListTypeNode(type2) {
  return type2.kind === Kind.LIST_TYPE;
}
function isNonNullTypeNode(type2) {
  return type2.kind === Kind.NON_NULL_TYPE;
}
function printTypeNode(type2) {
  if (isListTypeNode(type2)) {
    return `[${printTypeNode(type2.type)}]`;
  }
  if (isNonNullTypeNode(type2)) {
    return `${printTypeNode(type2.type)}!`;
  }
  return type2.name.value;
}
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
function fieldAlreadyExists(fieldsArr, otherField, config2) {
  const result2 = fieldsArr.find((field) => field.name.value === otherField.name.value);
  if (result2 && !(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
    const t1 = extractType(result2.type);
    const t2 = extractType(otherField.type);
    if (t1.name.value !== t2.name.value) {
      throw new Error(`Field "${otherField.name.value}" already defined with a different type. Declared as "${t1.name.value}", but you tried to override with "${t2.name.value}"`);
    }
  }
  return !!result2;
}
function mergeFields(type2, f1, f2, config2) {
  const result2 = [];
  if (f2 != null) {
    result2.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      if (fieldAlreadyExists(result2, field, config2)) {
        const existing = result2.find((f) => f.name.value === field.name.value);
        if (!(config2 === null || config2 === void 0 ? void 0 : config2.ignoreFieldConflicts)) {
          if (config2 === null || config2 === void 0 ? void 0 : config2.throwOnConflict) {
            preventConflicts(type2, existing, field, false);
          } else {
            preventConflicts(type2, existing, field, true);
          }
          if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {
            existing.type = field.type;
          }
        }
        existing.arguments = mergeArguments(field["arguments"] || [], existing.arguments || [], config2);
        existing.directives = mergeDirectives(field.directives, existing.directives, config2);
        existing.description = field.description || existing.description;
      } else {
        result2.push(field);
      }
    }
  }
  if (config2 && config2.sort) {
    result2.sort(compareNodes);
  }
  if (config2 && config2.exclusions) {
    const exclusions = config2.exclusions;
    return result2.filter((field) => !exclusions.includes(`${type2.name.value}.${field.name.value}`));
  }
  return result2;
}
function preventConflicts(type2, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType && !safeChangeForFieldType(a.type, b.type, ignoreNullability)) {
    throw new Error(`Field '${type2.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
  }
}
function safeChangeForFieldType(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
}
function mergeInputType(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, node), {
    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION
  }) : node;
}
function mergeInterface(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config2) : void 0
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, node), {
    kind: Kind.INTERFACE_TYPE_DEFINITION
  }) : node;
}
function alreadyExists(arr, other) {
  return !!arr.find((i2) => i2.name.value === other.name.value);
}
function mergeNamedTypeArray(first = [], second = [], config2 = {}) {
  const result2 = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config2 && config2.sort) {
    result2.sort(compareNodes);
  }
  return result2;
}
function mergeType(node, existingNode, config2) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config2),
        directives: mergeDirectives(node.directives, existingNode.directives, config2),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config2)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, node), {
    kind: Kind.OBJECT_TYPE_DEFINITION
  }) : node;
}
function mergeScalar(node, existingNode, config2) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, node), {
    kind: Kind.SCALAR_TYPE_DEFINITION
  }) : node;
}
function mergeUnion(first, second, config2) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives(first.directives, second.directives, config2),
      kind: (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? Kind.UNION_TYPE_DEFINITION : Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config2)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, first), {
    kind: Kind.UNION_TYPE_DEFINITION
  }) : first;
}
const DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};
function mergeOperationTypes(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n2) => n2.operation === opNodeType) || existingOpNodeList.find((n2) => n2.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
}
function mergeSchemaDefs(node, existingNode, config2) {
  if (existingNode) {
    return {
      kind: node.kind === Kind.SCHEMA_DEFINITION || existingNode.kind === Kind.SCHEMA_DEFINITION ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config2),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return (config2 === null || config2 === void 0 ? void 0 : config2.convertExtensions) ? __spreadProps2(__spreadValues2({}, node), {
    kind: Kind.SCHEMA_DEFINITION
  }) : node;
}
const schemaDefSymbol = "SCHEMA_DEF_SYMBOL";
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config2) {
  var _a2, _b, _c;
  const mergedResultMap = {};
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = (_a2 = nodeDefinition.name) === null || _a2 === void 0 ? void 0 : _a2.value;
      if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (((_b = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _b === void 0 ? void 0 : _b.includes(name + ".*")) || ((_c = config2 === null || config2 === void 0 ? void 0 : config2.exclusions) === null || _c === void 0 ? void 0 : _c.includes(name))) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case Kind.OBJECT_TYPE_DEFINITION:
          case Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.ENUM_TYPE_DEFINITION:
          case Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.UNION_TYPE_DEFINITION:
          case Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.SCALAR_TYPE_DEFINITION:
          case Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.INTERFACE_TYPE_DEFINITION:
          case Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config2);
            break;
          case Kind.DIRECTIVE_DEFINITION:
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === Kind.SCHEMA_DEFINITION || nodeDefinition.kind === Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config2);
    }
  }
  return mergedResultMap;
}
function mergeTypeDefs(typeSource, config2) {
  resetComments();
  const doc = {
    kind: Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, __spreadValues2({
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false
    }, config2))
  };
  let result2;
  if (config2 === null || config2 === void 0 ? void 0 : config2.commentDescriptions) {
    result2 = printWithComments(doc);
  } else {
    result2 = doc;
  }
  resetComments();
  return result2;
}
function visitTypeSources(typeSource, options2, allNodes = [], visitedTypeSources = /* @__PURE__ */ new Set()) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options2, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type2 of typeSource) {
        visitTypeSources(type2, options2, allNodes, visitedTypeSources);
      }
    } else if (isSchema(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options2);
      visitTypeSources(documentNode.definitions, options2, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = parse$6(typeSource, options2);
      visitTypeSources(documentNode.definitions, options2, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && isDefinitionNode(typeSource)) {
      allNodes.push(typeSource);
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options2, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return allNodes;
}
function mergeGraphQLTypes(typeSource, config2) {
  var _a2, _b, _c;
  resetComments();
  const allNodes = visitTypeSources(typeSource, config2);
  const mergedNodes = mergeGraphQLNodes(allNodes, config2);
  if (config2 === null || config2 === void 0 ? void 0 : config2.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (((_a2 = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a2 === void 0 ? void 0 : _a2.length) != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if ((config2 === null || config2 === void 0 ? void 0 : config2.forceSchemaDefinition) && !((_c = (_b = mergedNodes[schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {
    mergedNodes[schemaDefSymbol] = {
      kind: Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: Kind.NAMED_TYPE,
            name: {
              kind: Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config2 === null || config2 === void 0 ? void 0 : config2.sort) {
    const sortFn = typeof config2.sort === "function" ? config2.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => {
      var _a3, _b2;
      return sortFn((_a3 = a.name) === null || _a3 === void 0 ? void 0 : _a3.value, (_b2 = b.name) === null || _b2 === void 0 ? void 0 : _b2.value);
    });
  }
  return mergedNodeDefinitions;
}
function travelSchemaPossibleExtensions(schema2, hooks) {
  hooks.onSchema(schema2);
  const typesMap = schema2.getTypeMap();
  for (const [, type2] of Object.entries(typesMap)) {
    const isPredefinedScalar = isScalarType(type2) && isSpecifiedScalarType(type2);
    const isIntrospection = isIntrospectionType(type2);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if (isObjectType(type2)) {
      hooks.onObjectType(type2);
      const fields8 = type2.getFields();
      for (const [, field] of Object.entries(fields8)) {
        hooks.onObjectField(type2, field);
        const args2 = field.args || [];
        for (const arg of args2) {
          hooks.onObjectFieldArg(type2, field, arg);
        }
      }
    } else if (isInterfaceType(type2)) {
      hooks.onInterface(type2);
      const fields8 = type2.getFields();
      for (const [, field] of Object.entries(fields8)) {
        hooks.onInterfaceField(type2, field);
        const args2 = field.args || [];
        for (const arg of args2) {
          hooks.onInterfaceFieldArg(type2, field, arg);
        }
      }
    } else if (isInputObjectType(type2)) {
      hooks.onInputType(type2);
      const fields8 = type2.getFields();
      for (const [, field] of Object.entries(fields8)) {
        hooks.onInputFieldType(type2, field);
      }
    } else if (isUnionType(type2)) {
      hooks.onUnion(type2);
    } else if (isScalarType(type2)) {
      hooks.onScalar(type2);
    } else if (isEnumType(type2)) {
      hooks.onEnum(type2);
      for (const value2 of type2.getValues()) {
        hooks.onEnumValue(type2, value2);
      }
    }
  }
}
function mergeExtensions(extensions) {
  return mergeDeep(extensions);
}
function applyExtensionObject(obj2, extensions) {
  if (!obj2) {
    return;
  }
  obj2.extensions = mergeDeep([obj2.extensions || {}, extensions || {}]);
}
function applyExtensions(schema2, extensions) {
  applyExtensionObject(schema2, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type2 = schema2.getType(typeName);
    if (type2) {
      applyExtensionObject(type2, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value2 = type2.getValue(valueName);
          applyExtensionObject(value2, valueData);
        }
      }
    }
  }
  return schema2;
}
function extractExtensionsFromSchema(schema2) {
  const result2 = {
    schemaExtensions: {},
    types: {}
  };
  travelSchemaPossibleExtensions(schema2, {
    onSchema: (schema3) => result2.schemaExtensions = schema3.extensions || {},
    onObjectType: (type2) => result2.types[type2.name] = { fields: {}, type: "object", extensions: type2.extensions || {} },
    onObjectField: (type2, field) => result2.types[type2.name].fields[field.name] = {
      arguments: {},
      extensions: field.extensions || {}
    },
    onObjectFieldArg: (type2, field, arg) => result2.types[type2.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
    onInterface: (type2) => result2.types[type2.name] = { fields: {}, type: "interface", extensions: type2.extensions || {} },
    onInterfaceField: (type2, field) => result2.types[type2.name].fields[field.name] = {
      arguments: {},
      extensions: field.extensions || {}
    },
    onInterfaceFieldArg: (type2, field, arg) => result2.types[type2.name].fields[field.name].arguments[arg.name] = arg.extensions || {},
    onEnum: (type2) => result2.types[type2.name] = { values: {}, type: "enum", extensions: type2.extensions || {} },
    onEnumValue: (type2, value2) => result2.types[type2.name].values[value2.name] = value2.extensions || {},
    onScalar: (type2) => result2.types[type2.name] = { type: "scalar", extensions: type2.extensions || {} },
    onUnion: (type2) => result2.types[type2.name] = { type: "union", extensions: type2.extensions || {} },
    onInputType: (type2) => result2.types[type2.name] = { fields: {}, type: "input", extensions: type2.extensions || {} },
    onInputFieldType: (type2, field) => result2.types[type2.name].fields[field.name] = { extensions: field.extensions || {} }
  });
  return result2;
}
function assertResolversPresent(schema2, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema2, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !isScalarType(getNamedType(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
function expectResolver(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
}
function checkForResolveTypeResolver(schema2, requireResolversForResolveType) {
  mapSchema(schema2, {
    [MapperKind.ABSTRACT_TYPE]: (type2) => {
      if (!type2.resolveType) {
        const message = `Type "${type2.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return void 0;
    }
  });
}
function extendResolversFromInterfaces(schema2, resolvers) {
  const extendedResolvers = {};
  const typeMap = schema2.getTypeMap();
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if ("getInterfaces" in type2) {
      extendedResolvers[typeName] = {};
      for (const iFace of type2.getInterfaces()) {
        if (resolvers[iFace.name]) {
          for (const fieldName in resolvers[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers[typeName];
      extendedResolvers[typeName] = __spreadValues2(__spreadValues2({}, extendedResolvers[typeName]), typeResolvers);
    } else {
      const typeResolvers = resolvers[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}
function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {
  const options2 = isSchema(schemaOrOptions) ? {
    schema: schemaOrOptions,
    resolvers: legacyInputResolvers !== null && legacyInputResolvers !== void 0 ? legacyInputResolvers : {},
    resolverValidationOptions: legacyInputValidationOptions
  } : schemaOrOptions;
  let { schema: schema2, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false } = options2;
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema2, inputResolvers) : inputResolvers;
  for (const typeName in resolvers) {
    const resolverValue = resolvers[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type2 = schema2.getType(typeName);
    if (type2 == null) {
      if (requireResolversToMatchSchema === "ignore") {
        break;
      }
      throw new Error(`"${typeName}" defined in resolvers, but not in schema`);
    } else if (isSpecifiedScalarType(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type2[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType(type2)) {
      const values = type2.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values.some((value2) => value2.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but not present within ${type2.name}`);
        }
      }
    } else if (isUnionType(type2)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          throw new Error(`${type2.name}.${fieldName} was defined in resolvers, but ${type2.name} is not an object or interface type`);
        }
      }
    } else if (isObjectType(type2) || isInterfaceType(type2)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields8 = type2.getFields();
          const field = fields8[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema2 = updateResolversInPlace ? addResolversToExistingSchema(schema2, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema2, resolvers, defaultFieldResolver);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema2, requireResolversForResolveType);
  }
  return schema2;
}
function addResolversToExistingSchema(schema2, resolvers, defaultFieldResolver) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const typeMap = schema2.getTypeMap();
  for (const typeName in resolvers) {
    const type2 = schema2.getType(typeName);
    const resolverValue = resolvers[typeName];
    if (isScalarType(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type2.astNode != null) {
          type2.astNode = __spreadProps2(__spreadValues2({}, type2.astNode), {
            description: (_c = (_b = (_a2 = resolverValue) === null || _a2 === void 0 ? void 0 : _a2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type2.astNode.description,
            directives: ((_d = type2.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])
          });
        } else if (fieldName === "extensionASTNodes" && type2.extensionASTNodes != null) {
          type2.extensionASTNodes = type2.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);
        } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
          type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
        } else {
          type2[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType(type2)) {
      const config2 = type2.toConfig();
      const enumValueConfigMap = config2.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config2[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config2.astNode != null) {
          config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
            description: (_m = (_l = (_k = resolverValue) === null || _k === void 0 ? void 0 : _k.astNode) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : config2.astNode.description,
            directives: ((_o = config2.astNode.directives) !== null && _o !== void 0 ? _o : []).concat((_r = (_q = (_p = resolverValue) === null || _p === void 0 ? void 0 : _p.astNode) === null || _q === void 0 ? void 0 : _q.directives) !== null && _r !== void 0 ? _r : [])
          });
        } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
          config2.extensionASTNodes = config2.extensionASTNodes.concat((_t = (_s = resolverValue) === null || _s === void 0 ? void 0 : _s.extensionASTNodes) !== null && _t !== void 0 ? _t : []);
        } else if (fieldName === "extensions" && type2.extensions != null && resolverValue.extensions != null) {
          type2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new GraphQLEnumType(config2);
    } else if (isUnionType(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if (isObjectType(type2) || isInterfaceType(type2)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type2[fieldName.substring(2)] = resolverValue[fieldName];
          break;
        }
        const fields8 = type2.getFields();
        const field = fields8[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema2, serializeInputValue);
  healSchema(schema2);
  forEachDefaultValue(schema2, parseInputValue);
  if (defaultFieldResolver != null) {
    forEachField(schema2, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver;
      }
    });
  }
  return schema2;
}
function createNewSchemaWithResolvers(schema2, resolvers, defaultFieldResolver) {
  schema2 = mapSchema(schema2, {
    [MapperKind.SCALAR_TYPE]: (type2) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const config2 = type2.toConfig();
      const resolverValue = resolvers[type2.name];
      if (!isSpecifiedScalarType(type2) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
              description: (_c = (_b = (_a2 = resolverValue) === null || _a2 === void 0 ? void 0 : _a2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config2.astNode.description,
              directives: ((_d = config2.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])
            });
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
          } else {
            config2[fieldName] = resolverValue[fieldName];
          }
        }
        return new GraphQLScalarType(config2);
      }
    },
    [MapperKind.ENUM_TYPE]: (type2) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
      const resolverValue = resolvers[type2.name];
      const config2 = type2.toConfig();
      const enumValueConfigMap = config2.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config2[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config2.astNode != null) {
            config2.astNode = __spreadProps2(__spreadValues2({}, config2.astNode), {
              description: (_c = (_b = (_a2 = resolverValue) === null || _a2 === void 0 ? void 0 : _a2.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config2.astNode.description,
              directives: ((_d = config2.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])
            });
          } else if (fieldName === "extensionASTNodes" && config2.extensionASTNodes != null) {
            config2.extensionASTNodes = config2.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);
          } else if (fieldName === "extensions" && config2.extensions != null && resolverValue.extensions != null) {
            config2.extensions = Object.assign(/* @__PURE__ */ Object.create(null), type2.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new GraphQLEnumType(config2);
      }
    },
    [MapperKind.UNION_TYPE]: (type2) => {
      const resolverValue = resolvers[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLUnionType(config2);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type2) => {
      const resolverValue = resolvers[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config2.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new GraphQLObjectType(config2);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type2) => {
      const resolverValue = resolvers[type2.name];
      if (resolverValue != null) {
        const config2 = type2.toConfig();
        if (resolverValue["__resolveType"]) {
          config2.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLInterfaceType(config2);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = __spreadValues2({}, fieldConfig);
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver != null) {
    schema2 = mapSchema(schema2, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => __spreadProps2(__spreadValues2({}, fieldConfig), {
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver
      })
    });
  }
  return schema2;
}
function setFieldProperties(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
}
function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, updateResolversInPlace = false, schemaExtensions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs) {
    throw new Error("Must provide typeDefs");
  }
  let schema2;
  if (isSchema(typeDefs)) {
    schema2 = typeDefs;
  } else if (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, __spreadProps2(__spreadValues2({}, parseOptions), {
      commentDescriptions: true
    }));
    schema2 = buildSchema(mergedTypeDefs, parseOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, parseOptions);
    schema2 = buildASTSchema(mergedTypeDefs, parseOptions);
  }
  if (pruningOptions) {
    schema2 = pruneSchema(schema2);
  }
  schema2 = addResolversToSchema({
    schema: schema2,
    resolvers: mergeResolvers(resolvers),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema2, resolverValidationOptions);
  }
  if (schemaExtensions) {
    schemaExtensions = mergeExtensions(asArray(schemaExtensions));
    applyExtensions(schema2, schemaExtensions);
  }
  return schema2;
}
function mergeSchemas(config2) {
  const extractedTypeDefs = asArray(config2.typeDefs || []);
  const extractedResolvers = asArray(config2.resolvers || []);
  const extractedSchemaExtensions = asArray(config2.schemaExtensions || []);
  const schemas = config2.schemas || [];
  for (const schema2 of schemas) {
    extractedTypeDefs.push(schema2);
    extractedResolvers.push(getResolversFromSchema(schema2));
    extractedSchemaExtensions.push(extractExtensionsFromSchema(schema2));
  }
  return makeExecutableSchema(__spreadProps2(__spreadValues2({
    parseOptions: config2
  }, config2), {
    typeDefs: extractedTypeDefs,
    resolvers: extractedResolvers,
    schemaExtensions: extractedSchemaExtensions
  }));
}
async function executePlugin(options2, plugin) {
  var _a2;
  if (!plugin || !plugin.plugin || typeof plugin.plugin !== "function") {
    throw new DetailedError(`Invalid Custom Plugin "${options2.name}"`, `
        Plugin ${options2.name} does not export a valid JS object with "plugin" function.

        Make sure your custom plugin is written in the following form:

        module.exports = {
          plugin: (schema, documents, config) => {
            return 'my-custom-plugin-content';
          },
        };
        `);
  }
  const outputSchema = options2.schemaAst || buildASTSchema(options2.schema, options2.config);
  const documents = options2.documents || [];
  const pluginContext = options2.pluginContext || {};
  const profiler = (_a2 = options2.profiler) !== null && _a2 !== void 0 ? _a2 : createNoopProfiler();
  if (plugin.validate && typeof plugin.validate === "function") {
    try {
      await profiler.run(async () => plugin.validate(outputSchema, documents, options2.config, options2.outputFilename, options2.allPlugins, pluginContext), `Plugin ${options2.name} validate`);
    } catch (e) {
      throw new DetailedError(`Plugin "${options2.name}" validation failed:`, `
            ${e.message}
          `);
    }
  }
  return profiler.run(() => Promise.resolve(plugin.plugin(outputSchema, documents, typeof options2.config === "object" ? __spreadValues2({}, options2.config) : options2.config, {
    outputFile: options2.outputFilename,
    allPlugins: options2.allPlugins,
    pluginContext
  })), `Plugin ${options2.name} execution`);
}
function isObjectMap(obj2) {
  return obj2 && typeof obj2 === "object" && !Array.isArray(obj2);
}
function prioritize(...values) {
  const picked = values.find((val) => typeof val === "boolean");
  if (typeof picked !== "boolean") {
    return values[values.length - 1];
  }
  return picked;
}
function pickFlag(flag, config2) {
  return isObjectMap(config2) ? config2[flag] : void 0;
}
function shouldValidateDuplicateDocuments(skipDocumentsValidationOption) {
  if (skipDocumentsValidationOption === true) {
    return false;
  }
  if (typeof skipDocumentsValidationOption === "object" && skipDocumentsValidationOption.skipDuplicateValidation) {
    return false;
  }
  return true;
}
function shouldValidateDocumentsAgainstSchema(skipDocumentsValidationOption) {
  if (skipDocumentsValidationOption === true) {
    return false;
  }
  if (typeof skipDocumentsValidationOption === "object" && skipDocumentsValidationOption.skipValidationAgainstSchema) {
    return false;
  }
  return true;
}
function getSkipDocumentsValidationOption(options2) {
  if (options2.skipDocumentsValidation) {
    return options2.skipDocumentsValidation;
  }
  const flagFromConfig = pickFlag("skipDocumentsValidation", options2.config);
  if (flagFromConfig) {
    return flagFromConfig;
  }
  return false;
}
const federationDirectives = ["key", "requires", "provides", "external"];
function hasFederationSpec(schemaOrAST) {
  if (isSchema(schemaOrAST)) {
    return federationDirectives.some((directive2) => schemaOrAST.getDirective(directive2));
  } else if (isDocumentNode(schemaOrAST)) {
    return schemaOrAST.definitions.some((def) => def.kind === Kind.DIRECTIVE_DEFINITION && federationDirectives.includes(def.name.value));
  }
  return false;
}
function extractHashFromSchema(schema2) {
  var _a2;
  if (!schema2.extensions) {
    schema2.extensions = {};
  }
  return (_a2 = schema2.extensions["hash"]) !== null && _a2 !== void 0 ? _a2 : null;
}
async function codegen(options2) {
  var _a2;
  const documents = options2.documents || [];
  const profiler = (_a2 = options2.profiler) !== null && _a2 !== void 0 ? _a2 : createNoopProfiler();
  const skipDocumentsValidation = getSkipDocumentsValidationOption(options2);
  if (documents.length > 0 && shouldValidateDuplicateDocuments(skipDocumentsValidation)) {
    await profiler.run(async () => validateDuplicateDocuments(documents), "validateDuplicateDocuments");
  }
  const pluginPackages = Object.keys(options2.pluginMap).map((key) => options2.pluginMap[key]);
  const additionalTypeDefs = [];
  for (const plugin of pluginPackages) {
    const addToSchema = typeof plugin.addToSchema === "function" ? plugin.addToSchema(options2.config) : plugin.addToSchema;
    if (addToSchema) {
      additionalTypeDefs.push(addToSchema);
    }
  }
  const federationInConfig = pickFlag("federation", options2.config);
  const isFederation = prioritize(federationInConfig, false);
  if (isFederation && !hasFederationSpec(options2.schemaAst || options2.schema)) {
    additionalTypeDefs.push(federationSpec);
  }
  const mergeNeeded = !options2.schemaAst || additionalTypeDefs.length > 0;
  const schemaInstance = await profiler.run(async () => {
    return mergeNeeded ? mergeSchemas(__spreadValues2({
      schemas: options2.schemaAst ? [options2.schemaAst] : [],
      typeDefs: options2.schemaAst ? additionalTypeDefs : [options2.schema, ...additionalTypeDefs],
      convertExtensions: true,
      assumeValid: true,
      assumeValidSDL: true
    }, options2.config)) : options2.schemaAst;
  }, "Create schema instance");
  const schemaDocumentNode = mergeNeeded || !options2.schema ? getCachedDocumentNodeFromSchema(schemaInstance) : options2.schema;
  if (schemaInstance && documents.length > 0 && shouldValidateDocumentsAgainstSchema(skipDocumentsValidation)) {
    const ignored = ["NoUnusedFragments", "NoUnusedVariables", "KnownDirectives"];
    if (typeof skipDocumentsValidation === "object" && skipDocumentsValidation.ignoreRules) {
      ignored.push(...asArray(skipDocumentsValidation.ignoreRules));
    }
    const extraFragments = pickFlag("externalFragments", options2.config) || [];
    const errors = await profiler.run(() => {
      const fragments = extraFragments.map((f) => ({
        location: f.importFrom,
        document: { kind: Kind.DOCUMENT, definitions: [f.node] }
      }));
      const rules = specifiedRules.filter((rule) => !ignored.some((ignoredRule) => rule.name.startsWith(ignoredRule)));
      const schemaHash = extractHashFromSchema(schemaInstance);
      if (!schemaHash || !options2.cache || documents.some((d) => typeof d.hash !== "string")) {
        return validateGraphQlDocuments(schemaInstance, [...documents, ...fragments], rules);
      }
      const cacheKey = [schemaHash].concat(documents.map((doc) => doc.hash)).concat(JSON.stringify(fragments)).join(",");
      return options2.cache("documents-validation", cacheKey, () => validateGraphQlDocuments(schemaInstance, [...documents, ...fragments], rules));
    }, "Validate documents against schema");
    checkValidationErrors(errors);
  }
  const prepend = /* @__PURE__ */ new Set();
  const append2 = /* @__PURE__ */ new Set();
  const output = await Promise.all(options2.plugins.map(async (plugin) => {
    const name = Object.keys(plugin)[0];
    const pluginPackage = options2.pluginMap[name];
    const pluginConfig = plugin[name] || {};
    const execConfig = typeof pluginConfig !== "object" ? pluginConfig : __spreadValues2(__spreadValues2({}, options2.config), pluginConfig);
    const result2 = await profiler.run(() => executePlugin({
      name,
      config: execConfig,
      parentConfig: options2.config,
      schema: schemaDocumentNode,
      schemaAst: schemaInstance,
      documents: options2.documents,
      outputFilename: options2.filename,
      allPlugins: options2.plugins,
      skipDocumentsValidation: options2.skipDocumentsValidation,
      pluginContext: options2.pluginContext,
      profiler
    }, pluginPackage), `Plugin ${name}`);
    if (typeof result2 === "string") {
      return result2 || "";
    } else if (isComplexPluginOutput(result2)) {
      if (result2.append && result2.append.length > 0) {
        for (const item of result2.append) {
          if (item) {
            append2.add(item);
          }
        }
      }
      if (result2.prepend && result2.prepend.length > 0) {
        for (const item of result2.prepend) {
          if (item) {
            prepend.add(item);
          }
        }
      }
      return result2.content || "";
    }
    return "";
  }));
  return [...sortPrependValues(Array.from(prepend.values())), ...output, ...Array.from(append2.values())].filter(Boolean).join("\n");
}
function resolveCompareValue(a) {
  if (a.startsWith("/*") || a.startsWith("//") || a.startsWith(" *") || a.startsWith(" */") || a.startsWith("*/")) {
    return 0;
  } else if (a.startsWith("package")) {
    return 1;
  } else if (a.startsWith("import")) {
    return 2;
  } else {
    return 3;
  }
}
function sortPrependValues(values) {
  return values.sort((a, b) => {
    const aV = resolveCompareValue(a);
    const bV = resolveCompareValue(b);
    if (aV < bV) {
      return -1;
    }
    if (aV > bV) {
      return 1;
    }
    return 0;
  });
}
function validateDuplicateDocuments(files) {
  const definitionMap = {};
  function addDefinition(file, node, deduplicatedDefinitions) {
    if (typeof node.name !== "undefined") {
      if (!definitionMap[node.kind]) {
        definitionMap[node.kind] = {};
      }
      if (!definitionMap[node.kind][node.name.value]) {
        definitionMap[node.kind][node.name.value] = {
          paths: /* @__PURE__ */ new Set(),
          contents: /* @__PURE__ */ new Set()
        };
      }
      const definitionKindMap = definitionMap[node.kind];
      const length = definitionKindMap[node.name.value].contents.size;
      definitionKindMap[node.name.value].paths.add(file.location);
      definitionKindMap[node.name.value].contents.add(print(node));
      if (length === definitionKindMap[node.name.value].contents.size) {
        return null;
      }
    }
    return deduplicatedDefinitions.add(node);
  }
  files.forEach((file) => {
    const deduplicatedDefinitions = /* @__PURE__ */ new Set();
    visit(file.document, {
      OperationDefinition(node) {
        addDefinition(file, node, deduplicatedDefinitions);
      },
      FragmentDefinition(node) {
        addDefinition(file, node, deduplicatedDefinitions);
      }
    });
    file.document.definitions = Array.from(deduplicatedDefinitions);
  });
  const kinds = Object.keys(definitionMap);
  kinds.forEach((kind) => {
    const definitionKindMap = definitionMap[kind];
    const names = Object.keys(definitionKindMap);
    if (names.length) {
      const duplicated = names.filter((name) => definitionKindMap[name].contents.size > 1);
      if (!duplicated.length) {
        return;
      }
      const list = duplicated.map((name) => `
        * ${name} found in:
          ${[...definitionKindMap[name].paths].map((filepath) => {
        return `
              - ${filepath}
            `.trimRight();
      }).join("")}
    `.trimRight()).join("");
      const definitionKindName = kind.replace("Definition", "").toLowerCase();
      throw new DetailedError(`Not all ${definitionKindName}s have an unique name: ${duplicated.join(", ")}`, `
          Not all ${definitionKindName}s have an unique name
          ${list}
        `);
    }
  });
}
function setupConfig(generates) {
  let options2 = [];
  for (const [filename, outputOptions] of Object.entries(generates)) {
    options2.push({
      filename,
      config: outputOptions == null ? void 0 : outputOptions.config
    });
  }
  return options2;
}
async function generateTypes({
  config: config2,
  generatedSchema,
  documents
}) {
  var _a2, _b, _c, _d;
  const typescriptPlugin = await import("./index2.js");
  const operationsPlugin = await import("./index4.js");
  const urqlPlugin = await import("./index5.js");
  const introspectionPlugin = await import("./index6.js");
  try {
    const cleanTabs = config2.replace(/\t/g, "  ");
    const { generates } = load(cleanTabs);
    const runConfigurations = [];
    let output = {};
    const options2 = setupConfig(generates);
    const pluginsGraphQL = [
      { typescript: {} },
      { "typescript-operations": {} },
      { "typescript-urql": {} }
    ];
    const pluginsIntrospection = [{ introspection: {} }];
    const pluginMapGraphQL = {
      typescript: typescriptPlugin,
      "typescript-operations": operationsPlugin,
      "typescript-urql": urqlPlugin
    };
    const pluginMapIntrospection = {
      introspection: introspectionPlugin
    };
    if (generatedSchema !== "") {
      runConfigurations.push({
        filename: (_a2 = options2[0]) == null ? void 0 : _a2.filename,
        plugins: pluginsGraphQL,
        schema: parse$6(generatedSchema),
        documents,
        config: (_b = options2[0]) == null ? void 0 : _b.config,
        pluginMap: pluginMapGraphQL
      });
      runConfigurations.push({
        filename: (_c = options2 == null ? void 0 : options2[1]) == null ? void 0 : _c.filename,
        plugins: pluginsIntrospection,
        schema: parse$6(generatedSchema),
        documents,
        config: (_d = options2 == null ? void 0 : options2[1]) == null ? void 0 : _d.config,
        pluginMap: pluginMapIntrospection
      });
      output = {
        graphql: await codegen(runConfigurations[0]),
        introspection: await codegen(runConfigurations[1])
      };
    }
    return output;
  } catch (e) {
    return e;
  }
}
async function fetchGraphqlSchema(schema2, secret) {
  try {
    const headers = { "Content-Type": "application/json" };
    if (secret) {
      headers["x-hasura-admin-secret"] = secret;
    }
    const response = await fetch(`${schema2}`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        variables: {},
        query: getIntrospectionQuery()
      })
    });
    const { data } = await response.json();
    const buildSchema2 = buildClientSchema(data);
    const generatedSchema = printSchema(buildSchema2);
    return generatedSchema;
  } catch (e) {
    console.error(e);
    frontendActions.transpileError(e);
  }
}
async function generateGraphqlTypesFile(graphqlEndpoint, graphqlSecret, config2, documents) {
  const generatedSchema = await fetchGraphqlSchema(graphqlEndpoint, graphqlSecret) || "";
  const result2 = await generateTypes({
    config: config2,
    generatedSchema,
    documents
  });
  return result2;
}
async function loadGraphqlCodegenConfig(io) {
  var _a2;
  const config2 = (_a2 = await io.readFile(CONFIG_PATH)) != null ? _a2 : "";
  return load(config2);
}
async function getGeneratesFileNameFromConfig(io) {
  const { generates } = await loadGraphqlCodegenConfig(io);
  const genFiles = Object.keys(generates != null ? generates : {});
  if ((genFiles == null ? void 0 : genFiles.length) > 0) {
    return {
      graphql: "/" + (genFiles == null ? void 0 : genFiles[0]),
      introspection: "/" + (genFiles == null ? void 0 : genFiles[1])
    };
  }
}
function findGraphQlFiles(files, editedDocumentData, currentDocumentPath) {
  const documents = [];
  try {
    for (const filePath in files) {
      if (filePath.endsWith(".graphql") && !isEmptyOrSpaces(files[filePath])) {
        const changedFile = currentDocumentPath === filePath ? editedDocumentData : files[filePath];
        documents.push({ location: filePath, document: parse$6(changedFile) });
      }
    }
    return documents;
  } catch (e) {
    console.error(e);
    frontendActions.transpileError(e);
  }
}
async function graphqlCodegen({
  workbench: workbench2,
  files,
  data,
  path: path2
}) {
  var _a2;
  const editedDocumentData = data != null ? data : "";
  const editedDocumentPath = path2 != null ? path2 : "";
  const documents = findGraphQlFiles(files, editedDocumentData, editedDocumentPath);
  const config2 = await workbench2.readFile(CONFIG_PATH);
  const generated = (_a2 = await generateGraphqlTypesFile(workbench2.graphQLEndpoint, workbench2.graphQLSecret, config2, documents)) != null ? _a2 : {};
  const generatedFilePaths = await getGeneratesFileNameFromConfig(workbench2);
  return { generatedFilePaths, generated };
}
var main = {};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
const fs = require$$0;
const path = pathBrowserify;
function log(message) {
  console.log(`[dotenv][DEBUG] ${message}`);
}
const NEWLINE = "\n";
const RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
const RE_NEWLINES = /\\n/g;
const NEWLINES_MATCH = /\n|\r|\r\n/;
function parse(src, options2) {
  const debug = Boolean(options2 && options2.debug);
  const obj2 = {};
  src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
    const keyValueArr = line.match(RE_INI_KEY_VAL);
    if (keyValueArr != null) {
      const key = keyValueArr[1];
      let val = keyValueArr[2] || "";
      const end = val.length - 1;
      const isDoubleQuoted = val[0] === '"' && val[end] === '"';
      const isSingleQuoted = val[0] === "'" && val[end] === "'";
      if (isSingleQuoted || isDoubleQuoted) {
        val = val.substring(1, end);
        if (isDoubleQuoted) {
          val = val.replace(RE_NEWLINES, NEWLINE);
        }
      } else {
        val = val.trim();
      }
      obj2[key] = val;
    } else if (debug) {
      log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
    }
  });
  return obj2;
}
function config(options2) {
  let dotenvPath = path.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  let debug = false;
  if (options2) {
    if (options2.path != null) {
      dotenvPath = options2.path;
    }
    if (options2.encoding != null) {
      encoding = options2.encoding;
    }
    if (options2.debug != null) {
      debug = true;
    }
  }
  try {
    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug });
    Object.keys(parsed).forEach(function(key) {
      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
        process.env[key] = parsed[key];
      } else if (debug) {
        log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
      }
    });
    return { parsed };
  } catch (e) {
    return { error: e };
  }
}
main.config = config;
main.parse = parse;
const lookupAsFile = (uri2, silent, root2) => {
  const entry = lookup(uri2, silent, root2);
  if (entry instanceof File) {
    return entry;
  }
  return new VSCodeFSTransferableError(VsCodeFSErrors.FileIsADirectory, uri2);
};
const lookup = (uri2, silent, root2) => {
  const parts2 = uri2.path.split("/");
  let entry = root2 != null ? root2 : new Directory(URI$1.parse(""));
  for (const part of parts2) {
    if (!part) {
      continue;
    }
    let child;
    if (entry instanceof Directory) {
      child = entry.entries.get(part);
    }
    if (!child) {
      if (!silent) {
        return new VSCodeFSTransferableError(VsCodeFSErrors.FileNotFound, uri2);
      } else {
        return void 0;
      }
    }
    entry = child;
  }
  return entry;
};
const lookupParentDirectory = (uri2, root2) => {
  const dirUri = resolveDirname(uri2);
  const dirname2 = URI$1.parse(dirUri);
  return lookupAsDirectory(dirname2, false, root2);
};
const lookupAsDirectory = (uri2, silent, root2) => {
  const entry = lookup(uri2, silent, root2);
  if (entry instanceof Directory) {
    return entry;
  }
  return new VSCodeFSTransferableError(VsCodeFSErrors.FileNotADirectory, uri2);
};
class WriterMemoryFS {
  constructor(root2) {
    __publicField2(this, "root");
    this.root = root2;
  }
  setRoot(root2) {
    this.root = root2;
  }
  getRoot() {
    return this.root;
  }
  async readFile(path2, encoding) {
    const data = lookupAsFile(URI$1.parse(normalizePath(path2)), true, this.root);
    if (data instanceof VSCodeFSTransferableError) {
      return data;
    }
    return uint8ToString(data.data);
  }
  async writeFile(path2, data, options2) {
    const uri2 = URI$1.parse(normalizePath(path2));
    const basename2 = resolveFilename(uri2);
    let parent = lookupParentDirectory(uri2, this.root);
    const normalizedContent = transformObjectToUint8Array(Buffer.from(data));
    if (parent instanceof VSCodeFSTransferableError && parent.errorType === VsCodeFSErrors.FileNotADirectory) {
      parent = this._createDirectoryTree(parent.uri);
    }
    if (parent instanceof VSCodeFSTransferableError) {
      return parent;
    }
    let entry = parent.entries.get(basename2);
    if (entry instanceof Directory) {
      return new VSCodeFSTransferableError(VsCodeFSErrors.FileIsADirectory, uri2);
    }
    if (!entry && !options2.create) {
      return new VSCodeFSTransferableError(VsCodeFSErrors.FileNotFound, uri2);
    }
    if (entry && options2.create && !options2.overwrite) {
      return new VSCodeFSTransferableError(VsCodeFSErrors.FileExists, uri2);
    }
    if (!(parent instanceof VSCodeFSTransferableError)) {
      let entry2 = parent.entries.get(basename2);
      if (!(entry2 instanceof Directory)) {
        if (!entry2) {
          entry2 = new File(uri2, normalizedContent);
          parent.entries.set(basename2, entry2);
        }
        entry2.mtime = Date.now();
        entry2.size = normalizedContent.byteLength;
        entry2.data = normalizedContent;
      }
    }
    return normalizedContent;
  }
  async renameFile(oldPath, newPath) {
    const oldUri = URI$1.parse(oldPath);
    const newUri = URI$1.parse(newPath);
    const entry = lookup(oldUri, false, this.root);
    const oldParent = lookupParentDirectory(oldUri, this.root);
    const newParent = lookupParentDirectory(newUri, this.root);
    const newName = resolveFilename(newUri);
    if (oldParent instanceof Directory && newParent instanceof Directory) {
      oldParent.entries.delete(entry.name);
      entry.name = newName;
      newParent.entries.set(newName, entry);
    }
  }
  async deleteFile(path2) {
    const uri2 = URI$1.parse(normalizePath(path2));
    const fileName = resolveFilename(uri2);
    const dirName = resolveDirname(uri2);
    const dir = lookupAsDirectory(URI$1.parse(dirName), true, this.root);
    if (!(dir instanceof VSCodeFSTransferableError)) {
      dir.entries.delete(fileName);
      dir.mtime = Date.now();
      dir.size -= 1;
    }
  }
  async deleteFiles(files) {
    files.forEach((file) => {
      const uri2 = URI$1.parse(normalizePath(file.path));
      const fileName = resolveFilename(uri2);
      const dirName = resolveDirname(uri2);
      const dir = lookupAsDirectory(URI$1.parse(dirName), true, this.root);
      if (!(dir instanceof VSCodeFSTransferableError)) {
        dir.entries.delete(fileName);
        dir.mtime = Date.now();
        dir.size -= 1;
      }
    });
  }
  async readDirectory(path2, extensions, exclude, include, depth2) {
    const uri2 = URI$1.parse(normalizePath(path2));
    const dir = lookupAsDirectory(uri2, true, this.root);
    let filesPath = [];
    if (!(dir instanceof VSCodeFSTransferableError)) {
      [...dir.entries.keys()].map((key) => {
        filesPath[filesPath.length] = {
          fileName: key,
          filePath: path2.concat("/", key)
        };
      });
    }
    if (filesPath.length === 0) {
      throw new Error("Something went wrong");
    } else
      return filesPath;
  }
  async createDirectory(uri2) {
    const dirname2 = URI$1.parse(resolveDirname(uri2));
    const basename2 = resolveFilename(uri2);
    const parent = lookupAsDirectory(dirname2, false, this.root);
    if (!(parent instanceof VSCodeFSTransferableError)) {
      const entry = new Directory(URI$1.parse(basename2));
      parent.entries.set(entry.name, entry);
      parent.mtime = Date.now();
      parent.size += 1;
    }
  }
  _createDirectoryTree(uri2) {
    var _a2;
    let parts2 = uri2.path.split("/");
    let path2 = "";
    let entry = (_a2 = this.getRoot()) != null ? _a2 : new Directory(URI$1.parse(""));
    parts2.shift();
    while (parts2.length != 0) {
      const actualPart = parts2.shift();
      path2 += "/" + actualPart;
      let child;
      if (entry instanceof Directory) {
        child = entry.entries.get(actualPart);
      }
      if (!child) {
        child = new Directory(URI$1.parse(path2));
        if (entry instanceof Directory) {
          entry.entries.set(actualPart, child);
          entry = child;
          if (parts2.length == 0)
            return entry;
        }
      }
      entry = child;
    }
    return new VSCodeFSTransferableError(VsCodeFSErrors.FileNotADirectory, uri2);
  }
}
class WriterFetchFS {
  constructor(fsPort) {
    __publicField2(this, "fsPort");
    this.fsPort = fsPort;
  }
  setPort(fsPort) {
    this.fsPort = fsPort;
  }
  async readFile(path2, encoding) {
    try {
      const res2 = await fetch("/__fetchfs/read/file/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: path2 })
      });
      const data = await res2.text();
      return data;
    } catch (err2) {
      console.error(`Error while reading file from local FS, make sure fs-over-http is running on port: ${this.fsPort}`, err2);
    }
  }
  async writeFile(path2, data) {
    try {
      await fetch("/__fetchfs/write/file/", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: path2, data })
      });
    } catch (err2) {
      console.error(`Error while writing file to local FS, make sure fs-over-http is running on port: ${this.fsPort}`, err2);
    }
  }
  async renameFile(oldPath, newPath) {
    try {
      await fetch("/__fetchfs/rename/file/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ oldFilePath: oldPath, newFilePath: newPath })
      });
    } catch (err2) {
      console.error(`Error while renaming file in local FS, make sure fs-over-http is running on port: ${this.fsPort}`, err2);
    }
  }
  async deleteFile(path2) {
    try {
      await fetch("/__fetchfs/delete/file/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: path2 })
      });
    } catch (err2) {
      console.error(`Error while deleting file in local FS, make sure fs-over-http is running on port: ${this.fsPort}`, err2);
    }
  }
  async readDirectory(path2, extensions, exclude, include, depth2) {
    try {
      const res2 = await fetch("/__fetchfs/read/dir/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ path: path2 })
      });
      const filesPath = await res2.text();
      return this.createDirectoryObject(filesPath);
    } catch (err2) {
      console.error(`Error while reading file from local FS, make sure fs-over-http is running on port: ${this.fsPort}`, err2);
    }
  }
  async createDirectory(uri2) {
  }
  createDirectoryObject(response) {
    let filesOfDirectory = [];
    const correctedResponse = response.replace(/\[/g, "").replace(/\]/g, "").replace(/\\/g, "/").replace(/\"/g, "");
    const arr = correctedResponse.split(",");
    for (let item in arr) {
      const parsedPath = arr[item].split("/");
      const objToPush = [
        { fileName: parsedPath.pop(), filePath: arr[item] }
      ];
      filesOfDirectory = [...filesOfDirectory, ...objToPush];
    }
    return filesOfDirectory;
  }
}
class WatcherProxyFS {
  constructor(delegate) {
    __publicField2(this, "history", {});
    __publicField2(this, "delegate");
    this.delegate = delegate;
  }
  async readFile(path2, encoding, injectMode) {
    return await this.delegate.readFile(path2, encoding, injectMode);
  }
  async writeFile(path2, data, options2) {
    await this._watcherWriteFile(path2, data);
    return await this.delegate.writeFile(path2, data, options2);
  }
  async renameFile(oldPath, newPath) {
    await this._watcherRenameFile(oldPath, newPath);
    await this.delegate.renameFile(oldPath, newPath);
  }
  async deleteFile(path2) {
    await this._watcherDeleteFile(path2);
    await this.delegate.deleteFile(path2);
  }
  async deleteFiles(files) {
    for await (const file of files) {
      await this._watcherDeleteFile(file.path);
    }
    await this.delegate.deleteFiles(files);
  }
  async readDirectory(path2, extensions, exclude, include, depth2, injectMode) {
    return await this.delegate.readDirectory(path2, extensions, exclude, include, depth2, injectMode);
  }
  async createDirectory(uri2) {
    await this.delegate.createDirectory(uri2);
  }
  isHistoryEmpty() {
    return Object.keys(this.history).length == 0;
  }
  async readHistoryFile(path2, encoding) {
    return this.history[path2];
  }
  readHistoryFiles() {
    return __spreadValues2({}, this.history);
  }
  async writeHistoryFile(path2, data, newFile) {
    if (data == null) {
      const file = await this.readHistoryFile(path2);
      if (file != null && file.newFile) {
        this.deleteHistoryFile(path2);
      } else {
        this.history[path2] = { data: null, newFile };
      }
    } else {
      this.history[path2] = { data, newFile };
    }
  }
  writeHistoryFiles(files) {
    files.forEach((f) => this.writeHistoryFile(f.path, f.data, f.newFile));
  }
  mergeHistoryFiles(files) {
    Object.entries(files).forEach(([path2, { data, newFile }]) => {
      if (this.history[path2] == void 0) {
        this.history[path2] = { data, newFile };
      } else {
        this.history[path2].newFile = newFile;
      }
    });
  }
  deleteHistoryFile(path2) {
    delete this.history[path2];
  }
  deleteHistoryFiles() {
    this.history = {};
  }
  async _watcherRenameFile(oldPath, newPath) {
    const oldNormalizedPath = normalizePath(oldPath);
    const newNormalizedPath = normalizePath(newPath);
    const fileData = await this.delegate.readFile(oldPath);
    const changedFile = await this.readHistoryFile(oldNormalizedPath);
    if (changedFile == null) {
      this.writeHistoryFile(newNormalizedPath, fileData, false);
      this.writeHistoryFile(oldNormalizedPath, null, false);
    } else {
      this.writeHistoryFile(newNormalizedPath, changedFile.data, changedFile.newFile);
      this.writeHistoryFile(oldNormalizedPath, null, changedFile.newFile);
    }
  }
  async _watcherWriteFile(path2, data) {
    const normalizedPath = normalizePath(path2);
    const changedFile = await this.readHistoryFile(normalizedPath);
    if (changedFile == null) {
      const fileExist = await this.delegate.readFile(path2);
      this.writeHistoryFile(normalizedPath, data, fileExist == void 0);
    } else {
      this.writeHistoryFile(normalizedPath, data, changedFile.newFile);
    }
  }
  async _watcherDeleteFile(path2) {
    const normalizedPath = normalizePath(path2);
    await this.writeHistoryFile(normalizedPath, null, false);
  }
}
class DevWorkbench {
  constructor(messagingService2, fsPort, files) {
    __publicField2(this, "messagingService");
    __publicField2(this, "graphQLEndpoint");
    __publicField2(this, "graphQLSecret");
    __publicField2(this, "introspection");
    __publicField2(this, "env");
    __publicField2(this, "cwd");
    __publicField2(this, "fs");
    __publicField2(this, "memfs");
    __publicField2(this, "fetchfs");
    __publicField2(this, "injectMode", "jamstack");
    __publicField2(this, "mode", "production");
    __publicField2(this, "command", "build");
    __publicField2(this, "transpiledFiles");
    let root2 = new Directory(URI$1.parse(""));
    if (files) {
      root2 = this._transformObjectToFsTree(files);
    }
    this.transpiledFiles = null;
    this.messagingService = messagingService2;
    const defaultFSPort = fsPort != null ? fsPort : 7500;
    this.messagingService.addEventListener("FILE_WRITE", ({ data, path: path2 }) => this.writeFile(path2, data));
    this.messagingService.addEventListener(MULTIPLE_FILE_WRITE, async (filesToWrite) => {
      let newFiles = {};
      files = this.transformFsTreeToObject(this.getRoot());
      filesToWrite.forEach(async (file) => {
        const { path: path2, data } = file;
        if (path2.endsWith(".graphql")) {
          messagingService2.postMessage(GENERATE_GRAPHQL, { path: path2, data });
        } else {
          if (path2.includes(".env"))
            await this.parseEnvs();
          newFiles = __spreadProps2(__spreadValues2({}, newFiles), {
            [path2]: data
          });
        }
      });
      frontendActions.transpileMultipleFiles(newFiles, this.env, files);
    });
    this.messagingService.addEventListener(MULTIPLE_FILE_DELETE, (data) => this.deleteFiles(data));
    messagingService2.addEventListener(GENERATE_GRAPHQL, async ({ data, path: path2 }) => await this.generateGraphql(data, path2));
    messagingService2.addEventListener(FRONTEND_FILE_WRITE, async ({ data, path: path2 }) => {
      if (path2.endsWith(".graphql"))
        messagingService2.postMessage(GENERATE_GRAPHQL, { data, path: path2 });
      else {
        if (path2.includes(".env"))
          await this.parseEnvs();
        frontendActions.transpileSingleFile(path2, data, this.transpiledFiles, this.env);
        if (path2.includes(".tsx")) {
          files = this.transformFsTreeToObject(this.getRoot());
          notifyVSCodeFrontend(path2, data);
        }
      }
    });
    messagingService2.addEventListener(GET_PROJECT_FROM_ARCHIVE, async ({ url }) => {
      const files2 = await fetchProjectTar(url, this.command);
      this.memfs.setRoot(this._transformObjectToFsTree(files2));
      frontendActions.projectLoaded(files2);
    });
    messagingService2.addEventListener(UPDATE_TRANSPILED_FILES, (transpiledFiles) => this.transpiledFiles = transpiledFiles);
    this.memfs = new WriterMemoryFS(root2);
    this.fetchfs = new WriterFetchFS(defaultFSPort);
  }
  async generateGraphql(path2, data) {
    var _a2;
    const files = this.transformFsTreeToObject(this.getRoot());
    const codegen2 = await graphqlCodegen({
      workbench,
      files,
      data,
      path: path2
    });
    if ((_a2 = codegen2 == null ? void 0 : codegen2.generated) == null ? void 0 : _a2.errors)
      return codegen2;
    const { generated, generatedFilePaths } = codegen2;
    let filesToWrite = [];
    if ((generatedFilePaths == null ? void 0 : generatedFilePaths.introspection) && (generated == null ? void 0 : generated.introspection))
      filesToWrite = [
        ...filesToWrite,
        {
          path: generatedFilePaths == null ? void 0 : generatedFilePaths.introspection,
          data: generated == null ? void 0 : generated.introspection
        }
      ];
    if ((generatedFilePaths == null ? void 0 : generatedFilePaths.graphql) && (generated == null ? void 0 : generated.graphql))
      filesToWrite = [
        ...filesToWrite,
        {
          path: generatedFilePaths == null ? void 0 : generatedFilePaths.graphql,
          data: generated == null ? void 0 : generated.graphql
        }
      ];
    await this.writeFiles(filesToWrite);
  }
  async readFile(path2, encoding) {
    const content2 = await this.fs.readFile(path2, encoding, this.injectMode);
    if (!(content2 instanceof VSCodeFSTransferableError))
      return content2;
  }
  async readDirectory(path2, extensions, exclude, include, depth2) {
    return await this.fs.readDirectory(path2, extensions, exclude, include, depth2, this.injectMode);
  }
  async writeFile(path2, data) {
    const content2 = await this.fs.writeFile(path2, data, {
      create: true,
      overwrite: true
    });
    if (this.injectMode === "jamstack") {
      const uri2 = URI$1.parse(normalizePath(path2));
      const uintData = Buffer.from(data);
      if (!(content2 instanceof VSCodeFSTransferableError)) {
        dispatchFrontendFileWriteAction(uri2, uintData);
      }
      notifyVSCodeFrontend(path2, data);
    }
  }
  async renameFile(oldPath, newPath) {
    this.fs.renameFile(oldPath, newPath);
  }
  async deleteFile(path2) {
    this.fs.deleteFile(path2);
  }
  async writeFiles(files) {
    let filesToWrite = [];
    for (const file of files) {
      const { path: path2, data } = file;
      const content2 = await this.fs.writeFile(path2, data, {
        create: true,
        overwrite: true
      });
      if (this.injectMode === "jamstack") {
        const uri2 = URI$1.parse(normalizePath(path2));
        const buffer = Buffer.from(data);
        const stringContent = buffer.toString();
        if (!(content2 instanceof VSCodeFSTransferableError))
          filesToWrite = [
            ...filesToWrite,
            { path: uri2.path, data: stringContent }
          ];
      } else
        this.writeFile(path2, data);
    }
    if (this.injectMode === "jamstack")
      frontendActions.multipleFileWrite(filesToWrite);
  }
  async parseEnvs() {
    const envFileContent = await this.readEnvFileContent();
    const parsedEnvs = main.parse(envFileContent);
    this.env = __spreadValues2(__spreadValues2({}, this.env), parsedEnvs);
    return this.env;
  }
  async readEnvFileContent() {
    const envFileName = `.env.${this.mode}`;
    const directoryPath = this.injectMode === "jamstack" ? "" : this.cwd;
    const directoryContent = await this.readDirectory(directoryPath);
    if (directoryContent.find((content2) => content2.fileName === envFileName))
      return await this.readFile(envFileName);
    for (const content2 of directoryContent) {
      if (content2.fileName.includes(".env"))
        return await this.readFile(content2.fileName);
    }
    return "";
  }
  async writeEnvFileContent(data) {
    const envFileName = `.env.${this.mode}`;
    await this.writeFile(envFileName, data);
  }
  rename(oldUri, newUri, options2) {
    if (!options2.overwrite && lookup(newUri, true, this.getRoot())) {
      return new VSCodeFSTransferableError(VsCodeFSErrors.FileExists, newUri);
    }
    const oldParent = lookupParentDirectory(oldUri, this.getRoot());
    const newParent = lookupParentDirectory(newUri, this.getRoot());
    if (oldParent instanceof VSCodeFSTransferableError) {
      return oldParent;
    }
    if (newParent instanceof VSCodeFSTransferableError) {
      return newParent;
    }
    this.fs.renameFile(oldUri.path, newUri.path);
    this._renameInTranspiledFiles(oldUri, newUri);
  }
  delete(uri2) {
    const dirname2 = URI$1.parse(resolveDirname(uri2));
    const basename2 = resolveFilename(uri2);
    const parent = lookupAsDirectory(dirname2, false, this.getRoot());
    if (parent instanceof VSCodeFSTransferableError) {
      return parent;
    }
    if (!parent.entries.has(basename2)) {
      return new VSCodeFSTransferableError(VsCodeFSErrors.FileNotFound, uri2);
    }
    this.fs.deleteFile(normalizePath(uri2.path));
    this._deleteInTranspiledFiles(uri2);
  }
  stat(uri2) {
    return lookup(uri2, false, this.getRoot());
  }
  createDirectory(uri2) {
    const dirname2 = URI$1.parse(resolveDirname(uri2));
    const parent = lookupAsDirectory(dirname2, false, this.getRoot());
    if (parent instanceof VSCodeFSTransferableError) {
      return parent;
    }
    this.fs.createDirectory(uri2);
  }
  async deleteFiles(files) {
    await this.fs.deleteFiles(files);
  }
  setPort(fsPort) {
    this.fetchfs.setPort(fsPort);
  }
  _transformObjectToFsTree(files) {
    const root2 = new Directory(URI$1.parse(""));
    for (const path2 in files) {
      const pathParts = path2.split("/").filter(Boolean);
      let currentDir = root2;
      pathParts.forEach((p2, i2) => {
        if (i2 === pathParts.length - 1) {
          if (files[path2] === null) {
            currentDir.entries.set(p2, new Directory(URI$1.parse(path2)));
          } else {
            const fileContent = files[path2];
            if (fileContent) {
              const fileUri = URI$1.parse(path2);
              currentDir.entries.set(p2, new File(fileUri, Buffer.from(fileContent)));
            }
          }
        }
        if (!currentDir.entries.has(p2)) {
          const dir = pathParts.slice(0, i2 + 1);
          const dirString = dir.join("/");
          currentDir.entries.set(p2, new Directory(URI$1.parse(dirString)));
        }
        currentDir = currentDir.entries.get(p2);
      });
    }
    return root2;
  }
  setCwd(cwd) {
    this.cwd = cwd;
  }
  transformFsTreeToObject(root2) {
    const files = {};
    let currRoot = root2;
    const stack = [];
    do {
      currRoot.entries.forEach((e) => {
        if (e instanceof File)
          files[e.uri.path] = uint8ToString(e.data);
        if (e instanceof Directory)
          stack.push(e);
      });
      currRoot = stack.pop();
    } while (currRoot);
    return files;
  }
  readFileTree(uri2) {
    const data = lookupAsFile(uri2, false, this.getRoot());
    if (data instanceof VSCodeFSTransferableError) {
      return data;
    }
    return data.data;
  }
  readDirectoryTree(uri2) {
    const entry = lookupAsDirectory(uri2, false, this.getRoot());
    if (entry instanceof VSCodeFSTransferableError) {
      return entry;
    }
    const result2 = [];
    for (const [name, child] of entry.entries) {
      result2.push([name, child.type]);
    }
    return result2;
  }
  async writeFileTree(uri2, content2, options2) {
    const normalizedContent = transformObjectToUint8Array(content2);
    const norContent = await this.fs.writeFile(normalizePath(uri2.path), uint8ToString(normalizedContent), options2);
    if (norContent instanceof Uint8Array || norContent instanceof VSCodeFSTransferableError)
      return norContent;
  }
  _renameInTranspiledFiles(oldUri, newUri) {
    const oldPath = stripExtension$1(oldUri.path);
    const newPath = stripExtension$1(newUri.path);
    delete Object.assign(this.transpiledFiles, {
      [newPath]: this.transpiledFiles[oldPath]
    })[oldPath];
    if (this.transpiledFiles)
      frontendActions.bundleFiles(this.transpiledFiles);
  }
  _deleteInTranspiledFiles(uri2) {
    const path2 = stripExtension$1(uri2.path);
    delete this.transpiledFiles[path2];
    if (this.transpiledFiles)
      frontendActions.bundleFiles(this.transpiledFiles);
  }
  getRoot() {
    return this.memfs.getRoot();
  }
  setInjectionMode(injectMode) {
    this.injectMode = injectMode;
    this.fs = this.injectMode === "jamstack" ? new WatcherProxyFS(this.memfs) : new WatcherProxyFS(this.fetchfs);
  }
  setGraphQLEndpoint(graphQLEndpoint, graphQLSecret) {
    this.graphQLEndpoint = graphQLEndpoint;
    this.graphQLSecret = graphQLSecret;
  }
  setIntrospection(introspection) {
    this.introspection = introspection;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setCommand(command) {
    this.command = command;
  }
  setEnv(env) {
    this.env = env;
  }
}
class FrontendActions {
  constructor(messagingService2) {
    __publicField2(this, "messagingService");
    this.messagingService = messagingService2;
  }
  commitAllChanges() {
    this.messagingService.postMessage(COMMIT_ALL_CHANGES, {});
  }
  saveZip() {
    this.messagingService.postMessage(SAVE_ZIP, {});
  }
  fileWrite(path2, data) {
    this.messagingService.postMessage(FILE_WRITE, { path: path2, data });
  }
  multipleFileWrite(files) {
    this.messagingService.postMessage(MULTIPLE_FILE_WRITE, files);
  }
  multipleFileDelete(files) {
    this.messagingService.postMessage(MULTIPLE_FILE_DELETE, files);
  }
  frontendFileWrite(path2, data) {
    this.messagingService.postMessage(FRONTEND_FILE_WRITE, {
      path: path2,
      data
    });
  }
  elementHighlightClick(type2, source) {
    this.messagingService.postMessage(type2, source);
  }
  generateGraphql(path2, data) {
    this.messagingService.postMessage(GENERATE_GRAPHQL, {
      path: path2,
      data
    });
  }
  getProjectFromArchive(url) {
    this.messagingService.postMessage(GET_PROJECT_FROM_ARCHIVE, {
      url
    });
  }
  transpileError(err2) {
    this.messagingService.postMessage(TRANSPILER_ERROR, { err: err2 });
  }
  transpileSingleFile(path2, data, files, env) {
    this.messagingService.postMessage(TRANSPILE_SINGLE_FILE, {
      files,
      path: path2,
      data,
      env
    });
  }
  transpileMultipleFiles(newFiles, env, files) {
    this.messagingService.postMessage(TRANSPILE_MULTIPLE_FILES, {
      newFiles,
      env,
      files
    });
  }
  updateTranspiledFiles(transpiledFiles) {
    this.messagingService.postMessage(UPDATE_TRANSPILED_FILES, transpiledFiles);
  }
  bundleFiles(files, bundleEntry) {
    this.messagingService.postMessage(BUNDLE_FILES, {
      files,
      bundleEntry
    });
  }
  perfromReactRefresh(bundle) {
    this.messagingService.postMessage(PERFORM_REACT_REFRESH, { bundle });
  }
  refreshIframe(bundle) {
    this.messagingService.postMessage(REFRESH_IFRAME, {
      bundle
    });
  }
  projectLoaded(files) {
    this.messagingService.postMessage(PROJECT_LOADED, {
      files
    });
  }
  connectElementHighlight() {
    this.messagingService.postMessage(CONNECT_ELEMENT_HIGHLIGHT, {});
  }
  transpileFiles(files, env) {
    this.messagingService.postMessage(TRANSPILE_FILES, {
      files,
      env
    });
  }
}
var babel$1 = { exports: {} };
/** @license React vundefined
 * react-refresh-babel.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var reactRefreshBabel_production_min = function(r) {
  function t(a, b) {
    var c2 = a.scope.generateUidIdentifier("c");
    l2.has(a) || l2.set(a, []);
    l2.get(a).push({ handle: c2, persistentID: b });
    return c2;
  }
  function u(a) {
    return typeof a === "string" && "A" <= a[0] && "Z" >= a[0];
  }
  function m(a, b, c2) {
    var d = b.node;
    switch (d.type) {
      case "Identifier":
        if (!u(d.name))
          break;
        c2(a, d, null);
        return true;
      case "FunctionDeclaration":
        return c2(a, d.id, null), true;
      case "ArrowFunctionExpression":
        if (d.body.type === "ArrowFunctionExpression")
          break;
        c2(a, d, b);
        return true;
      case "FunctionExpression":
        return c2(a, d, b), true;
      case "CallExpression":
        var f = b.get("arguments");
        if (f === void 0 || f.length === 0)
          break;
        var g = b.get("callee");
        switch (g.node.type) {
          case "MemberExpression":
          case "Identifier":
            g = g.getSource();
            if (!m(a + "$" + g, f[0], c2))
              return false;
            c2(a, d, b);
            return true;
          default:
            return false;
        }
      case "VariableDeclarator":
        if (f = d.init, f !== null && (g = d.id.name, u(g))) {
          switch (f.type) {
            case "ArrowFunctionExpression":
            case "FunctionExpression":
              break;
            case "CallExpression":
              d = f.callee;
              var e2 = d.type;
              if (e2 === "Import" || e2 === "Identifier" && (d.name.indexOf("require") === 0 || d.name.indexOf("import") === 0))
                return false;
              break;
            case "TaggedTemplateExpression":
              break;
            default:
              return false;
          }
          d = b.get("init");
          if (m(a, d, c2))
            return true;
          g = b.scope.getBinding(g);
          if (g === void 0)
            return;
          b = false;
          g = g.referencePaths;
          for (e2 = 0; e2 < g.length; e2++) {
            var h = g[e2];
            if (!h.node || h.node.type === "JSXIdentifier" || h.node.type === "Identifier") {
              h = h.parent;
              if (h.type === "JSXOpeningElement")
                b = true;
              else if (h.type === "CallExpression") {
                h = h.callee;
                var k3 = void 0;
                switch (h.type) {
                  case "Identifier":
                    k3 = h.name;
                    break;
                  case "MemberExpression":
                    k3 = h.property.name;
                }
                switch (k3) {
                  case "createElement":
                  case "jsx":
                  case "jsxDEV":
                  case "jsxs":
                    b = true;
                }
              }
              if (b)
                return c2(a, f, d), true;
            }
          }
        }
    }
    return false;
  }
  function w(a) {
    a = n2.get(a);
    return a === void 0 ? null : { key: a.map(function(a2) {
      return a2.name + "{" + a2.key + "}";
    }).join("\n"), customHooks: a.filter(function(a2) {
      a:
        switch (a2.name) {
          case "useState":
          case "React.useState":
          case "useReducer":
          case "React.useReducer":
          case "useEffect":
          case "React.useEffect":
          case "useLayoutEffect":
          case "React.useLayoutEffect":
          case "useMemo":
          case "React.useMemo":
          case "useCallback":
          case "React.useCallback":
          case "useRef":
          case "React.useRef":
          case "useContext":
          case "React.useContext":
          case "useImperativeHandle":
          case "React.useImperativeHandle":
          case "useDebugValue":
          case "React.useDebugValue":
            a2 = true;
            break a;
          default:
            a2 = false;
        }
      return !a2;
    }).map(function(a2) {
      return e.cloneDeep(a2.callee);
    }) };
  }
  function B(a) {
    a = a.hub.file;
    var b = x2.get(a);
    if (b !== void 0)
      return b;
    b = false;
    for (var c2 = a.ast.comments, d = 0; d < c2.length; d++)
      if (c2[d].value.indexOf("@refresh reset") !== -1) {
        b = true;
        break;
      }
    x2.set(a, b);
    return b;
  }
  function v(a, b, c2) {
    var d = b.key;
    b = b.customHooks;
    var f = B(c2.path), g = [];
    b.forEach(function(a2) {
      switch (a2.type) {
        case "MemberExpression":
          if (a2.object.type === "Identifier")
            var b2 = a2.object.name;
          break;
        case "Identifier":
          b2 = a2.name;
      }
      c2.hasBinding(b2) ? g.push(a2) : f = true;
    });
    b = d;
    typeof commonjsRequire !== "function" || p2.emitFullSignatures || (b = require$$0.createHash("sha1").update(d).digest("base64"));
    a = [a, e.stringLiteral(b)];
    (f || 0 < g.length) && a.push(e.booleanLiteral(f));
    0 < g.length && a.push(e.functionExpression(null, [], e.blockStatement([e.returnStatement(e.arrayExpression(g))])));
    return a;
  }
  function C(a) {
    for (var b = []; ; ) {
      if (!a)
        return b;
      var c2 = a.parentPath;
      if (!c2)
        return b;
      if (c2.node.type === "AssignmentExpression" && a.node === c2.node.right)
        a = c2;
      else if (c2.node.type === "CallExpression" && a.node !== c2.node.callee)
        b.push(c2), a = c2;
      else
        return b;
    }
  }
  var p2 = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof r.env === "function") {
    var y2 = r.env();
    if (y2 !== "development" && !p2.skipEnvCheck)
      throw Error('React Refresh Babel transform should only be enabled in development environment. Instead, the environment is: "' + y2 + '". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');
  }
  var e = r.types, D = e.identifier(p2.refreshReg || "$RefreshReg$"), z2 = e.identifier(p2.refreshSig || "$RefreshSig$"), l2 = /* @__PURE__ */ new Map(), x2 = /* @__PURE__ */ new WeakMap(), k2 = /* @__PURE__ */ new WeakSet(), q = /* @__PURE__ */ new WeakSet(), A = /* @__PURE__ */ new WeakSet(), n2 = /* @__PURE__ */ new WeakMap(), E = { CallExpression: function(a) {
    var b = a.node.callee, c2 = null;
    switch (b.type) {
      case "Identifier":
        c2 = b.name;
        break;
      case "MemberExpression":
        c2 = b.property.name;
    }
    if (c2 !== null && /^use[A-Z]/.test(c2) && (b = a.scope.getFunctionParent(), b !== null)) {
      b = b.block;
      n2.has(b) || n2.set(b, []);
      b = n2.get(b);
      var d = "";
      a.parent.type === "VariableDeclarator" && (d = a.parentPath.get("id").getSource());
      var f = a.get("arguments");
      c2 === "useState" && 0 < f.length ? d += "(" + f[0].getSource() + ")" : c2 === "useReducer" && 1 < f.length && (d += "(" + f[1].getSource() + ")");
      b.push({ callee: a.node.callee, name: c2, key: d });
    }
  } };
  return { visitor: { ExportDefaultDeclaration: function(a) {
    var b = a.node, c2 = b.declaration, d = a.get("declaration");
    if (c2.type === "CallExpression" && !k2.has(b)) {
      k2.add(b);
      var f = a.parentPath;
      m("%default%", d, function(a2, b2, c3) {
        c3 !== null && (a2 = t(f, a2), c3.replaceWith(e.assignmentExpression("=", a2, b2)));
      });
    }
  }, FunctionDeclaration: { enter: function(a) {
    var b = a.node;
    switch (a.parent.type) {
      case "Program":
        var c2 = a;
        var d = a.parentPath;
        break;
      case "ExportNamedDeclaration":
        c2 = a.parentPath;
        d = c2.parentPath;
        break;
      case "ExportDefaultDeclaration":
        c2 = a.parentPath;
        d = c2.parentPath;
        break;
      default:
        return;
    }
    var f = b.id;
    f !== null && (f = f.name, u(f) && !k2.has(b) && (k2.add(b), m(f, a, function(a2, b2) {
      a2 = t(d, a2);
      c2.insertAfter(e.expressionStatement(e.assignmentExpression("=", a2, b2)));
    })));
  }, exit: function(a) {
    var b = a.node, c2 = b.id;
    if (c2 !== null) {
      var d = w(b);
      if (d !== null && !q.has(b)) {
        q.add(b);
        b = a.scope.generateUidIdentifier("_s");
        a.scope.parent.push({ id: b, init: e.callExpression(z2, []) });
        a.get("body").unshiftContainer("body", e.expressionStatement(e.callExpression(b, [])));
        var f = null;
        a.find(function(a2) {
          if (a2.parentPath.isBlock())
            return f = a2, true;
        });
        f !== null && f.insertAfter(e.expressionStatement(e.callExpression(b, v(c2, d, f.scope))));
      }
    }
  } }, "ArrowFunctionExpression|FunctionExpression": { exit: function(a) {
    var b = a.node, c2 = w(b);
    if (c2 !== null && !q.has(b)) {
      q.add(b);
      var d = a.scope.generateUidIdentifier("_s");
      a.scope.parent.push({ id: d, init: e.callExpression(z2, []) });
      a.node.body.type !== "BlockStatement" && (a.node.body = e.blockStatement([e.returnStatement(a.node.body)]));
      a.get("body").unshiftContainer("body", e.expressionStatement(e.callExpression(d, [])));
      if (a.parent.type === "VariableDeclarator") {
        var f = null;
        a.find(function(a2) {
          if (a2.parentPath.isBlock())
            return f = a2, true;
        });
        f !== null && f.insertAfter(e.expressionStatement(e.callExpression(d, v(a.parent.id, c2, f.scope))));
      } else
        [a].concat(C(a)).forEach(function(a2) {
          a2.replaceWith(e.callExpression(d, v(a2.node, c2, a2.scope)));
        });
    }
  } }, VariableDeclaration: function(a) {
    var b = a.node;
    switch (a.parent.type) {
      case "Program":
        var c2 = a;
        var d = a.parentPath;
        break;
      case "ExportNamedDeclaration":
        c2 = a.parentPath;
        d = c2.parentPath;
        break;
      case "ExportDefaultDeclaration":
        c2 = a.parentPath;
        d = c2.parentPath;
        break;
      default:
        return;
    }
    if (!k2.has(b) && (k2.add(b), a = a.get("declarations"), a.length === 1)) {
      var f = a[0];
      m(f.node.id.name, f, function(a2, b2, h) {
        h !== null && (a2 = t(d, a2), h.parent.type === "VariableDeclarator" ? c2.insertAfter(e.expressionStatement(e.assignmentExpression("=", a2, f.node.id))) : h.replaceWith(e.assignmentExpression("=", a2, b2)));
      });
    }
  }, Program: { enter: function(a) {
    a.traverse(E);
  }, exit: function(a) {
    var b = l2.get(a);
    if (b !== void 0) {
      var c2 = a.node;
      if (!A.has(c2)) {
        A.add(c2);
        l2.delete(a);
        var d = [];
        a.pushContainer("body", e.variableDeclaration("var", d));
        b.forEach(function(b2) {
          var c3 = b2.handle;
          a.pushContainer("body", e.expressionStatement(e.callExpression(D, [c3, e.stringLiteral(b2.persistentID)])));
          d.push(e.variableDeclarator(c3));
        });
      }
    }
  } } } };
};
{
  babel$1.exports = reactRefreshBabel_production_min;
}
var reactRefreshPlugin = babel$1.exports;
const JS_EXTENSIONS = [".js", ".jsx", ".ts", ".tsx"];
const stripExtension = (fileName) => {
  const dot = fileName.lastIndexOf(".");
  const hasExtension = dot > 0 && dot < fileName.length;
  if (hasExtension) {
    return fileName.substring(0, dot);
  }
  return fileName;
};
const changeImports = (sourceFile, filePath) => {
  const imports = sourceFile.getImportDeclarations();
  imports.forEach((i2) => {
    let importString = i2.getModuleSpecifierValue();
    if (importString === "./" || importString === ".") {
      i2.setModuleSpecifier("./index");
    }
    if (!i2.isModuleSpecifierRelative() && importString.startsWith("src/")) {
      let relativePath = absoluteToRelativePath(prefixString(importString, "/"), filePath);
      i2.setModuleSpecifier(relativePath);
    } else if (!i2.isModuleSpecifierRelative() && !importString.endsWith(".css")) {
      replaceDependencyImports(i2);
    } else if (importString.endsWith(".css")) {
      i2.replaceWithText(`//${i2.getText()}`);
    }
  });
};
const injectEnvs = (file, env) => {
  Object.keys(env).forEach((key) => {
    const nodes = findAllByCondition(file, (node) => {
      if (tsmorph.Node.isPropertyAccessExpression(node)) {
        const nodeText = node.getText();
        return nodeText.match(/\bimport\b.meta.env./g) != null && nodeText.endsWith(key);
      }
      return false;
    });
    if (nodes.length != 0)
      nodes.forEach((node) => node.replaceWithText(`'${env[key]}'`));
  });
};
const absoluteToRelativePath = (absolutePath, currentPath) => {
  const folders = currentPath.split("/");
  let relativePath = "";
  folders.pop();
  const current = folders[folders.length - 1];
  if (absolutePath.match(`/${current}/`)) {
    const substring = absolutePath.substring(absolutePath.lastIndexOf(`/${current}/`) + `/${current}/`.length);
    return "./" + substring;
  } else {
    relativePath += "../";
    folders.pop();
  }
  while (folders.length > 0) {
    const current2 = folders.pop();
    if (absolutePath.match(`/${current2}/`)) {
      const substring = absolutePath.substring(absolutePath.lastIndexOf(`/${current2}/`) + `/${current2}/`.length);
      return relativePath + substring;
    } else {
      relativePath += "../";
    }
  }
  return absolutePath;
};
const replaceDependencyImports = (i2) => {
  var _a2, _b, _c;
  const defaultImport = `const ${(_c = (_a2 = i2.getDefaultImport()) == null ? void 0 : _a2.print()) != null ? _c : (_b = i2.getNamespaceImport()) == null ? void 0 : _b.print()} = requireDefault('${i2.getModuleSpecifierValue()}')`;
  const namedImports = `const { ${i2.getNamedImports().map((imp) => imp.print().replaceAll(/as/g, ":")).join(",")} } = require('${i2.getModuleSpecifierValue()}')`;
  if (i2.getNamedImports().length && i2.getDefaultImport()) {
    i2.replaceWithText(defaultImport + "\n" + namedImports);
  } else if (i2.getDefaultImport() || i2.getNamespaceImport()) {
    i2.replaceWithText(defaultImport);
  } else if (i2.getNamedImports()) {
    i2.replaceWithText(namedImports);
  }
};
const prefixString = (string, prefix) => string.startsWith(prefix) ? string : prefix + string;
var URI = { exports: {} };
var punycode = { exports: {} };
/*! https://mths.be/punycode v1.4.0 by @mathias */
(function(module2, exports2) {
  (function(root2) {
    var freeExports2 = exports2 && !exports2.nodeType && exports2;
    var freeModule2 = module2 && !module2.nodeType && module2;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error2(type2) {
      throw new RangeError(errors[type2]);
    }
    function map2(array, fn2) {
      var length = array.length;
      var result2 = [];
      while (length--) {
        result2[length] = fn2(array[length]);
      }
      return result2;
    }
    function mapDomain(string, fn2) {
      var parts2 = string.split("@");
      var result2 = "";
      if (parts2.length > 1) {
        result2 = parts2[0] + "@";
        string = parts2[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn2).join(".");
      return result2 + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value2, extra;
      while (counter < length) {
        value2 = string.charCodeAt(counter++);
        if (value2 >= 55296 && value2 <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map2(array, function(value2) {
        var output = "";
        if (value2 > 65535) {
          value2 -= 65536;
          output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
          value2 = 56320 | value2 & 1023;
        }
        output += stringFromCharCode(value2);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode(input) {
      var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index2, oldi, w, k2, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error2("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        for (oldi = i2, w = 1, k2 = base; ; k2 += base) {
          if (index2 >= inputLength) {
            error2("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base || digit > floor((maxInt - i2) / w)) {
            error2("overflow");
          }
          i2 += digit * w;
          t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error2("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n2) {
          error2("overflow");
        }
        n2 += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return ucs2encode(output);
    }
    function encode(input) {
      var n2, delta, handledCPCount, basicLength, bias, j2, m, q, k2, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n2 && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error2("overflow");
        }
        delta += (m - n2) * handledCPCountPlusOne;
        n2 = m;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n2 && ++delta > maxInt) {
            error2("overflow");
          }
          if (currentValue == n2) {
            for (q = delta, k2 = base; ; k2 += base) {
              t = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    }
    punycode2 = {
      "version": "1.3.2",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports2 && freeModule2) {
      if (module2.exports == freeExports2) {
        freeModule2.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports2[key] = punycode2[key]);
        }
      }
    } else {
      root2.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode, punycode.exports);
var IPv6 = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function(module2) {
  (function(root2, factory2) {
    if (module2.exports) {
      module2.exports = factory2();
    } else {
      root2.IPv6 = factory2(root2);
    }
  })(commonjsGlobal, function(root2) {
    var _IPv6 = root2 && root2.IPv6;
    function bestPresentation(address) {
      var _address = address.toLowerCase();
      var segments = _address.split(":");
      var length = segments.length;
      var total = 8;
      if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
        segments.shift();
        segments.shift();
      } else if (segments[0] === "" && segments[1] === "") {
        segments.shift();
      } else if (segments[length - 1] === "" && segments[length - 2] === "") {
        segments.pop();
      }
      length = segments.length;
      if (segments[length - 1].indexOf(".") !== -1) {
        total = 7;
      }
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (segments[pos] === "") {
          break;
        }
      }
      if (pos < total) {
        segments.splice(pos, 1, "0000");
        while (segments.length < total) {
          segments.splice(pos, 0, "0000");
        }
      }
      var _segments;
      for (var i2 = 0; i2 < total; i2++) {
        _segments = segments[i2].split("");
        for (var j2 = 0; j2 < 3; j2++) {
          if (_segments[0] === "0" && _segments.length > 1) {
            _segments.splice(0, 1);
          } else {
            break;
          }
        }
        segments[i2] = _segments.join("");
      }
      var best = -1;
      var _best = 0;
      var _current = 0;
      var current = -1;
      var inzeroes = false;
      for (i2 = 0; i2 < total; i2++) {
        if (inzeroes) {
          if (segments[i2] === "0") {
            _current += 1;
          } else {
            inzeroes = false;
            if (_current > _best) {
              best = current;
              _best = _current;
            }
          }
        } else {
          if (segments[i2] === "0") {
            inzeroes = true;
            current = i2;
            _current = 1;
          }
        }
      }
      if (_current > _best) {
        best = current;
        _best = _current;
      }
      if (_best > 1) {
        segments.splice(best, _best, "");
      }
      length = segments.length;
      var result2 = "";
      if (segments[0] === "") {
        result2 = ":";
      }
      for (i2 = 0; i2 < length; i2++) {
        result2 += segments[i2];
        if (i2 === length - 1) {
          break;
        }
        result2 += ":";
      }
      if (segments[length - 1] === "") {
        result2 += ":";
      }
      return result2;
    }
    function noConflict() {
      if (root2.IPv6 === this) {
        root2.IPv6 = _IPv6;
      }
      return this;
    }
    return {
      best: bestPresentation,
      noConflict
    };
  });
})(IPv6);
var SecondLevelDomains = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function(module2) {
  (function(root2, factory2) {
    if (module2.exports) {
      module2.exports = factory2();
    } else {
      root2.SecondLevelDomains = factory2(root2);
    }
  })(commonjsGlobal, function(root2) {
    var _SecondLevelDomains = root2 && root2.SecondLevelDomains;
    var SLD = {
      list: {
        "ac": " com gov mil net org ",
        "ae": " ac co gov mil name net org pro sch ",
        "af": " com edu gov net org ",
        "al": " com edu gov mil net org ",
        "ao": " co ed gv it og pb ",
        "ar": " com edu gob gov int mil net org tur ",
        "at": " ac co gv or ",
        "au": " asn com csiro edu gov id net org ",
        "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
        "bb": " biz co com edu gov info net org store tv ",
        "bh": " biz cc com edu gov info net org ",
        "bn": " com edu gov net org ",
        "bo": " com edu gob gov int mil net org tv ",
        "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
        "bs": " com edu gov net org ",
        "bz": " du et om ov rg ",
        "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
        "ck": " biz co edu gen gov info net org ",
        "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
        "co": " com edu gov mil net nom org ",
        "cr": " ac c co ed fi go or sa ",
        "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
        "do": " art com edu gob gov mil net org sld web ",
        "dz": " art asso com edu gov net org pol ",
        "ec": " com edu fin gov info med mil net org pro ",
        "eg": " com edu eun gov mil name net org sci ",
        "er": " com edu gov ind mil net org rochest w ",
        "es": " com edu gob nom org ",
        "et": " biz com edu gov info name net org ",
        "fj": " ac biz com info mil name net org pro ",
        "fk": " ac co gov net nom org ",
        "fr": " asso com f gouv nom prd presse tm ",
        "gg": " co net org ",
        "gh": " com edu gov mil org ",
        "gn": " ac com gov net org ",
        "gr": " com edu gov mil net org ",
        "gt": " com edu gob ind mil net org ",
        "gu": " com edu gov net org ",
        "hk": " com edu gov idv net org ",
        "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
        "id": " ac co go mil net or sch web ",
        "il": " ac co gov idf k12 muni net org ",
        "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
        "iq": " com edu gov i mil net org ",
        "ir": " ac co dnssec gov i id net org sch ",
        "it": " edu gov ",
        "je": " co net org ",
        "jo": " com edu gov mil name net org sch ",
        "jp": " ac ad co ed go gr lg ne or ",
        "ke": " ac co go info me mobi ne or sc ",
        "kh": " com edu gov mil net org per ",
        "ki": " biz com de edu gov info mob net org tel ",
        "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
        "kn": " edu gov net org ",
        "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
        "kw": " com edu gov net org ",
        "ky": " com edu gov net org ",
        "kz": " com edu gov mil net org ",
        "lb": " com edu gov net org ",
        "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
        "lr": " com edu gov net org ",
        "lv": " asn com conf edu gov id mil net org ",
        "ly": " com edu gov id med net org plc sch ",
        "ma": " ac co gov m net org press ",
        "mc": " asso tm ",
        "me": " ac co edu gov its net org priv ",
        "mg": " com edu gov mil nom org prd tm ",
        "mk": " com edu gov inf name net org pro ",
        "ml": " com edu gov net org presse ",
        "mn": " edu gov org ",
        "mo": " com edu gov net org ",
        "mt": " com edu gov net org ",
        "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
        "mw": " ac co com coop edu gov int museum net org ",
        "mx": " com edu gob net org ",
        "my": " com edu gov mil name net org sch ",
        "nf": " arts com firm info net other per rec store web ",
        "ng": " biz com edu gov mil mobi name net org sch ",
        "ni": " ac co com edu gob mil net nom org ",
        "np": " com edu gov mil net org ",
        "nr": " biz com edu gov info net org ",
        "om": " ac biz co com edu gov med mil museum net org pro sch ",
        "pe": " com edu gob mil net nom org sld ",
        "ph": " com edu gov i mil net ngo org ",
        "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
        "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
        "pr": " ac biz com edu est gov info isla name net org pro prof ",
        "ps": " com edu gov net org plo sec ",
        "pw": " belau co ed go ne or ",
        "ro": " arts com firm info nom nt org rec store tm www ",
        "rs": " ac co edu gov in org ",
        "sb": " com edu gov net org ",
        "sc": " com edu gov net org ",
        "sh": " co com edu gov net nom org ",
        "sl": " com edu gov net org ",
        "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
        "sv": " com edu gob org red ",
        "sz": " ac co org ",
        "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
        "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
        "tw": " club com ebiz edu game gov idv mil net org ",
        "mu": " ac co com gov net or org ",
        "mz": " ac co edu gov org ",
        "na": " co com ",
        "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
        "pa": " abo ac com edu gob ing med net nom org sld ",
        "pt": " com edu gov int net nome org publ ",
        "py": " com edu gov mil net org ",
        "qa": " com edu gov mil net org ",
        "re": " asso com nom ",
        "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
        "rw": " ac co com edu gouv gov int mil net ",
        "sa": " com edu gov med net org pub sch ",
        "sd": " com edu gov info med net org tv ",
        "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
        "sg": " com edu gov idn net org per ",
        "sn": " art com edu gouv org perso univ ",
        "sy": " com edu gov mil net news org ",
        "th": " ac co go in mi net or ",
        "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
        "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
        "tz": " ac co go ne or ",
        "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
        "ug": " ac co go ne or org sc ",
        "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
        "us": " dni fed isa kids nsn ",
        "uy": " com edu gub mil net org ",
        "ve": " co com edu gob info mil net org web ",
        "vi": " co com k12 net org ",
        "vn": " ac biz com edu gov health info int name net org pro ",
        "ye": " co com gov ltd me net org plc ",
        "yu": " ac co edu gov org ",
        "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
        "zm": " ac co com edu gov net org sch ",
        "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
        "net": "gb jp se uk ",
        "org": "ae",
        "de": "com "
      },
      has: function(domain) {
        var tldOffset = domain.lastIndexOf(".");
        if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
          return false;
        }
        var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
      },
      is: function(domain) {
        var tldOffset = domain.lastIndexOf(".");
        if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
          return false;
        }
        var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
        if (sldOffset >= 0) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
      },
      get: function(domain) {
        var tldOffset = domain.lastIndexOf(".");
        if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
          return null;
        }
        var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
          return null;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return null;
        }
        if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
          return null;
        }
        return domain.slice(sldOffset + 1);
      },
      noConflict: function() {
        if (root2.SecondLevelDomains === this) {
          root2.SecondLevelDomains = _SecondLevelDomains;
        }
        return this;
      }
    };
    return SLD;
  });
})(SecondLevelDomains);
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function(module2) {
  (function(root2, factory2) {
    if (module2.exports) {
      module2.exports = factory2(punycode.exports, IPv6.exports, SecondLevelDomains.exports);
    } else {
      root2.URI = factory2(root2.punycode, root2.IPv6, root2.SecondLevelDomains, root2);
    }
  })(commonjsGlobal, function(punycode2, IPv62, SLD, root2) {
    var _URI = root2 && root2.URI;
    function URI2(url, base) {
      var _urlSupplied = arguments.length >= 1;
      var _baseSupplied = arguments.length >= 2;
      if (!(this instanceof URI2)) {
        if (_urlSupplied) {
          if (_baseSupplied) {
            return new URI2(url, base);
          }
          return new URI2(url);
        }
        return new URI2();
      }
      if (url === void 0) {
        if (_urlSupplied) {
          throw new TypeError("undefined is not a valid argument for URI");
        }
        if (typeof location !== "undefined") {
          url = location.href + "";
        } else {
          url = "";
        }
      }
      if (url === null) {
        if (_urlSupplied) {
          throw new TypeError("null is not a valid argument for URI");
        }
      }
      this.href(url);
      if (base !== void 0) {
        return this.absoluteTo(base);
      }
      return this;
    }
    function isInteger2(value2) {
      return /^[0-9]+$/.test(value2);
    }
    URI2.version = "1.19.11";
    var p2 = URI2.prototype;
    var hasOwn = Object.prototype.hasOwnProperty;
    function escapeRegEx2(string) {
      return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    }
    function getType(value2) {
      if (value2 === void 0) {
        return "Undefined";
      }
      return String(Object.prototype.toString.call(value2)).slice(8, -1);
    }
    function isArray2(obj2) {
      return getType(obj2) === "Array";
    }
    function filterArrayValues(data, value2) {
      var lookup2 = {};
      var i2, length;
      if (getType(value2) === "RegExp") {
        lookup2 = null;
      } else if (isArray2(value2)) {
        for (i2 = 0, length = value2.length; i2 < length; i2++) {
          lookup2[value2[i2]] = true;
        }
      } else {
        lookup2[value2] = true;
      }
      for (i2 = 0, length = data.length; i2 < length; i2++) {
        var _match = lookup2 && lookup2[data[i2]] !== void 0 || !lookup2 && value2.test(data[i2]);
        if (_match) {
          data.splice(i2, 1);
          length--;
          i2--;
        }
      }
      return data;
    }
    function arrayContains(list, value2) {
      var i2, length;
      if (isArray2(value2)) {
        for (i2 = 0, length = value2.length; i2 < length; i2++) {
          if (!arrayContains(list, value2[i2])) {
            return false;
          }
        }
        return true;
      }
      var _type = getType(value2);
      for (i2 = 0, length = list.length; i2 < length; i2++) {
        if (_type === "RegExp") {
          if (typeof list[i2] === "string" && list[i2].match(value2)) {
            return true;
          }
        } else if (list[i2] === value2) {
          return true;
        }
      }
      return false;
    }
    function arraysEqual(one, two) {
      if (!isArray2(one) || !isArray2(two)) {
        return false;
      }
      if (one.length !== two.length) {
        return false;
      }
      one.sort();
      two.sort();
      for (var i2 = 0, l2 = one.length; i2 < l2; i2++) {
        if (one[i2] !== two[i2]) {
          return false;
        }
      }
      return true;
    }
    function trimSlashes(text2) {
      var trim_expression = /^\/+|\/+$/g;
      return text2.replace(trim_expression, "");
    }
    URI2._parts = function() {
      return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        preventInvalidHostname: URI2.preventInvalidHostname,
        duplicateQueryParameters: URI2.duplicateQueryParameters,
        escapeQuerySpace: URI2.escapeQuerySpace
      };
    };
    URI2.preventInvalidHostname = false;
    URI2.duplicateQueryParameters = false;
    URI2.escapeQuerySpace = true;
    URI2.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
    URI2.idn_expression = /[^a-z0-9\._-]/i;
    URI2.punycode_expression = /(xn--)/i;
    URI2.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    URI2.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
    URI2.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
    URI2.findUri = {
      start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
      end: /[\s\r\n]|$/,
      trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
      parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
    };
    URI2.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    URI2.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
    URI2.defaultPorts = {
      http: "80",
      https: "443",
      ftp: "21",
      gopher: "70",
      ws: "80",
      wss: "443"
    };
    URI2.hostProtocols = [
      "http",
      "https"
    ];
    URI2.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
    URI2.domAttributes = {
      "a": "href",
      "blockquote": "cite",
      "link": "href",
      "base": "href",
      "script": "src",
      "form": "action",
      "img": "src",
      "area": "href",
      "iframe": "src",
      "embed": "src",
      "source": "src",
      "track": "src",
      "input": "src",
      "audio": "src",
      "video": "src"
    };
    URI2.getDomAttribute = function(node) {
      if (!node || !node.nodeName) {
        return void 0;
      }
      var nodeName = node.nodeName.toLowerCase();
      if (nodeName === "input" && node.type !== "image") {
        return void 0;
      }
      return URI2.domAttributes[nodeName];
    };
    function escapeForDumbFirefox36(value2) {
      return escape(value2);
    }
    function strictEncodeURIComponent(string) {
      return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
    }
    URI2.encode = strictEncodeURIComponent;
    URI2.decode = decodeURIComponent;
    URI2.iso8859 = function() {
      URI2.encode = escape;
      URI2.decode = unescape;
    };
    URI2.unicode = function() {
      URI2.encode = strictEncodeURIComponent;
      URI2.decode = decodeURIComponent;
    };
    URI2.characters = {
      pathname: {
        encode: {
          expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
          map: {
            "%24": "$",
            "%26": "&",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "=",
            "%3A": ":",
            "%40": "@"
          }
        },
        decode: {
          expression: /[\/\?#]/g,
          map: {
            "/": "%2F",
            "?": "%3F",
            "#": "%23"
          }
        }
      },
      reserved: {
        encode: {
          expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
          map: {
            "%3A": ":",
            "%2F": "/",
            "%3F": "?",
            "%23": "#",
            "%5B": "[",
            "%5D": "]",
            "%40": "@",
            "%21": "!",
            "%24": "$",
            "%26": "&",
            "%27": "'",
            "%28": "(",
            "%29": ")",
            "%2A": "*",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "="
          }
        }
      },
      urnpath: {
        encode: {
          expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
          map: {
            "%21": "!",
            "%24": "$",
            "%27": "'",
            "%28": "(",
            "%29": ")",
            "%2A": "*",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "=",
            "%40": "@"
          }
        },
        decode: {
          expression: /[\/\?#:]/g,
          map: {
            "/": "%2F",
            "?": "%3F",
            "#": "%23",
            ":": "%3A"
          }
        }
      }
    };
    URI2.encodeQuery = function(string, escapeQuerySpace) {
      var escaped = URI2.encode(string + "");
      if (escapeQuerySpace === void 0) {
        escapeQuerySpace = URI2.escapeQuerySpace;
      }
      return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
    };
    URI2.decodeQuery = function(string, escapeQuerySpace) {
      string += "";
      if (escapeQuerySpace === void 0) {
        escapeQuerySpace = URI2.escapeQuerySpace;
      }
      try {
        return URI2.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
      } catch (e) {
        return string;
      }
    };
    var _parts = { "encode": "encode", "decode": "decode" };
    var _part;
    var generateAccessor = function(_group, _part2) {
      return function(string) {
        try {
          return URI2[_part2](string + "").replace(URI2.characters[_group][_part2].expression, function(c2) {
            return URI2.characters[_group][_part2].map[c2];
          });
        } catch (e) {
          return string;
        }
      };
    };
    for (_part in _parts) {
      URI2[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
      URI2[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
    }
    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
      return function(string) {
        var actualCodingFunc;
        if (!_innerCodingFuncName) {
          actualCodingFunc = URI2[_codingFuncName];
        } else {
          actualCodingFunc = function(string2) {
            return URI2[_codingFuncName](URI2[_innerCodingFuncName](string2));
          };
        }
        var segments = (string + "").split(_sep);
        for (var i2 = 0, length = segments.length; i2 < length; i2++) {
          segments[i2] = actualCodingFunc(segments[i2]);
        }
        return segments.join(_sep);
      };
    };
    URI2.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
    URI2.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
    URI2.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
    URI2.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
    URI2.encodeReserved = generateAccessor("reserved", "encode");
    URI2.parse = function(string, parts2) {
      var pos;
      if (!parts2) {
        parts2 = {
          preventInvalidHostname: URI2.preventInvalidHostname
        };
      }
      string = string.replace(URI2.leading_whitespace_expression, "");
      string = string.replace(URI2.ascii_tab_whitespace, "");
      pos = string.indexOf("#");
      if (pos > -1) {
        parts2.fragment = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      pos = string.indexOf("?");
      if (pos > -1) {
        parts2.query = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
      string = string.replace(/^[/\\]{2,}/i, "//");
      if (string.substring(0, 2) === "//") {
        parts2.protocol = null;
        string = string.substring(2);
        string = URI2.parseAuthority(string, parts2);
      } else {
        pos = string.indexOf(":");
        if (pos > -1) {
          parts2.protocol = string.substring(0, pos) || null;
          if (parts2.protocol && !parts2.protocol.match(URI2.protocol_expression)) {
            parts2.protocol = void 0;
          } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
            string = string.substring(pos + 3);
            string = URI2.parseAuthority(string, parts2);
          } else {
            string = string.substring(pos + 1);
            parts2.urn = true;
          }
        }
      }
      parts2.path = string;
      return parts2;
    };
    URI2.parseHost = function(string, parts2) {
      if (!string) {
        string = "";
      }
      string = string.replace(/\\/g, "/");
      var pos = string.indexOf("/");
      var bracketPos;
      var t;
      if (pos === -1) {
        pos = string.length;
      }
      if (string.charAt(0) === "[") {
        bracketPos = string.indexOf("]");
        parts2.hostname = string.substring(1, bracketPos) || null;
        parts2.port = string.substring(bracketPos + 2, pos) || null;
        if (parts2.port === "/") {
          parts2.port = null;
        }
      } else {
        var firstColon = string.indexOf(":");
        var firstSlash = string.indexOf("/");
        var nextColon = string.indexOf(":", firstColon + 1);
        if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
          parts2.hostname = string.substring(0, pos) || null;
          parts2.port = null;
        } else {
          t = string.substring(0, pos).split(":");
          parts2.hostname = t[0] || null;
          parts2.port = t[1] || null;
        }
      }
      if (parts2.hostname && string.substring(pos).charAt(0) !== "/") {
        pos++;
        string = "/" + string;
      }
      if (parts2.preventInvalidHostname) {
        URI2.ensureValidHostname(parts2.hostname, parts2.protocol);
      }
      if (parts2.port) {
        URI2.ensureValidPort(parts2.port);
      }
      return string.substring(pos) || "/";
    };
    URI2.parseAuthority = function(string, parts2) {
      string = URI2.parseUserinfo(string, parts2);
      return URI2.parseHost(string, parts2);
    };
    URI2.parseUserinfo = function(string, parts2) {
      var _string = string;
      var firstBackSlash = string.indexOf("\\");
      if (firstBackSlash !== -1) {
        string = string.replace(/\\/g, "/");
      }
      var firstSlash = string.indexOf("/");
      var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
      var t;
      if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
        t = string.substring(0, pos).split(":");
        parts2.username = t[0] ? URI2.decode(t[0]) : null;
        t.shift();
        parts2.password = t[0] ? URI2.decode(t.join(":")) : null;
        string = _string.substring(pos + 1);
      } else {
        parts2.username = null;
        parts2.password = null;
      }
      return string;
    };
    URI2.parseQuery = function(string, escapeQuerySpace) {
      if (!string) {
        return {};
      }
      string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
      if (!string) {
        return {};
      }
      var items = {};
      var splits = string.split("&");
      var length = splits.length;
      var v, name, value2;
      for (var i2 = 0; i2 < length; i2++) {
        v = splits[i2].split("=");
        name = URI2.decodeQuery(v.shift(), escapeQuerySpace);
        value2 = v.length ? URI2.decodeQuery(v.join("="), escapeQuerySpace) : null;
        if (name === "__proto__") {
          continue;
        } else if (hasOwn.call(items, name)) {
          if (typeof items[name] === "string" || items[name] === null) {
            items[name] = [items[name]];
          }
          items[name].push(value2);
        } else {
          items[name] = value2;
        }
      }
      return items;
    };
    URI2.build = function(parts2) {
      var t = "";
      var requireAbsolutePath = false;
      if (parts2.protocol) {
        t += parts2.protocol + ":";
      }
      if (!parts2.urn && (t || parts2.hostname)) {
        t += "//";
        requireAbsolutePath = true;
      }
      t += URI2.buildAuthority(parts2) || "";
      if (typeof parts2.path === "string") {
        if (parts2.path.charAt(0) !== "/" && requireAbsolutePath) {
          t += "/";
        }
        t += parts2.path;
      }
      if (typeof parts2.query === "string" && parts2.query) {
        t += "?" + parts2.query;
      }
      if (typeof parts2.fragment === "string" && parts2.fragment) {
        t += "#" + parts2.fragment;
      }
      return t;
    };
    URI2.buildHost = function(parts2) {
      var t = "";
      if (!parts2.hostname) {
        return "";
      } else if (URI2.ip6_expression.test(parts2.hostname)) {
        t += "[" + parts2.hostname + "]";
      } else {
        t += parts2.hostname;
      }
      if (parts2.port) {
        t += ":" + parts2.port;
      }
      return t;
    };
    URI2.buildAuthority = function(parts2) {
      return URI2.buildUserinfo(parts2) + URI2.buildHost(parts2);
    };
    URI2.buildUserinfo = function(parts2) {
      var t = "";
      if (parts2.username) {
        t += URI2.encode(parts2.username);
      }
      if (parts2.password) {
        t += ":" + URI2.encode(parts2.password);
      }
      if (t) {
        t += "@";
      }
      return t;
    };
    URI2.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
      var t = "";
      var unique, key, i2, length;
      for (key in data) {
        if (key === "__proto__") {
          continue;
        } else if (hasOwn.call(data, key)) {
          if (isArray2(data[key])) {
            unique = {};
            for (i2 = 0, length = data[key].length; i2 < length; i2++) {
              if (data[key][i2] !== void 0 && unique[data[key][i2] + ""] === void 0) {
                t += "&" + URI2.buildQueryParameter(key, data[key][i2], escapeQuerySpace);
                if (duplicateQueryParameters !== true) {
                  unique[data[key][i2] + ""] = true;
                }
              }
            }
          } else if (data[key] !== void 0) {
            t += "&" + URI2.buildQueryParameter(key, data[key], escapeQuerySpace);
          }
        }
      }
      return t.substring(1);
    };
    URI2.buildQueryParameter = function(name, value2, escapeQuerySpace) {
      return URI2.encodeQuery(name, escapeQuerySpace) + (value2 !== null ? "=" + URI2.encodeQuery(value2, escapeQuerySpace) : "");
    };
    URI2.addQuery = function(data, name, value2) {
      if (typeof name === "object") {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            URI2.addQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === "string") {
        if (data[name] === void 0) {
          data[name] = value2;
          return;
        } else if (typeof data[name] === "string") {
          data[name] = [data[name]];
        }
        if (!isArray2(value2)) {
          value2 = [value2];
        }
        data[name] = (data[name] || []).concat(value2);
      } else {
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
      }
    };
    URI2.setQuery = function(data, name, value2) {
      if (typeof name === "object") {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            URI2.setQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === "string") {
        data[name] = value2 === void 0 ? null : value2;
      } else {
        throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
      }
    };
    URI2.removeQuery = function(data, name, value2) {
      var i2, length, key;
      if (isArray2(name)) {
        for (i2 = 0, length = name.length; i2 < length; i2++) {
          data[name[i2]] = void 0;
        }
      } else if (getType(name) === "RegExp") {
        for (key in data) {
          if (name.test(key)) {
            data[key] = void 0;
          }
        }
      } else if (typeof name === "object") {
        for (key in name) {
          if (hasOwn.call(name, key)) {
            URI2.removeQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === "string") {
        if (value2 !== void 0) {
          if (getType(value2) === "RegExp") {
            if (!isArray2(data[name]) && value2.test(data[name])) {
              data[name] = void 0;
            } else {
              data[name] = filterArrayValues(data[name], value2);
            }
          } else if (data[name] === String(value2) && (!isArray2(value2) || value2.length === 1)) {
            data[name] = void 0;
          } else if (isArray2(data[name])) {
            data[name] = filterArrayValues(data[name], value2);
          }
        } else {
          data[name] = void 0;
        }
      } else {
        throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
      }
    };
    URI2.hasQuery = function(data, name, value2, withinArray) {
      switch (getType(name)) {
        case "String":
          break;
        case "RegExp":
          for (var key in data) {
            if (hasOwn.call(data, key)) {
              if (name.test(key) && (value2 === void 0 || URI2.hasQuery(data, key, value2))) {
                return true;
              }
            }
          }
          return false;
        case "Object":
          for (var _key in name) {
            if (hasOwn.call(name, _key)) {
              if (!URI2.hasQuery(data, _key, name[_key])) {
                return false;
              }
            }
          }
          return true;
        default:
          throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
      }
      switch (getType(value2)) {
        case "Undefined":
          return name in data;
        case "Boolean":
          var _booly = Boolean(isArray2(data[name]) ? data[name].length : data[name]);
          return value2 === _booly;
        case "Function":
          return !!value2(data[name], name, data);
        case "Array":
          if (!isArray2(data[name])) {
            return false;
          }
          var op = withinArray ? arrayContains : arraysEqual;
          return op(data[name], value2);
        case "RegExp":
          if (!isArray2(data[name])) {
            return Boolean(data[name] && data[name].match(value2));
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value2);
        case "Number":
          value2 = String(value2);
        case "String":
          if (!isArray2(data[name])) {
            return data[name] === value2;
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value2);
        default:
          throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
      }
    };
    URI2.joinPaths = function() {
      var input = [];
      var segments = [];
      var nonEmptySegments = 0;
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var url = new URI2(arguments[i2]);
        input.push(url);
        var _segments = url.segment();
        for (var s = 0; s < _segments.length; s++) {
          if (typeof _segments[s] === "string") {
            segments.push(_segments[s]);
          }
          if (_segments[s]) {
            nonEmptySegments++;
          }
        }
      }
      if (!segments.length || !nonEmptySegments) {
        return new URI2("");
      }
      var uri2 = new URI2("").segment(segments);
      if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
        uri2.path("/" + uri2.path());
      }
      return uri2.normalize();
    };
    URI2.commonPath = function(one, two) {
      var length = Math.min(one.length, two.length);
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (one.charAt(pos) !== two.charAt(pos)) {
          pos--;
          break;
        }
      }
      if (pos < 1) {
        return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
      }
      if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
        pos = one.substring(0, pos).lastIndexOf("/");
      }
      return one.substring(0, pos + 1);
    };
    URI2.withinString = function(string, callback, options2) {
      options2 || (options2 = {});
      var _start = options2.start || URI2.findUri.start;
      var _end = options2.end || URI2.findUri.end;
      var _trim = options2.trim || URI2.findUri.trim;
      var _parens = options2.parens || URI2.findUri.parens;
      var _attributeOpen = /[a-z0-9-]=["']?$/i;
      _start.lastIndex = 0;
      while (true) {
        var match = _start.exec(string);
        if (!match) {
          break;
        }
        var start = match.index;
        if (options2.ignoreHtml) {
          var attributeOpen = string.slice(Math.max(start - 3, 0), start);
          if (attributeOpen && _attributeOpen.test(attributeOpen)) {
            continue;
          }
        }
        var end = start + string.slice(start).search(_end);
        var slice = string.slice(start, end);
        var parensEnd = -1;
        while (true) {
          var parensMatch = _parens.exec(slice);
          if (!parensMatch) {
            break;
          }
          var parensMatchEnd = parensMatch.index + parensMatch[0].length;
          parensEnd = Math.max(parensEnd, parensMatchEnd);
        }
        if (parensEnd > -1) {
          slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
        } else {
          slice = slice.replace(_trim, "");
        }
        if (slice.length <= match[0].length) {
          continue;
        }
        if (options2.ignore && options2.ignore.test(slice)) {
          continue;
        }
        end = start + slice.length;
        var result2 = callback(slice, start, end, string);
        if (result2 === void 0) {
          _start.lastIndex = end;
          continue;
        }
        result2 = String(result2);
        string = string.slice(0, start) + result2 + string.slice(end);
        _start.lastIndex = start + result2.length;
      }
      _start.lastIndex = 0;
      return string;
    };
    URI2.ensureValidHostname = function(v, protocol) {
      var hasHostname = !!v;
      var hasProtocol = !!protocol;
      var rejectEmptyHostname = false;
      if (hasProtocol) {
        rejectEmptyHostname = arrayContains(URI2.hostProtocols, protocol);
      }
      if (rejectEmptyHostname && !hasHostname) {
        throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
      } else if (v && v.match(URI2.invalid_hostname_characters)) {
        if (!punycode2) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
        }
        if (punycode2.toASCII(v).match(URI2.invalid_hostname_characters)) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
        }
      }
    };
    URI2.ensureValidPort = function(v) {
      if (!v) {
        return;
      }
      var port = Number(v);
      if (isInteger2(port) && port > 0 && port < 65536) {
        return;
      }
      throw new TypeError('Port "' + v + '" is not a valid port');
    };
    URI2.noConflict = function(removeAll) {
      if (removeAll) {
        var unconflicted = {
          URI: this.noConflict()
        };
        if (root2.URITemplate && typeof root2.URITemplate.noConflict === "function") {
          unconflicted.URITemplate = root2.URITemplate.noConflict();
        }
        if (root2.IPv6 && typeof root2.IPv6.noConflict === "function") {
          unconflicted.IPv6 = root2.IPv6.noConflict();
        }
        if (root2.SecondLevelDomains && typeof root2.SecondLevelDomains.noConflict === "function") {
          unconflicted.SecondLevelDomains = root2.SecondLevelDomains.noConflict();
        }
        return unconflicted;
      } else if (root2.URI === this) {
        root2.URI = _URI;
      }
      return this;
    };
    p2.build = function(deferBuild) {
      if (deferBuild === true) {
        this._deferred_build = true;
      } else if (deferBuild === void 0 || this._deferred_build) {
        this._string = URI2.build(this._parts);
        this._deferred_build = false;
      }
      return this;
    };
    p2.clone = function() {
      return new URI2(this);
    };
    p2.valueOf = p2.toString = function() {
      return this.build(false)._string;
    };
    function generateSimpleAccessor(_part2) {
      return function(v, build) {
        if (v === void 0) {
          return this._parts[_part2] || "";
        } else {
          this._parts[_part2] = v || null;
          this.build(!build);
          return this;
        }
      };
    }
    function generatePrefixAccessor(_part2, _key) {
      return function(v, build) {
        if (v === void 0) {
          return this._parts[_part2] || "";
        } else {
          if (v !== null) {
            v = v + "";
            if (v.charAt(0) === _key) {
              v = v.substring(1);
            }
          }
          this._parts[_part2] = v;
          this.build(!build);
          return this;
        }
      };
    }
    p2.protocol = generateSimpleAccessor("protocol");
    p2.username = generateSimpleAccessor("username");
    p2.password = generateSimpleAccessor("password");
    p2.hostname = generateSimpleAccessor("hostname");
    p2.port = generateSimpleAccessor("port");
    p2.query = generatePrefixAccessor("query", "?");
    p2.fragment = generatePrefixAccessor("fragment", "#");
    p2.search = function(v, build) {
      var t = this.query(v, build);
      return typeof t === "string" && t.length ? "?" + t : t;
    };
    p2.hash = function(v, build) {
      var t = this.fragment(v, build);
      return typeof t === "string" && t.length ? "#" + t : t;
    };
    p2.pathname = function(v, build) {
      if (v === void 0 || v === true) {
        var res2 = this._parts.path || (this._parts.hostname ? "/" : "");
        return v ? (this._parts.urn ? URI2.decodeUrnPath : URI2.decodePath)(res2) : res2;
      } else {
        if (this._parts.urn) {
          this._parts.path = v ? URI2.recodeUrnPath(v) : "";
        } else {
          this._parts.path = v ? URI2.recodePath(v) : "/";
        }
        this.build(!build);
        return this;
      }
    };
    p2.path = p2.pathname;
    p2.href = function(href, build) {
      var key;
      if (href === void 0) {
        return this.toString();
      }
      this._string = "";
      this._parts = URI2._parts();
      var _URI2 = href instanceof URI2;
      var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
      if (href.nodeName) {
        var attribute = URI2.getDomAttribute(href);
        href = href[attribute] || "";
        _object = false;
      }
      if (!_URI2 && _object && href.pathname !== void 0) {
        href = href.toString();
      }
      if (typeof href === "string" || href instanceof String) {
        this._parts = URI2.parse(String(href), this._parts);
      } else if (_URI2 || _object) {
        var src = _URI2 ? href._parts : href;
        for (key in src) {
          if (key === "query") {
            continue;
          }
          if (hasOwn.call(this._parts, key)) {
            this._parts[key] = src[key];
          }
        }
        if (src.query) {
          this.query(src.query, false);
        }
      } else {
        throw new TypeError("invalid input");
      }
      this.build(!build);
      return this;
    };
    p2.is = function(what) {
      var ip = false;
      var ip4 = false;
      var ip6 = false;
      var name = false;
      var sld = false;
      var idn = false;
      var punycode3 = false;
      var relative2 = !this._parts.urn;
      if (this._parts.hostname) {
        relative2 = false;
        ip4 = URI2.ip4_expression.test(this._parts.hostname);
        ip6 = URI2.ip6_expression.test(this._parts.hostname);
        ip = ip4 || ip6;
        name = !ip;
        sld = name && SLD && SLD.has(this._parts.hostname);
        idn = name && URI2.idn_expression.test(this._parts.hostname);
        punycode3 = name && URI2.punycode_expression.test(this._parts.hostname);
      }
      switch (what.toLowerCase()) {
        case "relative":
          return relative2;
        case "absolute":
          return !relative2;
        case "domain":
        case "name":
          return name;
        case "sld":
          return sld;
        case "ip":
          return ip;
        case "ip4":
        case "ipv4":
        case "inet4":
          return ip4;
        case "ip6":
        case "ipv6":
        case "inet6":
          return ip6;
        case "idn":
          return idn;
        case "url":
          return !this._parts.urn;
        case "urn":
          return !!this._parts.urn;
        case "punycode":
          return punycode3;
      }
      return null;
    };
    var _protocol = p2.protocol;
    var _port = p2.port;
    var _hostname = p2.hostname;
    p2.protocol = function(v, build) {
      if (v) {
        v = v.replace(/:(\/\/)?$/, "");
        if (!v.match(URI2.protocol_expression)) {
          throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
        }
      }
      return _protocol.call(this, v, build);
    };
    p2.scheme = p2.protocol;
    p2.port = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v !== void 0) {
        if (v === 0) {
          v = null;
        }
        if (v) {
          v += "";
          if (v.charAt(0) === ":") {
            v = v.substring(1);
          }
          URI2.ensureValidPort(v);
        }
      }
      return _port.call(this, v, build);
    };
    p2.hostname = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v !== void 0) {
        var x2 = { preventInvalidHostname: this._parts.preventInvalidHostname };
        var res2 = URI2.parseHost(v, x2);
        if (res2 !== "/") {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        v = x2.hostname;
        if (this._parts.preventInvalidHostname) {
          URI2.ensureValidHostname(v, this._parts.protocol);
        }
      }
      return _hostname.call(this, v, build);
    };
    p2.origin = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0) {
        var protocol = this.protocol();
        var authority = this.authority();
        if (!authority) {
          return "";
        }
        return (protocol ? protocol + "://" : "") + this.authority();
      } else {
        var origin = URI2(v);
        this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
        return this;
      }
    };
    p2.host = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0) {
        return this._parts.hostname ? URI2.buildHost(this._parts) : "";
      } else {
        var res2 = URI2.parseHost(v, this._parts);
        if (res2 !== "/") {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p2.authority = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0) {
        return this._parts.hostname ? URI2.buildAuthority(this._parts) : "";
      } else {
        var res2 = URI2.parseAuthority(v, this._parts);
        if (res2 !== "/") {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p2.userinfo = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0) {
        var t = URI2.buildUserinfo(this._parts);
        return t ? t.substring(0, t.length - 1) : t;
      } else {
        if (v[v.length - 1] !== "@") {
          v += "@";
        }
        URI2.parseUserinfo(v, this._parts);
        this.build(!build);
        return this;
      }
    };
    p2.resource = function(v, build) {
      var parts2;
      if (v === void 0) {
        return this.path() + this.search() + this.hash();
      }
      parts2 = URI2.parse(v);
      this._parts.path = parts2.path;
      this._parts.query = parts2.query;
      this._parts.fragment = parts2.fragment;
      this.build(!build);
      return this;
    };
    p2.subdomain = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0) {
        if (!this._parts.hostname || this.is("IP")) {
          return "";
        }
        var end = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, end) || "";
      } else {
        var e = this._parts.hostname.length - this.domain().length;
        var sub = this._parts.hostname.substring(0, e);
        var replace2 = new RegExp("^" + escapeRegEx2(sub));
        if (v && v.charAt(v.length - 1) !== ".") {
          v += ".";
        }
        if (v.indexOf(":") !== -1) {
          throw new TypeError("Domains cannot contain colons");
        }
        if (v) {
          URI2.ensureValidHostname(v, this._parts.protocol);
        }
        this._parts.hostname = this._parts.hostname.replace(replace2, v);
        this.build(!build);
        return this;
      }
    };
    p2.domain = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (typeof v === "boolean") {
        build = v;
        v = void 0;
      }
      if (v === void 0) {
        if (!this._parts.hostname || this.is("IP")) {
          return "";
        }
        var t = this._parts.hostname.match(/\./g);
        if (t && t.length < 2) {
          return this._parts.hostname;
        }
        var end = this._parts.hostname.length - this.tld(build).length - 1;
        end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
        return this._parts.hostname.substring(end) || "";
      } else {
        if (!v) {
          throw new TypeError("cannot set domain empty");
        }
        if (v.indexOf(":") !== -1) {
          throw new TypeError("Domains cannot contain colons");
        }
        URI2.ensureValidHostname(v, this._parts.protocol);
        if (!this._parts.hostname || this.is("IP")) {
          this._parts.hostname = v;
        } else {
          var replace2 = new RegExp(escapeRegEx2(this.domain()) + "$");
          this._parts.hostname = this._parts.hostname.replace(replace2, v);
        }
        this.build(!build);
        return this;
      }
    };
    p2.tld = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (typeof v === "boolean") {
        build = v;
        v = void 0;
      }
      if (v === void 0) {
        if (!this._parts.hostname || this.is("IP")) {
          return "";
        }
        var pos = this._parts.hostname.lastIndexOf(".");
        var tld = this._parts.hostname.substring(pos + 1);
        if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
          return SLD.get(this._parts.hostname) || tld;
        }
        return tld;
      } else {
        var replace2;
        if (!v) {
          throw new TypeError("cannot set TLD empty");
        } else if (v.match(/[^a-zA-Z0-9-]/)) {
          if (SLD && SLD.is(v)) {
            replace2 = new RegExp(escapeRegEx2(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace2, v);
          } else {
            throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
          }
        } else if (!this._parts.hostname || this.is("IP")) {
          throw new ReferenceError("cannot set TLD on non-domain host");
        } else {
          replace2 = new RegExp(escapeRegEx2(this.tld()) + "$");
          this._parts.hostname = this._parts.hostname.replace(replace2, v);
        }
        this.build(!build);
        return this;
      }
    };
    p2.directory = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0 || v === true) {
        if (!this._parts.path && !this._parts.hostname) {
          return "";
        }
        if (this._parts.path === "/") {
          return "/";
        }
        var end = this._parts.path.length - this.filename().length - 1;
        var res2 = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
        return v ? URI2.decodePath(res2) : res2;
      } else {
        var e = this._parts.path.length - this.filename().length;
        var directory = this._parts.path.substring(0, e);
        var replace2 = new RegExp("^" + escapeRegEx2(directory));
        if (!this.is("relative")) {
          if (!v) {
            v = "/";
          }
          if (v.charAt(0) !== "/") {
            v = "/" + v;
          }
        }
        if (v && v.charAt(v.length - 1) !== "/") {
          v += "/";
        }
        v = URI2.recodePath(v);
        this._parts.path = this._parts.path.replace(replace2, v);
        this.build(!build);
        return this;
      }
    };
    p2.filename = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (typeof v !== "string") {
        if (!this._parts.path || this._parts.path === "/") {
          return "";
        }
        var pos = this._parts.path.lastIndexOf("/");
        var res2 = this._parts.path.substring(pos + 1);
        return v ? URI2.decodePathSegment(res2) : res2;
      } else {
        var mutatedDirectory = false;
        if (v.charAt(0) === "/") {
          v = v.substring(1);
        }
        if (v.match(/\.?\//)) {
          mutatedDirectory = true;
        }
        var replace2 = new RegExp(escapeRegEx2(this.filename()) + "$");
        v = URI2.recodePath(v);
        this._parts.path = this._parts.path.replace(replace2, v);
        if (mutatedDirectory) {
          this.normalizePath(build);
        } else {
          this.build(!build);
        }
        return this;
      }
    };
    p2.suffix = function(v, build) {
      if (this._parts.urn) {
        return v === void 0 ? "" : this;
      }
      if (v === void 0 || v === true) {
        if (!this._parts.path || this._parts.path === "/") {
          return "";
        }
        var filename = this.filename();
        var pos = filename.lastIndexOf(".");
        var s, res2;
        if (pos === -1) {
          return "";
        }
        s = filename.substring(pos + 1);
        res2 = /^[a-z0-9%]+$/i.test(s) ? s : "";
        return v ? URI2.decodePathSegment(res2) : res2;
      } else {
        if (v.charAt(0) === ".") {
          v = v.substring(1);
        }
        var suffix = this.suffix();
        var replace2;
        if (!suffix) {
          if (!v) {
            return this;
          }
          this._parts.path += "." + URI2.recodePath(v);
        } else if (!v) {
          replace2 = new RegExp(escapeRegEx2("." + suffix) + "$");
        } else {
          replace2 = new RegExp(escapeRegEx2(suffix) + "$");
        }
        if (replace2) {
          v = URI2.recodePath(v);
          this._parts.path = this._parts.path.replace(replace2, v);
        }
        this.build(!build);
        return this;
      }
    };
    p2.segment = function(segment, v, build) {
      var separator = this._parts.urn ? ":" : "/";
      var path2 = this.path();
      var absolute = path2.substring(0, 1) === "/";
      var segments = path2.split(separator);
      if (segment !== void 0 && typeof segment !== "number") {
        build = v;
        v = segment;
        segment = void 0;
      }
      if (segment !== void 0 && typeof segment !== "number") {
        throw new Error('Bad segment "' + segment + '", must be 0-based integer');
      }
      if (absolute) {
        segments.shift();
      }
      if (segment < 0) {
        segment = Math.max(segments.length + segment, 0);
      }
      if (v === void 0) {
        return segment === void 0 ? segments : segments[segment];
      } else if (segment === null || segments[segment] === void 0) {
        if (isArray2(v)) {
          segments = [];
          for (var i2 = 0, l2 = v.length; i2 < l2; i2++) {
            if (!v[i2].length && (!segments.length || !segments[segments.length - 1].length)) {
              continue;
            }
            if (segments.length && !segments[segments.length - 1].length) {
              segments.pop();
            }
            segments.push(trimSlashes(v[i2]));
          }
        } else if (v || typeof v === "string") {
          v = trimSlashes(v);
          if (segments[segments.length - 1] === "") {
            segments[segments.length - 1] = v;
          } else {
            segments.push(v);
          }
        }
      } else {
        if (v) {
          segments[segment] = trimSlashes(v);
        } else {
          segments.splice(segment, 1);
        }
      }
      if (absolute) {
        segments.unshift("");
      }
      return this.path(segments.join(separator), build);
    };
    p2.segmentCoded = function(segment, v, build) {
      var segments, i2, l2;
      if (typeof segment !== "number") {
        build = v;
        v = segment;
        segment = void 0;
      }
      if (v === void 0) {
        segments = this.segment(segment, v, build);
        if (!isArray2(segments)) {
          segments = segments !== void 0 ? URI2.decode(segments) : void 0;
        } else {
          for (i2 = 0, l2 = segments.length; i2 < l2; i2++) {
            segments[i2] = URI2.decode(segments[i2]);
          }
        }
        return segments;
      }
      if (!isArray2(v)) {
        v = typeof v === "string" || v instanceof String ? URI2.encode(v) : v;
      } else {
        for (i2 = 0, l2 = v.length; i2 < l2; i2++) {
          v[i2] = URI2.encode(v[i2]);
        }
      }
      return this.segment(segment, v, build);
    };
    var q = p2.query;
    p2.query = function(v, build) {
      if (v === true) {
        return URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      } else if (typeof v === "function") {
        var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        var result2 = v.call(this, data);
        this._parts.query = URI2.buildQuery(result2 || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else if (v !== void 0 && typeof v !== "string") {
        this._parts.query = URI2.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else {
        return q.call(this, v, build);
      }
    };
    p2.setQuery = function(name, value2, build) {
      var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof name === "string" || name instanceof String) {
        data[name] = value2 !== void 0 ? value2 : null;
      } else if (typeof name === "object") {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            data[key] = name[key];
          }
        }
      } else {
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
      }
      this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== "string") {
        build = value2;
      }
      this.build(!build);
      return this;
    };
    p2.addQuery = function(name, value2, build) {
      var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI2.addQuery(data, name, value2 === void 0 ? null : value2);
      this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== "string") {
        build = value2;
      }
      this.build(!build);
      return this;
    };
    p2.removeQuery = function(name, value2, build) {
      var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI2.removeQuery(data, name, value2);
      this._parts.query = URI2.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== "string") {
        build = value2;
      }
      this.build(!build);
      return this;
    };
    p2.hasQuery = function(name, value2, withinArray) {
      var data = URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return URI2.hasQuery(data, name, value2, withinArray);
    };
    p2.setSearch = p2.setQuery;
    p2.addSearch = p2.addQuery;
    p2.removeSearch = p2.removeQuery;
    p2.hasSearch = p2.hasQuery;
    p2.normalize = function() {
      if (this._parts.urn) {
        return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      }
      return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    };
    p2.normalizeProtocol = function(build) {
      if (typeof this._parts.protocol === "string") {
        this._parts.protocol = this._parts.protocol.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p2.normalizeHostname = function(build) {
      if (this._parts.hostname) {
        if (this.is("IDN") && punycode2) {
          this._parts.hostname = punycode2.toASCII(this._parts.hostname);
        } else if (this.is("IPv6") && IPv62) {
          this._parts.hostname = IPv62.best(this._parts.hostname);
        }
        this._parts.hostname = this._parts.hostname.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p2.normalizePort = function(build) {
      if (typeof this._parts.protocol === "string" && this._parts.port === URI2.defaultPorts[this._parts.protocol]) {
        this._parts.port = null;
        this.build(!build);
      }
      return this;
    };
    p2.normalizePath = function(build) {
      var _path = this._parts.path;
      if (!_path) {
        return this;
      }
      if (this._parts.urn) {
        this._parts.path = URI2.recodeUrnPath(this._parts.path);
        this.build(!build);
        return this;
      }
      if (this._parts.path === "/") {
        return this;
      }
      _path = URI2.recodePath(_path);
      var _was_relative;
      var _leadingParents = "";
      var _parent, _pos;
      if (_path.charAt(0) !== "/") {
        _was_relative = true;
        _path = "/" + _path;
      }
      if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
        _path += "/";
      }
      _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
      if (_was_relative) {
        _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
        if (_leadingParents) {
          _leadingParents = _leadingParents[0];
        }
      }
      while (true) {
        _parent = _path.search(/\/\.\.(\/|$)/);
        if (_parent === -1) {
          break;
        } else if (_parent === 0) {
          _path = _path.substring(3);
          continue;
        }
        _pos = _path.substring(0, _parent).lastIndexOf("/");
        if (_pos === -1) {
          _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
      }
      if (_was_relative && this.is("relative")) {
        _path = _leadingParents + _path.substring(1);
      }
      this._parts.path = _path;
      this.build(!build);
      return this;
    };
    p2.normalizePathname = p2.normalizePath;
    p2.normalizeQuery = function(build) {
      if (typeof this._parts.query === "string") {
        if (!this._parts.query.length) {
          this._parts.query = null;
        } else {
          this.query(URI2.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
        }
        this.build(!build);
      }
      return this;
    };
    p2.normalizeFragment = function(build) {
      if (!this._parts.fragment) {
        this._parts.fragment = null;
        this.build(!build);
      }
      return this;
    };
    p2.normalizeSearch = p2.normalizeQuery;
    p2.normalizeHash = p2.normalizeFragment;
    p2.iso8859 = function() {
      var e = URI2.encode;
      var d = URI2.decode;
      URI2.encode = escape;
      URI2.decode = decodeURIComponent;
      try {
        this.normalize();
      } finally {
        URI2.encode = e;
        URI2.decode = d;
      }
      return this;
    };
    p2.unicode = function() {
      var e = URI2.encode;
      var d = URI2.decode;
      URI2.encode = strictEncodeURIComponent;
      URI2.decode = unescape;
      try {
        this.normalize();
      } finally {
        URI2.encode = e;
        URI2.decode = d;
      }
      return this;
    };
    p2.readable = function() {
      var uri2 = this.clone();
      uri2.username("").password("").normalize();
      var t = "";
      if (uri2._parts.protocol) {
        t += uri2._parts.protocol + "://";
      }
      if (uri2._parts.hostname) {
        if (uri2.is("punycode") && punycode2) {
          t += punycode2.toUnicode(uri2._parts.hostname);
          if (uri2._parts.port) {
            t += ":" + uri2._parts.port;
          }
        } else {
          t += uri2.host();
        }
      }
      if (uri2._parts.hostname && uri2._parts.path && uri2._parts.path.charAt(0) !== "/") {
        t += "/";
      }
      t += uri2.path(true);
      if (uri2._parts.query) {
        var q2 = "";
        for (var i2 = 0, qp = uri2._parts.query.split("&"), l2 = qp.length; i2 < l2; i2++) {
          var kv = (qp[i2] || "").split("=");
          q2 += "&" + URI2.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
          if (kv[1] !== void 0) {
            q2 += "=" + URI2.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
          }
        }
        t += "?" + q2.substring(1);
      }
      t += URI2.decodeQuery(uri2.hash(), true);
      return t;
    };
    p2.absoluteTo = function(base) {
      var resolved = this.clone();
      var properties = ["protocol", "username", "password", "hostname", "port"];
      var basedir, i2, p3;
      if (this._parts.urn) {
        throw new Error("URNs do not have any generally defined hierarchical components");
      }
      if (!(base instanceof URI2)) {
        base = new URI2(base);
      }
      if (resolved._parts.protocol) {
        return resolved;
      } else {
        resolved._parts.protocol = base._parts.protocol;
      }
      if (this._parts.hostname) {
        return resolved;
      }
      for (i2 = 0; p3 = properties[i2]; i2++) {
        resolved._parts[p3] = base._parts[p3];
      }
      if (!resolved._parts.path) {
        resolved._parts.path = base._parts.path;
        if (!resolved._parts.query) {
          resolved._parts.query = base._parts.query;
        }
      } else {
        if (resolved._parts.path.substring(-2) === "..") {
          resolved._parts.path += "/";
        }
        if (resolved.path().charAt(0) !== "/") {
          basedir = base.directory();
          basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
          resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
          resolved.normalizePath();
        }
      }
      resolved.build();
      return resolved;
    };
    p2.relativeTo = function(base) {
      var relative2 = this.clone().normalize();
      var relativeParts, baseParts, common2, relativePath, basePath;
      if (relative2._parts.urn) {
        throw new Error("URNs do not have any generally defined hierarchical components");
      }
      base = new URI2(base).normalize();
      relativeParts = relative2._parts;
      baseParts = base._parts;
      relativePath = relative2.path();
      basePath = base.path();
      if (relativePath.charAt(0) !== "/") {
        throw new Error("URI is already relative");
      }
      if (basePath.charAt(0) !== "/") {
        throw new Error("Cannot calculate a URI relative to another relative URI");
      }
      if (relativeParts.protocol === baseParts.protocol) {
        relativeParts.protocol = null;
      }
      if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
        return relative2.build();
      }
      if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
        return relative2.build();
      }
      if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
        relativeParts.hostname = null;
        relativeParts.port = null;
      } else {
        return relative2.build();
      }
      if (relativePath === basePath) {
        relativeParts.path = "";
        return relative2.build();
      }
      common2 = URI2.commonPath(relativePath, basePath);
      if (!common2) {
        return relative2.build();
      }
      var parents = baseParts.path.substring(common2.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
      relativeParts.path = parents + relativeParts.path.substring(common2.length) || "./";
      return relative2.build();
    };
    p2.equals = function(uri2) {
      var one = this.clone();
      var two = new URI2(uri2);
      var one_map = {};
      var two_map = {};
      var checked = {};
      var one_query, two_query, key;
      one.normalize();
      two.normalize();
      if (one.toString() === two.toString()) {
        return true;
      }
      one_query = one.query();
      two_query = two.query();
      one.query("");
      two.query("");
      if (one.toString() !== two.toString()) {
        return false;
      }
      if (one_query.length !== two_query.length) {
        return false;
      }
      one_map = URI2.parseQuery(one_query, this._parts.escapeQuerySpace);
      two_map = URI2.parseQuery(two_query, this._parts.escapeQuerySpace);
      for (key in one_map) {
        if (hasOwn.call(one_map, key)) {
          if (!isArray2(one_map[key])) {
            if (one_map[key] !== two_map[key]) {
              return false;
            }
          } else if (!arraysEqual(one_map[key], two_map[key])) {
            return false;
          }
          checked[key] = true;
        }
      }
      for (key in two_map) {
        if (hasOwn.call(two_map, key)) {
          if (!checked[key]) {
            return false;
          }
        }
      }
      return true;
    };
    p2.preventInvalidHostname = function(v) {
      this._parts.preventInvalidHostname = !!v;
      return this;
    };
    p2.duplicateQueryParameters = function(v) {
      this._parts.duplicateQueryParameters = !!v;
      return this;
    };
    p2.escapeQuerySpace = function(v) {
      this._parts.escapeQuerySpace = !!v;
      return this;
    };
    return URI2;
  });
})(URI);
var uri = URI.exports;
const changeGlobEagerImports = (code2, filePath, files) => {
  const foundMetaImports = findAllByCondition(code2, (node) => {
    if (tsmorph.Node.isCallExpression(node)) {
      const nodeText = node.getText();
      return nodeText.match(/\bimport\b.meta.globEager/g) != null;
    }
    return false;
  });
  if (foundMetaImports.length != 0) {
    foundMetaImports.forEach((node) => {
      const globUrl = getUrlFromNode(node.compilerNode);
      const relativePaths = getRelativePaths(globUrl, filePath, files);
      relativePaths.forEach((path2) => {
        code2.addImportDeclaration({
          defaultImport: stripUrlToBaseName(path2),
          moduleSpecifier: stripExtension(path2)
        });
      });
      const variableName = node.getParent().getName();
      const variableDeclaration = code2.getVariableDeclaration(variableName);
      const pathsObject = {};
      relativePaths.forEach((path2) => {
        pathsObject[JSON.stringify(path2)] = stripUrlToBaseName(path2);
      });
      variableDeclaration.setInitializer(tsmorph.Writers.object(pathsObject));
    });
  }
  return code2;
};
const getUrlFromNode = (globEagerNode) => {
  const globExpression = globEagerNode;
  const globUrl = globExpression.arguments[0].text;
  return globUrl;
};
const getRelativePaths = (globUrl, filePath, files) => {
  const searchedPaths = Object.keys(files);
  const matchedPaths = micromatch_1(searchedPaths, `**${stripUrl(globUrl)}`);
  const relativePaths = matchedPaths.map((path2) => {
    const uriPath = uri(path2).relativeTo(filePath)._string;
    const relativePath = uriPath.startsWith("..") ? uriPath : `./${uriPath}`;
    return relativePath;
  });
  return relativePaths;
};
const stripUrl = (url) => (url == null ? void 0 : url.startsWith(".")) || (url == null ? void 0 : url.startsWith("/")) && (url == null ? void 0 : url.charAt(1)) === "." ? stripUrl(url == null ? void 0 : url.substring(1)) : url;
const stripUrlToBaseName = (url) => url == null ? void 0 : url.split("/").reverse()[0].split(".")[0];
let babel;
let tsmorph;
let project;
const importBabel = async () => {
  try {
    babel = await import(
      //@ts-ignore
      "https://esm.sh/@babel/standalone"
    );
    babel == null ? void 0 : babel.registerPreset("iteriaPreset", {
      presets: [
        [babel.availablePresets.typescript],
        [babel.availablePresets.react],
        [
          babel.availablePresets.env,
          {
            targets: {
              esmodules: true
            },
            modules: false
          }
        ]
      ],
      plugins: [
        [babel.availablePlugins["transform-react-jsx-source"]],
        [reactRefreshPlugin, { skipEnvCheck: true, emitFullSignatures: true }]
      ]
    });
  } catch (err2) {
    return err2;
  }
};
const createProject = async () => {
  try {
    tsmorph = await import(
      //@ts-ignore
      "https://esm.sh/ts-morph"
    );
    project = new tsmorph.Project({ useInMemoryFileSystem: true });
  } catch (err2) {
    return err2;
  }
};
const transpileBabelStandalone = (code2, filename) => babel.transform(code2, { filename, presets: ["iteriaPreset"] });
const transpileFiles = async (files, env) => {
  if (!project)
    await createProject();
  if (!babel)
    await importBabel();
  const mappedFiles = {};
  for (const filePath in files) {
    if (filePath.startsWith("/node_modules/")) {
      mappedFiles[filePath] = files[filePath];
      continue;
    }
    if (JS_EXTENSIONS.some((e) => filePath.endsWith(e))) {
      try {
        const data = transpileBabelStandalone(files[filePath], filePath);
        if (data == null ? void 0 : data.code) {
          const sourceFile = project.createSourceFile(filePath, data.code, {
            overwrite: true
          });
          changeGlobEagerImports(sourceFile, filePath, files);
          injectEnvs(sourceFile, env);
          changeImports(sourceFile, filePath);
          const sourceFileCode = sourceFile.print();
          const finalCode = addCustomRefreshReg(sourceFileCode, filePath);
          mappedFiles[filePath] = finalCode;
        }
      } catch (err2) {
        console.error(err2);
        return { error: err2 };
      }
    } else if (filePath.endsWith(".json")) {
      mappedFiles[filePath] = "export default" + files[filePath];
    } else {
      mappedFiles[filePath] = files[filePath];
    }
  }
  return mappedFiles;
};
const transpileSingleFile = async (path2, code2, env, files) => {
  if (!project)
    await createProject();
  if (!babel)
    await importBabel();
  if (JS_EXTENSIONS.some((e) => path2.endsWith(e))) {
    try {
      const data = transpileBabelStandalone(code2, path2);
      const sourceFile = project.createSourceFile(path2, data.code, {
        overwrite: true
      });
      changeGlobEagerImports(sourceFile, path2, files);
      injectEnvs(sourceFile, env);
      changeImports(sourceFile, path2);
      const sourceFileCode = sourceFile.print();
      const finalCode = addCustomRefreshReg(sourceFileCode, path2);
      return finalCode;
    } catch (err2) {
      return { error: err2 };
    }
  } else if (path2.endsWith(".json")) {
    return "export default" + code2;
  } else {
    return code2;
  }
};
const addCustomRefreshReg = (code2, path2) => `
    function $RefreshReg$(c, id) {
      const path = "${path2}";
      window.$RefreshRegGlobal$(c, '.' +  path + ' ' + id);
    }
    ` + code2;
class BundleWorker {
  constructor(messagingService2) {
    __publicField2(this, "messagingService");
    this.messagingService = messagingService2;
    messagingService2.addEventListener(BUNDLE_FILES, async ({ files, bundleEntry }) => {
      const bundle = await this.bundleFiles(files, "/src/main");
      if (bundle)
        frontendActions.perfromReactRefresh(bundle);
    });
    messagingService2.addEventListener(TRANSPILE_FILES, async ({ files, env }) => {
      const transpiledFiles = await this.transpileFiles(files, env);
      if (transpiledFiles) {
        frontendActions.bundleFiles(transpiledFiles, "/src/main");
        frontendActions.updateTranspiledFiles(transpiledFiles);
      }
    });
    messagingService2.addEventListener(TRANSPILE_SINGLE_FILE, async ({ files, path: path2, data, env }) => {
      const transpiledFile = await this.transpileSingleFile(path2, data, env, files);
      if (transpiledFile) {
        const newFiles = __spreadProps2(__spreadValues2({}, files), { [path2]: transpiledFile });
        frontendActions.bundleFiles(newFiles);
        frontendActions.updateTranspiledFiles(newFiles);
      }
    });
    messagingService2.addEventListener(TRANSPILE_MULTIPLE_FILES, async ({ newFiles, env, files }) => {
      const transpiledFiles = await this.transpileFiles(__spreadValues2(__spreadValues2({}, files), newFiles), env);
      if (transpiledFiles) {
        frontendActions.bundleFiles(transpiledFiles, "/src/main");
        frontendActions.updateTranspiledFiles(transpiledFiles);
      }
    });
  }
  async bundleFiles(files, bundleEntry) {
    console.time("bundle");
    const data = await iteriaBundlerWorker.bundleFiles(files, bundleEntry);
    if (typeof data !== "string") {
      this.messagingService.postMessage(BUNDLER_ERROR, data);
      return null;
    }
    console.timeEnd("bundle");
    return data;
  }
  async transpileFiles(files, env) {
    const data = await transpileFiles(files, env);
    if ("error" in data) {
      this.messagingService.postMessage(TRANSPILER_ERROR, data);
      return null;
    }
    return data;
  }
  async transpileSingleFile(path2, data, env, files) {
    console.time("transpile");
    const transpiled = await transpileSingleFile(path2, data, env, files);
    if (typeof transpiled !== "string") {
      this.messagingService.postMessage(TRANSPILER_ERROR, transpiled);
      return null;
    }
    console.timeEnd("transpile");
    return transpiled;
  }
}
const getResourceHtmlElements = (htmlString, vercelString) => {
  const el2 = document.createElement("html");
  el2.innerHTML = htmlString;
  const linkTags = parseLocalLinkTags(el2, vercelString);
  const scriptTags = parseLocalScriptTags(el2, vercelString);
  return [...linkTags, ...scriptTags];
};
const parseLocalLinkTags = (el2, cdnString) => {
  const linkTags = [...el2.getElementsByTagName("link")].filter((lt) => {
    const attribute = lt.getAttribute("href");
    if (attribute)
      return !attribute.startsWith("http");
    else
      return false;
  }).map((lt) => {
    lt.href = cdnString + lt.getAttribute("href");
    return lt;
  });
  return linkTags;
};
const parseLocalScriptTags = (el2, cdnString) => {
  const scriptTags = [...el2.getElementsByTagName("script")].filter((st) => {
    const attribute = st.getAttribute("src");
    if (attribute)
      return !attribute.startsWith("http");
    else
      return true;
  }).map((st) => {
    if (st.getAttribute("src"))
      st.src = cdnString + st.getAttribute("src");
    return st;
  });
  return scriptTags;
};
const windowHasProperty = async (window2, property2) => {
  while (!window2[property2]) {
    await delay(5);
  }
};
class ReactInstrumentation {
  constructor(messagingService2) {
    __publicField2(this, "resourceHtmlElements");
    window.$RefreshSig$ = () => (type2) => type2;
    window.$RefreshRegGlobal$ = window.reactRefresh.register;
    this.resourceHtmlElements = [];
    this.appendCustomRequires();
    messagingService2.addEventListener(PERFORM_REACT_REFRESH, async ({ bundle }) => {
      const s = document.createElement("script");
      s.text = bundle;
      await windowHasProperty(window, "__deps");
      document.body.appendChild(s);
      window.reactRefresh.performReactRefresh();
    });
  }
  appendCustomRequires() {
    window.requireDefault = (dependency) => {
      const depParts = dependency.split("/");
      let pointerDeps = window.__deps;
      let pointerDepsDefault = window.__deps_default;
      depParts.forEach((dp) => {
        if (pointerDeps)
          pointerDeps = pointerDeps[dp];
        if (pointerDepsDefault)
          pointerDepsDefault = pointerDepsDefault[dp];
      });
      return pointerDepsDefault != null ? pointerDepsDefault : pointerDeps;
    };
    window.require = (dependency) => {
      const depParts = dependency.split("/");
      let pointerDeps = window.__deps;
      depParts.forEach((dp) => {
        if (pointerDeps)
          pointerDeps = pointerDeps[dp];
      });
      return pointerDeps;
    };
  }
  async setResourceHtmlElements(vercelUrl) {
    try {
      const res2 = await fetch(vercelUrl);
      const data = await res2.text();
      this.resourceHtmlElements = getResourceHtmlElements(data, vercelUrl);
      this.appendCustomRequires();
      window.__skip_render = true;
      this.getCdnBundle();
    } catch (err2) {
      throw new Error(err2);
    }
  }
  async getCdnBundle() {
    try {
      this.resourceHtmlElements.forEach((re) => {
        if (re instanceof HTMLLinkElement) {
          console.log("link", re);
          document.head.appendChild(re);
        } else if (re instanceof HTMLScriptElement) {
          const url = re.getAttribute("src");
          console.log("script", re);
          if (!url)
            return (0, eval)(re.innerText);
          fetch(url).then((res2) => res2.text()).then((data) => (0, eval)(data));
        }
      });
    } catch (err2) {
      throw new Error(err2);
    }
  }
}
const messagingService = new WindowMessaging(window);
new BundleWorker(messagingService);
const workbench = new DevWorkbench(messagingService);
const reactInstrumentation = new ReactInstrumentation(messagingService);
const frontendActions = new FrontendActions(messagingService);
const devServer = async (props) => {
  var _a2, _b, _c;
  const injectMode = (_a2 = props.injectMode) != null ? _a2 : "jamstack";
  workbench.setInjectionMode(injectMode);
  workbench.setMode(props.mode);
  workbench.setCommand(props.command);
  workbench.setEnv(props.env);
  if (props.fsPort)
    workbench.setPort(props.fsPort);
  if (props.graphQLEndpoint)
    workbench.setGraphQLEndpoint(props.graphQLEndpoint, (_b = props.graphQLSecret) != null ? _b : "");
  if (props.cwd)
    workbench.setCwd(props.cwd);
  if (injectMode === "jamstack") {
    addFrontendListeners(messagingService, injectMode, props == null ? void 0 : props.features);
    frontendActions.getProjectFromArchive((_c = props == null ? void 0 : props.deploymentUrl) != null ? _c : window.location.origin);
    initializeWysiwyg();
  } else {
    initializeWysiwyg();
    addFrontendListeners(messagingService, injectMode);
    addElementHighlight(window, injectMode, props == null ? void 0 : props.features);
  }
};
var index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messagingService,
  workbench,
  reactInstrumentation,
  frontendActions,
  devServer
}, Symbol.toStringTag, { value: "Module" }));
export { isRequiredInputField as $, GraphQLSchema as A, objectValues$1 as B, GraphQLDirective as C, isScalarType as D, isInterfaceType as E, GraphQLInterfaceType as F, GraphQLObjectType as G, isUnionType as H, GraphQLUnionType as I, GraphQLEnumType as J, Kind as K, GraphQLInputObjectType as L, isListType as M, GraphQLList as N, isNonNullType as O, GraphQLNonNull as P, isSource as Q, Source as R, SYMBOL_ASYNC_ITERATOR as S, TypeInfo as T, Lexer as U, TokenKind as V, isPunctuatorTokenKind as W, dedentBlockStringValue$1 as X, getBlockStringIndentation$1 as Y, isRequiredArgument as Z, isSpecifiedScalarType as _, printIntrospectionSchema as a, assertValidSchema as a$, print as a0, isNamedType as a1, astFromValue as a2, keyMap as a3, version as a4, versionInfo as a5, GraphQLScalarType as a6, specifiedScalarTypes as a7, GraphQLInt as a8, GraphQLFloat as a9, isOutputType as aA, isLeafType as aB, isCompositeType as aC, isAbstractType as aD, isWrappingType as aE, isNullableType as aF, isSpecifiedDirective as aG, assertSchema as aH, assertDirective as aI, assertType as aJ, assertScalarType as aK, assertObjectType as aL, assertInterfaceType as aM, assertUnionType as aN, assertEnumType as aO, assertInputObjectType as aP, assertListType as aQ, assertNonNullType as aR, assertInputType as aS, assertOutputType as aT, assertLeafType as aU, assertCompositeType as aV, assertAbstractType as aW, assertWrappingType as aX, assertNullableType as aY, assertNamedType as aZ, getNullableType as a_, GraphQLString as aa, GraphQLBoolean as ab, GraphQLID as ac, specifiedDirectives as ad, GraphQLIncludeDirective as ae, GraphQLSkipDirective as af, GraphQLDeprecatedDirective as ag, GraphQLSpecifiedByDirective as ah, TypeKind as ai, DEFAULT_DEPRECATION_REASON as aj, introspectionTypes as ak, __Schema as al, __Directive as am, __DirectiveLocation as an, __Type as ao, __Field as ap, __InputValue as aq, __EnumValue as ar, __TypeKind as as, SchemaMetaFieldDef as at, TypeMetaFieldDef as au, TypeNameMetaFieldDef as av, isSchema as aw, isDirective as ax, isType as ay, isInputType as az, buildASTSchema as b, printType as b$, Token as b0, Location as b1, getLocation as b2, printLocation as b3, printSourceLocation as b4, parseValue as b5, parseType as b6, visitInParallel as b7, getVisitFn as b8, BREAK as b9, PossibleFragmentSpreadsRule as bA, ProvidedRequiredArgumentsRule as bB, ScalarLeafsRule as bC, SingleFieldSubscriptionsRule as bD, UniqueArgumentNamesRule as bE, UniqueDirectivesPerLocationRule as bF, UniqueFragmentNamesRule as bG, UniqueInputFieldNamesRule as bH, UniqueOperationNamesRule as bI, UniqueVariableNamesRule as bJ, ValuesOfCorrectTypeRule as bK, VariablesAreInputTypesRule as bL, VariablesInAllowedPositionRule as bM, LoneSchemaDefinitionRule as bN, UniqueOperationTypesRule as bO, UniqueTypeNamesRule as bP, UniqueEnumValueNamesRule as bQ, UniqueFieldDefinitionNamesRule as bR, UniqueDirectiveNamesRule as bS, PossibleTypeExtensionsRule as bT, syntaxError$1 as bU, printError as bV, getIntrospectionQuery as bW, buildClientSchema as bX, buildSchema as bY, getDescription as bZ, printSchema as b_, DirectiveLocation as ba, isDefinitionNode as bb, isExecutableDefinitionNode as bc, isSelectionNode as bd, isValueNode as be, isTypeNode as bf, isTypeSystemDefinitionNode as bg, isTypeDefinitionNode as bh, isTypeSystemExtensionNode as bi, isTypeExtensionNode as bj, getDirectiveValues as bk, ValidationContext as bl, specifiedRules as bm, ExecutableDefinitionsRule as bn, FieldsOnCorrectTypeRule as bo, FragmentsOnCompositeTypesRule as bp, KnownArgumentNamesRule as bq, KnownDirectivesRule as br, KnownFragmentNamesRule as bs, KnownTypeNamesRule as bt, LoneAnonymousOperationRule as bu, NoFragmentCyclesRule as bv, NoUndefinedVariablesRule as bw, NoUnusedFragmentsRule as bx, NoUnusedVariablesRule as by, OverlappingFieldsCanBeMergedRule as bz, isObjectType as c, typeFromAST as c0, valueFromAST as c1, valueFromASTUntyped as c2, coerceInputValue as c3, concatAST as c4, isEqualType as c5, isTypeSubTypeOf as c6, doTypesOverlap as c7, assertValidName as c8, isValidNameError as c9, commonjsGlobal as ca, pathBrowserify as cb, getAugmentedNamespace as cc, printSchemaWithDirectives as cd, pascalCase as ce, getBaseType as cf, getRootTypes as cg, DetailedError as ch, removeNonNullWrapper as ci, resolveExternalModuleAndFn as cj, isObjectLike$8 as ck, getVariableValues as cl, safeArrayFrom as cm, index as cn, getNamedType as d, extendSchema as e, visitWithTypeInfo as f, getCachedDocumentNodeFromSchema as g, isIntrospectionType as h, isEnumType as i, validateSchema as j, validate as k, getArgumentValues as l, locatedError as m, pathToArray as n, oldVisit as o, parse$6 as p, inspect$1 as q, removeFederation as r, GraphQLError as s, addPath as t, invariant as u, visit as v, isInputObjectType as w, devAssert as x, keyValMap as y, naturalCompare as z };
